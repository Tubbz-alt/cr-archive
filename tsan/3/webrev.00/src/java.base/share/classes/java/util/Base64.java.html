<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/Base64.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.FilterOutputStream;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.nio.ByteBuffer;
  33 import java.nio.charset.StandardCharsets;
  34 
  35 import sun.nio.cs.ISO_8859_1;
  36 
  37 import jdk.internal.HotSpotIntrinsicCandidate;
  38 
  39 /**
  40  * This class consists exclusively of static methods for obtaining
  41  * encoders and decoders for the Base64 encoding scheme. The
  42  * implementation of this class supports the following types of Base64
  43  * as specified in
  44  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4648.txt&quot;&gt;RFC 4648&lt;/a&gt; and
  45  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;.
  46  *
  47  * &lt;ul&gt;
  48  * &lt;li&gt;&lt;a id=&quot;basic&quot;&gt;&lt;b&gt;Basic&lt;/b&gt;&lt;/a&gt;
  49  * &lt;p&gt; Uses &quot;The Base64 Alphabet&quot; as specified in Table 1 of
  50  *     RFC 4648 and RFC 2045 for encoding and decoding operation.
  51  *     The encoder does not add any line feed (line separator)
  52  *     character. The decoder rejects data that contains characters
  53  *     outside the base64 alphabet.&lt;/p&gt;&lt;/li&gt;
  54  *
  55  * &lt;li&gt;&lt;a id=&quot;url&quot;&gt;&lt;b&gt;URL and Filename safe&lt;/b&gt;&lt;/a&gt;
  56  * &lt;p&gt; Uses the &quot;URL and Filename safe Base64 Alphabet&quot; as specified
  57  *     in Table 2 of RFC 4648 for encoding and decoding. The
  58  *     encoder does not add any line feed (line separator) character.
  59  *     The decoder rejects data that contains characters outside the
  60  *     base64 alphabet.&lt;/p&gt;&lt;/li&gt;
  61  *
  62  * &lt;li&gt;&lt;a id=&quot;mime&quot;&gt;&lt;b&gt;MIME&lt;/b&gt;&lt;/a&gt;
  63  * &lt;p&gt; Uses &quot;The Base64 Alphabet&quot; as specified in Table 1 of
  64  *     RFC 2045 for encoding and decoding operation. The encoded output
  65  *     must be represented in lines of no more than 76 characters each
  66  *     and uses a carriage return {@code &#39;\r&#39;} followed immediately by
  67  *     a linefeed {@code &#39;\n&#39;} as the line separator. No line separator
  68  *     is added to the end of the encoded output. All line separators
  69  *     or other characters not found in the base64 alphabet table are
  70  *     ignored in decoding operation.&lt;/p&gt;&lt;/li&gt;
  71  * &lt;/ul&gt;
  72  *
  73  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a
  74  * method of this class will cause a {@link java.lang.NullPointerException
  75  * NullPointerException} to be thrown.
  76  *
  77  * @author  Xueming Shen
  78  * @since   1.8
  79  */
  80 
  81 public class Base64 {
  82 
  83     private Base64() {}
  84 
  85     /**
  86      * Returns a {@link Encoder} that encodes using the
  87      * &lt;a href=&quot;#basic&quot;&gt;Basic&lt;/a&gt; type base64 encoding scheme.
  88      *
  89      * @return  A Base64 encoder.
  90      */
  91     public static Encoder getEncoder() {
  92          return Encoder.RFC4648;
  93     }
  94 
  95     /**
  96      * Returns a {@link Encoder} that encodes using the
  97      * &lt;a href=&quot;#url&quot;&gt;URL and Filename safe&lt;/a&gt; type base64
  98      * encoding scheme.
  99      *
 100      * @return  A Base64 encoder.
 101      */
 102     public static Encoder getUrlEncoder() {
 103          return Encoder.RFC4648_URLSAFE;
 104     }
 105 
 106     /**
 107      * Returns a {@link Encoder} that encodes using the
 108      * &lt;a href=&quot;#mime&quot;&gt;MIME&lt;/a&gt; type base64 encoding scheme.
 109      *
 110      * @return  A Base64 encoder.
 111      */
 112     public static Encoder getMimeEncoder() {
 113         return Encoder.RFC2045;
 114     }
 115 
 116     /**
 117      * Returns a {@link Encoder} that encodes using the
 118      * &lt;a href=&quot;#mime&quot;&gt;MIME&lt;/a&gt; type base64 encoding scheme
 119      * with specified line length and line separators.
 120      *
 121      * @param   lineLength
 122      *          the length of each output line (rounded down to nearest multiple
 123      *          of 4). If the rounded down line length is not a positive value,
 124      *          the output will not be separated in lines
 125      * @param   lineSeparator
 126      *          the line separator for each output line
 127      *
 128      * @return  A Base64 encoder.
 129      *
 130      * @throws  IllegalArgumentException if {@code lineSeparator} includes any
 131      *          character of &quot;The Base64 Alphabet&quot; as specified in Table 1 of
 132      *          RFC 2045.
 133      */
 134     public static Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) {
 135          Objects.requireNonNull(lineSeparator);
 136          int[] base64 = Decoder.fromBase64;
 137          for (byte b : lineSeparator) {
 138              if (base64[b &amp; 0xff] != -1)
 139                  throw new IllegalArgumentException(
 140                      &quot;Illegal base64 line separator character 0x&quot; + Integer.toString(b, 16));
 141          }
 142          // round down to nearest multiple of 4
 143          lineLength &amp;= ~0b11;
 144          if (lineLength &lt;= 0) {
 145              return Encoder.RFC4648;
 146          }
 147          return new Encoder(false, lineSeparator, lineLength, true);
 148     }
 149 
 150     /**
 151      * Returns a {@link Decoder} that decodes using the
 152      * &lt;a href=&quot;#basic&quot;&gt;Basic&lt;/a&gt; type base64 encoding scheme.
 153      *
 154      * @return  A Base64 decoder.
 155      */
 156     public static Decoder getDecoder() {
 157          return Decoder.RFC4648;
 158     }
 159 
 160     /**
 161      * Returns a {@link Decoder} that decodes using the
 162      * &lt;a href=&quot;#url&quot;&gt;URL and Filename safe&lt;/a&gt; type base64
 163      * encoding scheme.
 164      *
 165      * @return  A Base64 decoder.
 166      */
 167     public static Decoder getUrlDecoder() {
 168          return Decoder.RFC4648_URLSAFE;
 169     }
 170 
 171     /**
 172      * Returns a {@link Decoder} that decodes using the
 173      * &lt;a href=&quot;#mime&quot;&gt;MIME&lt;/a&gt; type base64 decoding scheme.
 174      *
 175      * @return  A Base64 decoder.
 176      */
 177     public static Decoder getMimeDecoder() {
 178          return Decoder.RFC2045;
 179     }
 180 
 181     /**
 182      * This class implements an encoder for encoding byte data using
 183      * the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
 184      *
 185      * &lt;p&gt; Instances of {@link Encoder} class are safe for use by
 186      * multiple concurrent threads.
 187      *
 188      * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to
 189      * a method of this class will cause a
 190      * {@link java.lang.NullPointerException NullPointerException} to
 191      * be thrown.
 192      * &lt;p&gt; If the encoded byte output of the needed size can not
 193      *     be allocated, the encode methods of this class will
 194      *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
 195      *     to be thrown.
 196      *
 197      * @see     Decoder
 198      * @since   1.8
 199      */
 200     public static class Encoder {
 201 
 202         private final byte[] newline;
 203         private final int linemax;
 204         private final boolean isURL;
 205         private final boolean doPadding;
 206 
 207         private Encoder(boolean isURL, byte[] newline, int linemax, boolean doPadding) {
 208             this.isURL = isURL;
 209             this.newline = newline;
 210             this.linemax = linemax;
 211             this.doPadding = doPadding;
 212         }
 213 
 214         /**
 215          * This array is a lookup table that translates 6-bit positive integer
 216          * index values into their &quot;Base64 Alphabet&quot; equivalents as specified
 217          * in &quot;Table 1: The Base64 Alphabet&quot; of RFC 2045 (and RFC 4648).
 218          */
 219         private static final char[] toBase64 = {
 220             &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
 221             &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
 222             &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
 223             &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
 224             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;
 225         };
 226 
 227         /**
 228          * It&#39;s the lookup table for &quot;URL and Filename safe Base64&quot; as specified
 229          * in Table 2 of the RFC 4648, with the &#39;+&#39; and &#39;/&#39; changed to &#39;-&#39; and
 230          * &#39;_&#39;. This table is used when BASE64_URL is specified.
 231          */
 232         private static final char[] toBase64URL = {
 233             &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
 234             &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
 235             &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
 236             &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
 237             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;_&#39;
 238         };
 239 
 240         private static final int MIMELINEMAX = 76;
 241         private static final byte[] CRLF = new byte[] {&#39;\r&#39;, &#39;\n&#39;};
 242 
 243         static final Encoder RFC4648 = new Encoder(false, null, -1, true);
 244         static final Encoder RFC4648_URLSAFE = new Encoder(true, null, -1, true);
 245         static final Encoder RFC2045 = new Encoder(false, CRLF, MIMELINEMAX, true);
 246 
 247         /**
 248          * Calculates the length of the encoded output bytes.
 249          *
 250          * @param srclen length of the bytes to encode
 251          * @param throwOOME if true, throws OutOfMemoryError if the length of
 252          *                  the encoded bytes overflows; else returns the
 253          *                  length
 254          * @return length of the encoded bytes, or -1 if the length overflows
 255          *
 256          */
 257         private final int encodedOutLength(int srclen, boolean throwOOME) {
 258             int len = 0;
 259             try {
 260                 if (doPadding) {
 261                     len = Math.multiplyExact(4, (Math.addExact(srclen, 2) / 3));
 262                 } else {
 263                     int n = srclen % 3;
 264                     len = Math.addExact(Math.multiplyExact(4, (srclen / 3)), (n == 0 ? 0 : n + 1));
 265                 }
 266                 if (linemax &gt; 0) {                             // line separators
 267                     len = Math.addExact(len, (len - 1) / linemax * newline.length);
 268                 }
 269             } catch (ArithmeticException ex) {
 270                 if (throwOOME) {
 271                     throw new OutOfMemoryError(&quot;Encoded size is too large&quot;);
 272                 } else {
 273                     // let the caller know that encoded bytes length
 274                     // is too large
 275                     len = -1;
 276                 }
 277             }
 278             return len;
 279         }
 280 
 281         /**
 282          * Encodes all bytes from the specified byte array into a newly-allocated
 283          * byte array using the {@link Base64} encoding scheme. The returned byte
 284          * array is of the length of the resulting bytes.
 285          *
 286          * @param   src
 287          *          the byte array to encode
 288          * @return  A newly-allocated byte array containing the resulting
 289          *          encoded bytes.
 290          */
 291         public byte[] encode(byte[] src) {
 292             int len = encodedOutLength(src.length, true);          // dst array size
 293             byte[] dst = new byte[len];
 294             int ret = encode0(src, 0, src.length, dst);
 295             if (ret != dst.length)
 296                  return Arrays.copyOf(dst, ret);
 297             return dst;
 298         }
 299 
 300         /**
 301          * Encodes all bytes from the specified byte array using the
 302          * {@link Base64} encoding scheme, writing the resulting bytes to the
 303          * given output byte array, starting at offset 0.
 304          *
 305          * &lt;p&gt; It is the responsibility of the invoker of this method to make
 306          * sure the output byte array {@code dst} has enough space for encoding
 307          * all bytes from the input byte array. No bytes will be written to the
 308          * output byte array if the output byte array is not big enough.
 309          *
 310          * @param   src
 311          *          the byte array to encode
 312          * @param   dst
 313          *          the output byte array
 314          * @return  The number of bytes written to the output byte array
 315          *
 316          * @throws  IllegalArgumentException if {@code dst} does not have enough
 317          *          space for encoding all input bytes.
 318          */
 319         public int encode(byte[] src, byte[] dst) {
 320             int len = encodedOutLength(src.length, false);         // dst array size
 321             if (dst.length &lt; len || len == -1)
 322                 throw new IllegalArgumentException(
 323                     &quot;Output byte array is too small for encoding all input bytes&quot;);
 324             return encode0(src, 0, src.length, dst);
 325         }
 326 
 327         /**
 328          * Encodes the specified byte array into a String using the {@link Base64}
 329          * encoding scheme.
 330          *
 331          * &lt;p&gt; This method first encodes all input bytes into a base64 encoded
 332          * byte array and then constructs a new String by using the encoded byte
 333          * array and the {@link java.nio.charset.StandardCharsets#ISO_8859_1
 334          * ISO-8859-1} charset.
 335          *
 336          * &lt;p&gt; In other words, an invocation of this method has exactly the same
 337          * effect as invoking
 338          * {@code new String(encode(src), StandardCharsets.ISO_8859_1)}.
 339          *
 340          * @param   src
 341          *          the byte array to encode
 342          * @return  A String containing the resulting Base64 encoded characters
 343          */
 344         @SuppressWarnings(&quot;deprecation&quot;)
 345         public String encodeToString(byte[] src) {
 346             byte[] encoded = encode(src);
 347             return new String(encoded, 0, 0, encoded.length);
 348         }
 349 
 350         /**
 351          * Encodes all remaining bytes from the specified byte buffer into
 352          * a newly-allocated ByteBuffer using the {@link Base64} encoding
 353          * scheme.
 354          *
 355          * Upon return, the source buffer&#39;s position will be updated to
 356          * its limit; its limit will not have been changed. The returned
 357          * output buffer&#39;s position will be zero and its limit will be the
 358          * number of resulting encoded bytes.
 359          *
 360          * @param   buffer
 361          *          the source ByteBuffer to encode
 362          * @return  A newly-allocated byte buffer containing the encoded bytes.
 363          */
 364         public ByteBuffer encode(ByteBuffer buffer) {
 365             int len = encodedOutLength(buffer.remaining(), true);
 366             byte[] dst = new byte[len];
 367             int ret = 0;
 368             if (buffer.hasArray()) {
 369                 ret = encode0(buffer.array(),
 370                               buffer.arrayOffset() + buffer.position(),
 371                               buffer.arrayOffset() + buffer.limit(),
 372                               dst);
 373                 buffer.position(buffer.limit());
 374             } else {
 375                 byte[] src = new byte[buffer.remaining()];
 376                 buffer.get(src);
 377                 ret = encode0(src, 0, src.length, dst);
 378             }
 379             if (ret != dst.length)
 380                  dst = Arrays.copyOf(dst, ret);
 381             return ByteBuffer.wrap(dst);
 382         }
 383 
 384         /**
 385          * Wraps an output stream for encoding byte data using the {@link Base64}
 386          * encoding scheme.
 387          *
 388          * &lt;p&gt; It is recommended to promptly close the returned output stream after
 389          * use, during which it will flush all possible leftover bytes to the underlying
 390          * output stream. Closing the returned output stream will close the underlying
 391          * output stream.
 392          *
 393          * @param   os
 394          *          the output stream.
 395          * @return  the output stream for encoding the byte data into the
 396          *          specified Base64 encoded format
 397          */
 398         public OutputStream wrap(OutputStream os) {
 399             Objects.requireNonNull(os);
 400             return new EncOutputStream(os, isURL ? toBase64URL : toBase64,
 401                                        newline, linemax, doPadding);
 402         }
 403 
 404         /**
 405          * Returns an encoder instance that encodes equivalently to this one,
 406          * but without adding any padding character at the end of the encoded
 407          * byte data.
 408          *
 409          * &lt;p&gt; The encoding scheme of this encoder instance is unaffected by
 410          * this invocation. The returned encoder instance should be used for
 411          * non-padding encoding operation.
 412          *
 413          * @return an equivalent encoder that encodes without adding any
 414          *         padding character at the end
 415          */
 416         public Encoder withoutPadding() {
 417             if (!doPadding)
 418                 return this;
 419             return new Encoder(isURL, newline, linemax, false);
 420         }
 421 
 422         @HotSpotIntrinsicCandidate
 423         private void encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {
 424             char[] base64 = isURL ? toBase64URL : toBase64;
 425             for (int sp0 = sp, dp0 = dp ; sp0 &lt; sl; ) {
 426                 int bits = (src[sp0++] &amp; 0xff) &lt;&lt; 16 |
 427                            (src[sp0++] &amp; 0xff) &lt;&lt;  8 |
 428                            (src[sp0++] &amp; 0xff);
 429                 dst[dp0++] = (byte)base64[(bits &gt;&gt;&gt; 18) &amp; 0x3f];
 430                 dst[dp0++] = (byte)base64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];
 431                 dst[dp0++] = (byte)base64[(bits &gt;&gt;&gt; 6)  &amp; 0x3f];
 432                 dst[dp0++] = (byte)base64[bits &amp; 0x3f];
 433             }
 434         }
 435 
 436         private int encode0(byte[] src, int off, int end, byte[] dst) {
 437             char[] base64 = isURL ? toBase64URL : toBase64;
 438             int sp = off;
 439             int slen = (end - off) / 3 * 3;
 440             int sl = off + slen;
 441             if (linemax &gt; 0 &amp;&amp; slen  &gt; linemax / 4 * 3)
 442                 slen = linemax / 4 * 3;
 443             int dp = 0;
 444             while (sp &lt; sl) {
 445                 int sl0 = Math.min(sp + slen, sl);
 446                 encodeBlock(src, sp, sl0, dst, dp, isURL);
 447                 int dlen = (sl0 - sp) / 3 * 4;
 448                 dp += dlen;
 449                 sp = sl0;
 450                 if (dlen == linemax &amp;&amp; sp &lt; end) {
 451                     for (byte b : newline){
 452                         dst[dp++] = b;
 453                     }
 454                 }
 455             }
 456             if (sp &lt; end) {               // 1 or 2 leftover bytes
 457                 int b0 = src[sp++] &amp; 0xff;
 458                 dst[dp++] = (byte)base64[b0 &gt;&gt; 2];
 459                 if (sp == end) {
 460                     dst[dp++] = (byte)base64[(b0 &lt;&lt; 4) &amp; 0x3f];
 461                     if (doPadding) {
 462                         dst[dp++] = &#39;=&#39;;
 463                         dst[dp++] = &#39;=&#39;;
 464                     }
 465                 } else {
 466                     int b1 = src[sp++] &amp; 0xff;
 467                     dst[dp++] = (byte)base64[(b0 &lt;&lt; 4) &amp; 0x3f | (b1 &gt;&gt; 4)];
 468                     dst[dp++] = (byte)base64[(b1 &lt;&lt; 2) &amp; 0x3f];
 469                     if (doPadding) {
 470                         dst[dp++] = &#39;=&#39;;
 471                     }
 472                 }
 473             }
 474             return dp;
 475         }
 476     }
 477 
 478     /**
 479      * This class implements a decoder for decoding byte data using the
 480      * Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
 481      *
 482      * &lt;p&gt; The Base64 padding character {@code &#39;=&#39;} is accepted and
 483      * interpreted as the end of the encoded byte data, but is not
 484      * required. So if the final unit of the encoded byte data only has
 485      * two or three Base64 characters (without the corresponding padding
 486      * character(s) padded), they are decoded as if followed by padding
 487      * character(s). If there is a padding character present in the
 488      * final unit, the correct number of padding character(s) must be
 489      * present, otherwise {@code IllegalArgumentException} (
 490      * {@code IOException} when reading from a Base64 stream) is thrown
 491      * during decoding.
 492      *
 493      * &lt;p&gt; Instances of {@link Decoder} class are safe for use by
 494      * multiple concurrent threads.
 495      *
 496      * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to
 497      * a method of this class will cause a
 498      * {@link java.lang.NullPointerException NullPointerException} to
 499      * be thrown.
 500      * &lt;p&gt; If the decoded byte output of the needed size can not
 501      *     be allocated, the decode methods of this class will
 502      *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
 503      *     to be thrown.
 504      *
 505      * @see     Encoder
 506      * @since   1.8
 507      */
 508     public static class Decoder {
 509 
 510         private final boolean isURL;
 511         private final boolean isMIME;
 512 
 513         private Decoder(boolean isURL, boolean isMIME) {
 514             this.isURL = isURL;
 515             this.isMIME = isMIME;
 516         }
 517 
 518         /**
 519          * Lookup table for decoding unicode characters drawn from the
 520          * &quot;Base64 Alphabet&quot; (as specified in Table 1 of RFC 2045) into
 521          * their 6-bit positive integer equivalents.  Characters that
 522          * are not in the Base64 alphabet but fall within the bounds of
 523          * the array are encoded to -1.
 524          *
 525          */
 526         private static final int[] fromBase64 = new int[256];
 527         static {
 528             Arrays.fill(fromBase64, -1);
 529             for (int i = 0; i &lt; Encoder.toBase64.length; i++)
 530                 fromBase64[Encoder.toBase64[i]] = i;
 531             fromBase64[&#39;=&#39;] = -2;
 532         }
 533 
 534         /**
 535          * Lookup table for decoding &quot;URL and Filename safe Base64 Alphabet&quot;
 536          * as specified in Table2 of the RFC 4648.
 537          */
 538         private static final int[] fromBase64URL = new int[256];
 539 
 540         static {
 541             Arrays.fill(fromBase64URL, -1);
 542             for (int i = 0; i &lt; Encoder.toBase64URL.length; i++)
 543                 fromBase64URL[Encoder.toBase64URL[i]] = i;
 544             fromBase64URL[&#39;=&#39;] = -2;
 545         }
 546 
 547         static final Decoder RFC4648         = new Decoder(false, false);
 548         static final Decoder RFC4648_URLSAFE = new Decoder(true, false);
 549         static final Decoder RFC2045         = new Decoder(false, true);
 550 
 551         /**
 552          * Decodes all bytes from the input byte array using the {@link Base64}
 553          * encoding scheme, writing the results into a newly-allocated output
 554          * byte array. The returned byte array is of the length of the resulting
 555          * bytes.
 556          *
 557          * @param   src
 558          *          the byte array to decode
 559          *
 560          * @return  A newly-allocated byte array containing the decoded bytes.
 561          *
 562          * @throws  IllegalArgumentException
 563          *          if {@code src} is not in valid Base64 scheme
 564          */
 565         public byte[] decode(byte[] src) {
 566             byte[] dst = new byte[decodedOutLength(src, 0, src.length)];
 567             int ret = decode0(src, 0, src.length, dst);
 568             if (ret != dst.length) {
 569                 dst = Arrays.copyOf(dst, ret);
 570             }
 571             return dst;
 572         }
 573 
 574         /**
 575          * Decodes a Base64 encoded String into a newly-allocated byte array
 576          * using the {@link Base64} encoding scheme.
 577          *
 578          * &lt;p&gt; An invocation of this method has exactly the same effect as invoking
 579          * {@code decode(src.getBytes(StandardCharsets.ISO_8859_1))}
 580          *
 581          * @param   src
 582          *          the string to decode
 583          *
 584          * @return  A newly-allocated byte array containing the decoded bytes.
 585          *
 586          * @throws  IllegalArgumentException
 587          *          if {@code src} is not in valid Base64 scheme
 588          */
 589         public byte[] decode(String src) {
 590             return decode(src.getBytes(ISO_8859_1.INSTANCE));
 591         }
 592 
 593         /**
 594          * Decodes all bytes from the input byte array using the {@link Base64}
 595          * encoding scheme, writing the results into the given output byte array,
 596          * starting at offset 0.
 597          *
 598          * &lt;p&gt; It is the responsibility of the invoker of this method to make
 599          * sure the output byte array {@code dst} has enough space for decoding
 600          * all bytes from the input byte array. No bytes will be written to
 601          * the output byte array if the output byte array is not big enough.
 602          *
 603          * &lt;p&gt; If the input byte array is not in valid Base64 encoding scheme
 604          * then some bytes may have been written to the output byte array before
 605          * IllegalargumentException is thrown.
 606          *
 607          * @param   src
 608          *          the byte array to decode
 609          * @param   dst
 610          *          the output byte array
 611          *
 612          * @return  The number of bytes written to the output byte array
 613          *
 614          * @throws  IllegalArgumentException
 615          *          if {@code src} is not in valid Base64 scheme, or {@code dst}
 616          *          does not have enough space for decoding all input bytes.
 617          */
 618         public int decode(byte[] src, byte[] dst) {
 619             int len = decodedOutLength(src, 0, src.length);
 620             if (dst.length &lt; len || len == -1)
 621                 throw new IllegalArgumentException(
 622                     &quot;Output byte array is too small for decoding all input bytes&quot;);
 623             return decode0(src, 0, src.length, dst);
 624         }
 625 
 626         /**
 627          * Decodes all bytes from the input byte buffer using the {@link Base64}
 628          * encoding scheme, writing the results into a newly-allocated ByteBuffer.
 629          *
 630          * &lt;p&gt; Upon return, the source buffer&#39;s position will be updated to
 631          * its limit; its limit will not have been changed. The returned
 632          * output buffer&#39;s position will be zero and its limit will be the
 633          * number of resulting decoded bytes
 634          *
 635          * &lt;p&gt; {@code IllegalArgumentException} is thrown if the input buffer
 636          * is not in valid Base64 encoding scheme. The position of the input
 637          * buffer will not be advanced in this case.
 638          *
 639          * @param   buffer
 640          *          the ByteBuffer to decode
 641          *
 642          * @return  A newly-allocated byte buffer containing the decoded bytes
 643          *
 644          * @throws  IllegalArgumentException
 645          *          if {@code buffer} is not in valid Base64 scheme
 646          */
 647         public ByteBuffer decode(ByteBuffer buffer) {
 648             int pos0 = buffer.position();
 649             try {
 650                 byte[] src;
 651                 int sp, sl;
 652                 if (buffer.hasArray()) {
 653                     src = buffer.array();
 654                     sp = buffer.arrayOffset() + buffer.position();
 655                     sl = buffer.arrayOffset() + buffer.limit();
 656                     buffer.position(buffer.limit());
 657                 } else {
 658                     src = new byte[buffer.remaining()];
 659                     buffer.get(src);
 660                     sp = 0;
 661                     sl = src.length;
 662                 }
 663                 byte[] dst = new byte[decodedOutLength(src, sp, sl)];
 664                 return ByteBuffer.wrap(dst, 0, decode0(src, sp, sl, dst));
 665             } catch (IllegalArgumentException iae) {
 666                 buffer.position(pos0);
 667                 throw iae;
 668             }
 669         }
 670 
 671         /**
 672          * Returns an input stream for decoding {@link Base64} encoded byte stream.
 673          *
 674          * &lt;p&gt; The {@code read}  methods of the returned {@code InputStream} will
 675          * throw {@code IOException} when reading bytes that cannot be decoded.
 676          *
 677          * &lt;p&gt; Closing the returned input stream will close the underlying
 678          * input stream.
 679          *
 680          * @param   is
 681          *          the input stream
 682          *
 683          * @return  the input stream for decoding the specified Base64 encoded
 684          *          byte stream
 685          */
 686         public InputStream wrap(InputStream is) {
 687             Objects.requireNonNull(is);
 688             return new DecInputStream(is, isURL ? fromBase64URL : fromBase64, isMIME);
 689         }
 690 
 691         /**
 692          * Calculates the length of the decoded output bytes.
 693          *
 694          * @param src the byte array to decode
 695          * @param sp the source  position
 696          * @param sl the source limit
 697          *
 698          * @return length of the decoded bytes
 699          *
 700          */
 701         private int decodedOutLength(byte[] src, int sp, int sl) {
 702             int[] base64 = isURL ? fromBase64URL : fromBase64;
 703             int paddings = 0;
 704             int len = sl - sp;
 705             if (len == 0)
 706                 return 0;
 707             if (len &lt; 2) {
 708                 if (isMIME &amp;&amp; base64[0] == -1)
 709                     return 0;
 710                 throw new IllegalArgumentException(
 711                     &quot;Input byte[] should at least have 2 bytes for base64 bytes&quot;);
 712             }
 713             if (isMIME) {
 714                 // scan all bytes to fill out all non-alphabet. a performance
 715                 // trade-off of pre-scan or Arrays.copyOf
 716                 int n = 0;
 717                 while (sp &lt; sl) {
 718                     int b = src[sp++] &amp; 0xff;
 719                     if (b == &#39;=&#39;) {
 720                         len -= (sl - sp + 1);
 721                         break;
 722                     }
 723                     if ((b = base64[b]) == -1)
 724                         n++;
 725                 }
 726                 len -= n;
 727             } else {
 728                 if (src[sl - 1] == &#39;=&#39;) {
 729                     paddings++;
 730                     if (src[sl - 2] == &#39;=&#39;)
 731                         paddings++;
 732                 }
 733             }
 734             if (paddings == 0 &amp;&amp; (len &amp; 0x3) !=  0)
 735                 paddings = 4 - (len &amp; 0x3);
 736 
 737             // If len is near to Integer.MAX_VALUE, (len + 3)
 738             // can possibly overflow, perform this operation as
 739             // long and cast it back to integer when the value comes under
 740             // integer limit. The final value will always be in integer
 741             // limits
 742             return 3 * (int) ((len + 3L) / 4) - paddings;
 743         }
 744 
 745         private int decode0(byte[] src, int sp, int sl, byte[] dst) {
 746             int[] base64 = isURL ? fromBase64URL : fromBase64;
 747             int dp = 0;
 748             int bits = 0;
 749             int shiftto = 18;       // pos of first byte of 4-byte atom
 750 
 751             while (sp &lt; sl) {
 752                 if (shiftto == 18 &amp;&amp; sp + 4 &lt; sl) {       // fast path
 753                     int sl0 = sp + ((sl - sp) &amp; ~0b11);
 754                     while (sp &lt; sl0) {
 755                         int b1 = base64[src[sp++] &amp; 0xff];
 756                         int b2 = base64[src[sp++] &amp; 0xff];
 757                         int b3 = base64[src[sp++] &amp; 0xff];
 758                         int b4 = base64[src[sp++] &amp; 0xff];
 759                         if ((b1 | b2 | b3 | b4) &lt; 0) {    // non base64 byte
 760                             sp -= 4;
 761                             break;
 762                         }
 763                         int bits0 = b1 &lt;&lt; 18 | b2 &lt;&lt; 12 | b3 &lt;&lt; 6 | b4;
 764                         dst[dp++] = (byte)(bits0 &gt;&gt; 16);
 765                         dst[dp++] = (byte)(bits0 &gt;&gt;  8);
 766                         dst[dp++] = (byte)(bits0);
 767                     }
 768                     if (sp &gt;= sl)
 769                         break;
 770                 }
 771                 int b = src[sp++] &amp; 0xff;
 772                 if ((b = base64[b]) &lt; 0) {
 773                     if (b == -2) {         // padding byte &#39;=&#39;
 774                         // =     shiftto==18 unnecessary padding
 775                         // x=    shiftto==12 a dangling single x
 776                         // x     to be handled together with non-padding case
 777                         // xx=   shiftto==6&amp;&amp;sp==sl missing last =
 778                         // xx=y  shiftto==6 last is not =
 779                         if (shiftto == 6 &amp;&amp; (sp == sl || src[sp++] != &#39;=&#39;) ||
 780                             shiftto == 18) {
 781                             throw new IllegalArgumentException(
 782                                 &quot;Input byte array has wrong 4-byte ending unit&quot;);
 783                         }
 784                         break;
 785                     }
 786                     if (isMIME)    // skip if for rfc2045
 787                         continue;
 788                     else
 789                         throw new IllegalArgumentException(
 790                             &quot;Illegal base64 character &quot; +
 791                             Integer.toString(src[sp - 1], 16));
 792                 }
 793                 bits |= (b &lt;&lt; shiftto);
 794                 shiftto -= 6;
 795                 if (shiftto &lt; 0) {
 796                     dst[dp++] = (byte)(bits &gt;&gt; 16);
 797                     dst[dp++] = (byte)(bits &gt;&gt;  8);
 798                     dst[dp++] = (byte)(bits);
 799                     shiftto = 18;
 800                     bits = 0;
 801                 }
 802             }
 803             // reached end of byte array or hit padding &#39;=&#39; characters.
 804             if (shiftto == 6) {
 805                 dst[dp++] = (byte)(bits &gt;&gt; 16);
 806             } else if (shiftto == 0) {
 807                 dst[dp++] = (byte)(bits &gt;&gt; 16);
 808                 dst[dp++] = (byte)(bits &gt;&gt;  8);
 809             } else if (shiftto == 12) {
 810                 // dangling single &quot;x&quot;, incorrectly encoded.
 811                 throw new IllegalArgumentException(
 812                     &quot;Last unit does not have enough valid bits&quot;);
 813             }
 814             // anything left is invalid, if is not MIME.
 815             // if MIME, ignore all non-base64 character
 816             while (sp &lt; sl) {
 817                 if (isMIME &amp;&amp; base64[src[sp++] &amp; 0xff] &lt; 0)
 818                     continue;
 819                 throw new IllegalArgumentException(
 820                     &quot;Input byte array has incorrect ending byte at &quot; + sp);
 821             }
 822             return dp;
 823         }
 824     }
 825 
 826     /*
 827      * An output stream for encoding bytes into the Base64.
 828      */
 829     private static class EncOutputStream extends FilterOutputStream {
 830 
 831         private int leftover = 0;
 832         private int b0, b1, b2;
 833         private boolean closed = false;
 834 
 835         private final char[] base64;    // byte-&gt;base64 mapping
 836         private final byte[] newline;   // line separator, if needed
 837         private final int linemax;
 838         private final boolean doPadding;// whether or not to pad
 839         private int linepos = 0;
 840         private byte[] buf;
 841 
 842         EncOutputStream(OutputStream os, char[] base64,
 843                         byte[] newline, int linemax, boolean doPadding) {
 844             super(os);
 845             this.base64 = base64;
 846             this.newline = newline;
 847             this.linemax = linemax;
 848             this.doPadding = doPadding;
 849             this.buf = new byte[linemax &lt;= 0 ? 8124 : linemax];
 850         }
 851 
 852         @Override
 853         public void write(int b) throws IOException {
 854             byte[] buf = new byte[1];
 855             buf[0] = (byte)(b &amp; 0xff);
 856             write(buf, 0, 1);
 857         }
 858 
 859         private void checkNewline() throws IOException {
 860             if (linepos == linemax) {
 861                 out.write(newline);
 862                 linepos = 0;
 863             }
 864         }
 865 
 866         private void writeb4(char b1, char b2, char b3, char b4) throws IOException {
 867             buf[0] = (byte)b1;
 868             buf[1] = (byte)b2;
 869             buf[2] = (byte)b3;
 870             buf[3] = (byte)b4;
 871             out.write(buf, 0, 4);
 872         }
 873 
 874         @Override
 875         public void write(byte[] b, int off, int len) throws IOException {
 876             if (closed)
 877                 throw new IOException(&quot;Stream is closed&quot;);
 878             if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off)
 879                 throw new ArrayIndexOutOfBoundsException();
 880             if (len == 0)
 881                 return;
 882             if (leftover != 0) {
 883                 if (leftover == 1) {
 884                     b1 = b[off++] &amp; 0xff;
 885                     len--;
 886                     if (len == 0) {
 887                         leftover++;
 888                         return;
 889                     }
 890                 }
 891                 b2 = b[off++] &amp; 0xff;
 892                 len--;
 893                 checkNewline();
 894                 writeb4(base64[b0 &gt;&gt; 2],
 895                         base64[(b0 &lt;&lt; 4) &amp; 0x3f | (b1 &gt;&gt; 4)],
 896                         base64[(b1 &lt;&lt; 2) &amp; 0x3f | (b2 &gt;&gt; 6)],
 897                         base64[b2 &amp; 0x3f]);
 898                 linepos += 4;
 899             }
 900             int nBits24 = len / 3;
 901             leftover = len - (nBits24 * 3);
 902 
 903             while (nBits24 &gt; 0) {
 904                 checkNewline();
 905                 int dl = linemax &lt;= 0 ? buf.length : buf.length - linepos;
 906                 int sl = off + Math.min(nBits24, dl / 4) * 3;
 907                 int dp = 0;
 908                 for (int sp = off; sp &lt; sl; ) {
 909                     int bits = (b[sp++] &amp; 0xff) &lt;&lt; 16 |
 910                                (b[sp++] &amp; 0xff) &lt;&lt;  8 |
 911                                (b[sp++] &amp; 0xff);
 912                     buf[dp++] = (byte)base64[(bits &gt;&gt;&gt; 18) &amp; 0x3f];
 913                     buf[dp++] = (byte)base64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];
 914                     buf[dp++] = (byte)base64[(bits &gt;&gt;&gt; 6)  &amp; 0x3f];
 915                     buf[dp++] = (byte)base64[bits &amp; 0x3f];
 916                 }
 917                 out.write(buf, 0, dp);
 918                 off = sl;
 919                 linepos += dp;
 920                 nBits24 -= dp / 4;
 921             }
 922             if (leftover == 1) {
 923                 b0 = b[off++] &amp; 0xff;
 924             } else if (leftover == 2) {
 925                 b0 = b[off++] &amp; 0xff;
 926                 b1 = b[off++] &amp; 0xff;
 927             }
 928         }
 929 
 930         @Override
 931         public void close() throws IOException {
 932             if (!closed) {
 933                 closed = true;
 934                 if (leftover == 1) {
 935                     checkNewline();
 936                     out.write(base64[b0 &gt;&gt; 2]);
 937                     out.write(base64[(b0 &lt;&lt; 4) &amp; 0x3f]);
 938                     if (doPadding) {
 939                         out.write(&#39;=&#39;);
 940                         out.write(&#39;=&#39;);
 941                     }
 942                 } else if (leftover == 2) {
 943                     checkNewline();
 944                     out.write(base64[b0 &gt;&gt; 2]);
 945                     out.write(base64[(b0 &lt;&lt; 4) &amp; 0x3f | (b1 &gt;&gt; 4)]);
 946                     out.write(base64[(b1 &lt;&lt; 2) &amp; 0x3f]);
 947                     if (doPadding) {
 948                        out.write(&#39;=&#39;);
 949                     }
 950                 }
 951                 leftover = 0;
 952                 out.close();
 953             }
 954         }
 955     }
 956 
 957     /*
 958      * An input stream for decoding Base64 bytes
 959      */
 960     private static class DecInputStream extends InputStream {
 961 
 962         private final InputStream is;
 963         private final boolean isMIME;
 964         private final int[] base64;      // base64 -&gt; byte mapping
 965         private int bits = 0;            // 24-bit buffer for decoding
 966         private int nextin = 18;         // next available &quot;off&quot; in &quot;bits&quot; for input;
 967                                          // -&gt; 18, 12, 6, 0
 968         private int nextout = -8;        // next available &quot;off&quot; in &quot;bits&quot; for output;
 969                                          // -&gt; 8, 0, -8 (no byte for output)
 970         private boolean eof = false;
 971         private boolean closed = false;
 972 
 973         DecInputStream(InputStream is, int[] base64, boolean isMIME) {
 974             this.is = is;
 975             this.base64 = base64;
 976             this.isMIME = isMIME;
 977         }
 978 
 979         private byte[] sbBuf = new byte[1];
 980 
 981         @Override
 982         public int read() throws IOException {
 983             return read(sbBuf, 0, 1) == -1 ? -1 : sbBuf[0] &amp; 0xff;
 984         }
 985 
 986         private int eof(byte[] b, int off, int len, int oldOff)
 987             throws IOException
 988         {
 989             eof = true;
 990             if (nextin != 18) {
 991                 if (nextin == 12)
 992                     throw new IOException(&quot;Base64 stream has one un-decoded dangling byte.&quot;);
 993                 // treat ending xx/xxx without padding character legal.
 994                 // same logic as v == &#39;=&#39; below
 995                 b[off++] = (byte)(bits &gt;&gt; (16));
 996                 if (nextin == 0) {           // only one padding byte
 997                     if (len == 1) {          // no enough output space
 998                         bits &gt;&gt;= 8;          // shift to lowest byte
 999                         nextout = 0;
1000                     } else {
1001                         b[off++] = (byte) (bits &gt;&gt;  8);
1002                     }
1003                 }
1004             }
1005             return off == oldOff ? -1 : off - oldOff;
1006         }
1007 
1008         private int padding(byte[] b, int off, int len, int oldOff)
1009             throws IOException
1010         {
1011             // =     shiftto==18 unnecessary padding
1012             // x=    shiftto==12 dangling x, invalid unit
1013             // xx=   shiftto==6 &amp;&amp; missing last &#39;=&#39;
1014             // xx=y  or last is not &#39;=&#39;
1015             if (nextin == 18 || nextin == 12 ||
1016                 nextin == 6 &amp;&amp; is.read() != &#39;=&#39;) {
1017                 throw new IOException(&quot;Illegal base64 ending sequence:&quot; + nextin);
1018             }
1019             b[off++] = (byte)(bits &gt;&gt; (16));
1020             if (nextin == 0) {           // only one padding byte
1021                 if (len == 1) {          // no enough output space
1022                     bits &gt;&gt;= 8;          // shift to lowest byte
1023                     nextout = 0;
1024                 } else {
1025                     b[off++] = (byte) (bits &gt;&gt;  8);
1026                 }
1027             }
1028             eof = true;
1029             return off - oldOff;
1030         }
1031 
1032         @Override
1033         public int read(byte[] b, int off, int len) throws IOException {
1034             if (closed)
1035                 throw new IOException(&quot;Stream is closed&quot;);
1036             if (eof &amp;&amp; nextout &lt; 0)    // eof and no leftover
1037                 return -1;
1038             if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off)
1039                 throw new IndexOutOfBoundsException();
1040             int oldOff = off;
1041             while (nextout &gt;= 0) {       // leftover output byte(s) in bits buf
1042                 if (len == 0)
1043                     return off - oldOff;
1044                 b[off++] = (byte)(bits &gt;&gt; nextout);
1045                 len--;
1046                 nextout -= 8;
1047             }
1048             bits = 0;
1049             while (len &gt; 0) {
1050                 int v = is.read();
1051                 if (v == -1) {
1052                     return eof(b, off, len, oldOff);
1053                 }
1054                 if ((v = base64[v]) &lt; 0) {
1055                     if (v == -2) {       // padding byte(s)
1056                         return padding(b, off, len, oldOff);
1057                     }
1058                     if (v == -1) {
1059                         if (!isMIME)
1060                             throw new IOException(&quot;Illegal base64 character &quot; +
1061                                 Integer.toString(v, 16));
1062                         continue;        // skip if for rfc2045
1063                     }
1064                     // neve be here
1065                 }
1066                 bits |= (v &lt;&lt; nextin);
1067                 if (nextin == 0) {
1068                     nextin = 18;         // clear for next in
1069                     b[off++] = (byte)(bits &gt;&gt; 16);
1070                     if (len == 1) {
1071                         nextout = 8;    // 2 bytes left in bits
1072                         break;
1073                     }
1074                     b[off++] = (byte)(bits &gt;&gt; 8);
1075                     if (len == 2) {
1076                         nextout = 0;    // 1 byte left in bits
1077                         break;
1078                     }
1079                     b[off++] = (byte)bits;
1080                     len -= 3;
1081                     bits = 0;
1082                 } else {
1083                     nextin -= 6;
1084                 }
1085             }
1086             return off - oldOff;
1087         }
1088 
1089         @Override
1090         public int available() throws IOException {
1091             if (closed)
1092                 throw new IOException(&quot;Stream is closed&quot;);
1093             return is.available();   // TBD:
1094         }
1095 
1096         @Override
1097         public void close() throws IOException {
1098             if (!closed) {
1099                 closed = true;
1100                 is.close();
1101             }
1102         }
1103     }
1104 }
    </pre>
  </body>
</html>
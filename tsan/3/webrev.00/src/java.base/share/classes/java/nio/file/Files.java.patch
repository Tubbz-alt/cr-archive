diff a/src/java.base/share/classes/java/nio/file/Files.java b/src/java.base/share/classes/java/nio/file/Files.java
--- a/src/java.base/share/classes/java/nio/file/Files.java
+++ b/src/java.base/share/classes/java/nio/file/Files.java
@@ -75,11 +75,13 @@
 import java.util.Spliterators;
 import java.util.function.BiPredicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import jdk.internal.util.ArraysSupport;
 import sun.nio.ch.FileChannelImpl;
+import sun.nio.cs.UTF_8;
 import sun.nio.fs.AbstractFileSystemProvider;
 
 /**
  * This class consists exclusively of static methods that operate on files,
  * directories, or other types of files.
@@ -2941,11 +2943,11 @@
      *          method is invoked to check read access to the file.
      *
      * @since 1.8
      */
     public static BufferedReader newBufferedReader(Path path) throws IOException {
-        return newBufferedReader(path, StandardCharsets.UTF_8);
+        return newBufferedReader(path, UTF_8.INSTANCE);
     }
 
     /**
      * Opens or creates a file for writing, returning a {@code BufferedWriter}
      * that may be used to write text to the file in an efficient manner.
@@ -3033,11 +3035,11 @@
      * @since 1.8
      */
     public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
         throws IOException
     {
-        return newBufferedWriter(path, StandardCharsets.UTF_8, options);
+        return newBufferedWriter(path, UTF_8.INSTANCE, options);
     }
 
     /**
      * Copies all bytes from an input stream to a file. On return, the input
      * stream will be at end of stream.
@@ -3194,18 +3196,10 @@
         try (InputStream in = newInputStream(source)) {
             return in.transferTo(out);
         }
     }
 
-    /**
-     * The maximum size of array to allocate.
-     * Some VMs reserve some header words in an array.
-     * Attempts to allocate larger arrays may result in
-     * OutOfMemoryError: Requested array size exceeds VM limit
-     */
-    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
-
     private static final jdk.internal.access.JavaLangAccess JLA =
             jdk.internal.access.SharedSecrets.getJavaLangAccess();
 
     /**
      * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
@@ -3238,17 +3232,14 @@
             // otherwise, try to read one more byte; if that failed we're done too
             if (n < 0 || (n = source.read()) < 0)
                 break;
 
             // one more byte was read; need to allocate a larger buffer
-            if (capacity <= MAX_BUFFER_SIZE - capacity) {
-                capacity = Math.max(capacity << 1, BUFFER_SIZE);
-            } else {
-                if (capacity == MAX_BUFFER_SIZE)
-                    throw new OutOfMemoryError("Required array size too large");
-                capacity = MAX_BUFFER_SIZE;
-            }
+            capacity = Math.max(ArraysSupport.newLength(capacity,
+                                                        1,       /* minimum growth */
+                                                        capacity /* preferred growth */),
+                                BUFFER_SIZE);
             buf = Arrays.copyOf(buf, capacity);
             buf[nread++] = (byte)n;
         }
         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
     }
@@ -3281,11 +3272,11 @@
         try (SeekableByteChannel sbc = Files.newByteChannel(path);
              InputStream in = Channels.newInputStream(sbc)) {
             if (sbc instanceof FileChannelImpl)
                 ((FileChannelImpl) sbc).setUninterruptible();
             long size = sbc.size();
-            if (size > (long) MAX_BUFFER_SIZE)
+            if (size > (long) Integer.MAX_VALUE)
                 throw new OutOfMemoryError("Required array size too large");
             return read(in, (int)size);
         }
     }
 
@@ -3313,11 +3304,11 @@
      *          method is invoked to check read access to the file.
      *
      * @since 11
      */
     public static String readString(Path path) throws IOException {
-        return readString(path, StandardCharsets.UTF_8);
+        return readString(path, UTF_8.INSTANCE);
     }
 
     /**
      * Reads all characters from a file into a string, decoding from bytes to characters
      * using the specified {@linkplain Charset charset}.
@@ -3355,10 +3346,12 @@
     public static String readString(Path path, Charset cs) throws IOException {
         Objects.requireNonNull(path);
         Objects.requireNonNull(cs);
 
         byte[] ba = readAllBytes(path);
+        if (path.getClass().getModule() != Object.class.getModule())
+            ba = ba.clone();
         return JLA.newStringNoRepl(ba, cs);
     }
 
     /**
      * Read all lines from a file. This method ensures that the file is
@@ -3438,11 +3431,11 @@
      *          method is invoked to check read access to the file.
      *
      * @since 1.8
      */
     public static List<String> readAllLines(Path path) throws IOException {
-        return readAllLines(path, StandardCharsets.UTF_8);
+        return readAllLines(path, UTF_8.INSTANCE);
     }
 
     /**
      * Writes bytes to a file. The {@code options} parameter specifies how
      * the file is created or opened. If no options are present then this method
@@ -3558,12 +3551,12 @@
         throws IOException
     {
         // ensure lines is not null before opening file
         Objects.requireNonNull(lines);
         CharsetEncoder encoder = cs.newEncoder();
-        OutputStream out = newOutputStream(path, options);
-        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {
+        try (OutputStream out = newOutputStream(path, options);
+             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {
             for (CharSequence line: lines) {
                 writer.append(line);
                 writer.newLine();
             }
         }
@@ -3609,11 +3602,11 @@
     public static Path write(Path path,
                              Iterable<? extends CharSequence> lines,
                              OpenOption... options)
         throws IOException
     {
-        return write(path, lines, StandardCharsets.UTF_8, options);
+        return write(path, lines, UTF_8.INSTANCE, options);
     }
 
     /**
      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
      * Characters are encoded into bytes using the
@@ -3649,11 +3642,11 @@
      * @since 11
      */
     public static Path writeString(Path path, CharSequence csq, OpenOption... options)
             throws IOException
     {
-        return writeString(path, csq, StandardCharsets.UTF_8, options);
+        return writeString(path, csq, UTF_8.INSTANCE, options);
     }
 
     /**
      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
      * Characters are encoded into bytes using the specified
@@ -4196,8 +4189,8 @@
      *          method is invoked to check read access to the file.
      *
      * @since 1.8
      */
     public static Stream<String> lines(Path path) throws IOException {
-        return lines(path, StandardCharsets.UTF_8);
+        return lines(path, UTF_8.INSTANCE);
     }
 }

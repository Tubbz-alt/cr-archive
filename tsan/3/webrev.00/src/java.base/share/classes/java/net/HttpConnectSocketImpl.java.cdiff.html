<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/HttpConnectSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketImplFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HttpRetryException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/HttpConnectSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,28 ***</span>
  import java.util.Map;
  import java.util.Set;
  
  /**
   * Basic SocketImpl that relies on the internal HTTP protocol handler
<span class="line-modified">!  * implementation to perform the HTTP tunneling and authentication. The</span>
<span class="line-modified">!  * sockets impl is swapped out and replaced with the socket from the HTTP</span>
<span class="line-removed">-  * handler after the tunnel is successfully setup.</span>
   *
   * @since 1.8
   */
  
<span class="line-modified">! /*package*/ class HttpConnectSocketImpl extends PlainSocketImpl {</span>
  
      private static final String httpURLClazzStr =
                                    &quot;sun.net.www.protocol.http.HttpURLConnection&quot;;
      private static final String netClientClazzStr = &quot;sun.net.NetworkClient&quot;;
      private static final String doTunnelingStr = &quot;doTunneling&quot;;
      private static final Field httpField;
      private static final Field serverSocketField;
      private static final Method doTunneling;
  
      private final String server;
      private InetSocketAddress external_address;
      private HashMap&lt;Integer, Object&gt; optionsMap = new HashMap&lt;&gt;();
  
      static  {
          try {
<span class="line-new-header">--- 32,28 ---</span>
  import java.util.Map;
  import java.util.Set;
  
  /**
   * Basic SocketImpl that relies on the internal HTTP protocol handler
<span class="line-modified">!  * implementation to perform the HTTP tunneling and authentication. Once</span>
<span class="line-modified">!  * connected, all socket operations delegate to a platform SocketImpl.</span>
   *
   * @since 1.8
   */
  
<span class="line-modified">! /*package*/ class HttpConnectSocketImpl extends DelegatingSocketImpl {</span>
  
      private static final String httpURLClazzStr =
                                    &quot;sun.net.www.protocol.http.HttpURLConnection&quot;;
      private static final String netClientClazzStr = &quot;sun.net.NetworkClient&quot;;
      private static final String doTunnelingStr = &quot;doTunneling&quot;;
      private static final Field httpField;
      private static final Field serverSocketField;
      private static final Method doTunneling;
  
      private final String server;
<span class="line-added">+     private final Socket socket;</span>
      private InetSocketAddress external_address;
      private HashMap&lt;Integer, Object&gt; optionsMap = new HashMap&lt;&gt;();
  
      static  {
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,40 ***</span>
          } catch (ReflectiveOperationException x) {
              throw new InternalError(&quot;Should not reach here&quot;, x);
          }
      }
  
<span class="line-modified">!     HttpConnectSocketImpl(String server, int port) {</span>
<span class="line-modified">!         this.server = server;</span>
<span class="line-modified">!         this.port = port;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     HttpConnectSocketImpl(Proxy proxy) {</span>
          SocketAddress a = proxy.address();
          if ( !(a instanceof InetSocketAddress) )
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
  
          InetSocketAddress ad = (InetSocketAddress) a;
          server = ad.getHostString();
          port = ad.getPort();
      }
  
      @Override
      protected void connect(SocketAddress endpoint, int timeout)
          throws IOException
      {
          if (endpoint == null || !(endpoint instanceof InetSocketAddress))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
          final InetSocketAddress epoint = (InetSocketAddress)endpoint;
<span class="line-modified">!         final String destHost = epoint.isUnresolved() ? epoint.getHostName()</span>
<span class="line-modified">!                                                       : epoint.getAddress().getHostAddress();</span>
          final int destPort = epoint.getPort();
  
          SecurityManager security = System.getSecurityManager();
          if (security != null)
              security.checkConnect(destHost, destPort);
  
          // Connect to the HTTP proxy server
          String urlString = &quot;http://&quot; + destHost + &quot;:&quot; + destPort;
          Socket httpSocket = privilegedDoTunnel(urlString, timeout);
  
          // Success!
<span class="line-new-header">--- 74,50 ---</span>
          } catch (ReflectiveOperationException x) {
              throw new InternalError(&quot;Should not reach here&quot;, x);
          }
      }
  
<span class="line-modified">!     HttpConnectSocketImpl(Proxy proxy, SocketImpl delegate, Socket socket) {</span>
<span class="line-modified">!         super(delegate);</span>
<span class="line-modified">!         this.socket = socket;</span>
          SocketAddress a = proxy.address();
          if ( !(a instanceof InetSocketAddress) )
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
  
          InetSocketAddress ad = (InetSocketAddress) a;
          server = ad.getHostString();
          port = ad.getPort();
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void connect(String host, int port) throws IOException {</span>
<span class="line-added">+         connect(new InetSocketAddress(host, port), 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void connect(InetAddress address, int port) throws IOException {</span>
<span class="line-added">+         connect(new InetSocketAddress(address, port), 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      protected void connect(SocketAddress endpoint, int timeout)
          throws IOException
      {
          if (endpoint == null || !(endpoint instanceof InetSocketAddress))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
          final InetSocketAddress epoint = (InetSocketAddress)endpoint;
<span class="line-modified">!         String destHost = epoint.isUnresolved() ? epoint.getHostName()</span>
<span class="line-modified">!                                                 : epoint.getAddress().getHostAddress();</span>
          final int destPort = epoint.getPort();
  
          SecurityManager security = System.getSecurityManager();
          if (security != null)
              security.checkConnect(destHost, destPort);
  
<span class="line-added">+         if (destHost.contains(&quot;:&quot;))</span>
<span class="line-added">+             destHost = &quot;[&quot; + destHost + &quot;]&quot;;</span>
<span class="line-added">+ </span>
          // Connect to the HTTP proxy server
          String urlString = &quot;http://&quot; + destHost + &quot;:&quot; + destPort;
          Socket httpSocket = privilegedDoTunnel(urlString, timeout);
  
          // Success!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,25 ***</span>
  
          // close the original socket impl and release its descriptor
          close();
  
          // update the Sockets impl to the impl from the http Socket
<span class="line-modified">!         AbstractPlainSocketImpl psi = (AbstractPlainSocketImpl) httpSocket.impl;</span>
<span class="line-modified">!         this.getSocket().impl = psi;</span>
  
          // best effort is made to try and reset options previously set
          Set&lt;Map.Entry&lt;Integer,Object&gt;&gt; options = optionsMap.entrySet();
          try {
              for(Map.Entry&lt;Integer,Object&gt; entry : options) {
<span class="line-modified">!                 psi.setOption(entry.getKey(), entry.getValue());</span>
              }
          } catch (IOException x) {  /* gulp! */  }
      }
  
      @Override
      public void setOption(int opt, Object val) throws SocketException {
<span class="line-modified">!         super.setOption(opt, val);</span>
  
          if (external_address != null)
              return;  // we&#39;re connected, just return
  
          // store options so that they can be re-applied to the impl after connect
<span class="line-new-header">--- 125,41 ---</span>
  
          // close the original socket impl and release its descriptor
          close();
  
          // update the Sockets impl to the impl from the http Socket
<span class="line-modified">!         SocketImpl si = httpSocket.impl;</span>
<span class="line-modified">!         socket.setImpl(si);</span>
  
          // best effort is made to try and reset options previously set
          Set&lt;Map.Entry&lt;Integer,Object&gt;&gt; options = optionsMap.entrySet();
          try {
              for(Map.Entry&lt;Integer,Object&gt; entry : options) {
<span class="line-modified">!                 si.setOption(entry.getKey(), entry.getValue());</span>
              }
          } catch (IOException x) {  /* gulp! */  }
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void listen(int backlog) {</span>
<span class="line-added">+         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void accept(SocketImpl s) {</span>
<span class="line-added">+         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     void reset() {</span>
<span class="line-added">+         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public void setOption(int opt, Object val) throws SocketException {
<span class="line-modified">!         delegate.setOption(opt, val);</span>
  
          if (external_address != null)
              return;  // we&#39;re connected, just return
  
          // store options so that they can be re-applied to the impl after connect
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,40 ***</span>
      {
          Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(server, port));
          URL destURL = new URL(urlString);
          HttpURLConnection conn = (HttpURLConnection) destURL.openConnection(proxy);
          conn.setConnectTimeout(connectTimeout);
<span class="line-modified">!         conn.setReadTimeout(this.timeout);</span>
          conn.connect();
          doTunneling(conn);
          try {
              Object httpClient = httpField.get(conn);
              return (Socket) serverSocketField.get(httpClient);
          } catch (IllegalAccessException x) {
              throw new InternalError(&quot;Should not reach here&quot;, x);
          }
      }
  
<span class="line-modified">!     private void doTunneling(HttpURLConnection conn) {</span>
          try {
              doTunneling.invoke(conn);
          } catch (ReflectiveOperationException x) {
              throw new InternalError(&quot;Should not reach here&quot;, x);
          }
      }
  
      @Override
      protected InetAddress getInetAddress() {
          if (external_address != null)
              return external_address.getAddress();
          else
<span class="line-modified">!             return super.getInetAddress();</span>
      }
  
      @Override
      protected int getPort() {
          if (external_address != null)
              return external_address.getPort();
          else
<span class="line-modified">!             return super.getPort();</span>
      }
  }
<span class="line-new-header">--- 187,47 ---</span>
      {
          Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(server, port));
          URL destURL = new URL(urlString);
          HttpURLConnection conn = (HttpURLConnection) destURL.openConnection(proxy);
          conn.setConnectTimeout(connectTimeout);
<span class="line-modified">!         int timeout = (int) getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-added">+         if (timeout &gt; 0) {</span>
<span class="line-added">+             conn.setReadTimeout(timeout);</span>
<span class="line-added">+         }</span>
          conn.connect();
          doTunneling(conn);
          try {
              Object httpClient = httpField.get(conn);
              return (Socket) serverSocketField.get(httpClient);
          } catch (IllegalAccessException x) {
              throw new InternalError(&quot;Should not reach here&quot;, x);
          }
      }
  
<span class="line-modified">!     private void doTunneling(HttpURLConnection conn) throws IOException {</span>
          try {
              doTunneling.invoke(conn);
          } catch (ReflectiveOperationException x) {
<span class="line-added">+             Throwable cause = x.getCause();</span>
<span class="line-added">+             if (cause instanceof IOException) {</span>
<span class="line-added">+                 throw (IOException) cause;</span>
<span class="line-added">+             }</span>
              throw new InternalError(&quot;Should not reach here&quot;, x);
          }
      }
  
      @Override
      protected InetAddress getInetAddress() {
          if (external_address != null)
              return external_address.getAddress();
          else
<span class="line-modified">!             return delegate.getInetAddress();</span>
      }
  
      @Override
      protected int getPort() {
          if (external_address != null)
              return external_address.getPort();
          else
<span class="line-modified">!             return delegate.getPort();</span>
      }
  }
</pre>
<center><a href="DatagramSocketImplFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HttpRetryException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
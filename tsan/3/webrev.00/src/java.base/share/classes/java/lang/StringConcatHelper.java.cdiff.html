<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/StringConcatHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StringCoding.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringIndexOutOfBoundsException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/StringConcatHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,13 ---</span>
   * questions.
   */
  
  package java.lang;
  
<span class="line-added">+ import jdk.internal.misc.Unsafe;</span>
<span class="line-added">+ import jdk.internal.vm.annotation.ForceInline;</span>
<span class="line-added">+ </span>
  /**
   * Helper for string concatenation. These methods are mostly looked up with private lookups
   * from {@link java.lang.invoke.StringConcatFactory}, and used in {@link java.lang.invoke.MethodHandle}
   * combinators there.
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,92 ***</span>
          // no instantiation
      }
  
      /**
       * Check for overflow, throw exception on overflow.
<span class="line-modified">!      * @param lengthCoder String length and coder</span>
<span class="line-modified">!      * @return lengthCoder</span>
       */
      private static long checkOverflow(long lengthCoder) {
          if ((int)lengthCoder &gt;= 0) {
              return lengthCoder;
          }
          throw new OutOfMemoryError(&quot;Overflow: String length out of range&quot;);
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, boolean value) {</span>
<span class="line-modified">!         return checkOverflow(current + (value ? 4 : 5));</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, byte value) {</span>
<span class="line-modified">!         return mix(current, (int)value);</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, char value) {</span>
<span class="line-modified">!         return checkOverflow(current + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, short value) {</span>
<span class="line-modified">!         return mix(current, (int)value);</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, int value) {</span>
<span class="line-modified">!         return checkOverflow(current + Integer.stringSize(value));</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, long value) {</span>
<span class="line-modified">!         return checkOverflow(current + Long.stringSize(value));</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param current current length</span>
<span class="line-modified">!      * @param value   value to mix in</span>
<span class="line-modified">!      * @return new length and coder</span>
       */
<span class="line-modified">!     static long mix(long current, String value) {</span>
<span class="line-modified">!         current += value.length();</span>
          if (value.coder() == String.UTF16) {
<span class="line-modified">!             current |= UTF16;</span>
          }
<span class="line-modified">!         return checkOverflow(current);</span>
      }
  
      /**
       * Prepends the stringly representation of boolean value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
<span class="line-new-header">--- 39,101 ---</span>
          // no instantiation
      }
  
      /**
       * Check for overflow, throw exception on overflow.
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-added">+      *                    the upper word.</span>
<span class="line-added">+      * @return            the given parameter value, if valid</span>
       */
      private static long checkOverflow(long lengthCoder) {
          if ((int)lengthCoder &gt;= 0) {
              return lengthCoder;
          }
          throw new OutOfMemoryError(&quot;Overflow: String length out of range&quot;);
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, boolean value) {</span>
<span class="line-modified">!         return checkOverflow(lengthCoder + (value ? 4 : 5));</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, byte value) {</span>
<span class="line-modified">!         return mix(lengthCoder, (int)value);</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, char value) {</span>
<span class="line-modified">!         return checkOverflow(lengthCoder + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, short value) {</span>
<span class="line-modified">!         return mix(lengthCoder, (int)value);</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, int value) {</span>
<span class="line-modified">!         return checkOverflow(lengthCoder + Integer.stringSize(value));</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, long value) {</span>
<span class="line-modified">!         return checkOverflow(lengthCoder + Long.stringSize(value));</span>
      }
  
      /**
       * Mix value length and coder into current length and coder.
<span class="line-modified">!      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">!      *                    the upper word.</span>
<span class="line-modified">!      * @param value       value to mix in</span>
<span class="line-added">+      * @return            new length and coder</span>
       */
<span class="line-modified">!     static long mix(long lengthCoder, String value) {</span>
<span class="line-modified">!         lengthCoder += value.length();</span>
          if (value.coder() == String.UTF16) {
<span class="line-modified">!             lengthCoder |= UTF16;</span>
          }
<span class="line-modified">!         return checkOverflow(lengthCoder);</span>
      }
  
      /**
       * Prepends the stringly representation of boolean value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,11 ***</span>
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      boolean value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, boolean value) {</span>
          int index = (int)indexCoder;
          if (indexCoder &lt; UTF16) {
              if (value) {
                  buf[--index] = &#39;e&#39;;
                  buf[--index] = &#39;u&#39;;
<span class="line-new-header">--- 142,11 ---</span>
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      boolean value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     private static long prepend(long indexCoder, byte[] buf, boolean value) {</span>
          int index = (int)indexCoder;
          if (indexCoder &lt; UTF16) {
              if (value) {
                  buf[--index] = &#39;e&#39;;
                  buf[--index] = &#39;u&#39;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,21 ***</span>
              return index | UTF16;
          }
      }
  
      /**
<span class="line-modified">!      * Prepends the stringly representation of byte value into buffer,</span>
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
<span class="line-modified">!      * @param value      byte value to encode</span>
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, byte value) {</span>
<span class="line-modified">!         return prepend(indexCoder, buf, (int)value);</span>
      }
  
      /**
       * Prepends the stringly representation of char value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
<span class="line-new-header">--- 176,45 ---</span>
              return index | UTF16;
          }
      }
  
      /**
<span class="line-modified">!      * Prepends constant and the stringly representation of value into buffer,</span>
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
<span class="line-modified">!      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, String prefix, boolean value, String suffix) {</span>
<span class="line-modified">!         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">+      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">+      *                   into higher bits.</span>
<span class="line-added">+      * @param buf        buffer to append to</span>
<span class="line-added">+      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
<span class="line-added">+      * @return           updated index (coder value retained)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static long prepend(long indexCoder, byte[] buf, String prefix, byte value, String suffix) {</span>
<span class="line-added">+         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, (int)value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
      }
  
      /**
       * Prepends the stringly representation of char value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,31 ***</span>
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      char value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, char value) {</span>
          if (indexCoder &lt; UTF16) {
              buf[(int)(--indexCoder)] = (byte) (value &amp; 0xFF);
          } else {
              StringUTF16.putChar(buf, (int)(--indexCoder), value);
          }
          return indexCoder;
      }
  
      /**
<span class="line-modified">!      * Prepends the stringly representation of short value into buffer,</span>
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
<span class="line-modified">!      * @param value      short value to encode</span>
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, short value) {</span>
<span class="line-modified">!         return prepend(indexCoder, buf, (int)value);</span>
      }
  
      /**
       * Prepends the stringly representation of integer value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
<span class="line-new-header">--- 223,55 ---</span>
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      char value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     private static long prepend(long indexCoder, byte[] buf, char value) {</span>
          if (indexCoder &lt; UTF16) {
              buf[(int)(--indexCoder)] = (byte) (value &amp; 0xFF);
          } else {
              StringUTF16.putChar(buf, (int)(--indexCoder), value);
          }
          return indexCoder;
      }
  
      /**
<span class="line-modified">!      * Prepends constant and the stringly representation of value into buffer,</span>
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
<span class="line-modified">!      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, String prefix, char value, String suffix) {</span>
<span class="line-modified">!         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">+      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">+      *                   into higher bits.</span>
<span class="line-added">+      * @param buf        buffer to append to</span>
<span class="line-added">+      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
<span class="line-added">+      * @return           updated index (coder value retained)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static long prepend(long indexCoder, byte[] buf, String prefix, short value, String suffix) {</span>
<span class="line-added">+         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, (int)value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
      }
  
      /**
       * Prepends the stringly representation of integer value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,56 ***</span>
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      integer value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, int value) {</span>
          if (indexCoder &lt; UTF16) {
              return Integer.getChars(value, (int)indexCoder, buf);
          } else {
              return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
          }
      }
  
      /**
       * Prepends the stringly representation of long value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      long value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, long value) {</span>
          if (indexCoder &lt; UTF16) {
              return Long.getChars(value, (int)indexCoder, buf);
          } else {
              return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
          }
      }
  
      /**
       * Prepends the stringly representation of String value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      String value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     static long prepend(long indexCoder, byte[] buf, String value) {</span>
          indexCoder -= value.length();
          if (indexCoder &lt; UTF16) {
              value.getBytes(buf, (int)indexCoder, String.LATIN1);
          } else {
              value.getBytes(buf, (int)indexCoder, String.UTF16);
          }
          return indexCoder;
      }
  
      /**
       * Instantiates the String with given buffer and coder
       * @param buf           buffer to use
       * @param indexCoder    remaining index (should be zero) and coder
       * @return String       resulting string
<span class="line-new-header">--- 280,113 ---</span>
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      integer value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     private static long prepend(long indexCoder, byte[] buf, int value) {</span>
          if (indexCoder &lt; UTF16) {
              return Integer.getChars(value, (int)indexCoder, buf);
          } else {
              return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">+      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">+      *                   into higher bits.</span>
<span class="line-added">+      * @param buf        buffer to append to</span>
<span class="line-added">+      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
<span class="line-added">+      * @return           updated index (coder value retained)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static long prepend(long indexCoder, byte[] buf, String prefix, int value, String suffix) {</span>
<span class="line-added">+         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Prepends the stringly representation of long value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      long value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     private static long prepend(long indexCoder, byte[] buf, long value) {</span>
          if (indexCoder &lt; UTF16) {
              return Long.getChars(value, (int)indexCoder, buf);
          } else {
              return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">+      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">+      *                   into higher bits.</span>
<span class="line-added">+      * @param buf        buffer to append to</span>
<span class="line-added">+      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
<span class="line-added">+      * @return           updated index (coder value retained)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static long prepend(long indexCoder, byte[] buf, String prefix, long value, String suffix) {</span>
<span class="line-added">+         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Prepends the stringly representation of String value into buffer,
       * given the coder and final index. Index is measured in chars, not in bytes!
       *
       * @param indexCoder final char index in the buffer, along with coder packed
       *                   into higher bits.
       * @param buf        buffer to append to
       * @param value      String value to encode
       * @return           updated index (coder value retained)
       */
<span class="line-modified">!     private static long prepend(long indexCoder, byte[] buf, String value) {</span>
          indexCoder -= value.length();
          if (indexCoder &lt; UTF16) {
              value.getBytes(buf, (int)indexCoder, String.LATIN1);
          } else {
              value.getBytes(buf, (int)indexCoder, String.UTF16);
          }
          return indexCoder;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">+      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">+      *                   into higher bits.</span>
<span class="line-added">+      * @param buf        buffer to append to</span>
<span class="line-added">+      * @param prefix     a constant to prepend before value</span>
<span class="line-added">+      * @param value      boolean value to encode</span>
<span class="line-added">+      * @param suffix     a constant to prepend after value</span>
<span class="line-added">+      * @return           updated index (coder value retained)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static long prepend(long indexCoder, byte[] buf, String prefix, String value, String suffix) {</span>
<span class="line-added">+         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">+         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">+         return indexCoder;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Instantiates the String with given buffer and coder
       * @param buf           buffer to use
       * @param indexCoder    remaining index (should be zero) and coder
       * @return String       resulting string
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,14 ***</span>
<span class="line-new-header">--- 400,66 ---</span>
          } else {
              throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Perform a simple concatenation between two objects. Added for startup</span>
<span class="line-added">+      * performance, but also demonstrates the code that would be emitted by</span>
<span class="line-added">+      * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}</span>
<span class="line-added">+      * for two Object arguments.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param first         first argument</span>
<span class="line-added">+      * @param second        second argument</span>
<span class="line-added">+      * @return String       resulting string</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     static String simpleConcat(Object first, Object second) {</span>
<span class="line-added">+         String s1 = stringOf(first);</span>
<span class="line-added">+         String s2 = stringOf(second);</span>
<span class="line-added">+         // start &quot;mixing&quot; in length and coder or arguments, order is not</span>
<span class="line-added">+         // important</span>
<span class="line-added">+         long indexCoder = mix(initialCoder(), s2);</span>
<span class="line-added">+         indexCoder = mix(indexCoder, s1);</span>
<span class="line-added">+         byte[] buf = newArray(indexCoder);</span>
<span class="line-added">+         // prepend each argument in reverse order, since we prepending</span>
<span class="line-added">+         // from the end of the byte array</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, s2);</span>
<span class="line-added">+         indexCoder = prepend(indexCoder, buf, s1);</span>
<span class="line-added">+         return newString(buf, indexCoder);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * We need some additional conversion for Objects in general, because</span>
<span class="line-added">+      * {@code String.valueOf(Object)} may return null. String conversion rules</span>
<span class="line-added">+      * in Java state we need to produce &quot;null&quot; String in this case, so we</span>
<span class="line-added">+      * provide a customized version that deals with this problematic corner case.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static String stringOf(Object value) {</span>
<span class="line-added">+         String s;</span>
<span class="line-added">+         return (value == null || (s = value.toString()) == null) ? &quot;null&quot; : s;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static final long LATIN1 = (long)String.LATIN1 &lt;&lt; 32;
  
      private static final long UTF16 = (long)String.UTF16 &lt;&lt; 32;
  
<span class="line-added">+     private static final Unsafe UNSAFE = Unsafe.getUnsafe();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Allocates an uninitialized byte array based on the length and coder information</span>
<span class="line-added">+      * in indexCoder</span>
<span class="line-added">+      * @param indexCoder</span>
<span class="line-added">+      * @return the newly allocated byte array</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     static byte[] newArray(long indexCoder) {</span>
<span class="line-added">+         byte coder = (byte)(indexCoder &gt;&gt; 32);</span>
<span class="line-added">+         int index = (int)indexCoder;</span>
<span class="line-added">+         return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, index &lt;&lt; coder);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Provides the initial coder for the String.
       * @return initial coder, adjusted into the upper half
       */
      static long initialCoder() {
</pre>
<center><a href="StringCoding.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringIndexOutOfBoundsException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
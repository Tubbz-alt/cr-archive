<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/Buffer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../net/doc-files/net-properties.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ByteBufferAs-X-Buffer.java.template.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/Buffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio;
 27 
 28 import jdk.internal.HotSpotIntrinsicCandidate;
 29 import jdk.internal.access.JavaNioAccess;
 30 import jdk.internal.access.SharedSecrets;

 31 import jdk.internal.misc.Unsafe;

 32 
 33 import java.util.Spliterator;
 34 
 35 /**
 36  * A container for data of a specific primitive type.
 37  *
 38  * &lt;p&gt; A buffer is a linear, finite sequence of elements of a specific
 39  * primitive type.  Aside from its content, the essential properties of a
 40  * buffer are its capacity, limit, and position: &lt;/p&gt;
 41  *
 42  * &lt;blockquote&gt;
 43  *
 44  *   &lt;p&gt; A buffer&#39;s &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains.  The
 45  *   capacity of a buffer is never negative and never changes.  &lt;/p&gt;
 46  *
 47  *   &lt;p&gt; A buffer&#39;s &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should
 48  *   not be read or written.  A buffer&#39;s limit is never negative and is never
 49  *   greater than its capacity.  &lt;/p&gt;
 50  *
 51  *   &lt;p&gt; A buffer&#39;s &lt;i&gt;position&lt;/i&gt; is the index of the next element to be
</pre>
<hr />
<pre>
196         Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;
197 
198     // Invariants: mark &lt;= position &lt;= limit &lt;= capacity
199     private int mark = -1;
200     private int position = 0;
201     private int limit;
202     private int capacity;
203 
204     // Used by heap byte buffers or direct buffers with Unsafe access
205     // For heap byte buffers this field will be the address relative to the
206     // array base address and offset into that array. The address might
207     // not align on a word boundary for slices, nor align at a long word
208     // (8 byte) boundary for byte[] allocations on 32-bit systems.
209     // For direct buffers it is the start address of the memory region. The
210     // address might not align on a word boundary for slices, nor when created
211     // using JNI, see NewDirectByteBuffer(void*, long).
212     // Should ideally be declared final
213     // NOTE: hoisted here for speed in JNI GetDirectBufferAddress
214     long address;
215 












216     // Creates a new buffer with the given mark, position, limit, and capacity,
217     // after checking invariants.
218     //
<span class="line-modified">219     Buffer(int mark, int pos, int lim, int cap) {       // package-private</span>
220         if (cap &lt; 0)
221             throw createCapacityException(cap);
222         this.capacity = cap;

223         limit(lim);
224         position(pos);
225         if (mark &gt;= 0) {
226             if (mark &gt; pos)
227                 throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;
228                                                    + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);
229             this.mark = mark;
230         }
231     }
232 
233     /**
234      * Returns an {@code IllegalArgumentException} indicating that the source
235      * and target are the same {@code Buffer}.  Intended for use in
236      * {@code put(src)} when the parameter is the {@code Buffer} on which the
237      * method is being invoked.
238      *
239      * @return  IllegalArgumentException
240      *          With a message indicating equal source and target buffers
241      */
242     static IllegalArgumentException createSameBufferException() {
243         return new IllegalArgumentException(&quot;The source buffer is this buffer&quot;);
244     }
245 
246     /**
247      * Verify that the capacity is nonnegative.
248      *
249      * @param  capacity
250      *         The new buffer&#39;s capacity, in $type$s
251      *
<span class="line-modified">252      * @throws  IllegalArgumentException</span>
<span class="line-modified">253      *          If the {@code capacity} is a negative integer</span>
254      */
255     static IllegalArgumentException createCapacityException(int capacity) {
256         assert capacity &lt; 0 : &quot;capacity expected to be negative&quot;;
257         return new IllegalArgumentException(&quot;capacity &lt; 0: (&quot;
258             + capacity + &quot; &lt; 0)&quot;);
259     }
260 
261     /**
262      * Returns this buffer&#39;s capacity.
263      *
264      * @return  The capacity of this buffer
265      */
266     public final int capacity() {
267         return capacity;
268     }
269 
270     /**
271      * Returns this buffer&#39;s position.
272      *
273      * @return  The position of this buffer
</pre>
<hr />
<pre>
714     final int checkIndex(int i) {                       // package-private
715         if ((i &lt; 0) || (i &gt;= limit))
716             throw new IndexOutOfBoundsException();
717         return i;
718     }
719 
720     final int checkIndex(int i, int nb) {               // package-private
721         if ((i &lt; 0) || (nb &gt; limit - i))
722             throw new IndexOutOfBoundsException();
723         return i;
724     }
725 
726     final int markValue() {                             // package-private
727         return mark;
728     }
729 
730     final void discardMark() {                          // package-private
731         mark = -1;
732     }
733 
<span class="line-modified">734     static void checkBounds(int off, int len, int size) { // package-private</span>
<span class="line-modified">735         if ((off | len | (off + len) | (size - (off + len))) &lt; 0)</span>
<span class="line-modified">736             throw new IndexOutOfBoundsException();</span>


737     }
738 
739     static {
740         // setup access to this package in SharedSecrets
741         SharedSecrets.setJavaNioAccess(
742             new JavaNioAccess() {
743                 @Override
744                 public JavaNioAccess.BufferPool getDirectBufferPool() {
745                     return Bits.BUFFER_POOL;
746                 }

























747             });
748     }
749 
750 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio;
 27 
 28 import jdk.internal.HotSpotIntrinsicCandidate;
 29 import jdk.internal.access.JavaNioAccess;
 30 import jdk.internal.access.SharedSecrets;
<span class="line-added"> 31 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
 32 import jdk.internal.misc.Unsafe;
<span class="line-added"> 33 import jdk.internal.vm.annotation.ForceInline;</span>
 34 
 35 import java.util.Spliterator;
 36 
 37 /**
 38  * A container for data of a specific primitive type.
 39  *
 40  * &lt;p&gt; A buffer is a linear, finite sequence of elements of a specific
 41  * primitive type.  Aside from its content, the essential properties of a
 42  * buffer are its capacity, limit, and position: &lt;/p&gt;
 43  *
 44  * &lt;blockquote&gt;
 45  *
 46  *   &lt;p&gt; A buffer&#39;s &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains.  The
 47  *   capacity of a buffer is never negative and never changes.  &lt;/p&gt;
 48  *
 49  *   &lt;p&gt; A buffer&#39;s &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should
 50  *   not be read or written.  A buffer&#39;s limit is never negative and is never
 51  *   greater than its capacity.  &lt;/p&gt;
 52  *
 53  *   &lt;p&gt; A buffer&#39;s &lt;i&gt;position&lt;/i&gt; is the index of the next element to be
</pre>
<hr />
<pre>
198         Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;
199 
200     // Invariants: mark &lt;= position &lt;= limit &lt;= capacity
201     private int mark = -1;
202     private int position = 0;
203     private int limit;
204     private int capacity;
205 
206     // Used by heap byte buffers or direct buffers with Unsafe access
207     // For heap byte buffers this field will be the address relative to the
208     // array base address and offset into that array. The address might
209     // not align on a word boundary for slices, nor align at a long word
210     // (8 byte) boundary for byte[] allocations on 32-bit systems.
211     // For direct buffers it is the start address of the memory region. The
212     // address might not align on a word boundary for slices, nor when created
213     // using JNI, see NewDirectByteBuffer(void*, long).
214     // Should ideally be declared final
215     // NOTE: hoisted here for speed in JNI GetDirectBufferAddress
216     long address;
217 
<span class="line-added">218     // Used by buffers generated by the memory access API (JEP-370)</span>
<span class="line-added">219     final MemorySegmentProxy segment;</span>
<span class="line-added">220 </span>
<span class="line-added">221 </span>
<span class="line-added">222     // Creates a new buffer with given address and capacity.</span>
<span class="line-added">223     //</span>
<span class="line-added">224     Buffer(long addr, int cap, MemorySegmentProxy segment) {</span>
<span class="line-added">225         this.address = addr;</span>
<span class="line-added">226         this.capacity = cap;</span>
<span class="line-added">227         this.segment = segment;</span>
<span class="line-added">228     }</span>
<span class="line-added">229 </span>
230     // Creates a new buffer with the given mark, position, limit, and capacity,
231     // after checking invariants.
232     //
<span class="line-modified">233     Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) {       // package-private</span>
234         if (cap &lt; 0)
235             throw createCapacityException(cap);
236         this.capacity = cap;
<span class="line-added">237         this.segment = segment;</span>
238         limit(lim);
239         position(pos);
240         if (mark &gt;= 0) {
241             if (mark &gt; pos)
242                 throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;
243                                                    + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);
244             this.mark = mark;
245         }
246     }
247 
248     /**
249      * Returns an {@code IllegalArgumentException} indicating that the source
250      * and target are the same {@code Buffer}.  Intended for use in
251      * {@code put(src)} when the parameter is the {@code Buffer} on which the
252      * method is being invoked.
253      *
254      * @return  IllegalArgumentException
255      *          With a message indicating equal source and target buffers
256      */
257     static IllegalArgumentException createSameBufferException() {
258         return new IllegalArgumentException(&quot;The source buffer is this buffer&quot;);
259     }
260 
261     /**
262      * Verify that the capacity is nonnegative.
263      *
264      * @param  capacity
265      *         The new buffer&#39;s capacity, in $type$s
266      *
<span class="line-modified">267      * @throws IllegalArgumentException</span>
<span class="line-modified">268      *         If the {@code capacity} is a negative integer</span>
269      */
270     static IllegalArgumentException createCapacityException(int capacity) {
271         assert capacity &lt; 0 : &quot;capacity expected to be negative&quot;;
272         return new IllegalArgumentException(&quot;capacity &lt; 0: (&quot;
273             + capacity + &quot; &lt; 0)&quot;);
274     }
275 
276     /**
277      * Returns this buffer&#39;s capacity.
278      *
279      * @return  The capacity of this buffer
280      */
281     public final int capacity() {
282         return capacity;
283     }
284 
285     /**
286      * Returns this buffer&#39;s position.
287      *
288      * @return  The position of this buffer
</pre>
<hr />
<pre>
729     final int checkIndex(int i) {                       // package-private
730         if ((i &lt; 0) || (i &gt;= limit))
731             throw new IndexOutOfBoundsException();
732         return i;
733     }
734 
735     final int checkIndex(int i, int nb) {               // package-private
736         if ((i &lt; 0) || (nb &gt; limit - i))
737             throw new IndexOutOfBoundsException();
738         return i;
739     }
740 
741     final int markValue() {                             // package-private
742         return mark;
743     }
744 
745     final void discardMark() {                          // package-private
746         mark = -1;
747     }
748 
<span class="line-modified">749     @ForceInline</span>
<span class="line-modified">750     final void checkSegment() {</span>
<span class="line-modified">751         if (segment != null) {</span>
<span class="line-added">752             segment.checkValidState();</span>
<span class="line-added">753         }</span>
754     }
755 
756     static {
757         // setup access to this package in SharedSecrets
758         SharedSecrets.setJavaNioAccess(
759             new JavaNioAccess() {
760                 @Override
761                 public JavaNioAccess.BufferPool getDirectBufferPool() {
762                     return Bits.BUFFER_POOL;
763                 }
<span class="line-added">764 </span>
<span class="line-added">765                 @Override</span>
<span class="line-added">766                 public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment) {</span>
<span class="line-added">767                     return new DirectByteBuffer(addr, cap, obj, segment);</span>
<span class="line-added">768                 }</span>
<span class="line-added">769 </span>
<span class="line-added">770                 @Override</span>
<span class="line-added">771                 public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment) {</span>
<span class="line-added">772                     return new HeapByteBuffer(hb, offset, capacity, segment);</span>
<span class="line-added">773                 }</span>
<span class="line-added">774 </span>
<span class="line-added">775                 @Override</span>
<span class="line-added">776                 public Object getBufferBase(ByteBuffer bb) {</span>
<span class="line-added">777                     return bb.base();</span>
<span class="line-added">778                 }</span>
<span class="line-added">779 </span>
<span class="line-added">780                 @Override</span>
<span class="line-added">781                 public long getBufferAddress(ByteBuffer bb) {</span>
<span class="line-added">782                     return bb.address;</span>
<span class="line-added">783                 }</span>
<span class="line-added">784 </span>
<span class="line-added">785                 @Override</span>
<span class="line-added">786                 public void checkSegment(Buffer buffer) {</span>
<span class="line-added">787                     buffer.checkSegment();</span>
<span class="line-added">788                 }</span>
789             });
790     }
791 
792 }
</pre>
</td>
</tr>
</table>
<center><a href="../net/doc-files/net-properties.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ByteBufferAs-X-Buffer.java.template.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
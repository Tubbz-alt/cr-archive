<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/time/chrono/ChronoLocalDateImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 28  *
 29  * All rights reserved.
 30  *
 31  * Redistribution and use in source and binary forms, with or without
 32  * modification, are permitted provided that the following conditions are met:
 33  *
 34  *  * Redistributions of source code must retain the above copyright notice,
 35  *    this list of conditions and the following disclaimer.
 36  *
 37  *  * Redistributions in binary form must reproduce the above copyright notice,
 38  *    this list of conditions and the following disclaimer in the documentation
 39  *    and/or other materials provided with the distribution.
 40  *
 41  *  * Neither the name of JSR-310 nor the names of its contributors
 42  *    may be used to endorse or promote products derived from this software
 43  *    without specific prior written permission.
 44  *
 45  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 46  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 47  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 48  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 49  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 50  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 51  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 52  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 53  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 54  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 55  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 56  */
 57 package java.time.chrono;
 58 
 59 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
 60 import static java.time.temporal.ChronoField.ERA;
 61 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
 62 import static java.time.temporal.ChronoField.PROLEPTIC_MONTH;
 63 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
 64 
 65 import java.io.Serializable;
 66 import java.time.DateTimeException;
 67 import java.time.temporal.ChronoUnit;
 68 import java.time.temporal.Temporal;
 69 import java.time.temporal.TemporalAdjuster;
 70 import java.time.temporal.TemporalAmount;
 71 import java.time.temporal.TemporalField;
 72 import java.time.temporal.TemporalUnit;
 73 import java.time.temporal.UnsupportedTemporalTypeException;
 74 import java.time.temporal.ValueRange;
 75 import java.util.Objects;
 76 
 77 /**
 78  * A date expressed in terms of a standard year-month-day calendar system.
 79  * &lt;p&gt;
 80  * This class is used by applications seeking to handle dates in non-ISO calendar systems.
 81  * For example, the Japanese, Minguo, Thai Buddhist and others.
 82  * &lt;p&gt;
 83  * {@code ChronoLocalDate} is built on the generic concepts of year, month and day.
 84  * The calendar system, represented by a {@link java.time.chrono.Chronology}, expresses the relationship between
 85  * the fields and this class allows the resulting date to be manipulated.
 86  * &lt;p&gt;
 87  * Note that not all calendar systems are suitable for use with this class.
 88  * For example, the Mayan calendar uses a system that bears no relation to years, months and days.
 89  * &lt;p&gt;
 90  * The API design encourages the use of {@code LocalDate} for the majority of the application.
 91  * This includes code to read and write from a persistent data store, such as a database,
 92  * and to send dates and times across a network. The {@code ChronoLocalDate} instance is then used
 93  * at the user interface level to deal with localized input/output.
 94  *
 95  * &lt;P&gt;Example: &lt;/p&gt;
 96  * &lt;pre&gt;
 97  *        System.out.printf(&quot;Example()%n&quot;);
 98  *        // Enumerate the list of available calendars and print today for each
 99  *        Set&amp;lt;Chronology&amp;gt; chronos = Chronology.getAvailableChronologies();
100  *        for (Chronology chrono : chronos) {
101  *            ChronoLocalDate date = chrono.dateNow();
102  *            System.out.printf(&quot;   %20s: %s%n&quot;, chrono.getID(), date.toString());
103  *        }
104  *
105  *        // Print the Hijrah date and calendar
106  *        ChronoLocalDate date = Chronology.of(&quot;Hijrah&quot;).dateNow();
107  *        int day = date.get(ChronoField.DAY_OF_MONTH);
108  *        int dow = date.get(ChronoField.DAY_OF_WEEK);
109  *        int month = date.get(ChronoField.MONTH_OF_YEAR);
110  *        int year = date.get(ChronoField.YEAR);
111  *        System.out.printf(&quot;  Today is %s %s %d-%s-%d%n&quot;, date.getChronology().getID(),
112  *                dow, day, month, year);
113  *
114  *        // Print today&#39;s date and the last day of the year
115  *        ChronoLocalDate now1 = Chronology.of(&quot;Hijrah&quot;).dateNow();
116  *        ChronoLocalDate first = now1.with(ChronoField.DAY_OF_MONTH, 1)
117  *                .with(ChronoField.MONTH_OF_YEAR, 1);
118  *        ChronoLocalDate last = first.plus(1, ChronoUnit.YEARS)
119  *                .minus(1, ChronoUnit.DAYS);
120  *        System.out.printf(&quot;  Today is %s: start: %s; end: %s%n&quot;, last.getChronology().getID(),
121  *                first, last);
122  * &lt;/pre&gt;
123  *
124  * &lt;h2&gt;Adding Calendars&lt;/h2&gt;
125  * &lt;p&gt; The set of calendars is extensible by defining a subclass of {@link ChronoLocalDate}
126  * to represent a date instance and an implementation of {@code Chronology}
127  * to be the factory for the ChronoLocalDate subclass.
128  * &lt;/p&gt;
129  * &lt;p&gt; To permit the discovery of the additional calendar types the implementation of
130  * {@code Chronology} must be registered as a Service implementing the {@code Chronology} interface
131  * in the {@code META-INF/Services} file as per the specification of {@link java.util.ServiceLoader}.
132  * The subclass must function according to the {@code Chronology} class description and must provide its
133  * {@link java.time.chrono.Chronology#getId() chronlogy ID} and {@link Chronology#getCalendarType() calendar type}. &lt;/p&gt;
134  *
135  * @implSpec
136  * This abstract class must be implemented with care to ensure other classes operate correctly.
137  * All implementations that can be instantiated must be final, immutable and thread-safe.
138  * Subclasses should be Serializable wherever possible.
139  *
140  * @param &lt;D&gt; the ChronoLocalDate of this date-time
141  * @since 1.8
142  */
143 abstract class ChronoLocalDateImpl&lt;D extends ChronoLocalDate&gt;
144         implements ChronoLocalDate, Temporal, TemporalAdjuster, Serializable {
145 
146     /**
147      * Serialization version.
148      */
149     @java.io.Serial
150     private static final long serialVersionUID = 6282433883239719096L;
151 
152     /**
153      * Casts the {@code Temporal} to {@code ChronoLocalDate} ensuring it bas the specified chronology.
154      *
155      * @param chrono  the chronology to check for, not null
156      * @param temporal  a date-time to cast, not null
157      * @return the date-time checked and cast to {@code ChronoLocalDate}, not null
158      * @throws ClassCastException if the date-time cannot be cast to ChronoLocalDate
159      *  or the chronology is not equal this Chronology
160      */
161     static &lt;D extends ChronoLocalDate&gt; D ensureValid(Chronology chrono, Temporal temporal) {
162         @SuppressWarnings(&quot;unchecked&quot;)
163         D other = (D) temporal;
164         if (chrono.equals(other.getChronology()) == false) {
165             throw new ClassCastException(&quot;Chronology mismatch, expected: &quot; + chrono.getId() + &quot;, actual: &quot; + other.getChronology().getId());
166         }
167         return other;
168     }
169 
170     //-----------------------------------------------------------------------
171     /**
172      * Creates an instance.
173      */
174     ChronoLocalDateImpl() {
175     }
176 
177     @Override
178     @SuppressWarnings(&quot;unchecked&quot;)
179     public D with(TemporalAdjuster adjuster) {
180         return (D) ChronoLocalDate.super.with(adjuster);
181     }
182 
183     @Override
184     @SuppressWarnings(&quot;unchecked&quot;)
185     public D with(TemporalField field, long value) {
186         return (D) ChronoLocalDate.super.with(field, value);
187     }
188 
189     //-----------------------------------------------------------------------
190     @Override
191     @SuppressWarnings(&quot;unchecked&quot;)
192     public D plus(TemporalAmount amount) {
193         return (D) ChronoLocalDate.super.plus(amount);
194     }
195 
196     //-----------------------------------------------------------------------
197     @Override
198     @SuppressWarnings(&quot;unchecked&quot;)
199     public D plus(long amountToAdd, TemporalUnit unit) {
200         if (unit instanceof ChronoUnit) {
201             ChronoUnit f = (ChronoUnit) unit;
202             switch (f) {
203                 case DAYS: return plusDays(amountToAdd);
204                 case WEEKS: return plusDays(Math.multiplyExact(amountToAdd, 7));
205                 case MONTHS: return plusMonths(amountToAdd);
206                 case YEARS: return plusYears(amountToAdd);
207                 case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));
208                 case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));
209                 case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));
210                 case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));
211             }
212             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
213         }
214         return (D) ChronoLocalDate.super.plus(amountToAdd, unit);
215     }
216 
217     @Override
218     @SuppressWarnings(&quot;unchecked&quot;)
219     public D minus(TemporalAmount amount) {
220         return (D) ChronoLocalDate.super.minus(amount);
221     }
222 
223     @Override
224     @SuppressWarnings(&quot;unchecked&quot;)
225     public D minus(long amountToSubtract, TemporalUnit unit) {
226         return (D) ChronoLocalDate.super.minus(amountToSubtract, unit);
227     }
228 
229     //-----------------------------------------------------------------------
230     /**
231      * Returns a copy of this date with the specified number of years added.
232      * &lt;p&gt;
233      * This adds the specified period in years to the date.
234      * In some cases, adding years can cause the resulting date to become invalid.
235      * If this occurs, then other fields, typically the day-of-month, will be adjusted to ensure
236      * that the result is valid. Typically this will select the last valid day of the month.
237      * &lt;p&gt;
238      * This instance is immutable and unaffected by this method call.
239      *
240      * @param yearsToAdd  the years to add, may be negative
241      * @return a date based on this one with the years added, not null
242      * @throws DateTimeException if the result exceeds the supported date range
243      */
244     abstract D plusYears(long yearsToAdd);
245 
246     /**
247      * Returns a copy of this date with the specified number of months added.
248      * &lt;p&gt;
249      * This adds the specified period in months to the date.
250      * In some cases, adding months can cause the resulting date to become invalid.
251      * If this occurs, then other fields, typically the day-of-month, will be adjusted to ensure
252      * that the result is valid. Typically this will select the last valid day of the month.
253      * &lt;p&gt;
254      * This instance is immutable and unaffected by this method call.
255      *
256      * @param monthsToAdd  the months to add, may be negative
257      * @return a date based on this one with the months added, not null
258      * @throws DateTimeException if the result exceeds the supported date range
259      */
260     abstract D plusMonths(long monthsToAdd);
261 
262     /**
263      * Returns a copy of this date with the specified number of weeks added.
264      * &lt;p&gt;
265      * This adds the specified period in weeks to the date.
266      * In some cases, adding weeks can cause the resulting date to become invalid.
267      * If this occurs, then other fields will be adjusted to ensure that the result is valid.
268      * &lt;p&gt;
269      * The default implementation uses {@link #plusDays(long)} using a 7 day week.
270      * &lt;p&gt;
271      * This instance is immutable and unaffected by this method call.
272      *
273      * @param weeksToAdd  the weeks to add, may be negative
274      * @return a date based on this one with the weeks added, not null
275      * @throws DateTimeException if the result exceeds the supported date range
276      */
277     D plusWeeks(long weeksToAdd) {
278         return plusDays(Math.multiplyExact(weeksToAdd, 7));
279     }
280 
281     /**
282      * Returns a copy of this date with the specified number of days added.
283      * &lt;p&gt;
284      * This adds the specified period in days to the date.
285      * &lt;p&gt;
286      * This instance is immutable and unaffected by this method call.
287      *
288      * @param daysToAdd  the days to add, may be negative
289      * @return a date based on this one with the days added, not null
290      * @throws DateTimeException if the result exceeds the supported date range
291      */
292     abstract D plusDays(long daysToAdd);
293 
294     //-----------------------------------------------------------------------
295     /**
296      * Returns a copy of this date with the specified number of years subtracted.
297      * &lt;p&gt;
298      * This subtracts the specified period in years to the date.
299      * In some cases, subtracting years can cause the resulting date to become invalid.
300      * If this occurs, then other fields, typically the day-of-month, will be adjusted to ensure
301      * that the result is valid. Typically this will select the last valid day of the month.
302      * &lt;p&gt;
303      * The default implementation uses {@link #plusYears(long)}.
304      * &lt;p&gt;
305      * This instance is immutable and unaffected by this method call.
306      *
307      * @param yearsToSubtract  the years to subtract, may be negative
308      * @return a date based on this one with the years subtracted, not null
309      * @throws DateTimeException if the result exceeds the supported date range
310      */
311     @SuppressWarnings(&quot;unchecked&quot;)
312     D minusYears(long yearsToSubtract) {
313         return (yearsToSubtract == Long.MIN_VALUE ? ((ChronoLocalDateImpl&lt;D&gt;)plusYears(Long.MAX_VALUE)).plusYears(1) : plusYears(-yearsToSubtract));
314     }
315 
316     /**
317      * Returns a copy of this date with the specified number of months subtracted.
318      * &lt;p&gt;
319      * This subtracts the specified period in months to the date.
320      * In some cases, subtracting months can cause the resulting date to become invalid.
321      * If this occurs, then other fields, typically the day-of-month, will be adjusted to ensure
322      * that the result is valid. Typically this will select the last valid day of the month.
323      * &lt;p&gt;
324      * The default implementation uses {@link #plusMonths(long)}.
325      * &lt;p&gt;
326      * This instance is immutable and unaffected by this method call.
327      *
328      * @param monthsToSubtract  the months to subtract, may be negative
329      * @return a date based on this one with the months subtracted, not null
330      * @throws DateTimeException if the result exceeds the supported date range
331      */
332     @SuppressWarnings(&quot;unchecked&quot;)
333     D minusMonths(long monthsToSubtract) {
334         return (monthsToSubtract == Long.MIN_VALUE ? ((ChronoLocalDateImpl&lt;D&gt;)plusMonths(Long.MAX_VALUE)).plusMonths(1) : plusMonths(-monthsToSubtract));
335     }
336 
337     /**
338      * Returns a copy of this date with the specified number of weeks subtracted.
339      * &lt;p&gt;
340      * This subtracts the specified period in weeks to the date.
341      * In some cases, subtracting weeks can cause the resulting date to become invalid.
342      * If this occurs, then other fields will be adjusted to ensure that the result is valid.
343      * &lt;p&gt;
344      * The default implementation uses {@link #plusWeeks(long)}.
345      * &lt;p&gt;
346      * This instance is immutable and unaffected by this method call.
347      *
348      * @param weeksToSubtract  the weeks to subtract, may be negative
349      * @return a date based on this one with the weeks subtracted, not null
350      * @throws DateTimeException if the result exceeds the supported date range
351      */
352     @SuppressWarnings(&quot;unchecked&quot;)
353     D minusWeeks(long weeksToSubtract) {
354         return (weeksToSubtract == Long.MIN_VALUE ? ((ChronoLocalDateImpl&lt;D&gt;)plusWeeks(Long.MAX_VALUE)).plusWeeks(1) : plusWeeks(-weeksToSubtract));
355     }
356 
357     /**
358      * Returns a copy of this date with the specified number of days subtracted.
359      * &lt;p&gt;
360      * This subtracts the specified period in days to the date.
361      * &lt;p&gt;
362      * The default implementation uses {@link #plusDays(long)}.
363      * &lt;p&gt;
364      * This instance is immutable and unaffected by this method call.
365      *
366      * @param daysToSubtract  the days to subtract, may be negative
367      * @return a date based on this one with the days subtracted, not null
368      * @throws DateTimeException if the result exceeds the supported date range
369      */
370     @SuppressWarnings(&quot;unchecked&quot;)
371     D minusDays(long daysToSubtract) {
372         return (daysToSubtract == Long.MIN_VALUE ? ((ChronoLocalDateImpl&lt;D&gt;)plusDays(Long.MAX_VALUE)).plusDays(1) : plusDays(-daysToSubtract));
373     }
374 
375     //-----------------------------------------------------------------------
376     @Override
377     public long until(Temporal endExclusive, TemporalUnit unit) {
378         Objects.requireNonNull(endExclusive, &quot;endExclusive&quot;);
379         ChronoLocalDate end = getChronology().date(endExclusive);
380         if (unit instanceof ChronoUnit) {
381             switch ((ChronoUnit) unit) {
382                 case DAYS: return daysUntil(end);
383                 case WEEKS: return daysUntil(end) / 7;
384                 case MONTHS: return monthsUntil(end);
385                 case YEARS: return monthsUntil(end) / 12;
386                 case DECADES: return monthsUntil(end) / 120;
387                 case CENTURIES: return monthsUntil(end) / 1200;
388                 case MILLENNIA: return monthsUntil(end) / 12000;
389                 case ERAS: return end.getLong(ERA) - getLong(ERA);
390             }
391             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
392         }
393         Objects.requireNonNull(unit, &quot;unit&quot;);
394         return unit.between(this, end);
395     }
396 
397     private long daysUntil(ChronoLocalDate end) {
398         return end.toEpochDay() - toEpochDay();  // no overflow
399     }
400 
401     private long monthsUntil(ChronoLocalDate end) {
402         ValueRange range = getChronology().range(MONTH_OF_YEAR);
403         if (range.getMaximum() != 12) {
404             throw new IllegalStateException(&quot;ChronoLocalDateImpl only supports Chronologies with 12 months per year&quot;);
405         }
406         long packed1 = getLong(PROLEPTIC_MONTH) * 32L + get(DAY_OF_MONTH);  // no overflow
407         long packed2 = end.getLong(PROLEPTIC_MONTH) * 32L + end.get(DAY_OF_MONTH);  // no overflow
408         return (packed2 - packed1) / 32;
409     }
410 
411     @Override
412     public boolean equals(Object obj) {
413         if (this == obj) {
414             return true;
415         }
416         if (obj instanceof ChronoLocalDate) {
417             return compareTo((ChronoLocalDate) obj) == 0;
418         }
419         return false;
420     }
421 
422     @Override
423     public int hashCode() {
424         long epDay = toEpochDay();
425         return getChronology().hashCode() ^ ((int) (epDay ^ (epDay &gt;&gt;&gt; 32)));
426     }
427 
428     @Override
429     public String toString() {
430         // getLong() reduces chances of exceptions in toString()
431         long yoe = getLong(YEAR_OF_ERA);
432         long moy = getLong(MONTH_OF_YEAR);
433         long dom = getLong(DAY_OF_MONTH);
434         StringBuilder buf = new StringBuilder(30);
435         buf.append(getChronology().toString())
436                 .append(&quot; &quot;)
437                 .append(getEra())
438                 .append(&quot; &quot;)
439                 .append(yoe)
440                 .append(moy &lt; 10 ? &quot;-0&quot; : &quot;-&quot;).append(moy)
441                 .append(dom &lt; 10 ? &quot;-0&quot; : &quot;-&quot;).append(dom);
442         return buf.toString();
443     }
444 
445 }
    </pre>
  </body>
</html>
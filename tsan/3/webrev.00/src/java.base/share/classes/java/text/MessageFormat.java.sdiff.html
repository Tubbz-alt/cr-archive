<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/MessageFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MergeCollation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Normalizer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/MessageFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.text.DecimalFormat;
  45 import java.util.ArrayList;
  46 import java.util.Arrays;
  47 import java.util.Date;
  48 import java.util.List;
  49 import java.util.Locale;
  50 
  51 
  52 /**
<span class="line-modified">  53  * &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated</span>
  54  * messages in a language-neutral way. Use this to construct messages
  55  * displayed for end users.
  56  *
  57  * &lt;p&gt;
<span class="line-modified">  58  * &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then</span>
  59  * inserts the formatted strings into the pattern at the appropriate places.
  60  *
  61  * &lt;p&gt;
  62  * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified">  63  * &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified">  64  * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one</span>
<span class="line-modified">  65  * of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory</span>
<span class="line-modified">  66  * method). The factory methods aren&#39;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;</span>
  67  * itself doesn&#39;t implement locale specific behavior. Any locale specific
  68  * behavior is defined by the pattern that you provide as well as the
  69  * subformats used for inserted arguments.
  70  *
<span class="line-modified">  71  * &lt;h3&gt;&lt;a id=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h3&gt;</span>
  72  *
<span class="line-modified">  73  * &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:</span>
  74  * &lt;blockquote&gt;&lt;pre&gt;
  75  * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
  76  *         &lt;i&gt;String&lt;/i&gt;
  77  *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
  78  *
  79  * &lt;i&gt;FormatElement:&lt;/i&gt;
  80  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
  81  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
  82  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
  83  *
  84  * &lt;i&gt;FormatType: one of &lt;/i&gt;
  85  *         number date time choice
  86  *
  87  * &lt;i&gt;FormatStyle:&lt;/i&gt;
  88  *         short
  89  *         medium
  90  *         long
  91  *         full
  92  *         integer
  93  *         currency
  94  *         percent
  95  *         &lt;i&gt;SubformatPattern&lt;/i&gt;
  96  * &lt;/pre&gt;&lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
  99  * quote any arbitrary characters except single quotes. For example,
 100  * pattern string &lt;code&gt;&quot;&#39;{0}&#39;&quot;&lt;/code&gt; represents string
 101  * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
 102  * must be represented by doubled single quotes {@code &#39;&#39;} throughout a
 103  * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&#39;{&#39;&#39;}&#39;&quot;&lt;/code&gt; is
 104  * interpreted as a sequence of &lt;code&gt;&#39;{&lt;/code&gt; (start of quoting and a
<span class="line-modified"> 105  * left curly brace), &lt;code&gt;&#39;&#39;&lt;/code&gt; (a single quote), and</span>
 106  * &lt;code&gt;}&#39;&lt;/code&gt; (a right curly brace and end of quoting),
 107  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&#39;{&#39;&lt;/code&gt; and &lt;code&gt;&#39;}&#39;&lt;/code&gt; (quoted left and
 108  * right curly braces): representing string &lt;code&gt;&quot;{&#39;}&quot;&lt;/code&gt;,
 109  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
 110  *
 111  * &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
 112  * subformat, and subformat-dependent pattern rules apply. For example,
 113  * pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$&#39;#&#39;,##&lt;/u&gt;}&quot;&lt;/code&gt;
 114  * (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
 115  * with the pound-sign quoted, with a result such as: {@code
 116  * &quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for
 117  * details.
 118  *
 119  * &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
 120  * pattern. For example, pattern string {@code &quot;&#39;{0}&quot;} is treated as
 121  * pattern {@code &quot;&#39;{0}&#39;&quot;}.
 122  *
 123  * &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
 124  * example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab &#39;}&#39; de&quot;&lt;/code&gt; are
 125  * valid patterns, but &lt;code&gt;&quot;ab {0&#39;}&#39; de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt;
</pre>
<hr />
<pre>
 203  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 204  *    &lt;tr&gt;
 205  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code medium}
 206  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 207  *    &lt;tr&gt;
 208  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code long}
 209  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 210  *    &lt;tr&gt;
 211  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code full}
 212  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 213  *    &lt;tr&gt;
 214  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 215  *       &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 216  *    &lt;tr&gt;
 217  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code choice}
 218  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 219  *       &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 220  * &lt;/tbody&gt;
 221  * &lt;/table&gt;
 222  *
<span class="line-modified"> 223  * &lt;h4&gt;Usage Information&lt;/h4&gt;</span>
 224  *
 225  * &lt;p&gt;
 226  * Here are some examples of usage.
 227  * In real internationalized programs, the message format pattern and other
 228  * static strings will, of course, be obtained from resource bundles.
 229  * Other parameters will be dynamically determined at runtime.
 230  * &lt;p&gt;
<span class="line-modified"> 231  * The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,</span>
<span class="line-modified"> 232  * which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:</span>
 233  * &lt;blockquote&gt;&lt;pre&gt;
 234  * int planet = 7;
 235  * String event = &quot;a disturbance in the Force&quot;;
 236  *
 237  * String result = MessageFormat.format(
 238  *     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
 239  *     planet, new Date(), event);
 240  * &lt;/pre&gt;&lt;/blockquote&gt;
 241  * The output is:
 242  * &lt;blockquote&gt;&lt;pre&gt;
 243  * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 244  * &lt;/pre&gt;&lt;/blockquote&gt;
 245  *
 246  * &lt;p&gt;
<span class="line-modified"> 247  * The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that</span>
 248  * can be used repeatedly:
 249  * &lt;blockquote&gt;&lt;pre&gt;
 250  * int fileCount = 1273;
 251  * String diskName = &quot;MyDisk&quot;;
 252  * Object[] testArgs = {new Long(fileCount), diskName};
 253  *
 254  * MessageFormat form = new MessageFormat(
 255  *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
 256  *
 257  * System.out.println(form.format(testArgs));
 258  * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified"> 259  * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</span>
 260  * &lt;blockquote&gt;&lt;pre&gt;
 261  * The disk &quot;MyDisk&quot; contains 0 file(s).
 262  * The disk &quot;MyDisk&quot; contains 1 file(s).
 263  * The disk &quot;MyDisk&quot; contains 1,273 file(s).
 264  * &lt;/pre&gt;&lt;/blockquote&gt;
 265  *
 266  * &lt;p&gt;
<span class="line-modified"> 267  * For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
 268  * to produce correct forms for singular and plural:
 269  * &lt;blockquote&gt;&lt;pre&gt;
 270  * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 271  * double[] filelimits = {0,1,2};
 272  * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 273  * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 274  * form.setFormatByArgumentIndex(0, fileform);
 275  *
 276  * int fileCount = 1273;
 277  * String diskName = &quot;MyDisk&quot;;
 278  * Object[] testArgs = {new Long(fileCount), diskName};
 279  *
 280  * System.out.println(form.format(testArgs));
 281  * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified"> 282  * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</span>
 283  * &lt;blockquote&gt;&lt;pre&gt;
 284  * The disk &quot;MyDisk&quot; contains no files.
 285  * The disk &quot;MyDisk&quot; contains one file.
 286  * The disk &quot;MyDisk&quot; contains 1,273 files.
 287  * &lt;/pre&gt;&lt;/blockquote&gt;
 288  *
 289  * &lt;p&gt;
<span class="line-modified"> 290  * You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the</span>
 291  * above example, or by using a pattern. See {@link ChoiceFormat}
 292  * for more information.
 293  * &lt;blockquote&gt;&lt;pre&gt;{@code
 294  * form.applyPattern(
 295  *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
 296  * }&lt;/pre&gt;&lt;/blockquote&gt;
 297  *
 298  * &lt;p&gt;
 299  * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
<span class="line-modified"> 300  * by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;</span>
 301  * occurrences of &#39;{&#39; are used to indicate subformats, and cause recursion.
<span class="line-modified"> 302  * If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
 303  * programmatically (instead of using the string patterns), then be careful not to
 304  * produce a format that recurses on itself, which will cause an infinite loop.
 305  * &lt;p&gt;
 306  * When a single argument is parsed more than once in the string, the last match
 307  * will be the final result of the parsing.  For example,
 308  * &lt;blockquote&gt;&lt;pre&gt;
 309  * MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 310  * Object[] objs = {new Double(3.1415)};
 311  * String result = mf.format( objs );
 312  * // result now equals &quot;3.14, 3.1&quot;
 313  * objs = null;
 314  * objs = mf.parse(result, new ParsePosition(0));
 315  * // objs now equals {new Double(3.1)}
 316  * &lt;/pre&gt;&lt;/blockquote&gt;
 317  *
 318  * &lt;p&gt;
 319  * Likewise, parsing with a {@code MessageFormat} object using patterns containing
 320  * multiple occurrences of the same argument would return the last match.  For
 321  * example,
 322  * &lt;blockquote&gt;&lt;pre&gt;
 323  * MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 324  * String forParsing = &quot;x, y, z&quot;;
 325  * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 326  * // result now equals {new String(&quot;z&quot;)}
 327  * &lt;/pre&gt;&lt;/blockquote&gt;
 328  *
<span class="line-modified"> 329  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
 330  *
 331  * &lt;p&gt;
 332  * Message formats are not synchronized.
 333  * It is recommended to create separate format instances for each thread.
 334  * If multiple threads access a format concurrently, it must be synchronized
 335  * externally.
 336  *
 337  * @see          java.util.Locale
 338  * @see          Format
 339  * @see          NumberFormat
 340  * @see          DecimalFormat
 341  * @see          DecimalFormatSymbols
 342  * @see          ChoiceFormat
 343  * @see          DateFormat
 344  * @see          SimpleDateFormat
 345  *
 346  * @author       Mark Davis
 347  * @since 1.1
 348  */
 349 
 350 public class MessageFormat extends Format {
 351 

 352     private static final long serialVersionUID = 6479157306784022952L;
 353 
 354     /**
 355      * Constructs a MessageFormat for the default
 356      * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
 357      * specified pattern.
 358      * The constructor first sets the locale, then parses the pattern and
 359      * creates a list of subformats for the format elements contained in it.
 360      * Patterns and their interpretation are specified in the
 361      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 362      *
 363      * @param pattern the pattern for this message format
<span class="line-modified"> 364      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 365      * @exception NullPointerException if {@code pattern} is</span>
 366      *            {@code null}
 367      */
 368     public MessageFormat(String pattern) {
 369         this.locale = Locale.getDefault(Locale.Category.FORMAT);
 370         applyPattern(pattern);
 371     }
 372 
 373     /**
 374      * Constructs a MessageFormat for the specified locale and
 375      * pattern.
 376      * The constructor first sets the locale, then parses the pattern and
 377      * creates a list of subformats for the format elements contained in it.
 378      * Patterns and their interpretation are specified in the
 379      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 380      *
 381      * @param pattern the pattern for this message format
 382      * @param locale the locale for this message format
<span class="line-modified"> 383      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 384      * @exception NullPointerException if {@code pattern} is</span>
 385      *            {@code null}
 386      * @since 1.4
 387      */
 388     public MessageFormat(String pattern, Locale locale) {
 389         this.locale = locale;
 390         applyPattern(pattern);
 391     }
 392 
 393     /**
 394      * Sets the locale to be used when creating or comparing subformats.
 395      * This affects subsequent calls
 396      * &lt;ul&gt;
 397      * &lt;li&gt;to the {@link #applyPattern applyPattern}
 398      *     and {@link #toPattern toPattern} methods if format elements specify
 399      *     a format type and therefore have the subformats created in the
<span class="line-modified"> 400      *     &lt;code&gt;applyPattern&lt;/code&gt; method, as well as</span>
<span class="line-modified"> 401      * &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and</span>
 402      *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
 403      *     if format elements do not specify a format type and therefore have
 404      *     the subformats created in the formatting methods.
 405      * &lt;/ul&gt;
 406      * Subformats that have already been created are not affected.
 407      *
 408      * @param locale the locale to be used when creating or comparing subformats
 409      */
 410     public void setLocale(Locale locale) {
 411         this.locale = locale;
 412     }
 413 
 414     /**
 415      * Gets the locale that&#39;s used when creating or comparing subformats.
 416      *
 417      * @return the locale used when creating or comparing subformats
 418      */
 419     public Locale getLocale() {
 420         return locale;
 421     }
 422 
 423 
 424     /**
 425      * Sets the pattern used by this message format.
 426      * The method parses the pattern and creates a list of subformats
 427      * for the format elements contained in it.
 428      * Patterns and their interpretation are specified in the
 429      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 430      *
 431      * @param pattern the pattern for this message format
<span class="line-modified"> 432      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 433      * @exception NullPointerException if {@code pattern} is</span>
 434      *            {@code null}
 435      */
 436     @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
 437     public void applyPattern(String pattern) {
 438             StringBuilder[] segments = new StringBuilder[4];
 439             // Allocate only segments[SEG_RAW] here. The rest are
 440             // allocated on demand.
 441             segments[SEG_RAW] = new StringBuilder();
 442 
 443             int part = SEG_RAW;
 444             int formatNumber = 0;
 445             boolean inQuote = false;
 446             int braceStack = 0;
 447             maxOffset = -1;
 448             for (int i = 0; i &lt; pattern.length(); ++i) {
 449                 char ch = pattern.charAt(i);
 450                 if (part == SEG_RAW) {
 451                     if (ch == &#39;\&#39;&#39;) {
 452                         if (i + 1 &lt; pattern.length()
 453                             &amp;&amp; pattern.charAt(i+1) == &#39;\&#39;&#39;) {
</pre>
<hr />
<pre>
 578                 if (index &gt;= DATE_TIME_MODIFIERS.length) {
 579                     if (fmt instanceof SimpleDateFormat) {
 580                         result.append(&quot;,date,&quot;).append(((SimpleDateFormat)fmt).toPattern());
 581                     } else {
 582                         // UNKNOWN
 583                     }
 584                 } else if (index != MODIFIER_DEFAULT) {
 585                     result.append(&#39;,&#39;).append(DATE_TIME_MODIFIER_KEYWORDS[index]);
 586                 }
 587             } else {
 588                 //result.append(&quot;, unknown&quot;);
 589             }
 590             result.append(&#39;}&#39;);
 591         }
 592         copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);
 593         return result.toString();
 594     }
 595 
 596     /**
 597      * Sets the formats to use for the values passed into
<span class="line-modified"> 598      * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;</span>
<span class="line-modified"> 599      * methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt;</span>
 600      * correspond to the argument indices used in the previously set
 601      * pattern string.
<span class="line-modified"> 602      * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to</span>
<span class="line-modified"> 603      * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified"> 604      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified"> 605      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 606      * &lt;p&gt;
 607      * If an argument index is used for more than one format element
 608      * in the pattern string, then the corresponding new format is used
 609      * for all such format elements. If an argument index is not used
 610      * for any format element in the pattern string, then the
 611      * corresponding new format is ignored. If fewer formats are provided
 612      * than needed, then only the formats for argument indices less
<span class="line-modified"> 613      * than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</span>
 614      *
 615      * @param newFormats the new formats to use
<span class="line-modified"> 616      * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</span>
 617      * @since 1.4
 618      */
 619     public void setFormatsByArgumentIndex(Format[] newFormats) {
 620         for (int i = 0; i &lt;= maxOffset; i++) {
 621             int j = argumentNumbers[i];
 622             if (j &lt; newFormats.length) {
 623                 formats[i] = newFormats[j];
 624             }
 625         }
 626     }
 627 
 628     /**
 629      * Sets the formats to use for the format elements in the
 630      * previously set pattern string.
<span class="line-modified"> 631      * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; corresponds to</span>
 632      * the order of format elements in the pattern string.
 633      * &lt;p&gt;
 634      * If more formats are provided than needed by the pattern string,
 635      * the remaining ones are ignored. If fewer formats are provided
<span class="line-modified"> 636      * than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt;</span>
 637      * formats are replaced.
 638      * &lt;p&gt;
 639      * Since the order of format elements in a pattern string often
 640      * changes during localization, it is generally better to use the
 641      * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
 642      * method, which assumes an order of formats corresponding to the
<span class="line-modified"> 643      * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to</span>
<span class="line-modified"> 644      * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by</span>
<span class="line-modified"> 645      * the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 646      *
 647      * @param newFormats the new formats to use
<span class="line-modified"> 648      * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</span>
 649      */
 650     public void setFormats(Format[] newFormats) {
 651         int runsToCopy = newFormats.length;
 652         if (runsToCopy &gt; maxOffset + 1) {
 653             runsToCopy = maxOffset + 1;
 654         }
 655         for (int i = 0; i &lt; runsToCopy; i++) {
 656             formats[i] = newFormats[i];
 657         }
 658     }
 659 
 660     /**
 661      * Sets the format to use for the format elements within the
 662      * previously set pattern string that use the given argument
 663      * index.
 664      * The argument index is part of the format element definition and
<span class="line-modified"> 665      * represents an index into the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified"> 666      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified"> 667      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 668      * &lt;p&gt;
 669      * If the argument index is used for more than one format element
 670      * in the pattern string, then the new format is used for all such
 671      * format elements. If the argument index is not used for any format
 672      * element in the pattern string, then the new format is ignored.
 673      *
 674      * @param argumentIndex the argument index for which to use the new format
 675      * @param newFormat the new format to use
 676      * @since 1.4
 677      */
 678     public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
 679         for (int j = 0; j &lt;= maxOffset; j++) {
 680             if (argumentNumbers[j] == argumentIndex) {
 681                 formats[j] = newFormat;
 682             }
 683         }
 684     }
 685 
 686     /**
 687      * Sets the format to use for the format element with the given
 688      * format element index within the previously set pattern string.
 689      * The format element index is the zero-based number of the format
 690      * element counting from the start of the pattern string.
 691      * &lt;p&gt;
 692      * Since the order of format elements in a pattern string often
 693      * changes during localization, it is generally better to use the
 694      * {@link #setFormatByArgumentIndex setFormatByArgumentIndex}
 695      * method, which accesses format elements based on the argument
 696      * index they specify.
 697      *
 698      * @param formatElementIndex the index of a format element within the pattern
 699      * @param newFormat the format to use for the specified format element
<span class="line-modified"> 700      * @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or</span>
 701      *            larger than the number of format elements in the pattern string
 702      */
 703     public void setFormat(int formatElementIndex, Format newFormat) {
 704 
 705         if (formatElementIndex &gt; maxOffset) {
 706             throw new ArrayIndexOutOfBoundsException(formatElementIndex);
 707         }
 708         formats[formatElementIndex] = newFormat;
 709     }
 710 
 711     /**
 712      * Gets the formats used for the values passed into
<span class="line-modified"> 713      * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;</span>
 714      * methods. The indices of elements in the returned array
 715      * correspond to the argument indices used in the previously set
 716      * pattern string.
 717      * The order of formats in the returned array thus corresponds to
<span class="line-modified"> 718      * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified"> 719      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified"> 720      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 721      * &lt;p&gt;
 722      * If an argument index is used for more than one format element
 723      * in the pattern string, then the format used for the last such
 724      * format element is returned in the array. If an argument index
 725      * is not used for any format element in the pattern string, then
 726      * null is returned in the array.
 727      *
 728      * @return the formats used for the arguments within the pattern
 729      * @since 1.4
 730      */
 731     public Format[] getFormatsByArgumentIndex() {
 732         int maximumArgumentNumber = -1;
 733         for (int i = 0; i &lt;= maxOffset; i++) {
 734             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 735                 maximumArgumentNumber = argumentNumbers[i];
 736             }
 737         }
 738         Format[] resultArray = new Format[maximumArgumentNumber + 1];
 739         for (int i = 0; i &lt;= maxOffset; i++) {
 740             resultArray[argumentNumbers[i]] = formats[i];
 741         }
 742         return resultArray;
 743     }
 744 
 745     /**
 746      * Gets the formats used for the format elements in the
 747      * previously set pattern string.
 748      * The order of formats in the returned array corresponds to
 749      * the order of format elements in the pattern string.
 750      * &lt;p&gt;
 751      * Since the order of format elements in a pattern string often
 752      * changes during localization, it&#39;s generally better to use the
 753      * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
 754      * method, which assumes an order of formats corresponding to the
<span class="line-modified"> 755      * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to</span>
<span class="line-modified"> 756      * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by</span>
<span class="line-modified"> 757      * the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 758      *
 759      * @return the formats used for the format elements in the pattern
 760      */
 761     public Format[] getFormats() {
 762         Format[] resultArray = new Format[maxOffset + 1];
 763         System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
 764         return resultArray;
 765     }
 766 
 767     /**
<span class="line-modified"> 768      * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s</span>
 769      * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified"> 770      * provided &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
 771      * &lt;p&gt;
 772      * The text substituted for the individual format elements is derived from
 773      * the current subformat of the format element and the
<span class="line-modified"> 774      * &lt;code&gt;arguments&lt;/code&gt; element at the format element&#39;s argument index</span>
 775      * as indicated by the first matching line of the following table. An
<span class="line-modified"> 776      * argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is</span>
<span class="line-modified"> 777      * &lt;code&gt;null&lt;/code&gt; or has fewer than argumentIndex+1 elements.</span>
 778      *
 779      * &lt;table class=&quot;plain&quot;&gt;
 780      * &lt;caption style=&quot;display:none&quot;&gt;Examples of subformat,argument,and formatted text&lt;/caption&gt;
 781      * &lt;thead&gt;
 782      *    &lt;tr&gt;
 783      *       &lt;th scope=&quot;col&quot;&gt;Subformat
 784      *       &lt;th scope=&quot;col&quot;&gt;Argument
 785      *       &lt;th scope=&quot;col&quot;&gt;Formatted Text
 786      * &lt;/thead&gt;
 787      * &lt;tbody&gt;
 788      *    &lt;tr&gt;
 789      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=2&gt;&lt;i&gt;any&lt;/i&gt;
 790      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;unavailable&lt;/i&gt;
 791      *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
 792      *    &lt;tr&gt;
<span class="line-modified"> 793      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 794      *       &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;</span>
 795      *    &lt;tr&gt;
<span class="line-modified"> 796      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;</span>
 797      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
 798      *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&#39;{&#39;) &amp;gt;= 0 ?&lt;br&gt;
 799      *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
 800      *           subformat.format(argument)&lt;/code&gt;
 801      *    &lt;tr&gt;
<span class="line-modified"> 802      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;!= null&lt;/code&gt;</span>
 803      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified"> 804      *       &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;</span>
 805      *    &lt;tr&gt;
<span class="line-modified"> 806      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=4&gt;&lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 807      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof Number&lt;/code&gt;</span>
<span class="line-modified"> 808      *       &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;</span>
 809      *    &lt;tr&gt;
<span class="line-modified"> 810      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof Date&lt;/code&gt;</span>
<span class="line-modified"> 811      *       &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;</span>
 812      *    &lt;tr&gt;
<span class="line-modified"> 813      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof String&lt;/code&gt;</span>
<span class="line-modified"> 814      *       &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;</span>
 815      *    &lt;tr&gt;
 816      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified"> 817      *       &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;</span>
 818      * &lt;/tbody&gt;
 819      * &lt;/table&gt;
 820      * &lt;p&gt;
<span class="line-modified"> 821      * If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to</span>
<span class="line-modified"> 822      * &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted</span>
 823      * string will be returned.
 824      *
 825      * @param arguments an array of objects to be formatted and substituted.
 826      * @param result where text is appended.
 827      * @param pos keeps track on the position of the first replaced argument
 828                   in the output string.
 829      * @return the string buffer passed in as {@code result}, with formatted
 830      * text appended
<span class="line-modified"> 831      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 832      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
 833      *            expected by the format element(s) that use it.
<span class="line-modified"> 834      * @exception NullPointerException if {@code result} is {@code null}</span>
 835      */
 836     public final StringBuffer format(Object[] arguments, StringBuffer result,
 837                                      FieldPosition pos)
 838     {
 839         return subformat(arguments, result, pos, null);
 840     }
 841 
 842     /**
 843      * Creates a MessageFormat with the given pattern and uses it
 844      * to format the given arguments. This is equivalent to
 845      * &lt;blockquote&gt;
 846      *     &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 847      * &lt;/blockquote&gt;
 848      *
 849      * @param pattern   the pattern string
 850      * @param arguments object(s) to format
 851      * @return the formatted string
<span class="line-modified"> 852      * @exception IllegalArgumentException if the pattern is invalid,</span>
<span class="line-modified"> 853      *            or if an argument in the &lt;code&gt;arguments&lt;/code&gt; array</span>
 854      *            is not of the type expected by the format element(s)
 855      *            that use it.
<span class="line-modified"> 856      * @exception NullPointerException if {@code pattern} is {@code null}</span>
 857      */
 858     public static String format(String pattern, Object ... arguments) {
 859         MessageFormat temp = new MessageFormat(pattern);
 860         return temp.format(arguments);
 861     }
 862 
 863     // Overrides
 864     /**
<span class="line-modified"> 865      * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s</span>
 866      * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified"> 867      * provided &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
 868      * This is equivalent to
 869      * &lt;blockquote&gt;
 870      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
 871      * &lt;/blockquote&gt;
 872      *
 873      * @param arguments an array of objects to be formatted and substituted.
 874      * @param result where text is appended.
 875      * @param pos keeps track on the position of the first replaced argument
 876      *            in the output string.
<span class="line-modified"> 877      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 878      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
 879      *            expected by the format element(s) that use it.
<span class="line-modified"> 880      * @exception NullPointerException if {@code result} is {@code null}</span>
 881      */
 882     public final StringBuffer format(Object arguments, StringBuffer result,
 883                                      FieldPosition pos)
 884     {
 885         return subformat((Object[]) arguments, result, pos, null);
 886     }
 887 
 888     /**
 889      * Formats an array of objects and inserts them into the
<span class="line-modified"> 890      * &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s pattern, producing an</span>
<span class="line-modified"> 891      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified"> 892      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
 893      * to build the resulting String, as well as to determine information
 894      * about the resulting String.
 895      * &lt;p&gt;
<span class="line-modified"> 896      * The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is</span>
 897      * the same that would be returned by
 898      * &lt;blockquote&gt;
 899      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 900      * &lt;/blockquote&gt;
 901      * &lt;p&gt;
<span class="line-modified"> 902      * In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at</span>
 903      * least attributes indicating where text was generated from an
<span class="line-modified"> 904      * argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of</span>
<span class="line-modified"> 905      * type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are</span>
<span class="line-modified"> 906      * &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt;</span>
 907      * array of the argument from which the text was generated.
 908      * &lt;p&gt;
<span class="line-modified"> 909      * The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified"> 910      * instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be</span>
<span class="line-modified"> 911      * placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
 912      * This allows you to not only find where an argument is placed in the
 913      * resulting String, but also which fields it contains in turn.
 914      *
 915      * @param arguments an array of objects to be formatted and substituted.
 916      * @return AttributedCharacterIterator describing the formatted value.
<span class="line-modified"> 917      * @exception NullPointerException if &lt;code&gt;arguments&lt;/code&gt; is null.</span>
<span class="line-modified"> 918      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 919      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
 920      *            expected by the format element(s) that use it.
 921      * @since 1.4
 922      */
 923     public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
 924         StringBuffer result = new StringBuffer();
 925         ArrayList&lt;AttributedCharacterIterator&gt; iterators = new ArrayList&lt;&gt;();
 926 
 927         if (arguments == null) {
 928             throw new NullPointerException(
 929                    &quot;formatToCharacterIterator must be passed non-null object&quot;);
 930         }
 931         subformat((Object[]) arguments, result, null, iterators);
 932         if (iterators.size() == 0) {
 933             return createAttributedCharacterIterator(&quot;&quot;);
 934         }
 935         return createAttributedCharacterIterator(
 936                      iterators.toArray(
 937                      new AttributedCharacterIterator[iterators.size()]));
 938     }
 939 
</pre>
<hr />
<pre>
 950      *     the substituted strings contain {n} references.)
 951      * &lt;li&gt;Will not always find a match (or the correct match)
 952      *     if some part of the parse is ambiguous.
 953      *     For example, if the pattern &quot;{1},{2}&quot; is used with the
 954      *     string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
 955      *     When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
 956      * &lt;li&gt;If a single argument is parsed more than once in the string,
 957      *     then the later parse wins.
 958      * &lt;/ul&gt;
 959      * When the parse fails, use ParsePosition.getErrorIndex() to find out
 960      * where in the string the parsing failed.  The returned error
 961      * index is the starting offset of the sub-patterns that the string
 962      * is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
 963      * is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
 964      * 0. When an error occurs, the call to this method will return null.
 965      * If the source is null, return an empty array.
 966      *
 967      * @param source the string to parse
 968      * @param pos    the parse position
 969      * @return an array of parsed objects
<span class="line-modified"> 970      * @exception NullPointerException if {@code pos} is {@code null}</span>
 971      *            for a non-null {@code source} string.
 972      */
 973     public Object[] parse(String source, ParsePosition pos) {
 974         if (source == null) {
 975             Object[] empty = {};
 976             return empty;
 977         }
 978 
 979         int maximumArgumentNumber = -1;
 980         for (int i = 0; i &lt;= maxOffset; i++) {
 981             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 982                 maximumArgumentNumber = argumentNumbers[i];
 983             }
 984         }
 985         Object[] resultArray = new Object[maximumArgumentNumber + 1];
 986 
 987         int patternOffset = 0;
 988         int sourceOffset = pos.index;
 989         ParsePosition tempStatus = new ParsePosition(0);
 990         for (int i = 0; i &lt;= maxOffset; ++i) {
</pre>
<hr />
<pre>
1037         }
1038         int len = pattern.length() - patternOffset;
1039         if (len == 0 || pattern.regionMatches(patternOffset,
1040                                               source, sourceOffset, len)) {
1041             pos.index = sourceOffset + len;
1042         } else {
1043             pos.errorIndex = sourceOffset;
1044             return null; // leave index as is to signal error
1045         }
1046         return resultArray;
1047     }
1048 
1049     /**
1050      * Parses text from the beginning of the given string to produce an object
1051      * array.
1052      * The method may not use the entire text of the given string.
1053      * &lt;p&gt;
1054      * See the {@link #parse(String, ParsePosition)} method for more information
1055      * on message parsing.
1056      *
<span class="line-modified">1057      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">1058      * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.</span>
<span class="line-modified">1059      * @exception ParseException if the beginning of the specified string</span>
1060      *            cannot be parsed.
1061      */
1062     public Object[] parse(String source) throws ParseException {
1063         ParsePosition pos  = new ParsePosition(0);
1064         Object[] result = parse(source, pos);
1065         if (pos.index == 0)  // unchanged, returned object is null
1066             throw new ParseException(&quot;MessageFormat parse error!&quot;, pos.errorIndex);
1067 
1068         return result;
1069     }
1070 
1071     /**
1072      * Parses text from a string to produce an object array.
1073      * &lt;p&gt;
1074      * The method attempts to parse text starting at the index given by
<span class="line-modified">1075      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">1076      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
1077      * to the index after the last character used (parsing does not necessarily
1078      * use all characters up to the end of the string), and the parsed
<span class="line-modified">1079      * object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
1080      * indicate the starting point for the next call to this method.
<span class="line-modified">1081      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">1082      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
1083      * the character where the error occurred, and null is returned.
1084      * &lt;p&gt;
1085      * See the {@link #parse(String, ParsePosition)} method for more information
1086      * on message parsing.
1087      *
<span class="line-modified">1088      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">1089      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
1090      *            index information as described above.
<span class="line-modified">1091      * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of</span>
1092      *         error, returns null.
1093      * @throws NullPointerException if {@code pos} is null.
1094      */
1095     public Object parseObject(String source, ParsePosition pos) {
1096         return parse(source, pos);
1097     }
1098 
1099     /**
1100      * Creates and returns a copy of this object.
1101      *
1102      * @return a clone of this instance.
1103      */
1104     public Object clone() {
1105         MessageFormat other = (MessageFormat) super.clone();
1106 
1107         // clone arrays. Can&#39;t do with utility because of bug in Cloneable
1108         other.formats = formats.clone(); // shallow clone
1109         for (int i = 0; i &lt; formats.length; ++i) {
1110             if (formats[i] != null)
1111                 other.formats[i] = (Format)formats[i].clone();
</pre>
<hr />
<pre>
1128         MessageFormat other = (MessageFormat) obj;
1129         return (maxOffset == other.maxOffset
1130                 &amp;&amp; pattern.equals(other.pattern)
1131                 &amp;&amp; ((locale != null &amp;&amp; locale.equals(other.locale))
1132                  || (locale == null &amp;&amp; other.locale == null))
1133                 &amp;&amp; Arrays.equals(offsets,other.offsets)
1134                 &amp;&amp; Arrays.equals(argumentNumbers,other.argumentNumbers)
1135                 &amp;&amp; Arrays.equals(formats,other.formats));
1136     }
1137 
1138     /**
1139      * Generates a hash code for the message format object.
1140      */
1141     public int hashCode() {
1142         return pattern.hashCode(); // enough for reasonable distribution
1143     }
1144 
1145 
1146     /**
1147      * Defines constants that are used as attribute keys in the
<span class="line-modified">1148      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">1149      * from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.</span>
1150      *
1151      * @since 1.4
1152      */
1153     public static class Field extends Format.Field {
1154 
1155         // Proclaim serial compatibility with 1.4 FCS

1156         private static final long serialVersionUID = 7899943957617360810L;
1157 
1158         /**
1159          * Creates a Field with the specified name.
1160          *
1161          * @param name Name of the attribute
1162          */
1163         protected Field(String name) {
1164             super(name);
1165         }
1166 
1167         /**
1168          * Resolves instances being deserialized to the predefined constants.
1169          *
1170          * @throws InvalidObjectException if the constant could not be
1171          *         resolved.
1172          * @return resolved MessageFormat.Field constant
1173          */

1174         protected Object readResolve() throws InvalidObjectException {
1175             if (this.getClass() != MessageFormat.Field.class) {
1176                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1177             }
1178 
1179             return ARGUMENT;
1180         }
1181 
1182         //
1183         // The constants
1184         //
1185 
1186         /**
1187          * Constant identifying a portion of a message that was generated
<span class="line-modified">1188          * from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">1189          * The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;</span>
<span class="line-modified">1190          * indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the</span>
1191          * argument from which the text was generated.
1192          */
1193         public static final Field ARGUMENT =
1194                            new Field(&quot;message argument field&quot;);
1195     }
1196 
1197     // ===========================privates============================
1198 
1199     /**
1200      * The locale to use for formatting numbers and dates.
1201      * @serial
1202      */
1203     private Locale locale;
1204 
1205     /**
1206      * The string that the formatted values are to be plugged into.  In other words, this
1207      * is the pattern supplied on construction with all of the {} expressions taken out.
1208      * @serial
1209      */
1210     private String pattern = &quot;&quot;;
</pre>
<hr />
<pre>
1217      * @serial
1218      */
1219     private Format[] formats = new Format[INITIAL_FORMATS];
1220 
1221     /**
1222      * The positions where the results of formatting each argument are to be inserted
1223      * into the pattern.
1224      * @serial
1225      */
1226     private int[] offsets = new int[INITIAL_FORMATS];
1227 
1228     /**
1229      * The argument numbers corresponding to each formatter.  (The formatters are stored
1230      * in the order they occur in the pattern, not in the order in which the arguments
1231      * are specified.)
1232      * @serial
1233      */
1234     private int[] argumentNumbers = new int[INITIAL_FORMATS];
1235 
1236     /**
<span class="line-modified">1237      * One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;.  Can also be thought of</span>
<span class="line-modified">1238      * as the index of the highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used.</span>
<span class="line-modified">1239      * All of these arrays should have the same number of elements being used as &lt;code&gt;offsets&lt;/code&gt;</span>
1240      * does, and so this variable suffices to tell us how many entries are in all of them.
1241      * @serial
1242      */
1243     private int maxOffset = -1;
1244 
1245     /**
1246      * Internal routine used by format. If {@code characterIterators} is
1247      * {@code non-null}, AttributedCharacterIterator will be created from the
1248      * subformats as necessary. If {@code characterIterators} is {@code null}
1249      * and {@code fp} is {@code non-null} and identifies
1250      * {@code Field.ARGUMENT} as the field attribute, the location of
1251      * the first replaced argument will be set in it.
1252      *
<span class="line-modified">1253      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified">1254      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
1255      *            expected by the format element(s) that use it.
1256      */
1257     private StringBuffer subformat(Object[] arguments, StringBuffer result,
1258                                    FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
1259         // note: this implementation assumes a fast substring &amp; index.
1260         // if this is not true, would be better to append chars one by one.
1261         int lastOffset = 0;
1262         int last = result.length();
1263         for (int i = 0; i &lt;= maxOffset; ++i) {
1264             result.append(pattern, lastOffset, offsets[i]);
1265             lastOffset = offsets[i];
1266             int argumentNumber = argumentNumbers[i];
1267             if (arguments == null || argumentNumber &gt;= arguments.length) {
1268                 result.append(&#39;{&#39;).append(argumentNumber).append(&#39;}&#39;);
1269                 continue;
1270             }
1271             // int argRecursion = ((recursionProtection &gt;&gt; (argumentNumber*2)) &amp; 0x3);
1272             if (false) { // if (argRecursion == 3){
1273                 // prevent loop!!!
1274                 result.append(&#39;\uFFFD&#39;);
</pre>
<hr />
<pre>
1347                     result.append(arg);
1348                     if (i == 0 &amp;&amp; fp != null &amp;&amp; Field.ARGUMENT.equals(
1349                                   fp.getFieldAttribute())) {
1350                         fp.setBeginIndex(last);
1351                         fp.setEndIndex(result.length());
1352                     }
1353                     last = result.length();
1354                 }
1355             }
1356         }
1357         result.append(pattern, lastOffset, pattern.length());
1358         if (characterIterators != null &amp;&amp; last != result.length()) {
1359             characterIterators.add(createAttributedCharacterIterator(
1360                                    result.substring(last)));
1361         }
1362         return result;
1363     }
1364 
1365     /**
1366      * Convenience method to append all the characters in
<span class="line-modified">1367      * &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.</span>
1368      */
1369     private void append(StringBuffer result, CharacterIterator iterator) {
1370         if (iterator.first() != CharacterIterator.DONE) {
1371             char aChar;
1372 
1373             result.append(iterator.first());
1374             while ((aChar = iterator.next()) != CharacterIterator.DONE) {
1375                 result.append(aChar);
1376             }
1377         }
1378     }
1379 
1380     // Indices for segments
1381     private static final int SEG_RAW      = 0;
1382     private static final int SEG_INDEX    = 1;
1383     private static final int SEG_TYPE     = 2;
1384     private static final int SEG_MODIFIER = 3; // modifier or subformat
1385 
1386     // Indices for type keywords
1387     private static final int TYPE_NULL    = 0;
</pre>
<hr />
<pre>
1584             } else if (ch == &#39;\&#39;&#39;) {
1585                 target.append(&quot;&#39;&#39;&quot;);
1586             } else {
1587                 if (quoted) {
1588                     target.append(&#39;\&#39;&#39;);
1589                     quoted = false;
1590                 }
1591                 target.append(ch);
1592             }
1593         }
1594         if (quoted) {
1595             target.append(&#39;\&#39;&#39;);
1596         }
1597     }
1598 
1599     /**
1600      * After reading an object from the input stream, do a simple verification
1601      * to maintain class invariants.
1602      * @throws InvalidObjectException if the objects read from the stream is invalid.
1603      */

1604     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1605         in.defaultReadObject();
1606         boolean isValid = maxOffset &gt;= -1
1607                 &amp;&amp; formats.length &gt; maxOffset
1608                 &amp;&amp; offsets.length &gt; maxOffset
1609                 &amp;&amp; argumentNumbers.length &gt; maxOffset;
1610         if (isValid) {
1611             int lastOffset = pattern.length() + 1;
1612             for (int i = maxOffset; i &gt;= 0; --i) {
1613                 if ((offsets[i] &lt; 0) || (offsets[i] &gt; lastOffset)) {
1614                     isValid = false;
1615                     break;
1616                 } else {
1617                     lastOffset = offsets[i];
1618                 }
1619             }
1620         }
1621         if (!isValid) {
1622             throw new InvalidObjectException(&quot;Could not reconstruct MessageFormat from corrupt stream.&quot;);
1623         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.text.DecimalFormat;
  45 import java.util.ArrayList;
  46 import java.util.Arrays;
  47 import java.util.Date;
  48 import java.util.List;
  49 import java.util.Locale;
  50 
  51 
  52 /**
<span class="line-modified">  53  * {@code MessageFormat} provides a means to produce concatenated</span>
  54  * messages in a language-neutral way. Use this to construct messages
  55  * displayed for end users.
  56  *
  57  * &lt;p&gt;
<span class="line-modified">  58  * {@code MessageFormat} takes a set of objects, formats them, then</span>
  59  * inserts the formatted strings into the pattern at the appropriate places.
  60  *
  61  * &lt;p&gt;
  62  * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified">  63  * {@code MessageFormat} differs from the other {@code Format}</span>
<span class="line-modified">  64  * classes in that you create a {@code MessageFormat} object with one</span>
<span class="line-modified">  65  * of its constructors (not with a {@code getInstance} style factory</span>
<span class="line-modified">  66  * method). The factory methods aren&#39;t necessary because {@code MessageFormat}</span>
  67  * itself doesn&#39;t implement locale specific behavior. Any locale specific
  68  * behavior is defined by the pattern that you provide as well as the
  69  * subformats used for inserted arguments.
  70  *
<span class="line-modified">  71  * &lt;h2&gt;&lt;a id=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h2&gt;</span>
  72  *
<span class="line-modified">  73  * {@code MessageFormat} uses patterns of the following form:</span>
  74  * &lt;blockquote&gt;&lt;pre&gt;
  75  * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
  76  *         &lt;i&gt;String&lt;/i&gt;
  77  *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
  78  *
  79  * &lt;i&gt;FormatElement:&lt;/i&gt;
  80  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
  81  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
  82  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
  83  *
  84  * &lt;i&gt;FormatType: one of &lt;/i&gt;
  85  *         number date time choice
  86  *
  87  * &lt;i&gt;FormatStyle:&lt;/i&gt;
  88  *         short
  89  *         medium
  90  *         long
  91  *         full
  92  *         integer
  93  *         currency
  94  *         percent
  95  *         &lt;i&gt;SubformatPattern&lt;/i&gt;
  96  * &lt;/pre&gt;&lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
  99  * quote any arbitrary characters except single quotes. For example,
 100  * pattern string &lt;code&gt;&quot;&#39;{0}&#39;&quot;&lt;/code&gt; represents string
 101  * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
 102  * must be represented by doubled single quotes {@code &#39;&#39;} throughout a
 103  * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&#39;{&#39;&#39;}&#39;&quot;&lt;/code&gt; is
 104  * interpreted as a sequence of &lt;code&gt;&#39;{&lt;/code&gt; (start of quoting and a
<span class="line-modified"> 105  * left curly brace), {@code &#39;&#39;} (a single quote), and</span>
 106  * &lt;code&gt;}&#39;&lt;/code&gt; (a right curly brace and end of quoting),
 107  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&#39;{&#39;&lt;/code&gt; and &lt;code&gt;&#39;}&#39;&lt;/code&gt; (quoted left and
 108  * right curly braces): representing string &lt;code&gt;&quot;{&#39;}&quot;&lt;/code&gt;,
 109  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
 110  *
 111  * &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
 112  * subformat, and subformat-dependent pattern rules apply. For example,
 113  * pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$&#39;#&#39;,##&lt;/u&gt;}&quot;&lt;/code&gt;
 114  * (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
 115  * with the pound-sign quoted, with a result such as: {@code
 116  * &quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for
 117  * details.
 118  *
 119  * &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
 120  * pattern. For example, pattern string {@code &quot;&#39;{0}&quot;} is treated as
 121  * pattern {@code &quot;&#39;{0}&#39;&quot;}.
 122  *
 123  * &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
 124  * example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab &#39;}&#39; de&quot;&lt;/code&gt; are
 125  * valid patterns, but &lt;code&gt;&quot;ab {0&#39;}&#39; de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt;
</pre>
<hr />
<pre>
 203  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 204  *    &lt;tr&gt;
 205  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code medium}
 206  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 207  *    &lt;tr&gt;
 208  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code long}
 209  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 210  *    &lt;tr&gt;
 211  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code full}
 212  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 213  *    &lt;tr&gt;
 214  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 215  *       &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 216  *    &lt;tr&gt;
 217  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code choice}
 218  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 219  *       &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 220  * &lt;/tbody&gt;
 221  * &lt;/table&gt;
 222  *
<span class="line-modified"> 223  * &lt;h3&gt;Usage Information&lt;/h3&gt;</span>
 224  *
 225  * &lt;p&gt;
 226  * Here are some examples of usage.
 227  * In real internationalized programs, the message format pattern and other
 228  * static strings will, of course, be obtained from resource bundles.
 229  * Other parameters will be dynamically determined at runtime.
 230  * &lt;p&gt;
<span class="line-modified"> 231  * The first example uses the static method {@code MessageFormat.format},</span>
<span class="line-modified"> 232  * which internally creates a {@code MessageFormat} for one-time use:</span>
 233  * &lt;blockquote&gt;&lt;pre&gt;
 234  * int planet = 7;
 235  * String event = &quot;a disturbance in the Force&quot;;
 236  *
 237  * String result = MessageFormat.format(
 238  *     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
 239  *     planet, new Date(), event);
 240  * &lt;/pre&gt;&lt;/blockquote&gt;
 241  * The output is:
 242  * &lt;blockquote&gt;&lt;pre&gt;
 243  * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 244  * &lt;/pre&gt;&lt;/blockquote&gt;
 245  *
 246  * &lt;p&gt;
<span class="line-modified"> 247  * The following example creates a {@code MessageFormat} instance that</span>
 248  * can be used repeatedly:
 249  * &lt;blockquote&gt;&lt;pre&gt;
 250  * int fileCount = 1273;
 251  * String diskName = &quot;MyDisk&quot;;
 252  * Object[] testArgs = {new Long(fileCount), diskName};
 253  *
 254  * MessageFormat form = new MessageFormat(
 255  *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
 256  *
 257  * System.out.println(form.format(testArgs));
 258  * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified"> 259  * The output with different values for {@code fileCount}:</span>
 260  * &lt;blockquote&gt;&lt;pre&gt;
 261  * The disk &quot;MyDisk&quot; contains 0 file(s).
 262  * The disk &quot;MyDisk&quot; contains 1 file(s).
 263  * The disk &quot;MyDisk&quot; contains 1,273 file(s).
 264  * &lt;/pre&gt;&lt;/blockquote&gt;
 265  *
 266  * &lt;p&gt;
<span class="line-modified"> 267  * For more sophisticated patterns, you can use a {@code ChoiceFormat}</span>
 268  * to produce correct forms for singular and plural:
 269  * &lt;blockquote&gt;&lt;pre&gt;
 270  * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 271  * double[] filelimits = {0,1,2};
 272  * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 273  * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 274  * form.setFormatByArgumentIndex(0, fileform);
 275  *
 276  * int fileCount = 1273;
 277  * String diskName = &quot;MyDisk&quot;;
 278  * Object[] testArgs = {new Long(fileCount), diskName};
 279  *
 280  * System.out.println(form.format(testArgs));
 281  * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified"> 282  * The output with different values for {@code fileCount}:</span>
 283  * &lt;blockquote&gt;&lt;pre&gt;
 284  * The disk &quot;MyDisk&quot; contains no files.
 285  * The disk &quot;MyDisk&quot; contains one file.
 286  * The disk &quot;MyDisk&quot; contains 1,273 files.
 287  * &lt;/pre&gt;&lt;/blockquote&gt;
 288  *
 289  * &lt;p&gt;
<span class="line-modified"> 290  * You can create the {@code ChoiceFormat} programmatically, as in the</span>
 291  * above example, or by using a pattern. See {@link ChoiceFormat}
 292  * for more information.
 293  * &lt;blockquote&gt;&lt;pre&gt;{@code
 294  * form.applyPattern(
 295  *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
 296  * }&lt;/pre&gt;&lt;/blockquote&gt;
 297  *
 298  * &lt;p&gt;
 299  * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
<span class="line-modified"> 300  * by a {@code ChoiceFormat} in {@code MessageFormat} is treated as special;</span>
 301  * occurrences of &#39;{&#39; are used to indicate subformats, and cause recursion.
<span class="line-modified"> 302  * If you create both a {@code MessageFormat} and {@code ChoiceFormat}</span>
 303  * programmatically (instead of using the string patterns), then be careful not to
 304  * produce a format that recurses on itself, which will cause an infinite loop.
 305  * &lt;p&gt;
 306  * When a single argument is parsed more than once in the string, the last match
 307  * will be the final result of the parsing.  For example,
 308  * &lt;blockquote&gt;&lt;pre&gt;
 309  * MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 310  * Object[] objs = {new Double(3.1415)};
 311  * String result = mf.format( objs );
 312  * // result now equals &quot;3.14, 3.1&quot;
 313  * objs = null;
 314  * objs = mf.parse(result, new ParsePosition(0));
 315  * // objs now equals {new Double(3.1)}
 316  * &lt;/pre&gt;&lt;/blockquote&gt;
 317  *
 318  * &lt;p&gt;
 319  * Likewise, parsing with a {@code MessageFormat} object using patterns containing
 320  * multiple occurrences of the same argument would return the last match.  For
 321  * example,
 322  * &lt;blockquote&gt;&lt;pre&gt;
 323  * MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 324  * String forParsing = &quot;x, y, z&quot;;
 325  * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 326  * // result now equals {new String(&quot;z&quot;)}
 327  * &lt;/pre&gt;&lt;/blockquote&gt;
 328  *
<span class="line-modified"> 329  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
 330  *
 331  * &lt;p&gt;
 332  * Message formats are not synchronized.
 333  * It is recommended to create separate format instances for each thread.
 334  * If multiple threads access a format concurrently, it must be synchronized
 335  * externally.
 336  *
 337  * @see          java.util.Locale
 338  * @see          Format
 339  * @see          NumberFormat
 340  * @see          DecimalFormat
 341  * @see          DecimalFormatSymbols
 342  * @see          ChoiceFormat
 343  * @see          DateFormat
 344  * @see          SimpleDateFormat
 345  *
 346  * @author       Mark Davis
 347  * @since 1.1
 348  */
 349 
 350 public class MessageFormat extends Format {
 351 
<span class="line-added"> 352     @java.io.Serial</span>
 353     private static final long serialVersionUID = 6479157306784022952L;
 354 
 355     /**
 356      * Constructs a MessageFormat for the default
 357      * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
 358      * specified pattern.
 359      * The constructor first sets the locale, then parses the pattern and
 360      * creates a list of subformats for the format elements contained in it.
 361      * Patterns and their interpretation are specified in the
 362      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 363      *
 364      * @param pattern the pattern for this message format
<span class="line-modified"> 365      * @throws    IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 366      * @throws    NullPointerException if {@code pattern} is</span>
 367      *            {@code null}
 368      */
 369     public MessageFormat(String pattern) {
 370         this.locale = Locale.getDefault(Locale.Category.FORMAT);
 371         applyPattern(pattern);
 372     }
 373 
 374     /**
 375      * Constructs a MessageFormat for the specified locale and
 376      * pattern.
 377      * The constructor first sets the locale, then parses the pattern and
 378      * creates a list of subformats for the format elements contained in it.
 379      * Patterns and their interpretation are specified in the
 380      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 381      *
 382      * @param pattern the pattern for this message format
 383      * @param locale the locale for this message format
<span class="line-modified"> 384      * @throws    IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 385      * @throws    NullPointerException if {@code pattern} is</span>
 386      *            {@code null}
 387      * @since 1.4
 388      */
 389     public MessageFormat(String pattern, Locale locale) {
 390         this.locale = locale;
 391         applyPattern(pattern);
 392     }
 393 
 394     /**
 395      * Sets the locale to be used when creating or comparing subformats.
 396      * This affects subsequent calls
 397      * &lt;ul&gt;
 398      * &lt;li&gt;to the {@link #applyPattern applyPattern}
 399      *     and {@link #toPattern toPattern} methods if format elements specify
 400      *     a format type and therefore have the subformats created in the
<span class="line-modified"> 401      *     {@code applyPattern} method, as well as</span>
<span class="line-modified"> 402      * &lt;li&gt;to the {@code format} and</span>
 403      *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
 404      *     if format elements do not specify a format type and therefore have
 405      *     the subformats created in the formatting methods.
 406      * &lt;/ul&gt;
 407      * Subformats that have already been created are not affected.
 408      *
 409      * @param locale the locale to be used when creating or comparing subformats
 410      */
 411     public void setLocale(Locale locale) {
 412         this.locale = locale;
 413     }
 414 
 415     /**
 416      * Gets the locale that&#39;s used when creating or comparing subformats.
 417      *
 418      * @return the locale used when creating or comparing subformats
 419      */
 420     public Locale getLocale() {
 421         return locale;
 422     }
 423 
 424 
 425     /**
 426      * Sets the pattern used by this message format.
 427      * The method parses the pattern and creates a list of subformats
 428      * for the format elements contained in it.
 429      * Patterns and their interpretation are specified in the
 430      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 431      *
 432      * @param pattern the pattern for this message format
<span class="line-modified"> 433      * @throws    IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 434      * @throws    NullPointerException if {@code pattern} is</span>
 435      *            {@code null}
 436      */
 437     @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
 438     public void applyPattern(String pattern) {
 439             StringBuilder[] segments = new StringBuilder[4];
 440             // Allocate only segments[SEG_RAW] here. The rest are
 441             // allocated on demand.
 442             segments[SEG_RAW] = new StringBuilder();
 443 
 444             int part = SEG_RAW;
 445             int formatNumber = 0;
 446             boolean inQuote = false;
 447             int braceStack = 0;
 448             maxOffset = -1;
 449             for (int i = 0; i &lt; pattern.length(); ++i) {
 450                 char ch = pattern.charAt(i);
 451                 if (part == SEG_RAW) {
 452                     if (ch == &#39;\&#39;&#39;) {
 453                         if (i + 1 &lt; pattern.length()
 454                             &amp;&amp; pattern.charAt(i+1) == &#39;\&#39;&#39;) {
</pre>
<hr />
<pre>
 579                 if (index &gt;= DATE_TIME_MODIFIERS.length) {
 580                     if (fmt instanceof SimpleDateFormat) {
 581                         result.append(&quot;,date,&quot;).append(((SimpleDateFormat)fmt).toPattern());
 582                     } else {
 583                         // UNKNOWN
 584                     }
 585                 } else if (index != MODIFIER_DEFAULT) {
 586                     result.append(&#39;,&#39;).append(DATE_TIME_MODIFIER_KEYWORDS[index]);
 587                 }
 588             } else {
 589                 //result.append(&quot;, unknown&quot;);
 590             }
 591             result.append(&#39;}&#39;);
 592         }
 593         copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);
 594         return result.toString();
 595     }
 596 
 597     /**
 598      * Sets the formats to use for the values passed into
<span class="line-modified"> 599      * {@code format} methods or returned from {@code parse}</span>
<span class="line-modified"> 600      * methods. The indices of elements in {@code newFormats}</span>
 601      * correspond to the argument indices used in the previously set
 602      * pattern string.
<span class="line-modified"> 603      * The order of formats in {@code newFormats} thus corresponds to</span>
<span class="line-modified"> 604      * the order of elements in the {@code arguments} array passed</span>
<span class="line-modified"> 605      * to the {@code format} methods or the result array returned</span>
<span class="line-modified"> 606      * by the {@code parse} methods.</span>
 607      * &lt;p&gt;
 608      * If an argument index is used for more than one format element
 609      * in the pattern string, then the corresponding new format is used
 610      * for all such format elements. If an argument index is not used
 611      * for any format element in the pattern string, then the
 612      * corresponding new format is ignored. If fewer formats are provided
 613      * than needed, then only the formats for argument indices less
<span class="line-modified"> 614      * than {@code newFormats.length} are replaced.</span>
 615      *
 616      * @param newFormats the new formats to use
<span class="line-modified"> 617      * @throws    NullPointerException if {@code newFormats} is null</span>
 618      * @since 1.4
 619      */
 620     public void setFormatsByArgumentIndex(Format[] newFormats) {
 621         for (int i = 0; i &lt;= maxOffset; i++) {
 622             int j = argumentNumbers[i];
 623             if (j &lt; newFormats.length) {
 624                 formats[i] = newFormats[j];
 625             }
 626         }
 627     }
 628 
 629     /**
 630      * Sets the formats to use for the format elements in the
 631      * previously set pattern string.
<span class="line-modified"> 632      * The order of formats in {@code newFormats} corresponds to</span>
 633      * the order of format elements in the pattern string.
 634      * &lt;p&gt;
 635      * If more formats are provided than needed by the pattern string,
 636      * the remaining ones are ignored. If fewer formats are provided
<span class="line-modified"> 637      * than needed, then only the first {@code newFormats.length}</span>
 638      * formats are replaced.
 639      * &lt;p&gt;
 640      * Since the order of format elements in a pattern string often
 641      * changes during localization, it is generally better to use the
 642      * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
 643      * method, which assumes an order of formats corresponding to the
<span class="line-modified"> 644      * order of elements in the {@code arguments} array passed to</span>
<span class="line-modified"> 645      * the {@code format} methods or the result array returned by</span>
<span class="line-modified"> 646      * the {@code parse} methods.</span>
 647      *
 648      * @param newFormats the new formats to use
<span class="line-modified"> 649      * @throws    NullPointerException if {@code newFormats} is null</span>
 650      */
 651     public void setFormats(Format[] newFormats) {
 652         int runsToCopy = newFormats.length;
 653         if (runsToCopy &gt; maxOffset + 1) {
 654             runsToCopy = maxOffset + 1;
 655         }
 656         for (int i = 0; i &lt; runsToCopy; i++) {
 657             formats[i] = newFormats[i];
 658         }
 659     }
 660 
 661     /**
 662      * Sets the format to use for the format elements within the
 663      * previously set pattern string that use the given argument
 664      * index.
 665      * The argument index is part of the format element definition and
<span class="line-modified"> 666      * represents an index into the {@code arguments} array passed</span>
<span class="line-modified"> 667      * to the {@code format} methods or the result array returned</span>
<span class="line-modified"> 668      * by the {@code parse} methods.</span>
 669      * &lt;p&gt;
 670      * If the argument index is used for more than one format element
 671      * in the pattern string, then the new format is used for all such
 672      * format elements. If the argument index is not used for any format
 673      * element in the pattern string, then the new format is ignored.
 674      *
 675      * @param argumentIndex the argument index for which to use the new format
 676      * @param newFormat the new format to use
 677      * @since 1.4
 678      */
 679     public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
 680         for (int j = 0; j &lt;= maxOffset; j++) {
 681             if (argumentNumbers[j] == argumentIndex) {
 682                 formats[j] = newFormat;
 683             }
 684         }
 685     }
 686 
 687     /**
 688      * Sets the format to use for the format element with the given
 689      * format element index within the previously set pattern string.
 690      * The format element index is the zero-based number of the format
 691      * element counting from the start of the pattern string.
 692      * &lt;p&gt;
 693      * Since the order of format elements in a pattern string often
 694      * changes during localization, it is generally better to use the
 695      * {@link #setFormatByArgumentIndex setFormatByArgumentIndex}
 696      * method, which accesses format elements based on the argument
 697      * index they specify.
 698      *
 699      * @param formatElementIndex the index of a format element within the pattern
 700      * @param newFormat the format to use for the specified format element
<span class="line-modified"> 701      * @throws    ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or</span>
 702      *            larger than the number of format elements in the pattern string
 703      */
 704     public void setFormat(int formatElementIndex, Format newFormat) {
 705 
 706         if (formatElementIndex &gt; maxOffset) {
 707             throw new ArrayIndexOutOfBoundsException(formatElementIndex);
 708         }
 709         formats[formatElementIndex] = newFormat;
 710     }
 711 
 712     /**
 713      * Gets the formats used for the values passed into
<span class="line-modified"> 714      * {@code format} methods or returned from {@code parse}</span>
 715      * methods. The indices of elements in the returned array
 716      * correspond to the argument indices used in the previously set
 717      * pattern string.
 718      * The order of formats in the returned array thus corresponds to
<span class="line-modified"> 719      * the order of elements in the {@code arguments} array passed</span>
<span class="line-modified"> 720      * to the {@code format} methods or the result array returned</span>
<span class="line-modified"> 721      * by the {@code parse} methods.</span>
 722      * &lt;p&gt;
 723      * If an argument index is used for more than one format element
 724      * in the pattern string, then the format used for the last such
 725      * format element is returned in the array. If an argument index
 726      * is not used for any format element in the pattern string, then
 727      * null is returned in the array.
 728      *
 729      * @return the formats used for the arguments within the pattern
 730      * @since 1.4
 731      */
 732     public Format[] getFormatsByArgumentIndex() {
 733         int maximumArgumentNumber = -1;
 734         for (int i = 0; i &lt;= maxOffset; i++) {
 735             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 736                 maximumArgumentNumber = argumentNumbers[i];
 737             }
 738         }
 739         Format[] resultArray = new Format[maximumArgumentNumber + 1];
 740         for (int i = 0; i &lt;= maxOffset; i++) {
 741             resultArray[argumentNumbers[i]] = formats[i];
 742         }
 743         return resultArray;
 744     }
 745 
 746     /**
 747      * Gets the formats used for the format elements in the
 748      * previously set pattern string.
 749      * The order of formats in the returned array corresponds to
 750      * the order of format elements in the pattern string.
 751      * &lt;p&gt;
 752      * Since the order of format elements in a pattern string often
 753      * changes during localization, it&#39;s generally better to use the
 754      * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
 755      * method, which assumes an order of formats corresponding to the
<span class="line-modified"> 756      * order of elements in the {@code arguments} array passed to</span>
<span class="line-modified"> 757      * the {@code format} methods or the result array returned by</span>
<span class="line-modified"> 758      * the {@code parse} methods.</span>
 759      *
 760      * @return the formats used for the format elements in the pattern
 761      */
 762     public Format[] getFormats() {
 763         Format[] resultArray = new Format[maxOffset + 1];
 764         System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
 765         return resultArray;
 766     }
 767 
 768     /**
<span class="line-modified"> 769      * Formats an array of objects and appends the {@code MessageFormat}&#39;s</span>
 770      * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified"> 771      * provided {@code StringBuffer}.</span>
 772      * &lt;p&gt;
 773      * The text substituted for the individual format elements is derived from
 774      * the current subformat of the format element and the
<span class="line-modified"> 775      * {@code arguments} element at the format element&#39;s argument index</span>
 776      * as indicated by the first matching line of the following table. An
<span class="line-modified"> 777      * argument is &lt;i&gt;unavailable&lt;/i&gt; if {@code arguments} is</span>
<span class="line-modified"> 778      * {@code null} or has fewer than argumentIndex+1 elements.</span>
 779      *
 780      * &lt;table class=&quot;plain&quot;&gt;
 781      * &lt;caption style=&quot;display:none&quot;&gt;Examples of subformat,argument,and formatted text&lt;/caption&gt;
 782      * &lt;thead&gt;
 783      *    &lt;tr&gt;
 784      *       &lt;th scope=&quot;col&quot;&gt;Subformat
 785      *       &lt;th scope=&quot;col&quot;&gt;Argument
 786      *       &lt;th scope=&quot;col&quot;&gt;Formatted Text
 787      * &lt;/thead&gt;
 788      * &lt;tbody&gt;
 789      *    &lt;tr&gt;
 790      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=2&gt;&lt;i&gt;any&lt;/i&gt;
 791      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;unavailable&lt;/i&gt;
 792      *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
 793      *    &lt;tr&gt;
<span class="line-modified"> 794      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code null}</span>
<span class="line-modified"> 795      *       &lt;td&gt;{@code &quot;null&quot;}</span>
 796      *    &lt;tr&gt;
<span class="line-modified"> 797      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof ChoiceFormat}</span>
 798      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
 799      *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&#39;{&#39;) &amp;gt;= 0 ?&lt;br&gt;
 800      *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
 801      *           subformat.format(argument)&lt;/code&gt;
 802      *    &lt;tr&gt;
<span class="line-modified"> 803      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code != null}</span>
 804      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified"> 805      *       &lt;td&gt;{@code subformat.format(argument)}</span>
 806      *    &lt;tr&gt;
<span class="line-modified"> 807      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=4&gt;{@code null}</span>
<span class="line-modified"> 808      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof Number}</span>
<span class="line-modified"> 809      *       &lt;td&gt;{@code NumberFormat.getInstance(getLocale()).format(argument)}</span>
 810      *    &lt;tr&gt;
<span class="line-modified"> 811      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof Date}</span>
<span class="line-modified"> 812      *       &lt;td&gt;{@code DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)}</span>
 813      *    &lt;tr&gt;
<span class="line-modified"> 814      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof String}</span>
<span class="line-modified"> 815      *       &lt;td&gt;{@code argument}</span>
 816      *    &lt;tr&gt;
 817      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified"> 818      *       &lt;td&gt;{@code argument.toString()}</span>
 819      * &lt;/tbody&gt;
 820      * &lt;/table&gt;
 821      * &lt;p&gt;
<span class="line-modified"> 822      * If {@code pos} is non-null, and refers to</span>
<span class="line-modified"> 823      * {@code Field.ARGUMENT}, the location of the first formatted</span>
 824      * string will be returned.
 825      *
 826      * @param arguments an array of objects to be formatted and substituted.
 827      * @param result where text is appended.
 828      * @param pos keeps track on the position of the first replaced argument
 829                   in the output string.
 830      * @return the string buffer passed in as {@code result}, with formatted
 831      * text appended
<span class="line-modified"> 832      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 833      *            {@code arguments} array is not of the type</span>
 834      *            expected by the format element(s) that use it.
<span class="line-modified"> 835      * @throws    NullPointerException if {@code result} is {@code null}</span>
 836      */
 837     public final StringBuffer format(Object[] arguments, StringBuffer result,
 838                                      FieldPosition pos)
 839     {
 840         return subformat(arguments, result, pos, null);
 841     }
 842 
 843     /**
 844      * Creates a MessageFormat with the given pattern and uses it
 845      * to format the given arguments. This is equivalent to
 846      * &lt;blockquote&gt;
 847      *     &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 848      * &lt;/blockquote&gt;
 849      *
 850      * @param pattern   the pattern string
 851      * @param arguments object(s) to format
 852      * @return the formatted string
<span class="line-modified"> 853      * @throws    IllegalArgumentException if the pattern is invalid,</span>
<span class="line-modified"> 854      *            or if an argument in the {@code arguments} array</span>
 855      *            is not of the type expected by the format element(s)
 856      *            that use it.
<span class="line-modified"> 857      * @throws    NullPointerException if {@code pattern} is {@code null}</span>
 858      */
 859     public static String format(String pattern, Object ... arguments) {
 860         MessageFormat temp = new MessageFormat(pattern);
 861         return temp.format(arguments);
 862     }
 863 
 864     // Overrides
 865     /**
<span class="line-modified"> 866      * Formats an array of objects and appends the {@code MessageFormat}&#39;s</span>
 867      * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified"> 868      * provided {@code StringBuffer}.</span>
 869      * This is equivalent to
 870      * &lt;blockquote&gt;
 871      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
 872      * &lt;/blockquote&gt;
 873      *
 874      * @param arguments an array of objects to be formatted and substituted.
 875      * @param result where text is appended.
 876      * @param pos keeps track on the position of the first replaced argument
 877      *            in the output string.
<span class="line-modified"> 878      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 879      *            {@code arguments} array is not of the type</span>
 880      *            expected by the format element(s) that use it.
<span class="line-modified"> 881      * @throws    NullPointerException if {@code result} is {@code null}</span>
 882      */
 883     public final StringBuffer format(Object arguments, StringBuffer result,
 884                                      FieldPosition pos)
 885     {
 886         return subformat((Object[]) arguments, result, pos, null);
 887     }
 888 
 889     /**
 890      * Formats an array of objects and inserts them into the
<span class="line-modified"> 891      * {@code MessageFormat}&#39;s pattern, producing an</span>
<span class="line-modified"> 892      * {@code AttributedCharacterIterator}.</span>
<span class="line-modified"> 893      * You can use the returned {@code AttributedCharacterIterator}</span>
 894      * to build the resulting String, as well as to determine information
 895      * about the resulting String.
 896      * &lt;p&gt;
<span class="line-modified"> 897      * The text of the returned {@code AttributedCharacterIterator} is</span>
 898      * the same that would be returned by
 899      * &lt;blockquote&gt;
 900      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 901      * &lt;/blockquote&gt;
 902      * &lt;p&gt;
<span class="line-modified"> 903      * In addition, the {@code AttributedCharacterIterator} contains at</span>
 904      * least attributes indicating where text was generated from an
<span class="line-modified"> 905      * argument in the {@code arguments} array. The keys of these attributes are of</span>
<span class="line-modified"> 906      * type {@code MessageFormat.Field}, their values are</span>
<span class="line-modified"> 907      * {@code Integer} objects indicating the index in the {@code arguments}</span>
 908      * array of the argument from which the text was generated.
 909      * &lt;p&gt;
<span class="line-modified"> 910      * The attributes/value from the underlying {@code Format}</span>
<span class="line-modified"> 911      * instances that {@code MessageFormat} uses will also be</span>
<span class="line-modified"> 912      * placed in the resulting {@code AttributedCharacterIterator}.</span>
 913      * This allows you to not only find where an argument is placed in the
 914      * resulting String, but also which fields it contains in turn.
 915      *
 916      * @param arguments an array of objects to be formatted and substituted.
 917      * @return AttributedCharacterIterator describing the formatted value.
<span class="line-modified"> 918      * @throws    NullPointerException if {@code arguments} is null.</span>
<span class="line-modified"> 919      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 920      *            {@code arguments} array is not of the type</span>
 921      *            expected by the format element(s) that use it.
 922      * @since 1.4
 923      */
 924     public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
 925         StringBuffer result = new StringBuffer();
 926         ArrayList&lt;AttributedCharacterIterator&gt; iterators = new ArrayList&lt;&gt;();
 927 
 928         if (arguments == null) {
 929             throw new NullPointerException(
 930                    &quot;formatToCharacterIterator must be passed non-null object&quot;);
 931         }
 932         subformat((Object[]) arguments, result, null, iterators);
 933         if (iterators.size() == 0) {
 934             return createAttributedCharacterIterator(&quot;&quot;);
 935         }
 936         return createAttributedCharacterIterator(
 937                      iterators.toArray(
 938                      new AttributedCharacterIterator[iterators.size()]));
 939     }
 940 
</pre>
<hr />
<pre>
 951      *     the substituted strings contain {n} references.)
 952      * &lt;li&gt;Will not always find a match (or the correct match)
 953      *     if some part of the parse is ambiguous.
 954      *     For example, if the pattern &quot;{1},{2}&quot; is used with the
 955      *     string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
 956      *     When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
 957      * &lt;li&gt;If a single argument is parsed more than once in the string,
 958      *     then the later parse wins.
 959      * &lt;/ul&gt;
 960      * When the parse fails, use ParsePosition.getErrorIndex() to find out
 961      * where in the string the parsing failed.  The returned error
 962      * index is the starting offset of the sub-patterns that the string
 963      * is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
 964      * is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
 965      * 0. When an error occurs, the call to this method will return null.
 966      * If the source is null, return an empty array.
 967      *
 968      * @param source the string to parse
 969      * @param pos    the parse position
 970      * @return an array of parsed objects
<span class="line-modified"> 971      * @throws    NullPointerException if {@code pos} is {@code null}</span>
 972      *            for a non-null {@code source} string.
 973      */
 974     public Object[] parse(String source, ParsePosition pos) {
 975         if (source == null) {
 976             Object[] empty = {};
 977             return empty;
 978         }
 979 
 980         int maximumArgumentNumber = -1;
 981         for (int i = 0; i &lt;= maxOffset; i++) {
 982             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 983                 maximumArgumentNumber = argumentNumbers[i];
 984             }
 985         }
 986         Object[] resultArray = new Object[maximumArgumentNumber + 1];
 987 
 988         int patternOffset = 0;
 989         int sourceOffset = pos.index;
 990         ParsePosition tempStatus = new ParsePosition(0);
 991         for (int i = 0; i &lt;= maxOffset; ++i) {
</pre>
<hr />
<pre>
1038         }
1039         int len = pattern.length() - patternOffset;
1040         if (len == 0 || pattern.regionMatches(patternOffset,
1041                                               source, sourceOffset, len)) {
1042             pos.index = sourceOffset + len;
1043         } else {
1044             pos.errorIndex = sourceOffset;
1045             return null; // leave index as is to signal error
1046         }
1047         return resultArray;
1048     }
1049 
1050     /**
1051      * Parses text from the beginning of the given string to produce an object
1052      * array.
1053      * The method may not use the entire text of the given string.
1054      * &lt;p&gt;
1055      * See the {@link #parse(String, ParsePosition)} method for more information
1056      * on message parsing.
1057      *
<span class="line-modified">1058      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">1059      * @return An {@code Object} array parsed from the string.</span>
<span class="line-modified">1060      * @throws    ParseException if the beginning of the specified string</span>
1061      *            cannot be parsed.
1062      */
1063     public Object[] parse(String source) throws ParseException {
1064         ParsePosition pos  = new ParsePosition(0);
1065         Object[] result = parse(source, pos);
1066         if (pos.index == 0)  // unchanged, returned object is null
1067             throw new ParseException(&quot;MessageFormat parse error!&quot;, pos.errorIndex);
1068 
1069         return result;
1070     }
1071 
1072     /**
1073      * Parses text from a string to produce an object array.
1074      * &lt;p&gt;
1075      * The method attempts to parse text starting at the index given by
<span class="line-modified">1076      * {@code pos}.</span>
<span class="line-modified">1077      * If parsing succeeds, then the index of {@code pos} is updated</span>
1078      * to the index after the last character used (parsing does not necessarily
1079      * use all characters up to the end of the string), and the parsed
<span class="line-modified">1080      * object array is returned. The updated {@code pos} can be used to</span>
1081      * indicate the starting point for the next call to this method.
<span class="line-modified">1082      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">1083      * changed, the error index of {@code pos} is set to the index of</span>
1084      * the character where the error occurred, and null is returned.
1085      * &lt;p&gt;
1086      * See the {@link #parse(String, ParsePosition)} method for more information
1087      * on message parsing.
1088      *
<span class="line-modified">1089      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">1090      * @param pos A {@code ParsePosition} object with index and error</span>
1091      *            index information as described above.
<span class="line-modified">1092      * @return An {@code Object} array parsed from the string. In case of</span>
1093      *         error, returns null.
1094      * @throws NullPointerException if {@code pos} is null.
1095      */
1096     public Object parseObject(String source, ParsePosition pos) {
1097         return parse(source, pos);
1098     }
1099 
1100     /**
1101      * Creates and returns a copy of this object.
1102      *
1103      * @return a clone of this instance.
1104      */
1105     public Object clone() {
1106         MessageFormat other = (MessageFormat) super.clone();
1107 
1108         // clone arrays. Can&#39;t do with utility because of bug in Cloneable
1109         other.formats = formats.clone(); // shallow clone
1110         for (int i = 0; i &lt; formats.length; ++i) {
1111             if (formats[i] != null)
1112                 other.formats[i] = (Format)formats[i].clone();
</pre>
<hr />
<pre>
1129         MessageFormat other = (MessageFormat) obj;
1130         return (maxOffset == other.maxOffset
1131                 &amp;&amp; pattern.equals(other.pattern)
1132                 &amp;&amp; ((locale != null &amp;&amp; locale.equals(other.locale))
1133                  || (locale == null &amp;&amp; other.locale == null))
1134                 &amp;&amp; Arrays.equals(offsets,other.offsets)
1135                 &amp;&amp; Arrays.equals(argumentNumbers,other.argumentNumbers)
1136                 &amp;&amp; Arrays.equals(formats,other.formats));
1137     }
1138 
1139     /**
1140      * Generates a hash code for the message format object.
1141      */
1142     public int hashCode() {
1143         return pattern.hashCode(); // enough for reasonable distribution
1144     }
1145 
1146 
1147     /**
1148      * Defines constants that are used as attribute keys in the
<span class="line-modified">1149      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">1150      * from {@code MessageFormat.formatToCharacterIterator}.</span>
1151      *
1152      * @since 1.4
1153      */
1154     public static class Field extends Format.Field {
1155 
1156         // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">1157         @java.io.Serial</span>
1158         private static final long serialVersionUID = 7899943957617360810L;
1159 
1160         /**
1161          * Creates a Field with the specified name.
1162          *
1163          * @param name Name of the attribute
1164          */
1165         protected Field(String name) {
1166             super(name);
1167         }
1168 
1169         /**
1170          * Resolves instances being deserialized to the predefined constants.
1171          *
1172          * @throws InvalidObjectException if the constant could not be
1173          *         resolved.
1174          * @return resolved MessageFormat.Field constant
1175          */
<span class="line-added">1176         @java.io.Serial</span>
1177         protected Object readResolve() throws InvalidObjectException {
1178             if (this.getClass() != MessageFormat.Field.class) {
1179                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1180             }
1181 
1182             return ARGUMENT;
1183         }
1184 
1185         //
1186         // The constants
1187         //
1188 
1189         /**
1190          * Constant identifying a portion of a message that was generated
<span class="line-modified">1191          * from an argument passed into {@code formatToCharacterIterator}.</span>
<span class="line-modified">1192          * The value associated with the key will be an {@code Integer}</span>
<span class="line-modified">1193          * indicating the index in the {@code arguments} array of the</span>
1194          * argument from which the text was generated.
1195          */
1196         public static final Field ARGUMENT =
1197                            new Field(&quot;message argument field&quot;);
1198     }
1199 
1200     // ===========================privates============================
1201 
1202     /**
1203      * The locale to use for formatting numbers and dates.
1204      * @serial
1205      */
1206     private Locale locale;
1207 
1208     /**
1209      * The string that the formatted values are to be plugged into.  In other words, this
1210      * is the pattern supplied on construction with all of the {} expressions taken out.
1211      * @serial
1212      */
1213     private String pattern = &quot;&quot;;
</pre>
<hr />
<pre>
1220      * @serial
1221      */
1222     private Format[] formats = new Format[INITIAL_FORMATS];
1223 
1224     /**
1225      * The positions where the results of formatting each argument are to be inserted
1226      * into the pattern.
1227      * @serial
1228      */
1229     private int[] offsets = new int[INITIAL_FORMATS];
1230 
1231     /**
1232      * The argument numbers corresponding to each formatter.  (The formatters are stored
1233      * in the order they occur in the pattern, not in the order in which the arguments
1234      * are specified.)
1235      * @serial
1236      */
1237     private int[] argumentNumbers = new int[INITIAL_FORMATS];
1238 
1239     /**
<span class="line-modified">1240      * One less than the number of entries in {@code offsets}.  Can also be thought of</span>
<span class="line-modified">1241      * as the index of the highest-numbered element in {@code offsets} that is being used.</span>
<span class="line-modified">1242      * All of these arrays should have the same number of elements being used as {@code offsets}</span>
1243      * does, and so this variable suffices to tell us how many entries are in all of them.
1244      * @serial
1245      */
1246     private int maxOffset = -1;
1247 
1248     /**
1249      * Internal routine used by format. If {@code characterIterators} is
1250      * {@code non-null}, AttributedCharacterIterator will be created from the
1251      * subformats as necessary. If {@code characterIterators} is {@code null}
1252      * and {@code fp} is {@code non-null} and identifies
1253      * {@code Field.ARGUMENT} as the field attribute, the location of
1254      * the first replaced argument will be set in it.
1255      *
<span class="line-modified">1256      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified">1257      *            {@code arguments} array is not of the type</span>
1258      *            expected by the format element(s) that use it.
1259      */
1260     private StringBuffer subformat(Object[] arguments, StringBuffer result,
1261                                    FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
1262         // note: this implementation assumes a fast substring &amp; index.
1263         // if this is not true, would be better to append chars one by one.
1264         int lastOffset = 0;
1265         int last = result.length();
1266         for (int i = 0; i &lt;= maxOffset; ++i) {
1267             result.append(pattern, lastOffset, offsets[i]);
1268             lastOffset = offsets[i];
1269             int argumentNumber = argumentNumbers[i];
1270             if (arguments == null || argumentNumber &gt;= arguments.length) {
1271                 result.append(&#39;{&#39;).append(argumentNumber).append(&#39;}&#39;);
1272                 continue;
1273             }
1274             // int argRecursion = ((recursionProtection &gt;&gt; (argumentNumber*2)) &amp; 0x3);
1275             if (false) { // if (argRecursion == 3){
1276                 // prevent loop!!!
1277                 result.append(&#39;\uFFFD&#39;);
</pre>
<hr />
<pre>
1350                     result.append(arg);
1351                     if (i == 0 &amp;&amp; fp != null &amp;&amp; Field.ARGUMENT.equals(
1352                                   fp.getFieldAttribute())) {
1353                         fp.setBeginIndex(last);
1354                         fp.setEndIndex(result.length());
1355                     }
1356                     last = result.length();
1357                 }
1358             }
1359         }
1360         result.append(pattern, lastOffset, pattern.length());
1361         if (characterIterators != null &amp;&amp; last != result.length()) {
1362             characterIterators.add(createAttributedCharacterIterator(
1363                                    result.substring(last)));
1364         }
1365         return result;
1366     }
1367 
1368     /**
1369      * Convenience method to append all the characters in
<span class="line-modified">1370      * {@code iterator} to the StringBuffer {@code result}.</span>
1371      */
1372     private void append(StringBuffer result, CharacterIterator iterator) {
1373         if (iterator.first() != CharacterIterator.DONE) {
1374             char aChar;
1375 
1376             result.append(iterator.first());
1377             while ((aChar = iterator.next()) != CharacterIterator.DONE) {
1378                 result.append(aChar);
1379             }
1380         }
1381     }
1382 
1383     // Indices for segments
1384     private static final int SEG_RAW      = 0;
1385     private static final int SEG_INDEX    = 1;
1386     private static final int SEG_TYPE     = 2;
1387     private static final int SEG_MODIFIER = 3; // modifier or subformat
1388 
1389     // Indices for type keywords
1390     private static final int TYPE_NULL    = 0;
</pre>
<hr />
<pre>
1587             } else if (ch == &#39;\&#39;&#39;) {
1588                 target.append(&quot;&#39;&#39;&quot;);
1589             } else {
1590                 if (quoted) {
1591                     target.append(&#39;\&#39;&#39;);
1592                     quoted = false;
1593                 }
1594                 target.append(ch);
1595             }
1596         }
1597         if (quoted) {
1598             target.append(&#39;\&#39;&#39;);
1599         }
1600     }
1601 
1602     /**
1603      * After reading an object from the input stream, do a simple verification
1604      * to maintain class invariants.
1605      * @throws InvalidObjectException if the objects read from the stream is invalid.
1606      */
<span class="line-added">1607     @java.io.Serial</span>
1608     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1609         in.defaultReadObject();
1610         boolean isValid = maxOffset &gt;= -1
1611                 &amp;&amp; formats.length &gt; maxOffset
1612                 &amp;&amp; offsets.length &gt; maxOffset
1613                 &amp;&amp; argumentNumbers.length &gt; maxOffset;
1614         if (isValid) {
1615             int lastOffset = pattern.length() + 1;
1616             for (int i = maxOffset; i &gt;= 0; --i) {
1617                 if ((offsets[i] &lt; 0) || (offsets[i] &gt; lastOffset)) {
1618                     isValid = false;
1619                     break;
1620                 } else {
1621                     lastOffset = offsets[i];
1622                 }
1623             }
1624         }
1625         if (!isValid) {
1626             throw new InvalidObjectException(&quot;Could not reconstruct MessageFormat from corrupt stream.&quot;);
1627         }
</pre>
</td>
</tr>
</table>
<center><a href="MergeCollation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Normalizer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
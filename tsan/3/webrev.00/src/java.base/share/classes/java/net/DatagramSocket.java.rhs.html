<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/DatagramSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-added">  29 import java.io.UncheckedIOException;</span>
  30 import java.nio.channels.DatagramChannel;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedExceptionAction;
<a name="3" id="anc3"></a><span class="line-added">  33 import java.util.Objects;</span>
  34 import java.util.Set;
  35 import java.util.Collections;
  36 
  37 /**
  38  * This class represents a socket for sending and receiving datagram packets.
  39  *
  40  * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
  41  * delivery service. Each packet sent or received on a datagram socket
  42  * is individually addressed and routed. Multiple packets sent from
  43  * one machine to another may be routed differently, and may arrive in
  44  * any order.
  45  *
  46  * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
<a name="4" id="anc4"></a><span class="line-modified">  47  * {@link StandardSocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as</span>
  48  * to allow the transmission of broadcast datagrams. In order to receive
  49  * broadcast packets a DatagramSocket should be bound to the wildcard address.
  50  * In some implementations, broadcast packets may also be received when
  51  * a DatagramSocket is bound to a more specific address.
  52  * &lt;p&gt;
  53  * Example:
<a name="5" id="anc5"></a><span class="line-modified">  54  * &lt;pre&gt;{@code</span>
  55  *              DatagramSocket s = new DatagramSocket(null);
  56  *              s.bind(new InetSocketAddress(8888));
<a name="6" id="anc6"></a><span class="line-modified">  57  * }&lt;/pre&gt;</span>
  58  * Which is equivalent to:
<a name="7" id="anc7"></a><span class="line-modified">  59  * &lt;pre&gt;{@code</span>
  60  *              DatagramSocket s = new DatagramSocket(8888);
<a name="8" id="anc8"></a><span class="line-modified">  61  * }&lt;/pre&gt;</span>
  62  * Both cases will create a DatagramSocket able to receive broadcasts on
  63  * UDP port 8888.
  64  *
<a name="9" id="anc9"></a><span class="line-added">  65  * &lt;p&gt; The {@code DatagramSocket} class defines convenience</span>
<span class="line-added">  66  * methods to set and get several socket options. This class also</span>
<span class="line-added">  67  * defines the {@link #setOption(SocketOption,Object) setOption}</span>
<span class="line-added">  68  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added">  69  * and query socket options.</span>
<span class="line-added">  70  * A {@code DatagramSocket} supports the following socket options:</span>
<span class="line-added">  71  * &lt;blockquote&gt;</span>
<span class="line-added">  72  * &lt;a id=&quot;SocketOptions&quot;&gt;&lt;/a&gt;</span>
<span class="line-added">  73  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">  74  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added">  75  * &lt;thead&gt;</span>
<span class="line-added">  76  *   &lt;tr&gt;</span>
<span class="line-added">  77  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">  78  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">  79  *   &lt;/tr&gt;</span>
<span class="line-added">  80  * &lt;/thead&gt;</span>
<span class="line-added">  81  * &lt;tbody&gt;</span>
<span class="line-added">  82  *   &lt;tr&gt;</span>
<span class="line-added">  83  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;</span>
<span class="line-added">  84  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;</span>
<span class="line-added">  85  *   &lt;/tr&gt;</span>
<span class="line-added">  86  *   &lt;tr&gt;</span>
<span class="line-added">  87  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;</span>
<span class="line-added">  88  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;</span>
<span class="line-added">  89  *   &lt;/tr&gt;</span>
<span class="line-added">  90  *   &lt;tr&gt;</span>
<span class="line-added">  91  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;</span>
<span class="line-added">  92  *     &lt;td&gt; Re-use address &lt;/td&gt;</span>
<span class="line-added">  93  *   &lt;/tr&gt;</span>
<span class="line-added">  94  *   &lt;tr&gt;</span>
<span class="line-added">  95  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_BROADCAST SO_BROADCAST} &lt;/th&gt;</span>
<span class="line-added">  96  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;</span>
<span class="line-added">  97  *   &lt;/tr&gt;</span>
<span class="line-added">  98  *   &lt;tr&gt;</span>
<span class="line-added">  99  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;</span>
<span class="line-added"> 100  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;</span>
<span class="line-added"> 101  *   &lt;/tr&gt;</span>
<span class="line-added"> 102  * &lt;/tbody&gt;</span>
<span class="line-added"> 103  * &lt;/table&gt;</span>
<span class="line-added"> 104  * &lt;/blockquote&gt;</span>
<span class="line-added"> 105  * An implementation may also support additional options. In particular an implementation</span>
<span class="line-added"> 106  * may support &lt;a href=&quot;MulticastSocket.html#MulticastOptions&quot;&gt;multicast options&lt;/a&gt; which</span>
<span class="line-added"> 107  * can be useful when using a plain {@code DatagramSocket} to send datagrams to a</span>
<span class="line-added"> 108  * multicast group.</span>
<span class="line-added"> 109  *</span>
 110  * @author  Pavani Diwanji
 111  * @see     java.net.DatagramPacket
 112  * @see     java.nio.channels.DatagramChannel
 113  * @since 1.0
 114  */
<a name="10" id="anc10"></a><span class="line-modified"> 115 public class DatagramSocket implements java.io.Closeable {</span>

 116     /**
 117      * Various states of this socket.
 118      */
<a name="11" id="anc11"></a>
 119     private boolean bound = false;
 120     private boolean closed = false;
<a name="12" id="anc12"></a><span class="line-modified"> 121     private volatile boolean created;</span>
<span class="line-added"> 122     private final Object closeLock = new Object();</span>
 123 
 124     /*
 125      * The implementation of this DatagramSocket.
 126      */
<a name="13" id="anc13"></a><span class="line-modified"> 127     private final DatagramSocketImpl impl;</span>
 128 
 129     /**
 130      * Are we using an older DatagramSocketImpl?
 131      */
<a name="14" id="anc14"></a><span class="line-modified"> 132     final boolean oldImpl;</span>
 133 
 134     /**
 135      * Set when a socket is ST_CONNECTED until we are certain
 136      * that any packets which might have been received prior
 137      * to calling connect() but not read by the application
 138      * have been read. During this time we check the source
 139      * address of all packets received to be sure they are from
 140      * the connected destination. Other packets are read but
 141      * silently dropped.
 142      */
 143     private boolean explicitFilter = false;
 144     private int bytesLeftToFilter;
 145     /*
 146      * Connection state:
 147      * ST_NOT_CONNECTED = socket not connected
 148      * ST_CONNECTED = socket connected
 149      * ST_CONNECTED_NO_IMPL = socket connected but not at impl level
 150      */
 151     static final int ST_NOT_CONNECTED = 0;
 152     static final int ST_CONNECTED = 1;
 153     static final int ST_CONNECTED_NO_IMPL = 2;
 154 
 155     int connectState = ST_NOT_CONNECTED;
 156 
 157     /*
 158      * Connected address &amp; port
 159      */
 160     InetAddress connectedAddress = null;
 161     int connectedPort = -1;
 162 
 163     /**
 164      * Connects this socket to a remote socket address (IP address + port number).
 165      * Binds socket if not already bound.
 166      *
 167      * @param   address The remote address.
 168      * @param   port    The remote port
 169      * @throws  SocketException if binding the socket fails.
 170      */
 171     private synchronized void connectInternal(InetAddress address, int port) throws SocketException {
 172         if (port &lt; 0 || port &gt; 0xFFFF) {
 173             throw new IllegalArgumentException(&quot;connect: &quot; + port);
 174         }
 175         if (address == null) {
 176             throw new IllegalArgumentException(&quot;connect: null address&quot;);
 177         }
 178         checkAddress (address, &quot;connect&quot;);
 179         if (isClosed())
 180             return;
 181         SecurityManager security = System.getSecurityManager();
 182         if (security != null) {
 183             if (address.isMulticastAddress()) {
 184                 security.checkMulticast(address);
 185             } else {
 186                 security.checkConnect(address.getHostAddress(), port);
 187                 security.checkAccept(address.getHostAddress(), port);
 188             }
 189         }
 190 
 191         if (!isBound())
 192           bind(new InetSocketAddress(0));
 193 
 194         // old impls do not support connect/disconnect
 195         if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &amp;&amp;
 196              ((AbstractPlainDatagramSocketImpl)impl).nativeConnectDisabled())) {
 197             connectState = ST_CONNECTED_NO_IMPL;
 198         } else {
 199             try {
 200                 getImpl().connect(address, port);
 201 
 202                 // socket is now connected by the impl
 203                 connectState = ST_CONNECTED;
 204                 // Do we need to filter some packets?
 205                 int avail = getImpl().dataAvailable();
 206                 if (avail == -1) {
 207                     throw new SocketException();
 208                 }
 209                 explicitFilter = avail &gt; 0;
 210                 if (explicitFilter) {
 211                     bytesLeftToFilter = getReceiveBufferSize();
 212                 }
 213             } catch (SocketException se) {
 214 
 215                 // connection will be emulated by DatagramSocket
 216                 connectState = ST_CONNECTED_NO_IMPL;
 217             }
 218         }
 219 
 220         connectedAddress = address;
 221         connectedPort = port;
 222     }
 223 
 224 
 225     /**
 226      * Constructs a datagram socket and binds it to any available port
 227      * on the local host machine.  The socket will be bound to the
 228      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 229      * an IP address chosen by the kernel.
 230      *
 231      * &lt;p&gt;If there is a security manager,
 232      * its {@code checkListen} method is first called
 233      * with 0 as its argument to ensure the operation is allowed.
 234      * This could result in a SecurityException.
 235      *
<a name="15" id="anc15"></a><span class="line-modified"> 236      * @throws     SocketException  if the socket could not be opened,</span>
 237      *               or the socket could not bind to the specified local port.
<a name="16" id="anc16"></a><span class="line-modified"> 238      * @throws     SecurityException  if a security manager exists and its</span>
 239      *             {@code checkListen} method doesn&#39;t allow the operation.
 240      *
 241      * @see SecurityManager#checkListen
 242      */
 243     public DatagramSocket() throws SocketException {
 244         this(new InetSocketAddress(0));
 245     }
 246 
 247     /**
 248      * Creates an unbound datagram socket with the specified
 249      * DatagramSocketImpl.
 250      *
 251      * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
 252      *        the subclass wishes to use on the DatagramSocket.
 253      * @since   1.4
 254      */
 255     protected DatagramSocket(DatagramSocketImpl impl) {
 256         if (impl == null)
 257             throw new NullPointerException();
 258         this.impl = impl;
<a name="17" id="anc17"></a><span class="line-modified"> 259         this.oldImpl = checkOldImpl(impl);</span>
 260     }
 261 
 262     /**
 263      * Creates a datagram socket, bound to the specified local
 264      * socket address.
 265      * &lt;p&gt;
 266      * If, if the address is {@code null}, creates an unbound socket.
 267      *
 268      * &lt;p&gt;If there is a security manager,
 269      * its {@code checkListen} method is first called
 270      * with the port from the socket address
 271      * as its argument to ensure the operation is allowed.
 272      * This could result in a SecurityException.
 273      *
 274      * @param bindaddr local socket address to bind, or {@code null}
 275      *                 for an unbound socket.
 276      *
<a name="18" id="anc18"></a><span class="line-modified"> 277      * @throws     SocketException  if the socket could not be opened,</span>
 278      *               or the socket could not bind to the specified local port.
<a name="19" id="anc19"></a><span class="line-modified"> 279      * @throws     SecurityException  if a security manager exists and its</span>
 280      *             {@code checkListen} method doesn&#39;t allow the operation.
 281      *
 282      * @see SecurityManager#checkListen
 283      * @since   1.4
 284      */
 285     public DatagramSocket(SocketAddress bindaddr) throws SocketException {
<a name="20" id="anc20"></a><span class="line-added"> 286         // Special case initialization for the DatagramChannel socket adaptor.</span>
<span class="line-added"> 287         if (this instanceof sun.nio.ch.DatagramSocketAdaptor) {</span>
<span class="line-added"> 288             this.impl = null;  // no DatagramSocketImpl</span>
<span class="line-added"> 289             this.oldImpl = false;</span>
<span class="line-added"> 290             return;</span>
<span class="line-added"> 291         }</span>
<span class="line-added"> 292 </span>
 293         // create a datagram socket.
<a name="21" id="anc21"></a><span class="line-modified"> 294         boolean multicast = (this instanceof MulticastSocket);</span>
<span class="line-added"> 295         this.impl = createImpl(multicast);</span>
<span class="line-added"> 296         // creates the udp socket</span>
<span class="line-added"> 297         impl.create();</span>
<span class="line-added"> 298         created = true;</span>
<span class="line-added"> 299         this.oldImpl = checkOldImpl(impl);</span>
 300         if (bindaddr != null) {
 301             try {
 302                 bind(bindaddr);
 303             } finally {
 304                 if (!isBound())
 305                     close();
 306             }
 307         }
 308     }
 309 
 310     /**
 311      * Constructs a datagram socket and binds it to the specified port
 312      * on the local host machine.  The socket will be bound to the
 313      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 314      * an IP address chosen by the kernel.
 315      *
 316      * &lt;p&gt;If there is a security manager,
 317      * its {@code checkListen} method is first called
 318      * with the {@code port} argument
 319      * as its argument to ensure the operation is allowed.
 320      * This could result in a SecurityException.
 321      *
 322      * @param      port port to use.
<a name="22" id="anc22"></a><span class="line-modified"> 323      * @throws     SocketException  if the socket could not be opened,</span>
 324      *               or the socket could not bind to the specified local port.
<a name="23" id="anc23"></a><span class="line-modified"> 325      * @throws     SecurityException  if a security manager exists and its</span>
 326      *             {@code checkListen} method doesn&#39;t allow the operation.
 327      *
 328      * @see SecurityManager#checkListen
 329      */
 330     public DatagramSocket(int port) throws SocketException {
 331         this(port, null);
 332     }
 333 
 334     /**
 335      * Creates a datagram socket, bound to the specified local
 336      * address.  The local port must be between 0 and 65535 inclusive.
 337      * If the IP address is 0.0.0.0, the socket will be bound to the
 338      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 339      * an IP address chosen by the kernel.
 340      *
 341      * &lt;p&gt;If there is a security manager,
 342      * its {@code checkListen} method is first called
 343      * with the {@code port} argument
 344      * as its argument to ensure the operation is allowed.
 345      * This could result in a SecurityException.
 346      *
 347      * @param port local port to use
 348      * @param laddr local address to bind
 349      *
<a name="24" id="anc24"></a><span class="line-modified"> 350      * @throws     SocketException  if the socket could not be opened,</span>
 351      *               or the socket could not bind to the specified local port.
<a name="25" id="anc25"></a><span class="line-modified"> 352      * @throws     SecurityException  if a security manager exists and its</span>
 353      *             {@code checkListen} method doesn&#39;t allow the operation.
 354      *
 355      * @see SecurityManager#checkListen
 356      * @since   1.1
 357      */
 358     public DatagramSocket(int port, InetAddress laddr) throws SocketException {
 359         this(new InetSocketAddress(laddr, port));
 360     }
 361 
<a name="26" id="anc26"></a><span class="line-modified"> 362     /**</span>
<span class="line-modified"> 363      * Return true if the given DatagramSocketImpl is an &quot;old&quot; impl. An old impl</span>
<span class="line-modified"> 364      * is one that doesn&#39;t implement the abstract methods added in Java SE 1.4.</span>
<span class="line-added"> 365      */</span>
<span class="line-added"> 366     private static boolean checkOldImpl(DatagramSocketImpl impl) {</span>
 367         // DatagramSocketImpl.peekData() is a protected method, therefore we need to use
 368         // getDeclaredMethod, therefore we need permission to access the member
 369         try {
 370             AccessController.doPrivileged(
 371                 new PrivilegedExceptionAction&lt;&gt;() {
 372                     public Void run() throws NoSuchMethodException {
 373                         Class&lt;?&gt;[] cl = new Class&lt;?&gt;[1];
 374                         cl[0] = DatagramPacket.class;
 375                         impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);
 376                         return null;
 377                     }
 378                 });
<a name="27" id="anc27"></a><span class="line-added"> 379             return false;</span>
 380         } catch (java.security.PrivilegedActionException e) {
<a name="28" id="anc28"></a><span class="line-modified"> 381             return true;</span>
 382         }
 383     }
 384 
 385     static Class&lt;?&gt; implClass = null;
 386 
<a name="29" id="anc29"></a><span class="line-modified"> 387     /**</span>
<span class="line-modified"> 388      * Creates a DatagramSocketImpl.</span>
<span class="line-modified"> 389      * @param multicast true if the DatagramSocketImpl is for a MulticastSocket</span>
<span class="line-modified"> 390      */</span>
<span class="line-modified"> 391     private static DatagramSocketImpl createImpl(boolean multicast) throws SocketException {</span>
<span class="line-modified"> 392         DatagramSocketImpl impl;</span>
<span class="line-modified"> 393         DatagramSocketImplFactory factory = DatagramSocket.factory;</span>
<span class="line-modified"> 394         if (factory != null) {</span>
<span class="line-modified"> 395             impl = factory.createDatagramSocketImpl();</span>
<span class="line-modified"> 396         } else {</span>
<span class="line-modified"> 397             impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);</span>
 398         }
<a name="30" id="anc30"></a><span class="line-modified"> 399         return impl;</span>



 400     }
 401 
 402     /**
<a name="31" id="anc31"></a><span class="line-modified"> 403      * Return the {@code DatagramSocketImpl} attached to this socket,</span>
<span class="line-modified"> 404      * creating the socket if not already created.</span>
 405      *
 406      * @return  the {@code DatagramSocketImpl} attached to that
 407      *          DatagramSocket
<a name="32" id="anc32"></a><span class="line-modified"> 408      * @throws SocketException if creating the socket fails</span>
 409      * @since 1.4
 410      */
<a name="33" id="anc33"></a><span class="line-modified"> 411     final DatagramSocketImpl getImpl() throws SocketException {</span>
<span class="line-modified"> 412         if (!created) {</span>
<span class="line-modified"> 413             synchronized (this) {</span>
<span class="line-added"> 414                 if (!created)  {</span>
<span class="line-added"> 415                     impl.create();</span>
<span class="line-added"> 416                     created = true;</span>
<span class="line-added"> 417                 }</span>
<span class="line-added"> 418             }</span>
<span class="line-added"> 419         }</span>
 420         return impl;
 421     }
 422 
 423     /**
 424      * Binds this DatagramSocket to a specific address and port.
 425      * &lt;p&gt;
 426      * If the address is {@code null}, then the system will pick up
 427      * an ephemeral port and a valid local address to bind the socket.
 428      *
 429      * @param   addr The address and port to bind to.
 430      * @throws  SocketException if any error happens during the bind, or if the
 431      *          socket is already bound.
 432      * @throws  SecurityException  if a security manager exists and its
 433      *             {@code checkListen} method doesn&#39;t allow the operation.
 434      * @throws IllegalArgumentException if addr is a SocketAddress subclass
 435      *         not supported by this socket.
 436      * @since 1.4
 437      */
 438     public synchronized void bind(SocketAddress addr) throws SocketException {
 439         if (isClosed())
 440             throw new SocketException(&quot;Socket is closed&quot;);
 441         if (isBound())
 442             throw new SocketException(&quot;already bound&quot;);
 443         if (addr == null)
 444             addr = new InetSocketAddress(0);
 445         if (!(addr instanceof InetSocketAddress))
 446             throw new IllegalArgumentException(&quot;Unsupported address type!&quot;);
 447         InetSocketAddress epoint = (InetSocketAddress) addr;
 448         if (epoint.isUnresolved())
 449             throw new SocketException(&quot;Unresolved address&quot;);
 450         InetAddress iaddr = epoint.getAddress();
 451         int port = epoint.getPort();
 452         checkAddress(iaddr, &quot;bind&quot;);
 453         SecurityManager sec = System.getSecurityManager();
 454         if (sec != null) {
 455             sec.checkListen(port);
 456         }
 457         try {
 458             getImpl().bind(port, iaddr);
 459         } catch (SocketException e) {
 460             getImpl().close();
 461             throw e;
 462         }
 463         bound = true;
 464     }
 465 
 466     void checkAddress (InetAddress addr, String op) {
 467         if (addr == null) {
 468             return;
 469         }
 470         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {
 471             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);
 472         }
 473     }
 474 
 475     /**
 476      * Connects the socket to a remote address for this socket. When a
 477      * socket is connected to a remote address, packets may only be
 478      * sent to or received from that address. By default a datagram
<a name="34" id="anc34"></a><span class="line-modified"> 479      * socket is not connected. If the socket is already closed,</span>
<span class="line-added"> 480      * then this method has no effect.</span>
 481      *
<a name="35" id="anc35"></a><span class="line-modified"> 482      * &lt;p&gt; If this socket is not bound then this method will first cause the</span>
<span class="line-modified"> 483      * socket to be bound to an address that is assigned automatically,</span>
<span class="line-modified"> 484      * as if invoking the {@link #bind bind} method with a parameter of</span>
<span class="line-modified"> 485      * {@code null}. If the remote destination to which the socket is connected</span>
<span class="line-modified"> 486      * does not exist, or is otherwise unreachable, and if an ICMP destination</span>
<span class="line-added"> 487      * unreachable packet has been received for that address, then a subsequent</span>
<span class="line-added"> 488      * call to send or receive may throw a PortUnreachableException. Note,</span>
<span class="line-added"> 489      * there is no guarantee that the exception will be thrown.</span>
 490      *
 491      * &lt;p&gt; If a security manager has been installed then it is invoked to check
 492      * access to the remote address. Specifically, if the given {@code address}
 493      * is a {@link InetAddress#isMulticastAddress multicast address},
 494      * the security manager&#39;s {@link
 495      * java.lang.SecurityManager#checkMulticast(InetAddress)
 496      * checkMulticast} method is invoked with the given {@code address}.
 497      * Otherwise, the security manager&#39;s {@link
 498      * java.lang.SecurityManager#checkConnect(String,int) checkConnect}
 499      * and {@link java.lang.SecurityManager#checkAccept checkAccept} methods
 500      * are invoked, with the given {@code address} and {@code port}, to
 501      * verify that datagrams are permitted to be sent and received
 502      * respectively.
 503      *
<a name="36" id="anc36"></a><span class="line-modified"> 504      * &lt;p&gt; Care should be taken to ensure that a connected datagram socket</span>
<span class="line-modified"> 505      * is not shared with untrusted code. When a socket is connected,</span>
<span class="line-modified"> 506      * {@link #receive receive} and {@link #send send} &lt;b&gt;will not perform</span>
<span class="line-modified"> 507      * any security checks&lt;/b&gt; on incoming and outgoing packets, other than</span>
<span class="line-modified"> 508      * matching the packet&#39;s and the socket&#39;s address and port. On a send</span>
<span class="line-modified"> 509      * operation, if the packet&#39;s address is set and the packet&#39;s address</span>
<span class="line-modified"> 510      * and the socket&#39;s address do not match, an {@code IllegalArgumentException}</span>
<span class="line-modified"> 511      * will be thrown. A socket connected to a multicast address may only</span>
<span class="line-added"> 512      * be used to send packets.</span>
 513      *
 514      * @param address the remote address for the socket
 515      *
 516      * @param port the remote port for the socket.
 517      *
 518      * @throws IllegalArgumentException
 519      *         if the address is null, or the port is out of range.
 520      *
 521      * @throws SecurityException
 522      *         if a security manager has been installed and it does
 523      *         not permit access to the given remote address
 524      *
<a name="37" id="anc37"></a><span class="line-added"> 525      * @throws UncheckedIOException</span>
<span class="line-added"> 526      *         may be thrown if connect fails, for example, if the</span>
<span class="line-added"> 527      *         destination address is non-routable</span>
<span class="line-added"> 528      *</span>
 529      * @see #disconnect
<a name="38" id="anc38"></a><span class="line-added"> 530      *</span>
<span class="line-added"> 531      * @since 1.2</span>
 532      */
 533     public void connect(InetAddress address, int port) {
 534         try {
 535             connectInternal(address, port);
 536         } catch (SocketException se) {
<a name="39" id="anc39"></a><span class="line-modified"> 537             throw new UncheckedIOException(&quot;connect failed&quot;, se);</span>
 538         }
 539     }
 540 
 541     /**
 542      * Connects this socket to a remote socket address (IP address + port number).
 543      *
 544      * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
 545      * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
<a name="40" id="anc40"></a><span class="line-modified"> 546      * with the given socket addresses IP address and port number, except that the</span>
<span class="line-added"> 547      * {@code SocketException} that may be raised is not wrapped in an</span>
<span class="line-added"> 548      * {@code UncheckedIOException}.</span>
 549      *
 550      * @param   addr    The remote address.
 551      *
 552      * @throws  SocketException
 553      *          if the connect fails
 554      *
 555      * @throws IllegalArgumentException
 556      *         if {@code addr} is {@code null}, or {@code addr} is a SocketAddress
 557      *         subclass not supported by this socket
 558      *
 559      * @throws SecurityException
 560      *         if a security manager has been installed and it does
 561      *         not permit access to the given remote address
 562      *
 563      * @since 1.4
 564      */
 565     public void connect(SocketAddress addr) throws SocketException {
 566         if (addr == null)
 567             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
 568         if (!(addr instanceof InetSocketAddress))
 569             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 570         InetSocketAddress epoint = (InetSocketAddress) addr;
 571         if (epoint.isUnresolved())
 572             throw new SocketException(&quot;Unresolved address&quot;);
 573         connectInternal(epoint.getAddress(), epoint.getPort());
 574     }
 575 
 576     /**
 577      * Disconnects the socket. If the socket is closed or not connected,
 578      * then this method has no effect.
 579      *
<a name="41" id="anc41"></a><span class="line-added"> 580      * @apiNote If this method throws an UncheckedIOException, the socket</span>
<span class="line-added"> 581      *          may be left in an unspecified state. It is strongly</span>
<span class="line-added"> 582      *          recommended that the socket be closed when disconnect</span>
<span class="line-added"> 583      *          fails.</span>
<span class="line-added"> 584      *</span>
<span class="line-added"> 585      * @throws  UncheckedIOException</span>
<span class="line-added"> 586      *          may be thrown if disconnect fails to dissolve the</span>
<span class="line-added"> 587      *          association and restore the socket to a consistent state.</span>
<span class="line-added"> 588      *</span>
 589      * @see #connect
<a name="42" id="anc42"></a><span class="line-added"> 590      *</span>
<span class="line-added"> 591      * @since 1.2</span>
 592      */
 593     public void disconnect() {
 594         synchronized (this) {
 595             if (isClosed())
 596                 return;
 597             if (connectState == ST_CONNECTED) {
 598                 impl.disconnect ();
 599             }
 600             connectedAddress = null;
 601             connectedPort = -1;
 602             connectState = ST_NOT_CONNECTED;
 603             explicitFilter = false;
 604         }
 605     }
 606 
 607     /**
 608      * Returns the binding state of the socket.
 609      * &lt;p&gt;
 610      * If the socket was bound prior to being {@link #close closed},
 611      * then this method will continue to return {@code true}
 612      * after the socket is closed.
 613      *
 614      * @return true if the socket successfully bound to an address
 615      * @since 1.4
 616      */
 617     public boolean isBound() {
 618         return bound;
 619     }
 620 
 621     /**
 622      * Returns the connection state of the socket.
 623      * &lt;p&gt;
 624      * If the socket was connected prior to being {@link #close closed},
 625      * then this method will continue to return {@code true}
 626      * after the socket is closed.
 627      *
 628      * @return true if the socket successfully connected to a server
 629      * @since 1.4
 630      */
 631     public boolean isConnected() {
 632         return connectState != ST_NOT_CONNECTED;
 633     }
 634 
 635     /**
 636      * Returns the address to which this socket is connected. Returns
 637      * {@code null} if the socket is not connected.
 638      * &lt;p&gt;
 639      * If the socket was connected prior to being {@link #close closed},
 640      * then this method will continue to return the connected address
 641      * after the socket is closed.
 642      *
 643      * @return the address to which this socket is connected.
<a name="43" id="anc43"></a><span class="line-added"> 644      * @since 1.2</span>
 645      */
 646     public InetAddress getInetAddress() {
 647         return connectedAddress;
 648     }
 649 
 650     /**
 651      * Returns the port number to which this socket is connected.
 652      * Returns {@code -1} if the socket is not connected.
 653      * &lt;p&gt;
 654      * If the socket was connected prior to being {@link #close closed},
 655      * then this method will continue to return the connected port number
 656      * after the socket is closed.
 657      *
 658      * @return the port number to which this socket is connected.
<a name="44" id="anc44"></a><span class="line-added"> 659      * @since 1.2</span>
 660      */
 661     public int getPort() {
 662         return connectedPort;
 663     }
 664 
 665     /**
 666      * Returns the address of the endpoint this socket is connected to, or
 667      * {@code null} if it is unconnected.
 668      * &lt;p&gt;
 669      * If the socket was connected prior to being {@link #close closed},
 670      * then this method will continue to return the connected address
 671      * after the socket is closed.
 672      *
 673      * @return a {@code SocketAddress} representing the remote
 674      *         endpoint of this socket, or {@code null} if it is
 675      *         not connected yet.
 676      * @see #getInetAddress()
 677      * @see #getPort()
 678      * @see #connect(SocketAddress)
 679      * @since 1.4
 680      */
 681     public SocketAddress getRemoteSocketAddress() {
 682         if (!isConnected())
 683             return null;
 684         return new InetSocketAddress(getInetAddress(), getPort());
 685     }
 686 
 687     /**
 688      * Returns the address of the endpoint this socket is bound to.
 689      *
 690      * @return a {@code SocketAddress} representing the local endpoint of this
 691      *         socket, or {@code null} if it is closed or not bound yet.
 692      * @see #getLocalAddress()
 693      * @see #getLocalPort()
 694      * @see #bind(SocketAddress)
 695      * @since 1.4
 696      */
<a name="45" id="anc45"></a>
 697     public SocketAddress getLocalSocketAddress() {
 698         if (isClosed())
 699             return null;
 700         if (!isBound())
 701             return null;
 702         return new InetSocketAddress(getLocalAddress(), getLocalPort());
 703     }
 704 
 705     /**
 706      * Sends a datagram packet from this socket. The
 707      * {@code DatagramPacket} includes information indicating the
 708      * data to be sent, its length, the IP address of the remote host,
 709      * and the port number on the remote host.
 710      *
 711      * &lt;p&gt;If there is a security manager, and the socket is not currently
 712      * connected to a remote address, this method first performs some
 713      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
 714      * is true, this method calls the
 715      * security manager&#39;s {@code checkMulticast} method
 716      * with {@code p.getAddress()} as its argument.
 717      * If the evaluation of that expression is false,
 718      * this method instead calls the security manager&#39;s
 719      * {@code checkConnect} method with arguments
 720      * {@code p.getAddress().getHostAddress()} and
 721      * {@code p.getPort()}. Each call to a security manager method
 722      * could result in a SecurityException if the operation is not allowed.
 723      *
 724      * @param      p   the {@code DatagramPacket} to be sent.
 725      *
<a name="46" id="anc46"></a><span class="line-modified"> 726      * @throws     IOException  if an I/O error occurs.</span>
<span class="line-modified"> 727      * @throws     SecurityException  if a security manager exists and its</span>
 728      *             {@code checkMulticast} or {@code checkConnect}
 729      *             method doesn&#39;t allow the send.
<a name="47" id="anc47"></a><span class="line-modified"> 730      * @throws     PortUnreachableException may be thrown if the socket is connected</span>
 731      *             to a currently unreachable destination. Note, there is no
 732      *             guarantee that the exception will be thrown.
<a name="48" id="anc48"></a><span class="line-modified"> 733      * @throws     java.nio.channels.IllegalBlockingModeException</span>
 734      *             if this socket has an associated channel,
 735      *             and the channel is in non-blocking mode.
<a name="49" id="anc49"></a><span class="line-modified"> 736      * @throws     IllegalArgumentException if the socket is connected,</span>
<span class="line-modified"> 737      *             and connected address and packet address differ, or</span>
<span class="line-added"> 738      *             if the socket is not connected and the packet address</span>
<span class="line-added"> 739      *             is not set or if its port is out of range.</span>
 740      *
 741      * @see        java.net.DatagramPacket
 742      * @see        SecurityManager#checkMulticast(InetAddress)
 743      * @see        SecurityManager#checkConnect
 744      * @revised 1.4
 745      * @spec JSR-51
 746      */
 747     public void send(DatagramPacket p) throws IOException  {
<a name="50" id="anc50"></a>
 748         synchronized (p) {
 749             if (isClosed())
 750                 throw new SocketException(&quot;Socket is closed&quot;);
<a name="51" id="anc51"></a><span class="line-modified"> 751             InetAddress packetAddress = p.getAddress();</span>
<span class="line-added"> 752             int packetPort = p.getPort();</span>
<span class="line-added"> 753             checkAddress (packetAddress, &quot;send&quot;);</span>
 754             if (connectState == ST_NOT_CONNECTED) {
<a name="52" id="anc52"></a><span class="line-added"> 755                 if (packetAddress == null) {</span>
<span class="line-added"> 756                     throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added"> 757                 }</span>
<span class="line-added"> 758                 if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-added"> 759                     throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
 760                 // check the address is ok with the security manager on every send.
 761                 SecurityManager security = System.getSecurityManager();
 762 
 763                 // The reason you want to synchronize on datagram packet
 764                 // is because you don&#39;t want an applet to change the address
 765                 // while you are trying to send the packet for example
 766                 // after the security check but before the send.
 767                 if (security != null) {
<a name="53" id="anc53"></a><span class="line-modified"> 768                     if (packetAddress.isMulticastAddress()) {</span>
<span class="line-modified"> 769                         security.checkMulticast(packetAddress);</span>
 770                     } else {
<a name="54" id="anc54"></a><span class="line-modified"> 771                         security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-modified"> 772                                 packetPort);</span>
 773                     }
 774                 }
 775             } else {
 776                 // we&#39;re connected
<a name="55" id="anc55"></a>
 777                 if (packetAddress == null) {
 778                     p.setAddress(connectedAddress);
 779                     p.setPort(connectedPort);
 780                 } else if ((!packetAddress.equals(connectedAddress)) ||
<a name="56" id="anc56"></a><span class="line-modified"> 781                         packetPort != connectedPort) {</span>
 782                     throw new IllegalArgumentException(&quot;connected address &quot; +
 783                                                        &quot;and packet address&quot; +
 784                                                        &quot; differ&quot;);
 785                 }
 786             }
 787             // Check whether the socket is bound
 788             if (!isBound())
 789                 bind(new InetSocketAddress(0));
 790             // call the  method to send
 791             getImpl().send(p);
 792         }
 793     }
 794 
 795     /**
 796      * Receives a datagram packet from this socket. When this method
 797      * returns, the {@code DatagramPacket}&#39;s buffer is filled with
 798      * the data received. The datagram packet also contains the sender&#39;s
 799      * IP address, and the port number on the sender&#39;s machine.
 800      * &lt;p&gt;
 801      * This method blocks until a datagram is received. The
 802      * {@code length} field of the datagram packet object contains
 803      * the length of the received message. If the message is longer than
 804      * the packet&#39;s length, the message is truncated.
 805      * &lt;p&gt;
<a name="57" id="anc57"></a><span class="line-modified"> 806      * If there is a security manager, and the socket is not currently</span>
<span class="line-modified"> 807      * connected to a remote address, a packet cannot be received if the</span>
<span class="line-modified"> 808      * security manager&#39;s {@code checkAccept} method does not allow it.</span>
<span class="line-added"> 809      * Datagrams that are not permitted by the security manager are silently</span>
<span class="line-added"> 810      * discarded.</span>
 811      *
 812      * @param      p   the {@code DatagramPacket} into which to place
 813      *                 the incoming data.
<a name="58" id="anc58"></a><span class="line-modified"> 814      * @throws     IOException  if an I/O error occurs.</span>
<span class="line-modified"> 815      * @throws     SocketTimeoutException  if setSoTimeout was previously called</span>
 816      *                 and the timeout has expired.
<a name="59" id="anc59"></a><span class="line-modified"> 817      * @throws     PortUnreachableException may be thrown if the socket is connected</span>
 818      *             to a currently unreachable destination. Note, there is no guarantee that the
 819      *             exception will be thrown.
<a name="60" id="anc60"></a><span class="line-modified"> 820      * @throws     java.nio.channels.IllegalBlockingModeException</span>
 821      *             if this socket has an associated channel,
 822      *             and the channel is in non-blocking mode.
 823      * @see        java.net.DatagramPacket
 824      * @see        java.net.DatagramSocket
 825      * @revised 1.4
 826      * @spec JSR-51
 827      */
 828     public synchronized void receive(DatagramPacket p) throws IOException {
 829         synchronized (p) {
 830             if (!isBound())
 831                 bind(new InetSocketAddress(0));
 832             if (connectState == ST_NOT_CONNECTED) {
 833                 // check the address is ok with the security manager before every recv.
 834                 SecurityManager security = System.getSecurityManager();
 835                 if (security != null) {
 836                     while(true) {
 837                         String peekAd = null;
 838                         int peekPort = 0;
 839                         // peek at the packet to see who it is from.
 840                         if (!oldImpl) {
 841                             // We can use the new peekData() API
 842                             DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
 843                             peekPort = getImpl().peekData(peekPacket);
 844                             peekAd = peekPacket.getAddress().getHostAddress();
 845                         } else {
 846                             InetAddress adr = new InetAddress();
 847                             peekPort = getImpl().peek(adr);
 848                             peekAd = adr.getHostAddress();
 849                         }
 850                         try {
 851                             security.checkAccept(peekAd, peekPort);
 852                             // security check succeeded - so now break
 853                             // and recv the packet.
 854                             break;
 855                         } catch (SecurityException se) {
 856                             // Throw away the offending packet by consuming
 857                             // it in a tmp buffer.
 858                             DatagramPacket tmp = new DatagramPacket(new byte[1], 1);
 859                             getImpl().receive(tmp);
 860 
 861                             // silently discard the offending packet
 862                             // and continue: unknown/malicious
 863                             // entities on nets should not make
 864                             // runtime throw security exception and
 865                             // disrupt the applet by sending random
 866                             // datagram packets.
 867                             continue;
 868                         }
 869                     } // end of while
 870                 }
 871             }
 872             DatagramPacket tmp = null;
 873             if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {
 874                 // We have to do the filtering the old fashioned way since
 875                 // the native impl doesn&#39;t support connect or the connect
 876                 // via the impl failed, or .. &quot;explicitFilter&quot; may be set when
 877                 // a socket is connected via the impl, for a period of time
 878                 // when packets from other sources might be queued on socket.
 879                 boolean stop = false;
 880                 while (!stop) {
 881                     InetAddress peekAddress = null;
 882                     int peekPort = -1;
 883                     // peek at the packet to see who it is from.
 884                     if (!oldImpl) {
 885                         // We can use the new peekData() API
 886                         DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
 887                         peekPort = getImpl().peekData(peekPacket);
 888                         peekAddress = peekPacket.getAddress();
 889                     } else {
 890                         // this api only works for IPv4
 891                         peekAddress = new InetAddress();
 892                         peekPort = getImpl().peek(peekAddress);
 893                     }
 894                     if ((!connectedAddress.equals(peekAddress)) ||
 895                         (connectedPort != peekPort)) {
 896                         // throw the packet away and silently continue
 897                         tmp = new DatagramPacket(
 898                                                 new byte[1024], 1024);
 899                         getImpl().receive(tmp);
 900                         if (explicitFilter) {
 901                             if (checkFiltering(tmp)) {
 902                                 stop = true;
 903                             }
 904                         }
 905                     } else {
 906                         stop = true;
 907                     }
 908                 }
 909             }
 910             // If the security check succeeds, or the datagram is
 911             // connected then receive the packet
 912             getImpl().receive(p);
 913             if (explicitFilter &amp;&amp; tmp == null) {
 914                 // packet was not filtered, account for it here
 915                 checkFiltering(p);
 916             }
 917         }
 918     }
 919 
 920     private boolean checkFiltering(DatagramPacket p) throws SocketException {
 921         bytesLeftToFilter -= p.getLength();
 922         if (bytesLeftToFilter &lt;= 0 || getImpl().dataAvailable() &lt;= 0) {
 923             explicitFilter = false;
 924             return true;
 925         }
 926         return false;
 927     }
 928 
 929     /**
 930      * Gets the local address to which the socket is bound.
 931      *
 932      * &lt;p&gt;If there is a security manager, its
 933      * {@code checkConnect} method is first called
 934      * with the host address and {@code -1}
 935      * as its arguments to see if the operation is allowed.
 936      *
 937      * @see SecurityManager#checkConnect
 938      * @return  the local address to which the socket is bound,
 939      *          {@code null} if the socket is closed, or
 940      *          an {@code InetAddress} representing
 941      *          {@link InetAddress#isAnyLocalAddress wildcard}
 942      *          address if either the socket is not bound, or
 943      *          the security manager {@code checkConnect}
 944      *          method does not allow the operation
 945      * @since   1.1
 946      */
 947     public InetAddress getLocalAddress() {
 948         if (isClosed())
 949             return null;
<a name="61" id="anc61"></a><span class="line-modified"> 950         InetAddress in;</span>
 951         try {
 952             in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
 953             if (in.isAnyLocalAddress()) {
 954                 in = InetAddress.anyLocalAddress();
 955             }
 956             SecurityManager s = System.getSecurityManager();
 957             if (s != null) {
 958                 s.checkConnect(in.getHostAddress(), -1);
 959             }
 960         } catch (Exception e) {
 961             in = InetAddress.anyLocalAddress(); // &quot;0.0.0.0&quot;
 962         }
 963         return in;
 964     }
 965 
 966     /**
 967      * Returns the port number on the local host to which this socket
 968      * is bound.
 969      *
 970      * @return  the port number on the local host to which this socket is bound,
<a name="62" id="anc62"></a><span class="line-modified"> 971      *          {@code -1} if the socket is closed, or</span>
<span class="line-modified"> 972      *          {@code 0} if it is not bound yet.</span>
 973      */
 974     public int getLocalPort() {
 975         if (isClosed())
 976             return -1;
 977         try {
 978             return getImpl().getLocalPort();
 979         } catch (Exception e) {
 980             return 0;
 981         }
 982     }
 983 
<a name="63" id="anc63"></a><span class="line-modified"> 984     /**</span>
<span class="line-modified"> 985      * Enable/disable SO_TIMEOUT with the specified timeout, in</span>
<span class="line-modified"> 986      * milliseconds. With this option set to a positive timeout value,</span>
<span class="line-modified"> 987      * a call to receive() for this DatagramSocket</span>
<span class="line-modified"> 988      * will block for only this amount of time.  If the timeout expires,</span>
<span class="line-modified"> 989      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the</span>
<span class="line-modified"> 990      * DatagramSocket is still valid. A timeout of zero is interpreted</span>
<span class="line-modified"> 991      * as an infinite timeout.</span>
<span class="line-modified"> 992      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking</span>
<span class="line-added"> 993      * operation to have effect.</span>
 994      *
 995      * @param timeout the specified timeout in milliseconds.
 996      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
<a name="64" id="anc64"></a><span class="line-added"> 997      * @throws IllegalArgumentException if {@code timeout} is negative</span>
 998      * @since   1.1
 999      * @see #getSoTimeout()
1000      */
1001     public synchronized void setSoTimeout(int timeout) throws SocketException {
1002         if (isClosed())
1003             throw new SocketException(&quot;Socket is closed&quot;);
<a name="65" id="anc65"></a><span class="line-added">1004         if (timeout &lt; 0)</span>
<span class="line-added">1005             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
1006         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
1007     }
1008 
1009     /**
1010      * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
1011      * option is disabled (i.e., timeout of infinity).
1012      *
1013      * @return the setting for SO_TIMEOUT
1014      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
1015      * @since   1.1
1016      * @see #setSoTimeout(int)
1017      */
1018     public synchronized int getSoTimeout() throws SocketException {
1019         if (isClosed())
1020             throw new SocketException(&quot;Socket is closed&quot;);
1021         if (getImpl() == null)
1022             return 0;
1023         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
1024         /* extra type safety */
1025         if (o instanceof Integer) {
1026             return ((Integer) o).intValue();
1027         } else {
1028             return 0;
1029         }
1030     }
1031 
1032     /**
1033      * Sets the SO_SNDBUF option to the specified value for this
1034      * {@code DatagramSocket}. The SO_SNDBUF option is used by the
1035      * network implementation as a hint to size the underlying
1036      * network I/O buffers. The SO_SNDBUF setting may also be used
1037      * by the network implementation to determine the maximum size
1038      * of the packet that can be sent on this socket.
1039      * &lt;p&gt;
1040      * As SO_SNDBUF is a hint, applications that want to verify
1041      * what size the buffer is should call {@link #getSendBufferSize()}.
1042      * &lt;p&gt;
1043      * Increasing the buffer size may allow multiple outgoing packets
1044      * to be queued by the network implementation when the send rate
1045      * is high.
1046      * &lt;p&gt;
1047      * Note: If {@link #send(DatagramPacket)} is used to send a
1048      * {@code DatagramPacket} that is larger than the setting
1049      * of SO_SNDBUF then it is implementation specific if the
1050      * packet is sent or discarded.
1051      *
1052      * @param size the size to which to set the send buffer
1053      * size. This value must be greater than 0.
1054      *
<a name="66" id="anc66"></a><span class="line-modified">1055      * @throws    SocketException if there is an error</span>
1056      * in the underlying protocol, such as an UDP error.
<a name="67" id="anc67"></a><span class="line-modified">1057      * @throws    IllegalArgumentException if the value is 0 or is</span>
1058      * negative.
1059      * @see #getSendBufferSize()
<a name="68" id="anc68"></a><span class="line-added">1060      * @since 1.2</span>
1061      */
<a name="69" id="anc69"></a><span class="line-modified">1062     public synchronized void setSendBufferSize(int size) throws SocketException {</span>

1063         if (!(size &gt; 0)) {
1064             throw new IllegalArgumentException(&quot;negative send size&quot;);
1065         }
1066         if (isClosed())
1067             throw new SocketException(&quot;Socket is closed&quot;);
1068         getImpl().setOption(SocketOptions.SO_SNDBUF, size);
1069     }
1070 
1071     /**
1072      * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
1073      * buffer size used by the platform for output on this {@code DatagramSocket}.
1074      *
1075      * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
<a name="70" id="anc70"></a><span class="line-modified">1076      * @throws    SocketException if there is an error in</span>
1077      * the underlying protocol, such as an UDP error.
1078      * @see #setSendBufferSize
<a name="71" id="anc71"></a><span class="line-added">1079      * @since 1.2</span>
1080      */
1081     public synchronized int getSendBufferSize() throws SocketException {
1082         if (isClosed())
1083             throw new SocketException(&quot;Socket is closed&quot;);
1084         int result = 0;
1085         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
1086         if (o instanceof Integer) {
1087             result = ((Integer)o).intValue();
1088         }
1089         return result;
1090     }
1091 
1092     /**
1093      * Sets the SO_RCVBUF option to the specified value for this
1094      * {@code DatagramSocket}. The SO_RCVBUF option is used by
1095      * the network implementation as a hint to size the underlying
1096      * network I/O buffers. The SO_RCVBUF setting may also be used
1097      * by the network implementation to determine the maximum size
1098      * of the packet that can be received on this socket.
1099      * &lt;p&gt;
1100      * Because SO_RCVBUF is a hint, applications that want to
1101      * verify what size the buffers were set to should call
1102      * {@link #getReceiveBufferSize()}.
1103      * &lt;p&gt;
1104      * Increasing SO_RCVBUF may allow the network implementation
1105      * to buffer multiple packets when packets arrive faster than
1106      * are being received using {@link #receive(DatagramPacket)}.
1107      * &lt;p&gt;
1108      * Note: It is implementation specific if a packet larger
1109      * than SO_RCVBUF can be received.
1110      *
1111      * @param size the size to which to set the receive buffer
1112      * size. This value must be greater than 0.
1113      *
<a name="72" id="anc72"></a><span class="line-modified">1114      * @throws    SocketException if there is an error in</span>
1115      * the underlying protocol, such as an UDP error.
<a name="73" id="anc73"></a><span class="line-modified">1116      * @throws    IllegalArgumentException if the value is 0 or is</span>
1117      * negative.
1118      * @see #getReceiveBufferSize()
<a name="74" id="anc74"></a><span class="line-added">1119      * @since 1.2</span>
1120      */
<a name="75" id="anc75"></a><span class="line-modified">1121     public synchronized void setReceiveBufferSize(int size) throws SocketException {</span>

1122         if (size &lt;= 0) {
1123             throw new IllegalArgumentException(&quot;invalid receive size&quot;);
1124         }
1125         if (isClosed())
1126             throw new SocketException(&quot;Socket is closed&quot;);
1127         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
1128     }
1129 
1130     /**
1131      * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
1132      * buffer size used by the platform for input on this {@code DatagramSocket}.
1133      *
1134      * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
<a name="76" id="anc76"></a><span class="line-modified">1135      * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.</span>
1136      * @see #setReceiveBufferSize(int)
<a name="77" id="anc77"></a><span class="line-added">1137      * @since 1.2</span>
1138      */
<a name="78" id="anc78"></a><span class="line-modified">1139     public synchronized int getReceiveBufferSize() throws SocketException {</span>

1140         if (isClosed())
1141             throw new SocketException(&quot;Socket is closed&quot;);
1142         int result = 0;
1143         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
1144         if (o instanceof Integer) {
1145             result = ((Integer)o).intValue();
1146         }
1147         return result;
1148     }
1149 
1150     /**
1151      * Enable/disable the SO_REUSEADDR socket option.
1152      * &lt;p&gt;
1153      * For UDP sockets it may be necessary to bind more than one
1154      * socket to the same socket address. This is typically for the
1155      * purpose of receiving multicast packets
1156      * (See {@link java.net.MulticastSocket}). The
1157      * {@code SO_REUSEADDR} socket option allows multiple
1158      * sockets to be bound to the same socket address if the
1159      * {@code SO_REUSEADDR} socket option is enabled prior
1160      * to binding the socket using {@link #bind(SocketAddress)}.
1161      * &lt;p&gt;
1162      * Note: This functionality is not supported by all existing platforms,
1163      * so it is implementation specific whether this option will be ignored
1164      * or not. However, if it is not supported then
1165      * {@link #getReuseAddress()} will always return {@code false}.
1166      * &lt;p&gt;
1167      * When a {@code DatagramSocket} is created the initial setting
1168      * of {@code SO_REUSEADDR} is disabled.
1169      * &lt;p&gt;
1170      * The behaviour when {@code SO_REUSEADDR} is enabled or
1171      * disabled after a socket is bound (See {@link #isBound()})
1172      * is not defined.
1173      *
1174      * @param on  whether to enable or disable the
<a name="79" id="anc79"></a><span class="line-modified">1175      * @throws    SocketException if an error occurs enabling or</span>
1176      *            disabling the {@code SO_REUSEADDR} socket option,
1177      *            or the socket is closed.
1178      * @since 1.4
1179      * @see #getReuseAddress()
1180      * @see #bind(SocketAddress)
1181      * @see #isBound()
1182      * @see #isClosed()
1183      */
1184     public synchronized void setReuseAddress(boolean on) throws SocketException {
1185         if (isClosed())
1186             throw new SocketException(&quot;Socket is closed&quot;);
1187         // Integer instead of Boolean for compatibility with older DatagramSocketImpl
1188         if (oldImpl)
1189             getImpl().setOption(SocketOptions.SO_REUSEADDR, on?-1:0);
1190         else
1191             getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
1192     }
1193 
1194     /**
1195      * Tests if SO_REUSEADDR is enabled.
1196      *
1197      * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
<a name="80" id="anc80"></a><span class="line-modified">1198      * @throws    SocketException if there is an error</span>
1199      * in the underlying protocol, such as an UDP error.
1200      * @since   1.4
1201      * @see #setReuseAddress(boolean)
1202      */
1203     public synchronized boolean getReuseAddress() throws SocketException {
1204         if (isClosed())
1205             throw new SocketException(&quot;Socket is closed&quot;);
1206         Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);
1207         return ((Boolean)o).booleanValue();
1208     }
1209 
1210     /**
1211      * Enable/disable SO_BROADCAST.
1212      *
1213      * &lt;p&gt; Some operating systems may require that the Java virtual machine be
1214      * started with implementation specific privileges to enable this option or
1215      * send broadcast datagrams.
1216      *
1217      * @param  on
1218      *         whether or not to have broadcast turned on.
1219      *
1220      * @throws  SocketException
1221      *          if there is an error in the underlying protocol, such as an UDP
1222      *          error.
1223      *
1224      * @since 1.4
1225      * @see #getBroadcast()
1226      */
1227     public synchronized void setBroadcast(boolean on) throws SocketException {
1228         if (isClosed())
1229             throw new SocketException(&quot;Socket is closed&quot;);
1230         getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));
1231     }
1232 
1233     /**
1234      * Tests if SO_BROADCAST is enabled.
1235      * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
<a name="81" id="anc81"></a><span class="line-modified">1236      * @throws    SocketException if there is an error</span>
1237      * in the underlying protocol, such as an UDP error.
1238      * @since 1.4
1239      * @see #setBroadcast(boolean)
1240      */
1241     public synchronized boolean getBroadcast() throws SocketException {
1242         if (isClosed())
1243             throw new SocketException(&quot;Socket is closed&quot;);
1244         return ((Boolean)(getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();
1245     }
1246 
1247     /**
1248      * Sets traffic class or type-of-service octet in the IP
1249      * datagram header for datagrams sent from this DatagramSocket.
1250      * As the underlying network implementation may ignore this
1251      * value applications should consider it a hint.
1252      *
1253      * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
1254      * 255} or an IllegalArgumentException will be thrown.
1255      * &lt;p&gt;Notes:
1256      * &lt;p&gt;For Internet Protocol v4 the value consists of an
1257      * {@code integer}, the least significant 8 bits of which
1258      * represent the value of the TOS octet in IP packets sent by
1259      * the socket.
1260      * RFC 1349 defines the TOS values as follows:
1261      *
1262      * &lt;UL&gt;
1263      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
1264      * &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
1265      * &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
1266      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
1267      * &lt;/UL&gt;
1268      * The last low order bit is always ignored as this
1269      * corresponds to the MBZ (must be zero) bit.
1270      * &lt;p&gt;
1271      * Setting bits in the precedence field may result in a
1272      * SocketException indicating that the operation is not
1273      * permitted.
1274      * &lt;p&gt;
1275      * for Internet Protocol v6 {@code tc} is the value that
1276      * would be placed into the sin6_flowinfo field of the IP header.
1277      *
1278      * @param tc        an {@code int} value for the bitset.
1279      * @throws SocketException if there is an error setting the
1280      * traffic class or type-of-service
1281      * @since 1.4
1282      * @see #getTrafficClass
1283      */
1284     public synchronized void setTrafficClass(int tc) throws SocketException {
1285         if (tc &lt; 0 || tc &gt; 255)
1286             throw new IllegalArgumentException(&quot;tc is not in range 0 -- 255&quot;);
1287 
1288         if (isClosed())
1289             throw new SocketException(&quot;Socket is closed&quot;);
1290         try {
1291             getImpl().setOption(SocketOptions.IP_TOS, tc);
1292         } catch (SocketException se) {
1293             // not supported if socket already connected
1294             // Solaris returns error in such cases
1295             if(!isConnected())
1296                 throw se;
1297         }
1298     }
1299 
1300     /**
1301      * Gets traffic class or type-of-service in the IP datagram
1302      * header for packets sent from this DatagramSocket.
1303      * &lt;p&gt;
1304      * As the underlying network implementation may ignore the
1305      * traffic class or type-of-service set using {@link #setTrafficClass(int)}
1306      * this method may return a different value than was previously
1307      * set using the {@link #setTrafficClass(int)} method on this
1308      * DatagramSocket.
1309      *
1310      * @return the traffic class or type-of-service already set
1311      * @throws SocketException if there is an error obtaining the
1312      * traffic class or type-of-service value.
1313      * @since 1.4
1314      * @see #setTrafficClass(int)
1315      */
1316     public synchronized int getTrafficClass() throws SocketException {
1317         if (isClosed())
1318             throw new SocketException(&quot;Socket is closed&quot;);
1319         return ((Integer)(getImpl().getOption(SocketOptions.IP_TOS))).intValue();
1320     }
1321 
1322     /**
1323      * Closes this datagram socket.
1324      * &lt;p&gt;
1325      * Any thread currently blocked in {@link #receive} upon this socket
1326      * will throw a {@link SocketException}.
1327      *
1328      * &lt;p&gt; If this socket has an associated channel then the channel is closed
1329      * as well.
1330      *
1331      * @revised 1.4
1332      * @spec JSR-51
1333      */
1334     public void close() {
1335         synchronized(closeLock) {
1336             if (isClosed())
1337                 return;
1338             impl.close();
1339             closed = true;
1340         }
1341     }
1342 
1343     /**
1344      * Returns whether the socket is closed or not.
1345      *
1346      * @return true if the socket has been closed
1347      * @since 1.4
1348      */
1349     public boolean isClosed() {
1350         synchronized(closeLock) {
1351             return closed;
1352         }
1353     }
1354 
1355     /**
1356      * Returns the unique {@link java.nio.channels.DatagramChannel} object
1357      * associated with this datagram socket, if any.
1358      *
1359      * &lt;p&gt; A datagram socket will have a channel if, and only if, the channel
1360      * itself was created via the {@link java.nio.channels.DatagramChannel#open
1361      * DatagramChannel.open} method.
1362      *
1363      * @return  the datagram channel associated with this datagram socket,
1364      *          or {@code null} if this socket was not created for a channel
1365      *
1366      * @since 1.4
1367      * @spec JSR-51
1368      */
1369     public DatagramChannel getChannel() {
1370         return null;
1371     }
1372 
1373     /**
1374      * User defined factory for all datagram sockets.
1375      */
<a name="82" id="anc82"></a><span class="line-modified">1376     private static volatile DatagramSocketImplFactory factory;</span>
1377 
1378     /**
1379      * Sets the datagram socket implementation factory for the
1380      * application. The factory can be specified only once.
1381      * &lt;p&gt;
1382      * When an application creates a new datagram socket, the socket
1383      * implementation factory&#39;s {@code createDatagramSocketImpl} method is
1384      * called to create the actual datagram socket implementation.
1385      * &lt;p&gt;
1386      * Passing {@code null} to the method is a no-op unless the factory
1387      * was already set.
1388      *
1389      * &lt;p&gt;If there is a security manager, this method first calls
1390      * the security manager&#39;s {@code checkSetFactory} method
1391      * to ensure the operation is allowed.
1392      * This could result in a SecurityException.
1393      *
1394      * @param      fac   the desired factory.
<a name="83" id="anc83"></a><span class="line-modified">1395      * @throws     IOException  if an I/O error occurs when setting the</span>
1396      *              datagram socket factory.
<a name="84" id="anc84"></a><span class="line-modified">1397      * @throws     SocketException  if the factory is already defined.</span>
<span class="line-modified">1398      * @throws     SecurityException  if a security manager exists and its</span>
1399      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1400      * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
1401      * @see       SecurityManager#checkSetFactory
1402      * @since 1.3
1403      */
1404     public static synchronized void
1405     setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
1406        throws IOException
1407     {
1408         if (factory != null) {
1409             throw new SocketException(&quot;factory already defined&quot;);
1410         }
1411         SecurityManager security = System.getSecurityManager();
1412         if (security != null) {
1413             security.checkSetFactory();
1414         }
1415         factory = fac;
1416     }
1417 
1418     /**
1419      * Sets the value of a socket option.
1420      *
1421      * @param &lt;T&gt; The type of the socket option value
1422      * @param name The socket option
1423      * @param value The value of the socket option. A value of {@code null}
1424      *              may be valid for some options.
1425      *
1426      * @return this DatagramSocket
1427      *
1428      * @throws UnsupportedOperationException if the datagram socket
1429      *         does not support the option.
1430      *
1431      * @throws IllegalArgumentException if the value is not valid for
1432      *         the option.
1433      *
1434      * @throws IOException if an I/O error occurs, or if the socket is closed.
1435      *
1436      * @throws SecurityException if a security manager is set and if the socket
1437      *         option requires a security permission and if the caller does
1438      *         not have the required permission.
1439      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1440      *         do not require any security permission.
1441      *
1442      * @throws NullPointerException if name is {@code null}
1443      *
1444      * @since 9
1445      */
1446     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
1447         throws IOException
1448     {
<a name="85" id="anc85"></a><span class="line-added">1449         Objects.requireNonNull(name);</span>
<span class="line-added">1450         if (isClosed())</span>
<span class="line-added">1451             throw new SocketException(&quot;Socket is closed&quot;);</span>
1452         getImpl().setOption(name, value);
1453         return this;
1454     }
1455 
1456     /**
1457      * Returns the value of a socket option.
1458      *
1459      * @param &lt;T&gt; The type of the socket option value
1460      * @param name The socket option
1461      *
1462      * @return The value of the socket option.
1463      *
1464      * @throws UnsupportedOperationException if the datagram socket
1465      *         does not support the option.
1466      *
1467      * @throws IOException if an I/O error occurs, or if the socket is closed.
1468      *
1469      * @throws NullPointerException if name is {@code null}
1470      *
1471      * @throws SecurityException if a security manager is set and if the socket
1472      *         option requires a security permission and if the caller does
1473      *         not have the required permission.
1474      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1475      *         do not require any security permission.
1476      *
1477      * @since 9
1478      */
1479     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<a name="86" id="anc86"></a><span class="line-added">1480         Objects.requireNonNull(name);</span>
<span class="line-added">1481         if (isClosed())</span>
<span class="line-added">1482             throw new SocketException(&quot;Socket is closed&quot;);</span>
1483         return getImpl().getOption(name);
1484     }
1485 
1486     private static Set&lt;SocketOption&lt;?&gt;&gt; options;
1487     private static boolean optionsSet = false;
1488 
1489     /**
1490      * Returns a set of the socket options supported by this socket.
1491      *
1492      * This method will continue to return the set of options even after
1493      * the socket has been closed.
1494      *
1495      * @return A set of the socket options supported by this socket. This set
1496      *        may be empty if the socket&#39;s DatagramSocketImpl cannot be created.
1497      *
1498      * @since 9
1499      */
1500     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1501         synchronized(DatagramSocket.class) {
1502             if (optionsSet) {
1503                 return options;
1504             }
1505             try {
1506                 DatagramSocketImpl impl = getImpl();
1507                 options = Collections.unmodifiableSet(impl.supportedOptions());
1508             } catch (IOException e) {
1509                 options = Collections.emptySet();
1510             }
1511             optionsSet = true;
1512             return options;
1513         }
1514     }
1515 }
<a name="87" id="anc87"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="87" type="hidden" />
</body>
</html>
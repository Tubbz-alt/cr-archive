<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractQueuedLongSynchronizer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Condition.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -33,16 +33,16 @@</span>
   * http://creativecommons.org/publicdomain/zero/1.0/
   */
  
  package java.util.concurrent.locks;
  
<span class="udiff-line-removed">- import java.lang.invoke.MethodHandles;</span>
<span class="udiff-line-removed">- import java.lang.invoke.VarHandle;</span>
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.Date;
  import java.util.concurrent.TimeUnit;
<span class="udiff-line-added">+ import java.util.concurrent.ForkJoinPool;</span>
<span class="udiff-line-added">+ import jdk.internal.misc.Unsafe;</span>
  
  /**
   * Provides a framework for implementing blocking locks and related
   * synchronizers (semaphores, events, etc) that rely on
   * first-in-first-out (FIFO) wait queues.  This class is designed to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,11 +102,11 @@</span>
   * integer maintaining state, so deserialized objects have empty
   * thread queues. Typical subclasses requiring serializability will
   * define a {@code readObject} method that restores this to a known
   * initial state upon deserialization.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;Usage&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Usage&lt;/h2&gt;</span>
   *
   * &lt;p&gt;To use this class as the basis of a synchronizer, redefine the
   * following methods, as applicable, by inspecting and/or modifying
   * the synchronization state using {@link #getState}, {@link
   * #setState} and/or {@link #compareAndSetState}:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -185,11 +185,11 @@</span>
   * not suffice, you can build synchronizers from a lower level using
   * {@link java.util.concurrent.atomic atomic} classes, your own custom
   * {@link java.util.Queue} classes, and {@link LockSupport} blocking
   * support.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;Usage Examples&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Usage Examples&lt;/h2&gt;</span>
   *
   * &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses
   * the value zero to represent the unlocked state, and one to
   * represent the locked state. While a non-reentrant lock
   * does not strictly require recording of the current owner
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -310,269 +310,212 @@</span>
       * Creates a new {@code AbstractQueuedSynchronizer} instance
       * with initial synchronization state of zero.
       */
      protected AbstractQueuedSynchronizer() { }
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Wait queue node class.</span>
<span class="udiff-line-modified-added">+     /*</span>
<span class="udiff-line-modified-added">+      * Overview.</span>
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span>
<span class="udiff-line-modified-added">+      * The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span>
       * Hagersten) lock queue. CLH locks are normally used for
<span class="udiff-line-modified-removed">-      * spinlocks.  We instead use them for blocking synchronizers, but</span>
<span class="udiff-line-modified-removed">-      * use the same basic tactic of holding some of the control</span>
<span class="udiff-line-modified-removed">-      * information about a thread in the predecessor of its node.  A</span>
<span class="udiff-line-modified-removed">-      * &quot;status&quot; field in each node keeps track of whether a thread</span>
<span class="udiff-line-modified-removed">-      * should block.  A node is signalled when its predecessor</span>
<span class="udiff-line-modified-removed">-      * releases.  Each node of the queue otherwise serves as a</span>
<span class="udiff-line-modified-removed">-      * specific-notification-style monitor holding a single waiting</span>
<span class="udiff-line-modified-removed">-      * thread. The status field does NOT control whether threads are</span>
<span class="udiff-line-modified-removed">-      * granted locks etc though.  A thread may try to acquire if it is</span>
<span class="udiff-line-modified-removed">-      * first in the queue. But being first does not guarantee success;</span>
<span class="udiff-line-modified-removed">-      * it only gives the right to contend.  So the currently released</span>
<span class="udiff-line-modified-removed">-      * contender thread may need to rewait.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span>
<span class="udiff-line-modified-removed">-      * tail. To dequeue, you just set the head field.</span>
<span class="udiff-line-modified-removed">-      * &lt;pre&gt;</span>
<span class="udiff-line-modified-removed">-      *      +------+  prev +-----+       +-----+</span>
<span class="udiff-line-modified-removed">-      * head |      | &lt;---- |     | &lt;---- |     |  tail</span>
<span class="udiff-line-modified-removed">-      *      +------+       +-----+       +-----+</span>
<span class="udiff-line-modified-removed">-      * &lt;/pre&gt;</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span>
<span class="udiff-line-modified-removed">-      * operation on &quot;tail&quot;, so there is a simple atomic point of</span>
<span class="udiff-line-modified-removed">-      * demarcation from unqueued to queued. Similarly, dequeuing</span>
<span class="udiff-line-modified-removed">-      * involves only updating the &quot;head&quot;. However, it takes a bit</span>
<span class="udiff-line-modified-removed">-      * more work for nodes to determine who their successors are,</span>
<span class="udiff-line-modified-removed">-      * in part to deal with possible cancellation due to timeouts</span>
<span class="udiff-line-modified-removed">-      * and interrupts.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly</span>
<span class="udiff-line-modified-removed">-      * needed to handle cancellation. If a node is cancelled, its</span>
<span class="udiff-line-modified-removed">-      * successor is (normally) relinked to a non-cancelled</span>
<span class="udiff-line-modified-removed">-      * predecessor. For explanation of similar mechanics in the case</span>
<span class="udiff-line-modified-removed">-      * of spin locks, see the papers by Scott and Scherer at</span>
<span class="udiff-line-modified-removed">-      * http://www.cs.rochester.edu/u/scott/synchronization/</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.</span>
<span class="udiff-line-modified-removed">-      * The thread id for each node is kept in its own node, so a</span>
<span class="udiff-line-modified-removed">-      * predecessor signals the next node to wake up by traversing</span>
<span class="udiff-line-modified-removed">-      * next link to determine which thread it is.  Determination of</span>
<span class="udiff-line-modified-removed">-      * successor must avoid races with newly queued nodes to set</span>
<span class="udiff-line-modified-removed">-      * the &quot;next&quot; fields of their predecessors.  This is solved</span>
<span class="udiff-line-modified-removed">-      * when necessary by checking backwards from the atomically</span>
<span class="udiff-line-modified-removed">-      * updated &quot;tail&quot; when a node&#39;s successor appears to be null.</span>
<span class="udiff-line-modified-removed">-      * (Or, said differently, the next-links are an optimization</span>
<span class="udiff-line-modified-removed">-      * so that we don&#39;t usually need a backward scan.)</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Cancellation introduces some conservatism to the basic</span>
<span class="udiff-line-modified-removed">-      * algorithms.  Since we must poll for cancellation of other</span>
<span class="udiff-line-modified-removed">-      * nodes, we can miss noticing whether a cancelled node is</span>
<span class="udiff-line-modified-removed">-      * ahead or behind us. This is dealt with by always unparking</span>
<span class="udiff-line-modified-removed">-      * successors upon cancellation, allowing them to stabilize on</span>
<span class="udiff-line-modified-removed">-      * a new predecessor, unless we can identify an uncancelled</span>
<span class="udiff-line-modified-removed">-      * predecessor who will carry this responsibility.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;CLH queues need a dummy header node to get started. But</span>
<span class="udiff-line-modified-added">+      * spinlocks.  We instead use them for blocking synchronizers by</span>
<span class="udiff-line-modified-added">+      * including explicit (&quot;prev&quot; and &quot;next&quot;) links plus a &quot;status&quot;</span>
<span class="udiff-line-modified-added">+      * field that allow nodes to signal successors when releasing</span>
<span class="udiff-line-modified-added">+      * locks, and handle cancellation due to interrupts and timeouts.</span>
<span class="udiff-line-modified-added">+      * The status field includes bits that track whether a thread</span>
<span class="udiff-line-modified-added">+      * needs a signal (using LockSupport.unpark). Despite these</span>
<span class="udiff-line-modified-added">+      * additions, we maintain most CLH locality properties.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * To enqueue into a CLH lock, you atomically splice it in as new</span>
<span class="udiff-line-modified-added">+      * tail. To dequeue, you set the head field, so the next eligible</span>
<span class="udiff-line-modified-added">+      * waiter becomes first.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      *  +------+  prev +-------+       +------+</span>
<span class="udiff-line-modified-added">+      *  | head | &lt;---- | first | &lt;---- | tail |</span>
<span class="udiff-line-modified-added">+      *  +------+       +-------+       +------+</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * Insertion into a CLH queue requires only a single atomic</span>
<span class="udiff-line-modified-added">+      * operation on &quot;tail&quot;, so there is a simple point of demarcation</span>
<span class="udiff-line-modified-added">+      * from unqueued to queued. The &quot;next&quot; link of the predecessor is</span>
<span class="udiff-line-modified-added">+      * set by the enqueuing thread after successful CAS. Even though</span>
<span class="udiff-line-modified-added">+      * non-atomic, this suffices to ensure that any blocked thread is</span>
<span class="udiff-line-modified-added">+      * signalled by a predecessor when eligible (although in the case</span>
<span class="udiff-line-modified-added">+      * of cancellation, possibly with the assistance of a signal in</span>
<span class="udiff-line-modified-added">+      * method cleanQueue). Signalling is based in part on a</span>
<span class="udiff-line-modified-added">+      * Dekker-like scheme in which the to-be waiting thread indicates</span>
<span class="udiff-line-modified-added">+      * WAITING status, then retries acquiring, and then rechecks</span>
<span class="udiff-line-modified-added">+      * status before blocking. The signaller atomically clears WAITING</span>
<span class="udiff-line-modified-added">+      * status when unparking.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * Dequeuing on acquire involves detaching (nulling) a node&#39;s</span>
<span class="udiff-line-modified-added">+      * &quot;prev&quot; node and then updating the &quot;head&quot;. Other threads check</span>
<span class="udiff-line-modified-added">+      * if a node is or was dequeued by checking &quot;prev&quot; rather than</span>
<span class="udiff-line-modified-added">+      * head. We enforce the nulling then setting order by spin-waiting</span>
<span class="udiff-line-modified-added">+      * if necessary. Because of this, the lock algorithm is not itself</span>
<span class="udiff-line-modified-added">+      * strictly &quot;lock-free&quot; because an acquiring thread may need to</span>
<span class="udiff-line-modified-added">+      * wait for a previous acquire to make progress. When used with</span>
<span class="udiff-line-modified-added">+      * exclusive locks, such progress is required anyway. However</span>
<span class="udiff-line-modified-added">+      * Shared mode may (uncommonly) require a spin-wait before</span>
<span class="udiff-line-modified-added">+      * setting head field to ensure proper propagation. (Historical</span>
<span class="udiff-line-modified-added">+      * note: This allows some simplifications and efficiencies</span>
<span class="udiff-line-modified-added">+      * compared to previous versions of this class.)</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * A node&#39;s predecessor can change due to cancellation while it is</span>
<span class="udiff-line-modified-added">+      * waiting, until the node is first in queue, at which point it</span>
<span class="udiff-line-modified-added">+      * cannot change. The acquire methods cope with this by rechecking</span>
<span class="udiff-line-modified-added">+      * &quot;prev&quot; before waiting. The prev and next fields are modified</span>
<span class="udiff-line-modified-added">+      * only via CAS by cancelled nodes in method cleanQueue. The</span>
<span class="udiff-line-modified-added">+      * unsplice strategy is reminiscent of Michael-Scott queues in</span>
<span class="udiff-line-modified-added">+      * that after a successful CAS to prev field, other threads help</span>
<span class="udiff-line-modified-added">+      * fix next fields.  Because cancellation often occurs in bunches</span>
<span class="udiff-line-modified-added">+      * that complicate decisions about necessary signals, each call to</span>
<span class="udiff-line-modified-added">+      * cleanQueue traverses the queue until a clean sweep. Nodes that</span>
<span class="udiff-line-modified-added">+      * become relinked as first are unconditionally unparked</span>
<span class="udiff-line-modified-added">+      * (sometimes unnecessarily, but those cases are not worth</span>
<span class="udiff-line-modified-added">+      * avoiding).</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-added">+      * A thread may try to acquire if it is first (frontmost) in the</span>
<span class="udiff-line-added">+      * queue, and sometimes before.  Being first does not guarantee</span>
<span class="udiff-line-added">+      * success; it only gives the right to contend. We balance</span>
<span class="udiff-line-added">+      * throughput, overhead, and fairness by allowing incoming threads</span>
<span class="udiff-line-added">+      * to &quot;barge&quot; and acquire the synchronizer while in the process of</span>
<span class="udiff-line-added">+      * enqueuing, in which case an awakened first thread may need to</span>
<span class="udiff-line-added">+      * rewait.  To counteract possible repeated unlucky rewaits, we</span>
<span class="udiff-line-added">+      * exponentially increase retries (up to 256) to acquire each time</span>
<span class="udiff-line-added">+      * a thread is unparked. Except in this case, AQS locks do not</span>
<span class="udiff-line-added">+      * spin; they instead interleave attempts to acquire with</span>
<span class="udiff-line-added">+      * bookkeeping steps. (Users who want spinlocks can use</span>
<span class="udiff-line-added">+      * tryAcquire.)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * To improve garbage collectibility, fields of nodes not yet on</span>
<span class="udiff-line-added">+      * list are null. (It is not rare to create and then throw away a</span>
<span class="udiff-line-added">+      * node without using it.) Fields of nodes coming off the list are</span>
<span class="udiff-line-added">+      * nulled out as soon as possible. This accentuates the challenge</span>
<span class="udiff-line-added">+      * of externally determining the first waiting thread (as in</span>
<span class="udiff-line-added">+      * method getFirstQueuedThread). This sometimes requires the</span>
<span class="udiff-line-added">+      * fallback of traversing backwards from the atomically updated</span>
<span class="udiff-line-added">+      * &quot;tail&quot; when fields appear null. (This is never needed in the</span>
<span class="udiff-line-added">+      * process of signalling though.)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * CLH queues need a dummy header node to get started. But</span>
       * we don&#39;t create them on construction, because it would be wasted
       * effort if there is never contention. Instead, the node
       * is constructed and head and tail pointers are set upon first
       * contention.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span>
<span class="udiff-line-modified-removed">-      * use an additional link. Conditions only need to link nodes</span>
<span class="udiff-line-modified-removed">-      * in simple (non-concurrent) linked queues because they are</span>
<span class="udiff-line-modified-removed">-      * only accessed when exclusively held.  Upon await, a node is</span>
<span class="udiff-line-modified-removed">-      * inserted into a condition queue.  Upon signal, the node is</span>
<span class="udiff-line-modified-removed">-      * transferred to the main queue.  A special value of status</span>
<span class="udiff-line-modified-removed">-      * field is used to mark which queue a node is on.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span>
<span class="udiff-line-modified-added">+      * Shared mode operations differ from Exclusive in that an acquire</span>
<span class="udiff-line-modified-added">+      * signals the next waiter to try to acquire if it is also</span>
<span class="udiff-line-modified-added">+      * Shared. The tryAcquireShared API allows users to indicate the</span>
<span class="udiff-line-modified-added">+      * degree of propagation, but in most applications, it is more</span>
<span class="udiff-line-modified-added">+      * efficient to ignore this, allowing the successor to try</span>
<span class="udiff-line-modified-added">+      * acquiring in any case.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * Threads waiting on Conditions use nodes with an additional</span>
<span class="udiff-line-modified-added">+      * link to maintain the (FIFO) list of conditions. Conditions only</span>
<span class="udiff-line-added">+      * need to link nodes in simple (non-concurrent) linked queues</span>
<span class="udiff-line-added">+      * because they are only accessed when exclusively held.  Upon</span>
<span class="udiff-line-added">+      * await, a node is inserted into a condition queue.  Upon signal,</span>
<span class="udiff-line-added">+      * the node is enqueued on the main queue.  A special status field</span>
<span class="udiff-line-added">+      * value is used to track and atomically trigger this.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Accesses to fields head, tail, and state use full Volatile</span>
<span class="udiff-line-added">+      * mode, along with CAS. Node fields status, prev and next also do</span>
<span class="udiff-line-added">+      * so while threads may be signallable, but sometimes use weaker</span>
<span class="udiff-line-added">+      * modes otherwise. Accesses to field &quot;waiter&quot; (the thread to be</span>
<span class="udiff-line-added">+      * signalled) are always sandwiched between other atomic accesses</span>
<span class="udiff-line-added">+      * so are used in Plain mode. We use jdk.internal Unsafe versions</span>
<span class="udiff-line-added">+      * of atomic access methods rather than VarHandles to avoid</span>
<span class="udiff-line-added">+      * potential VM bootstrap issues.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Most of the above is performed by primary internal method</span>
<span class="udiff-line-added">+      * acquire, that is invoked in some way by all exported acquire</span>
<span class="udiff-line-added">+      * methods.  (It is usually easy for compilers to optimize</span>
<span class="udiff-line-added">+      * call-site specializations when heavily used.)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * There are several arbitrary decisions about when and how to</span>
<span class="udiff-line-added">+      * check interrupts in both acquire and await before and/or after</span>
<span class="udiff-line-added">+      * blocking. The decisions are less arbitrary in implementation</span>
<span class="udiff-line-added">+      * updates because some users appear to rely on original behaviors</span>
<span class="udiff-line-added">+      * in ways that are racy and so (rarely) wrong in general but hard</span>
<span class="udiff-line-added">+      * to justify changing.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span>
       * Scherer and Michael Scott, along with members of JSR-166
       * expert group, for helpful ideas, discussions, and critiques
       * on the design of this class.
       */
<span class="udiff-line-removed">-     static final class Node {</span>
<span class="udiff-line-removed">-         /** Marker to indicate a node is waiting in shared mode */</span>
<span class="udiff-line-removed">-         static final Node SHARED = new Node();</span>
<span class="udiff-line-removed">-         /** Marker to indicate a node is waiting in exclusive mode */</span>
<span class="udiff-line-removed">-         static final Node EXCLUSIVE = null;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /** waitStatus value to indicate thread has cancelled. */</span>
<span class="udiff-line-removed">-         static final int CANCELLED =  1;</span>
<span class="udiff-line-removed">-         /** waitStatus value to indicate successor&#39;s thread needs unparking. */</span>
<span class="udiff-line-removed">-         static final int SIGNAL    = -1;</span>
<span class="udiff-line-removed">-         /** waitStatus value to indicate thread is waiting on condition. */</span>
<span class="udiff-line-removed">-         static final int CONDITION = -2;</span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * waitStatus value to indicate the next acquireShared should</span>
<span class="udiff-line-removed">-          * unconditionally propagate.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         static final int PROPAGATE = -3;</span>
  
<span class="udiff-line-modified-removed">-         /**</span>
<span class="udiff-line-modified-removed">-          * Status field, taking on only the values:</span>
<span class="udiff-line-modified-removed">-          *   SIGNAL:     The successor of this node is (or will soon be)</span>
<span class="udiff-line-modified-removed">-          *               blocked (via park), so the current node must</span>
<span class="udiff-line-modified-removed">-          *               unpark its successor when it releases or</span>
<span class="udiff-line-modified-removed">-          *               cancels. To avoid races, acquire methods must</span>
<span class="udiff-line-modified-removed">-          *               first indicate they need a signal,</span>
<span class="udiff-line-modified-removed">-          *               then retry the atomic acquire, and then,</span>
<span class="udiff-line-modified-removed">-          *               on failure, block.</span>
<span class="udiff-line-modified-removed">-          *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span>
<span class="udiff-line-modified-removed">-          *               Nodes never leave this state. In particular,</span>
<span class="udiff-line-modified-removed">-          *               a thread with cancelled node never again blocks.</span>
<span class="udiff-line-modified-removed">-          *   CONDITION:  This node is currently on a condition queue.</span>
<span class="udiff-line-modified-removed">-          *               It will not be used as a sync queue node</span>
<span class="udiff-line-modified-removed">-          *               until transferred, at which time the status</span>
<span class="udiff-line-removed">-          *               will be set to 0. (Use of this value here has</span>
<span class="udiff-line-removed">-          *               nothing to do with the other uses of the</span>
<span class="udiff-line-removed">-          *               field, but simplifies mechanics.)</span>
<span class="udiff-line-removed">-          *   PROPAGATE:  A releaseShared should be propagated to other</span>
<span class="udiff-line-removed">-          *               nodes. This is set (for head node only) in</span>
<span class="udiff-line-removed">-          *               doReleaseShared to ensure propagation</span>
<span class="udiff-line-removed">-          *               continues, even if other operations have</span>
<span class="udiff-line-removed">-          *               since intervened.</span>
<span class="udiff-line-removed">-          *   0:          None of the above</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * The values are arranged numerically to simplify use.</span>
<span class="udiff-line-removed">-          * Non-negative values mean that a node doesn&#39;t need to</span>
<span class="udiff-line-removed">-          * signal. So, most code doesn&#39;t need to check for particular</span>
<span class="udiff-line-removed">-          * values, just for sign.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * The field is initialized to 0 for normal sync nodes, and</span>
<span class="udiff-line-removed">-          * CONDITION for condition nodes.  It is modified using CAS</span>
<span class="udiff-line-removed">-          * (or when possible, unconditional volatile writes).</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         volatile int waitStatus;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Link to predecessor node that current node/thread relies on</span>
<span class="udiff-line-removed">-          * for checking waitStatus. Assigned during enqueuing, and nulled</span>
<span class="udiff-line-removed">-          * out (for sake of GC) only upon dequeuing.  Also, upon</span>
<span class="udiff-line-removed">-          * cancellation of a predecessor, we short-circuit while</span>
<span class="udiff-line-removed">-          * finding a non-cancelled one, which will always exist</span>
<span class="udiff-line-removed">-          * because the head node is never cancelled: A node becomes</span>
<span class="udiff-line-removed">-          * head only as a result of successful acquire. A</span>
<span class="udiff-line-removed">-          * cancelled thread never succeeds in acquiring, and a thread only</span>
<span class="udiff-line-removed">-          * cancels itself, not any other node.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         volatile Node prev;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Link to the successor node that the current node/thread</span>
<span class="udiff-line-removed">-          * unparks upon release. Assigned during enqueuing, adjusted</span>
<span class="udiff-line-removed">-          * when bypassing cancelled predecessors, and nulled out (for</span>
<span class="udiff-line-removed">-          * sake of GC) when dequeued.  The enq operation does not</span>
<span class="udiff-line-removed">-          * assign next field of a predecessor until after attachment,</span>
<span class="udiff-line-removed">-          * so seeing a null next field does not necessarily mean that</span>
<span class="udiff-line-removed">-          * node is at end of queue. However, if a next field appears</span>
<span class="udiff-line-removed">-          * to be null, we can scan prev&#39;s from the tail to</span>
<span class="udiff-line-removed">-          * double-check.  The next field of cancelled nodes is set to</span>
<span class="udiff-line-removed">-          * point to the node itself instead of null, to make life</span>
<span class="udiff-line-removed">-          * easier for isOnSyncQueue.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         volatile Node next;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * The thread that enqueued this node.  Initialized on</span>
<span class="udiff-line-removed">-          * construction and nulled out after use.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         volatile Thread thread;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Link to next node waiting on condition, or the special</span>
<span class="udiff-line-removed">-          * value SHARED.  Because condition queues are accessed only</span>
<span class="udiff-line-removed">-          * when holding in exclusive mode, we just need a simple</span>
<span class="udiff-line-removed">-          * linked queue to hold nodes while they are waiting on</span>
<span class="udiff-line-removed">-          * conditions. They are then transferred to the queue to</span>
<span class="udiff-line-removed">-          * re-acquire. And because conditions can only be exclusive,</span>
<span class="udiff-line-removed">-          * we save a field by using special value to indicate shared</span>
<span class="udiff-line-removed">-          * mode.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         Node nextWaiter;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Returns true if node is waiting in shared mode.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         final boolean isShared() {</span>
<span class="udiff-line-removed">-             return nextWaiter == SHARED;</span>
<span class="udiff-line-modified-added">+     // Node status bits, also used as argument and return values</span>
<span class="udiff-line-modified-added">+     static final int WAITING   = 1;          // must be 1</span>
<span class="udiff-line-modified-added">+     static final int CANCELLED = 0x80000000; // must be negative</span>
<span class="udiff-line-modified-added">+     static final int COND      = 2;          // in a condition wait</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /** CLH Nodes */</span>
<span class="udiff-line-modified-added">+     abstract static class Node {</span>
<span class="udiff-line-modified-added">+         volatile Node prev;       // initially attached via casTail</span>
<span class="udiff-line-modified-added">+         volatile Node next;       // visibly nonnull when signallable</span>
<span class="udiff-line-modified-added">+         Thread waiter;            // visibly nonnull when enqueued</span>
<span class="udiff-line-modified-added">+         volatile int status;      // written by owner, atomic bit ops by others</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // methods for atomic operations</span>
<span class="udiff-line-modified-added">+         final boolean casPrev(Node c, Node v) {  // for cleanQueue</span>
<span class="udiff-line-modified-added">+             return U.weakCompareAndSetReference(this, PREV, c, v);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /**</span>
<span class="udiff-line-removed">-          * Returns previous node, or throws NullPointerException if null.</span>
<span class="udiff-line-removed">-          * Use when predecessor cannot be null.  The null check could</span>
<span class="udiff-line-removed">-          * be elided, but is present to help the VM.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * @return the predecessor of this node</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         final Node predecessor() {</span>
<span class="udiff-line-removed">-             Node p = prev;</span>
<span class="udiff-line-removed">-             if (p == null)</span>
<span class="udiff-line-removed">-                 throw new NullPointerException();</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 return p;</span>
<span class="udiff-line-modified-added">+         final boolean casNext(Node c, Node v) {  // for cleanQueue</span>
<span class="udiff-line-modified-added">+             return U.weakCompareAndSetReference(this, NEXT, c, v);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /** Establishes initial head or SHARED marker. */</span>
<span class="udiff-line-removed">-         Node() {}</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /** Constructor used by addWaiter. */</span>
<span class="udiff-line-removed">-         Node(Node nextWaiter) {</span>
<span class="udiff-line-removed">-             this.nextWaiter = nextWaiter;</span>
<span class="udiff-line-removed">-             THREAD.set(this, Thread.currentThread());</span>
<span class="udiff-line-modified-added">+         final int getAndUnsetStatus(int v) {     // for signalling</span>
<span class="udiff-line-modified-added">+             return U.getAndBitwiseAndInt(this, STATUS, ~v);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /** Constructor used by addConditionWaiter. */</span>
<span class="udiff-line-removed">-         Node(int waitStatus) {</span>
<span class="udiff-line-removed">-             WAITSTATUS.set(this, waitStatus);</span>
<span class="udiff-line-removed">-             THREAD.set(this, Thread.currentThread());</span>
<span class="udiff-line-modified-added">+         final void setPrevRelaxed(Node p) {      // for off-queue assignment</span>
<span class="udiff-line-modified-added">+             U.putReference(this, PREV, p);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /** CASes waitStatus field. */</span>
<span class="udiff-line-removed">-         final boolean compareAndSetWaitStatus(int expect, int update) {</span>
<span class="udiff-line-removed">-             return WAITSTATUS.compareAndSet(this, expect, update);</span>
<span class="udiff-line-modified-added">+         final void setStatusRelaxed(int s) {     // for off-queue assignment</span>
<span class="udiff-line-modified-added">+             U.putInt(this, STATUS, s);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /** CASes next field. */</span>
<span class="udiff-line-removed">-         final boolean compareAndSetNext(Node expect, Node update) {</span>
<span class="udiff-line-removed">-             return NEXT.compareAndSet(this, expect, update);</span>
<span class="udiff-line-modified-added">+         final void clearStatus() {               // for reducing unneeded signals</span>
<span class="udiff-line-modified-added">+             U.putIntOpaque(this, STATUS, 0);</span>
          }
  
<span class="udiff-line-modified-removed">-         final void setPrevRelaxed(Node p) {</span>
<span class="udiff-line-modified-removed">-             PREV.set(this, p);</span>
<span class="udiff-line-modified-added">+         private static final long STATUS</span>
<span class="udiff-line-modified-added">+             = U.objectFieldOffset(Node.class, &quot;status&quot;);</span>
<span class="udiff-line-added">+         private static final long NEXT</span>
<span class="udiff-line-added">+             = U.objectFieldOffset(Node.class, &quot;next&quot;);</span>
<span class="udiff-line-added">+         private static final long PREV</span>
<span class="udiff-line-added">+             = U.objectFieldOffset(Node.class, &quot;prev&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Concrete classes tagged by type</span>
<span class="udiff-line-added">+     static final class ExclusiveNode extends Node { }</span>
<span class="udiff-line-added">+     static final class SharedNode extends Node { }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static final class ConditionNode extends Node</span>
<span class="udiff-line-added">+         implements ForkJoinPool.ManagedBlocker {</span>
<span class="udiff-line-added">+         ConditionNode nextWaiter;            // link to next waiting node</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Allows Conditions to be used in ForkJoinPools without</span>
<span class="udiff-line-added">+          * risking fixed pool exhaustion. This is usable only for</span>
<span class="udiff-line-added">+          * untimed Condition waits, not timed versions.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public final boolean isReleasable() {</span>
<span class="udiff-line-added">+             return status &lt;= 1 || Thread.currentThread().isInterrupted();</span>
          }
  
<span class="udiff-line-modified-removed">-         // VarHandle mechanics</span>
<span class="udiff-line-modified-removed">-         private static final VarHandle NEXT;</span>
<span class="udiff-line-modified-removed">-         private static final VarHandle PREV;</span>
<span class="udiff-line-removed">-         private static final VarHandle THREAD;</span>
<span class="udiff-line-removed">-         private static final VarHandle WAITSTATUS;</span>
<span class="udiff-line-removed">-         static {</span>
<span class="udiff-line-removed">-             try {</span>
<span class="udiff-line-removed">-                 MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="udiff-line-removed">-                 NEXT = l.findVarHandle(Node.class, &quot;next&quot;, Node.class);</span>
<span class="udiff-line-removed">-                 PREV = l.findVarHandle(Node.class, &quot;prev&quot;, Node.class);</span>
<span class="udiff-line-removed">-                 THREAD = l.findVarHandle(Node.class, &quot;thread&quot;, Thread.class);</span>
<span class="udiff-line-removed">-                 WAITSTATUS = l.findVarHandle(Node.class, &quot;waitStatus&quot;, int.class);</span>
<span class="udiff-line-removed">-             } catch (ReflectiveOperationException e) {</span>
<span class="udiff-line-removed">-                 throw new ExceptionInInitializerError(e);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         public final boolean block() {</span>
<span class="udiff-line-modified-added">+             while (!isReleasable()) LockSupport.park();</span>
<span class="udiff-line-modified-added">+             return true;</span>
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Head of the wait queue, lazily initialized.  Except for</span>
<span class="udiff-line-removed">-      * initialization, it is modified only via method setHead.  Note:</span>
<span class="udiff-line-removed">-      * If head exists, its waitStatus is guaranteed not to be</span>
<span class="udiff-line-removed">-      * CANCELLED.</span>
<span class="udiff-line-modified-added">+      * Head of the wait queue, lazily initialized.</span>
       */
      private transient volatile Node head;
  
      /**
<span class="udiff-line-modified-removed">-      * Tail of the wait queue, lazily initialized.  Modified only via</span>
<span class="udiff-line-removed">-      * method enq to add new wait node.</span>
<span class="udiff-line-modified-added">+      * Tail of the wait queue. After initialization, modified only via casTail.</span>
       */
      private transient volatile Node tail;
  
      /**
       * The synchronization state.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -607,485 +550,239 @@</span>
       * @param update the new value
       * @return {@code true} if successful. False return indicates that the actual
       *         value was not equal to the expected value.
       */
      protected final boolean compareAndSetState(int expect, int update) {
<span class="udiff-line-modified-removed">-         return STATE.compareAndSet(this, expect, update);</span>
<span class="udiff-line-modified-added">+         return U.compareAndSetInt(this, STATE, expect, update);</span>
      }
  
      // Queuing utilities
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * The number of nanoseconds for which it is faster to spin</span>
<span class="udiff-line-removed">-      * rather than to use timed park. A rough estimate suffices</span>
<span class="udiff-line-removed">-      * to improve responsiveness with very short timeouts.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1000L;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Inserts node into queue, initializing if necessary. See picture above.</span>
<span class="udiff-line-removed">-      * @param node the node to insert</span>
<span class="udiff-line-removed">-      * @return node&#39;s predecessor</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private Node enq(Node node) {</span>
<span class="udiff-line-removed">-         for (;;) {</span>
<span class="udiff-line-removed">-             Node oldTail = tail;</span>
<span class="udiff-line-removed">-             if (oldTail != null) {</span>
<span class="udiff-line-removed">-                 node.setPrevRelaxed(oldTail);</span>
<span class="udiff-line-removed">-                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="udiff-line-removed">-                     oldTail.next = node;</span>
<span class="udiff-line-removed">-                     return oldTail;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 initializeSyncQueue();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Creates and enqueues node for current thread and given mode.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span>
<span class="udiff-line-removed">-      * @return the new node</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private Node addWaiter(Node mode) {</span>
<span class="udiff-line-removed">-         Node node = new Node(mode);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         for (;;) {</span>
<span class="udiff-line-removed">-             Node oldTail = tail;</span>
<span class="udiff-line-removed">-             if (oldTail != null) {</span>
<span class="udiff-line-removed">-                 node.setPrevRelaxed(oldTail);</span>
<span class="udiff-line-removed">-                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="udiff-line-removed">-                     oldTail.next = node;</span>
<span class="udiff-line-removed">-                     return node;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 initializeSyncQueue();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Sets head of queue to be node, thus dequeuing. Called only by</span>
<span class="udiff-line-removed">-      * acquire methods.  Also nulls out unused fields for sake of GC</span>
<span class="udiff-line-removed">-      * and to suppress unnecessary signals and traversals.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param node the node</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private void setHead(Node node) {</span>
<span class="udiff-line-removed">-         head = node;</span>
<span class="udiff-line-removed">-         node.thread = null;</span>
<span class="udiff-line-removed">-         node.prev = null;</span>
<span class="udiff-line-modified-added">+     private boolean casTail(Node c, Node v) {</span>
<span class="udiff-line-modified-added">+         return U.compareAndSetReference(this, TAIL, c, v);</span>
      }
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Wakes up node&#39;s successor, if one exists.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param node the node</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-removed">-     private void unparkSuccessor(Node node) {</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * If status is negative (i.e., possibly needing signal) try</span>
<span class="udiff-line-removed">-          * to clear in anticipation of signalling.  It is OK if this</span>
<span class="udiff-line-removed">-          * fails or if status is changed by waiting thread.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         int ws = node.waitStatus;</span>
<span class="udiff-line-removed">-         if (ws &lt; 0)</span>
<span class="udiff-line-removed">-             node.compareAndSetWaitStatus(ws, 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * Thread to unpark is held in successor, which is normally</span>
<span class="udiff-line-removed">-          * just the next node.  But if cancelled or apparently null,</span>
<span class="udiff-line-removed">-          * traverse backwards from tail to find the actual</span>
<span class="udiff-line-removed">-          * non-cancelled successor.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         Node s = node.next;</span>
<span class="udiff-line-removed">-         if (s == null || s.waitStatus &gt; 0) {</span>
<span class="udiff-line-removed">-             s = null;</span>
<span class="udiff-line-removed">-             for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span>
<span class="udiff-line-removed">-                 if (p.waitStatus &lt;= 0)</span>
<span class="udiff-line-removed">-                     s = p;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (s != null)</span>
<span class="udiff-line-removed">-             LockSupport.unpark(s.thread);</span>
<span class="udiff-line-modified-added">+     /** tries once to CAS a new dummy node for head */</span>
<span class="udiff-line-modified-added">+     private void tryInitializeHead() {</span>
<span class="udiff-line-modified-added">+         Node h = new ExclusiveNode();</span>
<span class="udiff-line-modified-added">+         if (U.compareAndSetReference(this, HEAD, null, h))</span>
<span class="udiff-line-modified-added">+             tail = h;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Release action for shared mode -- signals successor and ensures</span>
<span class="udiff-line-modified-removed">-      * propagation. (Note: For exclusive mode, release just amounts</span>
<span class="udiff-line-removed">-      * to calling unparkSuccessor of head if it needs signal.)</span>
<span class="udiff-line-modified-added">+      * Enqueues the node unless null. (Currently used only for</span>
<span class="udiff-line-modified-added">+      * ConditionNodes; other cases are interleaved with acquires.)</span>
       */
<span class="udiff-line-modified-removed">-     private void doReleaseShared() {</span>
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Ensure that a release propagates, even if there are other</span>
<span class="udiff-line-modified-removed">-          * in-progress acquires/releases.  This proceeds in the usual</span>
<span class="udiff-line-modified-removed">-          * way of trying to unparkSuccessor of head if it needs</span>
<span class="udiff-line-modified-removed">-          * signal. But if it does not, status is set to PROPAGATE to</span>
<span class="udiff-line-modified-removed">-          * ensure that upon release, propagation continues.</span>
<span class="udiff-line-modified-removed">-          * Additionally, we must loop in case a new node is added</span>
<span class="udiff-line-modified-removed">-          * while we are doing this. Also, unlike other uses of</span>
<span class="udiff-line-modified-removed">-          * unparkSuccessor, we need to know if CAS to reset status</span>
<span class="udiff-line-modified-removed">-          * fails, if so rechecking.</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-removed">-         for (;;) {</span>
<span class="udiff-line-removed">-             Node h = head;</span>
<span class="udiff-line-removed">-             if (h != null &amp;&amp; h != tail) {</span>
<span class="udiff-line-removed">-                 int ws = h.waitStatus;</span>
<span class="udiff-line-removed">-                 if (ws == Node.SIGNAL) {</span>
<span class="udiff-line-removed">-                     if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))</span>
<span class="udiff-line-removed">-                         continue;            // loop to recheck cases</span>
<span class="udiff-line-removed">-                     unparkSuccessor(h);</span>
<span class="udiff-line-modified-added">+     final void enqueue(Node node) {</span>
<span class="udiff-line-modified-added">+         if (node != null) {</span>
<span class="udiff-line-modified-added">+             for (;;) {</span>
<span class="udiff-line-modified-added">+                 Node t = tail;</span>
<span class="udiff-line-modified-added">+                 node.setPrevRelaxed(t);        // avoid unnecessary fence</span>
<span class="udiff-line-modified-added">+                 if (t == null)                 // initialize</span>
<span class="udiff-line-modified-added">+                     tryInitializeHead();</span>
<span class="udiff-line-modified-added">+                 else if (casTail(t, node)) {</span>
<span class="udiff-line-modified-added">+                     t.next = node;</span>
<span class="udiff-line-modified-added">+                     if (t.status &lt; 0)          // wake up to clean link</span>
<span class="udiff-line-modified-added">+                         LockSupport.unpark(node.waiter);</span>
<span class="udiff-line-modified-added">+                     break;</span>
                  }
<span class="udiff-line-removed">-                 else if (ws == 0 &amp;&amp;</span>
<span class="udiff-line-removed">-                          !h.compareAndSetWaitStatus(0, Node.PROPAGATE))</span>
<span class="udiff-line-removed">-                     continue;                // loop on failed CAS</span>
              }
<span class="udiff-line-removed">-             if (h == head)                   // loop if head changed</span>
<span class="udiff-line-removed">-                 break;</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Sets head of queue, and checks if successor may be waiting</span>
<span class="udiff-line-modified-removed">-      * in shared mode, if so propagating if either propagate &gt; 0 or</span>
<span class="udiff-line-modified-removed">-      * PROPAGATE status was set.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param node the node</span>
<span class="udiff-line-removed">-      * @param propagate the return value from a tryAcquireShared</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private void setHeadAndPropagate(Node node, int propagate) {</span>
<span class="udiff-line-removed">-         Node h = head; // Record old head for check below</span>
<span class="udiff-line-removed">-         setHead(node);</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * Try to signal next queued node if:</span>
<span class="udiff-line-removed">-          *   Propagation was indicated by caller,</span>
<span class="udiff-line-removed">-          *     or was recorded (as h.waitStatus either before</span>
<span class="udiff-line-removed">-          *     or after setHead) by a previous operation</span>
<span class="udiff-line-removed">-          *     (note: this uses sign-check of waitStatus because</span>
<span class="udiff-line-removed">-          *      PROPAGATE status may transition to SIGNAL.)</span>
<span class="udiff-line-removed">-          * and</span>
<span class="udiff-line-removed">-          *   The next node is waiting in shared mode,</span>
<span class="udiff-line-removed">-          *     or we don&#39;t know, because it appears null</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * The conservatism in both of these checks may cause</span>
<span class="udiff-line-removed">-          * unnecessary wake-ups, but only when there are multiple</span>
<span class="udiff-line-removed">-          * racing acquires/releases, so most need signals now or soon</span>
<span class="udiff-line-removed">-          * anyway.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span>
<span class="udiff-line-removed">-             (h = head) == null || h.waitStatus &lt; 0) {</span>
<span class="udiff-line-removed">-             Node s = node.next;</span>
<span class="udiff-line-removed">-             if (s == null || s.isShared())</span>
<span class="udiff-line-removed">-                 doReleaseShared();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     /** Returns true if node is found in traversal from tail */</span>
<span class="udiff-line-modified-added">+     final boolean isEnqueued(Node node) {</span>
<span class="udiff-line-modified-added">+         for (Node t = tail; t != null; t = t.prev)</span>
<span class="udiff-line-modified-added">+             if (t == node)</span>
<span class="udiff-line-modified-added">+                 return true;</span>
<span class="udiff-line-modified-added">+         return false;</span>
      }
  
<span class="udiff-line-removed">-     // Utilities for various versions of acquire</span>
<span class="udiff-line-removed">- </span>
      /**
<span class="udiff-line-modified-removed">-      * Cancels an ongoing attempt to acquire.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param node the node</span>
<span class="udiff-line-modified-added">+      * Wakes up the successor of given node, if one exists, and unsets its</span>
<span class="udiff-line-modified-added">+      * WAITING status to avoid park race. This may fail to wake up an</span>
<span class="udiff-line-modified-added">+      * eligible thread when one or more have been cancelled, but</span>
<span class="udiff-line-added">+      * cancelAcquire ensures liveness.</span>
       */
<span class="udiff-line-modified-removed">-     private void cancelAcquire(Node node) {</span>
<span class="udiff-line-modified-removed">-         // Ignore if node doesn&#39;t exist</span>
<span class="udiff-line-modified-removed">-         if (node == null)</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         node.thread = null;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Skip cancelled predecessors</span>
<span class="udiff-line-removed">-         Node pred = node.prev;</span>
<span class="udiff-line-removed">-         while (pred.waitStatus &gt; 0)</span>
<span class="udiff-line-removed">-             node.prev = pred = pred.prev;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // predNext is the apparent node to unsplice. CASes below will</span>
<span class="udiff-line-removed">-         // fail if not, in which case, we lost race vs another cancel</span>
<span class="udiff-line-removed">-         // or signal, so no further action is necessary, although with</span>
<span class="udiff-line-removed">-         // a possibility that a cancelled node may transiently remain</span>
<span class="udiff-line-removed">-         // reachable.</span>
<span class="udiff-line-removed">-         Node predNext = pred.next;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Can use unconditional write instead of CAS here.</span>
<span class="udiff-line-removed">-         // After this atomic step, other Nodes can skip past us.</span>
<span class="udiff-line-removed">-         // Before, we are free of interference from other threads.</span>
<span class="udiff-line-removed">-         node.waitStatus = Node.CANCELLED;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // If we are the tail, remove ourselves.</span>
<span class="udiff-line-removed">-         if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span>
<span class="udiff-line-removed">-             pred.compareAndSetNext(predNext, null);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             // If successor needs signal, try to set pred&#39;s next-link</span>
<span class="udiff-line-removed">-             // so it will get one. Otherwise wake it up to propagate.</span>
<span class="udiff-line-removed">-             int ws;</span>
<span class="udiff-line-removed">-             if (pred != head &amp;&amp;</span>
<span class="udiff-line-removed">-                 ((ws = pred.waitStatus) == Node.SIGNAL ||</span>
<span class="udiff-line-removed">-                  (ws &lt;= 0 &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span>
<span class="udiff-line-removed">-                 pred.thread != null) {</span>
<span class="udiff-line-removed">-                 Node next = node.next;</span>
<span class="udiff-line-removed">-                 if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span>
<span class="udiff-line-removed">-                     pred.compareAndSetNext(predNext, next);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 unparkSuccessor(node);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             node.next = node; // help GC</span>
<span class="udiff-line-modified-added">+     private static void signalNext(Node h) {</span>
<span class="udiff-line-modified-added">+         Node s;</span>
<span class="udiff-line-modified-added">+         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp; s.status != 0) {</span>
<span class="udiff-line-modified-added">+             s.getAndUnsetStatus(WAITING);</span>
<span class="udiff-line-modified-added">+             LockSupport.unpark(s.waiter);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Checks and updates status for a node that failed to acquire.</span>
<span class="udiff-line-modified-removed">-      * Returns true if thread should block. This is the main signal</span>
<span class="udiff-line-modified-removed">-      * control in all acquire loops.  Requires that pred == node.prev.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param pred node&#39;s predecessor holding status</span>
<span class="udiff-line-modified-removed">-      * @param node the node</span>
<span class="udiff-line-removed">-      * @return {@code true} if thread should block</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</span>
<span class="udiff-line-removed">-         int ws = pred.waitStatus;</span>
<span class="udiff-line-removed">-         if (ws == Node.SIGNAL)</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * This node has already set status asking a release</span>
<span class="udiff-line-removed">-              * to signal it, so it can safely park.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         if (ws &gt; 0) {</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Predecessor was cancelled. Skip over predecessors and</span>
<span class="udiff-line-removed">-              * indicate retry.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             do {</span>
<span class="udiff-line-removed">-                 node.prev = pred = pred.prev;</span>
<span class="udiff-line-removed">-             } while (pred.waitStatus &gt; 0);</span>
<span class="udiff-line-removed">-             pred.next = node;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * waitStatus must be 0 or PROPAGATE.  Indicate that we</span>
<span class="udiff-line-removed">-              * need a signal, but don&#39;t park yet.  Caller will need to</span>
<span class="udiff-line-removed">-              * retry to make sure it cannot acquire before parking.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span>
<span class="udiff-line-modified-added">+     /** Wakes up the given node if in shared mode */</span>
<span class="udiff-line-modified-added">+     private static void signalNextIfShared(Node h) {</span>
<span class="udiff-line-modified-added">+         Node s;</span>
<span class="udiff-line-modified-added">+         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="udiff-line-modified-added">+             (s instanceof SharedNode) &amp;&amp; s.status != 0) {</span>
<span class="udiff-line-modified-added">+             s.getAndUnsetStatus(WAITING);</span>
<span class="udiff-line-modified-added">+             LockSupport.unpark(s.waiter);</span>
          }
<span class="udiff-line-removed">-         return false;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Convenience method to interrupt current thread.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static void selfInterrupt() {</span>
<span class="udiff-line-removed">-         Thread.currentThread().interrupt();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Convenience method to park and then check if interrupted.</span>
<span class="udiff-line-modified-added">+      * Main acquire method, invoked by all exported acquire methods.</span>
       *
<span class="udiff-line-modified-removed">-      * @return {@code true} if interrupted</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private final boolean parkAndCheckInterrupt() {</span>
<span class="udiff-line-removed">-         LockSupport.park(this);</span>
<span class="udiff-line-removed">-         return Thread.interrupted();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /*</span>
<span class="udiff-line-removed">-      * Various flavors of acquire, varying in exclusive/shared and</span>
<span class="udiff-line-removed">-      * control modes.  Each is mostly the same, but annoyingly</span>
<span class="udiff-line-removed">-      * different.  Only a little bit of factoring is possible due to</span>
<span class="udiff-line-removed">-      * interactions of exception mechanics (including ensuring that we</span>
<span class="udiff-line-removed">-      * cancel if tryAcquire throws exception) and other control, at</span>
<span class="udiff-line-removed">-      * least not without hurting performance too much.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Acquires in exclusive uninterruptible mode for thread already in</span>
<span class="udiff-line-removed">-      * queue. Used by condition wait methods as well as acquire.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param node the node</span>
<span class="udiff-line-modified-added">+      * @param node null unless a reacquiring Condition</span>
       * @param arg the acquire argument
<span class="udiff-line-modified-removed">-      * @return {@code true} if interrupted while waiting</span>
<span class="udiff-line-modified-added">+      * @param shared true if shared mode else exclusive</span>
<span class="udiff-line-added">+      * @param interruptible if abort and return negative on interrupt</span>
<span class="udiff-line-added">+      * @param timed if true use timed waits</span>
<span class="udiff-line-added">+      * @param time if timed, the System.nanoTime value to timeout</span>
<span class="udiff-line-added">+      * @return positive if acquired, 0 if timed out, negative if interrupted</span>
       */
<span class="udiff-line-modified-removed">-     final boolean acquireQueued(final Node node, int arg) {</span>
<span class="udiff-line-modified-removed">-         boolean interrupted = false;</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             for (;;) {</span>
<span class="udiff-line-modified-removed">-                 final Node p = node.predecessor();</span>
<span class="udiff-line-modified-removed">-                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="udiff-line-removed">-                     setHead(node);</span>
<span class="udiff-line-removed">-                     p.next = null; // help GC</span>
<span class="udiff-line-removed">-                     return interrupted;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="udiff-line-removed">-                     interrupted |= parkAndCheckInterrupt();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-removed">-             cancelAcquire(node);</span>
<span class="udiff-line-removed">-             if (interrupted)</span>
<span class="udiff-line-removed">-                 selfInterrupt();</span>
<span class="udiff-line-removed">-             throw t;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     final int acquire(Node node, int arg, boolean shared,</span>
<span class="udiff-line-modified-added">+                       boolean interruptible, boolean timed, long time) {</span>
<span class="udiff-line-modified-added">+         Thread current = Thread.currentThread();</span>
<span class="udiff-line-modified-added">+         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="udiff-line-modified-added">+         boolean interrupted = false, first = false;</span>
<span class="udiff-line-modified-added">+         Node pred = null;                // predecessor of node when enqueued</span>
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Acquires in exclusive interruptible mode.</span>
<span class="udiff-line-modified-removed">-      * @param arg the acquire argument</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private void doAcquireInterruptibly(int arg)</span>
<span class="udiff-line-modified-removed">-         throws InterruptedException {</span>
<span class="udiff-line-modified-removed">-         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             for (;;) {</span>
<span class="udiff-line-modified-removed">-                 final Node p = node.predecessor();</span>
<span class="udiff-line-modified-removed">-                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="udiff-line-modified-removed">-                     setHead(node);</span>
<span class="udiff-line-modified-removed">-                     p.next = null; // help GC</span>
<span class="udiff-line-modified-removed">-                     return;</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Repeatedly:</span>
<span class="udiff-line-modified-added">+          *  Check if node now first</span>
<span class="udiff-line-modified-added">+          *    if so, ensure head stable, else ensure valid predecessor</span>
<span class="udiff-line-modified-added">+          *  if node is first or not yet enqueued, try acquiring</span>
<span class="udiff-line-modified-added">+          *  else if node not yet created, create it</span>
<span class="udiff-line-modified-added">+          *  else if not yet enqueued, try once to enqueue</span>
<span class="udiff-line-modified-added">+          *  else if woken from park, retry (up to postSpins times)</span>
<span class="udiff-line-modified-added">+          *  else if WAITING status not set, set and retry</span>
<span class="udiff-line-modified-added">+          *  else park and clear WAITING status, and check cancellation</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         for (;;) {</span>
<span class="udiff-line-modified-added">+             if (!first &amp;&amp; (pred = (node == null) ? null : node.prev) != null &amp;&amp;</span>
<span class="udiff-line-added">+                 !(first = (head == pred))) {</span>
<span class="udiff-line-added">+                 if (pred.status &lt; 0) {</span>
<span class="udiff-line-added">+                     cleanQueue();           // predecessor cancelled</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 } else if (pred.prev == null) {</span>
<span class="udiff-line-added">+                     Thread.onSpinWait();    // ensure serialization</span>
<span class="udiff-line-added">+                     continue;</span>
                  }
<span class="udiff-line-removed">-                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="udiff-line-removed">-                     parkAndCheckInterrupt())</span>
<span class="udiff-line-removed">-                     throw new InterruptedException();</span>
              }
<span class="udiff-line-modified-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-modified-removed">-             cancelAcquire(node);</span>
<span class="udiff-line-modified-removed">-             throw t;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Acquires in exclusive timed mode.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param arg the acquire argument</span>
<span class="udiff-line-removed">-      * @param nanosTimeout max wait time</span>
<span class="udiff-line-removed">-      * @return {@code true} if acquired</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private boolean doAcquireNanos(int arg, long nanosTimeout)</span>
<span class="udiff-line-removed">-             throws InterruptedException {</span>
<span class="udiff-line-removed">-         if (nanosTimeout &lt;= 0L)</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="udiff-line-removed">-         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="udiff-line-removed">-         try {</span>
<span class="udiff-line-removed">-             for (;;) {</span>
<span class="udiff-line-removed">-                 final Node p = node.predecessor();</span>
<span class="udiff-line-removed">-                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="udiff-line-removed">-                     setHead(node);</span>
<span class="udiff-line-removed">-                     p.next = null; // help GC</span>
<span class="udiff-line-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+             if (first || pred == null) {</span>
<span class="udiff-line-modified-added">+                 boolean acquired;</span>
<span class="udiff-line-modified-added">+                 try {</span>
<span class="udiff-line-modified-added">+                     if (shared)</span>
<span class="udiff-line-modified-added">+                         acquired = (tryAcquireShared(arg) &gt;= 0);</span>
<span class="udiff-line-modified-added">+                     else</span>
<span class="udiff-line-modified-added">+                         acquired = tryAcquire(arg);</span>
<span class="udiff-line-modified-added">+                 } catch (Throwable ex) {</span>
<span class="udiff-line-modified-added">+                     cancelAcquire(node, interrupted, false);</span>
<span class="udiff-line-modified-added">+                     throw ex;</span>
                  }
<span class="udiff-line-modified-removed">-                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="udiff-line-modified-removed">-                 if (nanosTimeout &lt;= 0L) {</span>
<span class="udiff-line-modified-removed">-                     cancelAcquire(node);</span>
<span class="udiff-line-modified-removed">-                     return false;</span>
<span class="udiff-line-modified-added">+                 if (acquired) {</span>
<span class="udiff-line-modified-added">+                     if (first) {</span>
<span class="udiff-line-modified-added">+                         node.prev = null;</span>
<span class="udiff-line-modified-added">+                         head = node;</span>
<span class="udiff-line-added">+                         pred.next = null;</span>
<span class="udiff-line-added">+                         node.waiter = null;</span>
<span class="udiff-line-added">+                         if (shared)</span>
<span class="udiff-line-added">+                             signalNextIfShared(node);</span>
<span class="udiff-line-added">+                         if (interrupted)</span>
<span class="udiff-line-added">+                             current.interrupt();</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     return 1;</span>
                  }
<span class="udiff-line-removed">-                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="udiff-line-removed">-                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="udiff-line-removed">-                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="udiff-line-removed">-                 if (Thread.interrupted())</span>
<span class="udiff-line-removed">-                     throw new InterruptedException();</span>
              }
<span class="udiff-line-modified-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-modified-removed">-             cancelAcquire(node);</span>
<span class="udiff-line-modified-removed">-             throw t;</span>
<span class="udiff-line-modified-added">+             if (node == null) {                 // allocate; retry before enqueue</span>
<span class="udiff-line-modified-added">+                 if (shared)</span>
<span class="udiff-line-modified-added">+                     node = new SharedNode();</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     node = new ExclusiveNode();</span>
<span class="udiff-line-added">+             } else if (pred == null) {          // try to enqueue</span>
<span class="udiff-line-added">+                 node.waiter = current;</span>
<span class="udiff-line-added">+                 Node t = tail;</span>
<span class="udiff-line-added">+                 node.setPrevRelaxed(t);         // avoid unnecessary fence</span>
<span class="udiff-line-added">+                 if (t == null)</span>
<span class="udiff-line-added">+                     tryInitializeHead();</span>
<span class="udiff-line-added">+                 else if (!casTail(t, node))</span>
<span class="udiff-line-added">+                     node.setPrevRelaxed(null);  // back out</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     t.next = node;</span>
<span class="udiff-line-added">+             } else if (first &amp;&amp; spins != 0) {</span>
<span class="udiff-line-added">+                 --spins;                        // reduce unfairness on rewaits</span>
<span class="udiff-line-added">+                 Thread.onSpinWait();</span>
<span class="udiff-line-added">+             } else if (node.status == 0) {</span>
<span class="udiff-line-added">+                 node.status = WAITING;          // enable signal and recheck</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 long nanos;</span>
<span class="udiff-line-added">+                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="udiff-line-added">+                 if (!timed)</span>
<span class="udiff-line-added">+                     LockSupport.park(this);</span>
<span class="udiff-line-added">+                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="udiff-line-added">+                     LockSupport.parkNanos(this, nanos);</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 node.clearStatus();</span>
<span class="udiff-line-added">+                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+             }</span>
          }
<span class="udiff-line-added">+         return cancelAcquire(node, interrupted, interruptible);</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Acquires in shared uninterruptible mode.</span>
<span class="udiff-line-modified-removed">-      * @param arg the acquire argument</span>
<span class="udiff-line-modified-added">+      * Possibly repeatedly traverses from tail, unsplicing cancelled</span>
<span class="udiff-line-modified-added">+      * nodes until none are found. Unparks nodes that may have been</span>
<span class="udiff-line-added">+      * relinked to be next eligible acquirer.</span>
       */
<span class="udiff-line-modified-removed">-     private void doAcquireShared(int arg) {</span>
<span class="udiff-line-modified-removed">-         final Node node = addWaiter(Node.SHARED);</span>
<span class="udiff-line-modified-removed">-         boolean interrupted = false;</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             for (;;) {</span>
<span class="udiff-line-modified-removed">-                 final Node p = node.predecessor();</span>
<span class="udiff-line-modified-removed">-                 if (p == head) {</span>
<span class="udiff-line-modified-removed">-                     int r = tryAcquireShared(arg);</span>
<span class="udiff-line-modified-removed">-                     if (r &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-                         setHeadAndPropagate(node, r);</span>
<span class="udiff-line-modified-removed">-                         p.next = null; // help GC</span>
<span class="udiff-line-modified-removed">-                         return;</span>
<span class="udiff-line-modified-added">+     private void cleanQueue() {</span>
<span class="udiff-line-modified-added">+         for (;;) {                               // restart point</span>
<span class="udiff-line-modified-added">+             for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples</span>
<span class="udiff-line-modified-added">+                 if (q == null || (p = q.prev) == null)</span>
<span class="udiff-line-modified-added">+                     return;                      // end of list</span>
<span class="udiff-line-modified-added">+                 if (s == null ? tail != q : (s.prev != q || s.status &lt; 0))</span>
<span class="udiff-line-modified-added">+                     break;                       // inconsistent</span>
<span class="udiff-line-modified-added">+                 if (q.status &lt; 0) {              // cancelled</span>
<span class="udiff-line-modified-added">+                     if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                         q.prev == p) {</span>
<span class="udiff-line-modified-added">+                         p.casNext(q, s);         // OK if fails</span>
<span class="udiff-line-modified-added">+                         if (p.prev == null)</span>
<span class="udiff-line-added">+                             signalNext(p);</span>
                      }
<span class="udiff-line-added">+                     break;</span>
                  }
<span class="udiff-line-modified-removed">-                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="udiff-line-modified-removed">-                     interrupted |= parkAndCheckInterrupt();</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-modified-removed">-             cancelAcquire(node);</span>
<span class="udiff-line-removed">-             throw t;</span>
<span class="udiff-line-removed">-         } finally {</span>
<span class="udiff-line-removed">-             if (interrupted)</span>
<span class="udiff-line-removed">-                 selfInterrupt();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Acquires in shared interruptible mode.</span>
<span class="udiff-line-removed">-      * @param arg the acquire argument</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private void doAcquireSharedInterruptibly(int arg)</span>
<span class="udiff-line-removed">-         throws InterruptedException {</span>
<span class="udiff-line-removed">-         final Node node = addWaiter(Node.SHARED);</span>
<span class="udiff-line-removed">-         try {</span>
<span class="udiff-line-removed">-             for (;;) {</span>
<span class="udiff-line-removed">-                 final Node p = node.predecessor();</span>
<span class="udiff-line-removed">-                 if (p == head) {</span>
<span class="udiff-line-removed">-                     int r = tryAcquireShared(arg);</span>
<span class="udiff-line-removed">-                     if (r &gt;= 0) {</span>
<span class="udiff-line-removed">-                         setHeadAndPropagate(node, r);</span>
<span class="udiff-line-removed">-                         p.next = null; // help GC</span>
<span class="udiff-line-removed">-                         return;</span>
<span class="udiff-line-modified-added">+                 if ((n = p.next) != q) {         // help finish</span>
<span class="udiff-line-modified-added">+                     if (n != null &amp;&amp; q.prev == p) {</span>
<span class="udiff-line-modified-added">+                         p.casNext(n, q);</span>
<span class="udiff-line-modified-added">+                         if (p.prev == null)</span>
<span class="udiff-line-modified-added">+                             signalNext(p);</span>
                      }
<span class="udiff-line-added">+                     break;</span>
                  }
<span class="udiff-line-modified-removed">-                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                     parkAndCheckInterrupt())</span>
<span class="udiff-line-removed">-                     throw new InterruptedException();</span>
<span class="udiff-line-modified-added">+                 s = q;</span>
<span class="udiff-line-modified-added">+                 q = q.prev;</span>
              }
<span class="udiff-line-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-removed">-             cancelAcquire(node);</span>
<span class="udiff-line-removed">-             throw t;</span>
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Acquires in shared timed mode.</span>
<span class="udiff-line-modified-added">+      * Cancels an ongoing attempt to acquire.</span>
       *
<span class="udiff-line-modified-removed">-      * @param arg the acquire argument</span>
<span class="udiff-line-modified-removed">-      * @param nanosTimeout max wait time</span>
<span class="udiff-line-modified-removed">-      * @return {@code true} if acquired</span>
<span class="udiff-line-modified-added">+      * @param node the node (may be null if cancelled before enqueuing)</span>
<span class="udiff-line-modified-added">+      * @param interrupted true if thread interrupted</span>
<span class="udiff-line-modified-added">+      * @param interruptible if should report interruption vs reset</span>
       */
<span class="udiff-line-modified-removed">-     private boolean doAcquireSharedNanos(int arg, long nanosTimeout)</span>
<span class="udiff-line-modified-removed">-             throws InterruptedException {</span>
<span class="udiff-line-modified-removed">-         if (nanosTimeout &lt;= 0L)</span>
<span class="udiff-line-modified-removed">-             return false;</span>
<span class="udiff-line-modified-removed">-         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="udiff-line-modified-removed">-         final Node node = addWaiter(Node.SHARED);</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             for (;;) {</span>
<span class="udiff-line-modified-removed">-                 final Node p = node.predecessor();</span>
<span class="udiff-line-modified-removed">-                 if (p == head) {</span>
<span class="udiff-line-modified-removed">-                     int r = tryAcquireShared(arg);</span>
<span class="udiff-line-modified-removed">-                     if (r &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-                         setHeadAndPropagate(node, r);</span>
<span class="udiff-line-removed">-                         p.next = null; // help GC</span>
<span class="udiff-line-removed">-                         return true;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="udiff-line-removed">-                 if (nanosTimeout &lt;= 0L) {</span>
<span class="udiff-line-removed">-                     cancelAcquire(node);</span>
<span class="udiff-line-removed">-                     return false;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="udiff-line-removed">-                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="udiff-line-removed">-                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="udiff-line-removed">-                 if (Thread.interrupted())</span>
<span class="udiff-line-removed">-                     throw new InterruptedException();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-removed">-             cancelAcquire(node);</span>
<span class="udiff-line-removed">-             throw t;</span>
<span class="udiff-line-modified-added">+     private int cancelAcquire(Node node, boolean interrupted,</span>
<span class="udiff-line-modified-added">+                               boolean interruptible) {</span>
<span class="udiff-line-modified-added">+         if (node != null) {</span>
<span class="udiff-line-modified-added">+             node.waiter = null;</span>
<span class="udiff-line-modified-added">+             node.status = CANCELLED;</span>
<span class="udiff-line-modified-added">+             if (node.prev != null)</span>
<span class="udiff-line-modified-added">+                 cleanQueue();</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         if (interrupted) {</span>
<span class="udiff-line-modified-added">+             if (interruptible)</span>
<span class="udiff-line-modified-added">+                 return CANCELLED;</span>
<span class="udiff-line-modified-added">+             else</span>
<span class="udiff-line-modified-added">+                 Thread.currentThread().interrupt();</span>
          }
<span class="udiff-line-added">+         return 0;</span>
      }
  
      // Main exported methods
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1234,13 +931,12 @@</span>
       * @param arg the acquire argument.  This value is conveyed to
       *        {@link #tryAcquire} but is otherwise uninterpreted and
       *        can represent anything you like.
       */
      public final void acquire(int arg) {
<span class="udiff-line-modified-removed">-         if (!tryAcquire(arg) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span>
<span class="udiff-line-removed">-             selfInterrupt();</span>
<span class="udiff-line-modified-added">+         if (!tryAcquire(arg))</span>
<span class="udiff-line-modified-added">+             acquire(null, arg, false, false, false, 0L);</span>
      }
  
      /**
       * Acquires in exclusive mode, aborting if interrupted.
       * Implemented by first checking interrupt status, then invoking
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1254,15 +950,14 @@</span>
       *        {@link #tryAcquire} but is otherwise uninterpreted and
       *        can represent anything you like.
       * @throws InterruptedException if the current thread is interrupted
       */
      public final void acquireInterruptibly(int arg)
<span class="udiff-line-modified-removed">-             throws InterruptedException {</span>
<span class="udiff-line-modified-removed">-         if (Thread.interrupted())</span>
<span class="udiff-line-modified-added">+         throws InterruptedException {</span>
<span class="udiff-line-modified-added">+         if (Thread.interrupted() ||</span>
<span class="udiff-line-added">+             (!tryAcquire(arg) &amp;&amp; acquire(null, arg, false, true, false, 0L) &lt; 0))</span>
              throw new InterruptedException();
<span class="udiff-line-removed">-         if (!tryAcquire(arg))</span>
<span class="udiff-line-removed">-             doAcquireInterruptibly(arg);</span>
      }
  
      /**
       * Attempts to acquire in exclusive mode, aborting if interrupted,
       * and failing if the given timeout elapses.  Implemented by first
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1279,15 +974,24 @@</span>
       * @param nanosTimeout the maximum number of nanoseconds to wait
       * @return {@code true} if acquired; {@code false} if timed out
       * @throws InterruptedException if the current thread is interrupted
       */
      public final boolean tryAcquireNanos(int arg, long nanosTimeout)
<span class="udiff-line-modified-removed">-             throws InterruptedException {</span>
<span class="udiff-line-modified-removed">-         if (Thread.interrupted())</span>
<span class="udiff-line-modified-removed">-             throw new InterruptedException();</span>
<span class="udiff-line-modified-removed">-         return tryAcquire(arg) ||</span>
<span class="udiff-line-modified-removed">-             doAcquireNanos(arg, nanosTimeout);</span>
<span class="udiff-line-modified-added">+         throws InterruptedException {</span>
<span class="udiff-line-modified-added">+         if (!Thread.interrupted()) {</span>
<span class="udiff-line-modified-added">+             if (tryAcquire(arg))</span>
<span class="udiff-line-modified-added">+                 return true;</span>
<span class="udiff-line-modified-added">+             if (nanosTimeout &lt;= 0L)</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             int stat = acquire(null, arg, false, true, true,</span>
<span class="udiff-line-added">+                                System.nanoTime() + nanosTimeout);</span>
<span class="udiff-line-added">+             if (stat &gt; 0)</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             if (stat == 0)</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         throw new InterruptedException();</span>
      }
  
      /**
       * Releases in exclusive mode.  Implemented by unblocking one or
       * more threads if {@link #tryRelease} returns true.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1298,13 +1002,11 @@</span>
       *        can represent anything you like.
       * @return the value returned from {@link #tryRelease}
       */
      public final boolean release(int arg) {
          if (tryRelease(arg)) {
<span class="udiff-line-modified-removed">-             Node h = head;</span>
<span class="udiff-line-removed">-             if (h != null &amp;&amp; h.waitStatus != 0)</span>
<span class="udiff-line-removed">-                 unparkSuccessor(h);</span>
<span class="udiff-line-modified-added">+             signalNext(head);</span>
              return true;
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1319,11 +1021,11 @@</span>
       *        {@link #tryAcquireShared} but is otherwise uninterpreted
       *        and can represent anything you like.
       */
      public final void acquireShared(int arg) {
          if (tryAcquireShared(arg) &lt; 0)
<span class="udiff-line-modified-removed">-             doAcquireShared(arg);</span>
<span class="udiff-line-modified-added">+             acquire(null, arg, true, false, false, 0L);</span>
      }
  
      /**
       * Acquires in shared mode, aborting if interrupted.  Implemented
       * by first checking interrupt status, then invoking at least once
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1336,15 +1038,15 @@</span>
       * otherwise uninterpreted and can represent anything
       * you like.
       * @throws InterruptedException if the current thread is interrupted
       */
      public final void acquireSharedInterruptibly(int arg)
<span class="udiff-line-modified-removed">-             throws InterruptedException {</span>
<span class="udiff-line-modified-removed">-         if (Thread.interrupted())</span>
<span class="udiff-line-modified-added">+         throws InterruptedException {</span>
<span class="udiff-line-modified-added">+         if (Thread.interrupted() ||</span>
<span class="udiff-line-added">+             (tryAcquireShared(arg) &lt; 0 &amp;&amp;</span>
<span class="udiff-line-added">+              acquire(null, arg, true, true, false, 0L) &lt; 0))</span>
              throw new InterruptedException();
<span class="udiff-line-removed">-         if (tryAcquireShared(arg) &lt; 0)</span>
<span class="udiff-line-removed">-             doAcquireSharedInterruptibly(arg);</span>
      }
  
      /**
       * Attempts to acquire in shared mode, aborting if interrupted, and
       * failing if the given timeout elapses.  Implemented by first
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1361,14 +1063,23 @@</span>
       * @return {@code true} if acquired; {@code false} if timed out
       * @throws InterruptedException if the current thread is interrupted
       */
      public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
              throws InterruptedException {
<span class="udiff-line-modified-removed">-         if (Thread.interrupted())</span>
<span class="udiff-line-modified-removed">-             throw new InterruptedException();</span>
<span class="udiff-line-modified-removed">-         return tryAcquireShared(arg) &gt;= 0 ||</span>
<span class="udiff-line-modified-removed">-             doAcquireSharedNanos(arg, nanosTimeout);</span>
<span class="udiff-line-modified-added">+         if (!Thread.interrupted()) {</span>
<span class="udiff-line-modified-added">+             if (tryAcquireShared(arg) &gt;= 0)</span>
<span class="udiff-line-modified-added">+                 return true;</span>
<span class="udiff-line-modified-added">+             if (nanosTimeout &lt;= 0L)</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             int stat = acquire(null, arg, true, true, true,</span>
<span class="udiff-line-added">+                                System.nanoTime() + nanosTimeout);</span>
<span class="udiff-line-added">+             if (stat &gt; 0)</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             if (stat == 0)</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         throw new InterruptedException();</span>
      }
  
      /**
       * Releases in shared mode.  Implemented by unblocking one or more
       * threads if {@link #tryReleaseShared} returns true.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1378,11 +1089,11 @@</span>
       *        and can represent anything you like.
       * @return the value returned from {@link #tryReleaseShared}
       */
      public final boolean releaseShared(int arg) {
          if (tryReleaseShared(arg)) {
<span class="udiff-line-modified-removed">-             doReleaseShared();</span>
<span class="udiff-line-modified-added">+             signalNext(head);</span>
              return true;
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1396,11 +1107,11 @@</span>
       *
       * @return {@code true} if there may be other threads waiting to acquire
       */
      public final boolean hasQueuedThreads() {
          for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<span class="udiff-line-modified-removed">-             if (p.waitStatus &lt;= 0)</span>
<span class="udiff-line-modified-added">+             if (p.status &gt;= 0)</span>
                  return true;
          return false;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1426,49 +1137,20 @@</span>
       *
       * @return the first (longest-waiting) thread in the queue, or
       *         {@code null} if no threads are currently queued
       */
      public final Thread getFirstQueuedThread() {
<span class="udiff-line-modified-removed">-         // handle only fast path, else relay</span>
<span class="udiff-line-modified-removed">-         return (head == tail) ? null : fullGetFirstQueuedThread();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Version of getFirstQueuedThread called when fastpath fails.</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private Thread fullGetFirstQueuedThread() {</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * The first node is normally head.next. Try to get its</span>
<span class="udiff-line-removed">-          * thread field, ensuring consistent reads: If thread</span>
<span class="udiff-line-removed">-          * field is nulled out or s.prev is no longer head, then</span>
<span class="udiff-line-removed">-          * some other thread(s) concurrently performed setHead in</span>
<span class="udiff-line-removed">-          * between some of our reads. We try this twice before</span>
<span class="udiff-line-removed">-          * resorting to traversal.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         Node h, s;</span>
<span class="udiff-line-removed">-         Thread st;</span>
<span class="udiff-line-removed">-         if (((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="udiff-line-removed">-              s.prev == head &amp;&amp; (st = s.thread) != null) ||</span>
<span class="udiff-line-removed">-             ((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="udiff-line-removed">-              s.prev == head &amp;&amp; (st = s.thread) != null))</span>
<span class="udiff-line-removed">-             return st;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * Head&#39;s next field might not have been set yet, or may have</span>
<span class="udiff-line-removed">-          * been unset after setHead. So we must check to see if tail</span>
<span class="udiff-line-removed">-          * is actually first node. If not, we continue on, safely</span>
<span class="udiff-line-removed">-          * traversing from tail back to head to find first,</span>
<span class="udiff-line-removed">-          * guaranteeing termination.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         Thread firstThread = null;</span>
<span class="udiff-line-removed">-         for (Node p = tail; p != null &amp;&amp; p != head; p = p.prev) {</span>
<span class="udiff-line-removed">-             Thread t = p.thread;</span>
<span class="udiff-line-removed">-             if (t != null)</span>
<span class="udiff-line-removed">-                 firstThread = t;</span>
<span class="udiff-line-modified-added">+         Thread first = null, w; Node h, s;</span>
<span class="udiff-line-modified-added">+         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="udiff-line-modified-added">+                                    (first = s.waiter) == null ||</span>
<span class="udiff-line-modified-added">+                                    s.prev == null)) {</span>
<span class="udiff-line-modified-added">+             // traverse from tail on stale reads</span>
<span class="udiff-line-modified-added">+             for (Node p = tail, q; p != null &amp;&amp; (q = p.prev) != null; p = q)</span>
<span class="udiff-line-modified-added">+                 if ((w = p.waiter) != null)</span>
<span class="udiff-line-modified-added">+                     first = w;</span>
          }
<span class="udiff-line-modified-removed">-         return firstThread;</span>
<span class="udiff-line-modified-added">+         return first;</span>
      }
  
      /**
       * Returns true if the given thread is currently queued.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1481,11 +1163,11 @@</span>
       */
      public final boolean isQueued(Thread thread) {
          if (thread == null)
              throw new NullPointerException();
          for (Node p = tail; p != null; p = p.prev)
<span class="udiff-line-modified-removed">-             if (p.thread == thread)</span>
<span class="udiff-line-modified-added">+             if (p.waiter == thread)</span>
                  return true;
          return false;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1497,14 +1179,12 @@</span>
       * is not the first queued thread.  Used only as a heuristic in
       * ReentrantReadWriteLock.
       */
      final boolean apparentlyFirstQueuedIsExclusive() {
          Node h, s;
<span class="udiff-line-modified-removed">-         return (h = head) != null &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             (s = h.next)  != null &amp;&amp;</span>
<span class="udiff-line-removed">-             !s.isShared()         &amp;&amp;</span>
<span class="udiff-line-removed">-             s.thread != null;</span>
<span class="udiff-line-modified-added">+         return (h = head) != null &amp;&amp; (s = h.next)  != null &amp;&amp;</span>
<span class="udiff-line-modified-added">+             !(s instanceof SharedNode) &amp;&amp; s.waiter != null;</span>
      }
  
      /**
       * Queries whether any threads have been waiting to acquire longer
       * than the current thread.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1547,23 +1227,16 @@</span>
       *         current thread, and {@code false} if the current thread
       *         is at the head of the queue or the queue is empty
       * @since 1.7
       */
      public final boolean hasQueuedPredecessors() {
<span class="udiff-line-modified-removed">-         Node h, s;</span>
<span class="udiff-line-modified-removed">-         if ((h = head) != null) {</span>
<span class="udiff-line-modified-removed">-             if ((s = h.next) == null || s.waitStatus &gt; 0) {</span>
<span class="udiff-line-modified-removed">-                 s = null; // traverse in case of concurrent cancellation</span>
<span class="udiff-line-modified-removed">-                 for (Node p = tail; p != h &amp;&amp; p != null; p = p.prev) {</span>
<span class="udiff-line-modified-removed">-                     if (p.waitStatus &lt;= 0)</span>
<span class="udiff-line-removed">-                         s = p;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (s != null &amp;&amp; s.thread != Thread.currentThread())</span>
<span class="udiff-line-removed">-                 return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-modified-added">+         Thread first = null; Node h, s;</span>
<span class="udiff-line-modified-added">+         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="udiff-line-modified-added">+                                    (first = s.waiter) == null ||</span>
<span class="udiff-line-modified-added">+                                    s.prev == null))</span>
<span class="udiff-line-modified-added">+             first = getFirstQueuedThread(); // retry via getFirstQueuedThread</span>
<span class="udiff-line-modified-added">+         return first != null &amp;&amp; first != Thread.currentThread();</span>
      }
  
      // Instrumentation and monitoring methods
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1576,11 +1249,11 @@</span>
       * @return the estimated number of threads waiting to acquire
       */
      public final int getQueueLength() {
          int n = 0;
          for (Node p = tail; p != null; p = p.prev) {
<span class="udiff-line-modified-removed">-             if (p.thread != null)</span>
<span class="udiff-line-modified-added">+             if (p.waiter != null)</span>
                  ++n;
          }
          return n;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1596,11 +1269,11 @@</span>
       * @return the collection of threads
       */
      public final Collection&lt;Thread&gt; getQueuedThreads() {
          ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
          for (Node p = tail; p != null; p = p.prev) {
<span class="udiff-line-modified-removed">-             Thread t = p.thread;</span>
<span class="udiff-line-modified-added">+             Thread t = p.waiter;</span>
              if (t != null)
                  list.add(t);
          }
          return list;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1614,12 +1287,12 @@</span>
       * @return the collection of threads
       */
      public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
          ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
          for (Node p = tail; p != null; p = p.prev) {
<span class="udiff-line-modified-removed">-             if (!p.isShared()) {</span>
<span class="udiff-line-modified-removed">-                 Thread t = p.thread;</span>
<span class="udiff-line-modified-added">+             if (!(p instanceof SharedNode)) {</span>
<span class="udiff-line-modified-added">+                 Thread t = p.waiter;</span>
                  if (t != null)
                      list.add(t);
              }
          }
          return list;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1634,12 +1307,12 @@</span>
       * @return the collection of threads
       */
      public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
          ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
          for (Node p = tail; p != null; p = p.prev) {
<span class="udiff-line-modified-removed">-             if (p.isShared()) {</span>
<span class="udiff-line-modified-removed">-                 Thread t = p.thread;</span>
<span class="udiff-line-modified-added">+             if (p instanceof SharedNode) {</span>
<span class="udiff-line-modified-added">+                 Thread t = p.waiter;</span>
                  if (t != null)
                      list.add(t);
              }
          }
          return list;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1658,121 +1331,10 @@</span>
          return super.toString()
              + &quot;[State = &quot; + getState() + &quot;, &quot;
              + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
      }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Internal support methods for Conditions</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Returns true if a node, always one that was initially placed on</span>
<span class="udiff-line-removed">-      * a condition queue, is now waiting to reacquire on sync queue.</span>
<span class="udiff-line-removed">-      * @param node the node</span>
<span class="udiff-line-removed">-      * @return true if is reacquiring</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     final boolean isOnSyncQueue(Node node) {</span>
<span class="udiff-line-removed">-         if (node.waitStatus == Node.CONDITION || node.prev == null)</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         if (node.next != null) // If has successor, it must be on queue</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * node.prev can be non-null, but not yet on queue because</span>
<span class="udiff-line-removed">-          * the CAS to place it on queue can fail. So we have to</span>
<span class="udiff-line-removed">-          * traverse from tail to make sure it actually made it.  It</span>
<span class="udiff-line-removed">-          * will always be near the tail in calls to this method, and</span>
<span class="udiff-line-removed">-          * unless the CAS failed (which is unlikely), it will be</span>
<span class="udiff-line-removed">-          * there, so we hardly ever traverse much.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         return findNodeFromTail(node);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Returns true if node is on sync queue by searching backwards from tail.</span>
<span class="udiff-line-removed">-      * Called only when needed by isOnSyncQueue.</span>
<span class="udiff-line-removed">-      * @return true if present</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private boolean findNodeFromTail(Node node) {</span>
<span class="udiff-line-removed">-         // We check for node first, since it&#39;s likely to be at or near tail.</span>
<span class="udiff-line-removed">-         // tail is known to be non-null, so we could re-order to &quot;save&quot;</span>
<span class="udiff-line-removed">-         // one null check, but we leave it this way to help the VM.</span>
<span class="udiff-line-removed">-         for (Node p = tail;;) {</span>
<span class="udiff-line-removed">-             if (p == node)</span>
<span class="udiff-line-removed">-                 return true;</span>
<span class="udiff-line-removed">-             if (p == null)</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             p = p.prev;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Transfers a node from a condition queue onto sync queue.</span>
<span class="udiff-line-removed">-      * Returns true if successful.</span>
<span class="udiff-line-removed">-      * @param node the node</span>
<span class="udiff-line-removed">-      * @return true if successfully transferred (else the node was</span>
<span class="udiff-line-removed">-      * cancelled before signal)</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     final boolean transferForSignal(Node node) {</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * If cannot change waitStatus, the node has been cancelled.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * Splice onto queue and try to set waitStatus of predecessor to</span>
<span class="udiff-line-removed">-          * indicate that thread is (probably) waiting. If cancelled or</span>
<span class="udiff-line-removed">-          * attempt to set waitStatus fails, wake up to resync (in which</span>
<span class="udiff-line-removed">-          * case the waitStatus can be transiently and harmlessly wrong).</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         Node p = enq(node);</span>
<span class="udiff-line-removed">-         int ws = p.waitStatus;</span>
<span class="udiff-line-removed">-         if (ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span>
<span class="udiff-line-removed">-             LockSupport.unpark(node.thread);</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Transfers node, if necessary, to sync queue after a cancelled wait.</span>
<span class="udiff-line-removed">-      * Returns true if thread was cancelled before being signalled.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param node the node</span>
<span class="udiff-line-removed">-      * @return true if cancelled before the node was signalled</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     final boolean transferAfterCancelledWait(Node node) {</span>
<span class="udiff-line-removed">-         if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {</span>
<span class="udiff-line-removed">-             enq(node);</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * If we lost out to a signal(), then we can&#39;t proceed</span>
<span class="udiff-line-removed">-          * until it finishes its enq().  Cancelling during an</span>
<span class="udiff-line-removed">-          * incomplete transfer is both rare and transient, so just</span>
<span class="udiff-line-removed">-          * spin.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         while (!isOnSyncQueue(node))</span>
<span class="udiff-line-removed">-             Thread.yield();</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Invokes release with current state value; returns saved state.</span>
<span class="udiff-line-removed">-      * Cancels node and throws exception on failure.</span>
<span class="udiff-line-removed">-      * @param node the condition node for this wait</span>
<span class="udiff-line-removed">-      * @return previous sync state</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     final int fullyRelease(Node node) {</span>
<span class="udiff-line-removed">-         try {</span>
<span class="udiff-line-removed">-             int savedState = getState();</span>
<span class="udiff-line-removed">-             if (release(savedState))</span>
<span class="udiff-line-removed">-                 return savedState;</span>
<span class="udiff-line-removed">-             throw new IllegalMonitorStateException();</span>
<span class="udiff-line-removed">-         } catch (Throwable t) {</span>
<span class="udiff-line-removed">-             node.waitStatus = Node.CANCELLED;</span>
<span class="udiff-line-removed">-             throw t;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      // Instrumentation methods for conditions
  
      /**
       * Queries whether the given ConditionObject
       * uses this synchronizer as its lock.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1866,139 +1428,128 @@</span>
       * so deserialized conditions have no waiters.
       */
      public class ConditionObject implements Condition, java.io.Serializable {
          private static final long serialVersionUID = 1173984872572414699L;
          /** First node of condition queue. */
<span class="udiff-line-modified-removed">-         private transient Node firstWaiter;</span>
<span class="udiff-line-modified-added">+         private transient ConditionNode firstWaiter;</span>
          /** Last node of condition queue. */
<span class="udiff-line-modified-removed">-         private transient Node lastWaiter;</span>
<span class="udiff-line-modified-added">+         private transient ConditionNode lastWaiter;</span>
  
          /**
           * Creates a new {@code ConditionObject} instance.
           */
          public ConditionObject() { }
  
<span class="udiff-line-modified-removed">-         // Internal methods</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Adds a new waiter to wait queue.</span>
<span class="udiff-line-removed">-          * @return its new wait node</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private Node addConditionWaiter() {</span>
<span class="udiff-line-removed">-             if (!isHeldExclusively())</span>
<span class="udiff-line-removed">-                 throw new IllegalMonitorStateException();</span>
<span class="udiff-line-removed">-             Node t = lastWaiter;</span>
<span class="udiff-line-removed">-             // If lastWaiter is cancelled, clean out.</span>
<span class="udiff-line-removed">-             if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span>
<span class="udiff-line-removed">-                 unlinkCancelledWaiters();</span>
<span class="udiff-line-removed">-                 t = lastWaiter;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             Node node = new Node(Node.CONDITION);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (t == null)</span>
<span class="udiff-line-removed">-                 firstWaiter = node;</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 t.nextWaiter = node;</span>
<span class="udiff-line-removed">-             lastWaiter = node;</span>
<span class="udiff-line-removed">-             return node;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         // Signalling methods</span>
  
          /**
<span class="udiff-line-modified-removed">-          * Removes and transfers nodes until hit non-cancelled one or</span>
<span class="udiff-line-removed">-          * null. Split out from signal in part to encourage compilers</span>
<span class="udiff-line-removed">-          * to inline the case of no waiters.</span>
<span class="udiff-line-removed">-          * @param first (non-null) the first node on condition queue</span>
<span class="udiff-line-modified-added">+          * Removes and transfers one or all waiters to sync queue.</span>
           */
<span class="udiff-line-modified-removed">-         private void doSignal(Node first) {</span>
<span class="udiff-line-modified-removed">-             do {</span>
<span class="udiff-line-modified-removed">-                 if ( (firstWaiter = first.nextWaiter) == null)</span>
<span class="udiff-line-modified-added">+         private void doSignal(ConditionNode first, boolean all) {</span>
<span class="udiff-line-modified-added">+             while (first != null) {</span>
<span class="udiff-line-modified-added">+                 ConditionNode next = first.nextWaiter;</span>
<span class="udiff-line-added">+                 if ((firstWaiter = next) == null)</span>
                      lastWaiter = null;
<span class="udiff-line-modified-removed">-                 first.nextWaiter = null;</span>
<span class="udiff-line-modified-removed">-             } while (!transferForSignal(first) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                      (first = firstWaiter) != null);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Removes and transfers all nodes.</span>
<span class="udiff-line-removed">-          * @param first (non-null) the first node on condition queue</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private void doSignalAll(Node first) {</span>
<span class="udiff-line-removed">-             lastWaiter = firstWaiter = null;</span>
<span class="udiff-line-removed">-             do {</span>
<span class="udiff-line-removed">-                 Node next = first.nextWaiter;</span>
<span class="udiff-line-removed">-                 first.nextWaiter = null;</span>
<span class="udiff-line-removed">-                 transferForSignal(first);</span>
<span class="udiff-line-removed">-                 first = next;</span>
<span class="udiff-line-removed">-             } while (first != null);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Unlinks cancelled waiter nodes from condition queue.</span>
<span class="udiff-line-removed">-          * Called only while holding lock. This is called when</span>
<span class="udiff-line-removed">-          * cancellation occurred during condition wait, and upon</span>
<span class="udiff-line-removed">-          * insertion of a new waiter when lastWaiter is seen to have</span>
<span class="udiff-line-removed">-          * been cancelled. This method is needed to avoid garbage</span>
<span class="udiff-line-removed">-          * retention in the absence of signals. So even though it may</span>
<span class="udiff-line-removed">-          * require a full traversal, it comes into play only when</span>
<span class="udiff-line-removed">-          * timeouts or cancellations occur in the absence of</span>
<span class="udiff-line-removed">-          * signals. It traverses all nodes rather than stopping at a</span>
<span class="udiff-line-removed">-          * particular target to unlink all pointers to garbage nodes</span>
<span class="udiff-line-removed">-          * without requiring many re-traversals during cancellation</span>
<span class="udiff-line-removed">-          * storms.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private void unlinkCancelledWaiters() {</span>
<span class="udiff-line-removed">-             Node t = firstWaiter;</span>
<span class="udiff-line-removed">-             Node trail = null;</span>
<span class="udiff-line-removed">-             while (t != null) {</span>
<span class="udiff-line-removed">-                 Node next = t.nextWaiter;</span>
<span class="udiff-line-removed">-                 if (t.waitStatus != Node.CONDITION) {</span>
<span class="udiff-line-removed">-                     t.nextWaiter = null;</span>
<span class="udiff-line-removed">-                     if (trail == null)</span>
<span class="udiff-line-removed">-                         firstWaiter = next;</span>
<span class="udiff-line-removed">-                     else</span>
<span class="udiff-line-removed">-                         trail.nextWaiter = next;</span>
<span class="udiff-line-removed">-                     if (next == null)</span>
<span class="udiff-line-removed">-                         lastWaiter = trail;</span>
<span class="udiff-line-modified-added">+                 if ((first.getAndUnsetStatus(COND) &amp; COND) != 0) {</span>
<span class="udiff-line-modified-added">+                     enqueue(first);</span>
<span class="udiff-line-modified-added">+                     if (!all)</span>
<span class="udiff-line-modified-added">+                         break;</span>
                  }
<span class="udiff-line-modified-removed">-                 else</span>
<span class="udiff-line-removed">-                     trail = t;</span>
<span class="udiff-line-removed">-                 t = next;</span>
<span class="udiff-line-modified-added">+                 first = next;</span>
              }
          }
  
<span class="udiff-line-removed">-         // public methods</span>
<span class="udiff-line-removed">- </span>
          /**
           * Moves the longest-waiting thread, if one exists, from the
           * wait queue for this condition to the wait queue for the
           * owning lock.
           *
           * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
           *         returns {@code false}
           */
          public final void signal() {
<span class="udiff-line-added">+             ConditionNode first = firstWaiter;</span>
              if (!isHeldExclusively())
                  throw new IllegalMonitorStateException();
<span class="udiff-line-removed">-             Node first = firstWaiter;</span>
              if (first != null)
<span class="udiff-line-modified-removed">-                 doSignal(first);</span>
<span class="udiff-line-modified-added">+                 doSignal(first, false);</span>
          }
  
          /**
           * Moves all threads from the wait queue for this condition to
           * the wait queue for the owning lock.
           *
           * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
           *         returns {@code false}
           */
          public final void signalAll() {
<span class="udiff-line-added">+             ConditionNode first = firstWaiter;</span>
              if (!isHeldExclusively())
                  throw new IllegalMonitorStateException();
<span class="udiff-line-removed">-             Node first = firstWaiter;</span>
              if (first != null)
<span class="udiff-line-modified-removed">-                 doSignalAll(first);</span>
<span class="udiff-line-modified-added">+                 doSignal(first, true);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Waiting methods</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Adds node to condition list and releases lock.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param node the node</span>
<span class="udiff-line-added">+          * @return savedState to reacquire after wait</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private int enableWait(ConditionNode node) {</span>
<span class="udiff-line-added">+             if (isHeldExclusively()) {</span>
<span class="udiff-line-added">+                 node.waiter = Thread.currentThread();</span>
<span class="udiff-line-added">+                 node.setStatusRelaxed(COND | WAITING);</span>
<span class="udiff-line-added">+                 ConditionNode last = lastWaiter;</span>
<span class="udiff-line-added">+                 if (last == null)</span>
<span class="udiff-line-added">+                     firstWaiter = node;</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     last.nextWaiter = node;</span>
<span class="udiff-line-added">+                 lastWaiter = node;</span>
<span class="udiff-line-added">+                 int savedState = getState();</span>
<span class="udiff-line-added">+                 if (release(savedState))</span>
<span class="udiff-line-added">+                     return savedState;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             node.status = CANCELLED; // lock not held or inconsistent</span>
<span class="udiff-line-added">+             throw new IllegalMonitorStateException();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns true if a node that was initially placed on a condition</span>
<span class="udiff-line-added">+          * queue is now ready to reacquire on sync queue.</span>
<span class="udiff-line-added">+          * @param node the node</span>
<span class="udiff-line-added">+          * @return true if is reacquiring</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private boolean canReacquire(ConditionNode node) {</span>
<span class="udiff-line-added">+             // check links, not status to avoid enqueue race</span>
<span class="udiff-line-added">+             return node != null &amp;&amp; node.prev != null &amp;&amp; isEnqueued(node);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Unlinks the given node and other non-waiting nodes from</span>
<span class="udiff-line-added">+          * condition queue unless already unlinked.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private void unlinkCancelledWaiters(ConditionNode node) {</span>
<span class="udiff-line-added">+             if (node == null || node.nextWaiter != null || node == lastWaiter) {</span>
<span class="udiff-line-added">+                 ConditionNode w = firstWaiter, trail = null;</span>
<span class="udiff-line-added">+                 while (w != null) {</span>
<span class="udiff-line-added">+                     ConditionNode next = w.nextWaiter;</span>
<span class="udiff-line-added">+                     if ((w.status &amp; COND) == 0) {</span>
<span class="udiff-line-added">+                         w.nextWaiter = null;</span>
<span class="udiff-line-added">+                         if (trail == null)</span>
<span class="udiff-line-added">+                             firstWaiter = next;</span>
<span class="udiff-line-added">+                         else</span>
<span class="udiff-line-added">+                             trail.nextWaiter = next;</span>
<span class="udiff-line-added">+                         if (next == null)</span>
<span class="udiff-line-added">+                             lastWaiter = trail;</span>
<span class="udiff-line-added">+                     } else</span>
<span class="udiff-line-added">+                         trail = w;</span>
<span class="udiff-line-added">+                     w = next;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
          }
  
          /**
           * Implements uninterruptible condition wait.
           * &lt;ol&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2009,55 +1560,31 @@</span>
           * &lt;li&gt;Reacquire by invoking specialized version of
           *     {@link #acquire} with saved state as argument.
           * &lt;/ol&gt;
           */
          public final void awaitUninterruptibly() {
<span class="udiff-line-modified-removed">-             Node node = addConditionWaiter();</span>
<span class="udiff-line-modified-removed">-             int savedState = fullyRelease(node);</span>
<span class="udiff-line-modified-added">+             ConditionNode node = new ConditionNode();</span>
<span class="udiff-line-modified-added">+             int savedState = enableWait(node);</span>
<span class="udiff-line-added">+             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
              boolean interrupted = false;
<span class="udiff-line-modified-removed">-             while (!isOnSyncQueue(node)) {</span>
<span class="udiff-line-removed">-                 LockSupport.park(this);</span>
<span class="udiff-line-modified-added">+             while (!canReacquire(node)) {</span>
                  if (Thread.interrupted())
                      interrupted = true;
<span class="udiff-line-added">+                 else if ((node.status &amp; COND) != 0) {</span>
<span class="udiff-line-added">+                     try {</span>
<span class="udiff-line-added">+                         ForkJoinPool.managedBlock(node);</span>
<span class="udiff-line-added">+                     } catch (InterruptedException ie) {</span>
<span class="udiff-line-added">+                         interrupted = true;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } else</span>
<span class="udiff-line-added">+                     Thread.onSpinWait();    // awoke while enqueuing</span>
              }
<span class="udiff-line-modified-removed">-             if (acquireQueued(node, savedState) || interrupted)</span>
<span class="udiff-line-modified-removed">-                 selfInterrupt();</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-removed">-          * For interruptible waits, we need to track whether to throw</span>
<span class="udiff-line-removed">-          * InterruptedException, if interrupted while blocked on</span>
<span class="udiff-line-removed">-          * condition, versus reinterrupt current thread, if</span>
<span class="udiff-line-removed">-          * interrupted while blocked waiting to re-acquire.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /** Mode meaning to reinterrupt on exit from wait */</span>
<span class="udiff-line-removed">-         private static final int REINTERRUPT =  1;</span>
<span class="udiff-line-removed">-         /** Mode meaning to throw InterruptedException on exit from wait */</span>
<span class="udiff-line-removed">-         private static final int THROW_IE    = -1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Checks for interrupt, returning THROW_IE if interrupted</span>
<span class="udiff-line-removed">-          * before signalled, REINTERRUPT if after signalled, or</span>
<span class="udiff-line-removed">-          * 0 if not interrupted.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private int checkInterruptWhileWaiting(Node node) {</span>
<span class="udiff-line-removed">-             return Thread.interrupted() ?</span>
<span class="udiff-line-removed">-                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span>
<span class="udiff-line-removed">-                 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Throws InterruptedException, reinterrupts current thread, or</span>
<span class="udiff-line-removed">-          * does nothing, depending on mode.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private void reportInterruptAfterWait(int interruptMode)</span>
<span class="udiff-line-removed">-             throws InterruptedException {</span>
<span class="udiff-line-removed">-             if (interruptMode == THROW_IE)</span>
<span class="udiff-line-removed">-                 throw new InterruptedException();</span>
<span class="udiff-line-removed">-             else if (interruptMode == REINTERRUPT)</span>
<span class="udiff-line-removed">-                 selfInterrupt();</span>
<span class="udiff-line-modified-added">+             LockSupport.setCurrentBlocker(null);</span>
<span class="udiff-line-modified-added">+             node.clearStatus();</span>
<span class="udiff-line-modified-added">+             acquire(node, savedState, false, false, false, 0L);</span>
<span class="udiff-line-modified-added">+             if (interrupted)</span>
<span class="udiff-line-modified-added">+                 Thread.currentThread().interrupt();</span>
          }
  
          /**
           * Implements interruptible condition wait.
           * &lt;ol&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2072,24 +1599,37 @@</span>
           * &lt;/ol&gt;
           */
          public final void await() throws InterruptedException {
              if (Thread.interrupted())
                  throw new InterruptedException();
<span class="udiff-line-modified-removed">-             Node node = addConditionWaiter();</span>
<span class="udiff-line-modified-removed">-             int savedState = fullyRelease(node);</span>
<span class="udiff-line-modified-removed">-             int interruptMode = 0;</span>
<span class="udiff-line-modified-removed">-             while (!isOnSyncQueue(node)) {</span>
<span class="udiff-line-modified-removed">-                 LockSupport.park(this);</span>
<span class="udiff-line-modified-removed">-                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-added">+             ConditionNode node = new ConditionNode();</span>
<span class="udiff-line-modified-added">+             int savedState = enableWait(node);</span>
<span class="udiff-line-modified-added">+             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
<span class="udiff-line-modified-added">+             boolean interrupted = false, cancelled = false;</span>
<span class="udiff-line-modified-added">+             while (!canReacquire(node)) {</span>
<span class="udiff-line-modified-added">+                 if (interrupted |= Thread.interrupted()) {</span>
<span class="udiff-line-modified-added">+                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="udiff-line-added">+                         break;              // else interrupted after signal</span>
<span class="udiff-line-added">+                 } else if ((node.status &amp; COND) != 0) {</span>
<span class="udiff-line-added">+                     try {</span>
<span class="udiff-line-added">+                         ForkJoinPool.managedBlock(node);</span>
<span class="udiff-line-added">+                     } catch (InterruptedException ie) {</span>
<span class="udiff-line-added">+                         interrupted = true;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } else</span>
<span class="udiff-line-added">+                     Thread.onSpinWait();    // awoke while enqueuing</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             LockSupport.setCurrentBlocker(null);</span>
<span class="udiff-line-added">+             node.clearStatus();</span>
<span class="udiff-line-added">+             acquire(node, savedState, false, false, false, 0L);</span>
<span class="udiff-line-added">+             if (interrupted) {</span>
<span class="udiff-line-added">+                 if (cancelled) {</span>
<span class="udiff-line-added">+                     unlinkCancelledWaiters(node);</span>
<span class="udiff-line-added">+                     throw new InterruptedException();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 Thread.currentThread().interrupt();</span>
              }
<span class="udiff-line-removed">-             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="udiff-line-removed">-                 interruptMode = REINTERRUPT;</span>
<span class="udiff-line-removed">-             if (node.nextWaiter != null) // clean up if cancelled</span>
<span class="udiff-line-removed">-                 unlinkCancelledWaiters();</span>
<span class="udiff-line-removed">-             if (interruptMode != 0)</span>
<span class="udiff-line-removed">-                 reportInterruptAfterWait(interruptMode);</span>
          }
  
          /**
           * Implements timed condition wait.
           * &lt;ol&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2105,36 +1645,33 @@</span>
           */
          public final long awaitNanos(long nanosTimeout)
                  throws InterruptedException {
              if (Thread.interrupted())
                  throw new InterruptedException();
<span class="udiff-line-modified-removed">-             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="udiff-line-modified-removed">-             // awaitNanos(0) as a way to &quot;yield the lock&quot;.</span>
<span class="udiff-line-modified-removed">-             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="udiff-line-modified-removed">-             long initialNanos = nanosTimeout;</span>
<span class="udiff-line-modified-removed">-             Node node = addConditionWaiter();</span>
<span class="udiff-line-modified-removed">-             int savedState = fullyRelease(node);</span>
<span class="udiff-line-modified-removed">-             int interruptMode = 0;</span>
<span class="udiff-line-modified-removed">-             while (!isOnSyncQueue(node)) {</span>
<span class="udiff-line-modified-removed">-                 if (nanosTimeout &lt;= 0L) {</span>
<span class="udiff-line-modified-removed">-                     transferAfterCancelledWait(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="udiff-line-removed">-                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="udiff-line-removed">-                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="udiff-line-modified-added">+             ConditionNode node = new ConditionNode();</span>
<span class="udiff-line-modified-added">+             int savedState = enableWait(node);</span>
<span class="udiff-line-modified-added">+             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="udiff-line-modified-added">+             long deadline = System.nanoTime() + nanos;</span>
<span class="udiff-line-modified-added">+             boolean cancelled = false, interrupted = false;</span>
<span class="udiff-line-modified-added">+             while (!canReacquire(node)) {</span>
<span class="udiff-line-modified-added">+                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="udiff-line-modified-added">+                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="udiff-line-modified-added">+                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="udiff-line-modified-added">+                         break;</span>
<span class="udiff-line-modified-added">+                 } else</span>
<span class="udiff-line-modified-added">+                     LockSupport.parkNanos(this, nanos);</span>
              }
<span class="udiff-line-modified-removed">-             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="udiff-line-modified-removed">-                 interruptMode = REINTERRUPT;</span>
<span class="udiff-line-modified-removed">-             if (node.nextWaiter != null)</span>
<span class="udiff-line-modified-removed">-                 unlinkCancelledWaiters();</span>
<span class="udiff-line-modified-removed">-             if (interruptMode != 0)</span>
<span class="udiff-line-modified-removed">-                 reportInterruptAfterWait(interruptMode);</span>
<span class="udiff-line-modified-added">+             node.clearStatus();</span>
<span class="udiff-line-modified-added">+             acquire(node, savedState, false, false, false, 0L);</span>
<span class="udiff-line-modified-added">+             if (cancelled) {</span>
<span class="udiff-line-modified-added">+                 unlinkCancelledWaiters(node);</span>
<span class="udiff-line-modified-added">+                 if (interrupted)</span>
<span class="udiff-line-modified-added">+                     throw new InterruptedException();</span>
<span class="udiff-line-added">+             } else if (interrupted)</span>
<span class="udiff-line-added">+                 Thread.currentThread().interrupt();</span>
              long remaining = deadline - System.nanoTime(); // avoid overflow
<span class="udiff-line-modified-removed">-             return (remaining &lt;= initialNanos) ? remaining : Long.MIN_VALUE;</span>
<span class="udiff-line-modified-added">+             return (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;</span>
          }
  
          /**
           * Implements absolute timed condition wait.
           * &lt;ol&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2152,30 +1689,30 @@</span>
          public final boolean awaitUntil(Date deadline)
                  throws InterruptedException {
              long abstime = deadline.getTime();
              if (Thread.interrupted())
                  throw new InterruptedException();
<span class="udiff-line-modified-removed">-             Node node = addConditionWaiter();</span>
<span class="udiff-line-modified-removed">-             int savedState = fullyRelease(node);</span>
<span class="udiff-line-modified-removed">-             boolean timedout = false;</span>
<span class="udiff-line-modified-removed">-             int interruptMode = 0;</span>
<span class="udiff-line-modified-removed">-             while (!isOnSyncQueue(node)) {</span>
<span class="udiff-line-modified-removed">-                 if (System.currentTimeMillis() &gt;= abstime) {</span>
<span class="udiff-line-modified-removed">-                     timedout = transferAfterCancelledWait(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 LockSupport.parkUntil(this, abstime);</span>
<span class="udiff-line-removed">-                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-modified-added">+             ConditionNode node = new ConditionNode();</span>
<span class="udiff-line-modified-added">+             int savedState = enableWait(node);</span>
<span class="udiff-line-modified-added">+             boolean cancelled = false, interrupted = false;</span>
<span class="udiff-line-modified-added">+             while (!canReacquire(node)) {</span>
<span class="udiff-line-modified-added">+                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="udiff-line-modified-added">+                     System.currentTimeMillis() &gt;= abstime) {</span>
<span class="udiff-line-modified-added">+                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="udiff-line-modified-added">+                         break;</span>
<span class="udiff-line-modified-added">+                 } else</span>
<span class="udiff-line-modified-added">+                     LockSupport.parkUntil(this, abstime);</span>
              }
<span class="udiff-line-modified-removed">-             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="udiff-line-modified-removed">-                 interruptMode = REINTERRUPT;</span>
<span class="udiff-line-modified-removed">-             if (node.nextWaiter != null)</span>
<span class="udiff-line-modified-removed">-                 unlinkCancelledWaiters();</span>
<span class="udiff-line-modified-removed">-             if (interruptMode != 0)</span>
<span class="udiff-line-modified-removed">-                 reportInterruptAfterWait(interruptMode);</span>
<span class="udiff-line-modified-removed">-             return !timedout;</span>
<span class="udiff-line-modified-added">+             node.clearStatus();</span>
<span class="udiff-line-modified-added">+             acquire(node, savedState, false, false, false, 0L);</span>
<span class="udiff-line-modified-added">+             if (cancelled) {</span>
<span class="udiff-line-modified-added">+                 unlinkCancelledWaiters(node);</span>
<span class="udiff-line-modified-added">+                 if (interrupted)</span>
<span class="udiff-line-modified-added">+                     throw new InterruptedException();</span>
<span class="udiff-line-modified-added">+             } else if (interrupted)</span>
<span class="udiff-line-added">+                 Thread.currentThread().interrupt();</span>
<span class="udiff-line-added">+             return !cancelled;</span>
          }
  
          /**
           * Implements timed condition wait.
           * &lt;ol&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2193,35 +1730,32 @@</span>
          public final boolean await(long time, TimeUnit unit)
                  throws InterruptedException {
              long nanosTimeout = unit.toNanos(time);
              if (Thread.interrupted())
                  throw new InterruptedException();
<span class="udiff-line-modified-removed">-             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="udiff-line-modified-removed">-             // await(0, unit) as a way to &quot;yield the lock&quot;.</span>
<span class="udiff-line-modified-removed">-             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="udiff-line-modified-removed">-             Node node = addConditionWaiter();</span>
<span class="udiff-line-modified-removed">-             int savedState = fullyRelease(node);</span>
<span class="udiff-line-modified-removed">-             boolean timedout = false;</span>
<span class="udiff-line-modified-removed">-             int interruptMode = 0;</span>
<span class="udiff-line-modified-removed">-             while (!isOnSyncQueue(node)) {</span>
<span class="udiff-line-modified-removed">-                 if (nanosTimeout &lt;= 0L) {</span>
<span class="udiff-line-modified-removed">-                     timedout = transferAfterCancelledWait(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="udiff-line-removed">-                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="udiff-line-removed">-                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="udiff-line-modified-added">+             ConditionNode node = new ConditionNode();</span>
<span class="udiff-line-modified-added">+             int savedState = enableWait(node);</span>
<span class="udiff-line-modified-added">+             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="udiff-line-modified-added">+             long deadline = System.nanoTime() + nanos;</span>
<span class="udiff-line-modified-added">+             boolean cancelled = false, interrupted = false;</span>
<span class="udiff-line-modified-added">+             while (!canReacquire(node)) {</span>
<span class="udiff-line-modified-added">+                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="udiff-line-modified-added">+                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="udiff-line-modified-added">+                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="udiff-line-modified-added">+                         break;</span>
<span class="udiff-line-modified-added">+                 } else</span>
<span class="udiff-line-modified-added">+                     LockSupport.parkNanos(this, nanos);</span>
              }
<span class="udiff-line-modified-removed">-             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="udiff-line-modified-removed">-                 interruptMode = REINTERRUPT;</span>
<span class="udiff-line-modified-removed">-             if (node.nextWaiter != null)</span>
<span class="udiff-line-modified-removed">-                 unlinkCancelledWaiters();</span>
<span class="udiff-line-modified-removed">-             if (interruptMode != 0)</span>
<span class="udiff-line-modified-removed">-                 reportInterruptAfterWait(interruptMode);</span>
<span class="udiff-line-modified-removed">-             return !timedout;</span>
<span class="udiff-line-modified-added">+             node.clearStatus();</span>
<span class="udiff-line-modified-added">+             acquire(node, savedState, false, false, false, 0L);</span>
<span class="udiff-line-modified-added">+             if (cancelled) {</span>
<span class="udiff-line-modified-added">+                 unlinkCancelledWaiters(node);</span>
<span class="udiff-line-modified-added">+                 if (interrupted)</span>
<span class="udiff-line-modified-added">+                     throw new InterruptedException();</span>
<span class="udiff-line-modified-added">+             } else if (interrupted)</span>
<span class="udiff-line-added">+                 Thread.currentThread().interrupt();</span>
<span class="udiff-line-added">+             return !cancelled;</span>
          }
  
          //  support for instrumentation
  
          /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2243,12 +1777,12 @@</span>
           *         returns {@code false}
           */
          protected final boolean hasWaiters() {
              if (!isHeldExclusively())
                  throw new IllegalMonitorStateException();
<span class="udiff-line-modified-removed">-             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="udiff-line-modified-removed">-                 if (w.waitStatus == Node.CONDITION)</span>
<span class="udiff-line-modified-added">+             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="udiff-line-modified-added">+                 if ((w.status &amp; COND) != 0)</span>
                      return true;
              }
              return false;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2263,12 +1797,12 @@</span>
           */
          protected final int getWaitQueueLength() {
              if (!isHeldExclusively())
                  throw new IllegalMonitorStateException();
              int n = 0;
<span class="udiff-line-modified-removed">-             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="udiff-line-modified-removed">-                 if (w.waitStatus == Node.CONDITION)</span>
<span class="udiff-line-modified-added">+             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="udiff-line-modified-added">+                 if ((w.status &amp; COND) != 0)</span>
                      ++n;
              }
              return n;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2283,52 +1817,29 @@</span>
           */
          protected final Collection&lt;Thread&gt; getWaitingThreads() {
              if (!isHeldExclusively())
                  throw new IllegalMonitorStateException();
              ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<span class="udiff-line-modified-removed">-             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="udiff-line-modified-removed">-                 if (w.waitStatus == Node.CONDITION) {</span>
<span class="udiff-line-modified-removed">-                     Thread t = w.thread;</span>
<span class="udiff-line-modified-added">+             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="udiff-line-modified-added">+                 if ((w.status &amp; COND) != 0) {</span>
<span class="udiff-line-modified-added">+                     Thread t = w.waiter;</span>
                      if (t != null)
                          list.add(t);
                  }
              }
              return list;
          }
      }
  
<span class="udiff-line-modified-removed">-     // VarHandle mechanics</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle STATE;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle HEAD;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle TAIL;</span>
<span class="udiff-line-modified-added">+     // Unsafe</span>
<span class="udiff-line-modified-added">+     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="udiff-line-modified-added">+     private static final long STATE</span>
<span class="udiff-line-modified-added">+         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, &quot;state&quot;);</span>
<span class="udiff-line-added">+     private static final long HEAD</span>
<span class="udiff-line-added">+         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, &quot;head&quot;);</span>
<span class="udiff-line-added">+     private static final long TAIL</span>
<span class="udiff-line-added">+         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, &quot;tail&quot;);</span>
  
      static {
<span class="udiff-line-removed">-         try {</span>
<span class="udiff-line-removed">-             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="udiff-line-removed">-             STATE = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;state&quot;, int.class);</span>
<span class="udiff-line-removed">-             HEAD = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;head&quot;, Node.class);</span>
<span class="udiff-line-removed">-             TAIL = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;tail&quot;, Node.class);</span>
<span class="udiff-line-removed">-         } catch (ReflectiveOperationException e) {</span>
<span class="udiff-line-removed">-             throw new ExceptionInInitializerError(e);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Reduce the risk of rare disastrous classloading in first call to</span>
<span class="udiff-line-removed">-         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span>
          Class&lt;?&gt; ensureLoaded = LockSupport.class;
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Initializes head and tail fields on first contention.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private final void initializeSyncQueue() {</span>
<span class="udiff-line-removed">-         Node h;</span>
<span class="udiff-line-removed">-         if (HEAD.compareAndSet(this, null, (h = new Node())))</span>
<span class="udiff-line-removed">-             tail = h;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * CASes tail field.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private final boolean compareAndSetTail(Node expect, Node update) {</span>
<span class="udiff-line-removed">-         return TAIL.compareAndSet(this, expect, update);</span>
<span class="udiff-line-removed">-     }</span>
  }
</pre>
<center><a href="AbstractQueuedLongSynchronizer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Condition.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
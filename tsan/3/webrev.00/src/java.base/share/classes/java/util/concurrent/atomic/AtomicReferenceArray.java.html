<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 package java.util.concurrent.atomic;
 37 
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.invoke.VarHandle;
 40 import java.lang.reflect.Array;
 41 import java.lang.reflect.Field;
 42 import java.util.Arrays;
 43 import java.util.function.BinaryOperator;
 44 import java.util.function.UnaryOperator;
 45 
 46 /**
 47  * An array of object references in which elements may be updated
 48  * atomically.  See the {@link VarHandle} specification for
 49  * descriptions of the properties of atomic accesses.
 50  * @since 1.5
 51  * @author Doug Lea
 52  * @param &lt;E&gt; The base class of elements held in this array
 53  */
 54 public class AtomicReferenceArray&lt;E&gt; implements java.io.Serializable {
 55     private static final long serialVersionUID = -6209656149925076980L;
 56     private static final VarHandle AA
 57         = MethodHandles.arrayElementVarHandle(Object[].class);
 58     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
 59     private final Object[] array; // must have exact type Object[]
 60 
 61     /**
 62      * Creates a new AtomicReferenceArray of the given length, with all
 63      * elements initially null.
 64      *
 65      * @param length the length of the array
 66      */
 67     public AtomicReferenceArray(int length) {
 68         array = new Object[length];
 69     }
 70 
 71     /**
 72      * Creates a new AtomicReferenceArray with the same length as, and
 73      * all elements copied from, the given array.
 74      *
 75      * @param array the array to copy elements from
 76      * @throws NullPointerException if array is null
 77      */
 78     public AtomicReferenceArray(E[] array) {
 79         // Visibility guaranteed by final field guarantees
 80         this.array = Arrays.copyOf(array, array.length, Object[].class);
 81     }
 82 
 83     /**
 84      * Returns the length of the array.
 85      *
 86      * @return the length of the array
 87      */
 88     public final int length() {
 89         return array.length;
 90     }
 91 
 92     /**
 93      * Returns the current value of the element at index {@code i},
 94      * with memory effects as specified by {@link VarHandle#getVolatile}.
 95      *
 96      * @param i the index
 97      * @return the current value
 98      */
 99     @SuppressWarnings(&quot;unchecked&quot;)
100     public final E get(int i) {
101         return (E)AA.getVolatile(array, i);
102     }
103 
104     /**
105      * Sets the element at index {@code i} to {@code newValue},
106      * with memory effects as specified by {@link VarHandle#setVolatile}.
107      *
108      * @param i the index
109      * @param newValue the new value
110      */
111     public final void set(int i, E newValue) {
112         AA.setVolatile(array, i, newValue);
113     }
114 
115     /**
116      * Sets the element at index {@code i} to {@code newValue},
117      * with memory effects as specified by {@link VarHandle#setRelease}.
118      *
119      * @param i the index
120      * @param newValue the new value
121      * @since 1.6
122      */
123     public final void lazySet(int i, E newValue) {
124         AA.setRelease(array, i, newValue);
125     }
126 
127     /**
128      * Atomically sets the element at index {@code i} to {@code
129      * newValue} and returns the old value,
130      * with memory effects as specified by {@link VarHandle#getAndSet}.
131      *
132      * @param i the index
133      * @param newValue the new value
134      * @return the previous value
135      */
136     @SuppressWarnings(&quot;unchecked&quot;)
137     public final E getAndSet(int i, E newValue) {
138         return (E)AA.getAndSet(array, i, newValue);
139     }
140 
141     /**
142      * Atomically sets the element at index {@code i} to {@code newValue}
143      * if the element&#39;s current value {@code == expectedValue},
144      * with memory effects as specified by {@link VarHandle#compareAndSet}.
145      *
146      * @param i the index
147      * @param expectedValue the expected value
148      * @param newValue the new value
149      * @return {@code true} if successful. False return indicates that
150      * the actual value was not equal to the expected value.
151      */
152     public final boolean compareAndSet(int i, E expectedValue, E newValue) {
153         return AA.compareAndSet(array, i, expectedValue, newValue);
154     }
155 
156     /**
157      * Possibly atomically sets the element at index {@code i} to
158      * {@code newValue} if the element&#39;s current value {@code == expectedValue},
159      * with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
160      *
161      * @deprecated This method has plain memory effects but the method
162      * name implies volatile memory effects (see methods such as
163      * {@link #compareAndExchange} and {@link #compareAndSet}).  To avoid
164      * confusion over plain or volatile memory effects it is recommended that
165      * the method {@link #weakCompareAndSetPlain} be used instead.
166      *
167      * @param i the index
168      * @param expectedValue the expected value
169      * @param newValue the new value
170      * @return {@code true} if successful
171      * @see #weakCompareAndSetPlain
172      */
173     @Deprecated(since=&quot;9&quot;)
174     public final boolean weakCompareAndSet(int i, E expectedValue, E newValue) {
175         return AA.weakCompareAndSetPlain(array, i, expectedValue, newValue);
176     }
177 
178     /**
179      * Possibly atomically sets the element at index {@code i} to
180      * {@code newValue} if the element&#39;s current value {@code == expectedValue},
181      * with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
182      *
183      * @param i the index
184      * @param expectedValue the expected value
185      * @param newValue the new value
186      * @return {@code true} if successful
187      * @since 9
188      */
189     public final boolean weakCompareAndSetPlain(int i, E expectedValue, E newValue) {
190         return AA.weakCompareAndSetPlain(array, i, expectedValue, newValue);
191     }
192 
193     /**
194      * Atomically updates (with memory effects as specified by {@link
195      * VarHandle#compareAndSet}) the element at index {@code i} with
196      * the results of applying the given function, returning the
197      * previous value. The function should be side-effect-free, since
198      * it may be re-applied when attempted updates fail due to
199      * contention among threads.
200      *
201      * @param i the index
202      * @param updateFunction a side-effect-free function
203      * @return the previous value
204      * @since 1.8
205      */
206     public final E getAndUpdate(int i, UnaryOperator&lt;E&gt; updateFunction) {
207         E prev = get(i), next = null;
208         for (boolean haveNext = false;;) {
209             if (!haveNext)
210                 next = updateFunction.apply(prev);
211             if (weakCompareAndSetVolatile(i, prev, next))
212                 return prev;
213             haveNext = (prev == (prev = get(i)));
214         }
215     }
216 
217     /**
218      * Atomically updates (with memory effects as specified by {@link
219      * VarHandle#compareAndSet}) the element at index {@code i} with
220      * the results of applying the given function, returning the
221      * updated value. The function should be side-effect-free, since it
222      * may be re-applied when attempted updates fail due to contention
223      * among threads.
224      *
225      * @param i the index
226      * @param updateFunction a side-effect-free function
227      * @return the updated value
228      * @since 1.8
229      */
230     public final E updateAndGet(int i, UnaryOperator&lt;E&gt; updateFunction) {
231         E prev = get(i), next = null;
232         for (boolean haveNext = false;;) {
233             if (!haveNext)
234                 next = updateFunction.apply(prev);
235             if (weakCompareAndSetVolatile(i, prev, next))
236                 return next;
237             haveNext = (prev == (prev = get(i)));
238         }
239     }
240 
241     /**
242      * Atomically updates (with memory effects as specified by {@link
243      * VarHandle#compareAndSet}) the element at index {@code i} with
244      * the results of applying the given function to the current and
245      * given values, returning the previous value. The function should
246      * be side-effect-free, since it may be re-applied when attempted
247      * updates fail due to contention among threads.  The function is
248      * applied with the current value of the element at index {@code i}
249      * as its first argument, and the given update as the second
250      * argument.
251      *
252      * @param i the index
253      * @param x the update value
254      * @param accumulatorFunction a side-effect-free function of two arguments
255      * @return the previous value
256      * @since 1.8
257      */
258     public final E getAndAccumulate(int i, E x,
259                                     BinaryOperator&lt;E&gt; accumulatorFunction) {
260         E prev = get(i), next = null;
261         for (boolean haveNext = false;;) {
262             if (!haveNext)
263                 next = accumulatorFunction.apply(prev, x);
264             if (weakCompareAndSetVolatile(i, prev, next))
265                 return prev;
266             haveNext = (prev == (prev = get(i)));
267         }
268     }
269 
270     /**
271      * Atomically updates (with memory effects as specified by {@link
272      * VarHandle#compareAndSet}) the element at index {@code i} with
273      * the results of applying the given function to the current and
274      * given values, returning the updated value. The function should
275      * be side-effect-free, since it may be re-applied when attempted
276      * updates fail due to contention among threads.  The function is
277      * applied with the current value of the element at index {@code i}
278      * as its first argument, and the given update as the second
279      * argument.
280      *
281      * @param i the index
282      * @param x the update value
283      * @param accumulatorFunction a side-effect-free function of two arguments
284      * @return the updated value
285      * @since 1.8
286      */
287     public final E accumulateAndGet(int i, E x,
288                                     BinaryOperator&lt;E&gt; accumulatorFunction) {
289         E prev = get(i), next = null;
290         for (boolean haveNext = false;;) {
291             if (!haveNext)
292                 next = accumulatorFunction.apply(prev, x);
293             if (weakCompareAndSetVolatile(i, prev, next))
294                 return next;
295             haveNext = (prev == (prev = get(i)));
296         }
297     }
298 
299     /**
300      * Returns the String representation of the current values of array.
301      * @return the String representation of the current values of array
302      */
303     public String toString() {
304         int iMax = array.length - 1;
305         if (iMax == -1)
306             return &quot;[]&quot;;
307 
308         StringBuilder b = new StringBuilder();
309         b.append(&#39;[&#39;);
310         for (int i = 0; ; i++) {
311             b.append(get(i));
312             if (i == iMax)
313                 return b.append(&#39;]&#39;).toString();
314             b.append(&#39;,&#39;).append(&#39; &#39;);
315         }
316     }
317 
318     /**
319      * Reconstitutes the instance from a stream (that is, deserializes it).
320      * @param s the stream
321      * @throws ClassNotFoundException if the class of a serialized object
322      *         could not be found
323      * @throws java.io.IOException if an I/O error occurs
324      */
325     private void readObject(java.io.ObjectInputStream s)
326         throws java.io.IOException, ClassNotFoundException {
327         // Note: This must be changed if any additional fields are defined
328         Object a = s.readFields().get(&quot;array&quot;, null);
329         if (a == null || !a.getClass().isArray())
330             throw new java.io.InvalidObjectException(&quot;Not array type&quot;);
331         if (a.getClass() != Object[].class)
332             a = Arrays.copyOf((Object[])a, Array.getLength(a), Object[].class);
333         Field arrayField = java.security.AccessController.doPrivileged(
334             (java.security.PrivilegedAction&lt;Field&gt;) () -&gt; {
335                 try {
336                     Field f = AtomicReferenceArray.class
337                         .getDeclaredField(&quot;array&quot;);
338                     f.setAccessible(true);
339                     return f;
340                 } catch (ReflectiveOperationException e) {
341                     throw new Error(e);
342                 }});
343         try {
344             arrayField.set(this, a);
345         } catch (IllegalAccessException e) {
346             throw new Error(e);
347         }
348     }
349 
350     // jdk9
351 
352     /**
353      * Returns the current value of the element at index {@code i},
354      * with memory semantics of reading as if the variable was declared
355      * non-{@code volatile}.
356      *
357      * @param i the index
358      * @return the value
359      * @since 9
360      */
361     public final E getPlain(int i) {
362         return (E)AA.get(array, i);
363     }
364 
365     /**
366      * Sets the element at index {@code i} to {@code newValue},
367      * with memory semantics of setting as if the variable was
368      * declared non-{@code volatile} and non-{@code final}.
369      *
370      * @param i the index
371      * @param newValue the new value
372      * @since 9
373      */
374     public final void setPlain(int i, E newValue) {
375         AA.set(array, i, newValue);
376     }
377 
378     /**
379      * Returns the current value of the element at index {@code i},
380      * with memory effects as specified by {@link VarHandle#getOpaque}.
381      *
382      * @param i the index
383      * @return the value
384      * @since 9
385      */
386     public final E getOpaque(int i) {
387         return (E)AA.getOpaque(array, i);
388     }
389 
390     /**
391      * Sets the element at index {@code i} to {@code newValue},
392      * with memory effects as specified by {@link VarHandle#setOpaque}.
393      *
394      * @param i the index
395      * @param newValue the new value
396      * @since 9
397      */
398     public final void setOpaque(int i, E newValue) {
399         AA.setOpaque(array, i, newValue);
400     }
401 
402     /**
403      * Returns the current value of the element at index {@code i},
404      * with memory effects as specified by {@link VarHandle#getAcquire}.
405      *
406      * @param i the index
407      * @return the value
408      * @since 9
409      */
410     public final E getAcquire(int i) {
411         return (E)AA.getAcquire(array, i);
412     }
413 
414     /**
415      * Sets the element at index {@code i} to {@code newValue},
416      * with memory effects as specified by {@link VarHandle#setRelease}.
417      *
418      * @param i the index
419      * @param newValue the new value
420      * @since 9
421      */
422     public final void setRelease(int i, E newValue) {
423         AA.setRelease(array, i, newValue);
424     }
425 
426     /**
427      * Atomically sets the element at index {@code i} to {@code newValue}
428      * if the element&#39;s current value, referred to as the &lt;em&gt;witness
429      * value&lt;/em&gt;, {@code == expectedValue},
430      * with memory effects as specified by
431      * {@link VarHandle#compareAndExchange}.
432      *
433      * @param i the index
434      * @param expectedValue the expected value
435      * @param newValue the new value
436      * @return the witness value, which will be the same as the
437      * expected value if successful
438      * @since 9
439      */
440     public final E compareAndExchange(int i, E expectedValue, E newValue) {
441         return (E)AA.compareAndExchange(array, i, expectedValue, newValue);
442     }
443 
444     /**
445      * Atomically sets the element at index {@code i} to {@code newValue}
446      * if the element&#39;s current value, referred to as the &lt;em&gt;witness
447      * value&lt;/em&gt;, {@code == expectedValue},
448      * with memory effects as specified by
449      * {@link VarHandle#compareAndExchangeAcquire}.
450      *
451      * @param i the index
452      * @param expectedValue the expected value
453      * @param newValue the new value
454      * @return the witness value, which will be the same as the
455      * expected value if successful
456      * @since 9
457      */
458     public final E compareAndExchangeAcquire(int i, E expectedValue, E newValue) {
459         return (E)AA.compareAndExchangeAcquire(array, i, expectedValue, newValue);
460     }
461 
462     /**
463      * Atomically sets the element at index {@code i} to {@code newValue}
464      * if the element&#39;s current value, referred to as the &lt;em&gt;witness
465      * value&lt;/em&gt;, {@code == expectedValue},
466      * with memory effects as specified by
467      * {@link VarHandle#compareAndExchangeRelease}.
468      *
469      * @param i the index
470      * @param expectedValue the expected value
471      * @param newValue the new value
472      * @return the witness value, which will be the same as the
473      * expected value if successful
474      * @since 9
475      */
476     public final E compareAndExchangeRelease(int i, E expectedValue, E newValue) {
477         return (E)AA.compareAndExchangeRelease(array, i, expectedValue, newValue);
478     }
479 
480     /**
481      * Possibly atomically sets the element at index {@code i} to
482      * {@code newValue} if the element&#39;s current value {@code == expectedValue},
483      * with memory effects as specified by
484      * {@link VarHandle#weakCompareAndSet}.
485      *
486      * @param i the index
487      * @param expectedValue the expected value
488      * @param newValue the new value
489      * @return {@code true} if successful
490      * @since 9
491      */
492     public final boolean weakCompareAndSetVolatile(int i, E expectedValue, E newValue) {
493         return AA.weakCompareAndSet(array, i, expectedValue, newValue);
494     }
495 
496     /**
497      * Possibly atomically sets the element at index {@code i} to
498      * {@code newValue} if the element&#39;s current value {@code == expectedValue},
499      * with memory effects as specified by
500      * {@link VarHandle#weakCompareAndSetAcquire}.
501      *
502      * @param i the index
503      * @param expectedValue the expected value
504      * @param newValue the new value
505      * @return {@code true} if successful
506      * @since 9
507      */
508     public final boolean weakCompareAndSetAcquire(int i, E expectedValue, E newValue) {
509         return AA.weakCompareAndSetAcquire(array, i, expectedValue, newValue);
510     }
511 
512     /**
513      * Possibly atomically sets the element at index {@code i} to
514      * {@code newValue} if the element&#39;s current value {@code == expectedValue},
515      * with memory effects as specified by
516      * {@link VarHandle#weakCompareAndSetRelease}.
517      *
518      * @param i the index
519      * @param expectedValue the expected value
520      * @param newValue the new value
521      * @return {@code true} if successful
522      * @since 9
523      */
524     public final boolean weakCompareAndSetRelease(int i, E expectedValue, E newValue) {
525         return AA.weakCompareAndSetRelease(array, i, expectedValue, newValue);
526     }
527 
528 }
    </pre>
  </body>
</html>
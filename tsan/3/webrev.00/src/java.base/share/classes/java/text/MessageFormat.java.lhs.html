<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/text/MessageFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.text.DecimalFormat;
  45 import java.util.ArrayList;
  46 import java.util.Arrays;
  47 import java.util.Date;
  48 import java.util.List;
  49 import java.util.Locale;
  50 
  51 
  52 /**
<a name="2" id="anc2"></a><span class="line-modified">  53  * &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated</span>
  54  * messages in a language-neutral way. Use this to construct messages
  55  * displayed for end users.
  56  *
  57  * &lt;p&gt;
<a name="3" id="anc3"></a><span class="line-modified">  58  * &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then</span>
  59  * inserts the formatted strings into the pattern at the appropriate places.
  60  *
  61  * &lt;p&gt;
  62  * &lt;strong&gt;Note:&lt;/strong&gt;
<a name="4" id="anc4"></a><span class="line-modified">  63  * &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified">  64  * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one</span>
<span class="line-modified">  65  * of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory</span>
<span class="line-modified">  66  * method). The factory methods aren&#39;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;</span>
  67  * itself doesn&#39;t implement locale specific behavior. Any locale specific
  68  * behavior is defined by the pattern that you provide as well as the
  69  * subformats used for inserted arguments.
  70  *
<a name="5" id="anc5"></a><span class="line-modified">  71  * &lt;h3&gt;&lt;a id=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h3&gt;</span>
  72  *
<a name="6" id="anc6"></a><span class="line-modified">  73  * &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:</span>
  74  * &lt;blockquote&gt;&lt;pre&gt;
  75  * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
  76  *         &lt;i&gt;String&lt;/i&gt;
  77  *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
  78  *
  79  * &lt;i&gt;FormatElement:&lt;/i&gt;
  80  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
  81  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
  82  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
  83  *
  84  * &lt;i&gt;FormatType: one of &lt;/i&gt;
  85  *         number date time choice
  86  *
  87  * &lt;i&gt;FormatStyle:&lt;/i&gt;
  88  *         short
  89  *         medium
  90  *         long
  91  *         full
  92  *         integer
  93  *         currency
  94  *         percent
  95  *         &lt;i&gt;SubformatPattern&lt;/i&gt;
  96  * &lt;/pre&gt;&lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
  99  * quote any arbitrary characters except single quotes. For example,
 100  * pattern string &lt;code&gt;&quot;&#39;{0}&#39;&quot;&lt;/code&gt; represents string
 101  * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
 102  * must be represented by doubled single quotes {@code &#39;&#39;} throughout a
 103  * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&#39;{&#39;&#39;}&#39;&quot;&lt;/code&gt; is
 104  * interpreted as a sequence of &lt;code&gt;&#39;{&lt;/code&gt; (start of quoting and a
<a name="7" id="anc7"></a><span class="line-modified"> 105  * left curly brace), &lt;code&gt;&#39;&#39;&lt;/code&gt; (a single quote), and</span>
 106  * &lt;code&gt;}&#39;&lt;/code&gt; (a right curly brace and end of quoting),
 107  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&#39;{&#39;&lt;/code&gt; and &lt;code&gt;&#39;}&#39;&lt;/code&gt; (quoted left and
 108  * right curly braces): representing string &lt;code&gt;&quot;{&#39;}&quot;&lt;/code&gt;,
 109  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
 110  *
 111  * &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
 112  * subformat, and subformat-dependent pattern rules apply. For example,
 113  * pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$&#39;#&#39;,##&lt;/u&gt;}&quot;&lt;/code&gt;
 114  * (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
 115  * with the pound-sign quoted, with a result such as: {@code
 116  * &quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for
 117  * details.
 118  *
 119  * &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
 120  * pattern. For example, pattern string {@code &quot;&#39;{0}&quot;} is treated as
 121  * pattern {@code &quot;&#39;{0}&#39;&quot;}.
 122  *
 123  * &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
 124  * example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab &#39;}&#39; de&quot;&lt;/code&gt; are
 125  * valid patterns, but &lt;code&gt;&quot;ab {0&#39;}&#39; de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt;
 126  * and &lt;code&gt;&quot;&#39;&#39;{&#39;&#39;&quot;&lt;/code&gt; are not.
 127  *
 128  * &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message
 129  * format patterns unfortunately have shown to be somewhat confusing.
 130  * In particular, it isn&#39;t always obvious to localizers whether single
 131  * quotes need to be doubled or not. Make sure to inform localizers about
 132  * the rules, and tell them (for example, by using comments in resource
 133  * bundle source files) which strings will be processed by {@code MessageFormat}.
 134  * Note that localizers may need to use single quotes in translated
 135  * strings where the original version doesn&#39;t have them.
 136  * &lt;/dl&gt;
 137  * &lt;p&gt;
 138  * The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written
 139  * using the digits {@code &#39;0&#39;} through {@code &#39;9&#39;}, and represents an index into the
 140  * {@code arguments} array passed to the {@code format} methods
 141  * or the result array returned by the {@code parse} methods.
 142  * &lt;p&gt;
 143  * The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create
 144  * a {@code Format} instance for the format element. The following
 145  * table shows how the values map to {@code Format} instances. Combinations not
 146  * shown in the table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must
 147  * be a valid pattern string for the {@code Format} subclass used.
 148  *
 149  * &lt;table class=&quot;plain&quot;&gt;
 150  * &lt;caption style=&quot;display:none&quot;&gt;Shows how FormatType and FormatStyle values map to Format instances&lt;/caption&gt;
 151  * &lt;thead&gt;
 152  *    &lt;tr&gt;
 153  *       &lt;th scope=&quot;col&quot; class=&quot;TableHeadingColor&quot;&gt;FormatType
 154  *       &lt;th scope=&quot;col&quot; class=&quot;TableHeadingColor&quot;&gt;FormatStyle
 155  *       &lt;th scope=&quot;col&quot; class=&quot;TableHeadingColor&quot;&gt;Subformat Created
 156  * &lt;/thead&gt;
 157  * &lt;tbody&gt;
 158  *    &lt;tr&gt;
 159  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 160  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 161  *       &lt;td&gt;{@code null}
 162  *    &lt;tr&gt;
 163  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot; rowspan=5&gt;{@code number}
 164  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 165  *       &lt;td&gt;{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
 166  *    &lt;tr&gt;
 167  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code integer}
 168  *       &lt;td&gt;{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
 169  *    &lt;tr&gt;
 170  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code currency}
 171  *       &lt;td&gt;{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}
 172  *    &lt;tr&gt;
 173  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code percent}
 174  *       &lt;td&gt;{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
 175  *    &lt;tr&gt;
 176  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 177  *       &lt;td&gt;{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
 178  *    &lt;tr&gt;
 179  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot; rowspan=6&gt;{@code date}
 180  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 181  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 182  *    &lt;tr&gt;
 183  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code short}
 184  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 185  *    &lt;tr&gt;
 186  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code medium}
 187  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 188  *    &lt;tr&gt;
 189  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code long}
 190  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 191  *    &lt;tr&gt;
 192  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code full}
 193  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 194  *    &lt;tr&gt;
 195  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 196  *       &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 197  *    &lt;tr&gt;
 198  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot; rowspan=6&gt;{@code time}
 199  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 200  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 201  *    &lt;tr&gt;
 202  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code short}
 203  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 204  *    &lt;tr&gt;
 205  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code medium}
 206  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 207  *    &lt;tr&gt;
 208  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code long}
 209  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 210  *    &lt;tr&gt;
 211  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code full}
 212  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 213  *    &lt;tr&gt;
 214  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 215  *       &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 216  *    &lt;tr&gt;
 217  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code choice}
 218  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 219  *       &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 220  * &lt;/tbody&gt;
 221  * &lt;/table&gt;
 222  *
<a name="8" id="anc8"></a><span class="line-modified"> 223  * &lt;h4&gt;Usage Information&lt;/h4&gt;</span>
 224  *
 225  * &lt;p&gt;
 226  * Here are some examples of usage.
 227  * In real internationalized programs, the message format pattern and other
 228  * static strings will, of course, be obtained from resource bundles.
 229  * Other parameters will be dynamically determined at runtime.
 230  * &lt;p&gt;
<a name="9" id="anc9"></a><span class="line-modified"> 231  * The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,</span>
<span class="line-modified"> 232  * which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:</span>
 233  * &lt;blockquote&gt;&lt;pre&gt;
 234  * int planet = 7;
 235  * String event = &quot;a disturbance in the Force&quot;;
 236  *
 237  * String result = MessageFormat.format(
 238  *     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
 239  *     planet, new Date(), event);
 240  * &lt;/pre&gt;&lt;/blockquote&gt;
 241  * The output is:
 242  * &lt;blockquote&gt;&lt;pre&gt;
 243  * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 244  * &lt;/pre&gt;&lt;/blockquote&gt;
 245  *
 246  * &lt;p&gt;
<a name="10" id="anc10"></a><span class="line-modified"> 247  * The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that</span>
 248  * can be used repeatedly:
 249  * &lt;blockquote&gt;&lt;pre&gt;
 250  * int fileCount = 1273;
 251  * String diskName = &quot;MyDisk&quot;;
 252  * Object[] testArgs = {new Long(fileCount), diskName};
 253  *
 254  * MessageFormat form = new MessageFormat(
 255  *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
 256  *
 257  * System.out.println(form.format(testArgs));
 258  * &lt;/pre&gt;&lt;/blockquote&gt;
<a name="11" id="anc11"></a><span class="line-modified"> 259  * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</span>
 260  * &lt;blockquote&gt;&lt;pre&gt;
 261  * The disk &quot;MyDisk&quot; contains 0 file(s).
 262  * The disk &quot;MyDisk&quot; contains 1 file(s).
 263  * The disk &quot;MyDisk&quot; contains 1,273 file(s).
 264  * &lt;/pre&gt;&lt;/blockquote&gt;
 265  *
 266  * &lt;p&gt;
<a name="12" id="anc12"></a><span class="line-modified"> 267  * For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
 268  * to produce correct forms for singular and plural:
 269  * &lt;blockquote&gt;&lt;pre&gt;
 270  * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 271  * double[] filelimits = {0,1,2};
 272  * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 273  * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 274  * form.setFormatByArgumentIndex(0, fileform);
 275  *
 276  * int fileCount = 1273;
 277  * String diskName = &quot;MyDisk&quot;;
 278  * Object[] testArgs = {new Long(fileCount), diskName};
 279  *
 280  * System.out.println(form.format(testArgs));
 281  * &lt;/pre&gt;&lt;/blockquote&gt;
<a name="13" id="anc13"></a><span class="line-modified"> 282  * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</span>
 283  * &lt;blockquote&gt;&lt;pre&gt;
 284  * The disk &quot;MyDisk&quot; contains no files.
 285  * The disk &quot;MyDisk&quot; contains one file.
 286  * The disk &quot;MyDisk&quot; contains 1,273 files.
 287  * &lt;/pre&gt;&lt;/blockquote&gt;
 288  *
 289  * &lt;p&gt;
<a name="14" id="anc14"></a><span class="line-modified"> 290  * You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the</span>
 291  * above example, or by using a pattern. See {@link ChoiceFormat}
 292  * for more information.
 293  * &lt;blockquote&gt;&lt;pre&gt;{@code
 294  * form.applyPattern(
 295  *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
 296  * }&lt;/pre&gt;&lt;/blockquote&gt;
 297  *
 298  * &lt;p&gt;
 299  * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
<a name="15" id="anc15"></a><span class="line-modified"> 300  * by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;</span>
 301  * occurrences of &#39;{&#39; are used to indicate subformats, and cause recursion.
<a name="16" id="anc16"></a><span class="line-modified"> 302  * If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
 303  * programmatically (instead of using the string patterns), then be careful not to
 304  * produce a format that recurses on itself, which will cause an infinite loop.
 305  * &lt;p&gt;
 306  * When a single argument is parsed more than once in the string, the last match
 307  * will be the final result of the parsing.  For example,
 308  * &lt;blockquote&gt;&lt;pre&gt;
 309  * MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 310  * Object[] objs = {new Double(3.1415)};
 311  * String result = mf.format( objs );
 312  * // result now equals &quot;3.14, 3.1&quot;
 313  * objs = null;
 314  * objs = mf.parse(result, new ParsePosition(0));
 315  * // objs now equals {new Double(3.1)}
 316  * &lt;/pre&gt;&lt;/blockquote&gt;
 317  *
 318  * &lt;p&gt;
 319  * Likewise, parsing with a {@code MessageFormat} object using patterns containing
 320  * multiple occurrences of the same argument would return the last match.  For
 321  * example,
 322  * &lt;blockquote&gt;&lt;pre&gt;
 323  * MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 324  * String forParsing = &quot;x, y, z&quot;;
 325  * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 326  * // result now equals {new String(&quot;z&quot;)}
 327  * &lt;/pre&gt;&lt;/blockquote&gt;
 328  *
<a name="17" id="anc17"></a><span class="line-modified"> 329  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
 330  *
 331  * &lt;p&gt;
 332  * Message formats are not synchronized.
 333  * It is recommended to create separate format instances for each thread.
 334  * If multiple threads access a format concurrently, it must be synchronized
 335  * externally.
 336  *
 337  * @see          java.util.Locale
 338  * @see          Format
 339  * @see          NumberFormat
 340  * @see          DecimalFormat
 341  * @see          DecimalFormatSymbols
 342  * @see          ChoiceFormat
 343  * @see          DateFormat
 344  * @see          SimpleDateFormat
 345  *
 346  * @author       Mark Davis
 347  * @since 1.1
 348  */
 349 
 350 public class MessageFormat extends Format {
 351 
<a name="18" id="anc18"></a>
 352     private static final long serialVersionUID = 6479157306784022952L;
 353 
 354     /**
 355      * Constructs a MessageFormat for the default
 356      * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
 357      * specified pattern.
 358      * The constructor first sets the locale, then parses the pattern and
 359      * creates a list of subformats for the format elements contained in it.
 360      * Patterns and their interpretation are specified in the
 361      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 362      *
 363      * @param pattern the pattern for this message format
<a name="19" id="anc19"></a><span class="line-modified"> 364      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 365      * @exception NullPointerException if {@code pattern} is</span>
 366      *            {@code null}
 367      */
 368     public MessageFormat(String pattern) {
 369         this.locale = Locale.getDefault(Locale.Category.FORMAT);
 370         applyPattern(pattern);
 371     }
 372 
 373     /**
 374      * Constructs a MessageFormat for the specified locale and
 375      * pattern.
 376      * The constructor first sets the locale, then parses the pattern and
 377      * creates a list of subformats for the format elements contained in it.
 378      * Patterns and their interpretation are specified in the
 379      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 380      *
 381      * @param pattern the pattern for this message format
 382      * @param locale the locale for this message format
<a name="20" id="anc20"></a><span class="line-modified"> 383      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 384      * @exception NullPointerException if {@code pattern} is</span>
 385      *            {@code null}
 386      * @since 1.4
 387      */
 388     public MessageFormat(String pattern, Locale locale) {
 389         this.locale = locale;
 390         applyPattern(pattern);
 391     }
 392 
 393     /**
 394      * Sets the locale to be used when creating or comparing subformats.
 395      * This affects subsequent calls
 396      * &lt;ul&gt;
 397      * &lt;li&gt;to the {@link #applyPattern applyPattern}
 398      *     and {@link #toPattern toPattern} methods if format elements specify
 399      *     a format type and therefore have the subformats created in the
<a name="21" id="anc21"></a><span class="line-modified"> 400      *     &lt;code&gt;applyPattern&lt;/code&gt; method, as well as</span>
<span class="line-modified"> 401      * &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and</span>
 402      *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
 403      *     if format elements do not specify a format type and therefore have
 404      *     the subformats created in the formatting methods.
 405      * &lt;/ul&gt;
 406      * Subformats that have already been created are not affected.
 407      *
 408      * @param locale the locale to be used when creating or comparing subformats
 409      */
 410     public void setLocale(Locale locale) {
 411         this.locale = locale;
 412     }
 413 
 414     /**
 415      * Gets the locale that&#39;s used when creating or comparing subformats.
 416      *
 417      * @return the locale used when creating or comparing subformats
 418      */
 419     public Locale getLocale() {
 420         return locale;
 421     }
 422 
 423 
 424     /**
 425      * Sets the pattern used by this message format.
 426      * The method parses the pattern and creates a list of subformats
 427      * for the format elements contained in it.
 428      * Patterns and their interpretation are specified in the
 429      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 430      *
 431      * @param pattern the pattern for this message format
<a name="22" id="anc22"></a><span class="line-modified"> 432      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified"> 433      * @exception NullPointerException if {@code pattern} is</span>
 434      *            {@code null}
 435      */
 436     @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
 437     public void applyPattern(String pattern) {
 438             StringBuilder[] segments = new StringBuilder[4];
 439             // Allocate only segments[SEG_RAW] here. The rest are
 440             // allocated on demand.
 441             segments[SEG_RAW] = new StringBuilder();
 442 
 443             int part = SEG_RAW;
 444             int formatNumber = 0;
 445             boolean inQuote = false;
 446             int braceStack = 0;
 447             maxOffset = -1;
 448             for (int i = 0; i &lt; pattern.length(); ++i) {
 449                 char ch = pattern.charAt(i);
 450                 if (part == SEG_RAW) {
 451                     if (ch == &#39;\&#39;&#39;) {
 452                         if (i + 1 &lt; pattern.length()
 453                             &amp;&amp; pattern.charAt(i+1) == &#39;\&#39;&#39;) {
 454                             segments[part].append(ch);  // handle doubles
 455                             ++i;
 456                         } else {
 457                             inQuote = !inQuote;
 458                         }
 459                     } else if (ch == &#39;{&#39; &amp;&amp; !inQuote) {
 460                         part = SEG_INDEX;
 461                         if (segments[SEG_INDEX] == null) {
 462                             segments[SEG_INDEX] = new StringBuilder();
 463                         }
 464                     } else {
 465                         segments[part].append(ch);
 466                     }
 467                 } else  {
 468                     if (inQuote) {              // just copy quotes in parts
 469                         segments[part].append(ch);
 470                         if (ch == &#39;\&#39;&#39;) {
 471                             inQuote = false;
 472                         }
 473                     } else {
 474                         switch (ch) {
 475                         case &#39;,&#39;:
 476                             if (part &lt; SEG_MODIFIER) {
 477                                 if (segments[++part] == null) {
 478                                     segments[part] = new StringBuilder();
 479                                 }
 480                             } else {
 481                                 segments[part].append(ch);
 482                             }
 483                             break;
 484                         case &#39;{&#39;:
 485                             ++braceStack;
 486                             segments[part].append(ch);
 487                             break;
 488                         case &#39;}&#39;:
 489                             if (braceStack == 0) {
 490                                 part = SEG_RAW;
 491                                 makeFormat(i, formatNumber, segments);
 492                                 formatNumber++;
 493                                 // throw away other segments
 494                                 segments[SEG_INDEX] = null;
 495                                 segments[SEG_TYPE] = null;
 496                                 segments[SEG_MODIFIER] = null;
 497                             } else {
 498                                 --braceStack;
 499                                 segments[part].append(ch);
 500                             }
 501                             break;
 502                         case &#39; &#39;:
 503                             // Skip any leading space chars for SEG_TYPE.
 504                             if (part != SEG_TYPE || segments[SEG_TYPE].length() &gt; 0) {
 505                                 segments[part].append(ch);
 506                             }
 507                             break;
 508                         case &#39;\&#39;&#39;:
 509                             inQuote = true;
 510                             // fall through, so we keep quotes in other parts
 511                         default:
 512                             segments[part].append(ch);
 513                             break;
 514                         }
 515                     }
 516                 }
 517             }
 518             if (braceStack == 0 &amp;&amp; part != 0) {
 519                 maxOffset = -1;
 520                 throw new IllegalArgumentException(&quot;Unmatched braces in the pattern.&quot;);
 521             }
 522             this.pattern = segments[0].toString();
 523     }
 524 
 525 
 526     /**
 527      * Returns a pattern representing the current state of the message format.
 528      * The string is constructed from internal information and therefore
 529      * does not necessarily equal the previously applied pattern.
 530      *
 531      * @return a pattern representing the current state of the message format
 532      */
 533     public String toPattern() {
 534         // later, make this more extensible
 535         int lastOffset = 0;
 536         StringBuilder result = new StringBuilder();
 537         for (int i = 0; i &lt;= maxOffset; ++i) {
 538             copyAndFixQuotes(pattern, lastOffset, offsets[i], result);
 539             lastOffset = offsets[i];
 540             result.append(&#39;{&#39;).append(argumentNumbers[i]);
 541             Format fmt = formats[i];
 542             if (fmt == null) {
 543                 // do nothing, string format
 544             } else if (fmt instanceof NumberFormat) {
 545                 if (fmt.equals(NumberFormat.getInstance(locale))) {
 546                     result.append(&quot;,number&quot;);
 547                 } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {
 548                     result.append(&quot;,number,currency&quot;);
 549                 } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {
 550                     result.append(&quot;,number,percent&quot;);
 551                 } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {
 552                     result.append(&quot;,number,integer&quot;);
 553                 } else {
 554                     if (fmt instanceof DecimalFormat) {
 555                         result.append(&quot;,number,&quot;).append(((DecimalFormat)fmt).toPattern());
 556                     } else if (fmt instanceof ChoiceFormat) {
 557                         result.append(&quot;,choice,&quot;).append(((ChoiceFormat)fmt).toPattern());
 558                     } else {
 559                         // UNKNOWN
 560                     }
 561                 }
 562             } else if (fmt instanceof DateFormat) {
 563                 int index;
 564                 for (index = MODIFIER_DEFAULT; index &lt; DATE_TIME_MODIFIERS.length; index++) {
 565                     DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index],
 566                                                                locale);
 567                     if (fmt.equals(df)) {
 568                         result.append(&quot;,date&quot;);
 569                         break;
 570                     }
 571                     df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index],
 572                                                     locale);
 573                     if (fmt.equals(df)) {
 574                         result.append(&quot;,time&quot;);
 575                         break;
 576                     }
 577                 }
 578                 if (index &gt;= DATE_TIME_MODIFIERS.length) {
 579                     if (fmt instanceof SimpleDateFormat) {
 580                         result.append(&quot;,date,&quot;).append(((SimpleDateFormat)fmt).toPattern());
 581                     } else {
 582                         // UNKNOWN
 583                     }
 584                 } else if (index != MODIFIER_DEFAULT) {
 585                     result.append(&#39;,&#39;).append(DATE_TIME_MODIFIER_KEYWORDS[index]);
 586                 }
 587             } else {
 588                 //result.append(&quot;, unknown&quot;);
 589             }
 590             result.append(&#39;}&#39;);
 591         }
 592         copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);
 593         return result.toString();
 594     }
 595 
 596     /**
 597      * Sets the formats to use for the values passed into
<a name="23" id="anc23"></a><span class="line-modified"> 598      * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;</span>
<span class="line-modified"> 599      * methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt;</span>
 600      * correspond to the argument indices used in the previously set
 601      * pattern string.
<a name="24" id="anc24"></a><span class="line-modified"> 602      * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to</span>
<span class="line-modified"> 603      * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified"> 604      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified"> 605      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 606      * &lt;p&gt;
 607      * If an argument index is used for more than one format element
 608      * in the pattern string, then the corresponding new format is used
 609      * for all such format elements. If an argument index is not used
 610      * for any format element in the pattern string, then the
 611      * corresponding new format is ignored. If fewer formats are provided
 612      * than needed, then only the formats for argument indices less
<a name="25" id="anc25"></a><span class="line-modified"> 613      * than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</span>
 614      *
 615      * @param newFormats the new formats to use
<a name="26" id="anc26"></a><span class="line-modified"> 616      * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</span>
 617      * @since 1.4
 618      */
 619     public void setFormatsByArgumentIndex(Format[] newFormats) {
 620         for (int i = 0; i &lt;= maxOffset; i++) {
 621             int j = argumentNumbers[i];
 622             if (j &lt; newFormats.length) {
 623                 formats[i] = newFormats[j];
 624             }
 625         }
 626     }
 627 
 628     /**
 629      * Sets the formats to use for the format elements in the
 630      * previously set pattern string.
<a name="27" id="anc27"></a><span class="line-modified"> 631      * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; corresponds to</span>
 632      * the order of format elements in the pattern string.
 633      * &lt;p&gt;
 634      * If more formats are provided than needed by the pattern string,
 635      * the remaining ones are ignored. If fewer formats are provided
<a name="28" id="anc28"></a><span class="line-modified"> 636      * than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt;</span>
 637      * formats are replaced.
 638      * &lt;p&gt;
 639      * Since the order of format elements in a pattern string often
 640      * changes during localization, it is generally better to use the
 641      * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
 642      * method, which assumes an order of formats corresponding to the
<a name="29" id="anc29"></a><span class="line-modified"> 643      * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to</span>
<span class="line-modified"> 644      * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by</span>
<span class="line-modified"> 645      * the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 646      *
 647      * @param newFormats the new formats to use
<a name="30" id="anc30"></a><span class="line-modified"> 648      * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</span>
 649      */
 650     public void setFormats(Format[] newFormats) {
 651         int runsToCopy = newFormats.length;
 652         if (runsToCopy &gt; maxOffset + 1) {
 653             runsToCopy = maxOffset + 1;
 654         }
 655         for (int i = 0; i &lt; runsToCopy; i++) {
 656             formats[i] = newFormats[i];
 657         }
 658     }
 659 
 660     /**
 661      * Sets the format to use for the format elements within the
 662      * previously set pattern string that use the given argument
 663      * index.
 664      * The argument index is part of the format element definition and
<a name="31" id="anc31"></a><span class="line-modified"> 665      * represents an index into the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified"> 666      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified"> 667      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 668      * &lt;p&gt;
 669      * If the argument index is used for more than one format element
 670      * in the pattern string, then the new format is used for all such
 671      * format elements. If the argument index is not used for any format
 672      * element in the pattern string, then the new format is ignored.
 673      *
 674      * @param argumentIndex the argument index for which to use the new format
 675      * @param newFormat the new format to use
 676      * @since 1.4
 677      */
 678     public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
 679         for (int j = 0; j &lt;= maxOffset; j++) {
 680             if (argumentNumbers[j] == argumentIndex) {
 681                 formats[j] = newFormat;
 682             }
 683         }
 684     }
 685 
 686     /**
 687      * Sets the format to use for the format element with the given
 688      * format element index within the previously set pattern string.
 689      * The format element index is the zero-based number of the format
 690      * element counting from the start of the pattern string.
 691      * &lt;p&gt;
 692      * Since the order of format elements in a pattern string often
 693      * changes during localization, it is generally better to use the
 694      * {@link #setFormatByArgumentIndex setFormatByArgumentIndex}
 695      * method, which accesses format elements based on the argument
 696      * index they specify.
 697      *
 698      * @param formatElementIndex the index of a format element within the pattern
 699      * @param newFormat the format to use for the specified format element
<a name="32" id="anc32"></a><span class="line-modified"> 700      * @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or</span>
 701      *            larger than the number of format elements in the pattern string
 702      */
 703     public void setFormat(int formatElementIndex, Format newFormat) {
 704 
 705         if (formatElementIndex &gt; maxOffset) {
 706             throw new ArrayIndexOutOfBoundsException(formatElementIndex);
 707         }
 708         formats[formatElementIndex] = newFormat;
 709     }
 710 
 711     /**
 712      * Gets the formats used for the values passed into
<a name="33" id="anc33"></a><span class="line-modified"> 713      * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;</span>
 714      * methods. The indices of elements in the returned array
 715      * correspond to the argument indices used in the previously set
 716      * pattern string.
 717      * The order of formats in the returned array thus corresponds to
<a name="34" id="anc34"></a><span class="line-modified"> 718      * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified"> 719      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified"> 720      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 721      * &lt;p&gt;
 722      * If an argument index is used for more than one format element
 723      * in the pattern string, then the format used for the last such
 724      * format element is returned in the array. If an argument index
 725      * is not used for any format element in the pattern string, then
 726      * null is returned in the array.
 727      *
 728      * @return the formats used for the arguments within the pattern
 729      * @since 1.4
 730      */
 731     public Format[] getFormatsByArgumentIndex() {
 732         int maximumArgumentNumber = -1;
 733         for (int i = 0; i &lt;= maxOffset; i++) {
 734             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 735                 maximumArgumentNumber = argumentNumbers[i];
 736             }
 737         }
 738         Format[] resultArray = new Format[maximumArgumentNumber + 1];
 739         for (int i = 0; i &lt;= maxOffset; i++) {
 740             resultArray[argumentNumbers[i]] = formats[i];
 741         }
 742         return resultArray;
 743     }
 744 
 745     /**
 746      * Gets the formats used for the format elements in the
 747      * previously set pattern string.
 748      * The order of formats in the returned array corresponds to
 749      * the order of format elements in the pattern string.
 750      * &lt;p&gt;
 751      * Since the order of format elements in a pattern string often
 752      * changes during localization, it&#39;s generally better to use the
 753      * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
 754      * method, which assumes an order of formats corresponding to the
<a name="35" id="anc35"></a><span class="line-modified"> 755      * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to</span>
<span class="line-modified"> 756      * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by</span>
<span class="line-modified"> 757      * the &lt;code&gt;parse&lt;/code&gt; methods.</span>
 758      *
 759      * @return the formats used for the format elements in the pattern
 760      */
 761     public Format[] getFormats() {
 762         Format[] resultArray = new Format[maxOffset + 1];
 763         System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
 764         return resultArray;
 765     }
 766 
 767     /**
<a name="36" id="anc36"></a><span class="line-modified"> 768      * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s</span>
 769      * pattern, with format elements replaced by the formatted objects, to the
<a name="37" id="anc37"></a><span class="line-modified"> 770      * provided &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
 771      * &lt;p&gt;
 772      * The text substituted for the individual format elements is derived from
 773      * the current subformat of the format element and the
<a name="38" id="anc38"></a><span class="line-modified"> 774      * &lt;code&gt;arguments&lt;/code&gt; element at the format element&#39;s argument index</span>
 775      * as indicated by the first matching line of the following table. An
<a name="39" id="anc39"></a><span class="line-modified"> 776      * argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is</span>
<span class="line-modified"> 777      * &lt;code&gt;null&lt;/code&gt; or has fewer than argumentIndex+1 elements.</span>
 778      *
 779      * &lt;table class=&quot;plain&quot;&gt;
 780      * &lt;caption style=&quot;display:none&quot;&gt;Examples of subformat,argument,and formatted text&lt;/caption&gt;
 781      * &lt;thead&gt;
 782      *    &lt;tr&gt;
 783      *       &lt;th scope=&quot;col&quot;&gt;Subformat
 784      *       &lt;th scope=&quot;col&quot;&gt;Argument
 785      *       &lt;th scope=&quot;col&quot;&gt;Formatted Text
 786      * &lt;/thead&gt;
 787      * &lt;tbody&gt;
 788      *    &lt;tr&gt;
 789      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=2&gt;&lt;i&gt;any&lt;/i&gt;
 790      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;unavailable&lt;/i&gt;
 791      *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
 792      *    &lt;tr&gt;
<a name="40" id="anc40"></a><span class="line-modified"> 793      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 794      *       &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;</span>
 795      *    &lt;tr&gt;
<a name="41" id="anc41"></a><span class="line-modified"> 796      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;</span>
 797      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
 798      *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&#39;{&#39;) &amp;gt;= 0 ?&lt;br&gt;
 799      *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
 800      *           subformat.format(argument)&lt;/code&gt;
 801      *    &lt;tr&gt;
<a name="42" id="anc42"></a><span class="line-modified"> 802      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;!= null&lt;/code&gt;</span>
 803      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<a name="43" id="anc43"></a><span class="line-modified"> 804      *       &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;</span>
 805      *    &lt;tr&gt;
<a name="44" id="anc44"></a><span class="line-modified"> 806      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=4&gt;&lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 807      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof Number&lt;/code&gt;</span>
<span class="line-modified"> 808      *       &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;</span>
 809      *    &lt;tr&gt;
<a name="45" id="anc45"></a><span class="line-modified"> 810      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof Date&lt;/code&gt;</span>
<span class="line-modified"> 811      *       &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;</span>
 812      *    &lt;tr&gt;
<a name="46" id="anc46"></a><span class="line-modified"> 813      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof String&lt;/code&gt;</span>
<span class="line-modified"> 814      *       &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;</span>
 815      *    &lt;tr&gt;
 816      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<a name="47" id="anc47"></a><span class="line-modified"> 817      *       &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;</span>
 818      * &lt;/tbody&gt;
 819      * &lt;/table&gt;
 820      * &lt;p&gt;
<a name="48" id="anc48"></a><span class="line-modified"> 821      * If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to</span>
<span class="line-modified"> 822      * &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted</span>
 823      * string will be returned.
 824      *
 825      * @param arguments an array of objects to be formatted and substituted.
 826      * @param result where text is appended.
 827      * @param pos keeps track on the position of the first replaced argument
 828                   in the output string.
 829      * @return the string buffer passed in as {@code result}, with formatted
 830      * text appended
<a name="49" id="anc49"></a><span class="line-modified"> 831      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 832      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
 833      *            expected by the format element(s) that use it.
<a name="50" id="anc50"></a><span class="line-modified"> 834      * @exception NullPointerException if {@code result} is {@code null}</span>
 835      */
 836     public final StringBuffer format(Object[] arguments, StringBuffer result,
 837                                      FieldPosition pos)
 838     {
 839         return subformat(arguments, result, pos, null);
 840     }
 841 
 842     /**
 843      * Creates a MessageFormat with the given pattern and uses it
 844      * to format the given arguments. This is equivalent to
 845      * &lt;blockquote&gt;
 846      *     &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 847      * &lt;/blockquote&gt;
 848      *
 849      * @param pattern   the pattern string
 850      * @param arguments object(s) to format
 851      * @return the formatted string
<a name="51" id="anc51"></a><span class="line-modified"> 852      * @exception IllegalArgumentException if the pattern is invalid,</span>
<span class="line-modified"> 853      *            or if an argument in the &lt;code&gt;arguments&lt;/code&gt; array</span>
 854      *            is not of the type expected by the format element(s)
 855      *            that use it.
<a name="52" id="anc52"></a><span class="line-modified"> 856      * @exception NullPointerException if {@code pattern} is {@code null}</span>
 857      */
 858     public static String format(String pattern, Object ... arguments) {
 859         MessageFormat temp = new MessageFormat(pattern);
 860         return temp.format(arguments);
 861     }
 862 
 863     // Overrides
 864     /**
<a name="53" id="anc53"></a><span class="line-modified"> 865      * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s</span>
 866      * pattern, with format elements replaced by the formatted objects, to the
<a name="54" id="anc54"></a><span class="line-modified"> 867      * provided &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
 868      * This is equivalent to
 869      * &lt;blockquote&gt;
 870      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
 871      * &lt;/blockquote&gt;
 872      *
 873      * @param arguments an array of objects to be formatted and substituted.
 874      * @param result where text is appended.
 875      * @param pos keeps track on the position of the first replaced argument
 876      *            in the output string.
<a name="55" id="anc55"></a><span class="line-modified"> 877      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 878      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
 879      *            expected by the format element(s) that use it.
<a name="56" id="anc56"></a><span class="line-modified"> 880      * @exception NullPointerException if {@code result} is {@code null}</span>
 881      */
 882     public final StringBuffer format(Object arguments, StringBuffer result,
 883                                      FieldPosition pos)
 884     {
 885         return subformat((Object[]) arguments, result, pos, null);
 886     }
 887 
 888     /**
 889      * Formats an array of objects and inserts them into the
<a name="57" id="anc57"></a><span class="line-modified"> 890      * &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s pattern, producing an</span>
<span class="line-modified"> 891      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified"> 892      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
 893      * to build the resulting String, as well as to determine information
 894      * about the resulting String.
 895      * &lt;p&gt;
<a name="58" id="anc58"></a><span class="line-modified"> 896      * The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is</span>
 897      * the same that would be returned by
 898      * &lt;blockquote&gt;
 899      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 900      * &lt;/blockquote&gt;
 901      * &lt;p&gt;
<a name="59" id="anc59"></a><span class="line-modified"> 902      * In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at</span>
 903      * least attributes indicating where text was generated from an
<a name="60" id="anc60"></a><span class="line-modified"> 904      * argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of</span>
<span class="line-modified"> 905      * type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are</span>
<span class="line-modified"> 906      * &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt;</span>
 907      * array of the argument from which the text was generated.
 908      * &lt;p&gt;
<a name="61" id="anc61"></a><span class="line-modified"> 909      * The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified"> 910      * instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be</span>
<span class="line-modified"> 911      * placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
 912      * This allows you to not only find where an argument is placed in the
 913      * resulting String, but also which fields it contains in turn.
 914      *
 915      * @param arguments an array of objects to be formatted and substituted.
 916      * @return AttributedCharacterIterator describing the formatted value.
<a name="62" id="anc62"></a><span class="line-modified"> 917      * @exception NullPointerException if &lt;code&gt;arguments&lt;/code&gt; is null.</span>
<span class="line-modified"> 918      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified"> 919      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
 920      *            expected by the format element(s) that use it.
 921      * @since 1.4
 922      */
 923     public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
 924         StringBuffer result = new StringBuffer();
 925         ArrayList&lt;AttributedCharacterIterator&gt; iterators = new ArrayList&lt;&gt;();
 926 
 927         if (arguments == null) {
 928             throw new NullPointerException(
 929                    &quot;formatToCharacterIterator must be passed non-null object&quot;);
 930         }
 931         subformat((Object[]) arguments, result, null, iterators);
 932         if (iterators.size() == 0) {
 933             return createAttributedCharacterIterator(&quot;&quot;);
 934         }
 935         return createAttributedCharacterIterator(
 936                      iterators.toArray(
 937                      new AttributedCharacterIterator[iterators.size()]));
 938     }
 939 
 940     /**
 941      * Parses the string.
 942      *
 943      * &lt;p&gt;Caveats: The parse may fail in a number of circumstances.
 944      * For example:
 945      * &lt;ul&gt;
 946      * &lt;li&gt;If one of the arguments does not occur in the pattern.
 947      * &lt;li&gt;If the format of an argument loses information, such as
 948      *     with a choice format where a large number formats to &quot;many&quot;.
 949      * &lt;li&gt;Does not yet handle recursion (where
 950      *     the substituted strings contain {n} references.)
 951      * &lt;li&gt;Will not always find a match (or the correct match)
 952      *     if some part of the parse is ambiguous.
 953      *     For example, if the pattern &quot;{1},{2}&quot; is used with the
 954      *     string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
 955      *     When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
 956      * &lt;li&gt;If a single argument is parsed more than once in the string,
 957      *     then the later parse wins.
 958      * &lt;/ul&gt;
 959      * When the parse fails, use ParsePosition.getErrorIndex() to find out
 960      * where in the string the parsing failed.  The returned error
 961      * index is the starting offset of the sub-patterns that the string
 962      * is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
 963      * is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
 964      * 0. When an error occurs, the call to this method will return null.
 965      * If the source is null, return an empty array.
 966      *
 967      * @param source the string to parse
 968      * @param pos    the parse position
 969      * @return an array of parsed objects
<a name="63" id="anc63"></a><span class="line-modified"> 970      * @exception NullPointerException if {@code pos} is {@code null}</span>
 971      *            for a non-null {@code source} string.
 972      */
 973     public Object[] parse(String source, ParsePosition pos) {
 974         if (source == null) {
 975             Object[] empty = {};
 976             return empty;
 977         }
 978 
 979         int maximumArgumentNumber = -1;
 980         for (int i = 0; i &lt;= maxOffset; i++) {
 981             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 982                 maximumArgumentNumber = argumentNumbers[i];
 983             }
 984         }
 985         Object[] resultArray = new Object[maximumArgumentNumber + 1];
 986 
 987         int patternOffset = 0;
 988         int sourceOffset = pos.index;
 989         ParsePosition tempStatus = new ParsePosition(0);
 990         for (int i = 0; i &lt;= maxOffset; ++i) {
 991             // match up to format
 992             int len = offsets[i] - patternOffset;
 993             if (len == 0 || pattern.regionMatches(patternOffset,
 994                                                   source, sourceOffset, len)) {
 995                 sourceOffset += len;
 996                 patternOffset += len;
 997             } else {
 998                 pos.errorIndex = sourceOffset;
 999                 return null; // leave index as is to signal error
1000             }
1001 
1002             // now use format
1003             if (formats[i] == null) {   // string format
1004                 // if at end, use longest possible match
1005                 // otherwise uses first match to intervening string
1006                 // does NOT recursively try all possibilities
1007                 int tempLength = (i != maxOffset) ? offsets[i+1] : pattern.length();
1008 
1009                 int next;
1010                 if (patternOffset &gt;= tempLength) {
1011                     next = source.length();
1012                 }else{
1013                     next = source.indexOf(pattern.substring(patternOffset, tempLength),
1014                                           sourceOffset);
1015                 }
1016 
1017                 if (next &lt; 0) {
1018                     pos.errorIndex = sourceOffset;
1019                     return null; // leave index as is to signal error
1020                 } else {
1021                     String strValue= source.substring(sourceOffset,next);
1022                     if (!strValue.equals(&quot;{&quot;+argumentNumbers[i]+&quot;}&quot;))
1023                         resultArray[argumentNumbers[i]]
1024                             = source.substring(sourceOffset,next);
1025                     sourceOffset = next;
1026                 }
1027             } else {
1028                 tempStatus.index = sourceOffset;
1029                 resultArray[argumentNumbers[i]]
1030                     = formats[i].parseObject(source,tempStatus);
1031                 if (tempStatus.index == sourceOffset) {
1032                     pos.errorIndex = sourceOffset;
1033                     return null; // leave index as is to signal error
1034                 }
1035                 sourceOffset = tempStatus.index; // update
1036             }
1037         }
1038         int len = pattern.length() - patternOffset;
1039         if (len == 0 || pattern.regionMatches(patternOffset,
1040                                               source, sourceOffset, len)) {
1041             pos.index = sourceOffset + len;
1042         } else {
1043             pos.errorIndex = sourceOffset;
1044             return null; // leave index as is to signal error
1045         }
1046         return resultArray;
1047     }
1048 
1049     /**
1050      * Parses text from the beginning of the given string to produce an object
1051      * array.
1052      * The method may not use the entire text of the given string.
1053      * &lt;p&gt;
1054      * See the {@link #parse(String, ParsePosition)} method for more information
1055      * on message parsing.
1056      *
<a name="64" id="anc64"></a><span class="line-modified">1057      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">1058      * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.</span>
<span class="line-modified">1059      * @exception ParseException if the beginning of the specified string</span>
1060      *            cannot be parsed.
1061      */
1062     public Object[] parse(String source) throws ParseException {
1063         ParsePosition pos  = new ParsePosition(0);
1064         Object[] result = parse(source, pos);
1065         if (pos.index == 0)  // unchanged, returned object is null
1066             throw new ParseException(&quot;MessageFormat parse error!&quot;, pos.errorIndex);
1067 
1068         return result;
1069     }
1070 
1071     /**
1072      * Parses text from a string to produce an object array.
1073      * &lt;p&gt;
1074      * The method attempts to parse text starting at the index given by
<a name="65" id="anc65"></a><span class="line-modified">1075      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">1076      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
1077      * to the index after the last character used (parsing does not necessarily
1078      * use all characters up to the end of the string), and the parsed
<a name="66" id="anc66"></a><span class="line-modified">1079      * object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
1080      * indicate the starting point for the next call to this method.
<a name="67" id="anc67"></a><span class="line-modified">1081      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">1082      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
1083      * the character where the error occurred, and null is returned.
1084      * &lt;p&gt;
1085      * See the {@link #parse(String, ParsePosition)} method for more information
1086      * on message parsing.
1087      *
<a name="68" id="anc68"></a><span class="line-modified">1088      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">1089      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
1090      *            index information as described above.
<a name="69" id="anc69"></a><span class="line-modified">1091      * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of</span>
1092      *         error, returns null.
1093      * @throws NullPointerException if {@code pos} is null.
1094      */
1095     public Object parseObject(String source, ParsePosition pos) {
1096         return parse(source, pos);
1097     }
1098 
1099     /**
1100      * Creates and returns a copy of this object.
1101      *
1102      * @return a clone of this instance.
1103      */
1104     public Object clone() {
1105         MessageFormat other = (MessageFormat) super.clone();
1106 
1107         // clone arrays. Can&#39;t do with utility because of bug in Cloneable
1108         other.formats = formats.clone(); // shallow clone
1109         for (int i = 0; i &lt; formats.length; ++i) {
1110             if (formats[i] != null)
1111                 other.formats[i] = (Format)formats[i].clone();
1112         }
1113         // for primitives or immutables, shallow clone is enough
1114         other.offsets = offsets.clone();
1115         other.argumentNumbers = argumentNumbers.clone();
1116 
1117         return other;
1118     }
1119 
1120     /**
1121      * Equality comparison between two message format objects
1122      */
1123     public boolean equals(Object obj) {
1124         if (this == obj)                      // quick check
1125             return true;
1126         if (obj == null || getClass() != obj.getClass())
1127             return false;
1128         MessageFormat other = (MessageFormat) obj;
1129         return (maxOffset == other.maxOffset
1130                 &amp;&amp; pattern.equals(other.pattern)
1131                 &amp;&amp; ((locale != null &amp;&amp; locale.equals(other.locale))
1132                  || (locale == null &amp;&amp; other.locale == null))
1133                 &amp;&amp; Arrays.equals(offsets,other.offsets)
1134                 &amp;&amp; Arrays.equals(argumentNumbers,other.argumentNumbers)
1135                 &amp;&amp; Arrays.equals(formats,other.formats));
1136     }
1137 
1138     /**
1139      * Generates a hash code for the message format object.
1140      */
1141     public int hashCode() {
1142         return pattern.hashCode(); // enough for reasonable distribution
1143     }
1144 
1145 
1146     /**
1147      * Defines constants that are used as attribute keys in the
<a name="70" id="anc70"></a><span class="line-modified">1148      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">1149      * from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.</span>
1150      *
1151      * @since 1.4
1152      */
1153     public static class Field extends Format.Field {
1154 
1155         // Proclaim serial compatibility with 1.4 FCS
<a name="71" id="anc71"></a>
1156         private static final long serialVersionUID = 7899943957617360810L;
1157 
1158         /**
1159          * Creates a Field with the specified name.
1160          *
1161          * @param name Name of the attribute
1162          */
1163         protected Field(String name) {
1164             super(name);
1165         }
1166 
1167         /**
1168          * Resolves instances being deserialized to the predefined constants.
1169          *
1170          * @throws InvalidObjectException if the constant could not be
1171          *         resolved.
1172          * @return resolved MessageFormat.Field constant
1173          */
<a name="72" id="anc72"></a>
1174         protected Object readResolve() throws InvalidObjectException {
1175             if (this.getClass() != MessageFormat.Field.class) {
1176                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1177             }
1178 
1179             return ARGUMENT;
1180         }
1181 
1182         //
1183         // The constants
1184         //
1185 
1186         /**
1187          * Constant identifying a portion of a message that was generated
<a name="73" id="anc73"></a><span class="line-modified">1188          * from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">1189          * The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;</span>
<span class="line-modified">1190          * indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the</span>
1191          * argument from which the text was generated.
1192          */
1193         public static final Field ARGUMENT =
1194                            new Field(&quot;message argument field&quot;);
1195     }
1196 
1197     // ===========================privates============================
1198 
1199     /**
1200      * The locale to use for formatting numbers and dates.
1201      * @serial
1202      */
1203     private Locale locale;
1204 
1205     /**
1206      * The string that the formatted values are to be plugged into.  In other words, this
1207      * is the pattern supplied on construction with all of the {} expressions taken out.
1208      * @serial
1209      */
1210     private String pattern = &quot;&quot;;
1211 
1212     /** The initially expected number of subformats in the format */
1213     private static final int INITIAL_FORMATS = 10;
1214 
1215     /**
1216      * An array of formatters, which are used to format the arguments.
1217      * @serial
1218      */
1219     private Format[] formats = new Format[INITIAL_FORMATS];
1220 
1221     /**
1222      * The positions where the results of formatting each argument are to be inserted
1223      * into the pattern.
1224      * @serial
1225      */
1226     private int[] offsets = new int[INITIAL_FORMATS];
1227 
1228     /**
1229      * The argument numbers corresponding to each formatter.  (The formatters are stored
1230      * in the order they occur in the pattern, not in the order in which the arguments
1231      * are specified.)
1232      * @serial
1233      */
1234     private int[] argumentNumbers = new int[INITIAL_FORMATS];
1235 
1236     /**
<a name="74" id="anc74"></a><span class="line-modified">1237      * One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;.  Can also be thought of</span>
<span class="line-modified">1238      * as the index of the highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used.</span>
<span class="line-modified">1239      * All of these arrays should have the same number of elements being used as &lt;code&gt;offsets&lt;/code&gt;</span>
1240      * does, and so this variable suffices to tell us how many entries are in all of them.
1241      * @serial
1242      */
1243     private int maxOffset = -1;
1244 
1245     /**
1246      * Internal routine used by format. If {@code characterIterators} is
1247      * {@code non-null}, AttributedCharacterIterator will be created from the
1248      * subformats as necessary. If {@code characterIterators} is {@code null}
1249      * and {@code fp} is {@code non-null} and identifies
1250      * {@code Field.ARGUMENT} as the field attribute, the location of
1251      * the first replaced argument will be set in it.
1252      *
<a name="75" id="anc75"></a><span class="line-modified">1253      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified">1254      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
1255      *            expected by the format element(s) that use it.
1256      */
1257     private StringBuffer subformat(Object[] arguments, StringBuffer result,
1258                                    FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
1259         // note: this implementation assumes a fast substring &amp; index.
1260         // if this is not true, would be better to append chars one by one.
1261         int lastOffset = 0;
1262         int last = result.length();
1263         for (int i = 0; i &lt;= maxOffset; ++i) {
1264             result.append(pattern, lastOffset, offsets[i]);
1265             lastOffset = offsets[i];
1266             int argumentNumber = argumentNumbers[i];
1267             if (arguments == null || argumentNumber &gt;= arguments.length) {
1268                 result.append(&#39;{&#39;).append(argumentNumber).append(&#39;}&#39;);
1269                 continue;
1270             }
1271             // int argRecursion = ((recursionProtection &gt;&gt; (argumentNumber*2)) &amp; 0x3);
1272             if (false) { // if (argRecursion == 3){
1273                 // prevent loop!!!
1274                 result.append(&#39;\uFFFD&#39;);
1275             } else {
1276                 Object obj = arguments[argumentNumber];
1277                 String arg = null;
1278                 Format subFormatter = null;
1279                 if (obj == null) {
1280                     arg = &quot;null&quot;;
1281                 } else if (formats[i] != null) {
1282                     subFormatter = formats[i];
1283                     if (subFormatter instanceof ChoiceFormat) {
1284                         arg = formats[i].format(obj);
1285                         if (arg.indexOf(&#39;{&#39;) &gt;= 0) {
1286                             subFormatter = new MessageFormat(arg, locale);
1287                             obj = arguments;
1288                             arg = null;
1289                         }
1290                     }
1291                 } else if (obj instanceof Number) {
1292                     // format number if can
1293                     subFormatter = NumberFormat.getInstance(locale);
1294                 } else if (obj instanceof Date) {
1295                     // format a Date if can
1296                     subFormatter = DateFormat.getDateTimeInstance(
1297                              DateFormat.SHORT, DateFormat.SHORT, locale);//fix
1298                 } else if (obj instanceof String) {
1299                     arg = (String) obj;
1300 
1301                 } else {
1302                     arg = obj.toString();
1303                     if (arg == null) arg = &quot;null&quot;;
1304                 }
1305 
1306                 // At this point we are in two states, either subFormatter
1307                 // is non-null indicating we should format obj using it,
1308                 // or arg is non-null and we should use it as the value.
1309 
1310                 if (characterIterators != null) {
1311                     // If characterIterators is non-null, it indicates we need
1312                     // to get the CharacterIterator from the child formatter.
1313                     if (last != result.length()) {
1314                         characterIterators.add(
1315                             createAttributedCharacterIterator(result.substring
1316                                                               (last)));
1317                         last = result.length();
1318                     }
1319                     if (subFormatter != null) {
1320                         AttributedCharacterIterator subIterator =
1321                                    subFormatter.formatToCharacterIterator(obj);
1322 
1323                         append(result, subIterator);
1324                         if (last != result.length()) {
1325                             characterIterators.add(
1326                                          createAttributedCharacterIterator(
1327                                          subIterator, Field.ARGUMENT,
1328                                          Integer.valueOf(argumentNumber)));
1329                             last = result.length();
1330                         }
1331                         arg = null;
1332                     }
1333                     if (arg != null &amp;&amp; !arg.isEmpty()) {
1334                         result.append(arg);
1335                         characterIterators.add(
1336                                  createAttributedCharacterIterator(
1337                                  arg, Field.ARGUMENT,
1338                                  Integer.valueOf(argumentNumber)));
1339                         last = result.length();
1340                     }
1341                 }
1342                 else {
1343                     if (subFormatter != null) {
1344                         arg = subFormatter.format(obj);
1345                     }
1346                     last = result.length();
1347                     result.append(arg);
1348                     if (i == 0 &amp;&amp; fp != null &amp;&amp; Field.ARGUMENT.equals(
1349                                   fp.getFieldAttribute())) {
1350                         fp.setBeginIndex(last);
1351                         fp.setEndIndex(result.length());
1352                     }
1353                     last = result.length();
1354                 }
1355             }
1356         }
1357         result.append(pattern, lastOffset, pattern.length());
1358         if (characterIterators != null &amp;&amp; last != result.length()) {
1359             characterIterators.add(createAttributedCharacterIterator(
1360                                    result.substring(last)));
1361         }
1362         return result;
1363     }
1364 
1365     /**
1366      * Convenience method to append all the characters in
<a name="76" id="anc76"></a><span class="line-modified">1367      * &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.</span>
1368      */
1369     private void append(StringBuffer result, CharacterIterator iterator) {
1370         if (iterator.first() != CharacterIterator.DONE) {
1371             char aChar;
1372 
1373             result.append(iterator.first());
1374             while ((aChar = iterator.next()) != CharacterIterator.DONE) {
1375                 result.append(aChar);
1376             }
1377         }
1378     }
1379 
1380     // Indices for segments
1381     private static final int SEG_RAW      = 0;
1382     private static final int SEG_INDEX    = 1;
1383     private static final int SEG_TYPE     = 2;
1384     private static final int SEG_MODIFIER = 3; // modifier or subformat
1385 
1386     // Indices for type keywords
1387     private static final int TYPE_NULL    = 0;
1388     private static final int TYPE_NUMBER  = 1;
1389     private static final int TYPE_DATE    = 2;
1390     private static final int TYPE_TIME    = 3;
1391     private static final int TYPE_CHOICE  = 4;
1392 
1393     private static final String[] TYPE_KEYWORDS = {
1394         &quot;&quot;,
1395         &quot;number&quot;,
1396         &quot;date&quot;,
1397         &quot;time&quot;,
1398         &quot;choice&quot;
1399     };
1400 
1401     // Indices for number modifiers
1402     private static final int MODIFIER_DEFAULT  = 0; // common in number and date-time
1403     private static final int MODIFIER_CURRENCY = 1;
1404     private static final int MODIFIER_PERCENT  = 2;
1405     private static final int MODIFIER_INTEGER  = 3;
1406 
1407     private static final String[] NUMBER_MODIFIER_KEYWORDS = {
1408         &quot;&quot;,
1409         &quot;currency&quot;,
1410         &quot;percent&quot;,
1411         &quot;integer&quot;
1412     };
1413 
1414     // Indices for date-time modifiers
1415     private static final int MODIFIER_SHORT   = 1;
1416     private static final int MODIFIER_MEDIUM  = 2;
1417     private static final int MODIFIER_LONG    = 3;
1418     private static final int MODIFIER_FULL    = 4;
1419 
1420     private static final String[] DATE_TIME_MODIFIER_KEYWORDS = {
1421         &quot;&quot;,
1422         &quot;short&quot;,
1423         &quot;medium&quot;,
1424         &quot;long&quot;,
1425         &quot;full&quot;
1426     };
1427 
1428     // Date-time style values corresponding to the date-time modifiers.
1429     private static final int[] DATE_TIME_MODIFIERS = {
1430         DateFormat.DEFAULT,
1431         DateFormat.SHORT,
1432         DateFormat.MEDIUM,
1433         DateFormat.LONG,
1434         DateFormat.FULL,
1435     };
1436 
1437     private void makeFormat(int position, int offsetNumber,
1438                             StringBuilder[] textSegments)
1439     {
1440         String[] segments = new String[textSegments.length];
1441         for (int i = 0; i &lt; textSegments.length; i++) {
1442             StringBuilder oneseg = textSegments[i];
1443             segments[i] = (oneseg != null) ? oneseg.toString() : &quot;&quot;;
1444         }
1445 
1446         // get the argument number
1447         int argumentNumber;
1448         try {
1449             argumentNumber = Integer.parseInt(segments[SEG_INDEX]); // always unlocalized!
1450         } catch (NumberFormatException e) {
1451             throw new IllegalArgumentException(&quot;can&#39;t parse argument number: &quot;
1452                                                + segments[SEG_INDEX], e);
1453         }
1454         if (argumentNumber &lt; 0) {
1455             throw new IllegalArgumentException(&quot;negative argument number: &quot;
1456                                                + argumentNumber);
1457         }
1458 
1459         // resize format information arrays if necessary
1460         if (offsetNumber &gt;= formats.length) {
1461             int newLength = formats.length * 2;
1462             Format[] newFormats = new Format[newLength];
1463             int[] newOffsets = new int[newLength];
1464             int[] newArgumentNumbers = new int[newLength];
1465             System.arraycopy(formats, 0, newFormats, 0, maxOffset + 1);
1466             System.arraycopy(offsets, 0, newOffsets, 0, maxOffset + 1);
1467             System.arraycopy(argumentNumbers, 0, newArgumentNumbers, 0, maxOffset + 1);
1468             formats = newFormats;
1469             offsets = newOffsets;
1470             argumentNumbers = newArgumentNumbers;
1471         }
1472         int oldMaxOffset = maxOffset;
1473         maxOffset = offsetNumber;
1474         offsets[offsetNumber] = segments[SEG_RAW].length();
1475         argumentNumbers[offsetNumber] = argumentNumber;
1476 
1477         // now get the format
1478         Format newFormat = null;
1479         if (!segments[SEG_TYPE].isEmpty()) {
1480             int type = findKeyword(segments[SEG_TYPE], TYPE_KEYWORDS);
1481             switch (type) {
1482             case TYPE_NULL:
1483                 // Type &quot;&quot; is allowed. e.g., &quot;{0,}&quot;, &quot;{0,,}&quot;, and &quot;{0,,#}&quot;
1484                 // are treated as &quot;{0}&quot;.
1485                 break;
1486 
1487             case TYPE_NUMBER:
1488                 switch (findKeyword(segments[SEG_MODIFIER], NUMBER_MODIFIER_KEYWORDS)) {
1489                 case MODIFIER_DEFAULT:
1490                     newFormat = NumberFormat.getInstance(locale);
1491                     break;
1492                 case MODIFIER_CURRENCY:
1493                     newFormat = NumberFormat.getCurrencyInstance(locale);
1494                     break;
1495                 case MODIFIER_PERCENT:
1496                     newFormat = NumberFormat.getPercentInstance(locale);
1497                     break;
1498                 case MODIFIER_INTEGER:
1499                     newFormat = NumberFormat.getIntegerInstance(locale);
1500                     break;
1501                 default: // DecimalFormat pattern
1502                     try {
1503                         newFormat = new DecimalFormat(segments[SEG_MODIFIER],
1504                                                       DecimalFormatSymbols.getInstance(locale));
1505                     } catch (IllegalArgumentException e) {
1506                         maxOffset = oldMaxOffset;
1507                         throw e;
1508                     }
1509                     break;
1510                 }
1511                 break;
1512 
1513             case TYPE_DATE:
1514             case TYPE_TIME:
1515                 int mod = findKeyword(segments[SEG_MODIFIER], DATE_TIME_MODIFIER_KEYWORDS);
1516                 if (mod &gt;= 0 &amp;&amp; mod &lt; DATE_TIME_MODIFIER_KEYWORDS.length) {
1517                     if (type == TYPE_DATE) {
1518                         newFormat = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[mod],
1519                                                                locale);
1520                     } else {
1521                         newFormat = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[mod],
1522                                                                locale);
1523                     }
1524                 } else {
1525                     // SimpleDateFormat pattern
1526                     try {
1527                         newFormat = new SimpleDateFormat(segments[SEG_MODIFIER], locale);
1528                     } catch (IllegalArgumentException e) {
1529                         maxOffset = oldMaxOffset;
1530                         throw e;
1531                     }
1532                 }
1533                 break;
1534 
1535             case TYPE_CHOICE:
1536                 try {
1537                     // ChoiceFormat pattern
1538                     newFormat = new ChoiceFormat(segments[SEG_MODIFIER]);
1539                 } catch (Exception e) {
1540                     maxOffset = oldMaxOffset;
1541                     throw new IllegalArgumentException(&quot;Choice Pattern incorrect: &quot;
1542                                                        + segments[SEG_MODIFIER], e);
1543                 }
1544                 break;
1545 
1546             default:
1547                 maxOffset = oldMaxOffset;
1548                 throw new IllegalArgumentException(&quot;unknown format type: &quot; +
1549                                                    segments[SEG_TYPE]);
1550             }
1551         }
1552         formats[offsetNumber] = newFormat;
1553     }
1554 
1555     private static final int findKeyword(String s, String[] list) {
1556         for (int i = 0; i &lt; list.length; ++i) {
1557             if (s.equals(list[i]))
1558                 return i;
1559         }
1560 
1561         // Try trimmed lowercase.
1562         String ls = s.trim().toLowerCase(Locale.ROOT);
1563         if (ls != s) {
1564             for (int i = 0; i &lt; list.length; ++i) {
1565                 if (ls.equals(list[i]))
1566                     return i;
1567             }
1568         }
1569         return -1;
1570     }
1571 
1572     private static final void copyAndFixQuotes(String source, int start, int end,
1573                                                StringBuilder target) {
1574         boolean quoted = false;
1575 
1576         for (int i = start; i &lt; end; ++i) {
1577             char ch = source.charAt(i);
1578             if (ch == &#39;{&#39;) {
1579                 if (!quoted) {
1580                     target.append(&#39;\&#39;&#39;);
1581                     quoted = true;
1582                 }
1583                 target.append(ch);
1584             } else if (ch == &#39;\&#39;&#39;) {
1585                 target.append(&quot;&#39;&#39;&quot;);
1586             } else {
1587                 if (quoted) {
1588                     target.append(&#39;\&#39;&#39;);
1589                     quoted = false;
1590                 }
1591                 target.append(ch);
1592             }
1593         }
1594         if (quoted) {
1595             target.append(&#39;\&#39;&#39;);
1596         }
1597     }
1598 
1599     /**
1600      * After reading an object from the input stream, do a simple verification
1601      * to maintain class invariants.
1602      * @throws InvalidObjectException if the objects read from the stream is invalid.
1603      */
<a name="77" id="anc77"></a>
1604     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1605         in.defaultReadObject();
1606         boolean isValid = maxOffset &gt;= -1
1607                 &amp;&amp; formats.length &gt; maxOffset
1608                 &amp;&amp; offsets.length &gt; maxOffset
1609                 &amp;&amp; argumentNumbers.length &gt; maxOffset;
1610         if (isValid) {
1611             int lastOffset = pattern.length() + 1;
1612             for (int i = maxOffset; i &gt;= 0; --i) {
1613                 if ((offsets[i] &lt; 0) || (offsets[i] &gt; lastOffset)) {
1614                     isValid = false;
1615                     break;
1616                 } else {
1617                     lastOffset = offsets[i];
1618                 }
1619             }
1620         }
1621         if (!isValid) {
1622             throw new InvalidObjectException(&quot;Could not reconstruct MessageFormat from corrupt stream.&quot;);
1623         }
1624     }
1625 }
<a name="78" id="anc78"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="78" type="hidden" />
</body>
</html>
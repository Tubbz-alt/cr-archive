<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractPlainDatagramSocketImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BindException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,27 ***</span>
  import java.io.FileDescriptor;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
  
  import java.util.Collections;
  import java.util.HashSet;
  import java.util.Set;
  
  import sun.net.ConnectionResetException;
  import sun.net.NetHooks;
  import sun.net.ResourceManager;
  import sun.net.util.SocketExceptions;
  
  /**
   * Default Socket Implementation. This implementation does
   * not implement any security checks.
   * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.
   *
   * @author  Steven B. Byrne
   */
<span class="line-modified">! abstract class AbstractPlainSocketImpl extends SocketImpl {</span>
      /* instance variable for SO_TIMEOUT */
      int timeout;   // timeout in millisec
      // traffic class
      private int trafficClass;
  
<span class="line-new-header">--- 28,34 ---</span>
  import java.io.FileDescriptor;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
  
<span class="line-added">+ import java.security.AccessController;</span>
<span class="line-added">+ import java.security.PrivilegedActionException;</span>
<span class="line-added">+ import java.security.PrivilegedExceptionAction;</span>
  import java.util.Collections;
  import java.util.HashSet;
<span class="line-added">+ import java.util.Objects;</span>
  import java.util.Set;
  
  import sun.net.ConnectionResetException;
  import sun.net.NetHooks;
<span class="line-added">+ import sun.net.PlatformSocketImpl;</span>
  import sun.net.ResourceManager;
<span class="line-added">+ import sun.net.ext.ExtendedSocketOptions;</span>
<span class="line-added">+ import sun.net.util.IPAddressUtil;</span>
  import sun.net.util.SocketExceptions;
  
  /**
   * Default Socket Implementation. This implementation does
   * not implement any security checks.
   * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.
   *
   * @author  Steven B. Byrne
   */
<span class="line-modified">! abstract class AbstractPlainSocketImpl extends SocketImpl implements PlatformSocketImpl {</span>
      /* instance variable for SO_TIMEOUT */
      int timeout;   // timeout in millisec
      // traffic class
      private int trafficClass;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,25 ***</span>
      protected boolean closePending = false;
  
      /* indicates connection reset state */
      private volatile boolean connectionReset;
  
     /* whether this Socket is a stream (TCP) socket or not (UDP)
      */
      protected boolean stream;
  
      /**
       * Load net library into runtime.
       */
      static {
<span class="line-modified">!         java.security.AccessController.doPrivileged(</span>
<span class="line-removed">-             new java.security.PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed">-                 public Void run() {</span>
<span class="line-removed">-                     System.loadLibrary(&quot;net&quot;);</span>
<span class="line-removed">-                     return null;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             });</span>
      }
  
      private static volatile boolean checkedReusePort;
      private static volatile boolean isReusePortAvailable;
  
<span class="line-new-header">--- 75,28 ---</span>
      protected boolean closePending = false;
  
      /* indicates connection reset state */
      private volatile boolean connectionReset;
  
<span class="line-added">+     /* indicates whether impl is bound  */</span>
<span class="line-added">+     boolean isBound;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* indicates whether impl is connected  */</span>
<span class="line-added">+     volatile boolean isConnected;</span>
<span class="line-added">+ </span>
     /* whether this Socket is a stream (TCP) socket or not (UDP)
      */
      protected boolean stream;
  
<span class="line-added">+     /* whether this is a server or not */</span>
<span class="line-added">+     final boolean isServer;</span>
<span class="line-added">+ </span>
      /**
       * Load net library into runtime.
       */
      static {
<span class="line-modified">!         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>
      }
  
      private static volatile boolean checkedReusePort;
      private static volatile boolean isReusePortAvailable;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,28 ***</span>
              checkedReusePort = true;
          }
          return isReusePortAvailable;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns a set of SocketOptions supported by this impl and by this impl&#39;s</span>
<span class="line-removed">-      * socket (Socket or ServerSocket)</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return a Set of SocketOptions</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-removed">-         Set&lt;SocketOption&lt;?&gt;&gt; options;</span>
<span class="line-removed">-         if (isReusePortAvailable()) {</span>
<span class="line-removed">-             options = new HashSet&lt;&gt;();</span>
<span class="line-removed">-             options.addAll(super.supportedOptions());</span>
<span class="line-removed">-             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-removed">-             options = Collections.unmodifiableSet(options);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             options = super.supportedOptions();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return options;</span>
      }
  
      /**
       * Creates a socket with a boolean that specifies whether this
       * is a stream socket (true) or an unconnected UDP socket (false).
<span class="line-new-header">--- 109,12 ---</span>
              checkedReusePort = true;
          }
          return isReusePortAvailable;
      }
  
<span class="line-modified">!     AbstractPlainSocketImpl(boolean isServer) {</span>
<span class="line-modified">!         this.isServer = isServer;</span>
      }
  
      /**
       * Creates a socket with a boolean that specifies whether this
       * is a stream socket (true) or an unconnected UDP socket (false).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,25 ***</span>
              ResourceManager.beforeUdpCreate();
              // only create the fd after we know we will be able to create the socket
              fd = new FileDescriptor();
              try {
                  socketCreate(false);
<span class="line-modified">!                 SocketCleanable.register(fd);</span>
              } catch (IOException ioe) {
                  ResourceManager.afterUdpClose();
                  fd = null;
                  throw ioe;
              }
          } else {
              fd = new FileDescriptor();
              socketCreate(true);
<span class="line-modified">!             SocketCleanable.register(fd);</span>
          }
<span class="line-removed">-         if (socket != null)</span>
<span class="line-removed">-             socket.setCreated();</span>
<span class="line-removed">-         if (serverSocket != null)</span>
<span class="line-removed">-             serverSocket.setCreated();</span>
      }
  
      /**
       * Creates a socket and connects it to the specified port on
       * the specified host.
<span class="line-new-header">--- 125,21 ---</span>
              ResourceManager.beforeUdpCreate();
              // only create the fd after we know we will be able to create the socket
              fd = new FileDescriptor();
              try {
                  socketCreate(false);
<span class="line-modified">!                 SocketCleanable.register(fd, false);</span>
              } catch (IOException ioe) {
                  ResourceManager.afterUdpClose();
                  fd = null;
                  throw ioe;
              }
          } else {
              fd = new FileDescriptor();
              socketCreate(true);
<span class="line-modified">!             SocketCleanable.register(fd, true);</span>
          }
      }
  
      /**
       * Creates a socket and connects it to the specified port on
       * the specified host.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,12 ***</span>
          throws UnknownHostException, IOException
      {
          boolean connected = false;
          try {
              InetAddress address = InetAddress.getByName(host);
<span class="line-modified">!             this.port = port;</span>
              this.address = address;
  
              connectToAddress(address, port, timeout);
              connected = true;
          } finally {
              if (!connected) {
<span class="line-new-header">--- 150,16 ---</span>
          throws UnknownHostException, IOException
      {
          boolean connected = false;
          try {
              InetAddress address = InetAddress.getByName(host);
<span class="line-modified">!             // recording this.address as supplied by caller before calling connect</span>
              this.address = address;
<span class="line-added">+             this.port = port;</span>
<span class="line-added">+             if (address.isLinkLocalAddress()) {</span>
<span class="line-added">+                 address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">+             }</span>
  
              connectToAddress(address, port, timeout);
              connected = true;
          } finally {
              if (!connected) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,25 ***</span>
                  } catch (IOException ioe) {
                      /* Do nothing. If connect threw an exception then
                         it will be passed up the call stack */
                  }
              }
          }
      }
  
      /**
       * Creates a socket and connects it to the specified address on
       * the specified port.
       * @param address the address
       * @param port the specified port
       */
      protected void connect(InetAddress address, int port) throws IOException {
<span class="line-modified">!         this.port = port;</span>
          this.address = address;
  
          try {
              connectToAddress(address, port, timeout);
              return;
          } catch (IOException e) {
              // everything failed
              close();
              throw e;
<span class="line-new-header">--- 168,31 ---</span>
                  } catch (IOException ioe) {
                      /* Do nothing. If connect threw an exception then
                         it will be passed up the call stack */
                  }
              }
<span class="line-added">+             isConnected = connected;</span>
          }
      }
  
      /**
       * Creates a socket and connects it to the specified address on
       * the specified port.
       * @param address the address
       * @param port the specified port
       */
      protected void connect(InetAddress address, int port) throws IOException {
<span class="line-modified">!         // recording this.address as supplied by caller before calling connect</span>
          this.address = address;
<span class="line-added">+         this.port = port;</span>
<span class="line-added">+         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">+             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">+         }</span>
  
          try {
              connectToAddress(address, port, timeout);
<span class="line-added">+             isConnected = true;</span>
              return;
          } catch (IOException e) {
              // everything failed
              close();
              throw e;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,24 ***</span>
              if (address == null || !(address instanceof InetSocketAddress))
                  throw new IllegalArgumentException(&quot;unsupported address type&quot;);
              InetSocketAddress addr = (InetSocketAddress) address;
              if (addr.isUnresolved())
                  throw new UnknownHostException(addr.getHostName());
              this.port = addr.getPort();
<span class="line-modified">!             this.address = addr.getAddress();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             connectToAddress(this.address, port, timeout);</span>
              connected = true;
          } finally {
              if (!connected) {
                  try {
                      close();
                  } catch (IOException ioe) {
                      /* Do nothing. If connect threw an exception then
                         it will be passed up the call stack */
                  }
              }
          }
      }
  
      private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
          if (address.isAnyLocalAddress()) {
<span class="line-new-header">--- 216,29 ---</span>
              if (address == null || !(address instanceof InetSocketAddress))
                  throw new IllegalArgumentException(&quot;unsupported address type&quot;);
              InetSocketAddress addr = (InetSocketAddress) address;
              if (addr.isUnresolved())
                  throw new UnknownHostException(addr.getHostName());
<span class="line-added">+             // recording this.address as supplied by caller before calling connect</span>
<span class="line-added">+             InetAddress ia = addr.getAddress();</span>
<span class="line-added">+             this.address = ia;</span>
              this.port = addr.getPort();
<span class="line-modified">!             if (ia.isLinkLocalAddress()) {</span>
<span class="line-modified">!                 ia = IPAddressUtil.toScopedAddress(ia);</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             connectToAddress(ia, port, timeout);</span>
              connected = true;
          } finally {
              if (!connected) {
                  try {
                      close();
                  } catch (IOException ioe) {
                      /* Do nothing. If connect threw an exception then
                         it will be passed up the call stack */
                  }
              }
<span class="line-added">+             isConnected = connected;</span>
          }
      }
  
      private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
          if (address.isAnyLocalAddress()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,19 ***</span>
          default:
              return null;
          }
      }
  
      /**
       * The workhorse of the connection operation.  Tries several times to
       * establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
       * throws an IOException indicating what went wrong.
       */
  
      synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
          synchronized (fdLock) {
<span class="line-modified">!             if (!closePending &amp;&amp; (socket == null || !socket.isBound())) {</span>
                  NetHooks.beforeTcpConnect(fd, address, port);
              }
          }
          try {
              acquireFD();
<span class="line-new-header">--- 384,142 ---</span>
          default:
              return null;
          }
      }
  
<span class="line-added">+     static final ExtendedSocketOptions extendedOptions =</span>
<span class="line-added">+             ExtendedSocketOptions.getInstance();</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions = clientSocketOptions();</span>
<span class="line-added">+     private static final Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions = serverSocketOptions();</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions() {</span>
<span class="line-added">+         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_KEEPALIVE);</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_SNDBUF);</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_LINGER);</span>
<span class="line-added">+         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">+         options.add(StandardSocketOptions.TCP_NODELAY);</span>
<span class="line-added">+         if (isReusePortAvailable())</span>
<span class="line-added">+             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">+         options.addAll(ExtendedSocketOptions.clientSocketOptions());</span>
<span class="line-added">+         return Collections.unmodifiableSet(options);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions() {</span>
<span class="line-added">+         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">+         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">+         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">+         if (isReusePortAvailable())</span>
<span class="line-added">+             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">+         options.addAll(ExtendedSocketOptions.serverSocketOptions());</span>
<span class="line-added">+         return Collections.unmodifiableSet(options);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">+         if (isServer)</span>
<span class="line-added">+             return serverSocketOptions;</span>
<span class="line-added">+         else</span>
<span class="line-added">+             return clientSocketOptions;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">+         Objects.requireNonNull(name);</span>
<span class="line-added">+         if (!supportedOptions().contains(name))</span>
<span class="line-added">+             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!name.type().isInstance(value))</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (isClosedOrPending())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (name == StandardSocketOptions.SO_KEEPALIVE) {</span>
<span class="line-added">+             setOption(SocketOptions.SO_KEEPALIVE, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">+             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Invalid send buffer size:&quot; + value);</span>
<span class="line-added">+             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">+             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Invalid recv buffer size:&quot; + value);</span>
<span class="line-added">+             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">+             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">+             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_LINGER ) {</span>
<span class="line-added">+             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">+                 setOption(SocketOptions.SO_LINGER, false);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 setOption(SocketOptions.SO_LINGER, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">+             int i = ((Integer)value).intValue();</span>
<span class="line-added">+             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Invalid IP_TOS value: &quot; + value);</span>
<span class="line-added">+             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.TCP_NODELAY) {</span>
<span class="line-added">+             setOption(SocketOptions.TCP_NODELAY, value);</span>
<span class="line-added">+         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">+             extendedOptions.setOption(fd, name, value);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">+         Objects.requireNonNull(name);</span>
<span class="line-added">+         if (!supportedOptions().contains(name))</span>
<span class="line-added">+             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (isClosedOrPending())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (name == StandardSocketOptions.SO_KEEPALIVE) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.SO_KEEPALIVE);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.SO_LINGER) {</span>
<span class="line-added">+             Object value = getOption(SocketOptions.SO_LINGER);</span>
<span class="line-added">+             if (value instanceof Boolean) {</span>
<span class="line-added">+                 assert ((Boolean)value).booleanValue() == false;</span>
<span class="line-added">+                 value = -1;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return (T)value;</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.IP_TOS);</span>
<span class="line-added">+         } else if (name == StandardSocketOptions.TCP_NODELAY) {</span>
<span class="line-added">+             return (T)getOption(SocketOptions.TCP_NODELAY);</span>
<span class="line-added">+         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">+             return (T) extendedOptions.getOption(fd, name);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * The workhorse of the connection operation.  Tries several times to
       * establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
       * throws an IOException indicating what went wrong.
       */
  
      synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
          synchronized (fdLock) {
<span class="line-modified">!             if (!closePending &amp;&amp; !isBound) {</span>
                  NetHooks.beforeTcpConnect(fd, address, port);
              }
          }
          try {
              acquireFD();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 401,18 ***</span>
                  synchronized (fdLock) {
                      if (closePending) {
                          throw new SocketException (&quot;Socket closed&quot;);
                      }
                  }
<span class="line-removed">-                 // If we have a ref. to the Socket, then sets the flags</span>
<span class="line-removed">-                 // created, bound &amp; connected to true.</span>
<span class="line-removed">-                 // This is normally done in Socket.connect() but some</span>
<span class="line-removed">-                 // subclasses of Socket may call impl.connect() directly!</span>
<span class="line-removed">-                 if (socket != null) {</span>
<span class="line-removed">-                     socket.setBound();</span>
<span class="line-removed">-                     socket.setConnected();</span>
<span class="line-removed">-                 }</span>
              } finally {
                  releaseFD();
              }
          } catch (IOException e) {
              close();
<span class="line-new-header">--- 529,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,19 ***</span>
       */
      protected synchronized void bind(InetAddress address, int lport)
          throws IOException
      {
         synchronized (fdLock) {
<span class="line-modified">!             if (!closePending &amp;&amp; (socket == null || !socket.isBound())) {</span>
                  NetHooks.beforeTcpBind(fd, address, lport);
              }
          }
          socketBind(address, lport);
<span class="line-modified">!         if (socket != null)</span>
<span class="line-removed">-             socket.setBound();</span>
<span class="line-removed">-         if (serverSocket != null)</span>
<span class="line-removed">-             serverSocket.setBound();</span>
      }
  
      /**
       * Listens, for a specified amount of time, for connections.
       * @param count the amount of time to listen for connections
<span class="line-new-header">--- 547,19 ---</span>
       */
      protected synchronized void bind(InetAddress address, int lport)
          throws IOException
      {
         synchronized (fdLock) {
<span class="line-modified">!             if (!closePending &amp;&amp; !isBound) {</span>
                  NetHooks.beforeTcpBind(fd, address, lport);
              }
          }
<span class="line-added">+         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">+             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">+         }</span>
          socketBind(address, lport);
<span class="line-modified">!         isBound = true;</span>
      }
  
      /**
       * Listens, for a specified amount of time, for connections.
       * @param count the amount of time to listen for connections
</pre>
<hr />
<pre>
<span class="line-old-header">*** 448,19 ***</span>
          socketListen(count);
      }
  
      /**
       * Accepts connections.
<span class="line-modified">!      * @param s the connection</span>
       */
<span class="line-modified">!     protected void accept(SocketImpl s) throws IOException {</span>
          acquireFD();
          try {
<span class="line-modified">!             socketAccept(s);</span>
          } finally {
              releaseFD();
          }
      }
  
      /**
       * Gets an InputStream for this socket.
       */
<span class="line-new-header">--- 568,21 ---</span>
          socketListen(count);
      }
  
      /**
       * Accepts connections.
<span class="line-modified">!      * @param si the socket impl</span>
       */
<span class="line-modified">!     protected void accept(SocketImpl si) throws IOException {</span>
<span class="line-added">+         si.fd = new FileDescriptor();</span>
          acquireFD();
          try {
<span class="line-modified">!             socketAccept(si);</span>
          } finally {
              releaseFD();
          }
<span class="line-added">+         SocketCleanable.register(si.fd, true);</span>
      }
  
      /**
       * Gets an InputStream for this socket.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,12 ***</span>
          synchronized (fdLock) {
              if (isClosedOrPending())
                  throw new IOException(&quot;Socket Closed&quot;);
              if (shut_rd)
                  throw new IOException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">!             if (socketInputStream == null)</span>
<span class="line-modified">!                 socketInputStream = new SocketInputStream(this);</span>
          }
          return socketInputStream;
      }
  
      void setInputStream(SocketInputStream in) {
<span class="line-new-header">--- 590,18 ---</span>
          synchronized (fdLock) {
              if (isClosedOrPending())
                  throw new IOException(&quot;Socket Closed&quot;);
              if (shut_rd)
                  throw new IOException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">!             if (socketInputStream == null) {</span>
<span class="line-modified">!                 PrivilegedExceptionAction&lt;SocketInputStream&gt; pa = () -&gt; new SocketInputStream(this);</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     socketInputStream = AccessController.doPrivileged(pa);</span>
<span class="line-added">+                 } catch (PrivilegedActionException e) {</span>
<span class="line-added">+                     throw (IOException) e.getCause();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
          return socketInputStream;
      }
  
      void setInputStream(SocketInputStream in) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,12 ***</span>
          synchronized (fdLock) {
              if (isClosedOrPending())
                  throw new IOException(&quot;Socket Closed&quot;);
              if (shut_wr)
                  throw new IOException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">!             if (socketOutputStream == null)</span>
<span class="line-modified">!                 socketOutputStream = new SocketOutputStream(this);</span>
          }
          return socketOutputStream;
      }
  
      void setFileDescriptor(FileDescriptor fd) {
<span class="line-new-header">--- 615,18 ---</span>
          synchronized (fdLock) {
              if (isClosedOrPending())
                  throw new IOException(&quot;Socket Closed&quot;);
              if (shut_wr)
                  throw new IOException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">!             if (socketOutputStream == null) {</span>
<span class="line-modified">!                 PrivilegedExceptionAction&lt;SocketOutputStream&gt; pa = () -&gt; new SocketOutputStream(this);</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     socketOutputStream = AccessController.doPrivileged(pa);</span>
<span class="line-added">+                 } catch (PrivilegedActionException e) {</span>
<span class="line-added">+                     throw (IOException) e.getCause();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
          return socketOutputStream;
      }
  
      void setFileDescriptor(FileDescriptor fd) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,13 ***</span>
       * Closes the socket.
       */
      protected void close() throws IOException {
          synchronized(fdLock) {
              if (fd != null) {
<span class="line-removed">-                 if (!stream) {</span>
<span class="line-removed">-                     ResourceManager.afterUdpClose();</span>
<span class="line-removed">-                 }</span>
                  if (fdUseCount == 0) {
                      if (closePending) {
                          return;
                      }
                      closePending = true;
<span class="line-new-header">--- 681,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 587,19 ***</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     void reset() throws IOException {</span>
<span class="line-modified">!         if (fd != null) {</span>
<span class="line-removed">-             socketClose();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         fd = null;</span>
<span class="line-removed">-         super.reset();</span>
      }
  
<span class="line-removed">- </span>
      /**
       * Shutdown read-half of the socket connection;
       */
      protected void shutdownInput() throws IOException {
        if (fd != null) {
<span class="line-new-header">--- 718,14 ---</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     void reset() {</span>
<span class="line-modified">!         throw new InternalError(&quot;should not get here&quot;);</span>
      }
  
      /**
       * Shutdown read-half of the socket connection;
       */
      protected void shutdownInput() throws IOException {
        if (fd != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 709,14 ***</span>
      /*
       * Close the socket (and release the file descriptor).
       */
      protected void socketClose() throws IOException {
          SocketCleanable.unregister(fd);
<span class="line-modified">!         socketClose0(false);</span>
      }
  
<span class="line-modified">!     abstract void socketCreate(boolean isServer) throws IOException;</span>
      abstract void socketConnect(InetAddress address, int port, int timeout)
          throws IOException;
      abstract void socketBind(InetAddress address, int port)
          throws IOException;
      abstract void socketListen(int count)
<span class="line-new-header">--- 835,20 ---</span>
      /*
       * Close the socket (and release the file descriptor).
       */
      protected void socketClose() throws IOException {
          SocketCleanable.unregister(fd);
<span class="line-modified">!         try {</span>
<span class="line-added">+             socketClose0(false);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             if (!stream) {</span>
<span class="line-added">+                 ResourceManager.afterUdpClose();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     abstract void socketCreate(boolean stream) throws IOException;</span>
      abstract void socketConnect(InetAddress address, int port, int timeout)
          throws IOException;
      abstract void socketBind(InetAddress address, int port)
          throws IOException;
      abstract void socketListen(int count)
</pre>
<center><a href="AbstractPlainDatagramSocketImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BindException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
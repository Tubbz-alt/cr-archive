<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/MulticastSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MalformedURLException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/MulticastSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;


 29 import java.util.Collections;
 30 import java.util.Enumeration;
 31 import java.util.Set;
 32 
 33 /**
 34  * The multicast datagram socket class is useful for sending
<span class="line-modified"> 35  * and receiving IP multicast packets.  A MulticastSocket is</span>
 36  * a (UDP) DatagramSocket, with additional capabilities for
 37  * joining &quot;groups&quot; of other multicast hosts on the internet.
 38  * &lt;P&gt;
 39  * A multicast group is specified by a class D IP address
 40  * and by a standard UDP port number. Class D IP addresses
<span class="line-modified"> 41  * are in the range &lt;CODE&gt;224.0.0.0&lt;/CODE&gt; to &lt;CODE&gt;239.255.255.255&lt;/CODE&gt;,</span>
 42  * inclusive. The address 224.0.0.0 is reserved and should not be used.
 43  * &lt;P&gt;
 44  * One would join a multicast group by first creating a MulticastSocket
 45  * with the desired port, then invoking the
 46  * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 47  * method:
 48  * &lt;PRE&gt;
 49  * // join a Multicast group and send the group salutations
 50  * ...
 51  * String msg = &quot;Hello&quot;;
<span class="line-modified"> 52  * InetAddress group = InetAddress.getByName(&quot;228.5.6.7&quot;);</span>


 53  * MulticastSocket s = new MulticastSocket(6789);
<span class="line-modified"> 54  * s.joinGroup(group);</span>

 55  * byte[] msgBytes = msg.getBytes(StandardCharsets.UTF_8);
 56  * DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length,
 57  *                                        group, 6789);
 58  * s.send(hi);
 59  * // get their responses!
 60  * byte[] buf = new byte[1000];
 61  * DatagramPacket recv = new DatagramPacket(buf, buf.length);
 62  * s.receive(recv);
 63  * ...
 64  * // OK, I&#39;m done talking - leave the group...
<span class="line-modified"> 65  * s.leaveGroup(group);</span>
 66  * &lt;/PRE&gt;
 67  *
 68  * When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
 69  * recipients to that host and port receive the message (within the
<span class="line-modified"> 70  * time-to-live range of the packet, see below).  The socket needn&#39;t</span>
 71  * be a member of the multicast group to send messages to it.
 72  * &lt;P&gt;
 73  * When a socket subscribes to a multicast group/port, it receives
 74  * datagrams sent by other hosts to the group/port, as do all other
 75  * members of the group and port.  A socket relinquishes membership
<span class="line-modified"> 76  * in a group by the leaveGroup(InetAddress addr) method.  &lt;B&gt;</span>
<span class="line-modified"> 77  * Multiple MulticastSocket&#39;s&lt;/B&gt; may subscribe to a multicast group</span>

 78  * and port concurrently, and they will all receive group datagrams.
<span class="line-modified"> 79  * &lt;P&gt;</span>
<span class="line-modified"> 80  * Currently applets are not allowed to use multicast sockets.</span>













































 81  *
 82  * @author Pavani Diwanji
<span class="line-modified"> 83  * @since  1.1</span>
 84  */
<span class="line-modified"> 85 public</span>
<span class="line-removed"> 86 class MulticastSocket extends DatagramSocket {</span>
 87 
 88     /**
 89      * Used on some platforms to record if an outgoing interface
 90      * has been set for this socket.
 91      */
 92     private boolean interfaceSet;
 93 
 94     /**
 95      * Create a multicast socket.
 96      *
 97      * &lt;p&gt;
 98      * If there is a security manager, its {@code checkListen} method is first
 99      * called with 0 as its argument to ensure the operation is allowed. This
100      * could result in a SecurityException.
101      * &lt;p&gt;
102      * When the socket is created the
103      * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
104      * enable the SO_REUSEADDR socket option.
105      *
<span class="line-modified">106      * @exception IOException if an I/O exception occurs while creating the</span>
107      * MulticastSocket
<span class="line-modified">108      * @exception SecurityException if a security manager exists and its</span>
109      * {@code checkListen} method doesn&#39;t allow the operation.
110      * @see SecurityManager#checkListen
111      * @see java.net.DatagramSocket#setReuseAddress(boolean)
112      * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
113      */
114     public MulticastSocket() throws IOException {
115         this(new InetSocketAddress(0));
116     }
117 
118     /**
119      * Create a multicast socket and bind it to a specific port.
120      *
121      * &lt;p&gt;If there is a security manager,
122      * its {@code checkListen} method is first called
123      * with the {@code port} argument
124      * as its argument to ensure the operation is allowed.
125      * This could result in a SecurityException.
126      * &lt;p&gt;
127      * When the socket is created the
128      * {@link DatagramSocket#setReuseAddress(boolean)} method is
129      * called to enable the SO_REUSEADDR socket option.
130      *
<span class="line-modified">131      * @param port port to use</span>
<span class="line-modified">132      * @exception IOException if an I/O exception occurs</span>
<span class="line-modified">133      * while creating the MulticastSocket</span>
<span class="line-modified">134      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">135      *             {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">136      * @see SecurityManager#checkListen</span>
<span class="line-modified">137      * @see java.net.DatagramSocket#setReuseAddress(boolean)</span>
138      */
139     public MulticastSocket(int port) throws IOException {
140         this(new InetSocketAddress(port));
141     }
142 
143     /**
144      * Create a MulticastSocket bound to the specified socket address.
145      * &lt;p&gt;
146      * Or, if the address is {@code null}, create an unbound socket.
147      *
148      * &lt;p&gt;If there is a security manager,
149      * its {@code checkListen} method is first called
150      * with the SocketAddress port as its argument to ensure the operation is allowed.
151      * This could result in a SecurityException.
152      * &lt;p&gt;
153      * When the socket is created the
154      * {@link DatagramSocket#setReuseAddress(boolean)} method is
155      * called to enable the SO_REUSEADDR socket option.
156      *
<span class="line-modified">157      * @param bindaddr Socket address to bind to, or {@code null} for</span>
<span class="line-modified">158      *                 an unbound socket.</span>
<span class="line-modified">159      * @exception IOException if an I/O exception occurs</span>
<span class="line-modified">160      * while creating the MulticastSocket</span>
<span class="line-modified">161      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">162      *             {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">163      * @see SecurityManager#checkListen</span>
<span class="line-modified">164      * @see java.net.DatagramSocket#setReuseAddress(boolean)</span>
165      *
166      * @since 1.4
167      */
168     public MulticastSocket(SocketAddress bindaddr) throws IOException {
169         super((SocketAddress) null);
170 




171         // Enable SO_REUSEADDR before binding
172         setReuseAddress(true);
173 
174         if (bindaddr != null) {
175             try {
176                 bind(bindaddr);
177             } finally {
178                 if (!isBound()) {
179                     close();
180                 }
181             }
182         }
183     }
184 
185     /**
186      * The lock on the socket&#39;s TTL. This is for set/getTTL and
187      * send(packet,ttl).
188      */
189     private Object ttlLock = new Object();
190 
191     /**
192      * The lock on the socket&#39;s interface - used by setInterface
193      * and getInterface
194      */
195     private Object infLock = new Object();
196 
197     /**
198      * The &quot;last&quot; interface set by setInterface on this MulticastSocket
199      */
200     private InetAddress infAddress = null;
201 
202 
203     /**
204      * Set the default time-to-live for multicast packets sent out
205      * on this {@code MulticastSocket} in order to control the
206      * scope of the multicasts.
207      *
208      * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
209      * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
210      *
<span class="line-modified">211      * @param ttl the time-to-live</span>
<span class="line-modified">212      * @exception IOException if an I/O exception occurs</span>
<span class="line-modified">213      * while setting the default time-to-live value</span>
214      * @deprecated use the setTimeToLive method instead, which uses
<span class="line-modified">215      * &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.</span>
216      * @see #getTTL()
217      */
218     @Deprecated
219     public void setTTL(byte ttl) throws IOException {
220         if (isClosed())
221             throw new SocketException(&quot;Socket is closed&quot;);
222         getImpl().setTTL(ttl);
223     }
224 
225     /**
226      * Set the default time-to-live for multicast packets sent out
227      * on this {@code MulticastSocket} in order to control the
228      * scope of the multicasts.
229      *
230      * &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
231      * 255} or an {@code IllegalArgumentException} will be thrown.
232      * Multicast packets sent with a TTL of {@code 0} are not transmitted
233      * on the network but may be delivered locally.
234      *
235      * @param  ttl
236      *         the time-to-live
237      *
238      * @throws  IOException
239      *          if an I/O exception occurs while setting the
240      *          default time-to-live value
241      *
242      * @see #getTimeToLive()

243      */
244     public void setTimeToLive(int ttl) throws IOException {
245         if (ttl &lt; 0 || ttl &gt; 255) {
246             throw new IllegalArgumentException(&quot;ttl out of range&quot;);
247         }
248         if (isClosed())
249             throw new SocketException(&quot;Socket is closed&quot;);
250         getImpl().setTimeToLive(ttl);
251     }
252 
253     /**
254      * Get the default time-to-live for multicast packets sent out on
255      * the socket.
256      *
<span class="line-modified">257      * @exception IOException if an I/O exception occurs</span>
258      * while getting the default time-to-live value
259      * @return the default time-to-live value
260      * @deprecated use the getTimeToLive method instead, which returns
261      * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
262      * @see #setTTL(byte)
263      */
264     @Deprecated
265     public byte getTTL() throws IOException {
266         if (isClosed())
267             throw new SocketException(&quot;Socket is closed&quot;);
268         return getImpl().getTTL();
269     }
270 
271     /**
272      * Get the default time-to-live for multicast packets sent out on
273      * the socket.
<span class="line-modified">274      * @exception IOException if an I/O exception occurs while</span>
275      * getting the default time-to-live value
276      * @return the default time-to-live value
277      * @see #setTimeToLive(int)

278      */
279     public int getTimeToLive() throws IOException {
280         if (isClosed())
281             throw new SocketException(&quot;Socket is closed&quot;);
282         return getImpl().getTimeToLive();
283     }
284 
285     /**
286      * Joins a multicast group. Its behavior may be affected by
287      * {@code setInterface} or {@code setNetworkInterface}.
288      *
289      * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">290      * calls its {@code checkMulticast} method</span>
<span class="line-modified">291      * with the {@code mcastaddr} argument</span>
<span class="line-modified">292      * as its argument.</span>
<span class="line-modified">293      *</span>
<span class="line-modified">294      * @param mcastaddr is the multicast address to join</span>
<span class="line-modified">295      *</span>
<span class="line-modified">296      * @exception IOException if there is an error joining, or when the address</span>
<span class="line-modified">297      *            is not a multicast address, or the platform does not support</span>
<span class="line-modified">298      *            multicasting</span>
<span class="line-modified">299      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">300      * {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">301      *</span>
<span class="line-modified">302      * @see SecurityManager#checkMulticast(InetAddress)</span>
303      */

304     public void joinGroup(InetAddress mcastaddr) throws IOException {
305         if (isClosed()) {
306             throw new SocketException(&quot;Socket is closed&quot;);
307         }
308 
309         checkAddress(mcastaddr, &quot;joinGroup&quot;);
310         SecurityManager security = System.getSecurityManager();
311         if (security != null) {
312             security.checkMulticast(mcastaddr);
313         }
314 
315         if (!mcastaddr.isMulticastAddress()) {
316             throw new SocketException(&quot;Not a multicast address&quot;);
317         }
318 
319         /**
320          * required for some platforms where it&#39;s not possible to join
321          * a group without setting the interface first.
322          */
323         NetworkInterface defaultInterface = NetworkInterface.getDefault();
324 
325         if (!interfaceSet &amp;&amp; defaultInterface != null) {
326             setNetworkInterface(defaultInterface);
327         }
328 
329         getImpl().join(mcastaddr);
330     }
331 
332     /**
333      * Leave a multicast group. Its behavior may be affected by
334      * {@code setInterface} or {@code setNetworkInterface}.
335      *
336      * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">337      * calls its {@code checkMulticast} method</span>
<span class="line-modified">338      * with the {@code mcastaddr} argument</span>
<span class="line-modified">339      * as its argument.</span>
<span class="line-modified">340      *</span>
<span class="line-modified">341      * @param mcastaddr is the multicast address to leave</span>
<span class="line-modified">342      * @exception IOException if there is an error leaving</span>
<span class="line-modified">343      * or when the address is not a multicast address.</span>
<span class="line-modified">344      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">345      * {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">346      *</span>
<span class="line-modified">347      * @see SecurityManager#checkMulticast(InetAddress)</span>

348      */

349     public void leaveGroup(InetAddress mcastaddr) throws IOException {
350         if (isClosed()) {
351             throw new SocketException(&quot;Socket is closed&quot;);
352         }
353 
354         checkAddress(mcastaddr, &quot;leaveGroup&quot;);
355         SecurityManager security = System.getSecurityManager();
356         if (security != null) {
357             security.checkMulticast(mcastaddr);
358         }
359 
360         if (!mcastaddr.isMulticastAddress()) {
361             throw new SocketException(&quot;Not a multicast address&quot;);
362         }
363 
364         getImpl().leave(mcastaddr);
365     }
366 
367     /**
368      * Joins the specified multicast group at the specified interface.
369      *
370      * &lt;p&gt;If there is a security manager, this method first
371      * calls its {@code checkMulticast} method
372      * with the {@code mcastaddr} argument
373      * as its argument.
374      *
<span class="line-modified">375      * @param mcastaddr is the multicast address to join</span>
<span class="line-modified">376      * @param netIf specifies the local interface to receive multicast</span>
<span class="line-modified">377      *        datagram packets, or &lt;i&gt;null&lt;/i&gt; to defer to the interface set by</span>
<span class="line-modified">378      *       {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">379      *       {@link MulticastSocket#setNetworkInterface(NetworkInterface)}</span>
<span class="line-modified">380      *</span>
<span class="line-modified">381      * @exception IOException if there is an error joining, or when the address</span>
<span class="line-modified">382      *            is not a multicast address, or the platform does not support</span>
<span class="line-modified">383      *            multicasting</span>
<span class="line-modified">384      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">385      * {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">386      * @throws  IllegalArgumentException if mcastaddr is null or is a</span>
<span class="line-modified">387      *          SocketAddress subclass not supported by this socket</span>
<span class="line-modified">388      *</span>
<span class="line-modified">389      * @see SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-modified">390      * @since 1.4</span>


391      */
392     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
393         throws IOException {
394         if (isClosed())
395             throw new SocketException(&quot;Socket is closed&quot;);
396 
397         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
398             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
399 
400         if (oldImpl)
401             throw new UnsupportedOperationException();
402 
403         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;joinGroup&quot;);
404         SecurityManager security = System.getSecurityManager();
405         if (security != null) {
406             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
407         }
408 
409         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
410             throw new SocketException(&quot;Not a multicast address&quot;);
411         }
412 
413         getImpl().joinGroup(mcastaddr, netIf);
414     }
415 
416     /**
417      * Leave a multicast group on a specified local interface.
418      *
419      * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">420      * calls its {@code checkMulticast} method</span>
<span class="line-modified">421      * with the {@code mcastaddr} argument</span>
<span class="line-modified">422      * as its argument.</span>
<span class="line-modified">423      *</span>
<span class="line-modified">424      * @param mcastaddr is the multicast address to leave</span>
<span class="line-modified">425      * @param netIf specifies the local interface or &lt;i&gt;null&lt;/i&gt; to defer</span>
<span class="line-modified">426      *             to the interface set by</span>
<span class="line-modified">427      *             {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">428      *             {@link MulticastSocket#setNetworkInterface(NetworkInterface)}</span>
<span class="line-modified">429      * @exception IOException if there is an error leaving</span>
<span class="line-modified">430      * or when the address is not a multicast address.</span>
<span class="line-modified">431      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">432      * {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">433      * @throws  IllegalArgumentException if mcastaddr is null or is a</span>
<span class="line-modified">434      *          SocketAddress subclass not supported by this socket</span>
<span class="line-modified">435      *</span>
<span class="line-modified">436      * @see SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-modified">437      * @since 1.4</span>

438      */
439     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
440         throws IOException {
441         if (isClosed())
442             throw new SocketException(&quot;Socket is closed&quot;);
443 
444         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
445             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
446 
447         if (oldImpl)
448             throw new UnsupportedOperationException();
449 
450         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;leaveGroup&quot;);
451         SecurityManager security = System.getSecurityManager();
452         if (security != null) {
453             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
454         }
455 
456         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
457             throw new SocketException(&quot;Not a multicast address&quot;);
458         }
459 
460         getImpl().leaveGroup(mcastaddr, netIf);
461      }
462 
463     /**
464      * Set the multicast network interface used by methods
465      * whose behavior would be affected by the value of the
466      * network interface. Useful for multihomed hosts.
<span class="line-modified">467      * @param inf the InetAddress</span>
<span class="line-modified">468      * @exception SocketException if there is an error in</span>
<span class="line-modified">469      * the underlying protocol, such as a TCP error.</span>
<span class="line-modified">470      * @see #getInterface()</span>




471      */

472     public void setInterface(InetAddress inf) throws SocketException {
473         if (isClosed()) {
474             throw new SocketException(&quot;Socket is closed&quot;);
475         }
476         checkAddress(inf, &quot;setInterface&quot;);
477         synchronized (infLock) {
478             getImpl().setOption(SocketOptions.IP_MULTICAST_IF, inf);
479             infAddress = inf;
480             interfaceSet = true;
481         }
482     }
483 
484     /**
485      * Retrieve the address of the network interface used for
486      * multicast packets.
487      *
<span class="line-modified">488      * @return An {@code InetAddress} representing</span>
<span class="line-modified">489      *  the address of the network interface used for</span>
<span class="line-modified">490      *  multicast packets.</span>
<span class="line-modified">491      *</span>
<span class="line-modified">492      * @exception SocketException if there is an error in</span>
<span class="line-modified">493      * the underlying protocol, such as a TCP error.</span>
<span class="line-modified">494      *</span>
<span class="line-modified">495      * @see #setInterface(java.net.InetAddress)</span>


496      */

497     public InetAddress getInterface() throws SocketException {
498         if (isClosed()) {
499             throw new SocketException(&quot;Socket is closed&quot;);
500         }
501         synchronized (infLock) {
502             InetAddress ia =
503                 (InetAddress)getImpl().getOption(SocketOptions.IP_MULTICAST_IF);
504 
505             /**
506              * No previous setInterface or interface can be
507              * set using setNetworkInterface
508              */
509             if (infAddress == null) {
510                 return ia;
511             }
512 
513             /**
514              * Same interface set with setInterface?
515              */
516             if (ia.equals(infAddress)) {
</pre>
<hr />
<pre>
532                     }
533                 }
534 
535                 /**
536                  * No match so reset infAddress to indicate that the
537                  * interface has changed via means
538                  */
539                 infAddress = null;
540                 return ia;
541             } catch (Exception e) {
542                 return ia;
543             }
544         }
545     }
546 
547     /**
548      * Specify the network interface for outgoing multicast datagrams
549      * sent on this socket.
550      *
551      * @param netIf the interface
<span class="line-modified">552      * @exception SocketException if there is an error in</span>
553      * the underlying protocol, such as a TCP error.
554      * @see #getNetworkInterface()
555      * @since 1.4
556      */
557     public void setNetworkInterface(NetworkInterface netIf)
558         throws SocketException {
559 
560         synchronized (infLock) {
561             getImpl().setOption(SocketOptions.IP_MULTICAST_IF2, netIf);
562             infAddress = null;
563             interfaceSet = true;
564         }
565     }
566 
567     /**
568      * Get the multicast network interface set.
569      *
<span class="line-modified">570      * @exception SocketException if there is an error in</span>
<span class="line-modified">571      * the underlying protocol, such as a TCP error.</span>
<span class="line-modified">572      * @return the multicast {@code NetworkInterface} currently set</span>
<span class="line-modified">573      * @see #setNetworkInterface(NetworkInterface)</span>
<span class="line-modified">574      * @since 1.4</span>


575      */
576     public NetworkInterface getNetworkInterface() throws SocketException {
577         NetworkInterface ni
578             = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
<span class="line-modified">579         if ((ni.getIndex() == 0) || (ni.getIndex() == -1)) {</span>
580             InetAddress[] addrs = new InetAddress[1];
581             addrs[0] = InetAddress.anyLocalAddress();
582             return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
583         } else {
584             return ni;
585         }
586     }
587 
588     /**
589      * Disable/Enable local loopback of multicast datagrams
590      * The option is used by the platform&#39;s networking code as a hint
591      * for setting whether multicast data will be looped back to
592      * the local socket.
593      *
594      * &lt;p&gt;Because this option is a hint, applications that want to
595      * verify what loopback mode is set to should call
596      * {@link #getLoopbackMode()}
<span class="line-modified">597      * @param disable {@code true} to disable the LoopbackMode</span>
<span class="line-modified">598      * @throws SocketException if an error occurs while setting the value</span>
<span class="line-modified">599      * @since 1.4</span>
<span class="line-modified">600      * @see #getLoopbackMode</span>





601      */

602     public void setLoopbackMode(boolean disable) throws SocketException {
603         getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
604     }
605 
606     /**
607      * Get the setting for local loopback of multicast datagrams.
608      *
<span class="line-modified">609      * @throws SocketException  if an error occurs while getting the value</span>
<span class="line-modified">610      * @return true if the LoopbackMode has been disabled</span>
<span class="line-modified">611      * @since 1.4</span>
<span class="line-modified">612      * @see #setLoopbackMode</span>



613      */

614     public boolean getLoopbackMode() throws SocketException {
615         return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
616     }
617 
618     /**
619      * Sends a datagram packet to the destination, with a TTL (time-
620      * to-live) other than the default for the socket.  This method
621      * need only be used in instances where a particular TTL is desired;
622      * otherwise it is preferable to set a TTL once on the socket, and
623      * use that default TTL for all packets.  This method does &lt;B&gt;not
624      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
625      * affected by {@code setInterface}.
626      *
627      * &lt;p&gt;If there is a security manager, this method first performs some
628      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
629      * is true, this method calls the
630      * security manager&#39;s {@code checkMulticast} method
631      * with {@code p.getAddress()} and {@code ttl} as its arguments.
632      * If the evaluation of that expression is false,
633      * this method instead calls the security manager&#39;s
634      * {@code checkConnect} method with arguments
635      * {@code p.getAddress().getHostAddress()} and
636      * {@code p.getPort()}. Each call to a security manager method
637      * could result in a SecurityException if the operation is not allowed.
638      *
639      * @param p is the packet to be sent. The packet should contain
640      * the destination multicast ip address and the data to be sent.
641      * One does not need to be the member of the group to send
642      * packets to a destination multicast address.
643      * @param ttl optional time to live for multicast packet.
644      * default ttl is 1.
645      *
<span class="line-modified">646      * @exception IOException is raised if an error occurs i.e</span>
<span class="line-modified">647      * error while setting ttl.</span>
<span class="line-modified">648      * @exception  SecurityException  if a security manager exists and its</span>
649      *             {@code checkMulticast} or {@code checkConnect}
650      *             method doesn&#39;t allow the send.








651      *
652      * @deprecated Use the following code or its equivalent instead:
653      *  ......
654      *  int ttl = mcastSocket.getTimeToLive();
655      *  mcastSocket.setTimeToLive(newttl);
656      *  mcastSocket.send(p);
657      *  mcastSocket.setTimeToLive(ttl);
658      *  ......
659      *
660      * @see DatagramSocket#send
661      * @see DatagramSocket#receive
662      * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)
663      * @see SecurityManager#checkConnect
664      */
665     @Deprecated
666     public void send(DatagramPacket p, byte ttl)
667         throws IOException {
668             if (isClosed())
669                 throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-removed">670             checkAddress(p.getAddress(), &quot;send&quot;);</span>
671             synchronized(ttlLock) {
672                 synchronized(p) {



673                     if (connectState == ST_NOT_CONNECTED) {





674                         // Security manager makes sure that the multicast address
675                         // is allowed one and that the ttl used is less
676                         // than the allowed maxttl.
677                         SecurityManager security = System.getSecurityManager();
678                         if (security != null) {
<span class="line-modified">679                             if (p.getAddress().isMulticastAddress()) {</span>
<span class="line-modified">680                                 security.checkMulticast(p.getAddress(), ttl);</span>
681                             } else {
<span class="line-modified">682                                 security.checkConnect(p.getAddress().getHostAddress(),</span>
<span class="line-modified">683                                                       p.getPort());</span>
684                             }
685                         }
686                     } else {
687                         // we&#39;re connected
<span class="line-removed">688                         InetAddress packetAddress = null;</span>
<span class="line-removed">689                         packetAddress = p.getAddress();</span>
690                         if (packetAddress == null) {
691                             p.setAddress(connectedAddress);
692                             p.setPort(connectedPort);
693                         } else if ((!packetAddress.equals(connectedAddress)) ||
<span class="line-modified">694                                    p.getPort() != connectedPort) {</span>
<span class="line-modified">695                             throw new SecurityException(&quot;connected address and packet address&quot; +</span>
696                                                         &quot; differ&quot;);
697                         }
698                     }
699                     byte dttl = getTTL();
700                     try {
701                         if (ttl != dttl) {
702                             // set the ttl
703                             getImpl().setTTL(ttl);
704                         }
705                         // call the datagram method to send
706                         getImpl().send(p);
707                     } finally {
708                         // set it back to default
709                         if (ttl != dttl) {
710                             getImpl().setTTL(dttl);
711                         }
712                     }
713                 } // synch p
714             }  //synch ttl
715     } //method
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
<span class="line-added"> 29 import java.nio.channels.DatagramChannel;</span>
<span class="line-added"> 30 import java.nio.channels.MulticastChannel;</span>
 31 import java.util.Collections;
 32 import java.util.Enumeration;
 33 import java.util.Set;
 34 
 35 /**
 36  * The multicast datagram socket class is useful for sending
<span class="line-modified"> 37  * and receiving IP multicast packets. A MulticastSocket is</span>
 38  * a (UDP) DatagramSocket, with additional capabilities for
 39  * joining &quot;groups&quot; of other multicast hosts on the internet.
 40  * &lt;P&gt;
 41  * A multicast group is specified by a class D IP address
 42  * and by a standard UDP port number. Class D IP addresses
<span class="line-modified"> 43  * are in the range {@code 224.0.0.0} to {@code 239.255.255.255},</span>
 44  * inclusive. The address 224.0.0.0 is reserved and should not be used.
 45  * &lt;P&gt;
 46  * One would join a multicast group by first creating a MulticastSocket
 47  * with the desired port, then invoking the
 48  * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 49  * method:
 50  * &lt;PRE&gt;
 51  * // join a Multicast group and send the group salutations
 52  * ...
 53  * String msg = &quot;Hello&quot;;
<span class="line-modified"> 54  * InetAddress mcastaddr = InetAddress.getByName(&quot;228.5.6.7&quot;);</span>
<span class="line-added"> 55  * InetSocketAddress group = new InetSocketAddress(mcastaddr, port);</span>
<span class="line-added"> 56  * NetworkInterface netIf = NetworkInterface.getByName(&quot;bge0&quot;);</span>
 57  * MulticastSocket s = new MulticastSocket(6789);
<span class="line-modified"> 58  *</span>
<span class="line-added"> 59  * s.joinGroup(group, netIf);</span>
 60  * byte[] msgBytes = msg.getBytes(StandardCharsets.UTF_8);
 61  * DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length,
 62  *                                        group, 6789);
 63  * s.send(hi);
 64  * // get their responses!
 65  * byte[] buf = new byte[1000];
 66  * DatagramPacket recv = new DatagramPacket(buf, buf.length);
 67  * s.receive(recv);
 68  * ...
 69  * // OK, I&#39;m done talking - leave the group...
<span class="line-modified"> 70  * s.leaveGroup(group, netIf);</span>
 71  * &lt;/PRE&gt;
 72  *
 73  * When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
 74  * recipients to that host and port receive the message (within the
<span class="line-modified"> 75  * time-to-live range of the packet, see below). The socket needn&#39;t</span>
 76  * be a member of the multicast group to send messages to it.
 77  * &lt;P&gt;
 78  * When a socket subscribes to a multicast group/port, it receives
 79  * datagrams sent by other hosts to the group/port, as do all other
 80  * members of the group and port.  A socket relinquishes membership
<span class="line-modified"> 81  * in a group by the leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)</span>
<span class="line-modified"> 82  * method.</span>
<span class="line-added"> 83  * &lt;B&gt;Multiple MulticastSockets&lt;/B&gt; may subscribe to a multicast group</span>
 84  * and port concurrently, and they will all receive group datagrams.
<span class="line-modified"> 85  *</span>
<span class="line-modified"> 86  * &lt;p&gt; The {@code DatagramSocket} and {@code MulticastSocket}</span>
<span class="line-added"> 87  * classes define convenience methods to set and get several</span>
<span class="line-added"> 88  * socket options. Like {@code DatagramSocket} this class also</span>
<span class="line-added"> 89  * supports the {@link #setOption(SocketOption, Object) setOption}</span>
<span class="line-added"> 90  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added"> 91  * and query socket options.</span>
<span class="line-added"> 92  * In addition to the socket options supported by</span>
<span class="line-added"> 93  * &lt;a href=&quot;DatagramSocket.html#SocketOptions&quot;&gt;{@code DatagramSocket}&lt;/a&gt;, a</span>
<span class="line-added"> 94  * {@code MulticastSocket} supports the following socket options:</span>
<span class="line-added"> 95  * &lt;blockquote&gt;</span>
<span class="line-added"> 96  * &lt;a id=&quot;MulticastOptions&quot;&gt;&lt;/a&gt;</span>
<span class="line-added"> 97  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added"> 98  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added"> 99  * &lt;thead&gt;</span>
<span class="line-added">100  *   &lt;tr&gt;</span>
<span class="line-added">101  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">102  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">103  *   &lt;/tr&gt;</span>
<span class="line-added">104  * &lt;/thead&gt;</span>
<span class="line-added">105  * &lt;tbody&gt;</span>
<span class="line-added">106  *   &lt;tr&gt;</span>
<span class="line-added">107  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} &lt;/th&gt;</span>
<span class="line-added">108  *     &lt;td&gt; The network interface for Internet Protocol (IP) multicast datagrams &lt;/td&gt;</span>
<span class="line-added">109  *   &lt;/tr&gt;</span>
<span class="line-added">110  *   &lt;tr&gt;</span>
<span class="line-added">111  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL</span>
<span class="line-added">112  *       IP_MULTICAST_TTL} &lt;/th&gt;</span>
<span class="line-added">113  *     &lt;td&gt; The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast</span>
<span class="line-added">114  *       datagrams &lt;/td&gt;</span>
<span class="line-added">115  *   &lt;/tr&gt;</span>
<span class="line-added">116  *   &lt;tr&gt;</span>
<span class="line-added">117  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP</span>
<span class="line-added">118  *       IP_MULTICAST_LOOP} &lt;/th&gt;</span>
<span class="line-added">119  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;</span>
<span class="line-added">120  *   &lt;/tr&gt;</span>
<span class="line-added">121  * &lt;/tbody&gt;</span>
<span class="line-added">122  * &lt;/table&gt;</span>
<span class="line-added">123  * &lt;/blockquote&gt;</span>
<span class="line-added">124  * Additional (implementation specific) options may also be supported.</span>
<span class="line-added">125  *</span>
<span class="line-added">126  * @apiNote {@link DatagramChannel} implements the {@link MulticastChannel} interface</span>
<span class="line-added">127  *          and provides an alternative API for sending and receiving multicast datagrams.</span>
<span class="line-added">128  *          The {@link MulticastChannel} API supports both {@linkplain</span>
<span class="line-added">129  *          MulticastChannel#join(InetAddress, NetworkInterface) any-source} and</span>
<span class="line-added">130  *          {@linkplain MulticastChannel#join(InetAddress, NetworkInterface, InetAddress)</span>
<span class="line-added">131  *          source-specific} multicast.</span>
132  *
133  * @author Pavani Diwanji
<span class="line-modified">134  * @since 1.1</span>
135  */
<span class="line-modified">136 public class MulticastSocket extends DatagramSocket {</span>

137 
138     /**
139      * Used on some platforms to record if an outgoing interface
140      * has been set for this socket.
141      */
142     private boolean interfaceSet;
143 
144     /**
145      * Create a multicast socket.
146      *
147      * &lt;p&gt;
148      * If there is a security manager, its {@code checkListen} method is first
149      * called with 0 as its argument to ensure the operation is allowed. This
150      * could result in a SecurityException.
151      * &lt;p&gt;
152      * When the socket is created the
153      * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
154      * enable the SO_REUSEADDR socket option.
155      *
<span class="line-modified">156      * @throws    IOException if an I/O exception occurs while creating the</span>
157      * MulticastSocket
<span class="line-modified">158      * @throws    SecurityException if a security manager exists and its</span>
159      * {@code checkListen} method doesn&#39;t allow the operation.
160      * @see SecurityManager#checkListen
161      * @see java.net.DatagramSocket#setReuseAddress(boolean)
162      * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
163      */
164     public MulticastSocket() throws IOException {
165         this(new InetSocketAddress(0));
166     }
167 
168     /**
169      * Create a multicast socket and bind it to a specific port.
170      *
171      * &lt;p&gt;If there is a security manager,
172      * its {@code checkListen} method is first called
173      * with the {@code port} argument
174      * as its argument to ensure the operation is allowed.
175      * This could result in a SecurityException.
176      * &lt;p&gt;
177      * When the socket is created the
178      * {@link DatagramSocket#setReuseAddress(boolean)} method is
179      * called to enable the SO_REUSEADDR socket option.
180      *
<span class="line-modified">181      * @param     port port to use</span>
<span class="line-modified">182      * @throws    IOException if an I/O exception occurs</span>
<span class="line-modified">183      *            while creating the MulticastSocket</span>
<span class="line-modified">184      * @throws    SecurityException  if a security manager exists and its</span>
<span class="line-modified">185      *            {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">186      * @see       SecurityManager#checkListen</span>
<span class="line-modified">187      * @see       java.net.DatagramSocket#setReuseAddress(boolean)</span>
188      */
189     public MulticastSocket(int port) throws IOException {
190         this(new InetSocketAddress(port));
191     }
192 
193     /**
194      * Create a MulticastSocket bound to the specified socket address.
195      * &lt;p&gt;
196      * Or, if the address is {@code null}, create an unbound socket.
197      *
198      * &lt;p&gt;If there is a security manager,
199      * its {@code checkListen} method is first called
200      * with the SocketAddress port as its argument to ensure the operation is allowed.
201      * This could result in a SecurityException.
202      * &lt;p&gt;
203      * When the socket is created the
204      * {@link DatagramSocket#setReuseAddress(boolean)} method is
205      * called to enable the SO_REUSEADDR socket option.
206      *
<span class="line-modified">207      * @param    bindaddr Socket address to bind to, or {@code null} for</span>
<span class="line-modified">208      *           an unbound socket.</span>
<span class="line-modified">209      * @throws   IOException if an I/O exception occurs</span>
<span class="line-modified">210      *           while creating the MulticastSocket</span>
<span class="line-modified">211      * @throws   SecurityException  if a security manager exists and its</span>
<span class="line-modified">212      *           {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">213      * @see      SecurityManager#checkListen</span>
<span class="line-modified">214      * @see      java.net.DatagramSocket#setReuseAddress(boolean)</span>
215      *
216      * @since 1.4
217      */
218     public MulticastSocket(SocketAddress bindaddr) throws IOException {
219         super((SocketAddress) null);
220 
<span class="line-added">221         // No further initialization when this is a DatagramChannel socket adaptor</span>
<span class="line-added">222         if (this instanceof sun.nio.ch.DatagramSocketAdaptor)</span>
<span class="line-added">223             return;</span>
<span class="line-added">224 </span>
225         // Enable SO_REUSEADDR before binding
226         setReuseAddress(true);
227 
228         if (bindaddr != null) {
229             try {
230                 bind(bindaddr);
231             } finally {
232                 if (!isBound()) {
233                     close();
234                 }
235             }
236         }
237     }
238 
239     /**
240      * The lock on the socket&#39;s TTL. This is for set/getTTL and
241      * send(packet,ttl).
242      */
243     private Object ttlLock = new Object();
244 
245     /**
246      * The lock on the socket&#39;s interface - used by setInterface
247      * and getInterface
248      */
249     private Object infLock = new Object();
250 
251     /**
252      * The &quot;last&quot; interface set by setInterface on this MulticastSocket
253      */
254     private InetAddress infAddress = null;
255 
256 
257     /**
258      * Set the default time-to-live for multicast packets sent out
259      * on this {@code MulticastSocket} in order to control the
260      * scope of the multicasts.
261      *
262      * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
263      * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
264      *
<span class="line-modified">265      * @param      ttl the time-to-live</span>
<span class="line-modified">266      * @throws     IOException if an I/O exception occurs</span>
<span class="line-modified">267      *             while setting the default time-to-live value</span>
268      * @deprecated use the setTimeToLive method instead, which uses
<span class="line-modified">269      *             &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.</span>
270      * @see #getTTL()
271      */
272     @Deprecated
273     public void setTTL(byte ttl) throws IOException {
274         if (isClosed())
275             throw new SocketException(&quot;Socket is closed&quot;);
276         getImpl().setTTL(ttl);
277     }
278 
279     /**
280      * Set the default time-to-live for multicast packets sent out
281      * on this {@code MulticastSocket} in order to control the
282      * scope of the multicasts.
283      *
284      * &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
285      * 255} or an {@code IllegalArgumentException} will be thrown.
286      * Multicast packets sent with a TTL of {@code 0} are not transmitted
287      * on the network but may be delivered locally.
288      *
289      * @param  ttl
290      *         the time-to-live
291      *
292      * @throws  IOException
293      *          if an I/O exception occurs while setting the
294      *          default time-to-live value
295      *
296      * @see #getTimeToLive()
<span class="line-added">297      * @since 1.2</span>
298      */
299     public void setTimeToLive(int ttl) throws IOException {
300         if (ttl &lt; 0 || ttl &gt; 255) {
301             throw new IllegalArgumentException(&quot;ttl out of range&quot;);
302         }
303         if (isClosed())
304             throw new SocketException(&quot;Socket is closed&quot;);
305         getImpl().setTimeToLive(ttl);
306     }
307 
308     /**
309      * Get the default time-to-live for multicast packets sent out on
310      * the socket.
311      *
<span class="line-modified">312      * @throws    IOException if an I/O exception occurs</span>
313      * while getting the default time-to-live value
314      * @return the default time-to-live value
315      * @deprecated use the getTimeToLive method instead, which returns
316      * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
317      * @see #setTTL(byte)
318      */
319     @Deprecated
320     public byte getTTL() throws IOException {
321         if (isClosed())
322             throw new SocketException(&quot;Socket is closed&quot;);
323         return getImpl().getTTL();
324     }
325 
326     /**
327      * Get the default time-to-live for multicast packets sent out on
328      * the socket.
<span class="line-modified">329      * @throws    IOException if an I/O exception occurs while</span>
330      * getting the default time-to-live value
331      * @return the default time-to-live value
332      * @see #setTimeToLive(int)
<span class="line-added">333      * @since 1.2</span>
334      */
335     public int getTimeToLive() throws IOException {
336         if (isClosed())
337             throw new SocketException(&quot;Socket is closed&quot;);
338         return getImpl().getTimeToLive();
339     }
340 
341     /**
342      * Joins a multicast group. Its behavior may be affected by
343      * {@code setInterface} or {@code setNetworkInterface}.
344      *
345      * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">346      * calls its {@code checkMulticast} method with the</span>
<span class="line-modified">347      * {@code mcastaddr} argument as its argument.</span>
<span class="line-modified">348      *</span>
<span class="line-modified">349      * @param      mcastaddr is the multicast address to join</span>
<span class="line-modified">350      * @throws     IOException if there is an error joining,</span>
<span class="line-modified">351      *             or when the address is not a multicast address,</span>
<span class="line-modified">352      *             or the platform does not support multicasting</span>
<span class="line-modified">353      * @throws     SecurityException if a security manager exists and its</span>
<span class="line-modified">354      *             {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">355      * @deprecated This method does not accept the network interface on</span>
<span class="line-modified">356      *             which to join the multicast group. Use</span>
<span class="line-modified">357      *             {@link #joinGroup(SocketAddress, NetworkInterface)} instead.</span>
<span class="line-modified">358      * @see        SecurityManager#checkMulticast(InetAddress)</span>
359      */
<span class="line-added">360     @Deprecated(since=&quot;14&quot;)</span>
361     public void joinGroup(InetAddress mcastaddr) throws IOException {
362         if (isClosed()) {
363             throw new SocketException(&quot;Socket is closed&quot;);
364         }
365 
366         checkAddress(mcastaddr, &quot;joinGroup&quot;);
367         SecurityManager security = System.getSecurityManager();
368         if (security != null) {
369             security.checkMulticast(mcastaddr);
370         }
371 
372         if (!mcastaddr.isMulticastAddress()) {
373             throw new SocketException(&quot;Not a multicast address&quot;);
374         }
375 
376         /**
377          * required for some platforms where it&#39;s not possible to join
378          * a group without setting the interface first.
379          */
380         NetworkInterface defaultInterface = NetworkInterface.getDefault();
381 
382         if (!interfaceSet &amp;&amp; defaultInterface != null) {
383             setNetworkInterface(defaultInterface);
384         }
385 
386         getImpl().join(mcastaddr);
387     }
388 
389     /**
390      * Leave a multicast group. Its behavior may be affected by
391      * {@code setInterface} or {@code setNetworkInterface}.
392      *
393      * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">394      * calls its {@code checkMulticast} method with the</span>
<span class="line-modified">395      * {@code mcastaddr} argument as its argument.</span>
<span class="line-modified">396      *</span>
<span class="line-modified">397      * @param      mcastaddr is the multicast address to leave</span>
<span class="line-modified">398      * @throws     IOException if there is an error leaving</span>
<span class="line-modified">399      *             or when the address is not a multicast address.</span>
<span class="line-modified">400      * @throws     SecurityException if a security manager exists and its</span>
<span class="line-modified">401      *             {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">402      * @deprecated This method does not accept the network interface on which</span>
<span class="line-modified">403      *             to leave the multicast group. Use</span>
<span class="line-modified">404      *             {@link #leaveGroup(SocketAddress, NetworkInterface)} instead.</span>
<span class="line-added">405      * @see        SecurityManager#checkMulticast(InetAddress)</span>
406      */
<span class="line-added">407     @Deprecated(since=&quot;14&quot;)</span>
408     public void leaveGroup(InetAddress mcastaddr) throws IOException {
409         if (isClosed()) {
410             throw new SocketException(&quot;Socket is closed&quot;);
411         }
412 
413         checkAddress(mcastaddr, &quot;leaveGroup&quot;);
414         SecurityManager security = System.getSecurityManager();
415         if (security != null) {
416             security.checkMulticast(mcastaddr);
417         }
418 
419         if (!mcastaddr.isMulticastAddress()) {
420             throw new SocketException(&quot;Not a multicast address&quot;);
421         }
422 
423         getImpl().leave(mcastaddr);
424     }
425 
426     /**
427      * Joins the specified multicast group at the specified interface.
428      *
429      * &lt;p&gt;If there is a security manager, this method first
430      * calls its {@code checkMulticast} method
431      * with the {@code mcastaddr} argument
432      * as its argument.
433      *
<span class="line-modified">434      * @param  mcastaddr is the multicast address to join</span>
<span class="line-modified">435      * @param  netIf specifies the local interface to receive multicast</span>
<span class="line-modified">436      *         datagram packets, or {@code null} to defer to the interface set by</span>
<span class="line-modified">437      *         {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">438      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.</span>
<span class="line-modified">439      *         If {@code null}, and no interface has been set, the behaviour is</span>
<span class="line-modified">440      *         unspecified: any interface may be selected or the operation may fail</span>
<span class="line-modified">441      *         with a {@code SocketException}.</span>
<span class="line-modified">442      * @throws IOException if there is an error joining, or when the address</span>
<span class="line-modified">443      *         is not a multicast address, or the platform does not support</span>
<span class="line-modified">444      *         multicasting</span>
<span class="line-modified">445      * @throws SecurityException if a security manager exists and its</span>
<span class="line-modified">446      *         {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">447      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a</span>
<span class="line-modified">448      *         SocketAddress subclass not supported by this socket</span>
<span class="line-modified">449      * @see    SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-added">450      * @see    DatagramChannel#join(InetAddress, NetworkInterface)</span>
<span class="line-added">451      * @since  1.4</span>
452      */
453     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
454         throws IOException {
455         if (isClosed())
456             throw new SocketException(&quot;Socket is closed&quot;);
457 
458         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
459             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
460 
461         if (oldImpl)
462             throw new UnsupportedOperationException();
463 
464         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;joinGroup&quot;);
465         SecurityManager security = System.getSecurityManager();
466         if (security != null) {
467             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
468         }
469 
470         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
471             throw new SocketException(&quot;Not a multicast address&quot;);
472         }
473 
474         getImpl().joinGroup(mcastaddr, netIf);
475     }
476 
477     /**
478      * Leave a multicast group on a specified local interface.
479      *
480      * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">481      * calls its {@code checkMulticast} method with the</span>
<span class="line-modified">482      * {@code mcastaddr} argument as its argument.</span>
<span class="line-modified">483      *</span>
<span class="line-modified">484      * @param  mcastaddr is the multicast address to leave</span>
<span class="line-modified">485      * @param  netIf specifies the local interface or {@code null} to defer</span>
<span class="line-modified">486      *         to the interface set by</span>
<span class="line-modified">487      *         {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">488      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.</span>
<span class="line-modified">489      *         If {@code null}, and no interface has been set, the behaviour</span>
<span class="line-modified">490      *         is unspecified: any interface may be selected or the operation</span>
<span class="line-modified">491      *         may fail with a {@code SocketException}.</span>
<span class="line-modified">492      * @throws IOException if there is an error leaving or when the address</span>
<span class="line-modified">493      *         is not a multicast address.</span>
<span class="line-modified">494      * @throws SecurityException if a security manager exists and its</span>
<span class="line-modified">495      *         {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">496      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a</span>
<span class="line-modified">497      *         SocketAddress subclass not supported by this socket.</span>
<span class="line-modified">498      * @see    SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-added">499      * @since  1.4</span>
500      */
501     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
502         throws IOException {
503         if (isClosed())
504             throw new SocketException(&quot;Socket is closed&quot;);
505 
506         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
507             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
508 
509         if (oldImpl)
510             throw new UnsupportedOperationException();
511 
512         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;leaveGroup&quot;);
513         SecurityManager security = System.getSecurityManager();
514         if (security != null) {
515             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
516         }
517 
518         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
519             throw new SocketException(&quot;Not a multicast address&quot;);
520         }
521 
522         getImpl().leaveGroup(mcastaddr, netIf);
523      }
524 
525     /**
526      * Set the multicast network interface used by methods
527      * whose behavior would be affected by the value of the
528      * network interface. Useful for multihomed hosts.
<span class="line-modified">529      *</span>
<span class="line-modified">530      * @param      inf the InetAddress</span>
<span class="line-modified">531      * @throws     SocketException if there is an error in</span>
<span class="line-modified">532      *             the underlying protocol, such as a TCP error.</span>
<span class="line-added">533      * @deprecated The InetAddress may not uniquely identify</span>
<span class="line-added">534      *             the network interface. Use</span>
<span class="line-added">535      *             {@link #setNetworkInterface(NetworkInterface)} instead.</span>
<span class="line-added">536      * @see        #getInterface()</span>
537      */
<span class="line-added">538     @Deprecated(since=&quot;14&quot;)</span>
539     public void setInterface(InetAddress inf) throws SocketException {
540         if (isClosed()) {
541             throw new SocketException(&quot;Socket is closed&quot;);
542         }
543         checkAddress(inf, &quot;setInterface&quot;);
544         synchronized (infLock) {
545             getImpl().setOption(SocketOptions.IP_MULTICAST_IF, inf);
546             infAddress = inf;
547             interfaceSet = true;
548         }
549     }
550 
551     /**
552      * Retrieve the address of the network interface used for
553      * multicast packets.
554      *
<span class="line-modified">555      * @return     An {@code InetAddress} representing the address</span>
<span class="line-modified">556      *             of the network interface used for multicast packets,</span>
<span class="line-modified">557      *             or if no interface has been set, an {@code InetAddress}</span>
<span class="line-modified">558      *             representing any local address.</span>
<span class="line-modified">559      * @throws     SocketException if there is an error in the</span>
<span class="line-modified">560      *             underlying protocol, such as a TCP error.</span>
<span class="line-modified">561      * @deprecated The network interface may not be uniquely identified by</span>
<span class="line-modified">562      *             the InetAddress returned.</span>
<span class="line-added">563      *             Use {@link #getNetworkInterface()} instead.</span>
<span class="line-added">564      * @see        #setInterface(java.net.InetAddress)</span>
565      */
<span class="line-added">566     @Deprecated(since=&quot;14&quot;)</span>
567     public InetAddress getInterface() throws SocketException {
568         if (isClosed()) {
569             throw new SocketException(&quot;Socket is closed&quot;);
570         }
571         synchronized (infLock) {
572             InetAddress ia =
573                 (InetAddress)getImpl().getOption(SocketOptions.IP_MULTICAST_IF);
574 
575             /**
576              * No previous setInterface or interface can be
577              * set using setNetworkInterface
578              */
579             if (infAddress == null) {
580                 return ia;
581             }
582 
583             /**
584              * Same interface set with setInterface?
585              */
586             if (ia.equals(infAddress)) {
</pre>
<hr />
<pre>
602                     }
603                 }
604 
605                 /**
606                  * No match so reset infAddress to indicate that the
607                  * interface has changed via means
608                  */
609                 infAddress = null;
610                 return ia;
611             } catch (Exception e) {
612                 return ia;
613             }
614         }
615     }
616 
617     /**
618      * Specify the network interface for outgoing multicast datagrams
619      * sent on this socket.
620      *
621      * @param netIf the interface
<span class="line-modified">622      * @throws    SocketException if there is an error in</span>
623      * the underlying protocol, such as a TCP error.
624      * @see #getNetworkInterface()
625      * @since 1.4
626      */
627     public void setNetworkInterface(NetworkInterface netIf)
628         throws SocketException {
629 
630         synchronized (infLock) {
631             getImpl().setOption(SocketOptions.IP_MULTICAST_IF2, netIf);
632             infAddress = null;
633             interfaceSet = true;
634         }
635     }
636 
637     /**
638      * Get the multicast network interface set.
639      *
<span class="line-modified">640      * @throws SocketException if there is an error in</span>
<span class="line-modified">641      *         the underlying protocol, such as a TCP error.</span>
<span class="line-modified">642      * @return The multicast {@code NetworkInterface} currently set. A placeholder</span>
<span class="line-modified">643      *         NetworkInterface is returned when there is no interface set; it has</span>
<span class="line-modified">644      *         a single InetAddress to represent any local address.</span>
<span class="line-added">645      * @see    #setNetworkInterface(NetworkInterface)</span>
<span class="line-added">646      * @since  1.4</span>
647      */
648     public NetworkInterface getNetworkInterface() throws SocketException {
649         NetworkInterface ni
650             = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
<span class="line-modified">651         if (ni == null) {</span>
652             InetAddress[] addrs = new InetAddress[1];
653             addrs[0] = InetAddress.anyLocalAddress();
654             return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
655         } else {
656             return ni;
657         }
658     }
659 
660     /**
661      * Disable/Enable local loopback of multicast datagrams
662      * The option is used by the platform&#39;s networking code as a hint
663      * for setting whether multicast data will be looped back to
664      * the local socket.
665      *
666      * &lt;p&gt;Because this option is a hint, applications that want to
667      * verify what loopback mode is set to should call
668      * {@link #getLoopbackMode()}
<span class="line-modified">669      * @param      disable {@code true} to disable the LoopbackMode</span>
<span class="line-modified">670      * @throws     SocketException if an error occurs while setting the value</span>
<span class="line-modified">671      * @since      1.4</span>
<span class="line-modified">672      * @deprecated Use {@link #setOption(SocketOption, Object)} with</span>
<span class="line-added">673      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}</span>
<span class="line-added">674      *             instead. The loopback mode is enabled by default,</span>
<span class="line-added">675      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}</span>
<span class="line-added">676      *             disables it.</span>
<span class="line-added">677      * @see        #getLoopbackMode</span>
678      */
<span class="line-added">679     @Deprecated(since=&quot;14&quot;)</span>
680     public void setLoopbackMode(boolean disable) throws SocketException {
681         getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
682     }
683 
684     /**
685      * Get the setting for local loopback of multicast datagrams.
686      *
<span class="line-modified">687      * @throws     SocketException if an error occurs while getting the value</span>
<span class="line-modified">688      * @return     true if the LoopbackMode has been disabled</span>
<span class="line-modified">689      * @since      1.4</span>
<span class="line-modified">690      * @deprecated Use {@link #getOption(SocketOption)} with</span>
<span class="line-added">691      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}</span>
<span class="line-added">692      *             instead.</span>
<span class="line-added">693      * @see        #setLoopbackMode</span>
694      */
<span class="line-added">695     @Deprecated(since=&quot;14&quot;)</span>
696     public boolean getLoopbackMode() throws SocketException {
697         return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
698     }
699 
700     /**
701      * Sends a datagram packet to the destination, with a TTL (time-
702      * to-live) other than the default for the socket.  This method
703      * need only be used in instances where a particular TTL is desired;
704      * otherwise it is preferable to set a TTL once on the socket, and
705      * use that default TTL for all packets.  This method does &lt;B&gt;not
706      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
707      * affected by {@code setInterface}.
708      *
709      * &lt;p&gt;If there is a security manager, this method first performs some
710      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
711      * is true, this method calls the
712      * security manager&#39;s {@code checkMulticast} method
713      * with {@code p.getAddress()} and {@code ttl} as its arguments.
714      * If the evaluation of that expression is false,
715      * this method instead calls the security manager&#39;s
716      * {@code checkConnect} method with arguments
717      * {@code p.getAddress().getHostAddress()} and
718      * {@code p.getPort()}. Each call to a security manager method
719      * could result in a SecurityException if the operation is not allowed.
720      *
721      * @param p is the packet to be sent. The packet should contain
722      * the destination multicast ip address and the data to be sent.
723      * One does not need to be the member of the group to send
724      * packets to a destination multicast address.
725      * @param ttl optional time to live for multicast packet.
726      * default ttl is 1.
727      *
<span class="line-modified">728      * @throws     IOException is raised if an error occurs i.e</span>
<span class="line-modified">729      *             error while setting ttl.</span>
<span class="line-modified">730      * @throws     SecurityException  if a security manager exists and its</span>
731      *             {@code checkMulticast} or {@code checkConnect}
732      *             method doesn&#39;t allow the send.
<span class="line-added">733      * @throws     PortUnreachableException may be thrown if the socket is connected</span>
<span class="line-added">734      *             to a currently unreachable destination. Note, there is no</span>
<span class="line-added">735      *             guarantee that the exception will be thrown.</span>
<span class="line-added">736      * @throws     IllegalArgumentException if the socket is connected,</span>
<span class="line-added">737      *             and connected address and packet address differ, or</span>
<span class="line-added">738      *             if the socket is not connected and the packet address</span>
<span class="line-added">739      *             is not set or if its port is out of range.</span>
<span class="line-added">740      *</span>
741      *
742      * @deprecated Use the following code or its equivalent instead:
743      *  ......
744      *  int ttl = mcastSocket.getTimeToLive();
745      *  mcastSocket.setTimeToLive(newttl);
746      *  mcastSocket.send(p);
747      *  mcastSocket.setTimeToLive(ttl);
748      *  ......
749      *
750      * @see DatagramSocket#send
751      * @see DatagramSocket#receive
752      * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)
753      * @see SecurityManager#checkConnect
754      */
755     @Deprecated
756     public void send(DatagramPacket p, byte ttl)
757         throws IOException {
758             if (isClosed())
759                 throw new SocketException(&quot;Socket is closed&quot;);

760             synchronized(ttlLock) {
761                 synchronized(p) {
<span class="line-added">762                     InetAddress packetAddress = p.getAddress();</span>
<span class="line-added">763                     int packetPort = p.getPort();</span>
<span class="line-added">764                     checkAddress(packetAddress, &quot;send&quot;);</span>
765                     if (connectState == ST_NOT_CONNECTED) {
<span class="line-added">766                         if (packetAddress == null) {</span>
<span class="line-added">767                             throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added">768                         }</span>
<span class="line-added">769                         if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-added">770                             throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
771                         // Security manager makes sure that the multicast address
772                         // is allowed one and that the ttl used is less
773                         // than the allowed maxttl.
774                         SecurityManager security = System.getSecurityManager();
775                         if (security != null) {
<span class="line-modified">776                             if (packetAddress.isMulticastAddress()) {</span>
<span class="line-modified">777                                 security.checkMulticast(packetAddress, ttl);</span>
778                             } else {
<span class="line-modified">779                                 security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-modified">780                                         packetPort);</span>
781                             }
782                         }
783                     } else {
784                         // we&#39;re connected


785                         if (packetAddress == null) {
786                             p.setAddress(connectedAddress);
787                             p.setPort(connectedPort);
788                         } else if ((!packetAddress.equals(connectedAddress)) ||
<span class="line-modified">789                                 packetPort != connectedPort) {</span>
<span class="line-modified">790                             throw new IllegalArgumentException(&quot;connected address and packet address&quot; +</span>
791                                                         &quot; differ&quot;);
792                         }
793                     }
794                     byte dttl = getTTL();
795                     try {
796                         if (ttl != dttl) {
797                             // set the ttl
798                             getImpl().setTTL(ttl);
799                         }
800                         // call the datagram method to send
801                         getImpl().send(p);
802                     } finally {
803                         // set it back to default
804                         if (ttl != dttl) {
805                             getImpl().setTTL(dttl);
806                         }
807                     }
808                 } // synch p
809             }  //synch ttl
810     } //method
</pre>
</td>
</tr>
</table>
<center><a href="MalformedURLException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/ObjectOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.security.AccessController;
  31 import java.security.PrivilegedAction;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.List;
  35 import java.util.StringJoiner;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 import java.util.concurrent.ConcurrentMap;
  38 import static java.io.ObjectStreamClass.processQueue;
  39 import sun.reflect.misc.ReflectUtil;
  40 
  41 /**
  42  * An ObjectOutputStream writes primitive data types and graphs of Java objects
  43  * to an OutputStream.  The objects can be read (reconstituted) using an
  44  * ObjectInputStream.  Persistent storage of objects can be accomplished by
  45  * using a file for the stream.  If the stream is a network socket stream, the
  46  * objects can be reconstituted on another host or in another process.
  47  *
  48  * &lt;p&gt;Only objects that support the java.io.Serializable interface can be
  49  * written to streams.  The class of each serializable object is encoded
  50  * including the class name and signature of the class, the values of the
  51  * object&#39;s fields and arrays, and the closure of any other objects referenced
  52  * from the initial objects.
  53  *
  54  * &lt;p&gt;The method writeObject is used to write an object to the stream.  Any
  55  * object, including Strings and arrays, is written with writeObject. Multiple
  56  * objects or primitives can be written to the stream.  The objects must be
  57  * read back from the corresponding ObjectInputstream with the same types and
  58  * in the same order as they were written.
  59  *
  60  * &lt;p&gt;Primitive data types can also be written to the stream using the
  61  * appropriate methods from DataOutput. Strings can also be written using the
  62  * writeUTF method.
  63  *
  64  * &lt;p&gt;The default serialization mechanism for an object writes the class of the
  65  * object, the class signature, and the values of all non-transient and
  66  * non-static fields.  References to other objects (except in transient or
  67  * static fields) cause those objects to be written also. Multiple references
  68  * to a single object are encoded using a reference sharing mechanism so that
  69  * graphs of objects can be restored to the same shape as when the original was
  70  * written.
  71  *
  72  * &lt;p&gt;For example to write an object that can be read by the example in
  73  * ObjectInputStream:
  74  * &lt;br&gt;
  75  * &lt;pre&gt;
  76  *      FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);
  77  *      ObjectOutputStream oos = new ObjectOutputStream(fos);
  78  *
  79  *      oos.writeInt(12345);
  80  *      oos.writeObject(&quot;Today&quot;);
  81  *      oos.writeObject(new Date());
  82  *
  83  *      oos.close();
  84  * &lt;/pre&gt;
  85  *
  86  * &lt;p&gt;Classes that require special handling during the serialization and
  87  * deserialization process must implement special methods with these exact
  88  * signatures:
  89  * &lt;br&gt;
  90  * &lt;pre&gt;
  91  * private void readObject(java.io.ObjectInputStream stream)
  92  *     throws IOException, ClassNotFoundException;
  93  * private void writeObject(java.io.ObjectOutputStream stream)
  94  *     throws IOException
  95  * private void readObjectNoData()
  96  *     throws ObjectStreamException;
  97  * &lt;/pre&gt;
  98  *
  99  * &lt;p&gt;The writeObject method is responsible for writing the state of the object
 100  * for its particular class so that the corresponding readObject method can
 101  * restore it.  The method does not need to concern itself with the state
 102  * belonging to the object&#39;s superclasses or subclasses.  State is saved by
 103  * writing the individual fields to the ObjectOutputStream using the
 104  * writeObject method or by using the methods for primitive data types
 105  * supported by DataOutput.
 106  *
 107  * &lt;p&gt;Serialization does not write out the fields of any object that does not
 108  * implement the java.io.Serializable interface.  Subclasses of Objects that
 109  * are not serializable can be serializable. In this case the non-serializable
 110  * class must have a no-arg constructor to allow its fields to be initialized.
 111  * In this case it is the responsibility of the subclass to save and restore
 112  * the state of the non-serializable class. It is frequently the case that the
 113  * fields of that class are accessible (public, package, or protected) or that
 114  * there are get and set methods that can be used to restore the state.
 115  *
 116  * &lt;p&gt;Serialization of an object can be prevented by implementing writeObject
 117  * and readObject methods that throw the NotSerializableException.  The
 118  * exception will be caught by the ObjectOutputStream and abort the
 119  * serialization process.
 120  *
 121  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 122  * complete control over the contents and format of the object&#39;s serialized
 123  * form.  The methods of the Externalizable interface, writeExternal and
 124  * readExternal, are called to save and restore the objects state.  When
 125  * implemented by a class they can write and read their own state using all of
 126  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 127  * the objects to handle any versioning that occurs.
 128  *
 129  * &lt;p&gt;Enum constants are serialized differently than ordinary serializable or
 130  * externalizable objects.  The serialized form of an enum constant consists
 131  * solely of its name; field values of the constant are not transmitted.  To
 132  * serialize an enum constant, ObjectOutputStream writes the string returned by
 133  * the constant&#39;s name method.  Like other serializable or externalizable
 134  * objects, enum constants can function as the targets of back references
 135  * appearing subsequently in the serialization stream.  The process by which
 136  * enum constants are serialized cannot be customized; any class-specific
 137  * writeObject and writeReplace methods defined by enum types are ignored
 138  * during serialization.  Similarly, any serialPersistentFields or
 139  * serialVersionUID field declarations are also ignored--all enum types have a
 140  * fixed serialVersionUID of 0L.
 141  *
 142  * &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
 143  * written to the ObjectOutputStream in block-data records. A block data record
 144  * is composed of a header and data. The block data header consists of a marker
 145  * and the number of bytes to follow the header.  Consecutive primitive data
 146  * writes are merged into one block-data record.  The blocking factor used for
 147  * a block-data record will be 1024 bytes.  Each block-data record will be
 148  * filled up to 1024 bytes, or be written whenever there is a termination of
 149  * block-data mode.  Calls to the ObjectOutputStream methods writeObject,
 150  * defaultWriteObject and writeFields initially terminate any existing
 151  * block-data record.
 152  *
<a name="2" id="anc2"></a><span class="line-added"> 153  * @implSpec</span>
<span class="line-added"> 154  * Records are serialized differently than ordinary serializable or externalizable</span>
<span class="line-added"> 155  * objects, see &lt;a href=&quot;ObjectInputStream.html#record-serialization&quot;&gt;record serialization&lt;/a&gt;.</span>
<span class="line-added"> 156  *</span>
 157  * @author      Mike Warres
 158  * @author      Roger Riggs
 159  * @see java.io.DataOutput
 160  * @see java.io.ObjectInputStream
 161  * @see java.io.Serializable
 162  * @see java.io.Externalizable
 163  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/output.html&quot;&gt;
 164  *     Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;
 165  * @since       1.1
 166  */
 167 public class ObjectOutputStream
 168     extends OutputStream implements ObjectOutput, ObjectStreamConstants
 169 {
 170 
 171     private static class Caches {
 172         /** cache of subclass security audit results */
 173         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 174             new ConcurrentHashMap&lt;&gt;();
 175 
 176         /** queue for WeakReferences to audited subclasses */
 177         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
 178             new ReferenceQueue&lt;&gt;();
 179     }
 180 
 181     /** filter stream for handling block data conversion */
 182     private final BlockDataOutputStream bout;
 183     /** obj -&gt; wire handle map */
 184     private final HandleTable handles;
 185     /** obj -&gt; replacement obj map */
 186     private final ReplaceTable subs;
 187     /** stream protocol version */
 188     private int protocol = PROTOCOL_VERSION_2;
 189     /** recursion depth */
 190     private int depth;
 191 
 192     /** buffer for writing primitive field values */
 193     private byte[] primVals;
 194 
 195     /** if true, invoke writeObjectOverride() instead of writeObject() */
 196     private final boolean enableOverride;
 197     /** if true, invoke replaceObject() */
 198     private boolean enableReplace;
 199 
 200     // values below valid only during upcalls to writeObject()/writeExternal()
 201     /**
 202      * Context during upcalls to class-defined writeObject methods; holds
 203      * object currently being serialized and descriptor for current class.
 204      * Null when not during writeObject upcall.
 205      */
 206     private SerialCallbackContext curContext;
 207     /** current PutField object */
 208     private PutFieldImpl curPut;
 209 
 210     /** custom storage for debug trace info */
 211     private final DebugTraceInfoStack debugInfoStack;
 212 
 213     /**
 214      * value of &quot;sun.io.serialization.extendedDebugInfo&quot; property,
 215      * as true or false for extended information about exception&#39;s place
 216      */
 217     private static final boolean extendedDebugInfo =
 218         java.security.AccessController.doPrivileged(
 219             new sun.security.action.GetBooleanAction(
 220                 &quot;sun.io.serialization.extendedDebugInfo&quot;)).booleanValue();
 221 
 222     /**
 223      * Creates an ObjectOutputStream that writes to the specified OutputStream.
 224      * This constructor writes the serialization stream header to the
 225      * underlying stream; callers may wish to flush the stream immediately to
 226      * ensure that constructors for receiving ObjectInputStreams will not block
 227      * when reading the header.
 228      *
 229      * &lt;p&gt;If a security manager is installed, this constructor will check for
 230      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 231      * directly or indirectly by the constructor of a subclass which overrides
 232      * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared
 233      * methods.
 234      *
 235      * @param   out output stream to write to
 236      * @throws  IOException if an I/O error occurs while writing stream header
 237      * @throws  SecurityException if untrusted subclass illegally overrides
 238      *          security-sensitive methods
<a name="3" id="anc3"></a><span class="line-modified"> 239      * @throws  NullPointerException if {@code out} is {@code null}</span>
 240      * @since   1.4
 241      * @see     ObjectOutputStream#ObjectOutputStream()
 242      * @see     ObjectOutputStream#putFields()
 243      * @see     ObjectInputStream#ObjectInputStream(InputStream)
 244      */
 245     public ObjectOutputStream(OutputStream out) throws IOException {
 246         verifySubclass();
 247         bout = new BlockDataOutputStream(out);
 248         handles = new HandleTable(10, (float) 3.00);
 249         subs = new ReplaceTable(10, (float) 3.00);
 250         enableOverride = false;
 251         writeStreamHeader();
 252         bout.setBlockDataMode(true);
 253         if (extendedDebugInfo) {
 254             debugInfoStack = new DebugTraceInfoStack();
 255         } else {
 256             debugInfoStack = null;
 257         }
 258     }
 259 
 260     /**
 261      * Provide a way for subclasses that are completely reimplementing
 262      * ObjectOutputStream to not have to allocate private data just used by
 263      * this implementation of ObjectOutputStream.
 264      *
 265      * &lt;p&gt;If there is a security manager installed, this method first calls the
<a name="4" id="anc4"></a><span class="line-modified"> 266      * security manager&#39;s {@code checkPermission} method with a</span>
<span class="line-modified"> 267      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}</span>
 268      * permission to ensure it&#39;s ok to enable subclassing.
 269      *
 270      * @throws  SecurityException if a security manager exists and its
<a name="5" id="anc5"></a><span class="line-modified"> 271      *          {@code checkPermission} method denies enabling</span>
 272      *          subclassing.
 273      * @throws  IOException if an I/O error occurs while creating this stream
 274      * @see SecurityManager#checkPermission
 275      * @see java.io.SerializablePermission
 276      */
 277     protected ObjectOutputStream() throws IOException, SecurityException {
 278         SecurityManager sm = System.getSecurityManager();
 279         if (sm != null) {
 280             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 281         }
 282         bout = null;
 283         handles = null;
 284         subs = null;
 285         enableOverride = true;
 286         debugInfoStack = null;
 287     }
 288 
 289     /**
 290      * Specify stream protocol version to use when writing the stream.
 291      *
 292      * &lt;p&gt;This routine provides a hook to enable the current version of
 293      * Serialization to write in a format that is backwards compatible to a
 294      * previous version of the stream format.
 295      *
 296      * &lt;p&gt;Every effort will be made to avoid introducing additional
 297      * backwards incompatibilities; however, sometimes there is no
 298      * other alternative.
 299      *
 300      * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.
 301      * @throws  IllegalStateException if called after any objects
 302      *          have been serialized.
 303      * @throws  IllegalArgumentException if invalid version is passed in.
 304      * @throws  IOException if I/O errors occur
 305      * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1
 306      * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2
 307      * @since   1.2
 308      */
 309     public void useProtocolVersion(int version) throws IOException {
 310         if (handles.size() != 0) {
 311             // REMIND: implement better check for pristine stream?
 312             throw new IllegalStateException(&quot;stream non-empty&quot;);
 313         }
 314         switch (version) {
 315             case PROTOCOL_VERSION_1:
 316             case PROTOCOL_VERSION_2:
 317                 protocol = version;
 318                 break;
 319 
 320             default:
 321                 throw new IllegalArgumentException(
 322                     &quot;unknown version: &quot; + version);
 323         }
 324     }
 325 
 326     /**
 327      * Write the specified object to the ObjectOutputStream.  The class of the
 328      * object, the signature of the class, and the values of the non-transient
 329      * and non-static fields of the class and all of its supertypes are
 330      * written.  Default serialization for a class can be overridden using the
 331      * writeObject and the readObject methods.  Objects referenced by this
 332      * object are written transitively so that a complete equivalent graph of
 333      * objects can be reconstructed by an ObjectInputStream.
 334      *
 335      * &lt;p&gt;Exceptions are thrown for problems with the OutputStream and for
 336      * classes that should not be serialized.  All exceptions are fatal to the
 337      * OutputStream, which is left in an indeterminate state, and it is up to
 338      * the caller to ignore or recover the stream state.
 339      *
 340      * @throws  InvalidClassException Something is wrong with a class used by
 341      *          serialization.
 342      * @throws  NotSerializableException Some object to be serialized does not
 343      *          implement the java.io.Serializable interface.
 344      * @throws  IOException Any exception thrown by the underlying
 345      *          OutputStream.
 346      */
 347     public final void writeObject(Object obj) throws IOException {
 348         if (enableOverride) {
 349             writeObjectOverride(obj);
 350             return;
 351         }
 352         try {
 353             writeObject0(obj, false);
 354         } catch (IOException ex) {
 355             if (depth == 0) {
 356                 writeFatalException(ex);
 357             }
 358             throw ex;
 359         }
 360     }
 361 
 362     /**
 363      * Method used by subclasses to override the default writeObject method.
<a name="6" id="anc6"></a><span class="line-modified"> 364      * This method is called by trusted subclasses of ObjectOutputStream that</span>
<span class="line-modified"> 365      * constructed ObjectOutputStream using the protected no-arg constructor.</span>
 366      * The subclass is expected to provide an override method with the modifier
 367      * &quot;final&quot;.
 368      *
 369      * @param   obj object to be written to the underlying stream
 370      * @throws  IOException if there are I/O errors while writing to the
 371      *          underlying stream
 372      * @see #ObjectOutputStream()
 373      * @see #writeObject(Object)
 374      * @since 1.2
 375      */
 376     protected void writeObjectOverride(Object obj) throws IOException {
 377     }
 378 
 379     /**
 380      * Writes an &quot;unshared&quot; object to the ObjectOutputStream.  This method is
 381      * identical to writeObject, except that it always writes the given object
 382      * as a new, unique object in the stream (as opposed to a back-reference
 383      * pointing to a previously serialized instance).  Specifically:
 384      * &lt;ul&gt;
 385      *   &lt;li&gt;An object written via writeUnshared is always serialized in the
 386      *       same manner as a newly appearing object (an object that has not
 387      *       been written to the stream yet), regardless of whether or not the
 388      *       object has been written previously.
 389      *
 390      *   &lt;li&gt;If writeObject is used to write an object that has been previously
 391      *       written with writeUnshared, the previous writeUnshared operation
 392      *       is treated as if it were a write of a separate object.  In other
 393      *       words, ObjectOutputStream will never generate back-references to
 394      *       object data written by calls to writeUnshared.
 395      * &lt;/ul&gt;
 396      * While writing an object via writeUnshared does not in itself guarantee a
 397      * unique reference to the object when it is deserialized, it allows a
 398      * single object to be defined multiple times in a stream, so that multiple
 399      * calls to readUnshared by the receiver will not conflict.  Note that the
 400      * rules described above only apply to the base-level object written with
 401      * writeUnshared, and not to any transitively referenced sub-objects in the
 402      * object graph to be serialized.
 403      *
 404      * &lt;p&gt;ObjectOutputStream subclasses which override this method can only be
 405      * constructed in security contexts possessing the
 406      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 407      * instantiate such a subclass without this permission will cause a
 408      * SecurityException to be thrown.
 409      *
 410      * @param   obj object to write to stream
 411      * @throws  NotSerializableException if an object in the graph to be
 412      *          serialized does not implement the Serializable interface
 413      * @throws  InvalidClassException if a problem exists with the class of an
 414      *          object to be serialized
 415      * @throws  IOException if an I/O error occurs during serialization
 416      * @since 1.4
 417      */
 418     public void writeUnshared(Object obj) throws IOException {
 419         try {
 420             writeObject0(obj, true);
 421         } catch (IOException ex) {
 422             if (depth == 0) {
 423                 writeFatalException(ex);
 424             }
 425             throw ex;
 426         }
 427     }
 428 
 429     /**
 430      * Write the non-static and non-transient fields of the current class to
 431      * this stream.  This may only be called from the writeObject method of the
 432      * class being serialized. It will throw the NotActiveException if it is
 433      * called otherwise.
 434      *
 435      * @throws  IOException if I/O errors occur while writing to the underlying
<a name="7" id="anc7"></a><span class="line-modified"> 436      *          {@code OutputStream}</span>
 437      */
 438     public void defaultWriteObject() throws IOException {
 439         SerialCallbackContext ctx = curContext;
 440         if (ctx == null) {
 441             throw new NotActiveException(&quot;not in call to writeObject&quot;);
 442         }
 443         Object curObj = ctx.getObj();
 444         ObjectStreamClass curDesc = ctx.getDesc();
 445         bout.setBlockDataMode(false);
 446         defaultWriteFields(curObj, curDesc);
 447         bout.setBlockDataMode(true);
 448     }
 449 
 450     /**
 451      * Retrieve the object used to buffer persistent fields to be written to
 452      * the stream.  The fields will be written to the stream when writeFields
 453      * method is called.
 454      *
 455      * @return  an instance of the class Putfield that holds the serializable
 456      *          fields
 457      * @throws  IOException if I/O errors occur
 458      * @since 1.2
 459      */
 460     public ObjectOutputStream.PutField putFields() throws IOException {
 461         if (curPut == null) {
 462             SerialCallbackContext ctx = curContext;
 463             if (ctx == null) {
 464                 throw new NotActiveException(&quot;not in call to writeObject&quot;);
 465             }
 466             ctx.checkAndSetUsed();
 467             ObjectStreamClass curDesc = ctx.getDesc();
 468             curPut = new PutFieldImpl(curDesc);
 469         }
 470         return curPut;
 471     }
 472 
 473     /**
 474      * Write the buffered fields to the stream.
 475      *
 476      * @throws  IOException if I/O errors occur while writing to the underlying
 477      *          stream
 478      * @throws  NotActiveException Called when a classes writeObject method was
 479      *          not called to write the state of the object.
 480      * @since 1.2
 481      */
 482     public void writeFields() throws IOException {
 483         if (curPut == null) {
 484             throw new NotActiveException(&quot;no current PutField object&quot;);
 485         }
 486         bout.setBlockDataMode(false);
 487         curPut.writeFields();
 488         bout.setBlockDataMode(true);
 489     }
 490 
 491     /**
 492      * Reset will disregard the state of any objects already written to the
 493      * stream.  The state is reset to be the same as a new ObjectOutputStream.
 494      * The current point in the stream is marked as reset so the corresponding
 495      * ObjectInputStream will be reset at the same point.  Objects previously
 496      * written to the stream will not be referred to as already being in the
 497      * stream.  They will be written to the stream again.
 498      *
 499      * @throws  IOException if reset() is invoked while serializing an object.
 500      */
 501     public void reset() throws IOException {
 502         if (depth != 0) {
 503             throw new IOException(&quot;stream active&quot;);
 504         }
 505         bout.setBlockDataMode(false);
 506         bout.writeByte(TC_RESET);
 507         clear();
 508         bout.setBlockDataMode(true);
 509     }
 510 
 511     /**
 512      * Subclasses may implement this method to allow class data to be stored in
 513      * the stream. By default this method does nothing.  The corresponding
 514      * method in ObjectInputStream is resolveClass.  This method is called
 515      * exactly once for each unique class in the stream.  The class name and
 516      * signature will have already been written to the stream.  This method may
 517      * make free use of the ObjectOutputStream to save any representation of
 518      * the class it deems suitable (for example, the bytes of the class file).
 519      * The resolveClass method in the corresponding subclass of
 520      * ObjectInputStream must read and use any data or objects written by
 521      * annotateClass.
 522      *
 523      * @param   cl the class to annotate custom data for
 524      * @throws  IOException Any exception thrown by the underlying
 525      *          OutputStream.
 526      */
 527     protected void annotateClass(Class&lt;?&gt; cl) throws IOException {
 528     }
 529 
 530     /**
 531      * Subclasses may implement this method to store custom data in the stream
 532      * along with descriptors for dynamic proxy classes.
 533      *
 534      * &lt;p&gt;This method is called exactly once for each unique proxy class
 535      * descriptor in the stream.  The default implementation of this method in
<a name="8" id="anc8"></a><span class="line-modified"> 536      * {@code ObjectOutputStream} does nothing.</span>
 537      *
<a name="9" id="anc9"></a><span class="line-modified"> 538      * &lt;p&gt;The corresponding method in {@code ObjectInputStream} is</span>
<span class="line-modified"> 539      * {@code resolveProxyClass}.  For a given subclass of</span>
<span class="line-modified"> 540      * {@code ObjectOutputStream} that overrides this method, the</span>
<span class="line-modified"> 541      * {@code resolveProxyClass} method in the corresponding subclass of</span>
<span class="line-modified"> 542      * {@code ObjectInputStream} must read any data or objects written by</span>
<span class="line-modified"> 543      * {@code annotateProxyClass}.</span>
 544      *
 545      * @param   cl the proxy class to annotate custom data for
 546      * @throws  IOException any exception thrown by the underlying
<a name="10" id="anc10"></a><span class="line-modified"> 547      *          {@code OutputStream}</span>
 548      * @see ObjectInputStream#resolveProxyClass(String[])
 549      * @since   1.3
 550      */
 551     protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException {
 552     }
 553 
 554     /**
 555      * This method will allow trusted subclasses of ObjectOutputStream to
 556      * substitute one object for another during serialization. Replacing
 557      * objects is disabled until enableReplaceObject is called. The
 558      * enableReplaceObject method checks that the stream requesting to do
 559      * replacement can be trusted.  The first occurrence of each object written
 560      * into the serialization stream is passed to replaceObject.  Subsequent
 561      * references to the object are replaced by the object returned by the
 562      * original call to replaceObject.  To ensure that the private state of
 563      * objects is not unintentionally exposed, only trusted streams may use
 564      * replaceObject.
 565      *
 566      * &lt;p&gt;The ObjectOutputStream.writeObject method takes a parameter of type
 567      * Object (as opposed to type Serializable) to allow for cases where
 568      * non-serializable objects are replaced by serializable ones.
 569      *
 570      * &lt;p&gt;When a subclass is replacing objects it must insure that either a
 571      * complementary substitution must be made during deserialization or that
 572      * the substituted object is compatible with every field where the
 573      * reference will be stored.  Objects whose type is not a subclass of the
 574      * type of the field or array element abort the serialization by raising an
 575      * exception and the object is not be stored.
 576      *
 577      * &lt;p&gt;This method is called only once when each object is first
 578      * encountered.  All subsequent references to the object will be redirected
 579      * to the new object. This method should return the object to be
 580      * substituted or the original object.
 581      *
 582      * &lt;p&gt;Null can be returned as the object to be substituted, but may cause
 583      * NullReferenceException in classes that contain references to the
 584      * original object since they may be expecting an object instead of
 585      * null.
 586      *
 587      * @param   obj the object to be replaced
 588      * @return  the alternate object that replaced the specified one
 589      * @throws  IOException Any exception thrown by the underlying
 590      *          OutputStream.
 591      */
 592     protected Object replaceObject(Object obj) throws IOException {
 593         return obj;
 594     }
 595 
 596     /**
 597      * Enables the stream to do replacement of objects written to the stream.  When
 598      * enabled, the {@link #replaceObject} method is called for every object being
 599      * serialized.
 600      *
 601      * &lt;p&gt;If object replacement is currently not enabled, and
 602      * {@code enable} is true, and there is a security manager installed,
 603      * this method first calls the security manager&#39;s
 604      * {@code checkPermission} method with the
 605      * {@code SerializablePermission(&quot;enableSubstitution&quot;)} permission to
 606      * ensure that the caller is permitted to enable the stream to do replacement
 607      * of objects written to the stream.
 608      *
 609      * @param   enable true for enabling use of {@code replaceObject} for
 610      *          every object being serialized
 611      * @return  the previous setting before this method was invoked
 612      * @throws  SecurityException if a security manager exists and its
 613      *          {@code checkPermission} method denies enabling the stream
 614      *          to do replacement of objects written to the stream.
 615      * @see SecurityManager#checkPermission
 616      * @see java.io.SerializablePermission
 617      */
 618     protected boolean enableReplaceObject(boolean enable)
 619         throws SecurityException
 620     {
 621         if (enable == enableReplace) {
 622             return enable;
 623         }
 624         if (enable) {
 625             SecurityManager sm = System.getSecurityManager();
 626             if (sm != null) {
 627                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 628             }
 629         }
 630         enableReplace = enable;
 631         return !enableReplace;
 632     }
 633 
 634     /**
 635      * The writeStreamHeader method is provided so subclasses can append or
 636      * prepend their own header to the stream.  It writes the magic number and
 637      * version to the stream.
 638      *
 639      * @throws  IOException if I/O errors occur while writing to the underlying
 640      *          stream
 641      */
 642     protected void writeStreamHeader() throws IOException {
 643         bout.writeShort(STREAM_MAGIC);
 644         bout.writeShort(STREAM_VERSION);
 645     }
 646 
 647     /**
 648      * Write the specified class descriptor to the ObjectOutputStream.  Class
 649      * descriptors are used to identify the classes of objects written to the
 650      * stream.  Subclasses of ObjectOutputStream may override this method to
 651      * customize the way in which class descriptors are written to the
 652      * serialization stream.  The corresponding method in ObjectInputStream,
<a name="11" id="anc11"></a><span class="line-modified"> 653      * {@code readClassDescriptor}, should then be overridden to</span>
 654      * reconstitute the class descriptor from its custom stream representation.
 655      * By default, this method writes class descriptors according to the format
 656      * defined in the Object Serialization specification.
 657      *
 658      * &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
 659      * is not using the old serialization stream format (set by calling
<a name="12" id="anc12"></a><span class="line-modified"> 660      * ObjectOutputStream&#39;s {@code useProtocolVersion} method).  If this</span>
 661      * serialization stream is using the old format
<a name="13" id="anc13"></a><span class="line-modified"> 662      * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written</span>
 663      * internally in a manner that cannot be overridden or customized.
 664      *
 665      * @param   desc class descriptor to write to the stream
 666      * @throws  IOException If an I/O error has occurred.
 667      * @see java.io.ObjectInputStream#readClassDescriptor()
 668      * @see #useProtocolVersion(int)
 669      * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1
 670      * @since 1.3
 671      */
 672     protected void writeClassDescriptor(ObjectStreamClass desc)
 673         throws IOException
 674     {
 675         desc.writeNonProxy(this);
 676     }
 677 
 678     /**
 679      * Writes a byte. This method will block until the byte is actually
 680      * written.
 681      *
 682      * @param   val the byte to be written to the stream
 683      * @throws  IOException If an I/O error has occurred.
 684      */
 685     public void write(int val) throws IOException {
 686         bout.write(val);
 687     }
 688 
 689     /**
 690      * Writes an array of bytes. This method will block until the bytes are
 691      * actually written.
 692      *
 693      * @param   buf the data to be written
 694      * @throws  IOException If an I/O error has occurred.
 695      */
 696     public void write(byte[] buf) throws IOException {
 697         bout.write(buf, 0, buf.length, false);
 698     }
 699 
 700     /**
 701      * Writes a sub array of bytes.
 702      *
 703      * @param   buf the data to be written
 704      * @param   off the start offset in the data
 705      * @param   len the number of bytes that are written
 706      * @throws  IOException If an I/O error has occurred.
 707      */
 708     public void write(byte[] buf, int off, int len) throws IOException {
 709         if (buf == null) {
 710             throw new NullPointerException();
 711         }
 712         int endoff = off + len;
 713         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
 714             throw new IndexOutOfBoundsException();
 715         }
 716         bout.write(buf, off, len, false);
 717     }
 718 
 719     /**
 720      * Flushes the stream. This will write any buffered output bytes and flush
 721      * through to the underlying stream.
 722      *
 723      * @throws  IOException If an I/O error has occurred.
 724      */
 725     public void flush() throws IOException {
 726         bout.flush();
 727     }
 728 
 729     /**
 730      * Drain any buffered data in ObjectOutputStream.  Similar to flush but
 731      * does not propagate the flush to the underlying stream.
 732      *
 733      * @throws  IOException if I/O errors occur while writing to the underlying
 734      *          stream
 735      */
 736     protected void drain() throws IOException {
 737         bout.drain();
 738     }
 739 
 740     /**
 741      * Closes the stream. This method must be called to release any resources
 742      * associated with the stream.
 743      *
 744      * @throws  IOException If an I/O error has occurred.
 745      */
 746     public void close() throws IOException {
 747         flush();
 748         clear();
 749         bout.close();
 750     }
 751 
 752     /**
 753      * Writes a boolean.
 754      *
 755      * @param   val the boolean to be written
 756      * @throws  IOException if I/O errors occur while writing to the underlying
 757      *          stream
 758      */
 759     public void writeBoolean(boolean val) throws IOException {
 760         bout.writeBoolean(val);
 761     }
 762 
 763     /**
 764      * Writes an 8 bit byte.
 765      *
 766      * @param   val the byte value to be written
 767      * @throws  IOException if I/O errors occur while writing to the underlying
 768      *          stream
 769      */
 770     public void writeByte(int val) throws IOException  {
 771         bout.writeByte(val);
 772     }
 773 
 774     /**
 775      * Writes a 16 bit short.
 776      *
 777      * @param   val the short value to be written
 778      * @throws  IOException if I/O errors occur while writing to the underlying
 779      *          stream
 780      */
 781     public void writeShort(int val)  throws IOException {
 782         bout.writeShort(val);
 783     }
 784 
 785     /**
 786      * Writes a 16 bit char.
 787      *
 788      * @param   val the char value to be written
 789      * @throws  IOException if I/O errors occur while writing to the underlying
 790      *          stream
 791      */
 792     public void writeChar(int val)  throws IOException {
 793         bout.writeChar(val);
 794     }
 795 
 796     /**
 797      * Writes a 32 bit int.
 798      *
 799      * @param   val the integer value to be written
 800      * @throws  IOException if I/O errors occur while writing to the underlying
 801      *          stream
 802      */
 803     public void writeInt(int val)  throws IOException {
 804         bout.writeInt(val);
 805     }
 806 
 807     /**
 808      * Writes a 64 bit long.
 809      *
 810      * @param   val the long value to be written
 811      * @throws  IOException if I/O errors occur while writing to the underlying
 812      *          stream
 813      */
 814     public void writeLong(long val)  throws IOException {
 815         bout.writeLong(val);
 816     }
 817 
 818     /**
 819      * Writes a 32 bit float.
 820      *
 821      * @param   val the float value to be written
 822      * @throws  IOException if I/O errors occur while writing to the underlying
 823      *          stream
 824      */
 825     public void writeFloat(float val) throws IOException {
 826         bout.writeFloat(val);
 827     }
 828 
 829     /**
 830      * Writes a 64 bit double.
 831      *
 832      * @param   val the double value to be written
 833      * @throws  IOException if I/O errors occur while writing to the underlying
 834      *          stream
 835      */
 836     public void writeDouble(double val) throws IOException {
 837         bout.writeDouble(val);
 838     }
 839 
 840     /**
 841      * Writes a String as a sequence of bytes.
 842      *
 843      * @param   str the String of bytes to be written
 844      * @throws  IOException if I/O errors occur while writing to the underlying
 845      *          stream
 846      */
 847     public void writeBytes(String str) throws IOException {
 848         bout.writeBytes(str);
 849     }
 850 
 851     /**
 852      * Writes a String as a sequence of chars.
 853      *
 854      * @param   str the String of chars to be written
 855      * @throws  IOException if I/O errors occur while writing to the underlying
 856      *          stream
 857      */
 858     public void writeChars(String str) throws IOException {
 859         bout.writeChars(str);
 860     }
 861 
 862     /**
 863      * Primitive data write of this String in
 864      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 865      * format.  Note that there is a
 866      * significant difference between writing a String into the stream as
 867      * primitive data or as an Object. A String instance written by writeObject
 868      * is written into the stream as a String initially. Future writeObject()
 869      * calls write references to the string into the stream.
 870      *
 871      * @param   str the String to be written
 872      * @throws  IOException if I/O errors occur while writing to the underlying
 873      *          stream
 874      */
 875     public void writeUTF(String str) throws IOException {
 876         bout.writeUTF(str);
 877     }
 878 
 879     /**
 880      * Provide programmatic access to the persistent fields to be written
 881      * to ObjectOutput.
 882      *
 883      * @since 1.2
 884      */
 885     public abstract static class PutField {
<a name="14" id="anc14"></a><span class="line-added"> 886         /**</span>
<span class="line-added"> 887          * Constructor for subclasses to call.</span>
<span class="line-added"> 888          */</span>
<span class="line-added"> 889         public PutField() {}</span>
 890 
 891         /**
 892          * Put the value of the named boolean field into the persistent field.
 893          *
 894          * @param  name the name of the serializable field
 895          * @param  val the value to assign to the field
<a name="15" id="anc15"></a><span class="line-modified"> 896          * @throws IllegalArgumentException if {@code name} does not</span>
 897          * match the name of a serializable field for the class whose fields
 898          * are being written, or if the type of the named field is not
<a name="16" id="anc16"></a><span class="line-modified"> 899          * {@code boolean}</span>
 900          */
 901         public abstract void put(String name, boolean val);
 902 
 903         /**
 904          * Put the value of the named byte field into the persistent field.
 905          *
 906          * @param  name the name of the serializable field
 907          * @param  val the value to assign to the field
<a name="17" id="anc17"></a><span class="line-modified"> 908          * @throws IllegalArgumentException if {@code name} does not</span>
 909          * match the name of a serializable field for the class whose fields
 910          * are being written, or if the type of the named field is not
<a name="18" id="anc18"></a><span class="line-modified"> 911          * {@code byte}</span>
 912          */
 913         public abstract void put(String name, byte val);
 914 
 915         /**
 916          * Put the value of the named char field into the persistent field.
 917          *
 918          * @param  name the name of the serializable field
 919          * @param  val the value to assign to the field
<a name="19" id="anc19"></a><span class="line-modified"> 920          * @throws IllegalArgumentException if {@code name} does not</span>
 921          * match the name of a serializable field for the class whose fields
 922          * are being written, or if the type of the named field is not
<a name="20" id="anc20"></a><span class="line-modified"> 923          * {@code char}</span>
 924          */
 925         public abstract void put(String name, char val);
 926 
 927         /**
 928          * Put the value of the named short field into the persistent field.
 929          *
 930          * @param  name the name of the serializable field
 931          * @param  val the value to assign to the field
<a name="21" id="anc21"></a><span class="line-modified"> 932          * @throws IllegalArgumentException if {@code name} does not</span>
 933          * match the name of a serializable field for the class whose fields
 934          * are being written, or if the type of the named field is not
<a name="22" id="anc22"></a><span class="line-modified"> 935          * {@code short}</span>
 936          */
 937         public abstract void put(String name, short val);
 938 
 939         /**
 940          * Put the value of the named int field into the persistent field.
 941          *
 942          * @param  name the name of the serializable field
 943          * @param  val the value to assign to the field
<a name="23" id="anc23"></a><span class="line-modified"> 944          * @throws IllegalArgumentException if {@code name} does not</span>
 945          * match the name of a serializable field for the class whose fields
 946          * are being written, or if the type of the named field is not
<a name="24" id="anc24"></a><span class="line-modified"> 947          * {@code int}</span>
 948          */
 949         public abstract void put(String name, int val);
 950 
 951         /**
 952          * Put the value of the named long field into the persistent field.
 953          *
 954          * @param  name the name of the serializable field
 955          * @param  val the value to assign to the field
<a name="25" id="anc25"></a><span class="line-modified"> 956          * @throws IllegalArgumentException if {@code name} does not</span>
 957          * match the name of a serializable field for the class whose fields
 958          * are being written, or if the type of the named field is not
<a name="26" id="anc26"></a><span class="line-modified"> 959          * {@code long}</span>
 960          */
 961         public abstract void put(String name, long val);
 962 
 963         /**
 964          * Put the value of the named float field into the persistent field.
 965          *
 966          * @param  name the name of the serializable field
 967          * @param  val the value to assign to the field
<a name="27" id="anc27"></a><span class="line-modified"> 968          * @throws IllegalArgumentException if {@code name} does not</span>
 969          * match the name of a serializable field for the class whose fields
 970          * are being written, or if the type of the named field is not
<a name="28" id="anc28"></a><span class="line-modified"> 971          * {@code float}</span>
 972          */
 973         public abstract void put(String name, float val);
 974 
 975         /**
 976          * Put the value of the named double field into the persistent field.
 977          *
 978          * @param  name the name of the serializable field
 979          * @param  val the value to assign to the field
<a name="29" id="anc29"></a><span class="line-modified"> 980          * @throws IllegalArgumentException if {@code name} does not</span>
 981          * match the name of a serializable field for the class whose fields
 982          * are being written, or if the type of the named field is not
<a name="30" id="anc30"></a><span class="line-modified"> 983          * {@code double}</span>
 984          */
 985         public abstract void put(String name, double val);
 986 
 987         /**
 988          * Put the value of the named Object field into the persistent field.
 989          *
 990          * @param  name the name of the serializable field
 991          * @param  val the value to assign to the field
<a name="31" id="anc31"></a><span class="line-modified"> 992          *         (which may be {@code null})</span>
<span class="line-modified"> 993          * @throws IllegalArgumentException if {@code name} does not</span>
 994          * match the name of a serializable field for the class whose fields
 995          * are being written, or if the type of the named field is not a
 996          * reference type
 997          */
 998         public abstract void put(String name, Object val);
 999 
1000         /**
1001          * Write the data and fields to the specified ObjectOutput stream,
1002          * which must be the same stream that produced this
<a name="32" id="anc32"></a><span class="line-modified">1003          * {@code PutField} object.</span>
1004          *
1005          * @param  out the stream to write the data and fields to
1006          * @throws IOException if I/O errors occur while writing to the
1007          *         underlying stream
1008          * @throws IllegalArgumentException if the specified stream is not
<a name="33" id="anc33"></a><span class="line-modified">1009          *         the same stream that produced this {@code PutField}</span>
1010          *         object
1011          * @deprecated This method does not write the values contained by this
<a name="34" id="anc34"></a><span class="line-modified">1012          *         {@code PutField} object in a proper format, and may</span>
1013          *         result in corruption of the serialization stream.  The
<a name="35" id="anc35"></a><span class="line-modified">1014          *         correct way to write {@code PutField} data is by</span>
1015          *         calling the {@link java.io.ObjectOutputStream#writeFields()}
1016          *         method.
1017          */
1018         @Deprecated
1019         public abstract void write(ObjectOutput out) throws IOException;
1020     }
1021 
1022 
1023     /**
1024      * Returns protocol version in use.
1025      */
1026     int getProtocolVersion() {
1027         return protocol;
1028     }
1029 
1030     /**
1031      * Writes string without allowing it to be replaced in stream.  Used by
1032      * ObjectStreamClass to write class descriptor type strings.
1033      */
1034     void writeTypeString(String str) throws IOException {
1035         int handle;
1036         if (str == null) {
1037             writeNull();
1038         } else if ((handle = handles.lookup(str)) != -1) {
1039             writeHandle(handle);
1040         } else {
1041             writeString(str, false);
1042         }
1043     }
1044 
1045     /**
1046      * Verifies that this (possibly subclass) instance can be constructed
1047      * without violating security constraints: the subclass must not override
1048      * security-sensitive non-final methods, or else the
1049      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1050      */
1051     private void verifySubclass() {
1052         Class&lt;?&gt; cl = getClass();
1053         if (cl == ObjectOutputStream.class) {
1054             return;
1055         }
1056         SecurityManager sm = System.getSecurityManager();
1057         if (sm == null) {
1058             return;
1059         }
1060         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1061         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1062         Boolean result = Caches.subclassAudits.get(key);
1063         if (result == null) {
1064             result = auditSubclass(cl);
1065             Caches.subclassAudits.putIfAbsent(key, result);
1066         }
1067         if (!result) {
1068             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
1069         }
1070     }
1071 
1072     /**
1073      * Performs reflective checks on given subclass to verify that it doesn&#39;t
1074      * override security-sensitive non-final methods.  Returns TRUE if subclass
1075      * is &quot;safe&quot;, FALSE otherwise.
1076      */
1077     private static Boolean auditSubclass(Class&lt;?&gt; subcl) {
1078         return AccessController.doPrivileged(
1079             new PrivilegedAction&lt;&gt;() {
1080                 public Boolean run() {
1081                     for (Class&lt;?&gt; cl = subcl;
1082                          cl != ObjectOutputStream.class;
1083                          cl = cl.getSuperclass())
1084                     {
1085                         try {
1086                             cl.getDeclaredMethod(
1087                                 &quot;writeUnshared&quot;, new Class&lt;?&gt;[] { Object.class });
1088                             return Boolean.FALSE;
1089                         } catch (NoSuchMethodException ex) {
1090                         }
1091                         try {
1092                             cl.getDeclaredMethod(&quot;putFields&quot;, (Class&lt;?&gt;[]) null);
1093                             return Boolean.FALSE;
1094                         } catch (NoSuchMethodException ex) {
1095                         }
1096                     }
1097                     return Boolean.TRUE;
1098                 }
1099             }
1100         );
1101     }
1102 
1103     /**
1104      * Clears internal data structures.
1105      */
1106     private void clear() {
1107         subs.clear();
1108         handles.clear();
1109     }
1110 
1111     /**
1112      * Underlying writeObject/writeUnshared implementation.
1113      */
1114     private void writeObject0(Object obj, boolean unshared)
1115         throws IOException
1116     {
1117         boolean oldMode = bout.setBlockDataMode(false);
1118         depth++;
1119         try {
1120             // handle previously written and non-replaceable objects
1121             int h;
1122             if ((obj = subs.lookup(obj)) == null) {
1123                 writeNull();
1124                 return;
1125             } else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) {
1126                 writeHandle(h);
1127                 return;
1128             } else if (obj instanceof Class) {
1129                 writeClass((Class) obj, unshared);
1130                 return;
1131             } else if (obj instanceof ObjectStreamClass) {
1132                 writeClassDesc((ObjectStreamClass) obj, unshared);
1133                 return;
1134             }
1135 
1136             // check for replacement object
1137             Object orig = obj;
1138             Class&lt;?&gt; cl = obj.getClass();
1139             ObjectStreamClass desc;
1140             for (;;) {
1141                 // REMIND: skip this check for strings/arrays?
1142                 Class&lt;?&gt; repCl;
1143                 desc = ObjectStreamClass.lookup(cl, true);
1144                 if (!desc.hasWriteReplaceMethod() ||
1145                     (obj = desc.invokeWriteReplace(obj)) == null ||
1146                     (repCl = obj.getClass()) == cl)
1147                 {
1148                     break;
1149                 }
1150                 cl = repCl;
1151             }
1152             if (enableReplace) {
1153                 Object rep = replaceObject(obj);
1154                 if (rep != obj &amp;&amp; rep != null) {
1155                     cl = rep.getClass();
1156                     desc = ObjectStreamClass.lookup(cl, true);
1157                 }
1158                 obj = rep;
1159             }
1160 
1161             // if object replaced, run through original checks a second time
1162             if (obj != orig) {
1163                 subs.assign(orig, obj);
1164                 if (obj == null) {
1165                     writeNull();
1166                     return;
1167                 } else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) {
1168                     writeHandle(h);
1169                     return;
1170                 } else if (obj instanceof Class) {
1171                     writeClass((Class) obj, unshared);
1172                     return;
1173                 } else if (obj instanceof ObjectStreamClass) {
1174                     writeClassDesc((ObjectStreamClass) obj, unshared);
1175                     return;
1176                 }
1177             }
1178 
1179             // remaining cases
1180             if (obj instanceof String) {
1181                 writeString((String) obj, unshared);
1182             } else if (cl.isArray()) {
1183                 writeArray(obj, desc, unshared);
1184             } else if (obj instanceof Enum) {
1185                 writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
1186             } else if (obj instanceof Serializable) {
1187                 writeOrdinaryObject(obj, desc, unshared);
1188             } else {
1189                 if (extendedDebugInfo) {
1190                     throw new NotSerializableException(
1191                         cl.getName() + &quot;\n&quot; + debugInfoStack.toString());
1192                 } else {
1193                     throw new NotSerializableException(cl.getName());
1194                 }
1195             }
1196         } finally {
1197             depth--;
1198             bout.setBlockDataMode(oldMode);
1199         }
1200     }
1201 
1202     /**
1203      * Writes null code to stream.
1204      */
1205     private void writeNull() throws IOException {
1206         bout.writeByte(TC_NULL);
1207     }
1208 
1209     /**
1210      * Writes given object handle to stream.
1211      */
1212     private void writeHandle(int handle) throws IOException {
1213         bout.writeByte(TC_REFERENCE);
1214         bout.writeInt(baseWireHandle + handle);
1215     }
1216 
1217     /**
1218      * Writes representation of given class to stream.
1219      */
1220     private void writeClass(Class&lt;?&gt; cl, boolean unshared) throws IOException {
1221         bout.writeByte(TC_CLASS);
1222         writeClassDesc(ObjectStreamClass.lookup(cl, true), false);
1223         handles.assign(unshared ? null : cl);
1224     }
1225 
1226     /**
1227      * Writes representation of given class descriptor to stream.
1228      */
1229     private void writeClassDesc(ObjectStreamClass desc, boolean unshared)
1230         throws IOException
1231     {
1232         int handle;
1233         if (desc == null) {
1234             writeNull();
1235         } else if (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -1) {
1236             writeHandle(handle);
1237         } else if (desc.isProxy()) {
1238             writeProxyDesc(desc, unshared);
1239         } else {
1240             writeNonProxyDesc(desc, unshared);
1241         }
1242     }
1243 
1244     private boolean isCustomSubclass() {
1245         // Return true if this class is a custom subclass of ObjectOutputStream
1246         return getClass().getClassLoader()
1247                    != ObjectOutputStream.class.getClassLoader();
1248     }
1249 
1250     /**
1251      * Writes class descriptor representing a dynamic proxy class to stream.
1252      */
1253     private void writeProxyDesc(ObjectStreamClass desc, boolean unshared)
1254         throws IOException
1255     {
1256         bout.writeByte(TC_PROXYCLASSDESC);
1257         handles.assign(unshared ? null : desc);
1258 
1259         Class&lt;?&gt; cl = desc.forClass();
1260         Class&lt;?&gt;[] ifaces = cl.getInterfaces();
1261         bout.writeInt(ifaces.length);
1262         for (int i = 0; i &lt; ifaces.length; i++) {
1263             bout.writeUTF(ifaces[i].getName());
1264         }
1265 
1266         bout.setBlockDataMode(true);
1267         if (cl != null &amp;&amp; isCustomSubclass()) {
1268             ReflectUtil.checkPackageAccess(cl);
1269         }
1270         annotateProxyClass(cl);
1271         bout.setBlockDataMode(false);
1272         bout.writeByte(TC_ENDBLOCKDATA);
1273 
1274         writeClassDesc(desc.getSuperDesc(), false);
1275     }
1276 
1277     /**
1278      * Writes class descriptor representing a standard (i.e., not a dynamic
1279      * proxy) class to stream.
1280      */
1281     private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)
1282         throws IOException
1283     {
1284         bout.writeByte(TC_CLASSDESC);
1285         handles.assign(unshared ? null : desc);
1286 
1287         if (protocol == PROTOCOL_VERSION_1) {
1288             // do not invoke class descriptor write hook with old protocol
1289             desc.writeNonProxy(this);
1290         } else {
1291             writeClassDescriptor(desc);
1292         }
1293 
1294         Class&lt;?&gt; cl = desc.forClass();
1295         bout.setBlockDataMode(true);
1296         if (cl != null &amp;&amp; isCustomSubclass()) {
1297             ReflectUtil.checkPackageAccess(cl);
1298         }
1299         annotateClass(cl);
1300         bout.setBlockDataMode(false);
1301         bout.writeByte(TC_ENDBLOCKDATA);
1302 
1303         writeClassDesc(desc.getSuperDesc(), false);
1304     }
1305 
1306     /**
1307      * Writes given string to stream, using standard or long UTF format
1308      * depending on string length.
1309      */
1310     private void writeString(String str, boolean unshared) throws IOException {
1311         handles.assign(unshared ? null : str);
1312         long utflen = bout.getUTFLength(str);
1313         if (utflen &lt;= 0xFFFF) {
1314             bout.writeByte(TC_STRING);
1315             bout.writeUTF(str, utflen);
1316         } else {
1317             bout.writeByte(TC_LONGSTRING);
1318             bout.writeLongUTF(str, utflen);
1319         }
1320     }
1321 
1322     /**
1323      * Writes given array object to stream.
1324      */
1325     private void writeArray(Object array,
1326                             ObjectStreamClass desc,
1327                             boolean unshared)
1328         throws IOException
1329     {
1330         bout.writeByte(TC_ARRAY);
1331         writeClassDesc(desc, false);
1332         handles.assign(unshared ? null : array);
1333 
1334         Class&lt;?&gt; ccl = desc.forClass().getComponentType();
1335         if (ccl.isPrimitive()) {
1336             if (ccl == Integer.TYPE) {
1337                 int[] ia = (int[]) array;
1338                 bout.writeInt(ia.length);
1339                 bout.writeInts(ia, 0, ia.length);
1340             } else if (ccl == Byte.TYPE) {
1341                 byte[] ba = (byte[]) array;
1342                 bout.writeInt(ba.length);
1343                 bout.write(ba, 0, ba.length, true);
1344             } else if (ccl == Long.TYPE) {
1345                 long[] ja = (long[]) array;
1346                 bout.writeInt(ja.length);
1347                 bout.writeLongs(ja, 0, ja.length);
1348             } else if (ccl == Float.TYPE) {
1349                 float[] fa = (float[]) array;
1350                 bout.writeInt(fa.length);
1351                 bout.writeFloats(fa, 0, fa.length);
1352             } else if (ccl == Double.TYPE) {
1353                 double[] da = (double[]) array;
1354                 bout.writeInt(da.length);
1355                 bout.writeDoubles(da, 0, da.length);
1356             } else if (ccl == Short.TYPE) {
1357                 short[] sa = (short[]) array;
1358                 bout.writeInt(sa.length);
1359                 bout.writeShorts(sa, 0, sa.length);
1360             } else if (ccl == Character.TYPE) {
1361                 char[] ca = (char[]) array;
1362                 bout.writeInt(ca.length);
1363                 bout.writeChars(ca, 0, ca.length);
1364             } else if (ccl == Boolean.TYPE) {
1365                 boolean[] za = (boolean[]) array;
1366                 bout.writeInt(za.length);
1367                 bout.writeBooleans(za, 0, za.length);
1368             } else {
1369                 throw new InternalError();
1370             }
1371         } else {
1372             Object[] objs = (Object[]) array;
1373             int len = objs.length;
1374             bout.writeInt(len);
1375             if (extendedDebugInfo) {
1376                 debugInfoStack.push(
1377                     &quot;array (class \&quot;&quot; + array.getClass().getName() +
1378                     &quot;\&quot;, size: &quot; + len  + &quot;)&quot;);
1379             }
1380             try {
1381                 for (int i = 0; i &lt; len; i++) {
1382                     if (extendedDebugInfo) {
1383                         debugInfoStack.push(
1384                             &quot;element of array (index: &quot; + i + &quot;)&quot;);
1385                     }
1386                     try {
1387                         writeObject0(objs[i], false);
1388                     } finally {
1389                         if (extendedDebugInfo) {
1390                             debugInfoStack.pop();
1391                         }
1392                     }
1393                 }
1394             } finally {
1395                 if (extendedDebugInfo) {
1396                     debugInfoStack.pop();
1397                 }
1398             }
1399         }
1400     }
1401 
1402     /**
1403      * Writes given enum constant to stream.
1404      */
1405     private void writeEnum(Enum&lt;?&gt; en,
1406                            ObjectStreamClass desc,
1407                            boolean unshared)
1408         throws IOException
1409     {
1410         bout.writeByte(TC_ENUM);
1411         ObjectStreamClass sdesc = desc.getSuperDesc();
1412         writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);
1413         handles.assign(unshared ? null : en);
1414         writeString(en.name(), false);
1415     }
1416 
1417     /**
1418      * Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class,
1419      * ObjectStreamClass, array, or enum constant) serializable object to the
1420      * stream.
1421      */
1422     private void writeOrdinaryObject(Object obj,
1423                                      ObjectStreamClass desc,
1424                                      boolean unshared)
1425         throws IOException
1426     {
1427         if (extendedDebugInfo) {
1428             debugInfoStack.push(
1429                 (depth == 1 ? &quot;root &quot; : &quot;&quot;) + &quot;object (class \&quot;&quot; +
1430                 obj.getClass().getName() + &quot;\&quot;, &quot; + obj.toString() + &quot;)&quot;);
1431         }
1432         try {
1433             desc.checkSerialize();
1434 
1435             bout.writeByte(TC_OBJECT);
1436             writeClassDesc(desc, false);
1437             handles.assign(unshared ? null : obj);
<a name="36" id="anc36"></a><span class="line-modified">1438 </span>
<span class="line-added">1439             if (desc.isRecord()) {</span>
<span class="line-added">1440                 writeRecordData(obj, desc);</span>
<span class="line-added">1441             } else if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {</span>
1442                 writeExternalData((Externalizable) obj);
1443             } else {
1444                 writeSerialData(obj, desc);
1445             }
1446         } finally {
1447             if (extendedDebugInfo) {
1448                 debugInfoStack.pop();
1449             }
1450         }
1451     }
1452 
1453     /**
1454      * Writes externalizable data of given object by invoking its
1455      * writeExternal() method.
1456      */
1457     private void writeExternalData(Externalizable obj) throws IOException {
1458         PutFieldImpl oldPut = curPut;
1459         curPut = null;
1460 
1461         if (extendedDebugInfo) {
1462             debugInfoStack.push(&quot;writeExternal data&quot;);
1463         }
1464         SerialCallbackContext oldContext = curContext;
1465         try {
1466             curContext = null;
1467             if (protocol == PROTOCOL_VERSION_1) {
1468                 obj.writeExternal(this);
1469             } else {
1470                 bout.setBlockDataMode(true);
1471                 obj.writeExternal(this);
1472                 bout.setBlockDataMode(false);
1473                 bout.writeByte(TC_ENDBLOCKDATA);
1474             }
1475         } finally {
1476             curContext = oldContext;
1477             if (extendedDebugInfo) {
1478                 debugInfoStack.pop();
1479             }
1480         }
1481 
1482         curPut = oldPut;
1483     }
1484 
<a name="37" id="anc37"></a><span class="line-added">1485     /** Writes the record component values for the given record object. */</span>
<span class="line-added">1486     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1487     private void writeRecordData(Object obj, ObjectStreamClass desc)</span>
<span class="line-added">1488         throws IOException</span>
<span class="line-added">1489     {</span>
<span class="line-added">1490         assert obj.getClass().isRecord();</span>
<span class="line-added">1491         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="line-added">1492         if (slots.length != 1) {</span>
<span class="line-added">1493             throw new InvalidClassException(</span>
<span class="line-added">1494                     &quot;expected a single record slot length, but found: &quot; + slots.length);</span>
<span class="line-added">1495         }</span>
<span class="line-added">1496 </span>
<span class="line-added">1497         defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors</span>
<span class="line-added">1498     }</span>
<span class="line-added">1499 </span>
1500     /**
1501      * Writes instance data for each serializable class of given object, from
1502      * superclass to subclass.
1503      */
1504     private void writeSerialData(Object obj, ObjectStreamClass desc)
1505         throws IOException
1506     {
1507         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
1508         for (int i = 0; i &lt; slots.length; i++) {
1509             ObjectStreamClass slotDesc = slots[i].desc;
1510             if (slotDesc.hasWriteObjectMethod()) {
1511                 PutFieldImpl oldPut = curPut;
1512                 curPut = null;
1513                 SerialCallbackContext oldContext = curContext;
1514 
1515                 if (extendedDebugInfo) {
1516                     debugInfoStack.push(
1517                         &quot;custom writeObject data (class \&quot;&quot; +
1518                         slotDesc.getName() + &quot;\&quot;)&quot;);
1519                 }
1520                 try {
1521                     curContext = new SerialCallbackContext(obj, slotDesc);
1522                     bout.setBlockDataMode(true);
1523                     slotDesc.invokeWriteObject(obj, this);
1524                     bout.setBlockDataMode(false);
1525                     bout.writeByte(TC_ENDBLOCKDATA);
1526                 } finally {
1527                     curContext.setUsed();
1528                     curContext = oldContext;
1529                     if (extendedDebugInfo) {
1530                         debugInfoStack.pop();
1531                     }
1532                 }
1533 
1534                 curPut = oldPut;
1535             } else {
1536                 defaultWriteFields(obj, slotDesc);
1537             }
1538         }
1539     }
1540 
1541     /**
1542      * Fetches and writes values of serializable fields of given object to
1543      * stream.  The given class descriptor specifies which field values to
1544      * write, and in which order they should be written.
1545      */
1546     private void defaultWriteFields(Object obj, ObjectStreamClass desc)
1547         throws IOException
1548     {
1549         Class&lt;?&gt; cl = desc.forClass();
1550         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
1551             throw new ClassCastException();
1552         }
1553 
1554         desc.checkDefaultSerialize();
1555 
1556         int primDataSize = desc.getPrimDataSize();
1557         if (primDataSize &gt; 0) {
1558             if (primVals == null || primVals.length &lt; primDataSize) {
1559                 primVals = new byte[primDataSize];
1560             }
1561             desc.getPrimFieldValues(obj, primVals);
1562             bout.write(primVals, 0, primDataSize, false);
1563         }
1564 
1565         int numObjFields = desc.getNumObjFields();
1566         if (numObjFields &gt; 0) {
1567             ObjectStreamField[] fields = desc.getFields(false);
1568             Object[] objVals = new Object[numObjFields];
1569             int numPrimFields = fields.length - objVals.length;
1570             desc.getObjFieldValues(obj, objVals);
1571             for (int i = 0; i &lt; objVals.length; i++) {
1572                 if (extendedDebugInfo) {
1573                     debugInfoStack.push(
1574                         &quot;field (class \&quot;&quot; + desc.getName() + &quot;\&quot;, name: \&quot;&quot; +
1575                         fields[numPrimFields + i].getName() + &quot;\&quot;, type: \&quot;&quot; +
1576                         fields[numPrimFields + i].getType() + &quot;\&quot;)&quot;);
1577                 }
1578                 try {
1579                     writeObject0(objVals[i],
1580                                  fields[numPrimFields + i].isUnshared());
1581                 } finally {
1582                     if (extendedDebugInfo) {
1583                         debugInfoStack.pop();
1584                     }
1585                 }
1586             }
1587         }
1588     }
1589 
1590     /**
1591      * Attempts to write to stream fatal IOException that has caused
1592      * serialization to abort.
1593      */
1594     private void writeFatalException(IOException ex) throws IOException {
1595         /*
1596          * Note: the serialization specification states that if a second
1597          * IOException occurs while attempting to serialize the original fatal
1598          * exception to the stream, then a StreamCorruptedException should be
1599          * thrown (section 2.1).  However, due to a bug in previous
1600          * implementations of serialization, StreamCorruptedExceptions were
1601          * rarely (if ever) actually thrown--the &quot;root&quot; exceptions from
1602          * underlying streams were thrown instead.  This historical behavior is
1603          * followed here for consistency.
1604          */
1605         clear();
1606         boolean oldMode = bout.setBlockDataMode(false);
1607         try {
1608             bout.writeByte(TC_EXCEPTION);
1609             writeObject0(ex, false);
1610             clear();
1611         } finally {
1612             bout.setBlockDataMode(oldMode);
1613         }
1614     }
1615 
<a name="38" id="anc38"></a>















1616     /**
1617      * Default PutField implementation.
1618      */
1619     private class PutFieldImpl extends PutField {
1620 
1621         /** class descriptor describing serializable fields */
1622         private final ObjectStreamClass desc;
1623         /** primitive field values */
1624         private final byte[] primVals;
1625         /** object field values */
1626         private final Object[] objVals;
1627 
1628         /**
1629          * Creates PutFieldImpl object for writing fields defined in given
1630          * class descriptor.
1631          */
1632         PutFieldImpl(ObjectStreamClass desc) {
1633             this.desc = desc;
1634             primVals = new byte[desc.getPrimDataSize()];
1635             objVals = new Object[desc.getNumObjFields()];
1636         }
1637 
1638         public void put(String name, boolean val) {
1639             Bits.putBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);
1640         }
1641 
1642         public void put(String name, byte val) {
1643             primVals[getFieldOffset(name, Byte.TYPE)] = val;
1644         }
1645 
1646         public void put(String name, char val) {
1647             Bits.putChar(primVals, getFieldOffset(name, Character.TYPE), val);
1648         }
1649 
1650         public void put(String name, short val) {
1651             Bits.putShort(primVals, getFieldOffset(name, Short.TYPE), val);
1652         }
1653 
1654         public void put(String name, int val) {
1655             Bits.putInt(primVals, getFieldOffset(name, Integer.TYPE), val);
1656         }
1657 
1658         public void put(String name, float val) {
1659             Bits.putFloat(primVals, getFieldOffset(name, Float.TYPE), val);
1660         }
1661 
1662         public void put(String name, long val) {
1663             Bits.putLong(primVals, getFieldOffset(name, Long.TYPE), val);
1664         }
1665 
1666         public void put(String name, double val) {
1667             Bits.putDouble(primVals, getFieldOffset(name, Double.TYPE), val);
1668         }
1669 
1670         public void put(String name, Object val) {
1671             objVals[getFieldOffset(name, Object.class)] = val;
1672         }
1673 
1674         // deprecated in ObjectOutputStream.PutField
1675         public void write(ObjectOutput out) throws IOException {
1676             /*
1677              * Applications should *not* use this method to write PutField
1678              * data, as it will lead to stream corruption if the PutField
1679              * object writes any primitive data (since block data mode is not
1680              * unset/set properly, as is done in OOS.writeFields()).  This
1681              * broken implementation is being retained solely for behavioral
1682              * compatibility, in order to support applications which use
1683              * OOS.PutField.write() for writing only non-primitive data.
1684              *
1685              * Serialization of unshared objects is not implemented here since
1686              * it is not necessary for backwards compatibility; also, unshared
1687              * semantics may not be supported by the given ObjectOutput
1688              * instance.  Applications which write unshared objects using the
1689              * PutField API must use OOS.writeFields().
1690              */
1691             if (ObjectOutputStream.this != out) {
1692                 throw new IllegalArgumentException(&quot;wrong stream&quot;);
1693             }
1694             out.write(primVals, 0, primVals.length);
1695 
1696             ObjectStreamField[] fields = desc.getFields(false);
1697             int numPrimFields = fields.length - objVals.length;
1698             // REMIND: warn if numPrimFields &gt; 0?
1699             for (int i = 0; i &lt; objVals.length; i++) {
1700                 if (fields[numPrimFields + i].isUnshared()) {
1701                     throw new IOException(&quot;cannot write unshared object&quot;);
1702                 }
1703                 out.writeObject(objVals[i]);
1704             }
1705         }
1706 
1707         /**
1708          * Writes buffered primitive data and object fields to stream.
1709          */
1710         void writeFields() throws IOException {
1711             bout.write(primVals, 0, primVals.length, false);
1712 
1713             ObjectStreamField[] fields = desc.getFields(false);
1714             int numPrimFields = fields.length - objVals.length;
1715             for (int i = 0; i &lt; objVals.length; i++) {
1716                 if (extendedDebugInfo) {
1717                     debugInfoStack.push(
1718                         &quot;field (class \&quot;&quot; + desc.getName() + &quot;\&quot;, name: \&quot;&quot; +
1719                         fields[numPrimFields + i].getName() + &quot;\&quot;, type: \&quot;&quot; +
1720                         fields[numPrimFields + i].getType() + &quot;\&quot;)&quot;);
1721                 }
1722                 try {
1723                     writeObject0(objVals[i],
1724                                  fields[numPrimFields + i].isUnshared());
1725                 } finally {
1726                     if (extendedDebugInfo) {
1727                         debugInfoStack.pop();
1728                     }
1729                 }
1730             }
1731         }
1732 
1733         /**
1734          * Returns offset of field with given name and type.  A specified type
1735          * of null matches all types, Object.class matches all non-primitive
1736          * types, and any other non-null type matches assignable types only.
1737          * Throws IllegalArgumentException if no matching field found.
1738          */
1739         private int getFieldOffset(String name, Class&lt;?&gt; type) {
1740             ObjectStreamField field = desc.getField(name, type);
1741             if (field == null) {
1742                 throw new IllegalArgumentException(&quot;no such field &quot; + name +
1743                                                    &quot; with type &quot; + type);
1744             }
1745             return field.getOffset();
1746         }
1747     }
1748 
1749     /**
1750      * Buffered output stream with two modes: in default mode, outputs data in
1751      * same format as DataOutputStream; in &quot;block data&quot; mode, outputs data
1752      * bracketed by block data markers (see object serialization specification
1753      * for details).
1754      */
1755     private static class BlockDataOutputStream
1756         extends OutputStream implements DataOutput
1757     {
1758         /** maximum data block length */
1759         private static final int MAX_BLOCK_SIZE = 1024;
1760         /** maximum data block header length */
1761         private static final int MAX_HEADER_SIZE = 5;
1762         /** (tunable) length of char buffer (for writing strings) */
1763         private static final int CHAR_BUF_SIZE = 256;
1764 
1765         /** buffer for writing general/block data */
1766         private final byte[] buf = new byte[MAX_BLOCK_SIZE];
1767         /** buffer for writing block data headers */
1768         private final byte[] hbuf = new byte[MAX_HEADER_SIZE];
1769         /** char buffer for fast string writes */
1770         private final char[] cbuf = new char[CHAR_BUF_SIZE];
1771 
1772         /** block data mode */
1773         private boolean blkmode = false;
1774         /** current offset into buf */
1775         private int pos = 0;
1776 
1777         /** underlying output stream */
1778         private final OutputStream out;
1779         /** loopback stream (for data writes that span data blocks) */
1780         private final DataOutputStream dout;
1781 
1782         /**
1783          * Creates new BlockDataOutputStream on top of given underlying stream.
1784          * Block data mode is turned off by default.
1785          */
1786         BlockDataOutputStream(OutputStream out) {
1787             this.out = out;
1788             dout = new DataOutputStream(this);
1789         }
1790 
1791         /**
1792          * Sets block data mode to the given mode (true == on, false == off)
1793          * and returns the previous mode value.  If the new mode is the same as
1794          * the old mode, no action is taken.  If the new mode differs from the
1795          * old mode, any buffered data is flushed before switching to the new
1796          * mode.
1797          */
1798         boolean setBlockDataMode(boolean mode) throws IOException {
1799             if (blkmode == mode) {
1800                 return blkmode;
1801             }
1802             drain();
1803             blkmode = mode;
1804             return !blkmode;
1805         }
1806 
1807         /**
1808          * Returns true if the stream is currently in block data mode, false
1809          * otherwise.
1810          */
1811         boolean getBlockDataMode() {
1812             return blkmode;
1813         }
1814 
1815         /* ----------------- generic output stream methods ----------------- */
1816         /*
1817          * The following methods are equivalent to their counterparts in
1818          * OutputStream, except that they partition written data into data
1819          * blocks when in block data mode.
1820          */
1821 
1822         public void write(int b) throws IOException {
1823             if (pos &gt;= MAX_BLOCK_SIZE) {
1824                 drain();
1825             }
1826             buf[pos++] = (byte) b;
1827         }
1828 
1829         public void write(byte[] b) throws IOException {
1830             write(b, 0, b.length, false);
1831         }
1832 
1833         public void write(byte[] b, int off, int len) throws IOException {
1834             write(b, off, len, false);
1835         }
1836 
1837         public void flush() throws IOException {
1838             drain();
1839             out.flush();
1840         }
1841 
1842         public void close() throws IOException {
1843             flush();
1844             out.close();
1845         }
1846 
1847         /**
1848          * Writes specified span of byte values from given array.  If copy is
1849          * true, copies the values to an intermediate buffer before writing
1850          * them to underlying stream (to avoid exposing a reference to the
1851          * original byte array).
1852          */
1853         void write(byte[] b, int off, int len, boolean copy)
1854             throws IOException
1855         {
1856             if (!(copy || blkmode)) {           // write directly
1857                 drain();
1858                 out.write(b, off, len);
1859                 return;
1860             }
1861 
1862             while (len &gt; 0) {
1863                 if (pos &gt;= MAX_BLOCK_SIZE) {
1864                     drain();
1865                 }
1866                 if (len &gt;= MAX_BLOCK_SIZE &amp;&amp; !copy &amp;&amp; pos == 0) {
1867                     // avoid unnecessary copy
1868                     writeBlockHeader(MAX_BLOCK_SIZE);
1869                     out.write(b, off, MAX_BLOCK_SIZE);
1870                     off += MAX_BLOCK_SIZE;
1871                     len -= MAX_BLOCK_SIZE;
1872                 } else {
1873                     int wlen = Math.min(len, MAX_BLOCK_SIZE - pos);
1874                     System.arraycopy(b, off, buf, pos, wlen);
1875                     pos += wlen;
1876                     off += wlen;
1877                     len -= wlen;
1878                 }
1879             }
1880         }
1881 
1882         /**
1883          * Writes all buffered data from this stream to the underlying stream,
1884          * but does not flush underlying stream.
1885          */
1886         void drain() throws IOException {
1887             if (pos == 0) {
1888                 return;
1889             }
1890             if (blkmode) {
1891                 writeBlockHeader(pos);
1892             }
1893             out.write(buf, 0, pos);
1894             pos = 0;
1895         }
1896 
1897         /**
1898          * Writes block data header.  Data blocks shorter than 256 bytes are
1899          * prefixed with a 2-byte header; all others start with a 5-byte
1900          * header.
1901          */
1902         private void writeBlockHeader(int len) throws IOException {
1903             if (len &lt;= 0xFF) {
1904                 hbuf[0] = TC_BLOCKDATA;
1905                 hbuf[1] = (byte) len;
1906                 out.write(hbuf, 0, 2);
1907             } else {
1908                 hbuf[0] = TC_BLOCKDATALONG;
1909                 Bits.putInt(hbuf, 1, len);
1910                 out.write(hbuf, 0, 5);
1911             }
1912         }
1913 
1914 
1915         /* ----------------- primitive data output methods ----------------- */
1916         /*
1917          * The following methods are equivalent to their counterparts in
1918          * DataOutputStream, except that they partition written data into data
1919          * blocks when in block data mode.
1920          */
1921 
1922         public void writeBoolean(boolean v) throws IOException {
1923             if (pos &gt;= MAX_BLOCK_SIZE) {
1924                 drain();
1925             }
1926             Bits.putBoolean(buf, pos++, v);
1927         }
1928 
1929         public void writeByte(int v) throws IOException {
1930             if (pos &gt;= MAX_BLOCK_SIZE) {
1931                 drain();
1932             }
1933             buf[pos++] = (byte) v;
1934         }
1935 
1936         public void writeChar(int v) throws IOException {
1937             if (pos + 2 &lt;= MAX_BLOCK_SIZE) {
1938                 Bits.putChar(buf, pos, (char) v);
1939                 pos += 2;
1940             } else {
1941                 dout.writeChar(v);
1942             }
1943         }
1944 
1945         public void writeShort(int v) throws IOException {
1946             if (pos + 2 &lt;= MAX_BLOCK_SIZE) {
1947                 Bits.putShort(buf, pos, (short) v);
1948                 pos += 2;
1949             } else {
1950                 dout.writeShort(v);
1951             }
1952         }
1953 
1954         public void writeInt(int v) throws IOException {
1955             if (pos + 4 &lt;= MAX_BLOCK_SIZE) {
1956                 Bits.putInt(buf, pos, v);
1957                 pos += 4;
1958             } else {
1959                 dout.writeInt(v);
1960             }
1961         }
1962 
1963         public void writeFloat(float v) throws IOException {
1964             if (pos + 4 &lt;= MAX_BLOCK_SIZE) {
1965                 Bits.putFloat(buf, pos, v);
1966                 pos += 4;
1967             } else {
1968                 dout.writeFloat(v);
1969             }
1970         }
1971 
1972         public void writeLong(long v) throws IOException {
1973             if (pos + 8 &lt;= MAX_BLOCK_SIZE) {
1974                 Bits.putLong(buf, pos, v);
1975                 pos += 8;
1976             } else {
1977                 dout.writeLong(v);
1978             }
1979         }
1980 
1981         public void writeDouble(double v) throws IOException {
1982             if (pos + 8 &lt;= MAX_BLOCK_SIZE) {
1983                 Bits.putDouble(buf, pos, v);
1984                 pos += 8;
1985             } else {
1986                 dout.writeDouble(v);
1987             }
1988         }
1989 
1990         public void writeBytes(String s) throws IOException {
1991             int endoff = s.length();
1992             int cpos = 0;
1993             int csize = 0;
1994             for (int off = 0; off &lt; endoff; ) {
1995                 if (cpos &gt;= csize) {
1996                     cpos = 0;
1997                     csize = Math.min(endoff - off, CHAR_BUF_SIZE);
1998                     s.getChars(off, off + csize, cbuf, 0);
1999                 }
2000                 if (pos &gt;= MAX_BLOCK_SIZE) {
2001                     drain();
2002                 }
2003                 int n = Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);
2004                 int stop = pos + n;
2005                 while (pos &lt; stop) {
2006                     buf[pos++] = (byte) cbuf[cpos++];
2007                 }
2008                 off += n;
2009             }
2010         }
2011 
2012         public void writeChars(String s) throws IOException {
2013             int endoff = s.length();
2014             for (int off = 0; off &lt; endoff; ) {
2015                 int csize = Math.min(endoff - off, CHAR_BUF_SIZE);
2016                 s.getChars(off, off + csize, cbuf, 0);
2017                 writeChars(cbuf, 0, csize);
2018                 off += csize;
2019             }
2020         }
2021 
2022         public void writeUTF(String s) throws IOException {
2023             writeUTF(s, getUTFLength(s));
2024         }
2025 
2026 
2027         /* -------------- primitive data array output methods -------------- */
2028         /*
2029          * The following methods write out spans of primitive data values.
2030          * Though equivalent to calling the corresponding primitive write
2031          * methods repeatedly, these methods are optimized for writing groups
2032          * of primitive data values more efficiently.
2033          */
2034 
2035         void writeBooleans(boolean[] v, int off, int len) throws IOException {
2036             int endoff = off + len;
2037             while (off &lt; endoff) {
2038                 if (pos &gt;= MAX_BLOCK_SIZE) {
2039                     drain();
2040                 }
2041                 int stop = Math.min(endoff, off + (MAX_BLOCK_SIZE - pos));
2042                 while (off &lt; stop) {
2043                     Bits.putBoolean(buf, pos++, v[off++]);
2044                 }
2045             }
2046         }
2047 
2048         void writeChars(char[] v, int off, int len) throws IOException {
2049             int limit = MAX_BLOCK_SIZE - 2;
2050             int endoff = off + len;
2051             while (off &lt; endoff) {
2052                 if (pos &lt;= limit) {
2053                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 1;
2054                     int stop = Math.min(endoff, off + avail);
2055                     while (off &lt; stop) {
2056                         Bits.putChar(buf, pos, v[off++]);
2057                         pos += 2;
2058                     }
2059                 } else {
2060                     dout.writeChar(v[off++]);
2061                 }
2062             }
2063         }
2064 
2065         void writeShorts(short[] v, int off, int len) throws IOException {
2066             int limit = MAX_BLOCK_SIZE - 2;
2067             int endoff = off + len;
2068             while (off &lt; endoff) {
2069                 if (pos &lt;= limit) {
2070                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 1;
2071                     int stop = Math.min(endoff, off + avail);
2072                     while (off &lt; stop) {
2073                         Bits.putShort(buf, pos, v[off++]);
2074                         pos += 2;
2075                     }
2076                 } else {
2077                     dout.writeShort(v[off++]);
2078                 }
2079             }
2080         }
2081 
2082         void writeInts(int[] v, int off, int len) throws IOException {
2083             int limit = MAX_BLOCK_SIZE - 4;
2084             int endoff = off + len;
2085             while (off &lt; endoff) {
2086                 if (pos &lt;= limit) {
2087                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
2088                     int stop = Math.min(endoff, off + avail);
2089                     while (off &lt; stop) {
2090                         Bits.putInt(buf, pos, v[off++]);
2091                         pos += 4;
2092                     }
2093                 } else {
2094                     dout.writeInt(v[off++]);
2095                 }
2096             }
2097         }
2098 
2099         void writeFloats(float[] v, int off, int len) throws IOException {
2100             int limit = MAX_BLOCK_SIZE - 4;
2101             int endoff = off + len;
2102             while (off &lt; endoff) {
2103                 if (pos &lt;= limit) {
2104                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
<a name="39" id="anc39"></a><span class="line-modified">2105                     int stop = Math.min(endoff, off + avail);</span>
<span class="line-modified">2106                     while (off &lt; stop) {</span>
<span class="line-modified">2107                         Bits.putFloat(buf, pos, v[off++]);</span>
<span class="line-modified">2108                         pos += 4;</span>
<span class="line-added">2109                     }</span>
2110                 } else {
2111                     dout.writeFloat(v[off++]);
2112                 }
2113             }
2114         }
2115 
2116         void writeLongs(long[] v, int off, int len) throws IOException {
2117             int limit = MAX_BLOCK_SIZE - 8;
2118             int endoff = off + len;
2119             while (off &lt; endoff) {
2120                 if (pos &lt;= limit) {
2121                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
2122                     int stop = Math.min(endoff, off + avail);
2123                     while (off &lt; stop) {
2124                         Bits.putLong(buf, pos, v[off++]);
2125                         pos += 8;
2126                     }
2127                 } else {
2128                     dout.writeLong(v[off++]);
2129                 }
2130             }
2131         }
2132 
2133         void writeDoubles(double[] v, int off, int len) throws IOException {
2134             int limit = MAX_BLOCK_SIZE - 8;
2135             int endoff = off + len;
2136             while (off &lt; endoff) {
2137                 if (pos &lt;= limit) {
2138                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
<a name="40" id="anc40"></a><span class="line-modified">2139                     int stop = Math.min(endoff, off + avail);</span>
<span class="line-modified">2140                     while (off &lt; stop) {</span>
<span class="line-modified">2141                         Bits.putDouble(buf, pos, v[off++]);</span>
<span class="line-modified">2142                         pos += 8;</span>
<span class="line-added">2143                     }</span>
2144                 } else {
2145                     dout.writeDouble(v[off++]);
2146                 }
2147             }
2148         }
2149 
2150         /**
2151          * Returns the length in bytes of the UTF encoding of the given string.
2152          */
2153         long getUTFLength(String s) {
2154             int len = s.length();
2155             long utflen = 0;
2156             for (int off = 0; off &lt; len; ) {
2157                 int csize = Math.min(len - off, CHAR_BUF_SIZE);
2158                 s.getChars(off, off + csize, cbuf, 0);
2159                 for (int cpos = 0; cpos &lt; csize; cpos++) {
2160                     char c = cbuf[cpos];
2161                     if (c &gt;= 0x0001 &amp;&amp; c &lt;= 0x007F) {
2162                         utflen++;
2163                     } else if (c &gt; 0x07FF) {
2164                         utflen += 3;
2165                     } else {
2166                         utflen += 2;
2167                     }
2168                 }
2169                 off += csize;
2170             }
2171             return utflen;
2172         }
2173 
2174         /**
2175          * Writes the given string in UTF format.  This method is used in
2176          * situations where the UTF encoding length of the string is already
2177          * known; specifying it explicitly avoids a prescan of the string to
2178          * determine its UTF length.
2179          */
2180         void writeUTF(String s, long utflen) throws IOException {
2181             if (utflen &gt; 0xFFFFL) {
2182                 throw new UTFDataFormatException();
2183             }
2184             writeShort((int) utflen);
2185             if (utflen == (long) s.length()) {
2186                 writeBytes(s);
2187             } else {
2188                 writeUTFBody(s);
2189             }
2190         }
2191 
2192         /**
2193          * Writes given string in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
2194          * identical to standard UTF, except that it uses an 8 byte header
2195          * (instead of the standard 2 bytes) to convey the UTF encoding length.
2196          */
2197         void writeLongUTF(String s) throws IOException {
2198             writeLongUTF(s, getUTFLength(s));
2199         }
2200 
2201         /**
2202          * Writes given string in &quot;long&quot; UTF format, where the UTF encoding
2203          * length of the string is already known.
2204          */
2205         void writeLongUTF(String s, long utflen) throws IOException {
2206             writeLong(utflen);
2207             if (utflen == (long) s.length()) {
2208                 writeBytes(s);
2209             } else {
2210                 writeUTFBody(s);
2211             }
2212         }
2213 
2214         /**
2215          * Writes the &quot;body&quot; (i.e., the UTF representation minus the 2-byte or
2216          * 8-byte length header) of the UTF encoding for the given string.
2217          */
2218         private void writeUTFBody(String s) throws IOException {
2219             int limit = MAX_BLOCK_SIZE - 3;
2220             int len = s.length();
2221             for (int off = 0; off &lt; len; ) {
2222                 int csize = Math.min(len - off, CHAR_BUF_SIZE);
2223                 s.getChars(off, off + csize, cbuf, 0);
2224                 for (int cpos = 0; cpos &lt; csize; cpos++) {
2225                     char c = cbuf[cpos];
2226                     if (pos &lt;= limit) {
2227                         if (c &lt;= 0x007F &amp;&amp; c != 0) {
2228                             buf[pos++] = (byte) c;
2229                         } else if (c &gt; 0x07FF) {
2230                             buf[pos + 2] = (byte) (0x80 | ((c &gt;&gt; 0) &amp; 0x3F));
2231                             buf[pos + 1] = (byte) (0x80 | ((c &gt;&gt; 6) &amp; 0x3F));
2232                             buf[pos + 0] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
2233                             pos += 3;
2234                         } else {
2235                             buf[pos + 1] = (byte) (0x80 | ((c &gt;&gt; 0) &amp; 0x3F));
2236                             buf[pos + 0] = (byte) (0xC0 | ((c &gt;&gt; 6) &amp; 0x1F));
2237                             pos += 2;
2238                         }
2239                     } else {    // write one byte at a time to normalize block
2240                         if (c &lt;= 0x007F &amp;&amp; c != 0) {
2241                             write(c);
2242                         } else if (c &gt; 0x07FF) {
2243                             write(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
2244                             write(0x80 | ((c &gt;&gt; 6) &amp; 0x3F));
2245                             write(0x80 | ((c &gt;&gt; 0) &amp; 0x3F));
2246                         } else {
2247                             write(0xC0 | ((c &gt;&gt; 6) &amp; 0x1F));
2248                             write(0x80 | ((c &gt;&gt; 0) &amp; 0x3F));
2249                         }
2250                     }
2251                 }
2252                 off += csize;
2253             }
2254         }
2255     }
2256 
2257     /**
2258      * Lightweight identity hash table which maps objects to integer handles,
2259      * assigned in ascending order.
2260      */
2261     private static class HandleTable {
2262 
2263         /* number of mappings in table/next available handle */
2264         private int size;
2265         /* size threshold determining when to expand hash spine */
2266         private int threshold;
2267         /* factor for computing size threshold */
2268         private final float loadFactor;
2269         /* maps hash value -&gt; candidate handle value */
2270         private int[] spine;
2271         /* maps handle value -&gt; next candidate handle value */
2272         private int[] next;
2273         /* maps handle value -&gt; associated object */
2274         private Object[] objs;
2275 
2276         /**
2277          * Creates new HandleTable with given capacity and load factor.
2278          */
2279         HandleTable(int initialCapacity, float loadFactor) {
2280             this.loadFactor = loadFactor;
2281             spine = new int[initialCapacity];
2282             next = new int[initialCapacity];
2283             objs = new Object[initialCapacity];
2284             threshold = (int) (initialCapacity * loadFactor);
2285             clear();
2286         }
2287 
2288         /**
2289          * Assigns next available handle to given object, and returns handle
2290          * value.  Handles are assigned in ascending order starting at 0.
2291          */
2292         int assign(Object obj) {
2293             if (size &gt;= next.length) {
2294                 growEntries();
2295             }
2296             if (size &gt;= threshold) {
2297                 growSpine();
2298             }
2299             insert(obj, size);
2300             return size++;
2301         }
2302 
2303         /**
2304          * Looks up and returns handle associated with given object, or -1 if
2305          * no mapping found.
2306          */
2307         int lookup(Object obj) {
2308             if (size == 0) {
2309                 return -1;
2310             }
2311             int index = hash(obj) % spine.length;
2312             for (int i = spine[index]; i &gt;= 0; i = next[i]) {
2313                 if (objs[i] == obj) {
2314                     return i;
2315                 }
2316             }
2317             return -1;
2318         }
2319 
2320         /**
2321          * Resets table to its initial (empty) state.
2322          */
2323         void clear() {
2324             Arrays.fill(spine, -1);
2325             Arrays.fill(objs, 0, size, null);
2326             size = 0;
2327         }
2328 
2329         /**
2330          * Returns the number of mappings currently in table.
2331          */
2332         int size() {
2333             return size;
2334         }
2335 
2336         /**
2337          * Inserts mapping object -&gt; handle mapping into table.  Assumes table
2338          * is large enough to accommodate new mapping.
2339          */
2340         private void insert(Object obj, int handle) {
2341             int index = hash(obj) % spine.length;
2342             objs[handle] = obj;
2343             next[handle] = spine[index];
2344             spine[index] = handle;
2345         }
2346 
2347         /**
2348          * Expands the hash &quot;spine&quot; -- equivalent to increasing the number of
2349          * buckets in a conventional hash table.
2350          */
2351         private void growSpine() {
2352             spine = new int[(spine.length &lt;&lt; 1) + 1];
2353             threshold = (int) (spine.length * loadFactor);
2354             Arrays.fill(spine, -1);
2355             for (int i = 0; i &lt; size; i++) {
2356                 insert(objs[i], i);
2357             }
2358         }
2359 
2360         /**
2361          * Increases hash table capacity by lengthening entry arrays.
2362          */
2363         private void growEntries() {
2364             int newLength = (next.length &lt;&lt; 1) + 1;
2365             int[] newNext = new int[newLength];
2366             System.arraycopy(next, 0, newNext, 0, size);
2367             next = newNext;
2368 
2369             Object[] newObjs = new Object[newLength];
2370             System.arraycopy(objs, 0, newObjs, 0, size);
2371             objs = newObjs;
2372         }
2373 
2374         /**
2375          * Returns hash value for given object.
2376          */
2377         private int hash(Object obj) {
2378             return System.identityHashCode(obj) &amp; 0x7FFFFFFF;
2379         }
2380     }
2381 
2382     /**
2383      * Lightweight identity hash table which maps objects to replacement
2384      * objects.
2385      */
2386     private static class ReplaceTable {
2387 
2388         /* maps object -&gt; index */
2389         private final HandleTable htab;
2390         /* maps index -&gt; replacement object */
2391         private Object[] reps;
2392 
2393         /**
2394          * Creates new ReplaceTable with given capacity and load factor.
2395          */
2396         ReplaceTable(int initialCapacity, float loadFactor) {
2397             htab = new HandleTable(initialCapacity, loadFactor);
2398             reps = new Object[initialCapacity];
2399         }
2400 
2401         /**
2402          * Enters mapping from object to replacement object.
2403          */
2404         void assign(Object obj, Object rep) {
2405             int index = htab.assign(obj);
2406             while (index &gt;= reps.length) {
2407                 grow();
2408             }
2409             reps[index] = rep;
2410         }
2411 
2412         /**
2413          * Looks up and returns replacement for given object.  If no
2414          * replacement is found, returns the lookup object itself.
2415          */
2416         Object lookup(Object obj) {
2417             int index = htab.lookup(obj);
2418             return (index &gt;= 0) ? reps[index] : obj;
2419         }
2420 
2421         /**
2422          * Resets table to its initial (empty) state.
2423          */
2424         void clear() {
2425             Arrays.fill(reps, 0, htab.size(), null);
2426             htab.clear();
2427         }
2428 
2429         /**
2430          * Returns the number of mappings currently in table.
2431          */
2432         int size() {
2433             return htab.size();
2434         }
2435 
2436         /**
2437          * Increases table capacity.
2438          */
2439         private void grow() {
2440             Object[] newReps = new Object[(reps.length &lt;&lt; 1) + 1];
2441             System.arraycopy(reps, 0, newReps, 0, reps.length);
2442             reps = newReps;
2443         }
2444     }
2445 
2446     /**
2447      * Stack to keep debug information about the state of the
2448      * serialization process, for embedding in exception messages.
2449      */
2450     private static class DebugTraceInfoStack {
2451         private final List&lt;String&gt; stack;
2452 
2453         DebugTraceInfoStack() {
2454             stack = new ArrayList&lt;&gt;();
2455         }
2456 
2457         /**
2458          * Removes all of the elements from enclosed list.
2459          */
2460         void clear() {
2461             stack.clear();
2462         }
2463 
2464         /**
2465          * Removes the object at the top of enclosed list.
2466          */
2467         void pop() {
2468             stack.remove(stack.size()-1);
2469         }
2470 
2471         /**
2472          * Pushes a String onto the top of enclosed list.
2473          */
2474         void push(String entry) {
2475             stack.add(&quot;\t- &quot; + entry);
2476         }
2477 
2478         /**
2479          * Returns a string representation of this object
2480          */
2481         public String toString() {
2482             StringJoiner sj = new StringJoiner(&quot;\n&quot;);
2483             for (int i = stack.size() - 1; i &gt;= 0; i--) {
2484                 sj.add(stack.get(i));
2485             }
2486             return sj.toString();
2487         }
2488     }
2489 
2490 }
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
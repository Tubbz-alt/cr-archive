<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/PrintStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PipedWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PrintWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/PrintStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  28 import java.util.Formatter;
  29 import java.util.Locale;
  30 import java.nio.charset.Charset;
  31 import java.nio.charset.IllegalCharsetNameException;
  32 import java.nio.charset.UnsupportedCharsetException;
  33 
  34 /**
  35  * A {@code PrintStream} adds functionality to another output stream,
  36  * namely the ability to print representations of various data values
  37  * conveniently.  Two other features are provided as well.  Unlike other output
  38  * streams, a {@code PrintStream} never throws an
  39  * {@code IOException}; instead, exceptional situations merely set an
  40  * internal flag that can be tested via the {@code checkError} method.
  41  * Optionally, a {@code PrintStream} can be created so as to flush
  42  * automatically; this means that the {@code flush} method is
  43  * automatically invoked after a byte array is written, one of the
  44  * {@code println} methods is invoked, or a newline character or byte
  45  * ({@code &#39;\n&#39;}) is written.
  46  *
  47  * &lt;p&gt; All characters printed by a {@code PrintStream} are converted into
<span class="line-modified">  48  * bytes using the given encoding or charset, or platform&#39;s default character</span>
<span class="line-modified">  49  * encoding if not specified.</span>
  50  * The {@link PrintWriter} class should be used in situations that require
<span class="line-modified">  51  *  writing characters rather than bytes.</span>
  52  *
  53  * &lt;p&gt; This class always replaces malformed and unmappable character sequences with
  54  * the charset&#39;s default replacement string.
  55  * The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more
  56  * control over the encoding process is required.
  57  *
  58  * @author     Frank Yellin
  59  * @author     Mark Reinhold
  60  * @since      1.0
  61  */
  62 
  63 public class PrintStream extends FilterOutputStream
  64     implements Appendable, Closeable
  65 {
  66 
  67     private final boolean autoFlush;
  68     private boolean trouble = false;
  69     private Formatter formatter;
  70 
  71     /**
</pre>
<hr />
<pre>
 104     }
 105 
 106     /* Private constructors */
 107     private PrintStream(boolean autoFlush, OutputStream out) {
 108         super(out);
 109         this.autoFlush = autoFlush;
 110         this.charOut = new OutputStreamWriter(this);
 111         this.textOut = new BufferedWriter(charOut);
 112     }
 113 
 114     /* Variant of the private constructor so that the given charset name
 115      * can be verified before evaluating the OutputStream argument. Used
 116      * by constructors creating a FileOutputStream that also take a
 117      * charset name.
 118      */
 119     private PrintStream(boolean autoFlush, Charset charset, OutputStream out) {
 120         this(out, autoFlush, charset);
 121     }
 122 
 123     /**
<span class="line-modified"> 124      * Creates a new print stream.  This stream will not flush automatically.</span>


 125      *
 126      * @param  out        The output stream to which values and objects will be
 127      *                    printed
 128      *
 129      * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream)
 130      */
 131     public PrintStream(OutputStream out) {
 132         this(out, false);
 133     }
 134 
 135     /**
<span class="line-modified"> 136      * Creates a new print stream.</span>


 137      *
 138      * @param  out        The output stream to which values and objects will be
 139      *                    printed
<span class="line-modified"> 140      * @param  autoFlush  A boolean; if true, the output buffer will be flushed</span>
 141      *                    whenever a byte array is written, one of the
 142      *                    {@code println} methods is invoked, or a newline
 143      *                    character or byte ({@code &#39;\n&#39;}) is written
 144      *
 145      * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream, boolean)
 146      */
 147     public PrintStream(OutputStream out, boolean autoFlush) {
 148         this(autoFlush, requireNonNull(out, &quot;Null output stream&quot;));
 149     }
 150 
 151     /**
<span class="line-modified"> 152      * Creates a new print stream.</span>

 153      *
 154      * @param  out        The output stream to which values and objects will be
 155      *                    printed
<span class="line-modified"> 156      * @param  autoFlush  A boolean; if true, the output buffer will be flushed</span>
 157      *                    whenever a byte array is written, one of the
 158      *                    {@code println} methods is invoked, or a newline
 159      *                    character or byte ({@code &#39;\n&#39;}) is written
 160      * @param  encoding   The name of a supported
 161      *                    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;
 162      *                    character encoding&lt;/a&gt;
 163      *
 164      * @throws  UnsupportedEncodingException
 165      *          If the named encoding is not supported
 166      *
 167      * @since  1.4
 168      */
 169     public PrintStream(OutputStream out, boolean autoFlush, String encoding)
 170         throws UnsupportedEncodingException
 171     {
 172         this(requireNonNull(out, &quot;Null output stream&quot;), autoFlush, toCharset(encoding));
 173     }
 174 
 175     /**
<span class="line-modified"> 176      * Creates a new print stream, with the specified OutputStream, automatic line</span>
 177      * flushing and charset.  This convenience constructor creates the necessary
 178      * intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},
 179      * which will encode characters using the provided charset.
 180      *
 181      * @param  out        The output stream to which values and objects will be
 182      *                    printed
<span class="line-modified"> 183      * @param  autoFlush  A boolean; if true, the output buffer will be flushed</span>
 184      *                    whenever a byte array is written, one of the
 185      *                    {@code println} methods is invoked, or a newline
 186      *                    character or byte ({@code &#39;\n&#39;}) is written
 187      * @param  charset    A {@linkplain java.nio.charset.Charset charset}
 188      *
 189      * @since  10
 190      */
 191     public PrintStream(OutputStream out, boolean autoFlush, Charset charset) {
 192         super(out);
 193         this.autoFlush = autoFlush;
 194         this.charOut = new OutputStreamWriter(this, charset);
 195         this.textOut = new BufferedWriter(charOut);
 196     }
 197 
 198     /**
 199      * Creates a new print stream, without automatic line flushing, with the
 200      * specified file name.  This convenience constructor creates
 201      * the necessary intermediate {@link java.io.OutputStreamWriter
 202      * OutputStreamWriter}, which will encode characters using the
 203      * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}
</pre>
<hr />
<pre>
 393      *          denies write access to the file
 394      *
 395      * @since  10
 396      */
 397     public PrintStream(File file, Charset charset) throws IOException {
 398         this(false, requireNonNull(charset, &quot;charset&quot;), new FileOutputStream(file));
 399     }
 400 
 401     /** Check to make sure that the stream has not been closed */
 402     private void ensureOpen() throws IOException {
 403         if (out == null)
 404             throw new IOException(&quot;Stream closed&quot;);
 405     }
 406 
 407     /**
 408      * Flushes the stream.  This is done by writing any buffered output bytes to
 409      * the underlying output stream and then flushing that stream.
 410      *
 411      * @see        java.io.OutputStream#flush()
 412      */

 413     public void flush() {
 414         synchronized (this) {
 415             try {
 416                 ensureOpen();
 417                 out.flush();
 418             }
 419             catch (IOException x) {
 420                 trouble = true;
 421             }
 422         }
 423     }
 424 
 425     private boolean closing = false; /* To avoid recursive closing */
 426 
 427     /**
 428      * Closes the stream.  This is done by flushing the stream and then closing
 429      * the underlying output stream.
 430      *
 431      * @see        java.io.OutputStream#close()
 432      */

 433     public void close() {
 434         synchronized (this) {
 435             if (! closing) {
 436                 closing = true;
 437                 try {
 438                     textOut.close();
 439                     out.close();
 440                 }
 441                 catch (IOException x) {
 442                     trouble = true;
 443                 }
 444                 textOut = null;
 445                 charOut = null;
 446                 out = null;
 447             }
 448         }
 449     }
 450 
 451     /**
 452      * Flushes the stream and checks its error state. The internal error state
</pre>
<hr />
<pre>
 504 
 505     /*
 506      * Exception-catching, synchronized output operations,
 507      * which also implement the write() methods of OutputStream
 508      */
 509 
 510     /**
 511      * Writes the specified byte to this stream.  If the byte is a newline and
 512      * automatic flushing is enabled then the {@code flush} method will be
 513      * invoked.
 514      *
 515      * &lt;p&gt; Note that the byte is written as given; to write a character that
 516      * will be translated according to the platform&#39;s default character
 517      * encoding, use the {@code print(char)} or {@code println(char)}
 518      * methods.
 519      *
 520      * @param  b  The byte to be written
 521      * @see #print(char)
 522      * @see #println(char)
 523      */

 524     public void write(int b) {
 525         try {
 526             synchronized (this) {
 527                 ensureOpen();
 528                 out.write(b);
 529                 if ((b == &#39;\n&#39;) &amp;&amp; autoFlush)
 530                     out.flush();
 531             }
 532         }
 533         catch (InterruptedIOException x) {
 534             Thread.currentThread().interrupt();
 535         }
 536         catch (IOException x) {
 537             trouble = true;
 538         }
 539     }
 540 
 541     /**
 542      * Writes {@code len} bytes from the specified byte array starting at
 543      * offset {@code off} to this stream.  If automatic flushing is
 544      * enabled then the {@code flush} method will be invoked.
 545      *
 546      * &lt;p&gt; Note that the bytes will be written as given; to write characters
 547      * that will be translated according to the platform&#39;s default character
 548      * encoding, use the {@code print(char)} or {@code println(char)}
 549      * methods.
 550      *
 551      * @param  buf   A byte array
 552      * @param  off   Offset from which to start taking bytes
 553      * @param  len   Number of bytes to write
 554      */

 555     public void write(byte buf[], int off, int len) {
 556         try {
 557             synchronized (this) {
 558                 ensureOpen();
 559                 out.write(buf, off, len);
 560                 if (autoFlush)
 561                     out.flush();
 562             }
 563         }
 564         catch (InterruptedIOException x) {
 565             Thread.currentThread().interrupt();
 566         }
 567         catch (IOException x) {
 568             trouble = true;
 569         }
 570     }
 571 




























































 572     /*
 573      * The following private methods on the text- and character-output streams
 574      * always flush the stream buffers, so that writes to the underlying byte
 575      * stream occur as promptly as with the original PrintStream.
 576      */
 577 
 578     private void write(char[] buf) {
 579         try {
 580             synchronized (this) {
 581                 ensureOpen();
 582                 textOut.write(buf);
 583                 textOut.flushBuffer();
 584                 charOut.flushBuffer();
 585                 if (autoFlush) {
 586                     for (int i = 0; i &lt; buf.length; i++)
 587                         if (buf[i] == &#39;\n&#39;) {
 588                             out.flush();
 589                             break;
 590                         }
 591                 }
</pre>
<hr />
<pre>
 683         }
 684     }
 685 
 686     /* Methods that do not terminate lines */
 687 
 688     /**
 689      * Prints a boolean value.  The string produced by {@link
 690      * java.lang.String#valueOf(boolean)} is translated into bytes
 691      * according to the platform&#39;s default character encoding, and these bytes
 692      * are written in exactly the manner of the
 693      * {@link #write(int)} method.
 694      *
 695      * @param      b   The {@code boolean} to be printed
 696      */
 697     public void print(boolean b) {
 698         write(String.valueOf(b));
 699     }
 700 
 701     /**
 702      * Prints a character.  The character is translated into one or more bytes
<span class="line-modified"> 703      * according to the platform&#39;s default character encoding, and these bytes</span>
<span class="line-modified"> 704      * are written in exactly the manner of the</span>
<span class="line-modified"> 705      * {@link #write(int)} method.</span>
 706      *
 707      * @param      c   The {@code char} to be printed
 708      */
 709     public void print(char c) {
 710         write(String.valueOf(c));
 711     }
 712 
 713     /**
 714      * Prints an integer.  The string produced by {@link
 715      * java.lang.String#valueOf(int)} is translated into bytes
 716      * according to the platform&#39;s default character encoding, and these bytes
 717      * are written in exactly the manner of the
 718      * {@link #write(int)} method.
 719      *
 720      * @param      i   The {@code int} to be printed
 721      * @see        java.lang.Integer#toString(int)
 722      */
 723     public void print(int i) {
 724         write(String.valueOf(i));
 725     }
</pre>
<hr />
<pre>
 751     public void print(float f) {
 752         write(String.valueOf(f));
 753     }
 754 
 755     /**
 756      * Prints a double-precision floating-point number.  The string produced by
 757      * {@link java.lang.String#valueOf(double)} is translated into
 758      * bytes according to the platform&#39;s default character encoding, and these
 759      * bytes are written in exactly the manner of the {@link
 760      * #write(int)} method.
 761      *
 762      * @param      d   The {@code double} to be printed
 763      * @see        java.lang.Double#toString(double)
 764      */
 765     public void print(double d) {
 766         write(String.valueOf(d));
 767     }
 768 
 769     /**
 770      * Prints an array of characters.  The characters are converted into bytes
<span class="line-modified"> 771      * according to the platform&#39;s default character encoding, and these bytes</span>
<span class="line-modified"> 772      * are written in exactly the manner of the</span>
<span class="line-modified"> 773      * {@link #write(int)} method.</span>
 774      *
 775      * @param      s   The array of chars to be printed
 776      *
 777      * @throws  NullPointerException  If {@code s} is {@code null}
 778      */
 779     public void print(char s[]) {
 780         write(s);
 781     }
 782 
 783     /**
 784      * Prints a string.  If the argument is {@code null} then the string
 785      * {@code &quot;null&quot;} is printed.  Otherwise, the string&#39;s characters are
<span class="line-modified"> 786      * converted into bytes according to the platform&#39;s default character</span>
<span class="line-modified"> 787      * encoding, and these bytes are written in exactly the manner of the</span>

 788      * {@link #write(int)} method.
 789      *
 790      * @param      s   The {@code String} to be printed
 791      */
 792     public void print(String s) {
 793         write(String.valueOf(s));
 794     }
 795 
 796     /**
 797      * Prints an object.  The string produced by the {@link
 798      * java.lang.String#valueOf(Object)} method is translated into bytes
 799      * according to the platform&#39;s default character encoding, and these bytes
 800      * are written in exactly the manner of the
 801      * {@link #write(int)} method.
 802      *
 803      * @param      obj   The {@code Object} to be printed
 804      * @see        java.lang.Object#toString()
 805      */
 806     public void print(Object obj) {
 807         write(String.valueOf(obj));
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  28 import java.util.Formatter;
  29 import java.util.Locale;
  30 import java.nio.charset.Charset;
  31 import java.nio.charset.IllegalCharsetNameException;
  32 import java.nio.charset.UnsupportedCharsetException;
  33 
  34 /**
  35  * A {@code PrintStream} adds functionality to another output stream,
  36  * namely the ability to print representations of various data values
  37  * conveniently.  Two other features are provided as well.  Unlike other output
  38  * streams, a {@code PrintStream} never throws an
  39  * {@code IOException}; instead, exceptional situations merely set an
  40  * internal flag that can be tested via the {@code checkError} method.
  41  * Optionally, a {@code PrintStream} can be created so as to flush
  42  * automatically; this means that the {@code flush} method is
  43  * automatically invoked after a byte array is written, one of the
  44  * {@code println} methods is invoked, or a newline character or byte
  45  * ({@code &#39;\n&#39;}) is written.
  46  *
  47  * &lt;p&gt; All characters printed by a {@code PrintStream} are converted into
<span class="line-modified">  48  * bytes using the given encoding or charset, or the platform&#39;s default</span>
<span class="line-modified">  49  * character encoding if not specified.</span>
  50  * The {@link PrintWriter} class should be used in situations that require
<span class="line-modified">  51  * writing characters rather than bytes.</span>
  52  *
  53  * &lt;p&gt; This class always replaces malformed and unmappable character sequences with
  54  * the charset&#39;s default replacement string.
  55  * The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more
  56  * control over the encoding process is required.
  57  *
  58  * @author     Frank Yellin
  59  * @author     Mark Reinhold
  60  * @since      1.0
  61  */
  62 
  63 public class PrintStream extends FilterOutputStream
  64     implements Appendable, Closeable
  65 {
  66 
  67     private final boolean autoFlush;
  68     private boolean trouble = false;
  69     private Formatter formatter;
  70 
  71     /**
</pre>
<hr />
<pre>
 104     }
 105 
 106     /* Private constructors */
 107     private PrintStream(boolean autoFlush, OutputStream out) {
 108         super(out);
 109         this.autoFlush = autoFlush;
 110         this.charOut = new OutputStreamWriter(this);
 111         this.textOut = new BufferedWriter(charOut);
 112     }
 113 
 114     /* Variant of the private constructor so that the given charset name
 115      * can be verified before evaluating the OutputStream argument. Used
 116      * by constructors creating a FileOutputStream that also take a
 117      * charset name.
 118      */
 119     private PrintStream(boolean autoFlush, Charset charset, OutputStream out) {
 120         this(out, autoFlush, charset);
 121     }
 122 
 123     /**
<span class="line-modified"> 124      * Creates a new print stream, without automatic line flushing, with the</span>
<span class="line-added"> 125      * specified OutputStream. Characters written to the stream are converted</span>
<span class="line-added"> 126      * to bytes using the platform&#39;s default character encoding.</span>
 127      *
 128      * @param  out        The output stream to which values and objects will be
 129      *                    printed
 130      *
 131      * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream)
 132      */
 133     public PrintStream(OutputStream out) {
 134         this(out, false);
 135     }
 136 
 137     /**
<span class="line-modified"> 138      * Creates a new print stream, with the specified OutputStream and line</span>
<span class="line-added"> 139      * flushing. Characters written to the stream are converted to bytes using</span>
<span class="line-added"> 140      * the platform&#39;s default character encoding.</span>
 141      *
 142      * @param  out        The output stream to which values and objects will be
 143      *                    printed
<span class="line-modified"> 144      * @param  autoFlush  Whether the output buffer will be flushed</span>
 145      *                    whenever a byte array is written, one of the
 146      *                    {@code println} methods is invoked, or a newline
 147      *                    character or byte ({@code &#39;\n&#39;}) is written
 148      *
 149      * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream, boolean)
 150      */
 151     public PrintStream(OutputStream out, boolean autoFlush) {
 152         this(autoFlush, requireNonNull(out, &quot;Null output stream&quot;));
 153     }
 154 
 155     /**
<span class="line-modified"> 156      * Creates a new print stream, with the specified OutputStream, line</span>
<span class="line-added"> 157      * flushing, and character encoding.</span>
 158      *
 159      * @param  out        The output stream to which values and objects will be
 160      *                    printed
<span class="line-modified"> 161      * @param  autoFlush  Whether the output buffer will be flushed</span>
 162      *                    whenever a byte array is written, one of the
 163      *                    {@code println} methods is invoked, or a newline
 164      *                    character or byte ({@code &#39;\n&#39;}) is written
 165      * @param  encoding   The name of a supported
 166      *                    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;
 167      *                    character encoding&lt;/a&gt;
 168      *
 169      * @throws  UnsupportedEncodingException
 170      *          If the named encoding is not supported
 171      *
 172      * @since  1.4
 173      */
 174     public PrintStream(OutputStream out, boolean autoFlush, String encoding)
 175         throws UnsupportedEncodingException
 176     {
 177         this(requireNonNull(out, &quot;Null output stream&quot;), autoFlush, toCharset(encoding));
 178     }
 179 
 180     /**
<span class="line-modified"> 181      * Creates a new print stream, with the specified OutputStream, line</span>
 182      * flushing and charset.  This convenience constructor creates the necessary
 183      * intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},
 184      * which will encode characters using the provided charset.
 185      *
 186      * @param  out        The output stream to which values and objects will be
 187      *                    printed
<span class="line-modified"> 188      * @param  autoFlush  Whether the output buffer will be flushed</span>
 189      *                    whenever a byte array is written, one of the
 190      *                    {@code println} methods is invoked, or a newline
 191      *                    character or byte ({@code &#39;\n&#39;}) is written
 192      * @param  charset    A {@linkplain java.nio.charset.Charset charset}
 193      *
 194      * @since  10
 195      */
 196     public PrintStream(OutputStream out, boolean autoFlush, Charset charset) {
 197         super(out);
 198         this.autoFlush = autoFlush;
 199         this.charOut = new OutputStreamWriter(this, charset);
 200         this.textOut = new BufferedWriter(charOut);
 201     }
 202 
 203     /**
 204      * Creates a new print stream, without automatic line flushing, with the
 205      * specified file name.  This convenience constructor creates
 206      * the necessary intermediate {@link java.io.OutputStreamWriter
 207      * OutputStreamWriter}, which will encode characters using the
 208      * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}
</pre>
<hr />
<pre>
 398      *          denies write access to the file
 399      *
 400      * @since  10
 401      */
 402     public PrintStream(File file, Charset charset) throws IOException {
 403         this(false, requireNonNull(charset, &quot;charset&quot;), new FileOutputStream(file));
 404     }
 405 
 406     /** Check to make sure that the stream has not been closed */
 407     private void ensureOpen() throws IOException {
 408         if (out == null)
 409             throw new IOException(&quot;Stream closed&quot;);
 410     }
 411 
 412     /**
 413      * Flushes the stream.  This is done by writing any buffered output bytes to
 414      * the underlying output stream and then flushing that stream.
 415      *
 416      * @see        java.io.OutputStream#flush()
 417      */
<span class="line-added"> 418     @Override</span>
 419     public void flush() {
 420         synchronized (this) {
 421             try {
 422                 ensureOpen();
 423                 out.flush();
 424             }
 425             catch (IOException x) {
 426                 trouble = true;
 427             }
 428         }
 429     }
 430 
 431     private boolean closing = false; /* To avoid recursive closing */
 432 
 433     /**
 434      * Closes the stream.  This is done by flushing the stream and then closing
 435      * the underlying output stream.
 436      *
 437      * @see        java.io.OutputStream#close()
 438      */
<span class="line-added"> 439     @Override</span>
 440     public void close() {
 441         synchronized (this) {
 442             if (! closing) {
 443                 closing = true;
 444                 try {
 445                     textOut.close();
 446                     out.close();
 447                 }
 448                 catch (IOException x) {
 449                     trouble = true;
 450                 }
 451                 textOut = null;
 452                 charOut = null;
 453                 out = null;
 454             }
 455         }
 456     }
 457 
 458     /**
 459      * Flushes the stream and checks its error state. The internal error state
</pre>
<hr />
<pre>
 511 
 512     /*
 513      * Exception-catching, synchronized output operations,
 514      * which also implement the write() methods of OutputStream
 515      */
 516 
 517     /**
 518      * Writes the specified byte to this stream.  If the byte is a newline and
 519      * automatic flushing is enabled then the {@code flush} method will be
 520      * invoked.
 521      *
 522      * &lt;p&gt; Note that the byte is written as given; to write a character that
 523      * will be translated according to the platform&#39;s default character
 524      * encoding, use the {@code print(char)} or {@code println(char)}
 525      * methods.
 526      *
 527      * @param  b  The byte to be written
 528      * @see #print(char)
 529      * @see #println(char)
 530      */
<span class="line-added"> 531     @Override</span>
 532     public void write(int b) {
 533         try {
 534             synchronized (this) {
 535                 ensureOpen();
 536                 out.write(b);
 537                 if ((b == &#39;\n&#39;) &amp;&amp; autoFlush)
 538                     out.flush();
 539             }
 540         }
 541         catch (InterruptedIOException x) {
 542             Thread.currentThread().interrupt();
 543         }
 544         catch (IOException x) {
 545             trouble = true;
 546         }
 547     }
 548 
 549     /**
 550      * Writes {@code len} bytes from the specified byte array starting at
 551      * offset {@code off} to this stream.  If automatic flushing is
 552      * enabled then the {@code flush} method will be invoked.
 553      *
 554      * &lt;p&gt; Note that the bytes will be written as given; to write characters
 555      * that will be translated according to the platform&#39;s default character
 556      * encoding, use the {@code print(char)} or {@code println(char)}
 557      * methods.
 558      *
 559      * @param  buf   A byte array
 560      * @param  off   Offset from which to start taking bytes
 561      * @param  len   Number of bytes to write
 562      */
<span class="line-added"> 563     @Override</span>
 564     public void write(byte buf[], int off, int len) {
 565         try {
 566             synchronized (this) {
 567                 ensureOpen();
 568                 out.write(buf, off, len);
 569                 if (autoFlush)
 570                     out.flush();
 571             }
 572         }
 573         catch (InterruptedIOException x) {
 574             Thread.currentThread().interrupt();
 575         }
 576         catch (IOException x) {
 577             trouble = true;
 578         }
 579     }
 580 
<span class="line-added"> 581     /**</span>
<span class="line-added"> 582      * Writes all bytes from the specified byte array to this stream. If</span>
<span class="line-added"> 583      * automatic flushing is enabled then the {@code flush} method will be</span>
<span class="line-added"> 584      * invoked.</span>
<span class="line-added"> 585      *</span>
<span class="line-added"> 586      * &lt;p&gt; Note that the bytes will be written as given; to write characters</span>
<span class="line-added"> 587      * that will be translated according to the platform&#39;s default character</span>
<span class="line-added"> 588      * encoding, use the {@code print(char[])} or {@code println(char[])}</span>
<span class="line-added"> 589      * methods.</span>
<span class="line-added"> 590      *</span>
<span class="line-added"> 591      * @apiNote</span>
<span class="line-added"> 592      * Although declared to throw {@code IOException}, this method never</span>
<span class="line-added"> 593      * actually does so. Instead, like other methods that this class</span>
<span class="line-added"> 594      * overrides, it sets an internal flag which may be tested via the</span>
<span class="line-added"> 595      * {@link #checkError()} method. To write an array of bytes without having</span>
<span class="line-added"> 596      * to write a {@code catch} block for the {@code IOException}, use either</span>
<span class="line-added"> 597      * {@link #writeBytes(byte[] buf) writeBytes(buf)} or</span>
<span class="line-added"> 598      * {@link #write(byte[], int, int) write(buf, 0, buf.length)}.</span>
<span class="line-added"> 599      *</span>
<span class="line-added"> 600      * @implSpec</span>
<span class="line-added"> 601      * This method is equivalent to</span>
<span class="line-added"> 602      * {@link java.io.PrintStream#write(byte[],int,int)</span>
<span class="line-added"> 603      * this.write(buf, 0, buf.length)}.</span>
<span class="line-added"> 604      *</span>
<span class="line-added"> 605      * @param  buf   A byte array</span>
<span class="line-added"> 606      *</span>
<span class="line-added"> 607      * @throws IOException If an I/O error occurs.</span>
<span class="line-added"> 608      *</span>
<span class="line-added"> 609      * @see #writeBytes(byte[])</span>
<span class="line-added"> 610      * @see #write(byte[],int,int)</span>
<span class="line-added"> 611      *</span>
<span class="line-added"> 612      * @since 14</span>
<span class="line-added"> 613      */</span>
<span class="line-added"> 614     @Override</span>
<span class="line-added"> 615     public void write(byte buf[]) throws IOException {</span>
<span class="line-added"> 616         this.write(buf, 0, buf.length);</span>
<span class="line-added"> 617     }</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619     /**</span>
<span class="line-added"> 620      * Writes all bytes from the specified byte array to this stream.</span>
<span class="line-added"> 621      * If automatic flushing is enabled then the {@code flush} method</span>
<span class="line-added"> 622      * will be invoked.</span>
<span class="line-added"> 623      *</span>
<span class="line-added"> 624      * &lt;p&gt; Note that the bytes will be written as given; to write characters</span>
<span class="line-added"> 625      * that will be translated according to the platform&#39;s default character</span>
<span class="line-added"> 626      * encoding, use the {@code print(char[])} or {@code println(char[])}</span>
<span class="line-added"> 627      * methods.</span>
<span class="line-added"> 628      *</span>
<span class="line-added"> 629      * @implSpec</span>
<span class="line-added"> 630      * This method is equivalent to</span>
<span class="line-added"> 631      * {@link #write(byte[], int, int) this.write(buf, 0, buf.length)}.</span>
<span class="line-added"> 632      *</span>
<span class="line-added"> 633      * @param  buf   A byte array</span>
<span class="line-added"> 634      *</span>
<span class="line-added"> 635      * @since 14</span>
<span class="line-added"> 636      */</span>
<span class="line-added"> 637     public void writeBytes(byte buf[]) {</span>
<span class="line-added"> 638         this.write(buf, 0, buf.length);</span>
<span class="line-added"> 639     }</span>
<span class="line-added"> 640 </span>
 641     /*
 642      * The following private methods on the text- and character-output streams
 643      * always flush the stream buffers, so that writes to the underlying byte
 644      * stream occur as promptly as with the original PrintStream.
 645      */
 646 
 647     private void write(char[] buf) {
 648         try {
 649             synchronized (this) {
 650                 ensureOpen();
 651                 textOut.write(buf);
 652                 textOut.flushBuffer();
 653                 charOut.flushBuffer();
 654                 if (autoFlush) {
 655                     for (int i = 0; i &lt; buf.length; i++)
 656                         if (buf[i] == &#39;\n&#39;) {
 657                             out.flush();
 658                             break;
 659                         }
 660                 }
</pre>
<hr />
<pre>
 752         }
 753     }
 754 
 755     /* Methods that do not terminate lines */
 756 
 757     /**
 758      * Prints a boolean value.  The string produced by {@link
 759      * java.lang.String#valueOf(boolean)} is translated into bytes
 760      * according to the platform&#39;s default character encoding, and these bytes
 761      * are written in exactly the manner of the
 762      * {@link #write(int)} method.
 763      *
 764      * @param      b   The {@code boolean} to be printed
 765      */
 766     public void print(boolean b) {
 767         write(String.valueOf(b));
 768     }
 769 
 770     /**
 771      * Prints a character.  The character is translated into one or more bytes
<span class="line-modified"> 772      * according to the character encoding given to the constructor, or the</span>
<span class="line-modified"> 773      * platform&#39;s default character encoding if none specified. These bytes</span>
<span class="line-modified"> 774      * are written in exactly the manner of the {@link #write(int)} method.</span>
 775      *
 776      * @param      c   The {@code char} to be printed
 777      */
 778     public void print(char c) {
 779         write(String.valueOf(c));
 780     }
 781 
 782     /**
 783      * Prints an integer.  The string produced by {@link
 784      * java.lang.String#valueOf(int)} is translated into bytes
 785      * according to the platform&#39;s default character encoding, and these bytes
 786      * are written in exactly the manner of the
 787      * {@link #write(int)} method.
 788      *
 789      * @param      i   The {@code int} to be printed
 790      * @see        java.lang.Integer#toString(int)
 791      */
 792     public void print(int i) {
 793         write(String.valueOf(i));
 794     }
</pre>
<hr />
<pre>
 820     public void print(float f) {
 821         write(String.valueOf(f));
 822     }
 823 
 824     /**
 825      * Prints a double-precision floating-point number.  The string produced by
 826      * {@link java.lang.String#valueOf(double)} is translated into
 827      * bytes according to the platform&#39;s default character encoding, and these
 828      * bytes are written in exactly the manner of the {@link
 829      * #write(int)} method.
 830      *
 831      * @param      d   The {@code double} to be printed
 832      * @see        java.lang.Double#toString(double)
 833      */
 834     public void print(double d) {
 835         write(String.valueOf(d));
 836     }
 837 
 838     /**
 839      * Prints an array of characters.  The characters are converted into bytes
<span class="line-modified"> 840      * according to the character encoding given to the constructor, or the</span>
<span class="line-modified"> 841      * platform&#39;s default character encoding if none specified. These bytes</span>
<span class="line-modified"> 842      * are written in exactly the manner of the {@link #write(int)} method.</span>
 843      *
 844      * @param      s   The array of chars to be printed
 845      *
 846      * @throws  NullPointerException  If {@code s} is {@code null}
 847      */
 848     public void print(char s[]) {
 849         write(s);
 850     }
 851 
 852     /**
 853      * Prints a string.  If the argument is {@code null} then the string
 854      * {@code &quot;null&quot;} is printed.  Otherwise, the string&#39;s characters are
<span class="line-modified"> 855      * converted into bytes according to the character encoding given to the</span>
<span class="line-modified"> 856      * constructor, or the platform&#39;s default character encoding if none</span>
<span class="line-added"> 857      * specified. These bytes are written in exactly the manner of the</span>
 858      * {@link #write(int)} method.
 859      *
 860      * @param      s   The {@code String} to be printed
 861      */
 862     public void print(String s) {
 863         write(String.valueOf(s));
 864     }
 865 
 866     /**
 867      * Prints an object.  The string produced by the {@link
 868      * java.lang.String#valueOf(Object)} method is translated into bytes
 869      * according to the platform&#39;s default character encoding, and these bytes
 870      * are written in exactly the manner of the
 871      * {@link #write(int)} method.
 872      *
 873      * @param      obj   The {@code Object} to be printed
 874      * @see        java.lang.Object#toString()
 875      */
 876     public void print(Object obj) {
 877         write(String.valueOf(obj));
</pre>
</td>
</tr>
</table>
<center><a href="PipedWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PrintWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
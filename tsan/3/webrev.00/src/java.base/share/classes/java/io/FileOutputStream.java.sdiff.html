<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/FileOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FileNotFoundException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FilePermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/FileOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.nio.channels.FileChannel;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.access.JavaIOFileDescriptorAccess;
 31 import sun.nio.ch.FileChannelImpl;
 32 
 33 
 34 /**
 35  * A file output stream is an output stream for writing data to a
<span class="line-modified"> 36  * &lt;code&gt;File&lt;/code&gt; or to a &lt;code&gt;FileDescriptor&lt;/code&gt;. Whether or not</span>
 37  * a file is available or may be created depends upon the underlying
 38  * platform.  Some platforms, in particular, allow a file to be opened
 39  * for writing by only one {@code FileOutputStream} (or other
 40  * file-writing object) at a time.  In such situations the constructors in
 41  * this class will fail if the file involved is already open.
 42  *
<span class="line-modified"> 43  * &lt;p&gt;&lt;code&gt;FileOutputStream&lt;/code&gt; is meant for writing streams of raw bytes</span>
 44  * such as image data. For writing streams of characters, consider using
<span class="line-modified"> 45  * &lt;code&gt;FileWriter&lt;/code&gt;.</span>
 46  *
 47  * @apiNote
 48  * To release resources used by this stream {@link #close} should be called
 49  * directly or by try-with-resources. Subclasses are responsible for the cleanup
 50  * of resources acquired by the subclass.
 51  * Subclasses that override {@link #finalize} in order to perform cleanup
 52  * should be modified to use alternative cleanup mechanisms such as
 53  * {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.
 54  *
 55  * @implSpec
 56  * If this FileOutputStream has been subclassed and the {@link #close}
 57  * method has been overridden, the {@link #close} method will be
 58  * called when the FileInputStream is unreachable.
 59  * Otherwise, it is implementation specific how the resource cleanup described in
 60  * {@link #close} is performed.
 61  *
 62  * @author  Arthur van Hoff
 63  * @see     java.io.File
 64  * @see     java.io.FileDescriptor
 65  * @see     java.io.FileInputStream
 66  * @see     java.nio.file.Files#newOutputStream
 67  * @since   1.0
 68  */
<span class="line-modified"> 69 public</span>
<span class="line-removed"> 70 class FileOutputStream extends OutputStream</span>
 71 {
 72     /**
 73      * Access to FileDescriptor internals.
 74      */
 75     private static final JavaIOFileDescriptorAccess fdAccess =
 76         SharedSecrets.getJavaIOFileDescriptorAccess();
 77 
 78     /**
 79      * The system dependent file descriptor.
 80      */
 81     private final FileDescriptor fd;
 82 
 83     /**
 84      * The associated channel, initialized lazily.
 85      */
 86     private volatile FileChannel channel;
 87 
 88     /**
 89      * The path of the referenced file
 90      * (null if the stream is created with a file descriptor)
 91      */
 92     private final String path;
 93 
 94     private final Object closeLock = new Object();
 95 
 96     private volatile boolean closed;
 97 
 98     /**
 99      * Creates a file output stream to write to the file with the
<span class="line-modified">100      * specified name. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is</span>
101      * created to represent this file connection.
102      * &lt;p&gt;
<span class="line-modified">103      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">104      * method is called with &lt;code&gt;name&lt;/code&gt; as its argument.</span>
105      * &lt;p&gt;
106      * If the file exists but is a directory rather than a regular file, does
107      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">108      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
109      *
110      * @implSpec Invoking this constructor with the parameter {@code name} is
111      * equivalent to invoking {@link #FileOutputStream(String,boolean)
112      * new FileOutputStream(name, false)}.
113      *
114      * @param      name   the system-dependent filename
<span class="line-modified">115      * @exception  FileNotFoundException  if the file exists but is a directory</span>
116      *                   rather than a regular file, does not exist but cannot
117      *                   be created, or cannot be opened for any other reason
<span class="line-modified">118      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">119      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
120      *               to the file.
121      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
122      */
123     public FileOutputStream(String name) throws FileNotFoundException {
124         this(name != null ? new File(name) : null, false);
125     }
126 
127     /**
128      * Creates a file output stream to write to the file with the specified
<span class="line-modified">129      * name.  If the second argument is &lt;code&gt;true&lt;/code&gt;, then</span>
130      * bytes will be written to the end of the file rather than the beginning.
<span class="line-modified">131      * A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this</span>
132      * file connection.
133      * &lt;p&gt;
<span class="line-modified">134      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">135      * method is called with &lt;code&gt;name&lt;/code&gt; as its argument.</span>
136      * &lt;p&gt;
137      * If the file exists but is a directory rather than a regular file, does
138      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">139      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
140      *
141      * @param     name        the system-dependent file name
<span class="line-modified">142      * @param     append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written</span>
143      *                   to the end of the file rather than the beginning
<span class="line-modified">144      * @exception  FileNotFoundException  if the file exists but is a directory</span>
145      *                   rather than a regular file, does not exist but cannot
146      *                   be created, or cannot be opened for any other reason.
<span class="line-modified">147      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">148      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
149      *               to the file.
150      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
151      * @since     1.1
152      */
153     public FileOutputStream(String name, boolean append)
154         throws FileNotFoundException
155     {
156         this(name != null ? new File(name) : null, append);
157     }
158 
159     /**
160      * Creates a file output stream to write to the file represented by
<span class="line-modified">161      * the specified &lt;code&gt;File&lt;/code&gt; object. A new</span>
<span class="line-modified">162      * &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this</span>
163      * file connection.
164      * &lt;p&gt;
<span class="line-modified">165      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">166      * method is called with the path represented by the &lt;code&gt;file&lt;/code&gt;</span>
167      * argument as its argument.
168      * &lt;p&gt;
169      * If the file exists but is a directory rather than a regular file, does
170      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">171      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
172      *
173      * @param      file               the file to be opened for writing.
<span class="line-modified">174      * @exception  FileNotFoundException  if the file exists but is a directory</span>
175      *                   rather than a regular file, does not exist but cannot
176      *                   be created, or cannot be opened for any other reason
<span class="line-modified">177      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">178      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
179      *               to the file.
180      * @see        java.io.File#getPath()
181      * @see        java.lang.SecurityException
182      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
183      */
184     public FileOutputStream(File file) throws FileNotFoundException {
185         this(file, false);
186     }
187 
188     /**
189      * Creates a file output stream to write to the file represented by
<span class="line-modified">190      * the specified &lt;code&gt;File&lt;/code&gt; object. If the second argument is</span>
<span class="line-modified">191      * &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file</span>
<span class="line-modified">192      * rather than the beginning. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is</span>
193      * created to represent this file connection.
194      * &lt;p&gt;
<span class="line-modified">195      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">196      * method is called with the path represented by the &lt;code&gt;file&lt;/code&gt;</span>
197      * argument as its argument.
198      * &lt;p&gt;
199      * If the file exists but is a directory rather than a regular file, does
200      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">201      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
202      *
203      * @param      file               the file to be opened for writing.
<span class="line-modified">204      * @param     append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written</span>
205      *                   to the end of the file rather than the beginning
<span class="line-modified">206      * @exception  FileNotFoundException  if the file exists but is a directory</span>
207      *                   rather than a regular file, does not exist but cannot
208      *                   be created, or cannot be opened for any other reason
<span class="line-modified">209      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">210      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
211      *               to the file.
212      * @see        java.io.File#getPath()
213      * @see        java.lang.SecurityException
214      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
215      * @since 1.4
216      */
217     public FileOutputStream(File file, boolean append)
218         throws FileNotFoundException
219     {
220         String name = (file != null ? file.getPath() : null);
221         SecurityManager security = System.getSecurityManager();
222         if (security != null) {
223             security.checkWrite(name);
224         }
225         if (name == null) {
226             throw new NullPointerException();
227         }
228         if (file.isInvalid()) {
229             throw new FileNotFoundException(&quot;Invalid file path&quot;);
230         }
231         this.fd = new FileDescriptor();
232         fd.attach(this);
233         this.path = name;
234 
235         open(name, append);
236         FileCleanable.register(fd);   // open sets the fd, register the cleanup
237     }
238 
239     /**
240      * Creates a file output stream to write to the specified file
241      * descriptor, which represents an existing connection to an actual
242      * file in the file system.
243      * &lt;p&gt;
<span class="line-modified">244      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">245      * method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt;</span>
246      * argument as its argument.
247      * &lt;p&gt;
<span class="line-modified">248      * If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt;</span>
249      * is thrown.
250      * &lt;p&gt;
<span class="line-modified">251      * This constructor does not throw an exception if &lt;code&gt;fdObj&lt;/code&gt;</span>
252      * is {@link java.io.FileDescriptor#valid() invalid}.
253      * However, if the methods are invoked on the resulting stream to attempt
<span class="line-modified">254      * I/O on the stream, an &lt;code&gt;IOException&lt;/code&gt; is thrown.</span>
255      *
256      * @param      fdObj   the file descriptor to be opened for writing
<span class="line-modified">257      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">258      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies</span>
259      *               write access to the file descriptor
260      * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
261      */
262     public FileOutputStream(FileDescriptor fdObj) {
263         SecurityManager security = System.getSecurityManager();
264         if (fdObj == null) {
265             throw new NullPointerException();
266         }
267         if (security != null) {
268             security.checkWrite(fdObj);
269         }
270         this.fd = fdObj;
271         this.path = null;
272 
273         fd.attach(this);
274     }
275 
276     /**
277      * Opens a file, with the specified name, for overwriting or appending.
278      * @param name name of file to be opened
</pre>
<hr />
<pre>
286      * Opens a file, with the specified name, for overwriting or appending.
287      * @param name name of file to be opened
288      * @param append whether the file is to be opened in append mode
289      */
290     private void open(String name, boolean append)
291         throws FileNotFoundException {
292         open0(name, append);
293     }
294 
295     /**
296      * Writes the specified byte to this file output stream.
297      *
298      * @param   b   the byte to be written.
299      * @param   append   {@code true} if the write operation first
300      *     advances the position to the end of file
301      */
302     private native void write(int b, boolean append) throws IOException;
303 
304     /**
305      * Writes the specified byte to this file output stream. Implements
<span class="line-modified">306      * the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</span>
307      *
308      * @param      b   the byte to be written.
<span class="line-modified">309      * @exception  IOException  if an I/O error occurs.</span>
310      */
311     public void write(int b) throws IOException {
312         write(b, fdAccess.getAppend(fd));
313     }
314 
315     /**
316      * Writes a sub array as a sequence of bytes.
317      * @param b the data to be written
318      * @param off the start offset in the data
319      * @param len the number of bytes that are written
320      * @param append {@code true} to first advance the position to the
321      *     end of file
<span class="line-modified">322      * @exception IOException If an I/O error has occurred.</span>
323      */
324     private native void writeBytes(byte b[], int off, int len, boolean append)
325         throws IOException;
326 
327     /**
<span class="line-modified">328      * Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array</span>
329      * to this file output stream.
330      *
331      * @param      b   the data.
<span class="line-modified">332      * @exception  IOException  if an I/O error occurs.</span>
333      */
334     public void write(byte b[]) throws IOException {
335         writeBytes(b, 0, b.length, fdAccess.getAppend(fd));
336     }
337 
338     /**
<span class="line-modified">339      * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array</span>
<span class="line-modified">340      * starting at offset &lt;code&gt;off&lt;/code&gt; to this file output stream.</span>
341      *
342      * @param      b     the data.
343      * @param      off   the start offset in the data.
344      * @param      len   the number of bytes to write.
<span class="line-modified">345      * @exception  IOException  if an I/O error occurs.</span>
346      */
347     public void write(byte b[], int off, int len) throws IOException {
348         writeBytes(b, off, len, fdAccess.getAppend(fd));
349     }
350 
351     /**
352      * Closes this file output stream and releases any system resources
353      * associated with this stream. This file output stream may no longer
354      * be used for writing bytes.
355      *
356      * &lt;p&gt; If this stream has an associated channel then the channel is closed
357      * as well.
358      *
359      * @apiNote
360      * Overriding {@link #close} to perform cleanup actions is reliable
361      * only when called directly or when called by try-with-resources.
362      * Do not depend on finalization to invoke {@code close};
363      * finalization is not reliable and is deprecated.
364      * If cleanup of native resources is needed, other mechanisms such as
365      * {@linkplain java.lang.ref.Cleaner} should be used.
366      *
<span class="line-modified">367      * @exception  IOException  if an I/O error occurs.</span>
368      *
369      * @revised 1.4
370      * @spec JSR-51
371      */
372     public void close() throws IOException {
373         if (closed) {
374             return;
375         }
376         synchronized (closeLock) {
377             if (closed) {
378                 return;
379             }
380             closed = true;
381         }
382 
383         FileChannel fc = channel;
384         if (fc != null) {
385             // possible race with getChannel(), benign since
386             // FileChannel.close is final and idempotent
387             fc.close();
388         }
389 
390         fd.closeAll(new Closeable() {
391             public void close() throws IOException {
392                fd.close();
393            }
394         });
395     }
396 
397     /**
398      * Returns the file descriptor associated with this stream.
399      *
<span class="line-modified">400      * @return  the &lt;code&gt;FileDescriptor&lt;/code&gt; object that represents</span>
401      *          the connection to the file in the file system being used
<span class="line-modified">402      *          by this &lt;code&gt;FileOutputStream&lt;/code&gt; object.</span>
403      *
<span class="line-modified">404      * @exception  IOException  if an I/O error occurs.</span>
405      * @see        java.io.FileDescriptor
406      */
407      public final FileDescriptor getFD()  throws IOException {
408         if (fd != null) {
409             return fd;
410         }
411         throw new IOException();
412      }
413 
414     /**
415      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
416      * object associated with this file output stream.
417      *
418      * &lt;p&gt; The initial {@link java.nio.channels.FileChannel#position()
419      * position} of the returned channel will be equal to the
420      * number of bytes written to the file so far unless this stream is in
421      * append mode, in which case it will be equal to the size of the file.
422      * Writing bytes to this stream will increment the channel&#39;s position
423      * accordingly.  Changing the channel&#39;s position, either explicitly or by
424      * writing, will change this stream&#39;s file position.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.nio.channels.FileChannel;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.access.JavaIOFileDescriptorAccess;
 31 import sun.nio.ch.FileChannelImpl;
 32 
 33 
 34 /**
 35  * A file output stream is an output stream for writing data to a
<span class="line-modified"> 36  * {@code File} or to a {@code FileDescriptor}. Whether or not</span>
 37  * a file is available or may be created depends upon the underlying
 38  * platform.  Some platforms, in particular, allow a file to be opened
 39  * for writing by only one {@code FileOutputStream} (or other
 40  * file-writing object) at a time.  In such situations the constructors in
 41  * this class will fail if the file involved is already open.
 42  *
<span class="line-modified"> 43  * &lt;p&gt;{@code FileOutputStream} is meant for writing streams of raw bytes</span>
 44  * such as image data. For writing streams of characters, consider using
<span class="line-modified"> 45  * {@code FileWriter}.</span>
 46  *
 47  * @apiNote
 48  * To release resources used by this stream {@link #close} should be called
 49  * directly or by try-with-resources. Subclasses are responsible for the cleanup
 50  * of resources acquired by the subclass.
 51  * Subclasses that override {@link #finalize} in order to perform cleanup
 52  * should be modified to use alternative cleanup mechanisms such as
 53  * {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.
 54  *
 55  * @implSpec
 56  * If this FileOutputStream has been subclassed and the {@link #close}
 57  * method has been overridden, the {@link #close} method will be
 58  * called when the FileInputStream is unreachable.
 59  * Otherwise, it is implementation specific how the resource cleanup described in
 60  * {@link #close} is performed.
 61  *
 62  * @author  Arthur van Hoff
 63  * @see     java.io.File
 64  * @see     java.io.FileDescriptor
 65  * @see     java.io.FileInputStream
 66  * @see     java.nio.file.Files#newOutputStream
 67  * @since   1.0
 68  */
<span class="line-modified"> 69 public class FileOutputStream extends OutputStream</span>

 70 {
 71     /**
 72      * Access to FileDescriptor internals.
 73      */
 74     private static final JavaIOFileDescriptorAccess fdAccess =
 75         SharedSecrets.getJavaIOFileDescriptorAccess();
 76 
 77     /**
 78      * The system dependent file descriptor.
 79      */
 80     private final FileDescriptor fd;
 81 
 82     /**
 83      * The associated channel, initialized lazily.
 84      */
 85     private volatile FileChannel channel;
 86 
 87     /**
 88      * The path of the referenced file
 89      * (null if the stream is created with a file descriptor)
 90      */
 91     private final String path;
 92 
 93     private final Object closeLock = new Object();
 94 
 95     private volatile boolean closed;
 96 
 97     /**
 98      * Creates a file output stream to write to the file with the
<span class="line-modified"> 99      * specified name. A new {@code FileDescriptor} object is</span>
100      * created to represent this file connection.
101      * &lt;p&gt;
<span class="line-modified">102      * First, if there is a security manager, its {@code checkWrite}</span>
<span class="line-modified">103      * method is called with {@code name} as its argument.</span>
104      * &lt;p&gt;
105      * If the file exists but is a directory rather than a regular file, does
106      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">107      * reason then a {@code FileNotFoundException} is thrown.</span>
108      *
109      * @implSpec Invoking this constructor with the parameter {@code name} is
110      * equivalent to invoking {@link #FileOutputStream(String,boolean)
111      * new FileOutputStream(name, false)}.
112      *
113      * @param      name   the system-dependent filename
<span class="line-modified">114      * @throws     FileNotFoundException  if the file exists but is a directory</span>
115      *                   rather than a regular file, does not exist but cannot
116      *                   be created, or cannot be opened for any other reason
<span class="line-modified">117      * @throws     SecurityException  if a security manager exists and its</span>
<span class="line-modified">118      *               {@code checkWrite} method denies write access</span>
119      *               to the file.
120      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
121      */
122     public FileOutputStream(String name) throws FileNotFoundException {
123         this(name != null ? new File(name) : null, false);
124     }
125 
126     /**
127      * Creates a file output stream to write to the file with the specified
<span class="line-modified">128      * name.  If the second argument is {@code true}, then</span>
129      * bytes will be written to the end of the file rather than the beginning.
<span class="line-modified">130      * A new {@code FileDescriptor} object is created to represent this</span>
131      * file connection.
132      * &lt;p&gt;
<span class="line-modified">133      * First, if there is a security manager, its {@code checkWrite}</span>
<span class="line-modified">134      * method is called with {@code name} as its argument.</span>
135      * &lt;p&gt;
136      * If the file exists but is a directory rather than a regular file, does
137      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">138      * reason then a {@code FileNotFoundException} is thrown.</span>
139      *
140      * @param     name        the system-dependent file name
<span class="line-modified">141      * @param     append      if {@code true}, then bytes will be written</span>
142      *                   to the end of the file rather than the beginning
<span class="line-modified">143      * @throws     FileNotFoundException  if the file exists but is a directory</span>
144      *                   rather than a regular file, does not exist but cannot
145      *                   be created, or cannot be opened for any other reason.
<span class="line-modified">146      * @throws     SecurityException  if a security manager exists and its</span>
<span class="line-modified">147      *               {@code checkWrite} method denies write access</span>
148      *               to the file.
149      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
150      * @since     1.1
151      */
152     public FileOutputStream(String name, boolean append)
153         throws FileNotFoundException
154     {
155         this(name != null ? new File(name) : null, append);
156     }
157 
158     /**
159      * Creates a file output stream to write to the file represented by
<span class="line-modified">160      * the specified {@code File} object. A new</span>
<span class="line-modified">161      * {@code FileDescriptor} object is created to represent this</span>
162      * file connection.
163      * &lt;p&gt;
<span class="line-modified">164      * First, if there is a security manager, its {@code checkWrite}</span>
<span class="line-modified">165      * method is called with the path represented by the {@code file}</span>
166      * argument as its argument.
167      * &lt;p&gt;
168      * If the file exists but is a directory rather than a regular file, does
169      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">170      * reason then a {@code FileNotFoundException} is thrown.</span>
171      *
172      * @param      file               the file to be opened for writing.
<span class="line-modified">173      * @throws     FileNotFoundException  if the file exists but is a directory</span>
174      *                   rather than a regular file, does not exist but cannot
175      *                   be created, or cannot be opened for any other reason
<span class="line-modified">176      * @throws     SecurityException  if a security manager exists and its</span>
<span class="line-modified">177      *               {@code checkWrite} method denies write access</span>
178      *               to the file.
179      * @see        java.io.File#getPath()
180      * @see        java.lang.SecurityException
181      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
182      */
183     public FileOutputStream(File file) throws FileNotFoundException {
184         this(file, false);
185     }
186 
187     /**
188      * Creates a file output stream to write to the file represented by
<span class="line-modified">189      * the specified {@code File} object. If the second argument is</span>
<span class="line-modified">190      * {@code true}, then bytes will be written to the end of the file</span>
<span class="line-modified">191      * rather than the beginning. A new {@code FileDescriptor} object is</span>
192      * created to represent this file connection.
193      * &lt;p&gt;
<span class="line-modified">194      * First, if there is a security manager, its {@code checkWrite}</span>
<span class="line-modified">195      * method is called with the path represented by the {@code file}</span>
196      * argument as its argument.
197      * &lt;p&gt;
198      * If the file exists but is a directory rather than a regular file, does
199      * not exist but cannot be created, or cannot be opened for any other
<span class="line-modified">200      * reason then a {@code FileNotFoundException} is thrown.</span>
201      *
202      * @param      file               the file to be opened for writing.
<span class="line-modified">203      * @param     append      if {@code true}, then bytes will be written</span>
204      *                   to the end of the file rather than the beginning
<span class="line-modified">205      * @throws     FileNotFoundException  if the file exists but is a directory</span>
206      *                   rather than a regular file, does not exist but cannot
207      *                   be created, or cannot be opened for any other reason
<span class="line-modified">208      * @throws     SecurityException  if a security manager exists and its</span>
<span class="line-modified">209      *               {@code checkWrite} method denies write access</span>
210      *               to the file.
211      * @see        java.io.File#getPath()
212      * @see        java.lang.SecurityException
213      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
214      * @since 1.4
215      */
216     public FileOutputStream(File file, boolean append)
217         throws FileNotFoundException
218     {
219         String name = (file != null ? file.getPath() : null);
220         SecurityManager security = System.getSecurityManager();
221         if (security != null) {
222             security.checkWrite(name);
223         }
224         if (name == null) {
225             throw new NullPointerException();
226         }
227         if (file.isInvalid()) {
228             throw new FileNotFoundException(&quot;Invalid file path&quot;);
229         }
230         this.fd = new FileDescriptor();
231         fd.attach(this);
232         this.path = name;
233 
234         open(name, append);
235         FileCleanable.register(fd);   // open sets the fd, register the cleanup
236     }
237 
238     /**
239      * Creates a file output stream to write to the specified file
240      * descriptor, which represents an existing connection to an actual
241      * file in the file system.
242      * &lt;p&gt;
<span class="line-modified">243      * First, if there is a security manager, its {@code checkWrite}</span>
<span class="line-modified">244      * method is called with the file descriptor {@code fdObj}</span>
245      * argument as its argument.
246      * &lt;p&gt;
<span class="line-modified">247      * If {@code fdObj} is null then a {@code NullPointerException}</span>
248      * is thrown.
249      * &lt;p&gt;
<span class="line-modified">250      * This constructor does not throw an exception if {@code fdObj}</span>
251      * is {@link java.io.FileDescriptor#valid() invalid}.
252      * However, if the methods are invoked on the resulting stream to attempt
<span class="line-modified">253      * I/O on the stream, an {@code IOException} is thrown.</span>
254      *
255      * @param      fdObj   the file descriptor to be opened for writing
<span class="line-modified">256      * @throws     SecurityException  if a security manager exists and its</span>
<span class="line-modified">257      *               {@code checkWrite} method denies</span>
258      *               write access to the file descriptor
259      * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
260      */
261     public FileOutputStream(FileDescriptor fdObj) {
262         SecurityManager security = System.getSecurityManager();
263         if (fdObj == null) {
264             throw new NullPointerException();
265         }
266         if (security != null) {
267             security.checkWrite(fdObj);
268         }
269         this.fd = fdObj;
270         this.path = null;
271 
272         fd.attach(this);
273     }
274 
275     /**
276      * Opens a file, with the specified name, for overwriting or appending.
277      * @param name name of file to be opened
</pre>
<hr />
<pre>
285      * Opens a file, with the specified name, for overwriting or appending.
286      * @param name name of file to be opened
287      * @param append whether the file is to be opened in append mode
288      */
289     private void open(String name, boolean append)
290         throws FileNotFoundException {
291         open0(name, append);
292     }
293 
294     /**
295      * Writes the specified byte to this file output stream.
296      *
297      * @param   b   the byte to be written.
298      * @param   append   {@code true} if the write operation first
299      *     advances the position to the end of file
300      */
301     private native void write(int b, boolean append) throws IOException;
302 
303     /**
304      * Writes the specified byte to this file output stream. Implements
<span class="line-modified">305      * the {@code write} method of {@code OutputStream}.</span>
306      *
307      * @param      b   the byte to be written.
<span class="line-modified">308      * @throws     IOException  if an I/O error occurs.</span>
309      */
310     public void write(int b) throws IOException {
311         write(b, fdAccess.getAppend(fd));
312     }
313 
314     /**
315      * Writes a sub array as a sequence of bytes.
316      * @param b the data to be written
317      * @param off the start offset in the data
318      * @param len the number of bytes that are written
319      * @param append {@code true} to first advance the position to the
320      *     end of file
<span class="line-modified">321      * @throws    IOException If an I/O error has occurred.</span>
322      */
323     private native void writeBytes(byte b[], int off, int len, boolean append)
324         throws IOException;
325 
326     /**
<span class="line-modified">327      * Writes {@code b.length} bytes from the specified byte array</span>
328      * to this file output stream.
329      *
330      * @param      b   the data.
<span class="line-modified">331      * @throws     IOException  if an I/O error occurs.</span>
332      */
333     public void write(byte b[]) throws IOException {
334         writeBytes(b, 0, b.length, fdAccess.getAppend(fd));
335     }
336 
337     /**
<span class="line-modified">338      * Writes {@code len} bytes from the specified byte array</span>
<span class="line-modified">339      * starting at offset {@code off} to this file output stream.</span>
340      *
341      * @param      b     the data.
342      * @param      off   the start offset in the data.
343      * @param      len   the number of bytes to write.
<span class="line-modified">344      * @throws     IOException  if an I/O error occurs.</span>
345      */
346     public void write(byte b[], int off, int len) throws IOException {
347         writeBytes(b, off, len, fdAccess.getAppend(fd));
348     }
349 
350     /**
351      * Closes this file output stream and releases any system resources
352      * associated with this stream. This file output stream may no longer
353      * be used for writing bytes.
354      *
355      * &lt;p&gt; If this stream has an associated channel then the channel is closed
356      * as well.
357      *
358      * @apiNote
359      * Overriding {@link #close} to perform cleanup actions is reliable
360      * only when called directly or when called by try-with-resources.
361      * Do not depend on finalization to invoke {@code close};
362      * finalization is not reliable and is deprecated.
363      * If cleanup of native resources is needed, other mechanisms such as
364      * {@linkplain java.lang.ref.Cleaner} should be used.
365      *
<span class="line-modified">366      * @throws     IOException  if an I/O error occurs.</span>
367      *
368      * @revised 1.4
369      * @spec JSR-51
370      */
371     public void close() throws IOException {
372         if (closed) {
373             return;
374         }
375         synchronized (closeLock) {
376             if (closed) {
377                 return;
378             }
379             closed = true;
380         }
381 
382         FileChannel fc = channel;
383         if (fc != null) {
384             // possible race with getChannel(), benign since
385             // FileChannel.close is final and idempotent
386             fc.close();
387         }
388 
389         fd.closeAll(new Closeable() {
390             public void close() throws IOException {
391                fd.close();
392            }
393         });
394     }
395 
396     /**
397      * Returns the file descriptor associated with this stream.
398      *
<span class="line-modified">399      * @return  the {@code FileDescriptor} object that represents</span>
400      *          the connection to the file in the file system being used
<span class="line-modified">401      *          by this {@code FileOutputStream} object.</span>
402      *
<span class="line-modified">403      * @throws     IOException  if an I/O error occurs.</span>
404      * @see        java.io.FileDescriptor
405      */
406      public final FileDescriptor getFD()  throws IOException {
407         if (fd != null) {
408             return fd;
409         }
410         throw new IOException();
411      }
412 
413     /**
414      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
415      * object associated with this file output stream.
416      *
417      * &lt;p&gt; The initial {@link java.nio.channels.FileChannel#position()
418      * position} of the returned channel will be equal to the
419      * number of bytes written to the file so far unless this stream is in
420      * append mode, in which case it will be equal to the size of the file.
421      * Writing bytes to this stream will increment the channel&#39;s position
422      * accordingly.  Changing the channel&#39;s position, either explicitly or by
423      * writing, will change this stream&#39;s file position.
</pre>
</td>
</tr>
</table>
<center><a href="FileNotFoundException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FilePermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
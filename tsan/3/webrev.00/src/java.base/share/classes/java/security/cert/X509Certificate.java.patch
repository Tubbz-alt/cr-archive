diff a/src/java.base/share/classes/java/security/cert/X509Certificate.java b/src/java.base/share/classes/java/security/cert/X509Certificate.java
--- a/src/java.base/share/classes/java/security/cert/X509Certificate.java
+++ b/src/java.base/share/classes/java/security/cert/X509Certificate.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -106,10 +106,11 @@
  */
 
 public abstract class X509Certificate extends Certificate
 implements X509Extension {
 
+    @java.io.Serial
     private static final long serialVersionUID = -2491127588187038216L;
 
     private transient X500Principal subjectX500Principal, issuerX500Principal;
 
     /**
@@ -138,12 +139,12 @@
      * CertificateValidityDate ::= CHOICE {
      *     utcTime        UTCTime,
      *     generalTime    GeneralizedTime }
      * </pre>
      *
-     * @exception CertificateExpiredException if the certificate has expired.
-     * @exception CertificateNotYetValidException if the certificate is not
+     * @throws    CertificateExpiredException if the certificate has expired.
+     * @throws    CertificateNotYetValidException if the certificate is not
      * yet valid.
      */
     public abstract void checkValidity()
         throws CertificateExpiredException, CertificateNotYetValidException;
 
@@ -153,13 +154,13 @@
      * certificate would be valid at the given date/time.
      *
      * @param date the Date to check against to see if this certificate
      *        is valid at that date/time.
      *
-     * @exception CertificateExpiredException if the certificate has expired
+     * @throws    CertificateExpiredException if the certificate has expired
      * with respect to the {@code date} supplied.
-     * @exception CertificateNotYetValidException if the certificate is not
+     * @throws    CertificateNotYetValidException if the certificate is not
      * yet valid with respect to the {@code date} supplied.
      *
      * @see #checkValidity()
      */
     public abstract void checkValidity(Date date)
@@ -331,11 +332,11 @@
      * Gets the DER-encoded certificate information, the
      * {@code tbsCertificate} from this certificate.
      * This can be used to verify the signature independently.
      *
      * @return the DER-encoded certificate information.
-     * @exception CertificateEncodingException if an encoding error occurs.
+     * @throws    CertificateEncodingException if an encoding error occurs.
      */
     public abstract byte[] getTBSCertificate()
         throws CertificateEncodingException;
 
     /**
@@ -663,31 +664,29 @@
      * and it provides a default implementation.
      *
      * @param key the PublicKey used to carry out the verification.
      * @param sigProvider the signature provider.
      *
-     * @exception NoSuchAlgorithmException on unsupported signature
+     * @throws    NoSuchAlgorithmException on unsupported signature
      * algorithms.
-     * @exception InvalidKeyException on incorrect key.
-     * @exception SignatureException on signature errors.
-     * @exception CertificateException on encoding errors.
-     * @exception UnsupportedOperationException if the method is not supported
+     * @throws    InvalidKeyException on incorrect key.
+     * @throws    SignatureException on signature errors.
+     * @throws    CertificateException on encoding errors.
+     * @throws    UnsupportedOperationException if the method is not supported
      * @since 1.8
      */
     public void verify(PublicKey key, Provider sigProvider)
         throws CertificateException, NoSuchAlgorithmException,
         InvalidKeyException, SignatureException {
+        String sigName = getSigAlgName();
         Signature sig = (sigProvider == null)
-            ? Signature.getInstance(getSigAlgName())
-            : Signature.getInstance(getSigAlgName(), sigProvider);
+            ? Signature.getInstance(sigName)
+            : Signature.getInstance(sigName, sigProvider);
 
-        sig.initVerify(key);
-
-        // set parameters after Signature.initSign/initVerify call,
-        // so the deferred provider selections occur when key is set
         try {
-            SignatureUtil.specialSetParameter(sig, getSigAlgParams());
+            SignatureUtil.initVerifyWithParam(sig, key,
+                SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
         } catch (ProviderException e) {
             throw new CertificateException(e.getMessage(), e.getCause());
         } catch (InvalidAlgorithmParameterException e) {
             throw new CertificateException(e);
         }

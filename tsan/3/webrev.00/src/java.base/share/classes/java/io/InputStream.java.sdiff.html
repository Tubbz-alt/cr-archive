<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/InputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="IOException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputStreamReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/InputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.List;
 31 import java.util.Objects;
 32 
 33 /**
 34  * This abstract class is the superclass of all classes representing
 35  * an input stream of bytes.
 36  *
<span class="line-modified"> 37  * &lt;p&gt; Applications that need to define a subclass of &lt;code&gt;InputStream&lt;/code&gt;</span>
 38  * must always provide a method that returns the next byte of input.
 39  *
 40  * @author  Arthur van Hoff
 41  * @see     java.io.BufferedInputStream
 42  * @see     java.io.ByteArrayInputStream
 43  * @see     java.io.DataInputStream
 44  * @see     java.io.FilterInputStream
 45  * @see     java.io.InputStream#read()
 46  * @see     java.io.OutputStream
 47  * @see     java.io.PushbackInputStream
 48  * @since   1.0
 49  */
 50 public abstract class InputStream implements Closeable {
 51 
 52     // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to
 53     // use when skipping.
 54     private static final int MAX_SKIP_BUFFER_SIZE = 2048;
 55 
 56     private static final int DEFAULT_BUFFER_SIZE = 8192;
 57 





 58     /**
 59      * Returns a new {@code InputStream} that reads no bytes. The returned
 60      * stream is initially open.  The stream is closed by calling the
 61      * {@code close()} method.  Subsequent calls to {@code close()} have no
 62      * effect.
 63      *
 64      * &lt;p&gt; While the stream is open, the {@code available()}, {@code read()},
 65      * {@code read(byte[])}, {@code read(byte[], int, int)},
 66      * {@code readAllBytes()}, {@code readNBytes(byte[], int, int)},
 67      * {@code readNBytes(int)}, {@code skip(long)}, {@code skipNBytes(long)},
 68      * and {@code transferTo()} methods all behave as if end of stream has been
 69      * reached.  After the stream has been closed, these methods all throw
 70      * {@code IOException}.
 71      *
 72      * &lt;p&gt; The {@code markSupported()} method returns {@code false}.  The
 73      * {@code mark()} method does nothing, and the {@code reset()} method
 74      * throws {@code IOException}.
 75      *
 76      * @return an {@code InputStream} which contains no bytes
 77      *
</pre>
<hr />
<pre>
145                     throw new EOFException();
146                 }
147             }
148 
149             @Override
150             public long transferTo(OutputStream out) throws IOException {
151                 Objects.requireNonNull(out);
152                 ensureOpen();
153                 return 0L;
154             }
155 
156             @Override
157             public void close() throws IOException {
158                 closed = true;
159             }
160         };
161     }
162 
163     /**
164      * Reads the next byte of data from the input stream. The value byte is
<span class="line-modified">165      * returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to</span>
<span class="line-modified">166      * &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the stream</span>
<span class="line-modified">167      * has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. This method</span>
168      * blocks until input data is available, the end of the stream is detected,
169      * or an exception is thrown.
170      *
171      * &lt;p&gt; A subclass must provide an implementation of this method.
172      *
<span class="line-modified">173      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span>
174      *             stream is reached.
<span class="line-modified">175      * @exception  IOException  if an I/O error occurs.</span>
176      */
177     public abstract int read() throws IOException;
178 
179     /**
180      * Reads some number of bytes from the input stream and stores them into
<span class="line-modified">181      * the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is</span>
182      * returned as an integer.  This method blocks until input data is
183      * available, end of file is detected, or an exception is thrown.
184      *
<span class="line-modified">185      * &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">186      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
187      * least one byte. If no byte is available because the stream is at the
<span class="line-modified">188      * end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at</span>
<span class="line-modified">189      * least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
190      *
<span class="line-modified">191      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span>
<span class="line-modified">192      * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is,</span>
<span class="line-modified">193      * at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the</span>
194      * number of bytes actually read; these bytes will be stored in elements
<span class="line-modified">195      * &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">196      * leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">197      * &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.</span>
198      *
<span class="line-modified">199      * &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">200      * has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt;</span>
201      *
202      * @param      b   the buffer into which the data is read.
203      * @return     the total number of bytes read into the buffer, or
<span class="line-modified">204      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
205      *             the stream has been reached.
<span class="line-modified">206      * @exception  IOException  If the first byte cannot be read for any reason</span>
<span class="line-modified">207      * other than the end of the file, if the input stream has been closed, or</span>
<span class="line-modified">208      * if some other I/O error occurs.</span>
<span class="line-modified">209      * @exception  NullPointerException  if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
210      * @see        java.io.InputStream#read(byte[], int, int)
211      */
212     public int read(byte b[]) throws IOException {
213         return read(b, 0, b.length);
214     }
215 
216     /**
<span class="line-modified">217      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the input stream into</span>
218      * an array of bytes.  An attempt is made to read as many as
<span class="line-modified">219      * &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read.</span>
220      * The number of bytes actually read is returned as an integer.
221      *
222      * &lt;p&gt; This method blocks until input data is available, end of file is
223      * detected, or an exception is thrown.
224      *
<span class="line-modified">225      * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">226      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
227      * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">228      * file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one</span>
<span class="line-modified">229      * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
230      *
<span class="line-modified">231      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the</span>
<span class="line-modified">232      * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified">233      * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
234      * bytes actually read; these bytes will be stored in elements
<span class="line-modified">235      * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">236      * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">237      * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.</span>
<span class="line-modified">238      *</span>
<span class="line-modified">239      * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through</span>
<span class="line-modified">240      * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through</span>
<span class="line-modified">241      * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</span>
<span class="line-modified">242      *</span>
<span class="line-modified">243      * &lt;p&gt; The &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method</span>
<span class="line-modified">244      * for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method</span>
<span class="line-modified">245      * &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an</span>
<span class="line-modified">246      * &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to</span>
<span class="line-modified">247      * the &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method.  If</span>
<span class="line-modified">248      * any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a</span>
<span class="line-modified">249      * &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it</span>
250      * were end of file; the bytes read up to that point are stored into
<span class="line-modified">251      * &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception</span>
252      * occurred is returned. The default implementation of this method blocks
<span class="line-modified">253      * until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read,</span>
254      * end of file is detected, or an exception is thrown. Subclasses are
255      * encouraged to provide a more efficient implementation of this method.
256      *
257      * @param      b     the buffer into which the data is read.
<span class="line-modified">258      * @param      off   the start offset in array &lt;code&gt;b&lt;/code&gt;</span>
259      *                   at which the data is written.
260      * @param      len   the maximum number of bytes to read.
261      * @return     the total number of bytes read into the buffer, or
<span class="line-modified">262      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
263      *             the stream has been reached.
<span class="line-modified">264      * @exception  IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">265      * other than end of file, or if the input stream has been closed, or if</span>
<span class="line-modified">266      * some other I/O error occurs.</span>
<span class="line-modified">267      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">268      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">269      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">270      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
271      * @see        java.io.InputStream#read()
272      */
273     public int read(byte b[], int off, int len) throws IOException {
274         Objects.checkFromIndexSize(off, len, b.length);
275         if (len == 0) {
276             return 0;
277         }
278 
279         int c = read();
280         if (c == -1) {
281             return -1;
282         }
283         b[off] = (byte)c;
284 
285         int i = 1;
286         try {
287             for (; i &lt; len ; i++) {
288                 c = read();
289                 if (c == -1) {
290                     break;
</pre>
<hr />
<pre>
487      * @throws NullPointerException if {@code b} is {@code null}
488      * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}
489      *         is negative, or {@code len} is greater than {@code b.length - off}
490      *
491      * @since 9
492      */
493     public int readNBytes(byte[] b, int off, int len) throws IOException {
494         Objects.checkFromIndexSize(off, len, b.length);
495 
496         int n = 0;
497         while (n &lt; len) {
498             int count = read(b, off + n, len - n);
499             if (count &lt; 0)
500                 break;
501             n += count;
502         }
503         return n;
504     }
505 
506     /**
<span class="line-modified">507      * Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this input</span>
<span class="line-modified">508      * stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of reasons, end</span>
<span class="line-modified">509      * up skipping over some smaller number of bytes, possibly &lt;code&gt;0&lt;/code&gt;.</span>
510      * This may result from any of a number of conditions; reaching end of file
<span class="line-modified">511      * before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one possibility.</span>
512      * The actual number of bytes skipped is returned. If {@code n} is
513      * negative, the {@code skip} method for class {@code InputStream} always
514      * returns 0, and no bytes are skipped. Subclasses may handle the negative
515      * value differently.
516      *
<span class="line-modified">517      * &lt;p&gt; The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a</span>
<span class="line-modified">518      * byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes</span>
519      * have been read or the end of the stream has been reached. Subclasses are
520      * encouraged to provide a more efficient implementation of this method.
521      * For instance, the implementation may depend on the ability to seek.
522      *
523      * @param      n   the number of bytes to be skipped.
524      * @return     the actual number of bytes skipped which might be zero.
525      * @throws     IOException  if an I/O error occurs.
526      * @see        java.io.InputStream#skipNBytes(long)
527      */
528     public long skip(long n) throws IOException {
529         long remaining = n;
530         int nr;
531 
532         if (n &lt;= 0) {
533             return 0;
534         }
535 
536         int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
537         byte[] skipBuffer = new byte[size];
538         while (remaining &gt; 0) {
</pre>
<hr />
<pre>
612      * another thread.  A single read or skip of this many bytes will not block,
613      * but may read or skip fewer bytes.
614      *
615      * &lt;p&gt; Note that while some implementations of {@code InputStream} will
616      * return the total number of bytes in the stream, many will not.  It is
617      * never correct to use the return value of this method to allocate
618      * a buffer intended to hold all data in this stream.
619      *
620      * &lt;p&gt; A subclass&#39;s implementation of this method may choose to throw an
621      * {@link IOException} if this input stream has been closed by invoking the
622      * {@link #close()} method.
623      *
624      * &lt;p&gt; The {@code available} method of {@code InputStream} always returns
625      * {@code 0}.
626      *
627      * &lt;p&gt; This method should be overridden by subclasses.
628      *
629      * @return     an estimate of the number of bytes that can be read (or
630      *             skipped over) from this input stream without blocking or
631      *             {@code 0} when it reaches the end of the input stream.
<span class="line-modified">632      * @exception  IOException if an I/O error occurs.</span>
633      */
634     public int available() throws IOException {
635         return 0;
636     }
637 
638     /**
639      * Closes this input stream and releases any system resources associated
640      * with the stream.
641      *
<span class="line-modified">642      * &lt;p&gt; The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does</span>
643      * nothing.
644      *
<span class="line-modified">645      * @exception  IOException  if an I/O error occurs.</span>
646      */
647     public void close() throws IOException {}
648 
649     /**
650      * Marks the current position in this input stream. A subsequent call to
<span class="line-modified">651      * the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at the last marked</span>
652      * position so that subsequent reads re-read the same bytes.
653      *
<span class="line-modified">654      * &lt;p&gt; The &lt;code&gt;readlimit&lt;/code&gt; arguments tells this input stream to</span>
655      * allow that many bytes to be read before the mark position gets
656      * invalidated.
657      *
<span class="line-modified">658      * &lt;p&gt; The general contract of &lt;code&gt;mark&lt;/code&gt; is that, if the method</span>
<span class="line-modified">659      * &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the stream somehow</span>
<span class="line-modified">660      * remembers all the bytes read after the call to &lt;code&gt;mark&lt;/code&gt; and</span>
661      * stands ready to supply those same bytes again if and whenever the method
<span class="line-modified">662      * &lt;code&gt;reset&lt;/code&gt; is called.  However, the stream is not required to</span>
<span class="line-modified">663      * remember any data at all if more than &lt;code&gt;readlimit&lt;/code&gt; bytes are</span>
<span class="line-modified">664      * read from the stream before &lt;code&gt;reset&lt;/code&gt; is called.</span>
665      *
666      * &lt;p&gt; Marking a closed stream should not have any effect on the stream.
667      *
<span class="line-modified">668      * &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does</span>
669      * nothing.
670      *
671      * @param   readlimit   the maximum limit of bytes that can be read before
672      *                      the mark position becomes invalid.
673      * @see     java.io.InputStream#reset()
674      */
675     public synchronized void mark(int readlimit) {}
676 
677     /**
678      * Repositions this stream to the position at the time the
<span class="line-modified">679      * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.</span>
680      *
<span class="line-modified">681      * &lt;p&gt; The general contract of &lt;code&gt;reset&lt;/code&gt; is:</span>
682      *
683      * &lt;ul&gt;
<span class="line-modified">684      * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns</span>
<span class="line-modified">685      * &lt;code&gt;true&lt;/code&gt;, then:</span>
686      *
<span class="line-modified">687      *     &lt;ul&gt;&lt;li&gt; If the method &lt;code&gt;mark&lt;/code&gt; has not been called since</span>
688      *     the stream was created, or the number of bytes read from the stream
<span class="line-modified">689      *     since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument</span>
<span class="line-modified">690      *     to &lt;code&gt;mark&lt;/code&gt; at that last call, then an</span>
<span class="line-modified">691      *     &lt;code&gt;IOException&lt;/code&gt; might be thrown.</span>
692      *
<span class="line-modified">693      *     &lt;li&gt; If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the</span>
694      *     stream is reset to a state such that all the bytes read since the
<span class="line-modified">695      *     most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the</span>
<span class="line-modified">696      *     file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied</span>
<span class="line-modified">697      *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by</span>
698      *     any bytes that otherwise would have been the next input data as of
<span class="line-modified">699      *     the time of the call to &lt;code&gt;reset&lt;/code&gt;. &lt;/ul&gt;</span>
700      *
<span class="line-modified">701      * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns</span>
<span class="line-modified">702      * &lt;code&gt;false&lt;/code&gt;, then:</span>
703      *
<span class="line-modified">704      *     &lt;ul&gt;&lt;li&gt; The call to &lt;code&gt;reset&lt;/code&gt; may throw an</span>
<span class="line-modified">705      *     &lt;code&gt;IOException&lt;/code&gt;.</span>
706      *
<span class="line-modified">707      *     &lt;li&gt; If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream</span>
708      *     is reset to a fixed state that depends on the particular type of the
709      *     input stream and how it was created. The bytes that will be supplied
<span class="line-modified">710      *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the</span>
711      *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;
712      *
<span class="line-modified">713      * &lt;p&gt;The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">714      * does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</span>
715      *
<span class="line-modified">716      * @exception  IOException  if this stream has not been marked or if the</span>
<span class="line-modified">717      *               mark has been invalidated.</span>
718      * @see     java.io.InputStream#mark(int)
719      * @see     java.io.IOException
720      */
721     public synchronized void reset() throws IOException {
722         throw new IOException(&quot;mark/reset not supported&quot;);
723     }
724 
725     /**
<span class="line-modified">726      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and</span>
<span class="line-modified">727      * &lt;code&gt;reset&lt;/code&gt; methods. Whether or not &lt;code&gt;mark&lt;/code&gt; and</span>
<span class="line-modified">728      * &lt;code&gt;reset&lt;/code&gt; are supported is an invariant property of a</span>
<span class="line-modified">729      * particular input stream instance. The &lt;code&gt;markSupported&lt;/code&gt; method</span>
<span class="line-modified">730      * of &lt;code&gt;InputStream&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</span>
<span class="line-modified">731      *</span>
<span class="line-modified">732      * @return  &lt;code&gt;true&lt;/code&gt; if this stream instance supports the mark</span>
<span class="line-modified">733      *          and reset methods; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
734      * @see     java.io.InputStream#mark(int)
735      * @see     java.io.InputStream#reset()
736      */
737     public boolean markSupported() {
738         return false;
739     }
740 
741     /**
742      * Reads all bytes from this input stream and writes the bytes to the
743      * given output stream in the order that they are read. On return, this
744      * input stream will be at end of stream. This method does not close either
745      * stream.
746      * &lt;p&gt;
747      * This method may block indefinitely reading from the input stream, or
748      * writing to the output stream. The behavior for the case where the input
749      * and/or output stream is &lt;i&gt;asynchronously closed&lt;/i&gt;, or the thread
750      * interrupted during the transfer, is highly input and output stream
751      * specific, and therefore not specified.
752      * &lt;p&gt;
753      * If an I/O error occurs reading from the input stream or writing to the
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.List;
 31 import java.util.Objects;
 32 
 33 /**
 34  * This abstract class is the superclass of all classes representing
 35  * an input stream of bytes.
 36  *
<span class="line-modified"> 37  * &lt;p&gt; Applications that need to define a subclass of {@code InputStream}</span>
 38  * must always provide a method that returns the next byte of input.
 39  *
 40  * @author  Arthur van Hoff
 41  * @see     java.io.BufferedInputStream
 42  * @see     java.io.ByteArrayInputStream
 43  * @see     java.io.DataInputStream
 44  * @see     java.io.FilterInputStream
 45  * @see     java.io.InputStream#read()
 46  * @see     java.io.OutputStream
 47  * @see     java.io.PushbackInputStream
 48  * @since   1.0
 49  */
 50 public abstract class InputStream implements Closeable {
 51 
 52     // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to
 53     // use when skipping.
 54     private static final int MAX_SKIP_BUFFER_SIZE = 2048;
 55 
 56     private static final int DEFAULT_BUFFER_SIZE = 8192;
 57 
<span class="line-added"> 58     /**</span>
<span class="line-added"> 59      * Constructor for subclasses to call.</span>
<span class="line-added"> 60      */</span>
<span class="line-added"> 61     public InputStream() {}</span>
<span class="line-added"> 62 </span>
 63     /**
 64      * Returns a new {@code InputStream} that reads no bytes. The returned
 65      * stream is initially open.  The stream is closed by calling the
 66      * {@code close()} method.  Subsequent calls to {@code close()} have no
 67      * effect.
 68      *
 69      * &lt;p&gt; While the stream is open, the {@code available()}, {@code read()},
 70      * {@code read(byte[])}, {@code read(byte[], int, int)},
 71      * {@code readAllBytes()}, {@code readNBytes(byte[], int, int)},
 72      * {@code readNBytes(int)}, {@code skip(long)}, {@code skipNBytes(long)},
 73      * and {@code transferTo()} methods all behave as if end of stream has been
 74      * reached.  After the stream has been closed, these methods all throw
 75      * {@code IOException}.
 76      *
 77      * &lt;p&gt; The {@code markSupported()} method returns {@code false}.  The
 78      * {@code mark()} method does nothing, and the {@code reset()} method
 79      * throws {@code IOException}.
 80      *
 81      * @return an {@code InputStream} which contains no bytes
 82      *
</pre>
<hr />
<pre>
150                     throw new EOFException();
151                 }
152             }
153 
154             @Override
155             public long transferTo(OutputStream out) throws IOException {
156                 Objects.requireNonNull(out);
157                 ensureOpen();
158                 return 0L;
159             }
160 
161             @Override
162             public void close() throws IOException {
163                 closed = true;
164             }
165         };
166     }
167 
168     /**
169      * Reads the next byte of data from the input stream. The value byte is
<span class="line-modified">170      * returned as an {@code int} in the range {@code 0} to</span>
<span class="line-modified">171      * {@code 255}. If no byte is available because the end of the stream</span>
<span class="line-modified">172      * has been reached, the value {@code -1} is returned. This method</span>
173      * blocks until input data is available, the end of the stream is detected,
174      * or an exception is thrown.
175      *
176      * &lt;p&gt; A subclass must provide an implementation of this method.
177      *
<span class="line-modified">178      * @return     the next byte of data, or {@code -1} if the end of the</span>
179      *             stream is reached.
<span class="line-modified">180      * @throws     IOException  if an I/O error occurs.</span>
181      */
182     public abstract int read() throws IOException;
183 
184     /**
185      * Reads some number of bytes from the input stream and stores them into
<span class="line-modified">186      * the buffer array {@code b}. The number of bytes actually read is</span>
187      * returned as an integer.  This method blocks until input data is
188      * available, end of file is detected, or an exception is thrown.
189      *
<span class="line-modified">190      * &lt;p&gt; If the length of {@code b} is zero, then no bytes are read and</span>
<span class="line-modified">191      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
192      * least one byte. If no byte is available because the stream is at the
<span class="line-modified">193      * end of the file, the value {@code -1} is returned; otherwise, at</span>
<span class="line-modified">194      * least one byte is read and stored into {@code b}.</span>
195      *
<span class="line-modified">196      * &lt;p&gt; The first byte read is stored into element {@code b[0]}, the</span>
<span class="line-modified">197      * next one into {@code b[1]}, and so on. The number of bytes read is,</span>
<span class="line-modified">198      * at most, equal to the length of {@code b}. Let &lt;i&gt;k&lt;/i&gt; be the</span>
199      * number of bytes actually read; these bytes will be stored in elements
<span class="line-modified">200      * {@code b[0]} through {@code b[}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">201      * leaving elements {@code b[}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">202      * {@code b[b.length-1]} unaffected.</span>
203      *
<span class="line-modified">204      * &lt;p&gt; The {@code read(b)} method for class {@code InputStream}</span>
<span class="line-modified">205      * has the same effect as: &lt;pre&gt;{@code  read(b, 0, b.length) }&lt;/pre&gt;</span>
206      *
207      * @param      b   the buffer into which the data is read.
208      * @return     the total number of bytes read into the buffer, or
<span class="line-modified">209      *             {@code -1} if there is no more data because the end of</span>
210      *             the stream has been reached.
<span class="line-modified">211      * @throws     IOException  If the first byte cannot be read for any reason</span>
<span class="line-modified">212      *             other than the end of the file, if the input stream has been</span>
<span class="line-modified">213      *             closed, or if some other I/O error occurs.</span>
<span class="line-modified">214      * @throws     NullPointerException  if {@code b} is {@code null}.</span>
215      * @see        java.io.InputStream#read(byte[], int, int)
216      */
217     public int read(byte b[]) throws IOException {
218         return read(b, 0, b.length);
219     }
220 
221     /**
<span class="line-modified">222      * Reads up to {@code len} bytes of data from the input stream into</span>
223      * an array of bytes.  An attempt is made to read as many as
<span class="line-modified">224      * {@code len} bytes, but a smaller number may be read.</span>
225      * The number of bytes actually read is returned as an integer.
226      *
227      * &lt;p&gt; This method blocks until input data is available, end of file is
228      * detected, or an exception is thrown.
229      *
<span class="line-modified">230      * &lt;p&gt; If {@code len} is zero, then no bytes are read and</span>
<span class="line-modified">231      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
232      * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">233      * file, the value {@code -1} is returned; otherwise, at least one</span>
<span class="line-modified">234      * byte is read and stored into {@code b}.</span>
235      *
<span class="line-modified">236      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the</span>
<span class="line-modified">237      * next one into {@code b[off+1]}, and so on. The number of bytes read</span>
<span class="line-modified">238      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
239      * bytes actually read; these bytes will be stored in elements
<span class="line-modified">240      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">241      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">242      * {@code b[off+len-1]} unaffected.</span>
<span class="line-modified">243      *</span>
<span class="line-modified">244      * &lt;p&gt; In every case, elements {@code b[0]} through</span>
<span class="line-modified">245      * {@code b[off-1]} and elements {@code b[off+len]} through</span>
<span class="line-modified">246      * {@code b[b.length-1]} are unaffected.</span>
<span class="line-modified">247      *</span>
<span class="line-modified">248      * &lt;p&gt; The {@code read(b, off, len)} method</span>
<span class="line-modified">249      * for class {@code InputStream} simply calls the method</span>
<span class="line-modified">250      * {@code read()} repeatedly. If the first such call results in an</span>
<span class="line-modified">251      * {@code IOException}, that exception is returned from the call to</span>
<span class="line-modified">252      * the {@code read(b,} {@code off,} {@code len)} method.  If</span>
<span class="line-modified">253      * any subsequent call to {@code read()} results in a</span>
<span class="line-modified">254      * {@code IOException}, the exception is caught and treated as if it</span>
255      * were end of file; the bytes read up to that point are stored into
<span class="line-modified">256      * {@code b} and the number of bytes read before the exception</span>
257      * occurred is returned. The default implementation of this method blocks
<span class="line-modified">258      * until the requested amount of input data {@code len} has been read,</span>
259      * end of file is detected, or an exception is thrown. Subclasses are
260      * encouraged to provide a more efficient implementation of this method.
261      *
262      * @param      b     the buffer into which the data is read.
<span class="line-modified">263      * @param      off   the start offset in array {@code b}</span>
264      *                   at which the data is written.
265      * @param      len   the maximum number of bytes to read.
266      * @return     the total number of bytes read into the buffer, or
<span class="line-modified">267      *             {@code -1} if there is no more data because the end of</span>
268      *             the stream has been reached.
<span class="line-modified">269      * @throws     IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">270      *             other than end of file, or if the input stream has been closed,</span>
<span class="line-modified">271      *             or if some other I/O error occurs.</span>
<span class="line-modified">272      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">273      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">274      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">275      *             {@code b.length - off}</span>
276      * @see        java.io.InputStream#read()
277      */
278     public int read(byte b[], int off, int len) throws IOException {
279         Objects.checkFromIndexSize(off, len, b.length);
280         if (len == 0) {
281             return 0;
282         }
283 
284         int c = read();
285         if (c == -1) {
286             return -1;
287         }
288         b[off] = (byte)c;
289 
290         int i = 1;
291         try {
292             for (; i &lt; len ; i++) {
293                 c = read();
294                 if (c == -1) {
295                     break;
</pre>
<hr />
<pre>
492      * @throws NullPointerException if {@code b} is {@code null}
493      * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}
494      *         is negative, or {@code len} is greater than {@code b.length - off}
495      *
496      * @since 9
497      */
498     public int readNBytes(byte[] b, int off, int len) throws IOException {
499         Objects.checkFromIndexSize(off, len, b.length);
500 
501         int n = 0;
502         while (n &lt; len) {
503             int count = read(b, off + n, len - n);
504             if (count &lt; 0)
505                 break;
506             n += count;
507         }
508         return n;
509     }
510 
511     /**
<span class="line-modified">512      * Skips over and discards {@code n} bytes of data from this input</span>
<span class="line-modified">513      * stream. The {@code skip} method may, for a variety of reasons, end</span>
<span class="line-modified">514      * up skipping over some smaller number of bytes, possibly {@code 0}.</span>
515      * This may result from any of a number of conditions; reaching end of file
<span class="line-modified">516      * before {@code n} bytes have been skipped is only one possibility.</span>
517      * The actual number of bytes skipped is returned. If {@code n} is
518      * negative, the {@code skip} method for class {@code InputStream} always
519      * returns 0, and no bytes are skipped. Subclasses may handle the negative
520      * value differently.
521      *
<span class="line-modified">522      * &lt;p&gt; The {@code skip} method implementation of this class creates a</span>
<span class="line-modified">523      * byte array and then repeatedly reads into it until {@code n} bytes</span>
524      * have been read or the end of the stream has been reached. Subclasses are
525      * encouraged to provide a more efficient implementation of this method.
526      * For instance, the implementation may depend on the ability to seek.
527      *
528      * @param      n   the number of bytes to be skipped.
529      * @return     the actual number of bytes skipped which might be zero.
530      * @throws     IOException  if an I/O error occurs.
531      * @see        java.io.InputStream#skipNBytes(long)
532      */
533     public long skip(long n) throws IOException {
534         long remaining = n;
535         int nr;
536 
537         if (n &lt;= 0) {
538             return 0;
539         }
540 
541         int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
542         byte[] skipBuffer = new byte[size];
543         while (remaining &gt; 0) {
</pre>
<hr />
<pre>
617      * another thread.  A single read or skip of this many bytes will not block,
618      * but may read or skip fewer bytes.
619      *
620      * &lt;p&gt; Note that while some implementations of {@code InputStream} will
621      * return the total number of bytes in the stream, many will not.  It is
622      * never correct to use the return value of this method to allocate
623      * a buffer intended to hold all data in this stream.
624      *
625      * &lt;p&gt; A subclass&#39;s implementation of this method may choose to throw an
626      * {@link IOException} if this input stream has been closed by invoking the
627      * {@link #close()} method.
628      *
629      * &lt;p&gt; The {@code available} method of {@code InputStream} always returns
630      * {@code 0}.
631      *
632      * &lt;p&gt; This method should be overridden by subclasses.
633      *
634      * @return     an estimate of the number of bytes that can be read (or
635      *             skipped over) from this input stream without blocking or
636      *             {@code 0} when it reaches the end of the input stream.
<span class="line-modified">637      * @throws     IOException if an I/O error occurs.</span>
638      */
639     public int available() throws IOException {
640         return 0;
641     }
642 
643     /**
644      * Closes this input stream and releases any system resources associated
645      * with the stream.
646      *
<span class="line-modified">647      * &lt;p&gt; The {@code close} method of {@code InputStream} does</span>
648      * nothing.
649      *
<span class="line-modified">650      * @throws     IOException  if an I/O error occurs.</span>
651      */
652     public void close() throws IOException {}
653 
654     /**
655      * Marks the current position in this input stream. A subsequent call to
<span class="line-modified">656      * the {@code reset} method repositions this stream at the last marked</span>
657      * position so that subsequent reads re-read the same bytes.
658      *
<span class="line-modified">659      * &lt;p&gt; The {@code readlimit} arguments tells this input stream to</span>
660      * allow that many bytes to be read before the mark position gets
661      * invalidated.
662      *
<span class="line-modified">663      * &lt;p&gt; The general contract of {@code mark} is that, if the method</span>
<span class="line-modified">664      * {@code markSupported} returns {@code true}, the stream somehow</span>
<span class="line-modified">665      * remembers all the bytes read after the call to {@code mark} and</span>
666      * stands ready to supply those same bytes again if and whenever the method
<span class="line-modified">667      * {@code reset} is called.  However, the stream is not required to</span>
<span class="line-modified">668      * remember any data at all if more than {@code readlimit} bytes are</span>
<span class="line-modified">669      * read from the stream before {@code reset} is called.</span>
670      *
671      * &lt;p&gt; Marking a closed stream should not have any effect on the stream.
672      *
<span class="line-modified">673      * &lt;p&gt; The {@code mark} method of {@code InputStream} does</span>
674      * nothing.
675      *
676      * @param   readlimit   the maximum limit of bytes that can be read before
677      *                      the mark position becomes invalid.
678      * @see     java.io.InputStream#reset()
679      */
680     public synchronized void mark(int readlimit) {}
681 
682     /**
683      * Repositions this stream to the position at the time the
<span class="line-modified">684      * {@code mark} method was last called on this input stream.</span>
685      *
<span class="line-modified">686      * &lt;p&gt; The general contract of {@code reset} is:</span>
687      *
688      * &lt;ul&gt;
<span class="line-modified">689      * &lt;li&gt; If the method {@code markSupported} returns</span>
<span class="line-modified">690      * {@code true}, then:</span>
691      *
<span class="line-modified">692      *     &lt;ul&gt;&lt;li&gt; If the method {@code mark} has not been called since</span>
693      *     the stream was created, or the number of bytes read from the stream
<span class="line-modified">694      *     since {@code mark} was last called is larger than the argument</span>
<span class="line-modified">695      *     to {@code mark} at that last call, then an</span>
<span class="line-modified">696      *     {@code IOException} might be thrown.</span>
697      *
<span class="line-modified">698      *     &lt;li&gt; If such an {@code IOException} is not thrown, then the</span>
699      *     stream is reset to a state such that all the bytes read since the
<span class="line-modified">700      *     most recent call to {@code mark} (or since the start of the</span>
<span class="line-modified">701      *     file, if {@code mark} has not been called) will be resupplied</span>
<span class="line-modified">702      *     to subsequent callers of the {@code read} method, followed by</span>
703      *     any bytes that otherwise would have been the next input data as of
<span class="line-modified">704      *     the time of the call to {@code reset}. &lt;/ul&gt;</span>
705      *
<span class="line-modified">706      * &lt;li&gt; If the method {@code markSupported} returns</span>
<span class="line-modified">707      * {@code false}, then:</span>
708      *
<span class="line-modified">709      *     &lt;ul&gt;&lt;li&gt; The call to {@code reset} may throw an</span>
<span class="line-modified">710      *     {@code IOException}.</span>
711      *
<span class="line-modified">712      *     &lt;li&gt; If an {@code IOException} is not thrown, then the stream</span>
713      *     is reset to a fixed state that depends on the particular type of the
714      *     input stream and how it was created. The bytes that will be supplied
<span class="line-modified">715      *     to subsequent callers of the {@code read} method depend on the</span>
716      *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;
717      *
<span class="line-modified">718      * &lt;p&gt;The method {@code reset} for class {@code InputStream}</span>
<span class="line-modified">719      * does nothing except throw an {@code IOException}.</span>
720      *
<span class="line-modified">721      * @throws  IOException  if this stream has not been marked or if the</span>
<span class="line-modified">722      *          mark has been invalidated.</span>
723      * @see     java.io.InputStream#mark(int)
724      * @see     java.io.IOException
725      */
726     public synchronized void reset() throws IOException {
727         throw new IOException(&quot;mark/reset not supported&quot;);
728     }
729 
730     /**
<span class="line-modified">731      * Tests if this input stream supports the {@code mark} and</span>
<span class="line-modified">732      * {@code reset} methods. Whether or not {@code mark} and</span>
<span class="line-modified">733      * {@code reset} are supported is an invariant property of a</span>
<span class="line-modified">734      * particular input stream instance. The {@code markSupported} method</span>
<span class="line-modified">735      * of {@code InputStream} returns {@code false}.</span>
<span class="line-modified">736      *</span>
<span class="line-modified">737      * @return  {@code true} if this stream instance supports the mark</span>
<span class="line-modified">738      *          and reset methods; {@code false} otherwise.</span>
739      * @see     java.io.InputStream#mark(int)
740      * @see     java.io.InputStream#reset()
741      */
742     public boolean markSupported() {
743         return false;
744     }
745 
746     /**
747      * Reads all bytes from this input stream and writes the bytes to the
748      * given output stream in the order that they are read. On return, this
749      * input stream will be at end of stream. This method does not close either
750      * stream.
751      * &lt;p&gt;
752      * This method may block indefinitely reading from the input stream, or
753      * writing to the output stream. The behavior for the case where the input
754      * and/or output stream is &lt;i&gt;asynchronously closed&lt;/i&gt;, or the thread
755      * interrupted during the transfer, is highly input and output stream
756      * specific, and therefore not specified.
757      * &lt;p&gt;
758      * If an I/O error occurs reading from the input stream or writing to the
</pre>
</td>
</tr>
</table>
<center><a href="IOException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputStreamReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
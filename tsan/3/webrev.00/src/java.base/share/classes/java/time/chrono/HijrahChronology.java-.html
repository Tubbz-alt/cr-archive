<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/time/chrono/HijrahChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
  28  *
  29  * All rights reserved.
  30  *
  31  * Redistribution and use in source and binary forms, with or without
  32  * modification, are permitted provided that the following conditions are met:
  33  *
  34  *  * Redistributions of source code must retain the above copyright notice,
  35  *    this list of conditions and the following disclaimer.
  36  *
  37  *  * Redistributions in binary form must reproduce the above copyright notice,
  38  *    this list of conditions and the following disclaimer in the documentation
  39  *    and/or other materials provided with the distribution.
  40  *
  41  *  * Neither the name of JSR-310 nor the names of its contributors
  42  *    may be used to endorse or promote products derived from this software
  43  *    without specific prior written permission.
  44  *
  45  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  46  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  47  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  48  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  49  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  50  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  51  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  52  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  53  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  54  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  55  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  56  */
  57 
  58 package java.time.chrono;
  59 
  60 import static java.time.temporal.ChronoField.EPOCH_DAY;
  61 
  62 import java.io.FilePermission;
  63 import java.io.InputStream;
  64 import java.io.InvalidObjectException;
  65 import java.io.ObjectInputStream;
  66 import java.io.Serializable;
  67 import java.security.AccessController;
  68 import java.security.PrivilegedAction;
  69 import java.time.Clock;
  70 import java.time.DateTimeException;
  71 import java.time.Instant;
  72 import java.time.LocalDate;
  73 import java.time.ZoneId;
  74 import java.time.format.ResolverStyle;
  75 import java.time.temporal.ChronoField;
  76 import java.time.temporal.TemporalAccessor;
  77 import java.time.temporal.TemporalField;
  78 import java.time.temporal.ValueRange;
  79 import java.util.Arrays;
  80 import java.util.HashMap;
  81 import java.util.List;
  82 import java.util.Map;
  83 import java.util.Properties;
  84 
  85 import sun.util.logging.PlatformLogger;
  86 
  87 /**
  88  * The Hijrah calendar is a lunar calendar supporting Islamic calendars.
  89  * &lt;p&gt;
  90  * The HijrahChronology follows the rules of the Hijrah calendar system. The Hijrah
  91  * calendar has several variants based on differences in when the new moon is
  92  * determined to have occurred and where the observation is made.
  93  * In some variants the length of each month is
  94  * computed algorithmically from the astronomical data for the moon and earth and
  95  * in others the length of the month is determined by an authorized sighting
  96  * of the new moon. For the algorithmically based calendars the calendar
  97  * can project into the future.
  98  * For sighting based calendars only historical data from past
  99  * sightings is available.
 100  * &lt;p&gt;
 101  * The length of each month is 29 or 30 days.
 102  * Ordinary years have 354 days; leap years have 355 days.
 103  *
 104  * &lt;p&gt;
 105  * CLDR and LDML identify variants:
 106  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 107  * &lt;caption style=&quot;display:none&quot;&gt;Variants of Hijrah Calendars&lt;/caption&gt;
 108  * &lt;thead&gt;
 109  * &lt;tr&gt;
 110  * &lt;th scope=&quot;col&quot;&gt;Chronology ID&lt;/th&gt;
 111  * &lt;th scope=&quot;col&quot;&gt;Calendar Type&lt;/th&gt;
 112  * &lt;th scope=&quot;col&quot;&gt;Locale extension, see {@link java.util.Locale}&lt;/th&gt;
 113  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 114  * &lt;/tr&gt;
 115  * &lt;/thead&gt;
 116  * &lt;tbody&gt;
 117  * &lt;tr&gt;
 118  * &lt;th scope=&quot;row&quot;&gt;Hijrah-umalqura&lt;/th&gt;
 119  * &lt;td&gt;islamic-umalqura&lt;/td&gt;
 120  * &lt;td&gt;ca-islamic-umalqura&lt;/td&gt;
 121  * &lt;td&gt;Islamic - Umm Al-Qura calendar of Saudi Arabia&lt;/td&gt;
 122  * &lt;/tr&gt;
 123  * &lt;/tbody&gt;
 124  * &lt;/table&gt;
 125  * &lt;p&gt;Additional variants may be available through {@link Chronology#getAvailableChronologies()}.
 126  *
 127  * &lt;p&gt;Example&lt;/p&gt;
 128  * &lt;p&gt;
 129  * Selecting the chronology from the locale uses {@link Chronology#ofLocale}
 130  * to find the Chronology based on Locale supported BCP 47 extension mechanism
 131  * to request a specific calendar (&quot;ca&quot;). For example,
 132  * &lt;/p&gt;
 133  * &lt;pre&gt;
 134  *      Locale locale = Locale.forLanguageTag(&quot;en-US-u-ca-islamic-umalqura&quot;);
 135  *      Chronology chrono = Chronology.ofLocale(locale);
 136  * &lt;/pre&gt;
 137  *
 138  * @implSpec
 139  * This class is immutable and thread-safe.
 140  *
 141  * @implNote
 142  * Each Hijrah variant is configured individually. Each variant is defined by a
 143  * property resource that defines the {@code ID}, the {@code calendar type},
 144  * the start of the calendar, the alignment with the
 145  * ISO calendar, and the length of each month for a range of years.
 146  * The variants are loaded by HijrahChronology as a resource from
 147  * hijrah-config-&amp;lt;calendar type&amp;gt;.properties.
 148  * &lt;p&gt;
 149  * The Hijrah property resource is a set of properties that describe the calendar.
 150  * The syntax is defined by {@code java.util.Properties#load(Reader)}.
 151  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 152  * &lt;caption style=&quot;display:none&quot;&gt;Configuration of Hijrah Calendar&lt;/caption&gt;
 153  * &lt;thead&gt;
 154  * &lt;tr&gt;
 155  * &lt;th scope=&quot;col&quot;&gt;Property Name&lt;/th&gt;
 156  * &lt;th scope=&quot;col&quot;&gt;Property value&lt;/th&gt;
 157  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 158  * &lt;/tr&gt;
 159  * &lt;/thead&gt;
 160  * &lt;tbody&gt;
 161  * &lt;tr&gt;
 162  * &lt;th scope=&quot;row&quot;&gt;id&lt;/th&gt;
 163  * &lt;td&gt;Chronology Id, for example, &quot;Hijrah-umalqura&quot;&lt;/td&gt;
 164  * &lt;td&gt;The Id of the calendar in common usage&lt;/td&gt;
 165  * &lt;/tr&gt;
 166  * &lt;tr&gt;
 167  * &lt;th scope=&quot;row&quot;&gt;type&lt;/th&gt;
 168  * &lt;td&gt;Calendar type, for example, &quot;islamic-umalqura&quot;&lt;/td&gt;
 169  * &lt;td&gt;LDML defines the calendar types&lt;/td&gt;
 170  * &lt;/tr&gt;
 171  * &lt;tr&gt;
 172  * &lt;th scope=&quot;row&quot;&gt;version&lt;/th&gt;
 173  * &lt;td&gt;Version, for example: &quot;1.8.0_1&quot;&lt;/td&gt;
 174  * &lt;td&gt;The version of the Hijrah variant data&lt;/td&gt;
 175  * &lt;/tr&gt;
 176  * &lt;tr&gt;
 177  * &lt;th scope=&quot;row&quot;&gt;iso-start&lt;/th&gt;
 178  * &lt;td&gt;ISO start date, formatted as {@code yyyy-MM-dd}, for example: &quot;1900-04-30&quot;&lt;/td&gt;
 179  * &lt;td&gt;The ISO date of the first day of the minimum Hijrah year.&lt;/td&gt;
 180  * &lt;/tr&gt;
 181  * &lt;tr&gt;
 182  * &lt;th scope=&quot;row&quot;&gt;yyyy - a numeric 4 digit year, for example &quot;1434&quot;&lt;/th&gt;
 183  * &lt;td&gt;The value is a sequence of 12 month lengths,
 184  * for example: &quot;29 30 29 30 29 30 30 30 29 30 29 29&quot;&lt;/td&gt;
 185  * &lt;td&gt;The lengths of the 12 months of the year separated by whitespace.
 186  * A numeric year property must be present for every year without any gaps.
 187  * The month lengths must be between 29-32 inclusive.
 188  * &lt;/td&gt;
 189  * &lt;/tr&gt;
 190  * &lt;/tbody&gt;
 191  * &lt;/table&gt;
 192  *
 193  * @since 1.8
 194  */
 195 public final class HijrahChronology extends AbstractChronology implements Serializable {
 196 
 197     /**
 198      * The Hijrah Calendar id.
 199      */
 200     private final transient String typeId;
 201     /**
 202      * The Hijrah calendarType.
 203      */
 204     private final transient String calendarType;
 205     /**
 206      * Serialization version.
 207      */
 208     private static final long serialVersionUID = 3127340209035924785L;
 209     /**
 210      * Singleton instance of the Islamic Umm Al-Qura calendar of Saudi Arabia.
 211      * Other Hijrah chronology variants may be available from
 212      * {@link Chronology#getAvailableChronologies}.
 213      */
 214     public static final HijrahChronology INSTANCE;
 215     /**
 216      * Flag to indicate the initialization of configuration data is complete.
 217      * @see #checkCalendarInit()
 218      */
 219     private transient volatile boolean initComplete;
 220     /**
 221      * Array of epoch days indexed by Hijrah Epoch month.
 222      * Computed by {@link #loadCalendarData}.
 223      */
 224     private transient int[] hijrahEpochMonthStartDays;
 225     /**
 226      * The minimum epoch day of this Hijrah calendar.
 227      * Computed by {@link #loadCalendarData}.
 228      */
 229     private transient int minEpochDay;
 230     /**
 231      * The maximum epoch day for which calendar data is available.
 232      * Computed by {@link #loadCalendarData}.
 233      */
 234     private transient int maxEpochDay;
 235     /**
 236      * The minimum epoch month.
 237      * Computed by {@link #loadCalendarData}.
 238      */
 239     private transient int hijrahStartEpochMonth;
 240     /**
 241      * The minimum length of a month.
 242      * Computed by {@link #createEpochMonths}.
 243      */
 244     private transient int minMonthLength;
 245     /**
 246      * The maximum length of a month.
 247      * Computed by {@link #createEpochMonths}.
 248      */
 249     private transient int maxMonthLength;
 250     /**
 251      * The minimum length of a year in days.
 252      * Computed by {@link #createEpochMonths}.
 253      */
 254     private transient int minYearLength;
 255     /**
 256      * The maximum length of a year in days.
 257      * Computed by {@link #createEpochMonths}.
 258      */
 259     private transient int maxYearLength;
 260 
 261     /**
 262      * Prefix of resource names for Hijrah calendar variants.
 263      */
 264     private static final String RESOURCE_PREFIX = &quot;hijrah-config-&quot;;
 265 
 266     /**
 267      * Suffix of resource names for Hijrah calendar variants.
 268      */
 269     private static final String RESOURCE_SUFFIX = &quot;.properties&quot;;
 270 
 271     /**
 272      * Static initialization of the built-in calendars.
 273      * The data is not loaded until it is used.
 274      */
 275     static {
 276         INSTANCE = new HijrahChronology(&quot;Hijrah-umalqura&quot;, &quot;islamic-umalqura&quot;);
 277         // Register it by its aliases
 278         AbstractChronology.registerChrono(INSTANCE, &quot;Hijrah&quot;);
 279         AbstractChronology.registerChrono(INSTANCE, &quot;islamic&quot;);
 280     }
 281 
 282     /**
 283      * Create a HijrahChronology for the named variant and type.
 284      *
 285      * @param id the id of the calendar
 286      * @param calType the typeId of the calendar
 287      * @throws IllegalArgumentException if the id or typeId is empty
 288      */
 289     private HijrahChronology(String id, String calType) {
 290         if (id.isEmpty()) {
 291             throw new IllegalArgumentException(&quot;calendar id is empty&quot;);
 292         }
 293         if (calType.isEmpty()) {
 294             throw new IllegalArgumentException(&quot;calendar typeId is empty&quot;);
 295         }
 296         this.typeId = id;
 297         this.calendarType = calType;
 298     }
 299 
 300     /**
 301      * Check and ensure that the calendar data has been initialized.
 302      * The initialization check is performed at the boundary between
 303      * public and package methods.  If a public calls another public method
 304      * a check is not necessary in the caller.
 305      * The constructors of HijrahDate call {@link #getEpochDay} or
 306      * {@link #getHijrahDateInfo} so every call from HijrahDate to a
 307      * HijrahChronology via package private methods has been checked.
 308      *
 309      * @throws DateTimeException if the calendar data configuration is
 310      *     malformed or IOExceptions occur loading the data
 311      */
 312     private void checkCalendarInit() {
 313         // Keep this short so it can be inlined for performance
 314         if (initComplete == false) {
 315             loadCalendarData();
 316             initComplete = true;
 317         }
 318     }
 319 
 320     //-----------------------------------------------------------------------
 321     /**
 322      * Gets the ID of the chronology.
 323      * &lt;p&gt;
 324      * The ID uniquely identifies the {@code Chronology}. It can be used to
 325      * lookup the {@code Chronology} using {@link Chronology#of(String)}.
 326      *
 327      * @return the chronology ID, non-null
 328      * @see #getCalendarType()
 329      */
 330     @Override
 331     public String getId() {
 332         return typeId;
 333     }
 334 
 335     /**
 336      * Gets the calendar type of the Islamic calendar.
 337      * &lt;p&gt;
 338      * The calendar type is an identifier defined by the
 339      * &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification.
 340      * It can be used to lookup the {@code Chronology} using {@link Chronology#of(String)}.
 341      *
 342      * @return the calendar system type; non-null if the calendar has
 343      *    a standard type, otherwise null
 344      * @see #getId()
 345      */
 346     @Override
 347     public String getCalendarType() {
 348         return calendarType;
 349     }
 350 
 351     //-----------------------------------------------------------------------
 352     /**
 353      * Obtains a local date in Hijrah calendar system from the
 354      * era, year-of-era, month-of-year and day-of-month fields.
 355      *
 356      * @param era  the Hijrah era, not null
 357      * @param yearOfEra  the year-of-era
 358      * @param month  the month-of-year
 359      * @param dayOfMonth  the day-of-month
 360      * @return the Hijrah local date, not null
 361      * @throws DateTimeException if unable to create the date
 362      * @throws ClassCastException if the {@code era} is not a {@code HijrahEra}
 363      */
 364     @Override
 365     public HijrahDate date(Era era, int yearOfEra, int month, int dayOfMonth) {
 366         return date(prolepticYear(era, yearOfEra), month, dayOfMonth);
 367     }
 368 
 369     /**
 370      * Obtains a local date in Hijrah calendar system from the
 371      * proleptic-year, month-of-year and day-of-month fields.
 372      *
 373      * @param prolepticYear  the proleptic-year
 374      * @param month  the month-of-year
 375      * @param dayOfMonth  the day-of-month
 376      * @return the Hijrah local date, not null
 377      * @throws DateTimeException if unable to create the date
 378      */
 379     @Override
 380     public HijrahDate date(int prolepticYear, int month, int dayOfMonth) {
 381         return HijrahDate.of(this, prolepticYear, month, dayOfMonth);
 382     }
 383 
 384     /**
 385      * Obtains a local date in Hijrah calendar system from the
 386      * era, year-of-era and day-of-year fields.
 387      *
 388      * @param era  the Hijrah era, not null
 389      * @param yearOfEra  the year-of-era
 390      * @param dayOfYear  the day-of-year
 391      * @return the Hijrah local date, not null
 392      * @throws DateTimeException if unable to create the date
 393      * @throws ClassCastException if the {@code era} is not a {@code HijrahEra}
 394      */
 395     @Override
 396     public HijrahDate dateYearDay(Era era, int yearOfEra, int dayOfYear) {
 397         return dateYearDay(prolepticYear(era, yearOfEra), dayOfYear);
 398     }
 399 
 400     /**
 401      * Obtains a local date in Hijrah calendar system from the
 402      * proleptic-year and day-of-year fields.
 403      *
 404      * @param prolepticYear  the proleptic-year
 405      * @param dayOfYear  the day-of-year
 406      * @return the Hijrah local date, not null
 407      * @throws DateTimeException if the value of the year is out of range,
 408      *  or if the day-of-year is invalid for the year
 409      */
 410     @Override
 411     public HijrahDate dateYearDay(int prolepticYear, int dayOfYear) {
 412         HijrahDate date = HijrahDate.of(this, prolepticYear, 1, 1);
 413         if (dayOfYear &gt; date.lengthOfYear()) {
 414             throw new DateTimeException(&quot;Invalid dayOfYear: &quot; + dayOfYear);
 415         }
 416         return date.plusDays(dayOfYear - 1);
 417     }
 418 
 419     /**
 420      * Obtains a local date in the Hijrah calendar system from the epoch-day.
 421      *
 422      * @param epochDay  the epoch day
 423      * @return the Hijrah local date, not null
 424      * @throws DateTimeException if unable to create the date
 425      */
 426     @Override  // override with covariant return type
 427     public HijrahDate dateEpochDay(long epochDay) {
 428         return HijrahDate.ofEpochDay(this, epochDay);
 429     }
 430 
 431     @Override
 432     public HijrahDate dateNow() {
 433         return dateNow(Clock.systemDefaultZone());
 434     }
 435 
 436     @Override
 437     public HijrahDate dateNow(ZoneId zone) {
 438         return dateNow(Clock.system(zone));
 439     }
 440 
 441     @Override
 442     public HijrahDate dateNow(Clock clock) {
 443         return date(LocalDate.now(clock));
 444     }
 445 
 446     @Override
 447     public HijrahDate date(TemporalAccessor temporal) {
 448         if (temporal instanceof HijrahDate) {
 449             return (HijrahDate) temporal;
 450         }
 451         return HijrahDate.ofEpochDay(this, temporal.getLong(EPOCH_DAY));
 452     }
 453 
 454     @Override
 455     @SuppressWarnings(&quot;unchecked&quot;)
 456     public ChronoLocalDateTime&lt;HijrahDate&gt; localDateTime(TemporalAccessor temporal) {
 457         return (ChronoLocalDateTime&lt;HijrahDate&gt;) super.localDateTime(temporal);
 458     }
 459 
 460     @Override
 461     @SuppressWarnings(&quot;unchecked&quot;)
 462     public ChronoZonedDateTime&lt;HijrahDate&gt; zonedDateTime(TemporalAccessor temporal) {
 463         return (ChronoZonedDateTime&lt;HijrahDate&gt;) super.zonedDateTime(temporal);
 464     }
 465 
 466     @Override
 467     @SuppressWarnings(&quot;unchecked&quot;)
 468     public ChronoZonedDateTime&lt;HijrahDate&gt; zonedDateTime(Instant instant, ZoneId zone) {
 469         return (ChronoZonedDateTime&lt;HijrahDate&gt;) super.zonedDateTime(instant, zone);
 470     }
 471 
 472     //-----------------------------------------------------------------------
 473     @Override
 474     public boolean isLeapYear(long prolepticYear) {
 475         checkCalendarInit();
 476         if (prolepticYear &lt; getMinimumYear() || prolepticYear &gt; getMaximumYear()) {
 477             return false;
 478         }
 479         int len = getYearLength((int) prolepticYear);
 480         return (len &gt; 354);
 481     }
 482 
 483     @Override
 484     public int prolepticYear(Era era, int yearOfEra) {
 485         if (era instanceof HijrahEra == false) {
 486             throw new ClassCastException(&quot;Era must be HijrahEra&quot;);
 487         }
 488         return yearOfEra;
 489     }
 490 
 491     /**
 492      * Creates the HijrahEra object from the numeric value.
 493      * The Hijrah calendar system has only one era covering the
 494      * proleptic years greater than zero.
 495      * This method returns the singleton HijrahEra for the value 1.
 496      *
 497      * @param eraValue  the era value
 498      * @return the calendar system era, not null
 499      * @throws DateTimeException if unable to create the era
 500      */
 501     @Override
 502     public HijrahEra eraOf(int eraValue) {
 503         switch (eraValue) {
 504             case 1:
 505                 return HijrahEra.AH;
 506             default:
 507                 throw new DateTimeException(&quot;invalid Hijrah era&quot;);
 508         }
 509     }
 510 
 511     @Override
 512     public List&lt;Era&gt; eras() {
 513         return List.of(HijrahEra.values());
 514     }
 515 
 516     //-----------------------------------------------------------------------
 517     @Override
 518     public ValueRange range(ChronoField field) {
 519         checkCalendarInit();
 520         if (field instanceof ChronoField) {
 521             ChronoField f = field;
 522             switch (f) {
 523                 case DAY_OF_MONTH:
 524                     return ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());
 525                 case DAY_OF_YEAR:
 526                     return ValueRange.of(1, getMaximumDayOfYear());
 527                 case ALIGNED_WEEK_OF_MONTH:
 528                     return ValueRange.of(1, 5);
 529                 case YEAR:
 530                 case YEAR_OF_ERA:
 531                     return ValueRange.of(getMinimumYear(), getMaximumYear());
 532                 case ERA:
 533                     return ValueRange.of(1, 1);
 534                 default:
 535                     return field.range();
 536             }
 537         }
 538         return field.range();
 539     }
 540 
 541     //-----------------------------------------------------------------------
 542     @Override  // override for return type
 543     public HijrahDate resolveDate(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
 544         return (HijrahDate) super.resolveDate(fieldValues, resolverStyle);
 545     }
 546 
 547     //-----------------------------------------------------------------------
 548     /**
 549      * Check the validity of a year.
 550      *
 551      * @param prolepticYear the year to check
 552      */
 553     int checkValidYear(long prolepticYear) {
 554         if (prolepticYear &lt; getMinimumYear() || prolepticYear &gt; getMaximumYear()) {
 555             throw new DateTimeException(&quot;Invalid Hijrah year: &quot; + prolepticYear);
 556         }
 557         return (int) prolepticYear;
 558     }
 559 
 560     void checkValidDayOfYear(int dayOfYear) {
 561         if (dayOfYear &lt; 1 || dayOfYear &gt; getMaximumDayOfYear()) {
 562             throw new DateTimeException(&quot;Invalid Hijrah day of year: &quot; + dayOfYear);
 563         }
 564     }
 565 
 566     void checkValidMonth(int month) {
 567         if (month &lt; 1 || month &gt; 12) {
 568             throw new DateTimeException(&quot;Invalid Hijrah month: &quot; + month);
 569         }
 570     }
 571 
 572     //-----------------------------------------------------------------------
 573     /**
 574      * Returns an array containing the Hijrah year, month and day
 575      * computed from the epoch day.
 576      *
 577      * @param epochDay  the EpochDay
 578      * @return int[0] = YEAR, int[1] = MONTH, int[2] = DATE
 579      */
 580     int[] getHijrahDateInfo(int epochDay) {
 581         checkCalendarInit();    // ensure that the chronology is initialized
 582         if (epochDay &lt; minEpochDay || epochDay &gt;= maxEpochDay) {
 583             throw new DateTimeException(&quot;Hijrah date out of range&quot;);
 584         }
 585 
 586         int epochMonth = epochDayToEpochMonth(epochDay);
 587         int year = epochMonthToYear(epochMonth);
 588         int month = epochMonthToMonth(epochMonth);
 589         int day1 = epochMonthToEpochDay(epochMonth);
 590         int date = epochDay - day1; // epochDay - dayOfEpoch(year, month);
 591 
 592         int dateInfo[] = new int[3];
 593         dateInfo[0] = year;
 594         dateInfo[1] = month + 1; // change to 1-based.
 595         dateInfo[2] = date + 1; // change to 1-based.
 596         return dateInfo;
 597     }
 598 
 599     /**
 600      * Return the epoch day computed from Hijrah year, month, and day.
 601      *
 602      * @param prolepticYear the year to represent, 0-origin
 603      * @param monthOfYear the month-of-year to represent, 1-origin
 604      * @param dayOfMonth the day-of-month to represent, 1-origin
 605      * @return the epoch day
 606      */
 607     long getEpochDay(int prolepticYear, int monthOfYear, int dayOfMonth) {
 608         checkCalendarInit();    // ensure that the chronology is initialized
 609         checkValidMonth(monthOfYear);
 610         int epochMonth = yearToEpochMonth(prolepticYear) + (monthOfYear - 1);
 611         if (epochMonth &lt; 0 || epochMonth &gt;= hijrahEpochMonthStartDays.length) {
 612             throw new DateTimeException(&quot;Invalid Hijrah date, year: &quot; +
 613                     prolepticYear +  &quot;, month: &quot; + monthOfYear);
 614         }
 615         if (dayOfMonth &lt; 1 || dayOfMonth &gt; getMonthLength(prolepticYear, monthOfYear)) {
 616             throw new DateTimeException(&quot;Invalid Hijrah day of month: &quot; + dayOfMonth);
 617         }
 618         return epochMonthToEpochDay(epochMonth) + (dayOfMonth - 1);
 619     }
 620 
 621     /**
 622      * Returns day of year for the year and month.
 623      *
 624      * @param prolepticYear a proleptic year
 625      * @param month a month, 1-origin
 626      * @return the day of year, 1-origin
 627      */
 628     int getDayOfYear(int prolepticYear, int month) {
 629         return yearMonthToDayOfYear(prolepticYear, (month - 1));
 630     }
 631 
 632     /**
 633      * Returns month length for the year and month.
 634      *
 635      * @param prolepticYear a proleptic year
 636      * @param monthOfYear a month, 1-origin.
 637      * @return the length of the month
 638      */
 639     int getMonthLength(int prolepticYear, int monthOfYear) {
 640         int epochMonth = yearToEpochMonth(prolepticYear) + (monthOfYear - 1);
 641         if (epochMonth &lt; 0 || epochMonth &gt;= hijrahEpochMonthStartDays.length) {
 642             throw new DateTimeException(&quot;Invalid Hijrah date, year: &quot; +
 643                     prolepticYear +  &quot;, month: &quot; + monthOfYear);
 644         }
 645         return epochMonthLength(epochMonth);
 646     }
 647 
 648     /**
 649      * Returns year length.
 650      * Note: The 12th month must exist in the data.
 651      *
 652      * @param prolepticYear a proleptic year
 653      * @return year length in days
 654      */
 655     int getYearLength(int prolepticYear) {
 656         return yearMonthToDayOfYear(prolepticYear, 12);
 657     }
 658 
 659     /**
 660      * Return the minimum supported Hijrah year.
 661      *
 662      * @return the minimum
 663      */
 664     int getMinimumYear() {
 665         return epochMonthToYear(0);
 666     }
 667 
 668     /**
 669      * Return the maximum supported Hijrah year.
 670      *
 671      * @return the minimum
 672      */
 673     int getMaximumYear() {
 674         return epochMonthToYear(hijrahEpochMonthStartDays.length - 1) - 1;
 675     }
 676 
 677     /**
 678      * Returns maximum day-of-month.
 679      *
 680      * @return maximum day-of-month
 681      */
 682     int getMaximumMonthLength() {
 683         return maxMonthLength;
 684     }
 685 
 686     /**
 687      * Returns smallest maximum day-of-month.
 688      *
 689      * @return smallest maximum day-of-month
 690      */
 691     int getMinimumMonthLength() {
 692         return minMonthLength;
 693     }
 694 
 695     /**
 696      * Returns maximum day-of-year.
 697      *
 698      * @return maximum day-of-year
 699      */
 700     int getMaximumDayOfYear() {
 701         return maxYearLength;
 702     }
 703 
 704     /**
 705      * Returns smallest maximum day-of-year.
 706      *
 707      * @return smallest maximum day-of-year
 708      */
 709     int getSmallestMaximumDayOfYear() {
 710         return minYearLength;
 711     }
 712 
 713     /**
 714      * Returns the epochMonth found by locating the epochDay in the table. The
 715      * epochMonth is the index in the table
 716      *
 717      * @param epochDay
 718      * @return The index of the element of the start of the month containing the
 719      * epochDay.
 720      */
 721     private int epochDayToEpochMonth(int epochDay) {
 722         // binary search
 723         int ndx = Arrays.binarySearch(hijrahEpochMonthStartDays, epochDay);
 724         if (ndx &lt; 0) {
 725             ndx = -ndx - 2;
 726         }
 727         return ndx;
 728     }
 729 
 730     /**
 731      * Returns the year computed from the epochMonth
 732      *
 733      * @param epochMonth the epochMonth
 734      * @return the Hijrah Year
 735      */
 736     private int epochMonthToYear(int epochMonth) {
 737         return (epochMonth + hijrahStartEpochMonth) / 12;
 738     }
 739 
 740     /**
 741      * Returns the epochMonth for the Hijrah Year.
 742      *
 743      * @param year the HijrahYear
 744      * @return the epochMonth for the beginning of the year.
 745      */
 746     private int yearToEpochMonth(int year) {
 747         return (year * 12) - hijrahStartEpochMonth;
 748     }
 749 
 750     /**
 751      * Returns the Hijrah month from the epochMonth.
 752      *
 753      * @param epochMonth the epochMonth
 754      * @return the month of the Hijrah Year
 755      */
 756     private int epochMonthToMonth(int epochMonth) {
 757         return (epochMonth + hijrahStartEpochMonth) % 12;
 758     }
 759 
 760     /**
 761      * Returns the epochDay for the start of the epochMonth.
 762      *
 763      * @param epochMonth the epochMonth
 764      * @return the epochDay for the start of the epochMonth.
 765      */
 766     private int epochMonthToEpochDay(int epochMonth) {
 767         return hijrahEpochMonthStartDays[epochMonth];
 768 
 769     }
 770 
 771     /**
 772      * Returns the day of year for the requested HijrahYear and month.
 773      *
 774      * @param prolepticYear the Hijrah year
 775      * @param month the Hijrah month
 776      * @return the day of year for the start of the month of the year
 777      */
 778     private int yearMonthToDayOfYear(int prolepticYear, int month) {
 779         int epochMonthFirst = yearToEpochMonth(prolepticYear);
 780         return epochMonthToEpochDay(epochMonthFirst + month)
 781                 - epochMonthToEpochDay(epochMonthFirst);
 782     }
 783 
 784     /**
 785      * Returns the length of the epochMonth. It is computed from the start of
 786      * the following month minus the start of the requested month.
 787      *
 788      * @param epochMonth the epochMonth; assumed to be within range
 789      * @return the length in days of the epochMonth
 790      */
 791     private int epochMonthLength(int epochMonth) {
 792         // The very last entry in the epochMonth table is not the start of a month
 793         return hijrahEpochMonthStartDays[epochMonth + 1]
 794                 - hijrahEpochMonthStartDays[epochMonth];
 795     }
 796 
 797     //-----------------------------------------------------------------------
 798     private static final String KEY_ID = &quot;id&quot;;
 799     private static final String KEY_TYPE = &quot;type&quot;;
 800     private static final String KEY_VERSION = &quot;version&quot;;
 801     private static final String KEY_ISO_START = &quot;iso-start&quot;;
 802 
 803     /**
 804      * Return the configuration properties from the resource.
 805      * &lt;p&gt;
 806      * The location of the variant configuration resource is:
 807      * &lt;pre&gt;
 808      *   &quot;/java/time/chrono/hijrah-config-&quot; + calendarType + &quot;.properties&quot;
 809      * &lt;/pre&gt;
 810      *
 811      * @param calendarType the calendarType of the calendar variant
 812      * @return a Properties containing the properties read from the resource.
 813      * @throws Exception if access to the property resource fails
 814      */
 815     private Properties readConfigProperties(final String calendarType) throws Exception {
 816         String resourceName = RESOURCE_PREFIX + calendarType + RESOURCE_SUFFIX;
 817         PrivilegedAction&lt;InputStream&gt; getResourceAction =  () -&gt; HijrahChronology.class.getResourceAsStream(resourceName);
 818         FilePermission perm1 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;);
 819         RuntimePermission perm2 = new RuntimePermission(&quot;accessSystemModules&quot;);
 820         try (InputStream is = AccessController.doPrivileged(getResourceAction, null, perm1, perm2)) {
 821             if (is == null) {
 822                 throw new RuntimeException(&quot;Hijrah calendar resource not found: /java/time/chrono/&quot; + resourceName);
 823             }
 824             Properties props = new Properties();
 825             props.load(is);
 826             return props;
 827         }
 828     }
 829 
 830     /**
 831      * Loads and processes the Hijrah calendar properties file for this calendarType.
 832      * The starting Hijrah date and the corresponding ISO date are
 833      * extracted and used to calculate the epochDate offset.
 834      * The version number is identified and ignored.
 835      * Everything else is the data for a year with containing the length of each
 836      * of 12 months.
 837      *
 838      * @throws DateTimeException if initialization of the calendar data from the
 839      *     resource fails
 840      */
 841     private void loadCalendarData() {
 842         try {
 843             Properties props = readConfigProperties(calendarType);
 844 
 845             Map&lt;Integer, int[]&gt; years = new HashMap&lt;&gt;();
 846             int minYear = Integer.MAX_VALUE;
 847             int maxYear = Integer.MIN_VALUE;
 848             String id = null;
 849             String type = null;
 850             String version = null;
 851             int isoStart = 0;
 852             for (Map.Entry&lt;Object, Object&gt; entry : props.entrySet()) {
 853                 String key = (String) entry.getKey();
 854                 switch (key) {
 855                     case KEY_ID:
 856                         id = (String)entry.getValue();
 857                         break;
 858                     case KEY_TYPE:
 859                         type = (String)entry.getValue();
 860                         break;
 861                     case KEY_VERSION:
 862                         version = (String)entry.getValue();
 863                         break;
 864                     case KEY_ISO_START: {
 865                         int[] ymd = parseYMD((String) entry.getValue());
 866                         isoStart = (int) LocalDate.of(ymd[0], ymd[1], ymd[2]).toEpochDay();
 867                         break;
 868                     }
 869                     default:
 870                         try {
 871                             // Everything else is either a year or invalid
 872                             int year = Integer.parseInt(key);
 873                             int[] months = parseMonths((String) entry.getValue());
 874                             years.put(year, months);
 875                             maxYear = Math.max(maxYear, year);
 876                             minYear = Math.min(minYear, year);
 877                         } catch (NumberFormatException nfe) {
 878                             throw new IllegalArgumentException(&quot;bad key: &quot; + key);
 879                         }
 880                 }
 881             }
 882 
 883             if (!getId().equals(id)) {
 884                 throw new IllegalArgumentException(&quot;Configuration is for a different calendar: &quot; + id);
 885             }
 886             if (!getCalendarType().equals(type)) {
 887                 throw new IllegalArgumentException(&quot;Configuration is for a different calendar type: &quot; + type);
 888             }
 889             if (version == null || version.isEmpty()) {
 890                 throw new IllegalArgumentException(&quot;Configuration does not contain a version&quot;);
 891             }
 892             if (isoStart == 0) {
 893                 throw new IllegalArgumentException(&quot;Configuration does not contain a ISO start date&quot;);
 894             }
 895 
 896             // Now create and validate the array of epochDays indexed by epochMonth
 897             hijrahStartEpochMonth = minYear * 12;
 898             minEpochDay = isoStart;
 899             hijrahEpochMonthStartDays = createEpochMonths(minEpochDay, minYear, maxYear, years);
 900             maxEpochDay = hijrahEpochMonthStartDays[hijrahEpochMonthStartDays.length - 1];
 901 
 902             // Compute the min and max year length in days.
 903             for (int year = minYear; year &lt; maxYear; year++) {
 904                 int length = getYearLength(year);
 905                 minYearLength = Math.min(minYearLength, length);
 906                 maxYearLength = Math.max(maxYearLength, length);
 907             }
 908         } catch (Exception ex) {
 909             // Log error and throw a DateTimeException
 910             PlatformLogger logger = PlatformLogger.getLogger(&quot;java.time.chrono&quot;);
 911             logger.severe(&quot;Unable to initialize Hijrah calendar proxy: &quot; + typeId, ex);
 912             throw new DateTimeException(&quot;Unable to initialize HijrahCalendar: &quot; + typeId, ex);
 913         }
 914     }
 915 
 916     /**
 917      * Converts the map of year to month lengths ranging from minYear to maxYear
 918      * into a linear contiguous array of epochDays. The index is the hijrahMonth
 919      * computed from year and month and offset by minYear. The value of each
 920      * entry is the epochDay corresponding to the first day of the month.
 921      *
 922      * @param minYear The minimum year for which data is provided
 923      * @param maxYear The maximum year for which data is provided
 924      * @param years a Map of year to the array of 12 month lengths
 925      * @return array of epochDays for each month from min to max
 926      */
 927     private int[] createEpochMonths(int epochDay, int minYear, int maxYear, Map&lt;Integer, int[]&gt; years) {
 928         // Compute the size for the array of dates
 929         int numMonths = (maxYear - minYear + 1) * 12 + 1;
 930 
 931         // Initialize the running epochDay as the corresponding ISO Epoch day
 932         int epochMonth = 0; // index into array of epochMonths
 933         int[] epochMonths = new int[numMonths];
 934         minMonthLength = Integer.MAX_VALUE;
 935         maxMonthLength = Integer.MIN_VALUE;
 936 
 937         // Only whole years are valid, any zero&#39;s in the array are illegal
 938         for (int year = minYear; year &lt;= maxYear; year++) {
 939             int[] months = years.get(year);// must not be gaps
 940             for (int month = 0; month &lt; 12; month++) {
 941                 int length = months[month];
 942                 epochMonths[epochMonth++] = epochDay;
 943 
 944                 if (length &lt; 29 || length &gt; 32) {
 945                     throw new IllegalArgumentException(&quot;Invalid month length in year: &quot; + minYear);
 946                 }
 947                 epochDay += length;
 948                 minMonthLength = Math.min(minMonthLength, length);
 949                 maxMonthLength = Math.max(maxMonthLength, length);
 950             }
 951         }
 952 
 953         // Insert the final epochDay
 954         epochMonths[epochMonth++] = epochDay;
 955 
 956         if (epochMonth != epochMonths.length) {
 957             throw new IllegalStateException(&quot;Did not fill epochMonths exactly: ndx = &quot; + epochMonth
 958                     + &quot; should be &quot; + epochMonths.length);
 959         }
 960 
 961         return epochMonths;
 962     }
 963 
 964     /**
 965      * Parses the 12 months lengths from a property value for a specific year.
 966      *
 967      * @param line the value of a year property
 968      * @return an array of int[12] containing the 12 month lengths
 969      * @throws IllegalArgumentException if the number of months is not 12
 970      * @throws NumberFormatException if the 12 tokens are not numbers
 971      */
 972     private int[] parseMonths(String line) {
 973         int[] months = new int[12];
 974         String[] numbers = line.split(&quot;\\s&quot;);
 975         if (numbers.length != 12) {
 976             throw new IllegalArgumentException(&quot;wrong number of months on line: &quot; + Arrays.toString(numbers) + &quot;; count: &quot; + numbers.length);
 977         }
 978         for (int i = 0; i &lt; 12; i++) {
 979             try {
 980                 months[i] = Integer.parseInt(numbers[i]);
 981             } catch (NumberFormatException nfe) {
 982                 throw new IllegalArgumentException(&quot;bad key: &quot; + numbers[i]);
 983             }
 984         }
 985         return months;
 986     }
 987 
 988     /**
 989      * Parse yyyy-MM-dd into a 3 element array [yyyy, mm, dd].
 990      *
 991      * @param string the input string
 992      * @return the 3 element array with year, month, day
 993      */
 994     private int[] parseYMD(String string) {
 995         // yyyy-MM-dd
 996         string = string.trim();
 997         try {
 998             if (string.charAt(4) != &#39;-&#39; || string.charAt(7) != &#39;-&#39;) {
 999                 throw new IllegalArgumentException(&quot;date must be yyyy-MM-dd&quot;);
1000             }
1001             int[] ymd = new int[3];
1002             ymd[0] = Integer.parseInt(string, 0, 4, 10);
1003             ymd[1] = Integer.parseInt(string, 5, 7, 10);
1004             ymd[2] = Integer.parseInt(string, 8, 10, 10);
1005             return ymd;
1006         } catch (NumberFormatException ex) {
1007             throw new IllegalArgumentException(&quot;date must be yyyy-MM-dd&quot;, ex);
1008         }
1009     }
1010 
1011     //-----------------------------------------------------------------------
1012     /**
1013      * Writes the Chronology using a
1014      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1015      * @serialData
1016      * &lt;pre&gt;
1017      *  out.writeByte(1);     // identifies a Chronology
1018      *  out.writeUTF(getId());
1019      * &lt;/pre&gt;
1020      *
1021      * @return the instance of {@code Ser}, not null
1022      */
1023     @Override
1024     Object writeReplace() {
1025         return super.writeReplace();
1026     }
1027 
1028     /**
1029      * Defend against malicious streams.
1030      *
1031      * @param s the stream to read
1032      * @throws InvalidObjectException always
1033      */
1034     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1035         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1036     }
1037 }
    </pre>
  </body>
</html>
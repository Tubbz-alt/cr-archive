<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/BasicPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AuthProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Certificate.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/BasicPermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 52  * &quot;named&quot; permissions
 53  * (ones that contain a name but no actions list; you either have the
 54  * named permission or you don&#39;t.)
 55  * Subclasses may implement actions on top of BasicPermission,
 56  * if desired.
 57  *
 58  * @see java.security.Permission
 59  * @see java.security.Permissions
 60  * @see java.security.PermissionCollection
 61  * @see java.lang.SecurityManager
 62  *
 63  * @author Marianne Mueller
 64  * @author Roland Schemers
 65  * @since 1.2
 66  */
 67 
 68 public abstract class BasicPermission extends Permission
 69     implements java.io.Serializable
 70 {
 71 

 72     private static final long serialVersionUID = 6279438298436773498L;
 73 
 74     // does this permission have a wildcard at the end?
 75     private transient boolean wildcard;
 76 
 77     // the name without the wildcard on the end
 78     private transient String path;
 79 
 80     // is this permission the old-style exitVM permission (pre JDK 1.6)?
 81     private transient boolean exitVM;
 82 
 83     /**
 84      * initialize a BasicPermission object. Common to all constructors.
 85      */
 86     private void init(String name) {
 87         if (name == null)
 88             throw new NullPointerException(&quot;name can&#39;t be null&quot;);
 89 
 90         int len = name.length();
 91 
</pre>
<hr />
<pre>
243      * Returns a new PermissionCollection object for storing BasicPermission
244      * objects.
245      *
246      * &lt;p&gt;BasicPermission objects must be stored in a manner that allows them
247      * to be inserted in any order, but that also enables the
248      * PermissionCollection {@code implies} method
249      * to be implemented in an efficient (and consistent) manner.
250      *
251      * @return a new PermissionCollection object suitable for
252      * storing BasicPermissions.
253      */
254     @Override
255     public PermissionCollection newPermissionCollection() {
256         return new BasicPermissionCollection(this.getClass());
257     }
258 
259     /**
260      * readObject is called to restore the state of the BasicPermission from
261      * a stream.
262      */

263     private void readObject(ObjectInputStream s)
264          throws IOException, ClassNotFoundException
265     {
266         s.defaultReadObject();
267         // init is called to initialize the rest of the values.
268         init(getName());
269     }
270 
271     /**
272      * Returns the canonical name of this BasicPermission.
273      * All internal invocations of getName should invoke this method, so
274      * that the pre-JDK 1.6 &quot;exitVM&quot; and current &quot;exitVM.*&quot; permission are
275      * equivalent in equals/hashCode methods.
276      *
277      * @return the canonical name of this BasicPermission.
278      */
279     final String getCanonicalName() {
280         return exitVM ? &quot;exitVM.*&quot; : getName();
281     }
282 }
</pre>
<hr />
<pre>
288  * order, but enable the implies function to evaluate the implies
289  * method in an efficient (and consistent) manner.
290  *
291  * A BasicPermissionCollection handles comparing a permission like &quot;a.b.c.d.e&quot;
292  * with a Permission such as &quot;a.b.*&quot;, or &quot;*&quot;.
293  *
294  * @see java.security.Permission
295  * @see java.security.Permissions
296  *
297  *
298  * @author Roland Schemers
299  *
300  * @serial include
301  */
302 
303 final class BasicPermissionCollection
304     extends PermissionCollection
305     implements java.io.Serializable
306 {
307 

308     private static final long serialVersionUID = 739301742472979399L;
309 
310     /**
311       * Key is name, value is permission. All permission objects in
312       * collection must be of the same type.
313       * Not serialized; see serialization section at end of class.
314       */
315     private transient ConcurrentHashMap&lt;String, Permission&gt; perms;
316 
317     /**
318      * This is set to {@code true} if this BasicPermissionCollection
319      * contains a BasicPermission with &#39;*&#39; as its permission name.
320      *
321      * @see #serialPersistentFields
322      */
323     private boolean all_allowed;
324 
325     /**
326      * The class to which all BasicPermissions in this
327      * BasicPermissionCollection belong.
</pre>
<hr />
<pre>
329      * @see #serialPersistentFields
330      */
331     private Class&lt;?&gt; permClass;
332 
333     /**
334      * Create an empty BasicPermissionCollection object.
335      *
336      */
337     public BasicPermissionCollection(Class&lt;?&gt; clazz) {
338         perms = new ConcurrentHashMap&lt;&gt;(11);
339         all_allowed = false;
340         permClass = clazz;
341     }
342 
343     /**
344      * Adds a permission to the BasicPermissions. The key for the hash is
345      * permission.path.
346      *
347      * @param permission the Permission object to add.
348      *
<span class="line-modified">349      * @exception IllegalArgumentException - if the permission is not a</span>
350      *                                       BasicPermission, or if
351      *                                       the permission is not of the
352      *                                       same Class as the other
353      *                                       permissions in this collection.
354      *
<span class="line-modified">355      * @exception SecurityException - if this BasicPermissionCollection object</span>
356      *                                has been marked readonly
357      */
358     @Override
359     public void add(Permission permission) {
360         if (! (permission instanceof BasicPermission))
361             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
362                                                permission);
363         if (isReadOnly())
364             throw new SecurityException(&quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
365 
366         BasicPermission bp = (BasicPermission) permission;
367 
368         // make sure we only add new BasicPermissions of the same class
369         // Also check null for compatibility with deserialized form from
370         // previous versions.
371         if (permClass == null) {
372             // adding first permission
373             permClass = bp.getClass();
374         } else {
375             if (bp.getClass() != permClass)
</pre>
<hr />
<pre>
461 
462     // Need to maintain serialization interoperability with earlier releases,
463     // which had the serializable field:
464     //
465     // @serial the Hashtable is indexed by the BasicPermission name
466     //
467     // private Hashtable permissions;
468     /**
469      * @serialField permissions java.util.Hashtable
470      *    The BasicPermissions in this BasicPermissionCollection.
471      *    All BasicPermissions in the collection must belong to the same class.
472      *    The Hashtable is indexed by the BasicPermission name; the value
473      *    of the Hashtable entry is the permission.
474      * @serialField all_allowed boolean
475      *   This is set to {@code true} if this BasicPermissionCollection
476      *   contains a BasicPermission with &#39;*&#39; as its permission name.
477      * @serialField permClass java.lang.Class
478      *   The class to which all BasicPermissions in this
479      *   BasicPermissionCollection belongs.
480      */

481     private static final ObjectStreamField[] serialPersistentFields = {
482         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
483         new ObjectStreamField(&quot;all_allowed&quot;, Boolean.TYPE),
484         new ObjectStreamField(&quot;permClass&quot;, Class.class),
485     };
486 
487     /**
488      * @serialData Default fields.
489      */
490     /*
491      * Writes the contents of the perms field out as a Hashtable for
492      * serialization compatibility with earlier releases. all_allowed
493      * and permClass unchanged.
494      */

495     private void writeObject(ObjectOutputStream out) throws IOException {
496         // Don&#39;t call out.defaultWriteObject()
497 
498         // Copy perms into a Hashtable
499         Hashtable&lt;String, Permission&gt; permissions =
500                 new Hashtable&lt;&gt;(perms.size()*2);
501 
502         permissions.putAll(perms);
503 
504         // Write out serializable fields
505         ObjectOutputStream.PutField pfields = out.putFields();
506         pfields.put(&quot;all_allowed&quot;, all_allowed);
507         pfields.put(&quot;permissions&quot;, permissions);
508         pfields.put(&quot;permClass&quot;, permClass);
509         out.writeFields();
510     }
511 
512     /**
513      * readObject is called to restore the state of the
514      * BasicPermissionCollection from a stream.
515      */

516     private void readObject(java.io.ObjectInputStream in)
517          throws IOException, ClassNotFoundException
518     {
519         // Don&#39;t call defaultReadObject()
520 
521         // Read in serialized fields
522         ObjectInputStream.GetField gfields = in.readFields();
523 
524         // Get permissions
525         // writeObject writes a Hashtable&lt;String, Permission&gt; for the
526         // permissions key, so this cast is safe, unless the data is corrupt.
527         @SuppressWarnings(&quot;unchecked&quot;)
528         Hashtable&lt;String, Permission&gt; permissions =
529                 (Hashtable&lt;String, Permission&gt;)gfields.get(&quot;permissions&quot;, null);
530         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
531         perms.putAll(permissions);
532 
533         // Get all_allowed
534         all_allowed = gfields.get(&quot;all_allowed&quot;, false);
535 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 52  * &quot;named&quot; permissions
 53  * (ones that contain a name but no actions list; you either have the
 54  * named permission or you don&#39;t.)
 55  * Subclasses may implement actions on top of BasicPermission,
 56  * if desired.
 57  *
 58  * @see java.security.Permission
 59  * @see java.security.Permissions
 60  * @see java.security.PermissionCollection
 61  * @see java.lang.SecurityManager
 62  *
 63  * @author Marianne Mueller
 64  * @author Roland Schemers
 65  * @since 1.2
 66  */
 67 
 68 public abstract class BasicPermission extends Permission
 69     implements java.io.Serializable
 70 {
 71 
<span class="line-added"> 72     @java.io.Serial</span>
 73     private static final long serialVersionUID = 6279438298436773498L;
 74 
 75     // does this permission have a wildcard at the end?
 76     private transient boolean wildcard;
 77 
 78     // the name without the wildcard on the end
 79     private transient String path;
 80 
 81     // is this permission the old-style exitVM permission (pre JDK 1.6)?
 82     private transient boolean exitVM;
 83 
 84     /**
 85      * initialize a BasicPermission object. Common to all constructors.
 86      */
 87     private void init(String name) {
 88         if (name == null)
 89             throw new NullPointerException(&quot;name can&#39;t be null&quot;);
 90 
 91         int len = name.length();
 92 
</pre>
<hr />
<pre>
244      * Returns a new PermissionCollection object for storing BasicPermission
245      * objects.
246      *
247      * &lt;p&gt;BasicPermission objects must be stored in a manner that allows them
248      * to be inserted in any order, but that also enables the
249      * PermissionCollection {@code implies} method
250      * to be implemented in an efficient (and consistent) manner.
251      *
252      * @return a new PermissionCollection object suitable for
253      * storing BasicPermissions.
254      */
255     @Override
256     public PermissionCollection newPermissionCollection() {
257         return new BasicPermissionCollection(this.getClass());
258     }
259 
260     /**
261      * readObject is called to restore the state of the BasicPermission from
262      * a stream.
263      */
<span class="line-added">264     @java.io.Serial</span>
265     private void readObject(ObjectInputStream s)
266          throws IOException, ClassNotFoundException
267     {
268         s.defaultReadObject();
269         // init is called to initialize the rest of the values.
270         init(getName());
271     }
272 
273     /**
274      * Returns the canonical name of this BasicPermission.
275      * All internal invocations of getName should invoke this method, so
276      * that the pre-JDK 1.6 &quot;exitVM&quot; and current &quot;exitVM.*&quot; permission are
277      * equivalent in equals/hashCode methods.
278      *
279      * @return the canonical name of this BasicPermission.
280      */
281     final String getCanonicalName() {
282         return exitVM ? &quot;exitVM.*&quot; : getName();
283     }
284 }
</pre>
<hr />
<pre>
290  * order, but enable the implies function to evaluate the implies
291  * method in an efficient (and consistent) manner.
292  *
293  * A BasicPermissionCollection handles comparing a permission like &quot;a.b.c.d.e&quot;
294  * with a Permission such as &quot;a.b.*&quot;, or &quot;*&quot;.
295  *
296  * @see java.security.Permission
297  * @see java.security.Permissions
298  *
299  *
300  * @author Roland Schemers
301  *
302  * @serial include
303  */
304 
305 final class BasicPermissionCollection
306     extends PermissionCollection
307     implements java.io.Serializable
308 {
309 
<span class="line-added">310     @java.io.Serial</span>
311     private static final long serialVersionUID = 739301742472979399L;
312 
313     /**
314       * Key is name, value is permission. All permission objects in
315       * collection must be of the same type.
316       * Not serialized; see serialization section at end of class.
317       */
318     private transient ConcurrentHashMap&lt;String, Permission&gt; perms;
319 
320     /**
321      * This is set to {@code true} if this BasicPermissionCollection
322      * contains a BasicPermission with &#39;*&#39; as its permission name.
323      *
324      * @see #serialPersistentFields
325      */
326     private boolean all_allowed;
327 
328     /**
329      * The class to which all BasicPermissions in this
330      * BasicPermissionCollection belong.
</pre>
<hr />
<pre>
332      * @see #serialPersistentFields
333      */
334     private Class&lt;?&gt; permClass;
335 
336     /**
337      * Create an empty BasicPermissionCollection object.
338      *
339      */
340     public BasicPermissionCollection(Class&lt;?&gt; clazz) {
341         perms = new ConcurrentHashMap&lt;&gt;(11);
342         all_allowed = false;
343         permClass = clazz;
344     }
345 
346     /**
347      * Adds a permission to the BasicPermissions. The key for the hash is
348      * permission.path.
349      *
350      * @param permission the Permission object to add.
351      *
<span class="line-modified">352      * @throws    IllegalArgumentException   if the permission is not a</span>
353      *                                       BasicPermission, or if
354      *                                       the permission is not of the
355      *                                       same Class as the other
356      *                                       permissions in this collection.
357      *
<span class="line-modified">358      * @throws    SecurityException   if this BasicPermissionCollection object</span>
359      *                                has been marked readonly
360      */
361     @Override
362     public void add(Permission permission) {
363         if (! (permission instanceof BasicPermission))
364             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
365                                                permission);
366         if (isReadOnly())
367             throw new SecurityException(&quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
368 
369         BasicPermission bp = (BasicPermission) permission;
370 
371         // make sure we only add new BasicPermissions of the same class
372         // Also check null for compatibility with deserialized form from
373         // previous versions.
374         if (permClass == null) {
375             // adding first permission
376             permClass = bp.getClass();
377         } else {
378             if (bp.getClass() != permClass)
</pre>
<hr />
<pre>
464 
465     // Need to maintain serialization interoperability with earlier releases,
466     // which had the serializable field:
467     //
468     // @serial the Hashtable is indexed by the BasicPermission name
469     //
470     // private Hashtable permissions;
471     /**
472      * @serialField permissions java.util.Hashtable
473      *    The BasicPermissions in this BasicPermissionCollection.
474      *    All BasicPermissions in the collection must belong to the same class.
475      *    The Hashtable is indexed by the BasicPermission name; the value
476      *    of the Hashtable entry is the permission.
477      * @serialField all_allowed boolean
478      *   This is set to {@code true} if this BasicPermissionCollection
479      *   contains a BasicPermission with &#39;*&#39; as its permission name.
480      * @serialField permClass java.lang.Class
481      *   The class to which all BasicPermissions in this
482      *   BasicPermissionCollection belongs.
483      */
<span class="line-added">484     @java.io.Serial</span>
485     private static final ObjectStreamField[] serialPersistentFields = {
486         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
487         new ObjectStreamField(&quot;all_allowed&quot;, Boolean.TYPE),
488         new ObjectStreamField(&quot;permClass&quot;, Class.class),
489     };
490 
491     /**
492      * @serialData Default fields.
493      */
494     /*
495      * Writes the contents of the perms field out as a Hashtable for
496      * serialization compatibility with earlier releases. all_allowed
497      * and permClass unchanged.
498      */
<span class="line-added">499     @java.io.Serial</span>
500     private void writeObject(ObjectOutputStream out) throws IOException {
501         // Don&#39;t call out.defaultWriteObject()
502 
503         // Copy perms into a Hashtable
504         Hashtable&lt;String, Permission&gt; permissions =
505                 new Hashtable&lt;&gt;(perms.size()*2);
506 
507         permissions.putAll(perms);
508 
509         // Write out serializable fields
510         ObjectOutputStream.PutField pfields = out.putFields();
511         pfields.put(&quot;all_allowed&quot;, all_allowed);
512         pfields.put(&quot;permissions&quot;, permissions);
513         pfields.put(&quot;permClass&quot;, permClass);
514         out.writeFields();
515     }
516 
517     /**
518      * readObject is called to restore the state of the
519      * BasicPermissionCollection from a stream.
520      */
<span class="line-added">521     @java.io.Serial</span>
522     private void readObject(java.io.ObjectInputStream in)
523          throws IOException, ClassNotFoundException
524     {
525         // Don&#39;t call defaultReadObject()
526 
527         // Read in serialized fields
528         ObjectInputStream.GetField gfields = in.readFields();
529 
530         // Get permissions
531         // writeObject writes a Hashtable&lt;String, Permission&gt; for the
532         // permissions key, so this cast is safe, unless the data is corrupt.
533         @SuppressWarnings(&quot;unchecked&quot;)
534         Hashtable&lt;String, Permission&gt; permissions =
535                 (Hashtable&lt;String, Permission&gt;)gfields.get(&quot;permissions&quot;, null);
536         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
537         perms.putAll(permissions);
538 
539         // Get all_allowed
540         all_allowed = gfields.get(&quot;all_allowed&quot;, false);
541 
</pre>
</td>
</tr>
</table>
<center><a href="AuthProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Certificate.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/HashMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="GregorianCalendar.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashSet.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/HashMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136,10 +136,11 @@</span>
   * @since   1.2
   */
  public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
      implements Map&lt;K,V&gt;, Cloneable, Serializable {
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 362498820763181265L;
  
      /*
       * Implementation notes.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -909,10 +910,78 @@</span>
              keySet = ks;
          }
          return ks;
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Prepares the array for {@link Collection#toArray(Object[])} implementation.</span>
<span class="udiff-line-added">+      * If supplied array is smaller than this map size, a new array is allocated.</span>
<span class="udiff-line-added">+      * If supplied array is bigger than this map size, a null is written at size index.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a an original array passed to {@code toArray()} method</span>
<span class="udiff-line-added">+      * @param &lt;T&gt; type of array elements</span>
<span class="udiff-line-added">+      * @return an array ready to be filled and returned from {@code toArray()} method.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="udiff-line-added">+     final &lt;T&gt; T[] prepareArray(T[] a) {</span>
<span class="udiff-line-added">+         int size = this.size;</span>
<span class="udiff-line-added">+         if (a.length &lt; size) {</span>
<span class="udiff-line-added">+             return (T[]) java.lang.reflect.Array</span>
<span class="udiff-line-added">+                     .newInstance(a.getClass().getComponentType(), size);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (a.length &gt; size) {</span>
<span class="udiff-line-added">+             a[size] = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return a;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Fills an array with this map keys and returns it. This method assumes</span>
<span class="udiff-line-added">+      * that input array is big enough to fit all the keys. Use</span>
<span class="udiff-line-added">+      * {@link #prepareArray(Object[])} to ensure this.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a an array to fill</span>
<span class="udiff-line-added">+      * @param &lt;T&gt; type of array elements</span>
<span class="udiff-line-added">+      * @return supplied array</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     &lt;T&gt; T[] keysToArray(T[] a) {</span>
<span class="udiff-line-added">+         Object[] r = a;</span>
<span class="udiff-line-added">+         Node&lt;K,V&gt;[] tab;</span>
<span class="udiff-line-added">+         int idx = 0;</span>
<span class="udiff-line-added">+         if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="udiff-line-added">+             for (Node&lt;K,V&gt; e : tab) {</span>
<span class="udiff-line-added">+                 for (; e != null; e = e.next) {</span>
<span class="udiff-line-added">+                     r[idx++] = e.key;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return a;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Fills an array with this map values and returns it. This method assumes</span>
<span class="udiff-line-added">+      * that input array is big enough to fit all the values. Use</span>
<span class="udiff-line-added">+      * {@link #prepareArray(Object[])} to ensure this.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a an array to fill</span>
<span class="udiff-line-added">+      * @param &lt;T&gt; type of array elements</span>
<span class="udiff-line-added">+      * @return supplied array</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     &lt;T&gt; T[] valuesToArray(T[] a) {</span>
<span class="udiff-line-added">+         Object[] r = a;</span>
<span class="udiff-line-added">+         Node&lt;K,V&gt;[] tab;</span>
<span class="udiff-line-added">+         int idx = 0;</span>
<span class="udiff-line-added">+         if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="udiff-line-added">+             for (Node&lt;K,V&gt; e : tab) {</span>
<span class="udiff-line-added">+                 for (; e != null; e = e.next) {</span>
<span class="udiff-line-added">+                     r[idx++] = e.value;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return a;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      final class KeySet extends AbstractSet&lt;K&gt; {
          public final int size()                 { return size; }
          public final void clear()               { HashMap.this.clear(); }
          public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }
          public final boolean contains(Object o) { return containsKey(o); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -920,10 +989,19 @@</span>
              return removeNode(hash(key), key, null, false, true) != null;
          }
          public final Spliterator&lt;K&gt; spliterator() {
              return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public Object[] toArray() {</span>
<span class="udiff-line-added">+             return keysToArray(new Object[size]);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="udiff-line-added">+             return keysToArray(prepareArray(a));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          public final void forEach(Consumer&lt;? super K&gt; action) {
              Node&lt;K,V&gt;[] tab;
              if (action == null)
                  throw new NullPointerException();
              if (size &gt; 0 &amp;&amp; (tab = table) != null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -968,10 +1046,19 @@</span>
          public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }
          public final boolean contains(Object o) { return containsValue(o); }
          public final Spliterator&lt;V&gt; spliterator() {
              return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public Object[] toArray() {</span>
<span class="udiff-line-added">+             return valuesToArray(new Object[size]);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="udiff-line-added">+             return valuesToArray(prepareArray(a));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          public final void forEach(Consumer&lt;? super V&gt; action) {
              Node&lt;K,V&gt;[] tab;
              if (action == null)
                  throw new NullPointerException();
              if (size &gt; 0 &amp;&amp; (tab = table) != null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1401,10 +1488,11 @@</span>
       *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
       *             mappings), followed by the key (Object) and value (Object)
       *             for each key-value mapping.  The key-value mappings are
       *             emitted in no particular order.
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void writeObject(java.io.ObjectOutputStream s)
          throws IOException {
          int buckets = capacity();
          // Write out the threshold, loadfactor, and any hidden stuff
          s.defaultWriteObject();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1418,10 +1506,11 @@</span>
       * @param s the stream
       * @throws ClassNotFoundException if the class of a serialized object
       *         could not be found
       * @throws IOException if an I/O error occurs
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void readObject(java.io.ObjectInputStream s)
          throws IOException, ClassNotFoundException {
          // Read in the threshold (ignored), loadfactor, and any hidden stuff
          s.defaultReadObject();
          reinitialize();
</pre>
<center><a href="GregorianCalendar.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashSet.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Locale.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ListResourceBundle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LongSummaryStatistics.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Locale.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  49 import java.util.concurrent.ConcurrentHashMap;
  50 import java.util.spi.LocaleNameProvider;
  51 import java.util.stream.Collectors;
  52 
  53 import sun.security.action.GetPropertyAction;
  54 import sun.util.locale.BaseLocale;
  55 import sun.util.locale.InternalLocaleBuilder;
  56 import sun.util.locale.LanguageTag;
  57 import sun.util.locale.LocaleExtensions;
  58 import sun.util.locale.LocaleMatcher;
  59 import sun.util.locale.LocaleObjectCache;
  60 import sun.util.locale.LocaleSyntaxException;
  61 import sun.util.locale.LocaleUtils;
  62 import sun.util.locale.ParseStatus;
  63 import sun.util.locale.provider.LocaleProviderAdapter;
  64 import sun.util.locale.provider.LocaleResources;
  65 import sun.util.locale.provider.LocaleServiceProviderPool;
  66 import sun.util.locale.provider.TimeZoneNameUtility;
  67 
  68 /**
<span class="line-modified">  69  * A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,</span>
<span class="line-modified">  70  * or cultural region. An operation that requires a &lt;code&gt;Locale&lt;/code&gt; to perform</span>
<span class="line-modified">  71  * its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the &lt;code&gt;Locale&lt;/code&gt;</span>
  72  * to tailor information for the user. For example, displaying a number
  73  * is a locale-sensitive operation&amp;mdash; the number should be formatted
  74  * according to the customs and conventions of the user&#39;s native country,
  75  * region, or culture.
  76  *
  77  * &lt;p&gt; The {@code Locale} class implements IETF BCP 47 which is composed of
  78  * &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 &quot;Matching of Language
  79  * Tags&quot;&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646 &quot;Tags
  80  * for Identifying Languages&quot;&lt;/a&gt; with support for the LDML (UTS#35, &quot;Unicode
  81  * Locale Data Markup Language&quot;) BCP 47-compatible extensions for locale data
  82  * exchange.
  83  *
<span class="line-modified">  84  * &lt;p&gt; A &lt;code&gt;Locale&lt;/code&gt; object logically consists of the fields</span>
  85  * described below.
  86  *
  87  * &lt;dl&gt;
  88  *   &lt;dt&gt;&lt;a id=&quot;def_language&quot;&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
  89  *
  90  *   &lt;dd&gt;ISO 639 alpha-2 or alpha-3 language code, or registered
  91  *   language subtags up to 8 alpha letters (for future enhancements).
  92  *   When a language has both an alpha-2 code and an alpha-3 code, the
  93  *   alpha-2 code must be used.  You can find a full list of valid
  94  *   language codes in the IANA Language Subtag Registry (search for
  95  *   &quot;Type: language&quot;).  The language field is case insensitive, but
<span class="line-modified">  96  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to lower case.&lt;/dd&gt;</span>
  97  *
  98  *   &lt;dd&gt;Well-formed language values have the form
  99  *   &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
 100  *   BCP47 language production, since it excludes extlang.  They are
 101  *   not needed since modern three-letter language codes replace
 102  *   them.&lt;/dd&gt;
 103  *
 104  *   &lt;dd&gt;Example: &quot;en&quot; (English), &quot;ja&quot; (Japanese), &quot;kok&quot; (Konkani)&lt;/dd&gt;
 105  *
 106  *   &lt;dt&gt;&lt;a id=&quot;def_script&quot;&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 107  *
 108  *   &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
 109  *   valid script codes in the IANA Language Subtag Registry (search
 110  *   for &quot;Type: script&quot;).  The script field is case insensitive, but
<span class="line-modified"> 111  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to title case (the first</span>
 112  *   letter is upper case and the rest of the letters are lower
 113  *   case).&lt;/dd&gt;
 114  *
 115  *   &lt;dd&gt;Well-formed script values have the form
 116  *   &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
 117  *
 118  *   &lt;dd&gt;Example: &quot;Latn&quot; (Latin), &quot;Cyrl&quot; (Cyrillic)&lt;/dd&gt;
 119  *
 120  *   &lt;dt&gt;&lt;a id=&quot;def_region&quot;&gt;&lt;b&gt;country (region)&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 121  *
 122  *   &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
 123  *   You can find a full list of valid country and region codes in the
 124  *   IANA Language Subtag Registry (search for &quot;Type: region&quot;).  The
 125  *   country (region) field is case insensitive, but
<span class="line-modified"> 126  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to upper case.&lt;/dd&gt;</span>
 127  *
 128  *   &lt;dd&gt;Well-formed country/region values have
 129  *   the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
 130  *
 131  *   &lt;dd&gt;Example: &quot;US&quot; (United States), &quot;FR&quot; (France), &quot;029&quot;
 132  *   (Caribbean)&lt;/dd&gt;
 133  *
 134  *   &lt;dt&gt;&lt;a id=&quot;def_variant&quot;&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 135  *
 136  *   &lt;dd&gt;Any arbitrary value used to indicate a variation of a
<span class="line-modified"> 137  *   &lt;code&gt;Locale&lt;/code&gt;.  Where there are two or more variant values</span>
 138  *   each indicating its own semantics, these values should be ordered
 139  *   by importance, with most important first, separated by
 140  *   underscore(&#39;_&#39;).  The variant field is case sensitive.&lt;/dd&gt;
 141  *
 142  *   &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
 143  *   subtags.  Also BCP 47 subtags are strictly used to indicate
 144  *   additional variations that define a language or its dialects that
 145  *   are not covered by any combinations of language, script and
 146  *   region subtags.  You can find a full list of valid variant codes
 147  *   in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).
 148  *
<span class="line-modified"> 149  *   &lt;p&gt;However, the variant field in &lt;code&gt;Locale&lt;/code&gt; has</span>
 150  *   historically been used for any kind of variation, not just
 151  *   language variations.  For example, some supported variants
 152  *   available in Java SE Runtime Environments indicate alternative
 153  *   cultural behaviors such as calendar type or number script.  In
 154  *   BCP 47 this kind of information, which does not identify the
 155  *   language, is supported by extension subtags or private use
 156  *   subtags.&lt;/dd&gt;
 157  *
 158  *   &lt;dd&gt;Well-formed variant values have the form &lt;code&gt;SUBTAG
 159  *   ((&#39;_&#39;|&#39;-&#39;) SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
 160  *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only
 161  *   uses hyphen (&#39;-&#39;) as a delimiter, this is more lenient).&lt;/dd&gt;
 162  *
 163  *   &lt;dd&gt;Example: &quot;polyton&quot; (Polytonic Greek), &quot;POSIX&quot;&lt;/dd&gt;
 164  *
 165  *   &lt;dt&gt;&lt;a id=&quot;def_extensions&quot;&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 166  *
 167  *   &lt;dd&gt;A map from single character keys to string values, indicating
 168  *   extensions apart from language identification.  The extensions in
<span class="line-modified"> 169  *   &lt;code&gt;Locale&lt;/code&gt; implement the semantics and syntax of BCP 47</span>
 170  *   extension subtags and private use subtags. The extensions are
<span class="line-modified"> 171  *   case insensitive, but &lt;code&gt;Locale&lt;/code&gt; canonicalizes all</span>
 172  *   extension keys and values to lower case. Note that extensions
 173  *   cannot have empty values.&lt;/dd&gt;
 174  *
 175  *   &lt;dd&gt;Well-formed keys are single characters from the set
<span class="line-modified"> 176  *   &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;.  Well-formed values have the form</span>
<span class="line-modified"> 177  *   &lt;code&gt;SUBTAG (&#39;-&#39; SUBTAG)*&lt;/code&gt; where for the key &#39;x&#39;</span>
 178  *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
 179  *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, &#39;x&#39; allows
 180  *   single-character subtags).&lt;/dd&gt;
 181  *
 182  *   &lt;dd&gt;Example: key=&quot;u&quot;/value=&quot;ca-japanese&quot; (Japanese Calendar),
 183  *   key=&quot;x&quot;/value=&quot;java-1-7&quot;&lt;/dd&gt;
 184  * &lt;/dl&gt;
 185  *
 186  * &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
<span class="line-modified"> 187  * in the IANA Language Subtag Registry, the &lt;code&gt;Locale&lt;/code&gt; class</span>
<span class="line-modified"> 188  * does not provide any validation features.  The &lt;code&gt;Builder&lt;/code&gt;</span>
 189  * only checks if an individual field satisfies the syntactic
 190  * requirement (is well-formed), but does not validate the value
 191  * itself.  See {@link Builder} for details.
 192  *
<span class="line-modified"> 193  * &lt;h3&gt;&lt;a id=&quot;def_locale_extension&quot;&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h3&gt;</span>
 194  *
 195  * &lt;p&gt;UTS#35, &quot;Unicode Locale Data Markup Language&quot; defines optional
 196  * attributes and keywords to override or refine the default behavior
 197  * associated with a locale.  A keyword is represented by a pair of
 198  * key and type.  For example, &quot;nu-thai&quot; indicates that Thai local
 199  * digits (value:&quot;thai&quot;) should be used for formatting numbers
 200  * (key:&quot;nu&quot;).
 201  *
 202  * &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
 203  * extension key &#39;u&#39; ({@link #UNICODE_LOCALE_EXTENSION}).  The above
 204  * example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.
 205  *
<span class="line-modified"> 206  * &lt;p&gt;Thus, when a &lt;code&gt;Locale&lt;/code&gt; object contains Unicode locale</span>
 207  * attributes and keywords,
<span class="line-modified"> 208  * &lt;code&gt;getExtension(UNICODE_LOCALE_EXTENSION)&lt;/code&gt; will return a</span>
 209  * String representing this information, for example, &quot;nu-thai&quot;.  The
<span class="line-modified"> 210  * &lt;code&gt;Locale&lt;/code&gt; class also provides {@link</span>
 211  * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
 212  * {@link #getUnicodeLocaleType} which allow you to access Unicode
 213  * locale attributes and key/type pairs directly.  When represented as
 214  * a string, the Unicode Locale Extension lists attributes
 215  * alphabetically, followed by key/type sequences with keys listed
 216  * alphabetically (the order of subtags comprising a key&#39;s type is
 217  * fixed when the type is defined)
 218  *
 219  * &lt;p&gt;A well-formed locale key has the form
 220  * &lt;code&gt;[0-9a-zA-Z]{2}&lt;/code&gt;.  A well-formed locale type has the
 221  * form &lt;code&gt;&quot;&quot; | [0-9a-zA-Z]{3,8} (&#39;-&#39; [0-9a-zA-Z]{3,8})*&lt;/code&gt; (it
 222  * can be empty, or a series of subtags 3-8 alphanums in length).  A
 223  * well-formed locale attribute has the form
 224  * &lt;code&gt;[0-9a-zA-Z]{3,8}&lt;/code&gt; (it is a single subtag with the same
 225  * form as a locale type subtag).
 226  *
 227  * &lt;p&gt;The Unicode locale extension specifies optional behavior in
 228  * locale-sensitive services.  Although the LDML specification defines
 229  * various keys and values, actual locale-sensitive service
 230  * implementations in a Java Runtime Environment might not support any
 231  * particular Unicode locale attributes or key/type pairs.
 232  *
<span class="line-modified"> 233  * &lt;h4&gt;Creating a Locale&lt;/h4&gt;</span>
 234  *
<span class="line-modified"> 235  * &lt;p&gt;There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt;</span>
 236  * object.
 237  *
<span class="line-modified"> 238  * &lt;h5&gt;Builder&lt;/h5&gt;</span>
 239  *
<span class="line-modified"> 240  * &lt;p&gt;Using {@link Builder} you can construct a &lt;code&gt;Locale&lt;/code&gt; object</span>
 241  * that conforms to BCP 47 syntax.
 242  *
<span class="line-modified"> 243  * &lt;h5&gt;Constructors&lt;/h5&gt;</span>
 244  *
<span class="line-modified"> 245  * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides three constructors:</span>
 246  * &lt;blockquote&gt;
 247  * &lt;pre&gt;
 248  *     {@link #Locale(String language)}
 249  *     {@link #Locale(String language, String country)}
 250  *     {@link #Locale(String language, String country, String variant)}
 251  * &lt;/pre&gt;
 252  * &lt;/blockquote&gt;
<span class="line-modified"> 253  * These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object</span>
 254  * with language, country and variant, but you cannot specify
 255  * script or extensions.
 256  *
<span class="line-modified"> 257  * &lt;h5&gt;Factory Methods&lt;/h5&gt;</span>
 258  *
<span class="line-modified"> 259  * &lt;p&gt;The method {@link #forLanguageTag} creates a &lt;code&gt;Locale&lt;/code&gt;</span>
 260  * object for a well-formed BCP 47 language tag.
 261  *
<span class="line-modified"> 262  * &lt;h5&gt;Locale Constants&lt;/h5&gt;</span>
 263  *
<span class="line-modified"> 264  * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides a number of convenient constants</span>
<span class="line-modified"> 265  * that you can use to create &lt;code&gt;Locale&lt;/code&gt; objects for commonly used</span>
<span class="line-modified"> 266  * locales. For example, the following creates a &lt;code&gt;Locale&lt;/code&gt; object</span>
 267  * for the United States:
 268  * &lt;blockquote&gt;
 269  * &lt;pre&gt;
 270  *     Locale.US
 271  * &lt;/pre&gt;
 272  * &lt;/blockquote&gt;
 273  *
<span class="line-modified"> 274  * &lt;h4&gt;&lt;a id=&quot;LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;&lt;/h4&gt;</span>
 275  *
 276  * &lt;p&gt;If an application or a system is internationalized and provides localized
 277  * resources for multiple locales, it sometimes needs to find one or more
 278  * locales (or language tags) which meet each user&#39;s specific preferences. Note
 279  * that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this
 280  * locale matching documentation.
 281  *
 282  * &lt;p&gt;In order to do matching a user&#39;s preferred locales to a set of language
 283  * tags, &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of
 284  * Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup.
 285  * &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas
 286  * &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale.
 287  * Matching is done case-insensitively. These matching mechanisms are described
 288  * in the following sections.
 289  *
 290  * &lt;p&gt;A user&#39;s preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
 291  * expressed as a list of language ranges. There are syntactically two types of
 292  * language ranges: basic and extended. See
 293  * {@link Locale.LanguageRange Locale.LanguageRange} for details.
 294  *
<span class="line-modified"> 295  * &lt;h5&gt;Filtering&lt;/h5&gt;</span>
 296  *
 297  * &lt;p&gt;The filtering operation returns all matching language tags. It is defined
 298  * in RFC 4647 as follows:
 299  * &quot;In filtering, each language range represents the least specific language
 300  * tag (that is, the language tag with fewest number of subtags) that is an
 301  * acceptable match. All of the language tags in the matching set of tags will
 302  * have an equal or greater number of subtags than the language range. Every
 303  * non-wildcard subtag in the language range will appear in every one of the
 304  * matching language tags.&quot;
 305  *
 306  * &lt;p&gt;There are two types of filtering: filtering for basic language ranges
 307  * (called &quot;basic filtering&quot;) and filtering for extended language ranges
 308  * (called &quot;extended filtering&quot;). They may return different results by what
 309  * kind of language ranges are included in the given Language Priority List.
 310  * {@link Locale.FilteringMode} is a parameter to specify how filtering should
 311  * be done.
 312  *
<span class="line-modified"> 313  * &lt;h5&gt;Lookup&lt;/h5&gt;</span>
 314  *
 315  * &lt;p&gt;The lookup operation returns the best matching language tags. It is
 316  * defined in RFC 4647 as follows:
 317  * &quot;By contrast with filtering, each language range represents the most
 318  * specific tag that is an acceptable match.  The first matching tag found,
 319  * according to the user&#39;s priority, is considered the closest match and is the
 320  * item returned.&quot;
 321  *
 322  * &lt;p&gt;For example, if a Language Priority List consists of two language ranges,
 323  * {@code &quot;zh-Hant-TW&quot;} and {@code &quot;en-US&quot;}, in prioritized order, lookup
 324  * method progressively searches the language tags below in order to find the
 325  * best matching language tag.
 326  * &lt;blockquote&gt;
 327  * &lt;pre&gt;
 328  *    1. zh-Hant-TW
 329  *    2. zh-Hant
 330  *    3. zh
 331  *    4. en-US
 332  *    5. en
 333  * &lt;/pre&gt;
 334  * &lt;/blockquote&gt;
 335  * If there is a language tag which matches completely to a language range
 336  * above, the language tag is returned.
 337  *
 338  * &lt;p&gt;{@code &quot;*&quot;} is the special language range, and it is ignored in lookup.
 339  *
 340  * &lt;p&gt;If multiple language tags match as a result of the subtag {@code &#39;*&#39;}
 341  * included in a language range, the first matching language tag returned by
 342  * an {@link Iterator} over a {@link Collection} of language tags is treated as
 343  * the best matching one.
 344  *
<span class="line-modified"> 345  * &lt;h4&gt;Use of Locale&lt;/h4&gt;</span>
 346  *
<span class="line-modified"> 347  * &lt;p&gt;Once you&#39;ve created a &lt;code&gt;Locale&lt;/code&gt; you can query it for information</span>
<span class="line-modified"> 348  * about itself. Use &lt;code&gt;getCountry&lt;/code&gt; to get the country (or region)</span>
<span class="line-modified"> 349  * code and &lt;code&gt;getLanguage&lt;/code&gt; to get the language code.</span>
<span class="line-modified"> 350  * You can use &lt;code&gt;getDisplayCountry&lt;/code&gt; to get the</span>
 351  * name of the country suitable for displaying to the user. Similarly,
<span class="line-modified"> 352  * you can use &lt;code&gt;getDisplayLanguage&lt;/code&gt; to get the name of</span>
 353  * the language suitable for displaying to the user. Interestingly,
<span class="line-modified"> 354  * the &lt;code&gt;getDisplayXXX&lt;/code&gt; methods are themselves locale-sensitive</span>
 355  * and have two versions: one that uses the default
 356  * {@link Locale.Category#DISPLAY DISPLAY} locale and one
 357  * that uses the locale specified as an argument.
 358  *
 359  * &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
<span class="line-modified"> 360  * operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats</span>
 361  * numbers, currency, and percentages in a locale-sensitive manner. Classes
<span class="line-modified"> 362  * such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods</span>
 363  * for creating a default object of that type. For example, the
<span class="line-modified"> 364  * &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods</span>
<span class="line-modified"> 365  * for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:</span>
 366  * &lt;blockquote&gt;
 367  * &lt;pre&gt;
 368  *     NumberFormat.getInstance()
 369  *     NumberFormat.getCurrencyInstance()
 370  *     NumberFormat.getPercentInstance()
 371  * &lt;/pre&gt;
 372  * &lt;/blockquote&gt;
 373  * Each of these methods has two variants; one with an explicit locale
 374  * and one without; the latter uses the default
 375  * {@link Locale.Category#FORMAT FORMAT} locale:
 376  * &lt;blockquote&gt;
 377  * &lt;pre&gt;
 378  *     NumberFormat.getInstance(myLocale)
 379  *     NumberFormat.getCurrencyInstance(myLocale)
 380  *     NumberFormat.getPercentInstance(myLocale)
 381  * &lt;/pre&gt;
 382  * &lt;/blockquote&gt;
<span class="line-modified"> 383  * A &lt;code&gt;Locale&lt;/code&gt; is the mechanism for identifying the kind of object</span>
<span class="line-modified"> 384  * (&lt;code&gt;NumberFormat&lt;/code&gt;) that you would like to get. The locale is</span>
 385  * &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
 386  * &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
 387  *
<span class="line-modified"> 388  * &lt;h4&gt;Compatibility&lt;/h4&gt;</span>
 389  *
 390  * &lt;p&gt;In order to maintain compatibility with existing usage, Locale&#39;s
 391  * constructors retain their behavior prior to the Java Runtime
 392  * Environment version 1.7.  The same is largely true for the
<span class="line-modified"> 393  * &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to</span>
 394  * be used as they were. In particular, clients who parse the output
 395  * of toString into language, country, and variant fields can continue
 396  * to do so (although this is strongly discouraged), although the
 397  * variant field will have additional information in it if script or
 398  * extensions are present.
 399  *
 400  * &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
 401  * imposed by Locale&#39;s constructors. This means that conversions
 402  * between some Locales and BCP 47 language tags cannot be made without
<span class="line-modified"> 403  * losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot</span>
 404  * represent the state of locales whose language, country, or variant
 405  * do not conform to BCP 47.
 406  *
 407  * &lt;p&gt;Because of these issues, it is recommended that clients migrate
 408  * away from constructing non-conforming locales and use the
<span class="line-modified"> 409  * &lt;code&gt;forLanguageTag&lt;/code&gt; and &lt;code&gt;Locale.Builder&lt;/code&gt; APIs instead.</span>
 410  * Clients desiring a string representation of the complete locale can
<span class="line-modified"> 411  * then always rely on &lt;code&gt;toLanguageTag&lt;/code&gt; for this purpose.</span>
 412  *
<span class="line-modified"> 413  * &lt;h5&gt;&lt;a id=&quot;special_cases_constructor&quot;&gt;Special cases&lt;/a&gt;&lt;/h5&gt;</span>
 414  *
 415  * &lt;p&gt;For compatibility reasons, two
 416  * non-conforming locales are treated as special cases.  These are
 417  * &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
 418  * in BCP 47 since the variants are too short. To ease migration to BCP 47,
 419  * these are treated specially during construction.  These two cases (and only
 420  * these) cause a constructor to generate an extension, all other values behave
 421  * exactly as they did prior to Java 7.
 422  *
 423  * &lt;p&gt;Java has used {@code ja_JP_JP} to represent Japanese as used in
 424  * Japan together with the Japanese Imperial calendar. This is now
 425  * representable using a Unicode locale extension, by specifying the
 426  * Unicode locale key {@code ca} (for &quot;calendar&quot;) and type
 427  * {@code japanese}. When the Locale constructor is called with the
 428  * arguments &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;, the extension &quot;u-ca-japanese&quot; is
 429  * automatically added.
 430  *
 431  * &lt;p&gt;Java has used {@code th_TH_TH} to represent Thai as used in
 432  * Thailand together with Thai digits. This is also now representable using
 433  * a Unicode locale extension, by specifying the Unicode locale key
 434  * {@code nu} (for &quot;number&quot;) and value {@code thai}. When the Locale
 435  * constructor is called with the arguments &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;, the
 436  * extension &quot;u-nu-thai&quot; is automatically added.
 437  *
<span class="line-modified"> 438  * &lt;h5&gt;Serialization&lt;/h5&gt;</span>
 439  *
 440  * &lt;p&gt;During serialization, writeObject writes all fields to the output
 441  * stream, including extensions.
 442  *
 443  * &lt;p&gt;During deserialization, readResolve adds extensions as described
 444  * in &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;, only
 445  * for the two cases th_TH_TH and ja_JP_JP.
 446  *
<span class="line-modified"> 447  * &lt;h5&gt;Legacy language codes&lt;/h5&gt;</span>
 448  *
 449  * &lt;p&gt;Locale&#39;s constructor has always converted three language codes to
 450  * their earlier, obsoleted forms: {@code he} maps to {@code iw},
 451  * {@code yi} maps to {@code ji}, and {@code id} maps to
 452  * {@code in}.  This continues to be the case, in order to not break
 453  * backwards compatibility.
 454  *
 455  * &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
 456  * maintaining the old codes internal to Locale (so that
<span class="line-modified"> 457  * &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old</span>
 458  * code), but using the new codes in the BCP 47 language tag APIs (so
<span class="line-modified"> 459  * that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This</span>
 460  * preserves the equivalence between Locales no matter which code or
 461  * API is used to construct them. Java&#39;s default resource bundle
 462  * lookup mechanism also implements this mapping, so that resources
 463  * can be named using either convention, see {@link ResourceBundle.Control}.
 464  *
<span class="line-modified"> 465  * &lt;h5&gt;Three-letter language/country(region) codes&lt;/h5&gt;</span>
 466  *
 467  * &lt;p&gt;The Locale constructors have always specified that the language
 468  * and the country param be two characters in length, although in
 469  * practice they have accepted any length.  The specification has now
 470  * been relaxed to allow language codes of two to eight characters and
 471  * country (region) codes of two to three characters, and in
 472  * particular, three-letter language codes and three-digit region
 473  * codes as specified in the IANA Language Subtag Registry.  For
 474  * compatibility, the implementation still does not impose a length
 475  * constraint.
 476  *
 477  * @see Builder
 478  * @see ResourceBundle
 479  * @see java.text.Format
 480  * @see java.text.NumberFormat
 481  * @see java.text.Collator
 482  * @author Mark Davis
 483  * @since 1.1
 484  */
 485 public final class Locale implements Cloneable, Serializable {
 486 
<span class="line-removed"> 487     private static final  Cache LOCALECACHE = new Cache();</span>
<span class="line-removed"> 488 </span>
 489     /** Useful constant for language.
 490      */
<span class="line-modified"> 491     public static final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);</span>
 492 
 493     /** Useful constant for language.
 494      */
<span class="line-modified"> 495     public static final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);</span>
 496 
 497     /** Useful constant for language.
 498      */
<span class="line-modified"> 499     public static final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);</span>
 500 
 501     /** Useful constant for language.
 502      */
<span class="line-modified"> 503     public static final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);</span>
 504 
 505     /** Useful constant for language.
 506      */
<span class="line-modified"> 507     public static final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);</span>
 508 
 509     /** Useful constant for language.
 510      */
<span class="line-modified"> 511     public static final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);</span>
 512 
 513     /** Useful constant for language.
 514      */
<span class="line-modified"> 515     public static final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);</span>
 516 
 517     /** Useful constant for language.
 518      */
<span class="line-modified"> 519     public static final Locale SIMPLIFIED_CHINESE = createConstant(&quot;zh&quot;, &quot;CN&quot;);</span>
 520 
 521     /** Useful constant for language.
 522      */
<span class="line-modified"> 523     public static final Locale TRADITIONAL_CHINESE = createConstant(&quot;zh&quot;, &quot;TW&quot;);</span>
 524 
 525     /** Useful constant for country.
 526      */
<span class="line-modified"> 527     public static final Locale FRANCE = createConstant(&quot;fr&quot;, &quot;FR&quot;);</span>
 528 
 529     /** Useful constant for country.
 530      */
<span class="line-modified"> 531     public static final Locale GERMANY = createConstant(&quot;de&quot;, &quot;DE&quot;);</span>
 532 
 533     /** Useful constant for country.
 534      */
<span class="line-modified"> 535     public static final Locale ITALY = createConstant(&quot;it&quot;, &quot;IT&quot;);</span>
 536 
 537     /** Useful constant for country.
 538      */
<span class="line-modified"> 539     public static final Locale JAPAN = createConstant(&quot;ja&quot;, &quot;JP&quot;);</span>
 540 
 541     /** Useful constant for country.
 542      */
<span class="line-modified"> 543     public static final Locale KOREA = createConstant(&quot;ko&quot;, &quot;KR&quot;);</span>
 544 
 545     /** Useful constant for country.
 546      */
<span class="line-modified"> 547     public static final Locale CHINA = SIMPLIFIED_CHINESE;</span>
 548 
 549     /** Useful constant for country.
 550      */
<span class="line-modified"> 551     public static final Locale PRC = SIMPLIFIED_CHINESE;</span>
 552 
 553     /** Useful constant for country.
 554      */
<span class="line-modified"> 555     public static final Locale TAIWAN = TRADITIONAL_CHINESE;</span>
 556 
 557     /** Useful constant for country.
 558      */
<span class="line-modified"> 559     public static final Locale UK = createConstant(&quot;en&quot;, &quot;GB&quot;);</span>


































 560 
 561     /** Useful constant for country.
 562      */
<span class="line-modified"> 563     public static final Locale US = createConstant(&quot;en&quot;, &quot;US&quot;);</span>
 564 
 565     /** Useful constant for country.
 566      */
<span class="line-modified"> 567     public static final Locale CANADA = createConstant(&quot;en&quot;, &quot;CA&quot;);</span>
 568 
 569     /** Useful constant for country.
 570      */
<span class="line-modified"> 571     public static final Locale CANADA_FRENCH = createConstant(&quot;fr&quot;, &quot;CA&quot;);</span>
 572 
 573     /**
<span class="line-modified"> 574      * Useful constant for the root locale.  The root locale is the locale whose</span>
<span class="line-modified"> 575      * language, country, and variant are empty (&quot;&quot;) strings.  This is regarded</span>
<span class="line-removed"> 576      * as the base locale of all locales, and is used as the language/country</span>
<span class="line-removed"> 577      * neutral locale for the locale sensitive operations.</span>
<span class="line-removed"> 578      *</span>
<span class="line-removed"> 579      * @since 1.6</span>
 580      */
<span class="line-modified"> 581     public static final Locale ROOT = createConstant(&quot;&quot;, &quot;&quot;);</span>





 582 
 583     /**
 584      * The key for the private use extension (&#39;x&#39;).
 585      *
 586      * @see #getExtension(char)
 587      * @see Builder#setExtension(char, String)
 588      * @since 1.7
 589      */
 590     public static final char PRIVATE_USE_EXTENSION = &#39;x&#39;;
 591 
 592     /**
 593      * The key for Unicode locale extension (&#39;u&#39;).
 594      *
 595      * @see #getExtension(char)
 596      * @see Builder#setExtension(char, String)
 597      * @since 1.7
 598      */
 599     public static final char UNICODE_LOCALE_EXTENSION = &#39;u&#39;;
 600 
 601     /** serialization ID
 602      */

 603     static final long serialVersionUID = 9149081749638150636L;
 604 
 605     /**
 606      * Enum for specifying the type defined in ISO 3166. This enum is used to
 607      * retrieve the two-letter ISO3166-1 alpha-2, three-letter ISO3166-1
 608      * alpha-3, four-letter ISO3166-3 country codes.
 609      *
 610      * @see #getISOCountries(Locale.IsoCountryCode)
 611      * @since 9
 612      */
 613     public static enum IsoCountryCode {
 614         /**
 615          * PART1_ALPHA2 is used to represent the ISO3166-1 alpha-2 two letter
 616          * country codes.
 617          */
 618         PART1_ALPHA2 {
 619             @Override
 620             Set&lt;String&gt; createCountryCodeSet() {
 621                 return Set.of(Locale.getISOCountries());
 622             }
</pre>
<hr />
<pre>
 683     }
 684 
 685     /**
 686      * Construct a locale from language, country and variant.
 687      * This constructor normalizes the language value to lowercase and
 688      * the country value to uppercase.
 689      * &lt;p&gt;
 690      * &lt;b&gt;Note:&lt;/b&gt;
 691      * &lt;ul&gt;
 692      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 693      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 694      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 695      * API on Locale will return only the OLD codes.
 696      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 697      * any syntactic checks on the input.
 698      * &lt;li&gt;The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially,
 699      * see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.
 700      * &lt;/ul&gt;
 701      *
 702      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified"> 703      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
 704      * valid language values.
 705      * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified"> 706      * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</span>
<span class="line-modified"> 707      * @param variant Any arbitrary value used to indicate a variation of a &lt;code&gt;Locale&lt;/code&gt;.</span>
<span class="line-modified"> 708      * See the &lt;code&gt;Locale&lt;/code&gt; class description for the details.</span>
<span class="line-modified"> 709      * @exception NullPointerException thrown if any argument is null.</span>
 710      */
 711     public Locale(String language, String country, String variant) {
<span class="line-modified"> 712         if (language== null || country == null || variant == null) {</span>
 713             throw new NullPointerException();
 714         }
 715         baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);
 716         localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);
 717     }
 718 
 719     /**
 720      * Construct a locale from language and country.
 721      * This constructor normalizes the language value to lowercase and
 722      * the country value to uppercase.
 723      * &lt;p&gt;
 724      * &lt;b&gt;Note:&lt;/b&gt;
 725      * &lt;ul&gt;
 726      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 727      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 728      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 729      * API on Locale will return only the OLD codes.
 730      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 731      * any syntactic checks on the input.
 732      * &lt;/ul&gt;
 733      *
 734      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified"> 735      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
 736      * valid language values.
 737      * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified"> 738      * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</span>
<span class="line-modified"> 739      * @exception NullPointerException thrown if either argument is null.</span>
 740      */
 741     public Locale(String language, String country) {
 742         this(language, country, &quot;&quot;);
 743     }
 744 
 745     /**
 746      * Construct a locale from a language code.
 747      * This constructor normalizes the language value to lowercase.
 748      * &lt;p&gt;
 749      * &lt;b&gt;Note:&lt;/b&gt;
 750      * &lt;ul&gt;
 751      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 752      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 753      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 754      * API on Locale will return only the OLD codes.
 755      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 756      * any syntactic checks on the input.
 757      * &lt;/ul&gt;
 758      *
 759      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified"> 760      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
 761      * valid language values.
<span class="line-modified"> 762      * @exception NullPointerException thrown if argument is null.</span>
 763      * @since 1.4
 764      */
 765     public Locale(String language) {
 766         this(language, &quot;&quot;, &quot;&quot;);
 767     }
 768 
 769     /**
<span class="line-modified"> 770      * This method must be called only for creating the Locale.*</span>
<span class="line-modified"> 771      * constants due to making shortcuts.</span>
<span class="line-modified"> 772      */</span>
<span class="line-removed"> 773     private static Locale createConstant(String lang, String country) {</span>
<span class="line-removed"> 774         BaseLocale base = BaseLocale.createInstance(lang, country);</span>
<span class="line-removed"> 775         return getInstance(base, null);</span>
<span class="line-removed"> 776     }</span>
<span class="line-removed"> 777 </span>
<span class="line-removed"> 778     /**</span>
<span class="line-removed"> 779      * Returns a &lt;code&gt;Locale&lt;/code&gt; constructed from the given</span>
<span class="line-removed"> 780      * &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt; and</span>
<span class="line-removed"> 781      * &lt;code&gt;variant&lt;/code&gt;. If the same &lt;code&gt;Locale&lt;/code&gt; instance</span>
 782      * is available in the cache, then that instance is
<span class="line-modified"> 783      * returned. Otherwise, a new &lt;code&gt;Locale&lt;/code&gt; instance is</span>
 784      * created and cached.
 785      *
 786      * @param language lowercase 2 to 8 language code.
 787      * @param country uppercase two-letter ISO-3166 code and numeric-3 UN M.49 area code.
 788      * @param variant vendor and browser specific code. See class description.
<span class="line-modified"> 789      * @return the &lt;code&gt;Locale&lt;/code&gt; instance requested</span>
<span class="line-modified"> 790      * @exception NullPointerException if any argument is null.</span>
 791      */
 792     static Locale getInstance(String language, String country, String variant) {
 793         return getInstance(language, &quot;&quot;, country, variant, null);
 794     }
 795 
 796     static Locale getInstance(String language, String script, String country,
 797                                       String variant, LocaleExtensions extensions) {
 798         if (language== null || script == null || country == null || variant == null) {
 799             throw new NullPointerException();
 800         }
 801 
 802         if (extensions == null) {
 803             extensions = getCompatibilityExtensions(language, script, country, variant);
 804         }
 805 
<span class="line-modified"> 806         BaseLocale baseloc = BaseLocale.getInstance(language, script, country, variant);</span>
 807         return getInstance(baseloc, extensions);
 808     }
 809 
 810     static Locale getInstance(BaseLocale baseloc, LocaleExtensions extensions) {
 811         if (extensions == null) {
<span class="line-modified"> 812             return LOCALECACHE.get(baseloc);</span>




 813         } else {
 814             LocaleKey key = new LocaleKey(baseloc, extensions);
<span class="line-modified"> 815             return LOCALECACHE.get(key);</span>
 816         }
 817     }
 818 
 819     private static class Cache extends LocaleObjectCache&lt;Object, Locale&gt; {



 820         private Cache() {
 821         }
 822 
 823         @Override
 824         protected Locale createObject(Object key) {
 825             if (key instanceof BaseLocale) {
 826                 return new Locale((BaseLocale)key, null);
 827             } else {
 828                 LocaleKey lk = (LocaleKey)key;
 829                 return new Locale(lk.base, lk.exts);
 830             }
 831         }
 832     }
 833 
 834     private static final class LocaleKey {
 835         private final BaseLocale base;
 836         private final LocaleExtensions exts;
 837         private final int hash;
 838 
 839         private LocaleKey(BaseLocale baseLocale, LocaleExtensions extensions) {
</pre>
<hr />
<pre>
 881      * methods if no locale is explicitly specified.
 882      * It can be changed using the
 883      * {@link #setDefault(java.util.Locale) setDefault} method.
 884      *
 885      * @return the default locale for this instance of the Java Virtual Machine
 886      */
 887     public static Locale getDefault() {
 888         // do not synchronize this method - see 4071298
 889         return defaultLocale;
 890     }
 891 
 892     /**
 893      * Gets the current value of the default locale for the specified Category
 894      * for this instance of the Java Virtual Machine.
 895      * &lt;p&gt;
 896      * The Java Virtual Machine sets the default locale during startup based
 897      * on the host environment. It is used by many locale-sensitive methods
 898      * if no locale is explicitly specified. It can be changed using the
 899      * setDefault(Locale.Category, Locale) method.
 900      *
<span class="line-modified"> 901      * @param category - the specified category to get the default locale</span>
 902      * @throws NullPointerException if category is null
 903      * @return the default locale for the specified Category for this instance
 904      *     of the Java Virtual Machine
 905      * @see #setDefault(Locale.Category, Locale)
 906      * @since 1.7
 907      */
 908     public static Locale getDefault(Locale.Category category) {
 909         // do not synchronize this method - see 4071298
 910         switch (category) {
 911         case DISPLAY:
 912             if (defaultDisplayLocale == null) {
 913                 synchronized(Locale.class) {
 914                     if (defaultDisplayLocale == null) {
 915                         defaultDisplayLocale = initDefault(category);
 916                     }
 917                 }
 918             }
 919             return defaultDisplayLocale;
 920         case FORMAT:
 921             if (defaultFormatLocale == null) {
</pre>
<hr />
<pre>
 960                     .orElse(null));
 961     }
 962 
 963     private static Locale initDefault(Locale.Category category) {
 964         Properties props = GetPropertyAction.privilegedGetProperties();
 965 
 966         return getInstance(
 967             props.getProperty(category.languageKey,
 968                     defaultLocale.getLanguage()),
 969             props.getProperty(category.scriptKey,
 970                     defaultLocale.getScript()),
 971             props.getProperty(category.countryKey,
 972                     defaultLocale.getCountry()),
 973             props.getProperty(category.variantKey,
 974                     defaultLocale.getVariant()),
 975             getDefaultExtensions(props.getProperty(category.extensionsKey, &quot;&quot;))
 976                 .orElse(defaultLocale.getLocaleExtensions()));
 977     }
 978 
 979     private static Optional&lt;LocaleExtensions&gt; getDefaultExtensions(String extensionsProp) {
<span class="line-modified"> 980         LocaleExtensions exts = null;</span>


 981 

 982         try {
 983             exts = new InternalLocaleBuilder()
 984                 .setExtensions(extensionsProp)
 985                 .getLocaleExtensions();
 986         } catch (LocaleSyntaxException e) {
 987             // just ignore this incorrect property
 988         }
 989 
 990         return Optional.ofNullable(exts);
 991     }
 992 
 993     /**
 994      * Sets the default locale for this instance of the Java Virtual Machine.
 995      * This does not affect the host locale.
 996      * &lt;p&gt;
<span class="line-modified"> 997      * If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;</span>
<span class="line-modified"> 998      * method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt;</span>
 999      * permission before the default locale is changed.
1000      * &lt;p&gt;
1001      * The Java Virtual Machine sets the default locale during startup
1002      * based on the host environment. It is used by many locale-sensitive
1003      * methods if no locale is explicitly specified.
1004      * &lt;p&gt;
1005      * Since changing the default locale may affect many different areas
1006      * of functionality, this method should only be used if the caller
1007      * is prepared to reinitialize locale-sensitive code running
1008      * within the same Java Virtual Machine.
1009      * &lt;p&gt;
1010      * By setting the default locale with this method, all of the default
1011      * locales for each Category are also set to the specified default locale.
1012      *
1013      * @throws SecurityException
1014      *        if a security manager exists and its
<span class="line-modified">1015      *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow the operation.</span>
<span class="line-modified">1016      * @throws NullPointerException if &lt;code&gt;newLocale&lt;/code&gt; is null</span>
1017      * @param newLocale the new default locale
1018      * @see SecurityManager#checkPermission
1019      * @see java.util.PropertyPermission
1020      */
1021     public static synchronized void setDefault(Locale newLocale) {
1022         setDefault(Category.DISPLAY, newLocale);
1023         setDefault(Category.FORMAT, newLocale);
1024         defaultLocale = newLocale;
1025     }
1026 
1027     /**
1028      * Sets the default locale for the specified Category for this instance
1029      * of the Java Virtual Machine. This does not affect the host locale.
1030      * &lt;p&gt;
1031      * If there is a security manager, its checkPermission method is called
1032      * with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before
1033      * the default locale is changed.
1034      * &lt;p&gt;
1035      * The Java Virtual Machine sets the default locale during startup based
1036      * on the host environment. It is used by many locale-sensitive methods
1037      * if no locale is explicitly specified.
1038      * &lt;p&gt;
1039      * Since changing the default locale may affect many different areas of
1040      * functionality, this method should only be used if the caller is
1041      * prepared to reinitialize locale-sensitive code running within the
1042      * same Java Virtual Machine.
1043      *
<span class="line-modified">1044      * @param category - the specified category to set the default locale</span>
<span class="line-modified">1045      * @param newLocale - the new default locale</span>
1046      * @throws SecurityException if a security manager exists and its
1047      *     checkPermission method doesn&#39;t allow the operation.
1048      * @throws NullPointerException if category and/or newLocale is null
1049      * @see SecurityManager#checkPermission(java.security.Permission)
1050      * @see PropertyPermission
1051      * @see #getDefault(Locale.Category)
1052      * @since 1.7
1053      */
1054     public static synchronized void setDefault(Locale.Category category,
1055         Locale newLocale) {
1056         if (category == null)
1057             throw new NullPointerException(&quot;Category cannot be NULL&quot;);
1058         if (newLocale == null)
1059             throw new NullPointerException(&quot;Can&#39;t set default locale to NULL&quot;);
1060 
1061         SecurityManager sm = System.getSecurityManager();
1062         if (sm != null) sm.checkPermission(new PropertyPermission
1063                         (&quot;user.language&quot;, &quot;write&quot;));
1064         switch (category) {
1065         case DISPLAY:
1066             defaultDisplayLocale = newLocale;
1067             break;
1068         case FORMAT:
1069             defaultFormatLocale = newLocale;
1070             break;
1071         default:
1072             assert false: &quot;Unknown Category&quot;;
1073         }
1074     }
1075 
1076     /**
1077      * Returns an array of all installed locales.
1078      * The returned array represents the union of locales supported
1079      * by the Java runtime environment and by installed
1080      * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
<span class="line-modified">1081      * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
1082      * instance equal to {@link java.util.Locale#US Locale.US}.
1083      *
1084      * @return An array of installed locales.
1085      */
1086     public static Locale[] getAvailableLocales() {
1087         return LocaleServiceProviderPool.getAllAvailableLocales();
1088     }
1089 
1090     /**
1091      * Returns a list of all 2-letter country codes defined in ISO 3166.
1092      * Can be used to create Locales.
1093      * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
1094      * with {@code type}  {@link IsoCountryCode#PART1_ALPHA2}.
1095      * &lt;p&gt;
<span class="line-modified">1096      * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class also supports other codes for</span>
1097      * country (region), such as 3-letter numeric UN M.49 area codes.
1098      * Therefore, the list returned by this method does not contain ALL valid
1099      * codes that can be used to create Locales.
1100      * &lt;p&gt;
1101      * Note that this method does not return obsolete 2-letter country codes.
1102      * ISO3166-3 codes which designate country codes for those obsolete codes,
1103      * can be retrieved from {@link #getISOCountries(Locale.IsoCountryCode type)} with
1104      * {@code type}  {@link IsoCountryCode#PART3}.
1105      * @return An array of ISO 3166 two-letter country codes.
1106      */
1107     public static String[] getISOCountries() {
1108         if (isoCountries == null) {
1109             isoCountries = getISO2Table(LocaleISOData.isoCountryTable);
1110         }
1111         String[] result = new String[isoCountries.length];
1112         System.arraycopy(isoCountries, 0, result, 0, isoCountries.length);
1113         return result;
1114     }
1115 
1116     /**
</pre>
<hr />
<pre>
1119      * @param type {@link Locale.IsoCountryCode} specified ISO code type.
1120      * @see java.util.Locale.IsoCountryCode
1121      * @throws NullPointerException if type is null
1122      * @return a {@code Set} of ISO country codes for the specified type.
1123      * @since 9
1124      */
1125     public static Set&lt;String&gt; getISOCountries(IsoCountryCode type) {
1126         Objects.requireNonNull(type);
1127         return IsoCountryCode.retrieveISOCountryCodes(type);
1128     }
1129 
1130     /**
1131      * Returns a list of all 2-letter language codes defined in ISO 639.
1132      * Can be used to create Locales.
1133      * &lt;p&gt;
1134      * &lt;b&gt;Note:&lt;/b&gt;
1135      * &lt;ul&gt;
1136      * &lt;li&gt;ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
1137      * The list this function returns includes both the new and the old codes for the
1138      * languages whose codes have changed.
<span class="line-modified">1139      * &lt;li&gt;The &lt;code&gt;Locale&lt;/code&gt; class also supports language codes up to</span>
1140      * 8 characters in length.  Therefore, the list returned by this method does
1141      * not contain ALL valid codes that can be used to create Locales.
1142      * &lt;/ul&gt;
1143      *
1144      * @return An array of ISO 639 two-letter language codes.
1145      */
1146     public static String[] getISOLanguages() {
1147         if (isoLanguages == null) {
1148             isoLanguages = getISO2Table(LocaleISOData.isoLanguageTable);
1149         }
1150         String[] result = new String[isoLanguages.length];
1151         System.arraycopy(isoLanguages, 0, result, 0, isoLanguages.length);
1152         return result;
1153     }
1154 
1155     private static String[] getISO2Table(String table) {
1156         int len = table.length() / 5;
1157         String[] isoTable = new String[len];
1158         for (int i = 0, j = 0; i &lt; len; i++, j += 5) {
1159             isoTable[i] = table.substring(j, j + 2);
</pre>
<hr />
<pre>
1231         return localeExtensions != null;
1232     }
1233 
1234     /**
1235      * Returns a copy of this {@code Locale} with no &lt;a href=&quot;#def_extensions&quot;&gt;
1236      * extensions&lt;/a&gt;. If this {@code Locale} has no extensions, this {@code Locale}
1237      * is returned.
1238      *
1239      * @return a copy of this {@code Locale} with no extensions, or {@code this}
1240      *         if {@code this} has no extensions
1241      * @since 1.8
1242      */
1243     public Locale stripExtensions() {
1244         return hasExtensions() ? Locale.getInstance(baseLocale, null) : this;
1245     }
1246 
1247     /**
1248      * Returns the extension (or private use) value associated with
1249      * the specified key, or null if there is no extension
1250      * associated with the key. To be well-formed, the key must be one
<span class="line-modified">1251      * of &lt;code&gt;[0-9A-Za-z]&lt;/code&gt;. Keys are case-insensitive, so</span>
1252      * for example &#39;z&#39; and &#39;Z&#39; represent the same extension.
1253      *
1254      * @param key the extension key
1255      * @return The extension, or null if this locale defines no
1256      * extension for the specified key.
1257      * @throws IllegalArgumentException if key is not well-formed
1258      * @see #PRIVATE_USE_EXTENSION
1259      * @see #UNICODE_LOCALE_EXTENSION
1260      * @since 1.7
1261      */
1262     public String getExtension(char key) {
1263         if (!LocaleExtensions.isValidKey(key)) {
1264             throw new IllegalArgumentException(&quot;Ill-formed extension key: &quot; + key);
1265         }
1266         return hasExtensions() ? localeExtensions.getExtensionValue(key) : null;
1267     }
1268 
1269     /**
1270      * Returns the set of extension keys associated with this locale, or the
1271      * empty set if it has no extensions. The returned set is unmodifiable.
</pre>
<hr />
<pre>
1291      * @since 1.7
1292      */
1293     public Set&lt;String&gt; getUnicodeLocaleAttributes() {
1294         if (!hasExtensions()) {
1295             return Collections.emptySet();
1296         }
1297         return localeExtensions.getUnicodeLocaleAttributes();
1298     }
1299 
1300     /**
1301      * Returns the Unicode locale type associated with the specified Unicode locale key
1302      * for this locale. Returns the empty string for keys that are defined with no type.
1303      * Returns null if the key is not defined. Keys are case-insensitive. The key must
1304      * be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is
1305      * thrown.
1306      *
1307      * @param key the Unicode locale key
1308      * @return The Unicode locale type associated with the key, or null if the
1309      * locale does not define the key.
1310      * @throws IllegalArgumentException if the key is not well-formed
<span class="line-modified">1311      * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null</span>
1312      * @since 1.7
1313      */
1314     public String getUnicodeLocaleType(String key) {
1315         if (!isUnicodeExtensionKey(key)) {
1316             throw new IllegalArgumentException(&quot;Ill-formed Unicode locale key: &quot; + key);
1317         }
1318         return hasExtensions() ? localeExtensions.getUnicodeLocaleType(key) : null;
1319     }
1320 
1321     /**
1322      * Returns the set of Unicode locale keys defined by this locale, or the empty set if
1323      * this locale has none.  The returned set is immutable.  Keys are all lower case.
1324      *
1325      * @return The set of Unicode locale keys, or the empty set if this locale has
1326      * no Unicode locale keywords.
1327      * @since 1.7
1328      */
1329     public Set&lt;String&gt; getUnicodeLocaleKeys() {
1330         if (localeExtensions == null) {
1331             return Collections.emptySet();
</pre>
<hr />
<pre>
1336     /**
1337      * Package locale method returning the Locale&#39;s BaseLocale,
1338      * used by ResourceBundle
1339      * @return base locale of this Locale
1340      */
1341     BaseLocale getBaseLocale() {
1342         return baseLocale;
1343     }
1344 
1345     /**
1346      * Package private method returning the Locale&#39;s LocaleExtensions,
1347      * used by ResourceBundle.
1348      * @return locale extensions of this Locale,
1349      *         or {@code null} if no extensions are defined
1350      */
1351      LocaleExtensions getLocaleExtensions() {
1352          return localeExtensions;
1353      }
1354 
1355     /**
<span class="line-modified">1356      * Returns a string representation of this &lt;code&gt;Locale&lt;/code&gt;</span>
1357      * object, consisting of language, country, variant, script,
1358      * and extensions as below:
1359      * &lt;blockquote&gt;
1360      * language + &quot;_&quot; + country + &quot;_&quot; + (variant + &quot;_#&quot; | &quot;#&quot;) + script + &quot;_&quot; + extensions
1361      * &lt;/blockquote&gt;
1362      *
1363      * Language is always lower case, country is always upper case, script is always title
1364      * case, and extensions are always lower case.  Extensions and private use subtags
1365      * will be in canonical order as explained in {@link #toLanguageTag}.
1366      *
1367      * &lt;p&gt;When the locale has neither script nor extensions, the result is the same as in
1368      * Java 6 and prior.
1369      *
1370      * &lt;p&gt;If both the language and country fields are missing, this function will return
1371      * the empty string, even if the variant, script, or extensions field is present (you
1372      * can&#39;t have a locale with just a variant, the variant must accompany a well-formed
1373      * language or country code).
1374      *
1375      * &lt;p&gt;If script or extensions are present and variant is missing, no underscore is
1376      * added before the &quot;#&quot;.
1377      *
1378      * &lt;p&gt;This behavior is designed to support debugging and to be compatible with
<span class="line-modified">1379      * previous uses of &lt;code&gt;toString&lt;/code&gt; that expected language, country, and variant</span>
1380      * fields only.  To represent a Locale as a String for interchange purposes, use
1381      * {@link #toLanguageTag}.
1382      *
1383      * &lt;p&gt;Examples: &lt;ul&gt;
1384      * &lt;li&gt;{@code en}&lt;/li&gt;
1385      * &lt;li&gt;{@code de_DE}&lt;/li&gt;
1386      * &lt;li&gt;{@code _GB}&lt;/li&gt;
1387      * &lt;li&gt;{@code en_US_WIN}&lt;/li&gt;
1388      * &lt;li&gt;{@code de__POSIX}&lt;/li&gt;
1389      * &lt;li&gt;{@code zh_CN_#Hans}&lt;/li&gt;
1390      * &lt;li&gt;{@code zh_TW_#Hant_x-java}&lt;/li&gt;
1391      * &lt;li&gt;{@code th_TH_TH_#u-nu-thai}&lt;/li&gt;&lt;/ul&gt;
1392      *
1393      * @return A string representation of the Locale, for debugging.
1394      * @see #getDisplayName
1395      * @see #toLanguageTag
1396      */
1397     @Override
1398     public final String toString() {
1399         boolean l = !baseLocale.getLanguage().isEmpty();
</pre>
<hr />
<pre>
1415         if (s &amp;&amp; (l || r)) {
1416             result.append(&quot;_#&quot;)
1417                 .append(baseLocale.getScript());
1418         }
1419 
1420         if (e &amp;&amp; (l || r)) {
1421             result.append(&#39;_&#39;);
1422             if (!s) {
1423                 result.append(&#39;#&#39;);
1424             }
1425             result.append(localeExtensions.getID());
1426         }
1427 
1428         return result.toString();
1429     }
1430 
1431     /**
1432      * Returns a well-formed IETF BCP 47 language tag representing
1433      * this locale.
1434      *
<span class="line-modified">1435      * &lt;p&gt;If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or</span>
1436      * variant that does not satisfy the IETF BCP 47 language tag
1437      * syntax requirements, this method handles these fields as
1438      * described below:
1439      *
1440      * &lt;p&gt;&lt;b&gt;Language:&lt;/b&gt; If language is empty, or not &lt;a
1441      * href=&quot;#def_language&quot; &gt;well-formed&lt;/a&gt; (for example &quot;a&quot; or
1442      * &quot;e2&quot;), it will be emitted as &quot;und&quot; (Undetermined).
1443      *
1444      * &lt;p&gt;&lt;b&gt;Country:&lt;/b&gt; If country is not &lt;a
1445      * href=&quot;#def_region&quot;&gt;well-formed&lt;/a&gt; (for example &quot;12&quot; or &quot;USA&quot;),
1446      * it will be omitted.
1447      *
1448      * &lt;p&gt;&lt;b&gt;Variant:&lt;/b&gt; If variant &lt;b&gt;is&lt;/b&gt; &lt;a
1449      * href=&quot;#def_variant&quot;&gt;well-formed&lt;/a&gt;, each sub-segment
1450      * (delimited by &#39;-&#39; or &#39;_&#39;) is emitted as a subtag.  Otherwise:
1451      * &lt;ul&gt;
1452      *
1453      * &lt;li&gt;if all sub-segments match &lt;code&gt;[0-9a-zA-Z]{1,8}&lt;/code&gt;
1454      * (for example &quot;WIN&quot; or &quot;Oracle_JDK_Standard_Edition&quot;), the first
1455      * ill-formed sub-segment and all following will be appended to
</pre>
<hr />
<pre>
1651      * converted as follows:
1652      *
1653      * &lt;table class=&quot;striped&quot;&gt;
1654      * &lt;caption style=&quot;display:none&quot;&gt;Grandfathered tags with no modern replacement&lt;/caption&gt;
1655      * &lt;thead style=&quot;text-align:center&quot;&gt;
1656      * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;grandfathered tag&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;converts to&lt;/th&gt;&lt;/tr&gt;
1657      * &lt;/thead&gt;
1658      * &lt;tbody style=&quot;text-align:center&quot;&gt;
1659      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;cel-gaulish&lt;/th&gt;&lt;td&gt;xtg-x-cel-gaulish&lt;/td&gt;&lt;/tr&gt;
1660      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;en-GB-oed&lt;/th&gt;&lt;td&gt;en-GB-x-oed&lt;/td&gt;&lt;/tr&gt;
1661      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-default&lt;/th&gt;&lt;td&gt;en-x-i-default&lt;/td&gt;&lt;/tr&gt;
1662      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-enochian&lt;/th&gt;&lt;td&gt;und-x-i-enochian&lt;/td&gt;&lt;/tr&gt;
1663      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-mingo&lt;/th&gt;&lt;td&gt;see-x-i-mingo&lt;/td&gt;&lt;/tr&gt;
1664      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-min&lt;/th&gt;&lt;td&gt;nan-x-zh-min&lt;/td&gt;&lt;/tr&gt;
1665      * &lt;/tbody&gt;
1666      * &lt;/table&gt;
1667      *
1668      * &lt;p&gt;For a list of all grandfathered tags, see the
1669      * IANA Language Subtag Registry (search for &quot;Type: grandfathered&quot;).
1670      *
<span class="line-modified">1671      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: there is no guarantee that &lt;code&gt;toLanguageTag&lt;/code&gt;</span>
<span class="line-modified">1672      * and &lt;code&gt;forLanguageTag&lt;/code&gt; will round-trip.</span>
1673      *
1674      * @param languageTag the language tag
1675      * @return The locale that best represents the language tag.
<span class="line-modified">1676      * @throws NullPointerException if &lt;code&gt;languageTag&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1677      * @see #toLanguageTag()
1678      * @see java.util.Locale.Builder#setLanguageTag(String)
1679      * @since 1.7
1680      */
1681     public static Locale forLanguageTag(String languageTag) {
1682         LanguageTag tag = LanguageTag.parse(languageTag, null);
1683         InternalLocaleBuilder bldr = new InternalLocaleBuilder();
1684         bldr.setLanguageTag(tag);
1685         BaseLocale base = bldr.getBaseLocale();
1686         LocaleExtensions exts = bldr.getLocaleExtensions();
1687         if (exts == null &amp;&amp; !base.getVariant().isEmpty()) {
1688             exts = getCompatibilityExtensions(base.getLanguage(), base.getScript(),
1689                                               base.getRegion(), base.getVariant());
1690         }
1691         return getInstance(base, exts);
1692     }
1693 
1694     /**
1695      * Returns a three-letter abbreviation of this locale&#39;s language.
1696      * If the language matches an ISO 639-1 two-letter code, the
1697      * corresponding ISO 639-2/T three-letter lowercase code is
1698      * returned.  The ISO 639-2 language codes can be found on-line,
1699      * see &quot;Codes for the Representation of Names of Languages Part 2:
1700      * Alpha-3 Code&quot;.  If the locale specifies a three-letter
1701      * language, the language is returned as is.  If the locale does
1702      * not specify a language the empty string is returned.
1703      *
1704      * @return A three-letter abbreviation of this locale&#39;s language.
<span class="line-modified">1705      * @exception MissingResourceException Throws MissingResourceException if</span>
1706      * three-letter language abbreviation is not available for this locale.
1707      */
1708     public String getISO3Language() throws MissingResourceException {
1709         String lang = baseLocale.getLanguage();
1710         if (lang.length() == 3) {
1711             return lang;
1712         }
1713 
1714         String language3 = getISO3Code(lang, LocaleISOData.isoLanguageTable);
1715         if (language3 == null) {
1716             throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter language code for &quot;
1717                     + lang, &quot;FormatData_&quot; + toString(), &quot;ShortLanguage&quot;);
1718         }
1719         return language3;
1720     }
1721 
1722     /**
1723      * Returns a three-letter abbreviation for this locale&#39;s country.
1724      * If the country matches an ISO 3166-1 alpha-2 code, the
1725      * corresponding ISO 3166-1 alpha-3 uppercase code is returned.
1726      * If the locale doesn&#39;t specify a country, this will be the empty
1727      * string.
1728      *
1729      * &lt;p&gt;The ISO 3166-1 codes can be found on-line.
1730      *
1731      * @return A three-letter abbreviation of this locale&#39;s country.
<span class="line-modified">1732      * @exception MissingResourceException Throws MissingResourceException if the</span>
1733      * three-letter country abbreviation is not available for this locale.
1734      */
1735     public String getISO3Country() throws MissingResourceException {
1736         String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);
1737         if (country3 == null) {
1738             throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter country code for &quot;
1739                     + baseLocale.getRegion(), &quot;FormatData_&quot; + toString(), &quot;ShortCountry&quot;);
1740         }
1741         return country3;
1742     }
1743 
1744     private static String getISO3Code(String iso2Code, String table) {
1745         int codeLength = iso2Code.length();
1746         if (codeLength == 0) {
1747             return &quot;&quot;;
1748         }
1749 
1750         int tableLength = table.length();
1751         int index = tableLength;
1752         if (codeLength == 2) {
</pre>
<hr />
<pre>
1782      */
1783     public final String getDisplayLanguage() {
1784         return getDisplayLanguage(getDefault(Category.DISPLAY));
1785     }
1786 
1787     /**
1788      * Returns a name for the locale&#39;s language that is appropriate for display to the
1789      * user.
1790      * If possible, the name returned will be localized according to inLocale.
1791      * For example, if the locale is fr_FR and inLocale
1792      * is en_US, getDisplayLanguage() will return &quot;French&quot;; if the locale is en_US and
1793      * inLocale is fr_FR, getDisplayLanguage() will return &quot;anglais&quot;.
1794      * If the name returned cannot be localized according to inLocale,
1795      * (say, we don&#39;t have a Japanese name for Croatian),
1796      * this function falls back on the English name, and finally
1797      * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a language,
1798      * this function returns the empty string.
1799      *
1800      * @param inLocale The locale for which to retrieve the display language.
1801      * @return The name of the display language appropriate to the given locale.
<span class="line-modified">1802      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1803      */
1804     public String getDisplayLanguage(Locale inLocale) {
1805         return getDisplayString(baseLocale.getLanguage(), null, inLocale, DISPLAY_LANGUAGE);
1806     }
1807 
1808     /**
1809      * Returns a name for the locale&#39;s script that is appropriate for display to
1810      * the user. If possible, the name will be localized for the default
1811      * {@link Locale.Category#DISPLAY DISPLAY} locale.  Returns
1812      * the empty string if this locale doesn&#39;t specify a script code.
1813      *
1814      * @return the display name of the script code for the current default
1815      *     {@link Locale.Category#DISPLAY DISPLAY} locale
1816      * @since 1.7
1817      */
1818     public String getDisplayScript() {
1819         return getDisplayScript(getDefault(Category.DISPLAY));
1820     }
1821 
1822     /**
1823      * Returns a name for the locale&#39;s script that is appropriate
1824      * for display to the user. If possible, the name will be
1825      * localized for the given locale. Returns the empty string if
1826      * this locale doesn&#39;t specify a script code.
1827      *
1828      * @param inLocale The locale for which to retrieve the display script.
1829      * @return the display name of the script code for the current default
1830      * {@link Locale.Category#DISPLAY DISPLAY} locale
<span class="line-modified">1831      * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1832      * @since 1.7
1833      */
1834     public String getDisplayScript(Locale inLocale) {
1835         return getDisplayString(baseLocale.getScript(), null, inLocale, DISPLAY_SCRIPT);
1836     }
1837 
1838     /**
1839      * Returns a name for the locale&#39;s country that is appropriate for display to the
1840      * user.
1841      * If possible, the name returned will be localized for the default
1842      * {@link Locale.Category#DISPLAY DISPLAY} locale.
1843      * For example, if the locale is fr_FR and the default
1844      * {@link Locale.Category#DISPLAY DISPLAY} locale
1845      * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
1846      * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
1847      * getDisplayCountry() will return &quot;Etats-Unis&quot;.
1848      * If the name returned cannot be localized for the default
1849      * {@link Locale.Category#DISPLAY DISPLAY} locale,
1850      * (say, we don&#39;t have a Japanese name for Croatia),
1851      * this function falls back on the English name, and uses the ISO code as a last-resort
</pre>
<hr />
<pre>
1855      */
1856     public final String getDisplayCountry() {
1857         return getDisplayCountry(getDefault(Category.DISPLAY));
1858     }
1859 
1860     /**
1861      * Returns a name for the locale&#39;s country that is appropriate for display to the
1862      * user.
1863      * If possible, the name returned will be localized according to inLocale.
1864      * For example, if the locale is fr_FR and inLocale
1865      * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
1866      * inLocale is fr_FR, getDisplayCountry() will return &quot;Etats-Unis&quot;.
1867      * If the name returned cannot be localized according to inLocale.
1868      * (say, we don&#39;t have a Japanese name for Croatia),
1869      * this function falls back on the English name, and finally
1870      * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a country,
1871      * this function returns the empty string.
1872      *
1873      * @param inLocale The locale for which to retrieve the display country.
1874      * @return The name of the country appropriate to the given locale.
<span class="line-modified">1875      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1876      */
1877     public String getDisplayCountry(Locale inLocale) {
1878         return getDisplayString(baseLocale.getRegion(), null, inLocale, DISPLAY_COUNTRY);
1879     }
1880 
1881     private String getDisplayString(String code, String cat, Locale inLocale, int type) {
1882         Objects.requireNonNull(inLocale);
1883         Objects.requireNonNull(code);
1884 
1885         if (code.isEmpty()) {
1886             return &quot;&quot;;
1887         }
1888 
1889         LocaleServiceProviderPool pool =
1890             LocaleServiceProviderPool.getPool(LocaleNameProvider.class);
1891         String rbKey = (type == DISPLAY_VARIANT ? &quot;%%&quot;+code : code);
1892         String result = pool.getLocalizedObject(
1893                                 LocaleNameGetter.INSTANCE,
1894                                 inLocale, rbKey, type, code, cat);
1895         return result != null ? result : code;
</pre>
<hr />
<pre>
1897 
1898     /**
1899      * Returns a name for the locale&#39;s variant code that is appropriate for display to the
1900      * user.  If possible, the name will be localized for the default
1901      * {@link Locale.Category#DISPLAY DISPLAY} locale.  If the locale
1902      * doesn&#39;t specify a variant code, this function returns the empty string.
1903      *
1904      * @return The name of the display variant code appropriate to the locale.
1905      */
1906     public final String getDisplayVariant() {
1907         return getDisplayVariant(getDefault(Category.DISPLAY));
1908     }
1909 
1910     /**
1911      * Returns a name for the locale&#39;s variant code that is appropriate for display to the
1912      * user.  If possible, the name will be localized for inLocale.  If the locale
1913      * doesn&#39;t specify a variant code, this function returns the empty string.
1914      *
1915      * @param inLocale The locale for which to retrieve the display variant code.
1916      * @return The name of the display variant code appropriate to the given locale.
<span class="line-modified">1917      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1918      */
1919     public String getDisplayVariant(Locale inLocale) {
1920         if (baseLocale.getVariant().isEmpty())
1921             return &quot;&quot;;
1922 
1923         LocaleResources lr = LocaleProviderAdapter
1924             .getResourceBundleBased()
1925             .getLocaleResources(inLocale);
1926 
1927         String names[] = getDisplayVariantArray(inLocale);
1928 
1929         // Get the localized patterns for formatting a list, and use
1930         // them to format the list.
1931         return formatList(names,
1932                           lr.getLocaleName(&quot;ListCompositionPattern&quot;));
1933     }
1934 
1935     /**
1936      * Returns a name for the locale that is appropriate for display to the
1937      * user. This will be the values returned by getDisplayLanguage(),
</pre>
<hr />
<pre>
1962      * to the user.  This will be the values returned by
1963      * getDisplayLanguage(), getDisplayScript(),getDisplayCountry()
1964      * getDisplayVariant(), and optional &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;
1965      * Unicode extensions&lt;/a&gt; assembled into a single string. The non-empty
1966      * values are used in order, with the second and subsequent names in
1967      * parentheses.  For example:
1968      * &lt;blockquote&gt;
1969      * language (script, country, variant(, extension)*)&lt;br&gt;
1970      * language (country(, extension)*)&lt;br&gt;
1971      * language (variant(, extension)*)&lt;br&gt;
1972      * script (country(, extension)*)&lt;br&gt;
1973      * country (extension)*&lt;br&gt;
1974      * &lt;/blockquote&gt;
1975      * depending on which fields are specified in the locale. The field
1976      * separator in the above parentheses, denoted as a comma character, may
1977      * be localized depending on the locale. If the language, script, country,
1978      * and variant fields are all empty, this function returns the empty string.
1979      *
1980      * @param inLocale The locale for which to retrieve the display name.
1981      * @return The name of the locale appropriate to display.
<span class="line-modified">1982      * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1983      */
1984     public String getDisplayName(Locale inLocale) {
1985         LocaleResources lr =  LocaleProviderAdapter
1986             .getResourceBundleBased()
1987             .getLocaleResources(inLocale);
1988 
1989         String languageName = getDisplayLanguage(inLocale);
1990         String scriptName = getDisplayScript(inLocale);
1991         String countryName = getDisplayCountry(inLocale);
1992         String[] variantNames = getDisplayVariantArray(inLocale);
1993 
1994         // Get the localized patterns for formatting a display name.
1995         String displayNamePattern = lr.getLocaleName(&quot;DisplayNamePattern&quot;);
1996         String listCompositionPattern = lr.getLocaleName(&quot;ListCompositionPattern&quot;);
1997 
1998         // The display name consists of a main name, followed by qualifiers.
1999         // Typically, the format is &quot;MainName (Qualifier, Qualifier)&quot; but this
2000         // depends on what pattern is stored in the display locale.
2001         String   mainName;
2002         String[] qualifierNames;
</pre>
<hr />
<pre>
2250      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getLanguage()&quot;&gt;getLanguage()&lt;/a&gt;)
2251      * @serialField country     String
2252      *      country subtag in upper case.
2253      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getCountry()&quot;&gt;getCountry()&lt;/a&gt;)
2254      * @serialField variant     String
2255      *      variant subtags separated by LOWLINE characters.
2256      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getVariant()&quot;&gt;getVariant()&lt;/a&gt;)
2257      * @serialField hashcode    int
2258      *      deprecated, for forward compatibility only
2259      * @serialField script      String
2260      *      script subtag in title case
2261      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getScript()&quot;&gt;getScript()&lt;/a&gt;)
2262      * @serialField extensions  String
2263      *      canonical representation of extensions, that is,
2264      *      BCP47 extensions in alphabetical order followed by
2265      *      BCP47 private use subtags, all in lower case letters
2266      *      separated by HYPHEN-MINUS characters.
2267      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getExtensionKeys()&quot;&gt;getExtensionKeys()&lt;/a&gt;,
2268      *      &lt;a href=&quot;java.base/java/util/Locale.html#getExtension(char)&quot;&gt;getExtension(char)&lt;/a&gt;)
2269      */

2270     private static final ObjectStreamField[] serialPersistentFields = {
2271         new ObjectStreamField(&quot;language&quot;, String.class),
2272         new ObjectStreamField(&quot;country&quot;, String.class),
2273         new ObjectStreamField(&quot;variant&quot;, String.class),
2274         new ObjectStreamField(&quot;hashcode&quot;, int.class),
2275         new ObjectStreamField(&quot;script&quot;, String.class),
2276         new ObjectStreamField(&quot;extensions&quot;, String.class),
2277     };
2278 
2279     /**
<span class="line-modified">2280      * Serializes this &lt;code&gt;Locale&lt;/code&gt; to the specified &lt;code&gt;ObjectOutputStream&lt;/code&gt;.</span>
<span class="line-modified">2281      * @param out the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write</span>
2282      * @throws IOException
2283      * @since 1.7
2284      */

2285     private void writeObject(ObjectOutputStream out) throws IOException {
2286         ObjectOutputStream.PutField fields = out.putFields();
2287         fields.put(&quot;language&quot;, baseLocale.getLanguage());
2288         fields.put(&quot;script&quot;, baseLocale.getScript());
2289         fields.put(&quot;country&quot;, baseLocale.getRegion());
2290         fields.put(&quot;variant&quot;, baseLocale.getVariant());
2291         fields.put(&quot;extensions&quot;, localeExtensions == null ? &quot;&quot; : localeExtensions.getID());
2292         fields.put(&quot;hashcode&quot;, -1); // place holder just for backward support
2293         out.writeFields();
2294     }
2295 
2296     /**
<span class="line-modified">2297      * Deserializes this &lt;code&gt;Locale&lt;/code&gt;.</span>
<span class="line-modified">2298      * @param in the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read</span>
2299      * @throws IOException
2300      * @throws ClassNotFoundException
2301      * @throws IllformedLocaleException
2302      * @since 1.7
2303      */

2304     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
2305         ObjectInputStream.GetField fields = in.readFields();
2306         String language = (String)fields.get(&quot;language&quot;, &quot;&quot;);
2307         String script = (String)fields.get(&quot;script&quot;, &quot;&quot;);
2308         String country = (String)fields.get(&quot;country&quot;, &quot;&quot;);
2309         String variant = (String)fields.get(&quot;variant&quot;, &quot;&quot;);
2310         String extStr = (String)fields.get(&quot;extensions&quot;, &quot;&quot;);

2311         baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);
2312         if (!extStr.isEmpty()) {
2313             try {
2314                 InternalLocaleBuilder bldr = new InternalLocaleBuilder();
2315                 bldr.setExtensions(extStr);
2316                 localeExtensions = bldr.getLocaleExtensions();
2317             } catch (LocaleSyntaxException e) {
2318                 throw new IllformedLocaleException(e.getMessage());
2319             }
2320         } else {
2321             localeExtensions = null;
2322         }
2323     }
2324 
2325     /**
<span class="line-modified">2326      * Returns a cached &lt;code&gt;Locale&lt;/code&gt; instance equivalent to</span>
<span class="line-modified">2327      * the deserialized &lt;code&gt;Locale&lt;/code&gt;. When serialized</span>
2328      * language, country and variant fields read from the object data stream
2329      * are exactly &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot; or &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot; and script/extensions
<span class="line-modified">2330      * fields are empty, this method supplies &lt;code&gt;UNICODE_LOCALE_EXTENSION&lt;/code&gt;</span>
2331      * &quot;ca&quot;/&quot;japanese&quot; (calendar type is &quot;japanese&quot;) or &quot;nu&quot;/&quot;thai&quot; (number script
2332      * type is &quot;thai&quot;). See &lt;a href=&quot;Locale.html#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;
2333      * for more information.
2334      *
<span class="line-modified">2335      * @return an instance of &lt;code&gt;Locale&lt;/code&gt; equivalent to</span>
<span class="line-modified">2336      * the deserialized &lt;code&gt;Locale&lt;/code&gt;.</span>
2337      * @throws java.io.ObjectStreamException
2338      */

2339     private Object readResolve() throws java.io.ObjectStreamException {
2340         return getInstance(baseLocale.getLanguage(), baseLocale.getScript(),
2341                 baseLocale.getRegion(), baseLocale.getVariant(), localeExtensions);
2342     }
2343 
2344     private static volatile String[] isoLanguages;
2345 
2346     private static volatile String[] isoCountries;
2347 
2348     private static String convertOldISOCodes(String language) {
2349         // we accept both the old and the new ISO codes for the languages whose ISO
2350         // codes have changed, but we always store the OLD code, for backward compatibility
2351         language = LocaleUtils.toLowerString(language).intern();
2352         if (language == &quot;he&quot;) {
2353             return &quot;iw&quot;;
2354         } else if (language == &quot;yi&quot;) {
2355             return &quot;ji&quot;;
2356         } else if (language == &quot;id&quot;) {
2357             return &quot;in&quot;;
2358         } else {
</pre>
<hr />
<pre>
2452                &quot;user.variant.format&quot;,
2453                &quot;user.extensions.format&quot;);
2454 
2455         Category(String languageKey, String scriptKey, String countryKey,
2456                 String variantKey, String extensionsKey) {
2457             this.languageKey = languageKey;
2458             this.scriptKey = scriptKey;
2459             this.countryKey = countryKey;
2460             this.variantKey = variantKey;
2461             this.extensionsKey = extensionsKey;
2462         }
2463 
2464         final String languageKey;
2465         final String scriptKey;
2466         final String countryKey;
2467         final String variantKey;
2468         final String extensionsKey;
2469     }
2470 
2471     /**
<span class="line-modified">2472      * &lt;code&gt;Builder&lt;/code&gt; is used to build instances of &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2473      * from values configured by the setters.  Unlike the &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2474      * constructors, the &lt;code&gt;Builder&lt;/code&gt; checks if a value configured by a</span>
<span class="line-modified">2475      * setter satisfies the syntax requirements defined by the &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2476      * class.  A &lt;code&gt;Locale&lt;/code&gt; object created by a &lt;code&gt;Builder&lt;/code&gt; is</span>
2477      * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
2478      * without losing information.
2479      *
<span class="line-modified">2480      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class does not provide any</span>
2481      * syntactic restrictions on variant, while BCP 47 requires each variant
2482      * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
<span class="line-modified">2483      * alphanumerics.  The method &lt;code&gt;setVariant&lt;/code&gt; throws</span>
<span class="line-modified">2484      * &lt;code&gt;IllformedLocaleException&lt;/code&gt; for a variant that does not satisfy</span>
2485      * this restriction. If it is necessary to support such a variant, use a
<span class="line-modified">2486      * Locale constructor.  However, keep in mind that a &lt;code&gt;Locale&lt;/code&gt;</span>
2487      * object created this way might lose the variant information when
2488      * transformed to a BCP 47 language tag.
2489      *
<span class="line-modified">2490      * &lt;p&gt;The following example shows how to create a &lt;code&gt;Locale&lt;/code&gt; object</span>
<span class="line-modified">2491      * with the &lt;code&gt;Builder&lt;/code&gt;.</span>
2492      * &lt;blockquote&gt;
2493      * &lt;pre&gt;
2494      *     Locale aLocale = new Builder().setLanguage(&quot;sr&quot;).setScript(&quot;Latn&quot;).setRegion(&quot;RS&quot;).build();
2495      * &lt;/pre&gt;
2496      * &lt;/blockquote&gt;
2497      *
<span class="line-modified">2498      * &lt;p&gt;Builders can be reused; &lt;code&gt;clear()&lt;/code&gt; resets all</span>
2499      * fields to their default values.
2500      *
2501      * @see Locale#forLanguageTag
2502      * @since 1.7
2503      */
2504     public static final class Builder {
2505         private final InternalLocaleBuilder localeBuilder;
2506 
2507         /**
2508          * Constructs an empty Builder. The default value of all
2509          * fields, extensions, and private use information is the
2510          * empty string.
2511          */
2512         public Builder() {
2513             localeBuilder = new InternalLocaleBuilder();
2514         }
2515 
2516         /**
<span class="line-modified">2517          * Resets the &lt;code&gt;Builder&lt;/code&gt; to match the provided</span>
<span class="line-modified">2518          * &lt;code&gt;locale&lt;/code&gt;.  Existing state is discarded.</span>
2519          *
2520          * &lt;p&gt;All fields of the locale must be well-formed, see {@link Locale}.
2521          *
2522          * &lt;p&gt;Locales with any ill-formed fields cause
<span class="line-modified">2523          * &lt;code&gt;IllformedLocaleException&lt;/code&gt; to be thrown, except for the</span>
2524          * following three cases which are accepted for compatibility
2525          * reasons:&lt;ul&gt;
2526          * &lt;li&gt;Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) is treated as &quot;ja-JP-u-ca-japanese&quot;
2527          * &lt;li&gt;Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) is treated as &quot;th-TH-u-nu-thai&quot;
2528          * &lt;li&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;) is treated as &quot;nn-NO&quot;&lt;/ul&gt;
2529          *
2530          * @param locale the locale
2531          * @return This builder.
<span class="line-modified">2532          * @throws IllformedLocaleException if &lt;code&gt;locale&lt;/code&gt; has</span>
2533          * any ill-formed fields.
<span class="line-modified">2534          * @throws NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null.</span>
2535          */
2536         public Builder setLocale(Locale locale) {
2537             try {
2538                 localeBuilder.setLocale(locale.baseLocale, locale.localeExtensions);
2539             } catch (LocaleSyntaxException e) {
2540                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2541             }
2542             return this;
2543         }
2544 
2545         /**
2546          * Resets the Builder to match the provided IETF BCP 47
2547          * language tag.  Discards the existing state.  Null and the
2548          * empty string cause the builder to be reset, like {@link
2549          * #clear}.  Grandfathered tags (see {@link
2550          * Locale#forLanguageTag}) are converted to their canonical
2551          * form before being processed.  Otherwise, the language tag
2552          * must be well-formed (see {@link Locale}) or an exception is
<span class="line-modified">2553          * thrown (unlike &lt;code&gt;Locale.forLanguageTag&lt;/code&gt;, which</span>
2554          * just discards ill-formed and following portions of the
2555          * tag).
2556          *
2557          * @param languageTag the language tag
2558          * @return This builder.
<span class="line-modified">2559          * @throws IllformedLocaleException if &lt;code&gt;languageTag&lt;/code&gt; is ill-formed</span>
2560          * @see Locale#forLanguageTag(String)
2561          */
2562         public Builder setLanguageTag(String languageTag) {
2563             ParseStatus sts = new ParseStatus();
2564             LanguageTag tag = LanguageTag.parse(languageTag, sts);
2565             if (sts.isError()) {
2566                 throw new IllformedLocaleException(sts.getErrorMessage(), sts.getErrorIndex());
2567             }
2568             localeBuilder.setLanguageTag(tag);
2569             return this;
2570         }
2571 
2572         /**
<span class="line-modified">2573          * Sets the language.  If &lt;code&gt;language&lt;/code&gt; is the empty string or</span>
<span class="line-modified">2574          * null, the language in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,</span>
2575          * the language must be &lt;a href=&quot;./Locale.html#def_language&quot;&gt;well-formed&lt;/a&gt;
2576          * or an exception is thrown.
2577          *
2578          * &lt;p&gt;The typical language value is a two or three-letter language
2579          * code as defined in ISO639.
2580          *
2581          * @param language the language
2582          * @return This builder.
<span class="line-modified">2583          * @throws IllformedLocaleException if &lt;code&gt;language&lt;/code&gt; is ill-formed</span>
2584          */
2585         public Builder setLanguage(String language) {
2586             try {
2587                 localeBuilder.setLanguage(language);
2588             } catch (LocaleSyntaxException e) {
2589                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2590             }
2591             return this;
2592         }
2593 
2594         /**
<span class="line-modified">2595          * Sets the script. If &lt;code&gt;script&lt;/code&gt; is null or the empty string,</span>
<span class="line-modified">2596          * the script in this &lt;code&gt;Builder&lt;/code&gt; is removed.</span>
2597          * Otherwise, the script must be &lt;a href=&quot;./Locale.html#def_script&quot;&gt;well-formed&lt;/a&gt; or an
2598          * exception is thrown.
2599          *
2600          * &lt;p&gt;The typical script value is a four-letter script code as defined by ISO 15924.
2601          *
2602          * @param script the script
2603          * @return This builder.
<span class="line-modified">2604          * @throws IllformedLocaleException if &lt;code&gt;script&lt;/code&gt; is ill-formed</span>
2605          */
2606         public Builder setScript(String script) {
2607             try {
2608                 localeBuilder.setScript(script);
2609             } catch (LocaleSyntaxException e) {
2610                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2611             }
2612             return this;
2613         }
2614 
2615         /**
2616          * Sets the region.  If region is null or the empty string, the region
<span class="line-modified">2617          * in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,</span>
2618          * the region must be &lt;a href=&quot;./Locale.html#def_region&quot;&gt;well-formed&lt;/a&gt; or an
2619          * exception is thrown.
2620          *
2621          * &lt;p&gt;The typical region value is a two-letter ISO 3166 code or a
2622          * three-digit UN M.49 area code.
2623          *
<span class="line-modified">2624          * &lt;p&gt;The country value in the &lt;code&gt;Locale&lt;/code&gt; created by the</span>
<span class="line-modified">2625          * &lt;code&gt;Builder&lt;/code&gt; is always normalized to upper case.</span>
2626          *
2627          * @param region the region
2628          * @return This builder.
<span class="line-modified">2629          * @throws IllformedLocaleException if &lt;code&gt;region&lt;/code&gt; is ill-formed</span>
2630          */
2631         public Builder setRegion(String region) {
2632             try {
2633                 localeBuilder.setRegion(region);
2634             } catch (LocaleSyntaxException e) {
2635                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2636             }
2637             return this;
2638         }
2639 
2640         /**
2641          * Sets the variant.  If variant is null or the empty string, the
<span class="line-modified">2642          * variant in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise, it</span>
2643          * must consist of one or more &lt;a href=&quot;./Locale.html#def_variant&quot;&gt;well-formed&lt;/a&gt;
2644          * subtags, or an exception is thrown.
2645          *
<span class="line-modified">2646          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method checks if &lt;code&gt;variant&lt;/code&gt;</span>
2647          * satisfies the IETF BCP 47 variant subtag&#39;s syntax requirements,
2648          * and normalizes the value to lowercase letters.  However,
<span class="line-modified">2649          * the &lt;code&gt;Locale&lt;/code&gt; class does not impose any syntactic</span>
2650          * restriction on variant, and the variant value in
<span class="line-modified">2651          * &lt;code&gt;Locale&lt;/code&gt; is case sensitive.  To set such a variant,</span>
2652          * use a Locale constructor.
2653          *
2654          * @param variant the variant
2655          * @return This builder.
<span class="line-modified">2656          * @throws IllformedLocaleException if &lt;code&gt;variant&lt;/code&gt; is ill-formed</span>
2657          */
2658         public Builder setVariant(String variant) {
2659             try {
2660                 localeBuilder.setVariant(variant);
2661             } catch (LocaleSyntaxException e) {
2662                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2663             }
2664             return this;
2665         }
2666 
2667         /**
2668          * Sets the extension for the given key. If the value is null or the
2669          * empty string, the extension is removed.  Otherwise, the extension
2670          * must be &lt;a href=&quot;./Locale.html#def_extensions&quot;&gt;well-formed&lt;/a&gt; or an exception
2671          * is thrown.
2672          *
2673          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#UNICODE_LOCALE_EXTENSION
2674          * UNICODE_LOCALE_EXTENSION} (&#39;u&#39;) is used for the Unicode locale extension.
2675          * Setting a value for this key replaces any existing Unicode locale key/type
2676          * pairs with those defined in the extension.
2677          *
2678          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#PRIVATE_USE_EXTENSION
2679          * PRIVATE_USE_EXTENSION} (&#39;x&#39;) is used for the private use code. To be
2680          * well-formed, the value for this key needs only to have subtags of one to
2681          * eight alphanumeric characters, not two to eight as in the general case.
2682          *
2683          * @param key the extension key
2684          * @param value the extension value
2685          * @return This builder.
<span class="line-modified">2686          * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; is illegal</span>
<span class="line-modified">2687          * or &lt;code&gt;value&lt;/code&gt; is ill-formed</span>
2688          * @see #setUnicodeLocaleKeyword(String, String)
2689          */
2690         public Builder setExtension(char key, String value) {
2691             try {
2692                 localeBuilder.setExtension(key, value);
2693             } catch (LocaleSyntaxException e) {
2694                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2695             }
2696             return this;
2697         }
2698 
2699         /**
2700          * Sets the Unicode locale keyword type for the given key.  If the type
2701          * is null, the Unicode keyword is removed.  Otherwise, the key must be
2702          * non-null and both key and type must be &lt;a
2703          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2704          * is thrown.
2705          *
2706          * &lt;p&gt;Keys and types are converted to lower case.
2707          *
2708          * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;:Setting the &#39;u&#39; extension via {@link #setExtension}
2709          * replaces all Unicode locale keywords with those defined in the
2710          * extension.
2711          *
2712          * @param key the Unicode locale key
2713          * @param type the Unicode locale type
2714          * @return This builder.
<span class="line-modified">2715          * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;</span>
2716          * is ill-formed
<span class="line-modified">2717          * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null</span>
2718          * @see #setExtension(char, String)
2719          */
2720         public Builder setUnicodeLocaleKeyword(String key, String type) {
2721             try {
2722                 localeBuilder.setUnicodeLocaleKeyword(key, type);
2723             } catch (LocaleSyntaxException e) {
2724                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2725             }
2726             return this;
2727         }
2728 
2729         /**
2730          * Adds a unicode locale attribute, if not already present, otherwise
2731          * has no effect.  The attribute must not be null and must be &lt;a
2732          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2733          * is thrown.
2734          *
2735          * @param attribute the attribute
2736          * @return This builder.
<span class="line-modified">2737          * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null</span>
<span class="line-modified">2738          * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed</span>
2739          * @see #setExtension(char, String)
2740          */
2741         public Builder addUnicodeLocaleAttribute(String attribute) {
2742             try {
2743                 localeBuilder.addUnicodeLocaleAttribute(attribute);
2744             } catch (LocaleSyntaxException e) {
2745                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2746             }
2747             return this;
2748         }
2749 
2750         /**
2751          * Removes a unicode locale attribute, if present, otherwise has no
2752          * effect.  The attribute must not be null and must be &lt;a
2753          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2754          * is thrown.
2755          *
2756          * &lt;p&gt;Attribute comparison for removal is case-insensitive.
2757          *
2758          * @param attribute the attribute
2759          * @return This builder.
<span class="line-modified">2760          * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null</span>
<span class="line-modified">2761          * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed</span>
2762          * @see #setExtension(char, String)
2763          */
2764         public Builder removeUnicodeLocaleAttribute(String attribute) {
2765             Objects.requireNonNull(attribute);
2766             try {
2767                 localeBuilder.removeUnicodeLocaleAttribute(attribute);
2768             } catch (LocaleSyntaxException e) {
2769                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2770             }
2771             return this;
2772         }
2773 
2774         /**
2775          * Resets the builder to its initial, empty state.
2776          *
2777          * @return This builder.
2778          */
2779         public Builder clear() {
2780             localeBuilder.clear();
2781             return this;
2782         }
2783 
2784         /**
2785          * Resets the extensions to their initial, empty state.
2786          * Language, script, region and variant are unchanged.
2787          *
2788          * @return This builder.
2789          * @see #setExtension(char, String)
2790          */
2791         public Builder clearExtensions() {
2792             localeBuilder.clearExtensions();
2793             return this;
2794         }
2795 
2796         /**
<span class="line-modified">2797          * Returns an instance of &lt;code&gt;Locale&lt;/code&gt; created from the fields set</span>
2798          * on this builder.
2799          *
2800          * &lt;p&gt;This applies the conversions listed in {@link Locale#forLanguageTag}
2801          * when constructing a Locale. (Grandfathered tags are handled in
2802          * {@link #setLanguageTag}.)
2803          *
2804          * @return A Locale.
2805          */
2806         public Locale build() {
2807             BaseLocale baseloc = localeBuilder.getBaseLocale();
2808             LocaleExtensions extensions = localeBuilder.getLocaleExtensions();
2809             if (extensions == null &amp;&amp; !baseloc.getVariant().isEmpty()) {
2810                 extensions = getCompatibilityExtensions(baseloc.getLanguage(), baseloc.getScript(),
2811                         baseloc.getRegion(), baseloc.getVariant());
2812             }
2813             return Locale.getInstance(baseloc, extensions);
2814         }
2815     }
2816 
2817     /**
</pre>
<hr />
<pre>
3425      * @return a list of matching language tags sorted in descending order
3426      *     based on priority or weight, or an empty list if nothing matches.
3427      *     The list is modifiable.
3428      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3429      *     {@code null}
3430      *
3431      * @since 1.8
3432      */
3433     public static List&lt;String&gt; filterTags(List&lt;LanguageRange&gt; priorityList,
3434                                           Collection&lt;String&gt; tags) {
3435         return filterTags(priorityList, tags, FilteringMode.AUTOSELECT_FILTERING);
3436     }
3437 
3438     /**
3439      * Returns a {@code Locale} instance for the best-matching language
3440      * tag using the lookup mechanism defined in RFC 4647.
3441      *
3442      * @param priorityList user&#39;s Language Priority List in which each language
3443      *     tag is sorted in descending order based on priority or weight
3444      * @param locales {@code Locale} instances used for matching
<span class="line-modified">3445      * @return the best matching &lt;code&gt;Locale&lt;/code&gt; instance chosen based on</span>
3446      *     priority or weight, or {@code null} if nothing matches.
3447      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3448      *     {@code null}
3449      *
3450      * @since 1.8
3451      */
3452     public static Locale lookup(List&lt;LanguageRange&gt; priorityList,
3453                                 Collection&lt;Locale&gt; locales) {
3454         return LocaleMatcher.lookup(priorityList, locales);
3455     }
3456 
3457     /**
3458      * Returns the best-matching language tag using the lookup mechanism
3459      * defined in RFC 4647.
3460      *
3461      * This lookup operation on the given {@code tags} ensures that the
3462      * first matching tag with preserved case is returned.
3463      *
3464      * @param priorityList user&#39;s Language Priority List in which each language
3465      *     tag is sorted in descending order based on priority or weight
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  49 import java.util.concurrent.ConcurrentHashMap;
  50 import java.util.spi.LocaleNameProvider;
  51 import java.util.stream.Collectors;
  52 
  53 import sun.security.action.GetPropertyAction;
  54 import sun.util.locale.BaseLocale;
  55 import sun.util.locale.InternalLocaleBuilder;
  56 import sun.util.locale.LanguageTag;
  57 import sun.util.locale.LocaleExtensions;
  58 import sun.util.locale.LocaleMatcher;
  59 import sun.util.locale.LocaleObjectCache;
  60 import sun.util.locale.LocaleSyntaxException;
  61 import sun.util.locale.LocaleUtils;
  62 import sun.util.locale.ParseStatus;
  63 import sun.util.locale.provider.LocaleProviderAdapter;
  64 import sun.util.locale.provider.LocaleResources;
  65 import sun.util.locale.provider.LocaleServiceProviderPool;
  66 import sun.util.locale.provider.TimeZoneNameUtility;
  67 
  68 /**
<span class="line-modified">  69  * A {@code Locale} object represents a specific geographical, political,</span>
<span class="line-modified">  70  * or cultural region. An operation that requires a {@code Locale} to perform</span>
<span class="line-modified">  71  * its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the {@code Locale}</span>
  72  * to tailor information for the user. For example, displaying a number
  73  * is a locale-sensitive operation&amp;mdash; the number should be formatted
  74  * according to the customs and conventions of the user&#39;s native country,
  75  * region, or culture.
  76  *
  77  * &lt;p&gt; The {@code Locale} class implements IETF BCP 47 which is composed of
  78  * &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 &quot;Matching of Language
  79  * Tags&quot;&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646 &quot;Tags
  80  * for Identifying Languages&quot;&lt;/a&gt; with support for the LDML (UTS#35, &quot;Unicode
  81  * Locale Data Markup Language&quot;) BCP 47-compatible extensions for locale data
  82  * exchange.
  83  *
<span class="line-modified">  84  * &lt;p&gt; A {@code Locale} object logically consists of the fields</span>
  85  * described below.
  86  *
  87  * &lt;dl&gt;
  88  *   &lt;dt&gt;&lt;a id=&quot;def_language&quot;&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
  89  *
  90  *   &lt;dd&gt;ISO 639 alpha-2 or alpha-3 language code, or registered
  91  *   language subtags up to 8 alpha letters (for future enhancements).
  92  *   When a language has both an alpha-2 code and an alpha-3 code, the
  93  *   alpha-2 code must be used.  You can find a full list of valid
  94  *   language codes in the IANA Language Subtag Registry (search for
  95  *   &quot;Type: language&quot;).  The language field is case insensitive, but
<span class="line-modified">  96  *   {@code Locale} always canonicalizes to lower case.&lt;/dd&gt;</span>
  97  *
  98  *   &lt;dd&gt;Well-formed language values have the form
  99  *   &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
 100  *   BCP47 language production, since it excludes extlang.  They are
 101  *   not needed since modern three-letter language codes replace
 102  *   them.&lt;/dd&gt;
 103  *
 104  *   &lt;dd&gt;Example: &quot;en&quot; (English), &quot;ja&quot; (Japanese), &quot;kok&quot; (Konkani)&lt;/dd&gt;
 105  *
 106  *   &lt;dt&gt;&lt;a id=&quot;def_script&quot;&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 107  *
 108  *   &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
 109  *   valid script codes in the IANA Language Subtag Registry (search
 110  *   for &quot;Type: script&quot;).  The script field is case insensitive, but
<span class="line-modified"> 111  *   {@code Locale} always canonicalizes to title case (the first</span>
 112  *   letter is upper case and the rest of the letters are lower
 113  *   case).&lt;/dd&gt;
 114  *
 115  *   &lt;dd&gt;Well-formed script values have the form
 116  *   &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
 117  *
 118  *   &lt;dd&gt;Example: &quot;Latn&quot; (Latin), &quot;Cyrl&quot; (Cyrillic)&lt;/dd&gt;
 119  *
 120  *   &lt;dt&gt;&lt;a id=&quot;def_region&quot;&gt;&lt;b&gt;country (region)&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 121  *
 122  *   &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
 123  *   You can find a full list of valid country and region codes in the
 124  *   IANA Language Subtag Registry (search for &quot;Type: region&quot;).  The
 125  *   country (region) field is case insensitive, but
<span class="line-modified"> 126  *   {@code Locale} always canonicalizes to upper case.&lt;/dd&gt;</span>
 127  *
 128  *   &lt;dd&gt;Well-formed country/region values have
 129  *   the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
 130  *
 131  *   &lt;dd&gt;Example: &quot;US&quot; (United States), &quot;FR&quot; (France), &quot;029&quot;
 132  *   (Caribbean)&lt;/dd&gt;
 133  *
 134  *   &lt;dt&gt;&lt;a id=&quot;def_variant&quot;&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 135  *
 136  *   &lt;dd&gt;Any arbitrary value used to indicate a variation of a
<span class="line-modified"> 137  *   {@code Locale}.  Where there are two or more variant values</span>
 138  *   each indicating its own semantics, these values should be ordered
 139  *   by importance, with most important first, separated by
 140  *   underscore(&#39;_&#39;).  The variant field is case sensitive.&lt;/dd&gt;
 141  *
 142  *   &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
 143  *   subtags.  Also BCP 47 subtags are strictly used to indicate
 144  *   additional variations that define a language or its dialects that
 145  *   are not covered by any combinations of language, script and
 146  *   region subtags.  You can find a full list of valid variant codes
 147  *   in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).
 148  *
<span class="line-modified"> 149  *   &lt;p&gt;However, the variant field in {@code Locale} has</span>
 150  *   historically been used for any kind of variation, not just
 151  *   language variations.  For example, some supported variants
 152  *   available in Java SE Runtime Environments indicate alternative
 153  *   cultural behaviors such as calendar type or number script.  In
 154  *   BCP 47 this kind of information, which does not identify the
 155  *   language, is supported by extension subtags or private use
 156  *   subtags.&lt;/dd&gt;
 157  *
 158  *   &lt;dd&gt;Well-formed variant values have the form &lt;code&gt;SUBTAG
 159  *   ((&#39;_&#39;|&#39;-&#39;) SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
 160  *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only
 161  *   uses hyphen (&#39;-&#39;) as a delimiter, this is more lenient).&lt;/dd&gt;
 162  *
 163  *   &lt;dd&gt;Example: &quot;polyton&quot; (Polytonic Greek), &quot;POSIX&quot;&lt;/dd&gt;
 164  *
 165  *   &lt;dt&gt;&lt;a id=&quot;def_extensions&quot;&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 166  *
 167  *   &lt;dd&gt;A map from single character keys to string values, indicating
 168  *   extensions apart from language identification.  The extensions in
<span class="line-modified"> 169  *   {@code Locale} implement the semantics and syntax of BCP 47</span>
 170  *   extension subtags and private use subtags. The extensions are
<span class="line-modified"> 171  *   case insensitive, but {@code Locale} canonicalizes all</span>
 172  *   extension keys and values to lower case. Note that extensions
 173  *   cannot have empty values.&lt;/dd&gt;
 174  *
 175  *   &lt;dd&gt;Well-formed keys are single characters from the set
<span class="line-modified"> 176  *   {@code [0-9a-zA-Z]}.  Well-formed values have the form</span>
<span class="line-modified"> 177  *   {@code SUBTAG (&#39;-&#39; SUBTAG)*} where for the key &#39;x&#39;</span>
 178  *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
 179  *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, &#39;x&#39; allows
 180  *   single-character subtags).&lt;/dd&gt;
 181  *
 182  *   &lt;dd&gt;Example: key=&quot;u&quot;/value=&quot;ca-japanese&quot; (Japanese Calendar),
 183  *   key=&quot;x&quot;/value=&quot;java-1-7&quot;&lt;/dd&gt;
 184  * &lt;/dl&gt;
 185  *
 186  * &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
<span class="line-modified"> 187  * in the IANA Language Subtag Registry, the {@code Locale} class</span>
<span class="line-modified"> 188  * does not provide any validation features.  The {@code Builder}</span>
 189  * only checks if an individual field satisfies the syntactic
 190  * requirement (is well-formed), but does not validate the value
 191  * itself.  See {@link Builder} for details.
 192  *
<span class="line-modified"> 193  * &lt;h2&gt;&lt;a id=&quot;def_locale_extension&quot;&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h2&gt;</span>
 194  *
 195  * &lt;p&gt;UTS#35, &quot;Unicode Locale Data Markup Language&quot; defines optional
 196  * attributes and keywords to override or refine the default behavior
 197  * associated with a locale.  A keyword is represented by a pair of
 198  * key and type.  For example, &quot;nu-thai&quot; indicates that Thai local
 199  * digits (value:&quot;thai&quot;) should be used for formatting numbers
 200  * (key:&quot;nu&quot;).
 201  *
 202  * &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
 203  * extension key &#39;u&#39; ({@link #UNICODE_LOCALE_EXTENSION}).  The above
 204  * example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.
 205  *
<span class="line-modified"> 206  * &lt;p&gt;Thus, when a {@code Locale} object contains Unicode locale</span>
 207  * attributes and keywords,
<span class="line-modified"> 208  * {@code getExtension(UNICODE_LOCALE_EXTENSION)} will return a</span>
 209  * String representing this information, for example, &quot;nu-thai&quot;.  The
<span class="line-modified"> 210  * {@code Locale} class also provides {@link</span>
 211  * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
 212  * {@link #getUnicodeLocaleType} which allow you to access Unicode
 213  * locale attributes and key/type pairs directly.  When represented as
 214  * a string, the Unicode Locale Extension lists attributes
 215  * alphabetically, followed by key/type sequences with keys listed
 216  * alphabetically (the order of subtags comprising a key&#39;s type is
 217  * fixed when the type is defined)
 218  *
 219  * &lt;p&gt;A well-formed locale key has the form
 220  * &lt;code&gt;[0-9a-zA-Z]{2}&lt;/code&gt;.  A well-formed locale type has the
 221  * form &lt;code&gt;&quot;&quot; | [0-9a-zA-Z]{3,8} (&#39;-&#39; [0-9a-zA-Z]{3,8})*&lt;/code&gt; (it
 222  * can be empty, or a series of subtags 3-8 alphanums in length).  A
 223  * well-formed locale attribute has the form
 224  * &lt;code&gt;[0-9a-zA-Z]{3,8}&lt;/code&gt; (it is a single subtag with the same
 225  * form as a locale type subtag).
 226  *
 227  * &lt;p&gt;The Unicode locale extension specifies optional behavior in
 228  * locale-sensitive services.  Although the LDML specification defines
 229  * various keys and values, actual locale-sensitive service
 230  * implementations in a Java Runtime Environment might not support any
 231  * particular Unicode locale attributes or key/type pairs.
 232  *
<span class="line-modified"> 233  * &lt;h3&gt;Creating a Locale&lt;/h3&gt;</span>
 234  *
<span class="line-modified"> 235  * &lt;p&gt;There are several different ways to create a {@code Locale}</span>
 236  * object.
 237  *
<span class="line-modified"> 238  * &lt;h4&gt;Builder&lt;/h4&gt;</span>
 239  *
<span class="line-modified"> 240  * &lt;p&gt;Using {@link Builder} you can construct a {@code Locale} object</span>
 241  * that conforms to BCP 47 syntax.
 242  *
<span class="line-modified"> 243  * &lt;h4&gt;Constructors&lt;/h4&gt;</span>
 244  *
<span class="line-modified"> 245  * &lt;p&gt;The {@code Locale} class provides three constructors:</span>
 246  * &lt;blockquote&gt;
 247  * &lt;pre&gt;
 248  *     {@link #Locale(String language)}
 249  *     {@link #Locale(String language, String country)}
 250  *     {@link #Locale(String language, String country, String variant)}
 251  * &lt;/pre&gt;
 252  * &lt;/blockquote&gt;
<span class="line-modified"> 253  * These constructors allow you to create a {@code Locale} object</span>
 254  * with language, country and variant, but you cannot specify
 255  * script or extensions.
 256  *
<span class="line-modified"> 257  * &lt;h4&gt;Factory Methods&lt;/h4&gt;</span>
 258  *
<span class="line-modified"> 259  * &lt;p&gt;The method {@link #forLanguageTag} creates a {@code Locale}</span>
 260  * object for a well-formed BCP 47 language tag.
 261  *
<span class="line-modified"> 262  * &lt;h4&gt;Locale Constants&lt;/h4&gt;</span>
 263  *
<span class="line-modified"> 264  * &lt;p&gt;The {@code Locale} class provides a number of convenient constants</span>
<span class="line-modified"> 265  * that you can use to create {@code Locale} objects for commonly used</span>
<span class="line-modified"> 266  * locales. For example, the following creates a {@code Locale} object</span>
 267  * for the United States:
 268  * &lt;blockquote&gt;
 269  * &lt;pre&gt;
 270  *     Locale.US
 271  * &lt;/pre&gt;
 272  * &lt;/blockquote&gt;
 273  *
<span class="line-modified"> 274  * &lt;h3&gt;&lt;a id=&quot;LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;&lt;/h3&gt;</span>
 275  *
 276  * &lt;p&gt;If an application or a system is internationalized and provides localized
 277  * resources for multiple locales, it sometimes needs to find one or more
 278  * locales (or language tags) which meet each user&#39;s specific preferences. Note
 279  * that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this
 280  * locale matching documentation.
 281  *
 282  * &lt;p&gt;In order to do matching a user&#39;s preferred locales to a set of language
 283  * tags, &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of
 284  * Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup.
 285  * &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas
 286  * &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale.
 287  * Matching is done case-insensitively. These matching mechanisms are described
 288  * in the following sections.
 289  *
 290  * &lt;p&gt;A user&#39;s preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
 291  * expressed as a list of language ranges. There are syntactically two types of
 292  * language ranges: basic and extended. See
 293  * {@link Locale.LanguageRange Locale.LanguageRange} for details.
 294  *
<span class="line-modified"> 295  * &lt;h4&gt;Filtering&lt;/h4&gt;</span>
 296  *
 297  * &lt;p&gt;The filtering operation returns all matching language tags. It is defined
 298  * in RFC 4647 as follows:
 299  * &quot;In filtering, each language range represents the least specific language
 300  * tag (that is, the language tag with fewest number of subtags) that is an
 301  * acceptable match. All of the language tags in the matching set of tags will
 302  * have an equal or greater number of subtags than the language range. Every
 303  * non-wildcard subtag in the language range will appear in every one of the
 304  * matching language tags.&quot;
 305  *
 306  * &lt;p&gt;There are two types of filtering: filtering for basic language ranges
 307  * (called &quot;basic filtering&quot;) and filtering for extended language ranges
 308  * (called &quot;extended filtering&quot;). They may return different results by what
 309  * kind of language ranges are included in the given Language Priority List.
 310  * {@link Locale.FilteringMode} is a parameter to specify how filtering should
 311  * be done.
 312  *
<span class="line-modified"> 313  * &lt;h4&gt;Lookup&lt;/h4&gt;</span>
 314  *
 315  * &lt;p&gt;The lookup operation returns the best matching language tags. It is
 316  * defined in RFC 4647 as follows:
 317  * &quot;By contrast with filtering, each language range represents the most
 318  * specific tag that is an acceptable match.  The first matching tag found,
 319  * according to the user&#39;s priority, is considered the closest match and is the
 320  * item returned.&quot;
 321  *
 322  * &lt;p&gt;For example, if a Language Priority List consists of two language ranges,
 323  * {@code &quot;zh-Hant-TW&quot;} and {@code &quot;en-US&quot;}, in prioritized order, lookup
 324  * method progressively searches the language tags below in order to find the
 325  * best matching language tag.
 326  * &lt;blockquote&gt;
 327  * &lt;pre&gt;
 328  *    1. zh-Hant-TW
 329  *    2. zh-Hant
 330  *    3. zh
 331  *    4. en-US
 332  *    5. en
 333  * &lt;/pre&gt;
 334  * &lt;/blockquote&gt;
 335  * If there is a language tag which matches completely to a language range
 336  * above, the language tag is returned.
 337  *
 338  * &lt;p&gt;{@code &quot;*&quot;} is the special language range, and it is ignored in lookup.
 339  *
 340  * &lt;p&gt;If multiple language tags match as a result of the subtag {@code &#39;*&#39;}
 341  * included in a language range, the first matching language tag returned by
 342  * an {@link Iterator} over a {@link Collection} of language tags is treated as
 343  * the best matching one.
 344  *
<span class="line-modified"> 345  * &lt;h3&gt;Use of Locale&lt;/h3&gt;</span>
 346  *
<span class="line-modified"> 347  * &lt;p&gt;Once you&#39;ve created a {@code Locale} you can query it for information</span>
<span class="line-modified"> 348  * about itself. Use {@code getCountry} to get the country (or region)</span>
<span class="line-modified"> 349  * code and {@code getLanguage} to get the language code.</span>
<span class="line-modified"> 350  * You can use {@code getDisplayCountry} to get the</span>
 351  * name of the country suitable for displaying to the user. Similarly,
<span class="line-modified"> 352  * you can use {@code getDisplayLanguage} to get the name of</span>
 353  * the language suitable for displaying to the user. Interestingly,
<span class="line-modified"> 354  * the {@code getDisplayXXX} methods are themselves locale-sensitive</span>
 355  * and have two versions: one that uses the default
 356  * {@link Locale.Category#DISPLAY DISPLAY} locale and one
 357  * that uses the locale specified as an argument.
 358  *
 359  * &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
<span class="line-modified"> 360  * operations. For example, the {@code NumberFormat} class formats</span>
 361  * numbers, currency, and percentages in a locale-sensitive manner. Classes
<span class="line-modified"> 362  * such as {@code NumberFormat} have several convenience methods</span>
 363  * for creating a default object of that type. For example, the
<span class="line-modified"> 364  * {@code NumberFormat} class provides these three convenience methods</span>
<span class="line-modified"> 365  * for creating a default {@code NumberFormat} object:</span>
 366  * &lt;blockquote&gt;
 367  * &lt;pre&gt;
 368  *     NumberFormat.getInstance()
 369  *     NumberFormat.getCurrencyInstance()
 370  *     NumberFormat.getPercentInstance()
 371  * &lt;/pre&gt;
 372  * &lt;/blockquote&gt;
 373  * Each of these methods has two variants; one with an explicit locale
 374  * and one without; the latter uses the default
 375  * {@link Locale.Category#FORMAT FORMAT} locale:
 376  * &lt;blockquote&gt;
 377  * &lt;pre&gt;
 378  *     NumberFormat.getInstance(myLocale)
 379  *     NumberFormat.getCurrencyInstance(myLocale)
 380  *     NumberFormat.getPercentInstance(myLocale)
 381  * &lt;/pre&gt;
 382  * &lt;/blockquote&gt;
<span class="line-modified"> 383  * A {@code Locale} is the mechanism for identifying the kind of object</span>
<span class="line-modified"> 384  * ({@code NumberFormat}) that you would like to get. The locale is</span>
 385  * &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
 386  * &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
 387  *
<span class="line-modified"> 388  * &lt;h3&gt;Compatibility&lt;/h3&gt;</span>
 389  *
 390  * &lt;p&gt;In order to maintain compatibility with existing usage, Locale&#39;s
 391  * constructors retain their behavior prior to the Java Runtime
 392  * Environment version 1.7.  The same is largely true for the
<span class="line-modified"> 393  * {@code toString} method. Thus Locale objects can continue to</span>
 394  * be used as they were. In particular, clients who parse the output
 395  * of toString into language, country, and variant fields can continue
 396  * to do so (although this is strongly discouraged), although the
 397  * variant field will have additional information in it if script or
 398  * extensions are present.
 399  *
 400  * &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
 401  * imposed by Locale&#39;s constructors. This means that conversions
 402  * between some Locales and BCP 47 language tags cannot be made without
<span class="line-modified"> 403  * losing information. Thus {@code toLanguageTag} cannot</span>
 404  * represent the state of locales whose language, country, or variant
 405  * do not conform to BCP 47.
 406  *
 407  * &lt;p&gt;Because of these issues, it is recommended that clients migrate
 408  * away from constructing non-conforming locales and use the
<span class="line-modified"> 409  * {@code forLanguageTag} and {@code Locale.Builder} APIs instead.</span>
 410  * Clients desiring a string representation of the complete locale can
<span class="line-modified"> 411  * then always rely on {@code toLanguageTag} for this purpose.</span>
 412  *
<span class="line-modified"> 413  * &lt;h4&gt;&lt;a id=&quot;special_cases_constructor&quot;&gt;Special cases&lt;/a&gt;&lt;/h4&gt;</span>
 414  *
 415  * &lt;p&gt;For compatibility reasons, two
 416  * non-conforming locales are treated as special cases.  These are
 417  * &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
 418  * in BCP 47 since the variants are too short. To ease migration to BCP 47,
 419  * these are treated specially during construction.  These two cases (and only
 420  * these) cause a constructor to generate an extension, all other values behave
 421  * exactly as they did prior to Java 7.
 422  *
 423  * &lt;p&gt;Java has used {@code ja_JP_JP} to represent Japanese as used in
 424  * Japan together with the Japanese Imperial calendar. This is now
 425  * representable using a Unicode locale extension, by specifying the
 426  * Unicode locale key {@code ca} (for &quot;calendar&quot;) and type
 427  * {@code japanese}. When the Locale constructor is called with the
 428  * arguments &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;, the extension &quot;u-ca-japanese&quot; is
 429  * automatically added.
 430  *
 431  * &lt;p&gt;Java has used {@code th_TH_TH} to represent Thai as used in
 432  * Thailand together with Thai digits. This is also now representable using
 433  * a Unicode locale extension, by specifying the Unicode locale key
 434  * {@code nu} (for &quot;number&quot;) and value {@code thai}. When the Locale
 435  * constructor is called with the arguments &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;, the
 436  * extension &quot;u-nu-thai&quot; is automatically added.
 437  *
<span class="line-modified"> 438  * &lt;h4&gt;Serialization&lt;/h4&gt;</span>
 439  *
 440  * &lt;p&gt;During serialization, writeObject writes all fields to the output
 441  * stream, including extensions.
 442  *
 443  * &lt;p&gt;During deserialization, readResolve adds extensions as described
 444  * in &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;, only
 445  * for the two cases th_TH_TH and ja_JP_JP.
 446  *
<span class="line-modified"> 447  * &lt;h4&gt;Legacy language codes&lt;/h4&gt;</span>
 448  *
 449  * &lt;p&gt;Locale&#39;s constructor has always converted three language codes to
 450  * their earlier, obsoleted forms: {@code he} maps to {@code iw},
 451  * {@code yi} maps to {@code ji}, and {@code id} maps to
 452  * {@code in}.  This continues to be the case, in order to not break
 453  * backwards compatibility.
 454  *
 455  * &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
 456  * maintaining the old codes internal to Locale (so that
<span class="line-modified"> 457  * {@code getLanguage} and {@code toString} reflect the old</span>
 458  * code), but using the new codes in the BCP 47 language tag APIs (so
<span class="line-modified"> 459  * that {@code toLanguageTag} reflects the new one). This</span>
 460  * preserves the equivalence between Locales no matter which code or
 461  * API is used to construct them. Java&#39;s default resource bundle
 462  * lookup mechanism also implements this mapping, so that resources
 463  * can be named using either convention, see {@link ResourceBundle.Control}.
 464  *
<span class="line-modified"> 465  * &lt;h4&gt;Three-letter language/country(region) codes&lt;/h4&gt;</span>
 466  *
 467  * &lt;p&gt;The Locale constructors have always specified that the language
 468  * and the country param be two characters in length, although in
 469  * practice they have accepted any length.  The specification has now
 470  * been relaxed to allow language codes of two to eight characters and
 471  * country (region) codes of two to three characters, and in
 472  * particular, three-letter language codes and three-digit region
 473  * codes as specified in the IANA Language Subtag Registry.  For
 474  * compatibility, the implementation still does not impose a length
 475  * constraint.
 476  *
 477  * @see Builder
 478  * @see ResourceBundle
 479  * @see java.text.Format
 480  * @see java.text.NumberFormat
 481  * @see java.text.Collator
 482  * @author Mark Davis
 483  * @since 1.1
 484  */
 485 public final class Locale implements Cloneable, Serializable {
 486 


 487     /** Useful constant for language.
 488      */
<span class="line-modified"> 489     public static final Locale ENGLISH;</span>
 490 
 491     /** Useful constant for language.
 492      */
<span class="line-modified"> 493     public static final Locale FRENCH;</span>
 494 
 495     /** Useful constant for language.
 496      */
<span class="line-modified"> 497     public static final Locale GERMAN;</span>
 498 
 499     /** Useful constant for language.
 500      */
<span class="line-modified"> 501     public static final Locale ITALIAN;</span>
 502 
 503     /** Useful constant for language.
 504      */
<span class="line-modified"> 505     public static final Locale JAPANESE;</span>
 506 
 507     /** Useful constant for language.
 508      */
<span class="line-modified"> 509     public static final Locale KOREAN;</span>
 510 
 511     /** Useful constant for language.
 512      */
<span class="line-modified"> 513     public static final Locale CHINESE;</span>
 514 
 515     /** Useful constant for language.
 516      */
<span class="line-modified"> 517     public static final Locale SIMPLIFIED_CHINESE;</span>
 518 
 519     /** Useful constant for language.
 520      */
<span class="line-modified"> 521     public static final Locale TRADITIONAL_CHINESE;</span>
 522 
 523     /** Useful constant for country.
 524      */
<span class="line-modified"> 525     public static final Locale FRANCE;</span>
 526 
 527     /** Useful constant for country.
 528      */
<span class="line-modified"> 529     public static final Locale GERMANY;</span>
 530 
 531     /** Useful constant for country.
 532      */
<span class="line-modified"> 533     public static final Locale ITALY;</span>
 534 
 535     /** Useful constant for country.
 536      */
<span class="line-modified"> 537     public static final Locale JAPAN;</span>
 538 
 539     /** Useful constant for country.
 540      */
<span class="line-modified"> 541     public static final Locale KOREA;</span>
 542 
 543     /** Useful constant for country.
 544      */
<span class="line-modified"> 545     public static final Locale UK;</span>
 546 
 547     /** Useful constant for country.
 548      */
<span class="line-modified"> 549     public static final Locale US;</span>
 550 
 551     /** Useful constant for country.
 552      */
<span class="line-modified"> 553     public static final Locale CANADA;</span>
 554 
 555     /** Useful constant for country.
 556      */
<span class="line-modified"> 557     public static final Locale CANADA_FRENCH;</span>
<span class="line-added"> 558 </span>
<span class="line-added"> 559     /**</span>
<span class="line-added"> 560      * Useful constant for the root locale.  The root locale is the locale whose</span>
<span class="line-added"> 561      * language, country, and variant are empty (&quot;&quot;) strings.  This is regarded</span>
<span class="line-added"> 562      * as the base locale of all locales, and is used as the language/country</span>
<span class="line-added"> 563      * neutral locale for the locale sensitive operations.</span>
<span class="line-added"> 564      *</span>
<span class="line-added"> 565      * @since 1.6</span>
<span class="line-added"> 566      */</span>
<span class="line-added"> 567     public static final Locale ROOT;</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569     private static final Map&lt;BaseLocale, Locale&gt; CONSTANT_LOCALES = new HashMap&lt;&gt;();</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571     static {</span>
<span class="line-added"> 572         ENGLISH = createConstant(BaseLocale.ENGLISH);</span>
<span class="line-added"> 573         FRENCH = createConstant(BaseLocale.FRENCH);</span>
<span class="line-added"> 574         GERMAN = createConstant(BaseLocale.GERMAN);</span>
<span class="line-added"> 575         ITALIAN = createConstant(BaseLocale.ITALIAN);</span>
<span class="line-added"> 576         JAPANESE = createConstant(BaseLocale.JAPANESE);</span>
<span class="line-added"> 577         KOREAN = createConstant(BaseLocale.KOREAN);</span>
<span class="line-added"> 578         CHINESE = createConstant(BaseLocale.CHINESE);</span>
<span class="line-added"> 579         SIMPLIFIED_CHINESE = createConstant(BaseLocale.SIMPLIFIED_CHINESE);</span>
<span class="line-added"> 580         TRADITIONAL_CHINESE = createConstant(BaseLocale.TRADITIONAL_CHINESE);</span>
<span class="line-added"> 581         FRANCE = createConstant(BaseLocale.FRANCE);</span>
<span class="line-added"> 582         GERMANY = createConstant(BaseLocale.GERMANY);</span>
<span class="line-added"> 583         ITALY = createConstant(BaseLocale.ITALY);</span>
<span class="line-added"> 584         JAPAN = createConstant(BaseLocale.JAPAN);</span>
<span class="line-added"> 585         KOREA = createConstant(BaseLocale.KOREA);</span>
<span class="line-added"> 586         UK = createConstant(BaseLocale.UK);</span>
<span class="line-added"> 587         US = createConstant(BaseLocale.US);</span>
<span class="line-added"> 588         CANADA = createConstant(BaseLocale.CANADA);</span>
<span class="line-added"> 589         CANADA_FRENCH = createConstant(BaseLocale.CANADA_FRENCH);</span>
<span class="line-added"> 590         ROOT = createConstant(BaseLocale.ROOT);</span>
<span class="line-added"> 591     }</span>
 592 
 593     /** Useful constant for country.
 594      */
<span class="line-modified"> 595     public static final Locale CHINA = SIMPLIFIED_CHINESE;</span>
 596 
 597     /** Useful constant for country.
 598      */
<span class="line-modified"> 599     public static final Locale PRC = SIMPLIFIED_CHINESE;</span>
 600 
 601     /** Useful constant for country.
 602      */
<span class="line-modified"> 603     public static final Locale TAIWAN = TRADITIONAL_CHINESE;</span>
 604 
 605     /**
<span class="line-modified"> 606      * This method must be called only for creating the Locale.*</span>
<span class="line-modified"> 607      * constants due to making shortcuts.</span>




 608      */
<span class="line-modified"> 609     private static Locale createConstant(byte baseType) {</span>
<span class="line-added"> 610         BaseLocale base = BaseLocale.constantBaseLocales[baseType];</span>
<span class="line-added"> 611         Locale locale = new Locale(base, null);</span>
<span class="line-added"> 612         CONSTANT_LOCALES.put(base, locale);</span>
<span class="line-added"> 613         return locale;</span>
<span class="line-added"> 614     }</span>
 615 
 616     /**
 617      * The key for the private use extension (&#39;x&#39;).
 618      *
 619      * @see #getExtension(char)
 620      * @see Builder#setExtension(char, String)
 621      * @since 1.7
 622      */
 623     public static final char PRIVATE_USE_EXTENSION = &#39;x&#39;;
 624 
 625     /**
 626      * The key for Unicode locale extension (&#39;u&#39;).
 627      *
 628      * @see #getExtension(char)
 629      * @see Builder#setExtension(char, String)
 630      * @since 1.7
 631      */
 632     public static final char UNICODE_LOCALE_EXTENSION = &#39;u&#39;;
 633 
 634     /** serialization ID
 635      */
<span class="line-added"> 636     @java.io.Serial</span>
 637     static final long serialVersionUID = 9149081749638150636L;
 638 
 639     /**
 640      * Enum for specifying the type defined in ISO 3166. This enum is used to
 641      * retrieve the two-letter ISO3166-1 alpha-2, three-letter ISO3166-1
 642      * alpha-3, four-letter ISO3166-3 country codes.
 643      *
 644      * @see #getISOCountries(Locale.IsoCountryCode)
 645      * @since 9
 646      */
 647     public static enum IsoCountryCode {
 648         /**
 649          * PART1_ALPHA2 is used to represent the ISO3166-1 alpha-2 two letter
 650          * country codes.
 651          */
 652         PART1_ALPHA2 {
 653             @Override
 654             Set&lt;String&gt; createCountryCodeSet() {
 655                 return Set.of(Locale.getISOCountries());
 656             }
</pre>
<hr />
<pre>
 717     }
 718 
 719     /**
 720      * Construct a locale from language, country and variant.
 721      * This constructor normalizes the language value to lowercase and
 722      * the country value to uppercase.
 723      * &lt;p&gt;
 724      * &lt;b&gt;Note:&lt;/b&gt;
 725      * &lt;ul&gt;
 726      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 727      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 728      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 729      * API on Locale will return only the OLD codes.
 730      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 731      * any syntactic checks on the input.
 732      * &lt;li&gt;The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially,
 733      * see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.
 734      * &lt;/ul&gt;
 735      *
 736      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified"> 737      * up to 8 characters in length.  See the {@code Locale} class description about</span>
 738      * valid language values.
 739      * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified"> 740      * See the {@code Locale} class description about valid country values.</span>
<span class="line-modified"> 741      * @param variant Any arbitrary value used to indicate a variation of a {@code Locale}.</span>
<span class="line-modified"> 742      * See the {@code Locale} class description for the details.</span>
<span class="line-modified"> 743      * @throws    NullPointerException thrown if any argument is null.</span>
 744      */
 745     public Locale(String language, String country, String variant) {
<span class="line-modified"> 746         if (language == null || country == null || variant == null) {</span>
 747             throw new NullPointerException();
 748         }
 749         baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);
 750         localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);
 751     }
 752 
 753     /**
 754      * Construct a locale from language and country.
 755      * This constructor normalizes the language value to lowercase and
 756      * the country value to uppercase.
 757      * &lt;p&gt;
 758      * &lt;b&gt;Note:&lt;/b&gt;
 759      * &lt;ul&gt;
 760      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 761      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 762      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 763      * API on Locale will return only the OLD codes.
 764      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 765      * any syntactic checks on the input.
 766      * &lt;/ul&gt;
 767      *
 768      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified"> 769      * up to 8 characters in length.  See the {@code Locale} class description about</span>
 770      * valid language values.
 771      * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified"> 772      * See the {@code Locale} class description about valid country values.</span>
<span class="line-modified"> 773      * @throws    NullPointerException thrown if either argument is null.</span>
 774      */
 775     public Locale(String language, String country) {
 776         this(language, country, &quot;&quot;);
 777     }
 778 
 779     /**
 780      * Construct a locale from a language code.
 781      * This constructor normalizes the language value to lowercase.
 782      * &lt;p&gt;
 783      * &lt;b&gt;Note:&lt;/b&gt;
 784      * &lt;ul&gt;
 785      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 786      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 787      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 788      * API on Locale will return only the OLD codes.
 789      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 790      * any syntactic checks on the input.
 791      * &lt;/ul&gt;
 792      *
 793      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified"> 794      * up to 8 characters in length.  See the {@code Locale} class description about</span>
 795      * valid language values.
<span class="line-modified"> 796      * @throws    NullPointerException thrown if argument is null.</span>
 797      * @since 1.4
 798      */
 799     public Locale(String language) {
 800         this(language, &quot;&quot;, &quot;&quot;);
 801     }
 802 
 803     /**
<span class="line-modified"> 804      * Returns a {@code Locale} constructed from the given</span>
<span class="line-modified"> 805      * {@code language}, {@code country} and</span>
<span class="line-modified"> 806      * {@code variant}. If the same {@code Locale} instance</span>









 807      * is available in the cache, then that instance is
<span class="line-modified"> 808      * returned. Otherwise, a new {@code Locale} instance is</span>
 809      * created and cached.
 810      *
 811      * @param language lowercase 2 to 8 language code.
 812      * @param country uppercase two-letter ISO-3166 code and numeric-3 UN M.49 area code.
 813      * @param variant vendor and browser specific code. See class description.
<span class="line-modified"> 814      * @return the {@code Locale} instance requested</span>
<span class="line-modified"> 815      * @throws    NullPointerException if any argument is null.</span>
 816      */
 817     static Locale getInstance(String language, String country, String variant) {
 818         return getInstance(language, &quot;&quot;, country, variant, null);
 819     }
 820 
 821     static Locale getInstance(String language, String script, String country,
 822                                       String variant, LocaleExtensions extensions) {
 823         if (language== null || script == null || country == null || variant == null) {
 824             throw new NullPointerException();
 825         }
 826 
 827         if (extensions == null) {
 828             extensions = getCompatibilityExtensions(language, script, country, variant);
 829         }
 830 
<span class="line-modified"> 831         BaseLocale baseloc = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);</span>
 832         return getInstance(baseloc, extensions);
 833     }
 834 
 835     static Locale getInstance(BaseLocale baseloc, LocaleExtensions extensions) {
 836         if (extensions == null) {
<span class="line-modified"> 837             Locale locale = CONSTANT_LOCALES.get(baseloc);</span>
<span class="line-added"> 838             if (locale != null) {</span>
<span class="line-added"> 839                 return locale;</span>
<span class="line-added"> 840             }</span>
<span class="line-added"> 841             return Cache.LOCALECACHE.get(baseloc);</span>
 842         } else {
 843             LocaleKey key = new LocaleKey(baseloc, extensions);
<span class="line-modified"> 844             return Cache.LOCALECACHE.get(key);</span>
 845         }
 846     }
 847 
 848     private static class Cache extends LocaleObjectCache&lt;Object, Locale&gt; {
<span class="line-added"> 849 </span>
<span class="line-added"> 850         private static final Cache LOCALECACHE = new Cache();</span>
<span class="line-added"> 851 </span>
 852         private Cache() {
 853         }
 854 
 855         @Override
 856         protected Locale createObject(Object key) {
 857             if (key instanceof BaseLocale) {
 858                 return new Locale((BaseLocale)key, null);
 859             } else {
 860                 LocaleKey lk = (LocaleKey)key;
 861                 return new Locale(lk.base, lk.exts);
 862             }
 863         }
 864     }
 865 
 866     private static final class LocaleKey {
 867         private final BaseLocale base;
 868         private final LocaleExtensions exts;
 869         private final int hash;
 870 
 871         private LocaleKey(BaseLocale baseLocale, LocaleExtensions extensions) {
</pre>
<hr />
<pre>
 913      * methods if no locale is explicitly specified.
 914      * It can be changed using the
 915      * {@link #setDefault(java.util.Locale) setDefault} method.
 916      *
 917      * @return the default locale for this instance of the Java Virtual Machine
 918      */
 919     public static Locale getDefault() {
 920         // do not synchronize this method - see 4071298
 921         return defaultLocale;
 922     }
 923 
 924     /**
 925      * Gets the current value of the default locale for the specified Category
 926      * for this instance of the Java Virtual Machine.
 927      * &lt;p&gt;
 928      * The Java Virtual Machine sets the default locale during startup based
 929      * on the host environment. It is used by many locale-sensitive methods
 930      * if no locale is explicitly specified. It can be changed using the
 931      * setDefault(Locale.Category, Locale) method.
 932      *
<span class="line-modified"> 933      * @param category the specified category to get the default locale</span>
 934      * @throws NullPointerException if category is null
 935      * @return the default locale for the specified Category for this instance
 936      *     of the Java Virtual Machine
 937      * @see #setDefault(Locale.Category, Locale)
 938      * @since 1.7
 939      */
 940     public static Locale getDefault(Locale.Category category) {
 941         // do not synchronize this method - see 4071298
 942         switch (category) {
 943         case DISPLAY:
 944             if (defaultDisplayLocale == null) {
 945                 synchronized(Locale.class) {
 946                     if (defaultDisplayLocale == null) {
 947                         defaultDisplayLocale = initDefault(category);
 948                     }
 949                 }
 950             }
 951             return defaultDisplayLocale;
 952         case FORMAT:
 953             if (defaultFormatLocale == null) {
</pre>
<hr />
<pre>
 992                     .orElse(null));
 993     }
 994 
 995     private static Locale initDefault(Locale.Category category) {
 996         Properties props = GetPropertyAction.privilegedGetProperties();
 997 
 998         return getInstance(
 999             props.getProperty(category.languageKey,
1000                     defaultLocale.getLanguage()),
1001             props.getProperty(category.scriptKey,
1002                     defaultLocale.getScript()),
1003             props.getProperty(category.countryKey,
1004                     defaultLocale.getCountry()),
1005             props.getProperty(category.variantKey,
1006                     defaultLocale.getVariant()),
1007             getDefaultExtensions(props.getProperty(category.extensionsKey, &quot;&quot;))
1008                 .orElse(defaultLocale.getLocaleExtensions()));
1009     }
1010 
1011     private static Optional&lt;LocaleExtensions&gt; getDefaultExtensions(String extensionsProp) {
<span class="line-modified">1012         if (LocaleUtils.isEmpty(extensionsProp)) {</span>
<span class="line-added">1013             return Optional.empty();</span>
<span class="line-added">1014         }</span>
1015 
<span class="line-added">1016         LocaleExtensions exts = null;</span>
1017         try {
1018             exts = new InternalLocaleBuilder()
1019                 .setExtensions(extensionsProp)
1020                 .getLocaleExtensions();
1021         } catch (LocaleSyntaxException e) {
1022             // just ignore this incorrect property
1023         }
1024 
1025         return Optional.ofNullable(exts);
1026     }
1027 
1028     /**
1029      * Sets the default locale for this instance of the Java Virtual Machine.
1030      * This does not affect the host locale.
1031      * &lt;p&gt;
<span class="line-modified">1032      * If there is a security manager, its {@code checkPermission}</span>
<span class="line-modified">1033      * method is called with a {@code PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)}</span>
1034      * permission before the default locale is changed.
1035      * &lt;p&gt;
1036      * The Java Virtual Machine sets the default locale during startup
1037      * based on the host environment. It is used by many locale-sensitive
1038      * methods if no locale is explicitly specified.
1039      * &lt;p&gt;
1040      * Since changing the default locale may affect many different areas
1041      * of functionality, this method should only be used if the caller
1042      * is prepared to reinitialize locale-sensitive code running
1043      * within the same Java Virtual Machine.
1044      * &lt;p&gt;
1045      * By setting the default locale with this method, all of the default
1046      * locales for each Category are also set to the specified default locale.
1047      *
1048      * @throws SecurityException
1049      *        if a security manager exists and its
<span class="line-modified">1050      *        {@code checkPermission} method doesn&#39;t allow the operation.</span>
<span class="line-modified">1051      * @throws NullPointerException if {@code newLocale} is null</span>
1052      * @param newLocale the new default locale
1053      * @see SecurityManager#checkPermission
1054      * @see java.util.PropertyPermission
1055      */
1056     public static synchronized void setDefault(Locale newLocale) {
1057         setDefault(Category.DISPLAY, newLocale);
1058         setDefault(Category.FORMAT, newLocale);
1059         defaultLocale = newLocale;
1060     }
1061 
1062     /**
1063      * Sets the default locale for the specified Category for this instance
1064      * of the Java Virtual Machine. This does not affect the host locale.
1065      * &lt;p&gt;
1066      * If there is a security manager, its checkPermission method is called
1067      * with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before
1068      * the default locale is changed.
1069      * &lt;p&gt;
1070      * The Java Virtual Machine sets the default locale during startup based
1071      * on the host environment. It is used by many locale-sensitive methods
1072      * if no locale is explicitly specified.
1073      * &lt;p&gt;
1074      * Since changing the default locale may affect many different areas of
1075      * functionality, this method should only be used if the caller is
1076      * prepared to reinitialize locale-sensitive code running within the
1077      * same Java Virtual Machine.
1078      *
<span class="line-modified">1079      * @param category the specified category to set the default locale</span>
<span class="line-modified">1080      * @param newLocale the new default locale</span>
1081      * @throws SecurityException if a security manager exists and its
1082      *     checkPermission method doesn&#39;t allow the operation.
1083      * @throws NullPointerException if category and/or newLocale is null
1084      * @see SecurityManager#checkPermission(java.security.Permission)
1085      * @see PropertyPermission
1086      * @see #getDefault(Locale.Category)
1087      * @since 1.7
1088      */
1089     public static synchronized void setDefault(Locale.Category category,
1090         Locale newLocale) {
1091         if (category == null)
1092             throw new NullPointerException(&quot;Category cannot be NULL&quot;);
1093         if (newLocale == null)
1094             throw new NullPointerException(&quot;Can&#39;t set default locale to NULL&quot;);
1095 
1096         SecurityManager sm = System.getSecurityManager();
1097         if (sm != null) sm.checkPermission(new PropertyPermission
1098                         (&quot;user.language&quot;, &quot;write&quot;));
1099         switch (category) {
1100         case DISPLAY:
1101             defaultDisplayLocale = newLocale;
1102             break;
1103         case FORMAT:
1104             defaultFormatLocale = newLocale;
1105             break;
1106         default:
1107             assert false: &quot;Unknown Category&quot;;
1108         }
1109     }
1110 
1111     /**
1112      * Returns an array of all installed locales.
1113      * The returned array represents the union of locales supported
1114      * by the Java runtime environment and by installed
1115      * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
<span class="line-modified">1116      * implementations.  It must contain at least a {@code Locale}</span>
1117      * instance equal to {@link java.util.Locale#US Locale.US}.
1118      *
1119      * @return An array of installed locales.
1120      */
1121     public static Locale[] getAvailableLocales() {
1122         return LocaleServiceProviderPool.getAllAvailableLocales();
1123     }
1124 
1125     /**
1126      * Returns a list of all 2-letter country codes defined in ISO 3166.
1127      * Can be used to create Locales.
1128      * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
1129      * with {@code type}  {@link IsoCountryCode#PART1_ALPHA2}.
1130      * &lt;p&gt;
<span class="line-modified">1131      * &lt;b&gt;Note:&lt;/b&gt; The {@code Locale} class also supports other codes for</span>
1132      * country (region), such as 3-letter numeric UN M.49 area codes.
1133      * Therefore, the list returned by this method does not contain ALL valid
1134      * codes that can be used to create Locales.
1135      * &lt;p&gt;
1136      * Note that this method does not return obsolete 2-letter country codes.
1137      * ISO3166-3 codes which designate country codes for those obsolete codes,
1138      * can be retrieved from {@link #getISOCountries(Locale.IsoCountryCode type)} with
1139      * {@code type}  {@link IsoCountryCode#PART3}.
1140      * @return An array of ISO 3166 two-letter country codes.
1141      */
1142     public static String[] getISOCountries() {
1143         if (isoCountries == null) {
1144             isoCountries = getISO2Table(LocaleISOData.isoCountryTable);
1145         }
1146         String[] result = new String[isoCountries.length];
1147         System.arraycopy(isoCountries, 0, result, 0, isoCountries.length);
1148         return result;
1149     }
1150 
1151     /**
</pre>
<hr />
<pre>
1154      * @param type {@link Locale.IsoCountryCode} specified ISO code type.
1155      * @see java.util.Locale.IsoCountryCode
1156      * @throws NullPointerException if type is null
1157      * @return a {@code Set} of ISO country codes for the specified type.
1158      * @since 9
1159      */
1160     public static Set&lt;String&gt; getISOCountries(IsoCountryCode type) {
1161         Objects.requireNonNull(type);
1162         return IsoCountryCode.retrieveISOCountryCodes(type);
1163     }
1164 
1165     /**
1166      * Returns a list of all 2-letter language codes defined in ISO 639.
1167      * Can be used to create Locales.
1168      * &lt;p&gt;
1169      * &lt;b&gt;Note:&lt;/b&gt;
1170      * &lt;ul&gt;
1171      * &lt;li&gt;ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
1172      * The list this function returns includes both the new and the old codes for the
1173      * languages whose codes have changed.
<span class="line-modified">1174      * &lt;li&gt;The {@code Locale} class also supports language codes up to</span>
1175      * 8 characters in length.  Therefore, the list returned by this method does
1176      * not contain ALL valid codes that can be used to create Locales.
1177      * &lt;/ul&gt;
1178      *
1179      * @return An array of ISO 639 two-letter language codes.
1180      */
1181     public static String[] getISOLanguages() {
1182         if (isoLanguages == null) {
1183             isoLanguages = getISO2Table(LocaleISOData.isoLanguageTable);
1184         }
1185         String[] result = new String[isoLanguages.length];
1186         System.arraycopy(isoLanguages, 0, result, 0, isoLanguages.length);
1187         return result;
1188     }
1189 
1190     private static String[] getISO2Table(String table) {
1191         int len = table.length() / 5;
1192         String[] isoTable = new String[len];
1193         for (int i = 0, j = 0; i &lt; len; i++, j += 5) {
1194             isoTable[i] = table.substring(j, j + 2);
</pre>
<hr />
<pre>
1266         return localeExtensions != null;
1267     }
1268 
1269     /**
1270      * Returns a copy of this {@code Locale} with no &lt;a href=&quot;#def_extensions&quot;&gt;
1271      * extensions&lt;/a&gt;. If this {@code Locale} has no extensions, this {@code Locale}
1272      * is returned.
1273      *
1274      * @return a copy of this {@code Locale} with no extensions, or {@code this}
1275      *         if {@code this} has no extensions
1276      * @since 1.8
1277      */
1278     public Locale stripExtensions() {
1279         return hasExtensions() ? Locale.getInstance(baseLocale, null) : this;
1280     }
1281 
1282     /**
1283      * Returns the extension (or private use) value associated with
1284      * the specified key, or null if there is no extension
1285      * associated with the key. To be well-formed, the key must be one
<span class="line-modified">1286      * of {@code [0-9A-Za-z]}. Keys are case-insensitive, so</span>
1287      * for example &#39;z&#39; and &#39;Z&#39; represent the same extension.
1288      *
1289      * @param key the extension key
1290      * @return The extension, or null if this locale defines no
1291      * extension for the specified key.
1292      * @throws IllegalArgumentException if key is not well-formed
1293      * @see #PRIVATE_USE_EXTENSION
1294      * @see #UNICODE_LOCALE_EXTENSION
1295      * @since 1.7
1296      */
1297     public String getExtension(char key) {
1298         if (!LocaleExtensions.isValidKey(key)) {
1299             throw new IllegalArgumentException(&quot;Ill-formed extension key: &quot; + key);
1300         }
1301         return hasExtensions() ? localeExtensions.getExtensionValue(key) : null;
1302     }
1303 
1304     /**
1305      * Returns the set of extension keys associated with this locale, or the
1306      * empty set if it has no extensions. The returned set is unmodifiable.
</pre>
<hr />
<pre>
1326      * @since 1.7
1327      */
1328     public Set&lt;String&gt; getUnicodeLocaleAttributes() {
1329         if (!hasExtensions()) {
1330             return Collections.emptySet();
1331         }
1332         return localeExtensions.getUnicodeLocaleAttributes();
1333     }
1334 
1335     /**
1336      * Returns the Unicode locale type associated with the specified Unicode locale key
1337      * for this locale. Returns the empty string for keys that are defined with no type.
1338      * Returns null if the key is not defined. Keys are case-insensitive. The key must
1339      * be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is
1340      * thrown.
1341      *
1342      * @param key the Unicode locale key
1343      * @return The Unicode locale type associated with the key, or null if the
1344      * locale does not define the key.
1345      * @throws IllegalArgumentException if the key is not well-formed
<span class="line-modified">1346      * @throws NullPointerException if {@code key} is null</span>
1347      * @since 1.7
1348      */
1349     public String getUnicodeLocaleType(String key) {
1350         if (!isUnicodeExtensionKey(key)) {
1351             throw new IllegalArgumentException(&quot;Ill-formed Unicode locale key: &quot; + key);
1352         }
1353         return hasExtensions() ? localeExtensions.getUnicodeLocaleType(key) : null;
1354     }
1355 
1356     /**
1357      * Returns the set of Unicode locale keys defined by this locale, or the empty set if
1358      * this locale has none.  The returned set is immutable.  Keys are all lower case.
1359      *
1360      * @return The set of Unicode locale keys, or the empty set if this locale has
1361      * no Unicode locale keywords.
1362      * @since 1.7
1363      */
1364     public Set&lt;String&gt; getUnicodeLocaleKeys() {
1365         if (localeExtensions == null) {
1366             return Collections.emptySet();
</pre>
<hr />
<pre>
1371     /**
1372      * Package locale method returning the Locale&#39;s BaseLocale,
1373      * used by ResourceBundle
1374      * @return base locale of this Locale
1375      */
1376     BaseLocale getBaseLocale() {
1377         return baseLocale;
1378     }
1379 
1380     /**
1381      * Package private method returning the Locale&#39;s LocaleExtensions,
1382      * used by ResourceBundle.
1383      * @return locale extensions of this Locale,
1384      *         or {@code null} if no extensions are defined
1385      */
1386      LocaleExtensions getLocaleExtensions() {
1387          return localeExtensions;
1388      }
1389 
1390     /**
<span class="line-modified">1391      * Returns a string representation of this {@code Locale}</span>
1392      * object, consisting of language, country, variant, script,
1393      * and extensions as below:
1394      * &lt;blockquote&gt;
1395      * language + &quot;_&quot; + country + &quot;_&quot; + (variant + &quot;_#&quot; | &quot;#&quot;) + script + &quot;_&quot; + extensions
1396      * &lt;/blockquote&gt;
1397      *
1398      * Language is always lower case, country is always upper case, script is always title
1399      * case, and extensions are always lower case.  Extensions and private use subtags
1400      * will be in canonical order as explained in {@link #toLanguageTag}.
1401      *
1402      * &lt;p&gt;When the locale has neither script nor extensions, the result is the same as in
1403      * Java 6 and prior.
1404      *
1405      * &lt;p&gt;If both the language and country fields are missing, this function will return
1406      * the empty string, even if the variant, script, or extensions field is present (you
1407      * can&#39;t have a locale with just a variant, the variant must accompany a well-formed
1408      * language or country code).
1409      *
1410      * &lt;p&gt;If script or extensions are present and variant is missing, no underscore is
1411      * added before the &quot;#&quot;.
1412      *
1413      * &lt;p&gt;This behavior is designed to support debugging and to be compatible with
<span class="line-modified">1414      * previous uses of {@code toString} that expected language, country, and variant</span>
1415      * fields only.  To represent a Locale as a String for interchange purposes, use
1416      * {@link #toLanguageTag}.
1417      *
1418      * &lt;p&gt;Examples: &lt;ul&gt;
1419      * &lt;li&gt;{@code en}&lt;/li&gt;
1420      * &lt;li&gt;{@code de_DE}&lt;/li&gt;
1421      * &lt;li&gt;{@code _GB}&lt;/li&gt;
1422      * &lt;li&gt;{@code en_US_WIN}&lt;/li&gt;
1423      * &lt;li&gt;{@code de__POSIX}&lt;/li&gt;
1424      * &lt;li&gt;{@code zh_CN_#Hans}&lt;/li&gt;
1425      * &lt;li&gt;{@code zh_TW_#Hant_x-java}&lt;/li&gt;
1426      * &lt;li&gt;{@code th_TH_TH_#u-nu-thai}&lt;/li&gt;&lt;/ul&gt;
1427      *
1428      * @return A string representation of the Locale, for debugging.
1429      * @see #getDisplayName
1430      * @see #toLanguageTag
1431      */
1432     @Override
1433     public final String toString() {
1434         boolean l = !baseLocale.getLanguage().isEmpty();
</pre>
<hr />
<pre>
1450         if (s &amp;&amp; (l || r)) {
1451             result.append(&quot;_#&quot;)
1452                 .append(baseLocale.getScript());
1453         }
1454 
1455         if (e &amp;&amp; (l || r)) {
1456             result.append(&#39;_&#39;);
1457             if (!s) {
1458                 result.append(&#39;#&#39;);
1459             }
1460             result.append(localeExtensions.getID());
1461         }
1462 
1463         return result.toString();
1464     }
1465 
1466     /**
1467      * Returns a well-formed IETF BCP 47 language tag representing
1468      * this locale.
1469      *
<span class="line-modified">1470      * &lt;p&gt;If this {@code Locale} has a language, country, or</span>
1471      * variant that does not satisfy the IETF BCP 47 language tag
1472      * syntax requirements, this method handles these fields as
1473      * described below:
1474      *
1475      * &lt;p&gt;&lt;b&gt;Language:&lt;/b&gt; If language is empty, or not &lt;a
1476      * href=&quot;#def_language&quot; &gt;well-formed&lt;/a&gt; (for example &quot;a&quot; or
1477      * &quot;e2&quot;), it will be emitted as &quot;und&quot; (Undetermined).
1478      *
1479      * &lt;p&gt;&lt;b&gt;Country:&lt;/b&gt; If country is not &lt;a
1480      * href=&quot;#def_region&quot;&gt;well-formed&lt;/a&gt; (for example &quot;12&quot; or &quot;USA&quot;),
1481      * it will be omitted.
1482      *
1483      * &lt;p&gt;&lt;b&gt;Variant:&lt;/b&gt; If variant &lt;b&gt;is&lt;/b&gt; &lt;a
1484      * href=&quot;#def_variant&quot;&gt;well-formed&lt;/a&gt;, each sub-segment
1485      * (delimited by &#39;-&#39; or &#39;_&#39;) is emitted as a subtag.  Otherwise:
1486      * &lt;ul&gt;
1487      *
1488      * &lt;li&gt;if all sub-segments match &lt;code&gt;[0-9a-zA-Z]{1,8}&lt;/code&gt;
1489      * (for example &quot;WIN&quot; or &quot;Oracle_JDK_Standard_Edition&quot;), the first
1490      * ill-formed sub-segment and all following will be appended to
</pre>
<hr />
<pre>
1686      * converted as follows:
1687      *
1688      * &lt;table class=&quot;striped&quot;&gt;
1689      * &lt;caption style=&quot;display:none&quot;&gt;Grandfathered tags with no modern replacement&lt;/caption&gt;
1690      * &lt;thead style=&quot;text-align:center&quot;&gt;
1691      * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;grandfathered tag&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;converts to&lt;/th&gt;&lt;/tr&gt;
1692      * &lt;/thead&gt;
1693      * &lt;tbody style=&quot;text-align:center&quot;&gt;
1694      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;cel-gaulish&lt;/th&gt;&lt;td&gt;xtg-x-cel-gaulish&lt;/td&gt;&lt;/tr&gt;
1695      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;en-GB-oed&lt;/th&gt;&lt;td&gt;en-GB-x-oed&lt;/td&gt;&lt;/tr&gt;
1696      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-default&lt;/th&gt;&lt;td&gt;en-x-i-default&lt;/td&gt;&lt;/tr&gt;
1697      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-enochian&lt;/th&gt;&lt;td&gt;und-x-i-enochian&lt;/td&gt;&lt;/tr&gt;
1698      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-mingo&lt;/th&gt;&lt;td&gt;see-x-i-mingo&lt;/td&gt;&lt;/tr&gt;
1699      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-min&lt;/th&gt;&lt;td&gt;nan-x-zh-min&lt;/td&gt;&lt;/tr&gt;
1700      * &lt;/tbody&gt;
1701      * &lt;/table&gt;
1702      *
1703      * &lt;p&gt;For a list of all grandfathered tags, see the
1704      * IANA Language Subtag Registry (search for &quot;Type: grandfathered&quot;).
1705      *
<span class="line-modified">1706      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: there is no guarantee that {@code toLanguageTag}</span>
<span class="line-modified">1707      * and {@code forLanguageTag} will round-trip.</span>
1708      *
1709      * @param languageTag the language tag
1710      * @return The locale that best represents the language tag.
<span class="line-modified">1711      * @throws NullPointerException if {@code languageTag} is {@code null}</span>
1712      * @see #toLanguageTag()
1713      * @see java.util.Locale.Builder#setLanguageTag(String)
1714      * @since 1.7
1715      */
1716     public static Locale forLanguageTag(String languageTag) {
1717         LanguageTag tag = LanguageTag.parse(languageTag, null);
1718         InternalLocaleBuilder bldr = new InternalLocaleBuilder();
1719         bldr.setLanguageTag(tag);
1720         BaseLocale base = bldr.getBaseLocale();
1721         LocaleExtensions exts = bldr.getLocaleExtensions();
1722         if (exts == null &amp;&amp; !base.getVariant().isEmpty()) {
1723             exts = getCompatibilityExtensions(base.getLanguage(), base.getScript(),
1724                                               base.getRegion(), base.getVariant());
1725         }
1726         return getInstance(base, exts);
1727     }
1728 
1729     /**
1730      * Returns a three-letter abbreviation of this locale&#39;s language.
1731      * If the language matches an ISO 639-1 two-letter code, the
1732      * corresponding ISO 639-2/T three-letter lowercase code is
1733      * returned.  The ISO 639-2 language codes can be found on-line,
1734      * see &quot;Codes for the Representation of Names of Languages Part 2:
1735      * Alpha-3 Code&quot;.  If the locale specifies a three-letter
1736      * language, the language is returned as is.  If the locale does
1737      * not specify a language the empty string is returned.
1738      *
1739      * @return A three-letter abbreviation of this locale&#39;s language.
<span class="line-modified">1740      * @throws    MissingResourceException Throws MissingResourceException if</span>
1741      * three-letter language abbreviation is not available for this locale.
1742      */
1743     public String getISO3Language() throws MissingResourceException {
1744         String lang = baseLocale.getLanguage();
1745         if (lang.length() == 3) {
1746             return lang;
1747         }
1748 
1749         String language3 = getISO3Code(lang, LocaleISOData.isoLanguageTable);
1750         if (language3 == null) {
1751             throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter language code for &quot;
1752                     + lang, &quot;FormatData_&quot; + toString(), &quot;ShortLanguage&quot;);
1753         }
1754         return language3;
1755     }
1756 
1757     /**
1758      * Returns a three-letter abbreviation for this locale&#39;s country.
1759      * If the country matches an ISO 3166-1 alpha-2 code, the
1760      * corresponding ISO 3166-1 alpha-3 uppercase code is returned.
1761      * If the locale doesn&#39;t specify a country, this will be the empty
1762      * string.
1763      *
1764      * &lt;p&gt;The ISO 3166-1 codes can be found on-line.
1765      *
1766      * @return A three-letter abbreviation of this locale&#39;s country.
<span class="line-modified">1767      * @throws    MissingResourceException Throws MissingResourceException if the</span>
1768      * three-letter country abbreviation is not available for this locale.
1769      */
1770     public String getISO3Country() throws MissingResourceException {
1771         String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);
1772         if (country3 == null) {
1773             throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter country code for &quot;
1774                     + baseLocale.getRegion(), &quot;FormatData_&quot; + toString(), &quot;ShortCountry&quot;);
1775         }
1776         return country3;
1777     }
1778 
1779     private static String getISO3Code(String iso2Code, String table) {
1780         int codeLength = iso2Code.length();
1781         if (codeLength == 0) {
1782             return &quot;&quot;;
1783         }
1784 
1785         int tableLength = table.length();
1786         int index = tableLength;
1787         if (codeLength == 2) {
</pre>
<hr />
<pre>
1817      */
1818     public final String getDisplayLanguage() {
1819         return getDisplayLanguage(getDefault(Category.DISPLAY));
1820     }
1821 
1822     /**
1823      * Returns a name for the locale&#39;s language that is appropriate for display to the
1824      * user.
1825      * If possible, the name returned will be localized according to inLocale.
1826      * For example, if the locale is fr_FR and inLocale
1827      * is en_US, getDisplayLanguage() will return &quot;French&quot;; if the locale is en_US and
1828      * inLocale is fr_FR, getDisplayLanguage() will return &quot;anglais&quot;.
1829      * If the name returned cannot be localized according to inLocale,
1830      * (say, we don&#39;t have a Japanese name for Croatian),
1831      * this function falls back on the English name, and finally
1832      * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a language,
1833      * this function returns the empty string.
1834      *
1835      * @param inLocale The locale for which to retrieve the display language.
1836      * @return The name of the display language appropriate to the given locale.
<span class="line-modified">1837      * @throws    NullPointerException if {@code inLocale} is {@code null}</span>
1838      */
1839     public String getDisplayLanguage(Locale inLocale) {
1840         return getDisplayString(baseLocale.getLanguage(), null, inLocale, DISPLAY_LANGUAGE);
1841     }
1842 
1843     /**
1844      * Returns a name for the locale&#39;s script that is appropriate for display to
1845      * the user. If possible, the name will be localized for the default
1846      * {@link Locale.Category#DISPLAY DISPLAY} locale.  Returns
1847      * the empty string if this locale doesn&#39;t specify a script code.
1848      *
1849      * @return the display name of the script code for the current default
1850      *     {@link Locale.Category#DISPLAY DISPLAY} locale
1851      * @since 1.7
1852      */
1853     public String getDisplayScript() {
1854         return getDisplayScript(getDefault(Category.DISPLAY));
1855     }
1856 
1857     /**
1858      * Returns a name for the locale&#39;s script that is appropriate
1859      * for display to the user. If possible, the name will be
1860      * localized for the given locale. Returns the empty string if
1861      * this locale doesn&#39;t specify a script code.
1862      *
1863      * @param inLocale The locale for which to retrieve the display script.
1864      * @return the display name of the script code for the current default
1865      * {@link Locale.Category#DISPLAY DISPLAY} locale
<span class="line-modified">1866      * @throws NullPointerException if {@code inLocale} is {@code null}</span>
1867      * @since 1.7
1868      */
1869     public String getDisplayScript(Locale inLocale) {
1870         return getDisplayString(baseLocale.getScript(), null, inLocale, DISPLAY_SCRIPT);
1871     }
1872 
1873     /**
1874      * Returns a name for the locale&#39;s country that is appropriate for display to the
1875      * user.
1876      * If possible, the name returned will be localized for the default
1877      * {@link Locale.Category#DISPLAY DISPLAY} locale.
1878      * For example, if the locale is fr_FR and the default
1879      * {@link Locale.Category#DISPLAY DISPLAY} locale
1880      * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
1881      * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
1882      * getDisplayCountry() will return &quot;Etats-Unis&quot;.
1883      * If the name returned cannot be localized for the default
1884      * {@link Locale.Category#DISPLAY DISPLAY} locale,
1885      * (say, we don&#39;t have a Japanese name for Croatia),
1886      * this function falls back on the English name, and uses the ISO code as a last-resort
</pre>
<hr />
<pre>
1890      */
1891     public final String getDisplayCountry() {
1892         return getDisplayCountry(getDefault(Category.DISPLAY));
1893     }
1894 
1895     /**
1896      * Returns a name for the locale&#39;s country that is appropriate for display to the
1897      * user.
1898      * If possible, the name returned will be localized according to inLocale.
1899      * For example, if the locale is fr_FR and inLocale
1900      * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
1901      * inLocale is fr_FR, getDisplayCountry() will return &quot;Etats-Unis&quot;.
1902      * If the name returned cannot be localized according to inLocale.
1903      * (say, we don&#39;t have a Japanese name for Croatia),
1904      * this function falls back on the English name, and finally
1905      * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a country,
1906      * this function returns the empty string.
1907      *
1908      * @param inLocale The locale for which to retrieve the display country.
1909      * @return The name of the country appropriate to the given locale.
<span class="line-modified">1910      * @throws    NullPointerException if {@code inLocale} is {@code null}</span>
1911      */
1912     public String getDisplayCountry(Locale inLocale) {
1913         return getDisplayString(baseLocale.getRegion(), null, inLocale, DISPLAY_COUNTRY);
1914     }
1915 
1916     private String getDisplayString(String code, String cat, Locale inLocale, int type) {
1917         Objects.requireNonNull(inLocale);
1918         Objects.requireNonNull(code);
1919 
1920         if (code.isEmpty()) {
1921             return &quot;&quot;;
1922         }
1923 
1924         LocaleServiceProviderPool pool =
1925             LocaleServiceProviderPool.getPool(LocaleNameProvider.class);
1926         String rbKey = (type == DISPLAY_VARIANT ? &quot;%%&quot;+code : code);
1927         String result = pool.getLocalizedObject(
1928                                 LocaleNameGetter.INSTANCE,
1929                                 inLocale, rbKey, type, code, cat);
1930         return result != null ? result : code;
</pre>
<hr />
<pre>
1932 
1933     /**
1934      * Returns a name for the locale&#39;s variant code that is appropriate for display to the
1935      * user.  If possible, the name will be localized for the default
1936      * {@link Locale.Category#DISPLAY DISPLAY} locale.  If the locale
1937      * doesn&#39;t specify a variant code, this function returns the empty string.
1938      *
1939      * @return The name of the display variant code appropriate to the locale.
1940      */
1941     public final String getDisplayVariant() {
1942         return getDisplayVariant(getDefault(Category.DISPLAY));
1943     }
1944 
1945     /**
1946      * Returns a name for the locale&#39;s variant code that is appropriate for display to the
1947      * user.  If possible, the name will be localized for inLocale.  If the locale
1948      * doesn&#39;t specify a variant code, this function returns the empty string.
1949      *
1950      * @param inLocale The locale for which to retrieve the display variant code.
1951      * @return The name of the display variant code appropriate to the given locale.
<span class="line-modified">1952      * @throws    NullPointerException if {@code inLocale} is {@code null}</span>
1953      */
1954     public String getDisplayVariant(Locale inLocale) {
1955         if (baseLocale.getVariant().isEmpty())
1956             return &quot;&quot;;
1957 
1958         LocaleResources lr = LocaleProviderAdapter
1959             .getResourceBundleBased()
1960             .getLocaleResources(inLocale);
1961 
1962         String names[] = getDisplayVariantArray(inLocale);
1963 
1964         // Get the localized patterns for formatting a list, and use
1965         // them to format the list.
1966         return formatList(names,
1967                           lr.getLocaleName(&quot;ListCompositionPattern&quot;));
1968     }
1969 
1970     /**
1971      * Returns a name for the locale that is appropriate for display to the
1972      * user. This will be the values returned by getDisplayLanguage(),
</pre>
<hr />
<pre>
1997      * to the user.  This will be the values returned by
1998      * getDisplayLanguage(), getDisplayScript(),getDisplayCountry()
1999      * getDisplayVariant(), and optional &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;
2000      * Unicode extensions&lt;/a&gt; assembled into a single string. The non-empty
2001      * values are used in order, with the second and subsequent names in
2002      * parentheses.  For example:
2003      * &lt;blockquote&gt;
2004      * language (script, country, variant(, extension)*)&lt;br&gt;
2005      * language (country(, extension)*)&lt;br&gt;
2006      * language (variant(, extension)*)&lt;br&gt;
2007      * script (country(, extension)*)&lt;br&gt;
2008      * country (extension)*&lt;br&gt;
2009      * &lt;/blockquote&gt;
2010      * depending on which fields are specified in the locale. The field
2011      * separator in the above parentheses, denoted as a comma character, may
2012      * be localized depending on the locale. If the language, script, country,
2013      * and variant fields are all empty, this function returns the empty string.
2014      *
2015      * @param inLocale The locale for which to retrieve the display name.
2016      * @return The name of the locale appropriate to display.
<span class="line-modified">2017      * @throws NullPointerException if {@code inLocale} is {@code null}</span>
2018      */
2019     public String getDisplayName(Locale inLocale) {
2020         LocaleResources lr =  LocaleProviderAdapter
2021             .getResourceBundleBased()
2022             .getLocaleResources(inLocale);
2023 
2024         String languageName = getDisplayLanguage(inLocale);
2025         String scriptName = getDisplayScript(inLocale);
2026         String countryName = getDisplayCountry(inLocale);
2027         String[] variantNames = getDisplayVariantArray(inLocale);
2028 
2029         // Get the localized patterns for formatting a display name.
2030         String displayNamePattern = lr.getLocaleName(&quot;DisplayNamePattern&quot;);
2031         String listCompositionPattern = lr.getLocaleName(&quot;ListCompositionPattern&quot;);
2032 
2033         // The display name consists of a main name, followed by qualifiers.
2034         // Typically, the format is &quot;MainName (Qualifier, Qualifier)&quot; but this
2035         // depends on what pattern is stored in the display locale.
2036         String   mainName;
2037         String[] qualifierNames;
</pre>
<hr />
<pre>
2285      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getLanguage()&quot;&gt;getLanguage()&lt;/a&gt;)
2286      * @serialField country     String
2287      *      country subtag in upper case.
2288      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getCountry()&quot;&gt;getCountry()&lt;/a&gt;)
2289      * @serialField variant     String
2290      *      variant subtags separated by LOWLINE characters.
2291      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getVariant()&quot;&gt;getVariant()&lt;/a&gt;)
2292      * @serialField hashcode    int
2293      *      deprecated, for forward compatibility only
2294      * @serialField script      String
2295      *      script subtag in title case
2296      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getScript()&quot;&gt;getScript()&lt;/a&gt;)
2297      * @serialField extensions  String
2298      *      canonical representation of extensions, that is,
2299      *      BCP47 extensions in alphabetical order followed by
2300      *      BCP47 private use subtags, all in lower case letters
2301      *      separated by HYPHEN-MINUS characters.
2302      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getExtensionKeys()&quot;&gt;getExtensionKeys()&lt;/a&gt;,
2303      *      &lt;a href=&quot;java.base/java/util/Locale.html#getExtension(char)&quot;&gt;getExtension(char)&lt;/a&gt;)
2304      */
<span class="line-added">2305     @java.io.Serial</span>
2306     private static final ObjectStreamField[] serialPersistentFields = {
2307         new ObjectStreamField(&quot;language&quot;, String.class),
2308         new ObjectStreamField(&quot;country&quot;, String.class),
2309         new ObjectStreamField(&quot;variant&quot;, String.class),
2310         new ObjectStreamField(&quot;hashcode&quot;, int.class),
2311         new ObjectStreamField(&quot;script&quot;, String.class),
2312         new ObjectStreamField(&quot;extensions&quot;, String.class),
2313     };
2314 
2315     /**
<span class="line-modified">2316      * Serializes this {@code Locale} to the specified {@code ObjectOutputStream}.</span>
<span class="line-modified">2317      * @param out the {@code ObjectOutputStream} to write</span>
2318      * @throws IOException
2319      * @since 1.7
2320      */
<span class="line-added">2321     @java.io.Serial</span>
2322     private void writeObject(ObjectOutputStream out) throws IOException {
2323         ObjectOutputStream.PutField fields = out.putFields();
2324         fields.put(&quot;language&quot;, baseLocale.getLanguage());
2325         fields.put(&quot;script&quot;, baseLocale.getScript());
2326         fields.put(&quot;country&quot;, baseLocale.getRegion());
2327         fields.put(&quot;variant&quot;, baseLocale.getVariant());
2328         fields.put(&quot;extensions&quot;, localeExtensions == null ? &quot;&quot; : localeExtensions.getID());
2329         fields.put(&quot;hashcode&quot;, -1); // place holder just for backward support
2330         out.writeFields();
2331     }
2332 
2333     /**
<span class="line-modified">2334      * Deserializes this {@code Locale}.</span>
<span class="line-modified">2335      * @param in the {@code ObjectInputStream} to read</span>
2336      * @throws IOException
2337      * @throws ClassNotFoundException
2338      * @throws IllformedLocaleException
2339      * @since 1.7
2340      */
<span class="line-added">2341     @java.io.Serial</span>
2342     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
2343         ObjectInputStream.GetField fields = in.readFields();
2344         String language = (String)fields.get(&quot;language&quot;, &quot;&quot;);
2345         String script = (String)fields.get(&quot;script&quot;, &quot;&quot;);
2346         String country = (String)fields.get(&quot;country&quot;, &quot;&quot;);
2347         String variant = (String)fields.get(&quot;variant&quot;, &quot;&quot;);
2348         String extStr = (String)fields.get(&quot;extensions&quot;, &quot;&quot;);
<span class="line-added">2349 </span>
2350         baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);
2351         if (!extStr.isEmpty()) {
2352             try {
2353                 InternalLocaleBuilder bldr = new InternalLocaleBuilder();
2354                 bldr.setExtensions(extStr);
2355                 localeExtensions = bldr.getLocaleExtensions();
2356             } catch (LocaleSyntaxException e) {
2357                 throw new IllformedLocaleException(e.getMessage());
2358             }
2359         } else {
2360             localeExtensions = null;
2361         }
2362     }
2363 
2364     /**
<span class="line-modified">2365      * Returns a cached {@code Locale} instance equivalent to</span>
<span class="line-modified">2366      * the deserialized {@code Locale}. When serialized</span>
2367      * language, country and variant fields read from the object data stream
2368      * are exactly &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot; or &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot; and script/extensions
<span class="line-modified">2369      * fields are empty, this method supplies {@code UNICODE_LOCALE_EXTENSION}</span>
2370      * &quot;ca&quot;/&quot;japanese&quot; (calendar type is &quot;japanese&quot;) or &quot;nu&quot;/&quot;thai&quot; (number script
2371      * type is &quot;thai&quot;). See &lt;a href=&quot;Locale.html#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;
2372      * for more information.
2373      *
<span class="line-modified">2374      * @return an instance of {@code Locale} equivalent to</span>
<span class="line-modified">2375      * the deserialized {@code Locale}.</span>
2376      * @throws java.io.ObjectStreamException
2377      */
<span class="line-added">2378     @java.io.Serial</span>
2379     private Object readResolve() throws java.io.ObjectStreamException {
2380         return getInstance(baseLocale.getLanguage(), baseLocale.getScript(),
2381                 baseLocale.getRegion(), baseLocale.getVariant(), localeExtensions);
2382     }
2383 
2384     private static volatile String[] isoLanguages;
2385 
2386     private static volatile String[] isoCountries;
2387 
2388     private static String convertOldISOCodes(String language) {
2389         // we accept both the old and the new ISO codes for the languages whose ISO
2390         // codes have changed, but we always store the OLD code, for backward compatibility
2391         language = LocaleUtils.toLowerString(language).intern();
2392         if (language == &quot;he&quot;) {
2393             return &quot;iw&quot;;
2394         } else if (language == &quot;yi&quot;) {
2395             return &quot;ji&quot;;
2396         } else if (language == &quot;id&quot;) {
2397             return &quot;in&quot;;
2398         } else {
</pre>
<hr />
<pre>
2492                &quot;user.variant.format&quot;,
2493                &quot;user.extensions.format&quot;);
2494 
2495         Category(String languageKey, String scriptKey, String countryKey,
2496                 String variantKey, String extensionsKey) {
2497             this.languageKey = languageKey;
2498             this.scriptKey = scriptKey;
2499             this.countryKey = countryKey;
2500             this.variantKey = variantKey;
2501             this.extensionsKey = extensionsKey;
2502         }
2503 
2504         final String languageKey;
2505         final String scriptKey;
2506         final String countryKey;
2507         final String variantKey;
2508         final String extensionsKey;
2509     }
2510 
2511     /**
<span class="line-modified">2512      * {@code Builder} is used to build instances of {@code Locale}</span>
<span class="line-modified">2513      * from values configured by the setters.  Unlike the {@code Locale}</span>
<span class="line-modified">2514      * constructors, the {@code Builder} checks if a value configured by a</span>
<span class="line-modified">2515      * setter satisfies the syntax requirements defined by the {@code Locale}</span>
<span class="line-modified">2516      * class.  A {@code Locale} object created by a {@code Builder} is</span>
2517      * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
2518      * without losing information.
2519      *
<span class="line-modified">2520      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The {@code Locale} class does not provide any</span>
2521      * syntactic restrictions on variant, while BCP 47 requires each variant
2522      * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
<span class="line-modified">2523      * alphanumerics.  The method {@code setVariant} throws</span>
<span class="line-modified">2524      * {@code IllformedLocaleException} for a variant that does not satisfy</span>
2525      * this restriction. If it is necessary to support such a variant, use a
<span class="line-modified">2526      * Locale constructor.  However, keep in mind that a {@code Locale}</span>
2527      * object created this way might lose the variant information when
2528      * transformed to a BCP 47 language tag.
2529      *
<span class="line-modified">2530      * &lt;p&gt;The following example shows how to create a {@code Locale} object</span>
<span class="line-modified">2531      * with the {@code Builder}.</span>
2532      * &lt;blockquote&gt;
2533      * &lt;pre&gt;
2534      *     Locale aLocale = new Builder().setLanguage(&quot;sr&quot;).setScript(&quot;Latn&quot;).setRegion(&quot;RS&quot;).build();
2535      * &lt;/pre&gt;
2536      * &lt;/blockquote&gt;
2537      *
<span class="line-modified">2538      * &lt;p&gt;Builders can be reused; {@code clear()} resets all</span>
2539      * fields to their default values.
2540      *
2541      * @see Locale#forLanguageTag
2542      * @since 1.7
2543      */
2544     public static final class Builder {
2545         private final InternalLocaleBuilder localeBuilder;
2546 
2547         /**
2548          * Constructs an empty Builder. The default value of all
2549          * fields, extensions, and private use information is the
2550          * empty string.
2551          */
2552         public Builder() {
2553             localeBuilder = new InternalLocaleBuilder();
2554         }
2555 
2556         /**
<span class="line-modified">2557          * Resets the {@code Builder} to match the provided</span>
<span class="line-modified">2558          * {@code locale}.  Existing state is discarded.</span>
2559          *
2560          * &lt;p&gt;All fields of the locale must be well-formed, see {@link Locale}.
2561          *
2562          * &lt;p&gt;Locales with any ill-formed fields cause
<span class="line-modified">2563          * {@code IllformedLocaleException} to be thrown, except for the</span>
2564          * following three cases which are accepted for compatibility
2565          * reasons:&lt;ul&gt;
2566          * &lt;li&gt;Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) is treated as &quot;ja-JP-u-ca-japanese&quot;
2567          * &lt;li&gt;Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) is treated as &quot;th-TH-u-nu-thai&quot;
2568          * &lt;li&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;) is treated as &quot;nn-NO&quot;&lt;/ul&gt;
2569          *
2570          * @param locale the locale
2571          * @return This builder.
<span class="line-modified">2572          * @throws IllformedLocaleException if {@code locale} has</span>
2573          * any ill-formed fields.
<span class="line-modified">2574          * @throws NullPointerException if {@code locale} is null.</span>
2575          */
2576         public Builder setLocale(Locale locale) {
2577             try {
2578                 localeBuilder.setLocale(locale.baseLocale, locale.localeExtensions);
2579             } catch (LocaleSyntaxException e) {
2580                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2581             }
2582             return this;
2583         }
2584 
2585         /**
2586          * Resets the Builder to match the provided IETF BCP 47
2587          * language tag.  Discards the existing state.  Null and the
2588          * empty string cause the builder to be reset, like {@link
2589          * #clear}.  Grandfathered tags (see {@link
2590          * Locale#forLanguageTag}) are converted to their canonical
2591          * form before being processed.  Otherwise, the language tag
2592          * must be well-formed (see {@link Locale}) or an exception is
<span class="line-modified">2593          * thrown (unlike {@code Locale.forLanguageTag}, which</span>
2594          * just discards ill-formed and following portions of the
2595          * tag).
2596          *
2597          * @param languageTag the language tag
2598          * @return This builder.
<span class="line-modified">2599          * @throws IllformedLocaleException if {@code languageTag} is ill-formed</span>
2600          * @see Locale#forLanguageTag(String)
2601          */
2602         public Builder setLanguageTag(String languageTag) {
2603             ParseStatus sts = new ParseStatus();
2604             LanguageTag tag = LanguageTag.parse(languageTag, sts);
2605             if (sts.isError()) {
2606                 throw new IllformedLocaleException(sts.getErrorMessage(), sts.getErrorIndex());
2607             }
2608             localeBuilder.setLanguageTag(tag);
2609             return this;
2610         }
2611 
2612         /**
<span class="line-modified">2613          * Sets the language.  If {@code language} is the empty string or</span>
<span class="line-modified">2614          * null, the language in this {@code Builder} is removed.  Otherwise,</span>
2615          * the language must be &lt;a href=&quot;./Locale.html#def_language&quot;&gt;well-formed&lt;/a&gt;
2616          * or an exception is thrown.
2617          *
2618          * &lt;p&gt;The typical language value is a two or three-letter language
2619          * code as defined in ISO639.
2620          *
2621          * @param language the language
2622          * @return This builder.
<span class="line-modified">2623          * @throws IllformedLocaleException if {@code language} is ill-formed</span>
2624          */
2625         public Builder setLanguage(String language) {
2626             try {
2627                 localeBuilder.setLanguage(language);
2628             } catch (LocaleSyntaxException e) {
2629                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2630             }
2631             return this;
2632         }
2633 
2634         /**
<span class="line-modified">2635          * Sets the script. If {@code script} is null or the empty string,</span>
<span class="line-modified">2636          * the script in this {@code Builder} is removed.</span>
2637          * Otherwise, the script must be &lt;a href=&quot;./Locale.html#def_script&quot;&gt;well-formed&lt;/a&gt; or an
2638          * exception is thrown.
2639          *
2640          * &lt;p&gt;The typical script value is a four-letter script code as defined by ISO 15924.
2641          *
2642          * @param script the script
2643          * @return This builder.
<span class="line-modified">2644          * @throws IllformedLocaleException if {@code script} is ill-formed</span>
2645          */
2646         public Builder setScript(String script) {
2647             try {
2648                 localeBuilder.setScript(script);
2649             } catch (LocaleSyntaxException e) {
2650                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2651             }
2652             return this;
2653         }
2654 
2655         /**
2656          * Sets the region.  If region is null or the empty string, the region
<span class="line-modified">2657          * in this {@code Builder} is removed.  Otherwise,</span>
2658          * the region must be &lt;a href=&quot;./Locale.html#def_region&quot;&gt;well-formed&lt;/a&gt; or an
2659          * exception is thrown.
2660          *
2661          * &lt;p&gt;The typical region value is a two-letter ISO 3166 code or a
2662          * three-digit UN M.49 area code.
2663          *
<span class="line-modified">2664          * &lt;p&gt;The country value in the {@code Locale} created by the</span>
<span class="line-modified">2665          * {@code Builder} is always normalized to upper case.</span>
2666          *
2667          * @param region the region
2668          * @return This builder.
<span class="line-modified">2669          * @throws IllformedLocaleException if {@code region} is ill-formed</span>
2670          */
2671         public Builder setRegion(String region) {
2672             try {
2673                 localeBuilder.setRegion(region);
2674             } catch (LocaleSyntaxException e) {
2675                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2676             }
2677             return this;
2678         }
2679 
2680         /**
2681          * Sets the variant.  If variant is null or the empty string, the
<span class="line-modified">2682          * variant in this {@code Builder} is removed.  Otherwise, it</span>
2683          * must consist of one or more &lt;a href=&quot;./Locale.html#def_variant&quot;&gt;well-formed&lt;/a&gt;
2684          * subtags, or an exception is thrown.
2685          *
<span class="line-modified">2686          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method checks if {@code variant}</span>
2687          * satisfies the IETF BCP 47 variant subtag&#39;s syntax requirements,
2688          * and normalizes the value to lowercase letters.  However,
<span class="line-modified">2689          * the {@code Locale} class does not impose any syntactic</span>
2690          * restriction on variant, and the variant value in
<span class="line-modified">2691          * {@code Locale} is case sensitive.  To set such a variant,</span>
2692          * use a Locale constructor.
2693          *
2694          * @param variant the variant
2695          * @return This builder.
<span class="line-modified">2696          * @throws IllformedLocaleException if {@code variant} is ill-formed</span>
2697          */
2698         public Builder setVariant(String variant) {
2699             try {
2700                 localeBuilder.setVariant(variant);
2701             } catch (LocaleSyntaxException e) {
2702                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2703             }
2704             return this;
2705         }
2706 
2707         /**
2708          * Sets the extension for the given key. If the value is null or the
2709          * empty string, the extension is removed.  Otherwise, the extension
2710          * must be &lt;a href=&quot;./Locale.html#def_extensions&quot;&gt;well-formed&lt;/a&gt; or an exception
2711          * is thrown.
2712          *
2713          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#UNICODE_LOCALE_EXTENSION
2714          * UNICODE_LOCALE_EXTENSION} (&#39;u&#39;) is used for the Unicode locale extension.
2715          * Setting a value for this key replaces any existing Unicode locale key/type
2716          * pairs with those defined in the extension.
2717          *
2718          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#PRIVATE_USE_EXTENSION
2719          * PRIVATE_USE_EXTENSION} (&#39;x&#39;) is used for the private use code. To be
2720          * well-formed, the value for this key needs only to have subtags of one to
2721          * eight alphanumeric characters, not two to eight as in the general case.
2722          *
2723          * @param key the extension key
2724          * @param value the extension value
2725          * @return This builder.
<span class="line-modified">2726          * @throws IllformedLocaleException if {@code key} is illegal</span>
<span class="line-modified">2727          * or {@code value} is ill-formed</span>
2728          * @see #setUnicodeLocaleKeyword(String, String)
2729          */
2730         public Builder setExtension(char key, String value) {
2731             try {
2732                 localeBuilder.setExtension(key, value);
2733             } catch (LocaleSyntaxException e) {
2734                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2735             }
2736             return this;
2737         }
2738 
2739         /**
2740          * Sets the Unicode locale keyword type for the given key.  If the type
2741          * is null, the Unicode keyword is removed.  Otherwise, the key must be
2742          * non-null and both key and type must be &lt;a
2743          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2744          * is thrown.
2745          *
2746          * &lt;p&gt;Keys and types are converted to lower case.
2747          *
2748          * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;:Setting the &#39;u&#39; extension via {@link #setExtension}
2749          * replaces all Unicode locale keywords with those defined in the
2750          * extension.
2751          *
2752          * @param key the Unicode locale key
2753          * @param type the Unicode locale type
2754          * @return This builder.
<span class="line-modified">2755          * @throws IllformedLocaleException if {@code key} or {@code type}</span>
2756          * is ill-formed
<span class="line-modified">2757          * @throws NullPointerException if {@code key} is null</span>
2758          * @see #setExtension(char, String)
2759          */
2760         public Builder setUnicodeLocaleKeyword(String key, String type) {
2761             try {
2762                 localeBuilder.setUnicodeLocaleKeyword(key, type);
2763             } catch (LocaleSyntaxException e) {
2764                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2765             }
2766             return this;
2767         }
2768 
2769         /**
2770          * Adds a unicode locale attribute, if not already present, otherwise
2771          * has no effect.  The attribute must not be null and must be &lt;a
2772          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2773          * is thrown.
2774          *
2775          * @param attribute the attribute
2776          * @return This builder.
<span class="line-modified">2777          * @throws NullPointerException if {@code attribute} is null</span>
<span class="line-modified">2778          * @throws IllformedLocaleException if {@code attribute} is ill-formed</span>
2779          * @see #setExtension(char, String)
2780          */
2781         public Builder addUnicodeLocaleAttribute(String attribute) {
2782             try {
2783                 localeBuilder.addUnicodeLocaleAttribute(attribute);
2784             } catch (LocaleSyntaxException e) {
2785                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2786             }
2787             return this;
2788         }
2789 
2790         /**
2791          * Removes a unicode locale attribute, if present, otherwise has no
2792          * effect.  The attribute must not be null and must be &lt;a
2793          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2794          * is thrown.
2795          *
2796          * &lt;p&gt;Attribute comparison for removal is case-insensitive.
2797          *
2798          * @param attribute the attribute
2799          * @return This builder.
<span class="line-modified">2800          * @throws NullPointerException if {@code attribute} is null</span>
<span class="line-modified">2801          * @throws IllformedLocaleException if {@code attribute} is ill-formed</span>
2802          * @see #setExtension(char, String)
2803          */
2804         public Builder removeUnicodeLocaleAttribute(String attribute) {
2805             Objects.requireNonNull(attribute);
2806             try {
2807                 localeBuilder.removeUnicodeLocaleAttribute(attribute);
2808             } catch (LocaleSyntaxException e) {
2809                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2810             }
2811             return this;
2812         }
2813 
2814         /**
2815          * Resets the builder to its initial, empty state.
2816          *
2817          * @return This builder.
2818          */
2819         public Builder clear() {
2820             localeBuilder.clear();
2821             return this;
2822         }
2823 
2824         /**
2825          * Resets the extensions to their initial, empty state.
2826          * Language, script, region and variant are unchanged.
2827          *
2828          * @return This builder.
2829          * @see #setExtension(char, String)
2830          */
2831         public Builder clearExtensions() {
2832             localeBuilder.clearExtensions();
2833             return this;
2834         }
2835 
2836         /**
<span class="line-modified">2837          * Returns an instance of {@code Locale} created from the fields set</span>
2838          * on this builder.
2839          *
2840          * &lt;p&gt;This applies the conversions listed in {@link Locale#forLanguageTag}
2841          * when constructing a Locale. (Grandfathered tags are handled in
2842          * {@link #setLanguageTag}.)
2843          *
2844          * @return A Locale.
2845          */
2846         public Locale build() {
2847             BaseLocale baseloc = localeBuilder.getBaseLocale();
2848             LocaleExtensions extensions = localeBuilder.getLocaleExtensions();
2849             if (extensions == null &amp;&amp; !baseloc.getVariant().isEmpty()) {
2850                 extensions = getCompatibilityExtensions(baseloc.getLanguage(), baseloc.getScript(),
2851                         baseloc.getRegion(), baseloc.getVariant());
2852             }
2853             return Locale.getInstance(baseloc, extensions);
2854         }
2855     }
2856 
2857     /**
</pre>
<hr />
<pre>
3465      * @return a list of matching language tags sorted in descending order
3466      *     based on priority or weight, or an empty list if nothing matches.
3467      *     The list is modifiable.
3468      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3469      *     {@code null}
3470      *
3471      * @since 1.8
3472      */
3473     public static List&lt;String&gt; filterTags(List&lt;LanguageRange&gt; priorityList,
3474                                           Collection&lt;String&gt; tags) {
3475         return filterTags(priorityList, tags, FilteringMode.AUTOSELECT_FILTERING);
3476     }
3477 
3478     /**
3479      * Returns a {@code Locale} instance for the best-matching language
3480      * tag using the lookup mechanism defined in RFC 4647.
3481      *
3482      * @param priorityList user&#39;s Language Priority List in which each language
3483      *     tag is sorted in descending order based on priority or weight
3484      * @param locales {@code Locale} instances used for matching
<span class="line-modified">3485      * @return the best matching {@code Locale} instance chosen based on</span>
3486      *     priority or weight, or {@code null} if nothing matches.
3487      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3488      *     {@code null}
3489      *
3490      * @since 1.8
3491      */
3492     public static Locale lookup(List&lt;LanguageRange&gt; priorityList,
3493                                 Collection&lt;Locale&gt; locales) {
3494         return LocaleMatcher.lookup(priorityList, locales);
3495     }
3496 
3497     /**
3498      * Returns the best-matching language tag using the lookup mechanism
3499      * defined in RFC 4647.
3500      *
3501      * This lookup operation on the given {@code tags} ensures that the
3502      * first matching tag with preserved case is returned.
3503      *
3504      * @param priorityList user&#39;s Language Priority List in which each language
3505      *     tag is sorted in descending order based on priority or weight
</pre>
</td>
</tr>
</table>
<center><a href="ListResourceBundle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LongSummaryStatistics.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
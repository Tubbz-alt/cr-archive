<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/time/Instant.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Duration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LocalDate.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/time/Instant.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  91 import java.time.temporal.TemporalQuery;
  92 import java.time.temporal.TemporalUnit;
  93 import java.time.temporal.UnsupportedTemporalTypeException;
  94 import java.time.temporal.ValueRange;
  95 import java.util.Objects;
  96 
  97 /**
  98  * An instantaneous point on the time-line.
  99  * &lt;p&gt;
 100  * This class models a single instantaneous point on the time-line.
 101  * This might be used to record event time-stamps in the application.
 102  * &lt;p&gt;
 103  * The range of an instant requires the storage of a number larger than a {@code long}.
 104  * To achieve this, the class stores a {@code long} representing epoch-seconds and an
 105  * {@code int} representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 106  * The epoch-seconds are measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z}
 107  * where instants after the epoch have positive values, and earlier instants have negative values.
 108  * For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
 109  * than a smaller value.
 110  *
<span class="line-modified"> 111  * &lt;h3&gt;Time-scale&lt;/h3&gt;</span>
 112  * &lt;p&gt;
 113  * The length of the solar day is the standard way that humans measure time.
 114  * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
 115  * forming a 86400 second day.
 116  * &lt;p&gt;
 117  * Modern timekeeping is based on atomic clocks which precisely define an SI second
 118  * relative to the transitions of a Caesium atom. The length of an SI second was defined
 119  * to be very close to the 86400th fraction of a day.
 120  * &lt;p&gt;
 121  * Unfortunately, as the Earth rotates the length of the day varies.
 122  * In addition, over time the average length of the day is getting longer as the Earth slows.
 123  * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
 124  * The actual length of any given day and the amount by which the Earth is slowing
 125  * are not predictable and can only be determined by measurement.
 126  * The UT1 time-scale captures the accurate length of day, but is only available some
 127  * time after the day has completed.
 128  * &lt;p&gt;
 129  * The UTC time-scale is a standard approach to bundle up all the additional fractions
 130  * of a second from UT1 into whole seconds, known as &lt;i&gt;leap-seconds&lt;/i&gt;.
 131  * A leap-second may be added or removed depending on the Earth&#39;s rotational changes.
</pre>
<hr />
<pre>
 228      * which affect the instant in addition to the local date-time.
 229      * The value is also chosen such that the value of the year fits in
 230      * an {@code int}.
 231      */
 232     public static final Instant MIN = Instant.ofEpochSecond(MIN_SECOND, 0);
 233     /**
 234      * The maximum supported {@code Instant}, &#39;1000000000-12-31T23:59:59.999999999Z&#39;.
 235      * This could be used by an application as a &quot;far future&quot; instant.
 236      * &lt;p&gt;
 237      * This is one year later than the maximum {@code LocalDateTime}.
 238      * This provides sufficient values to handle the range of {@code ZoneOffset}
 239      * which affect the instant in addition to the local date-time.
 240      * The value is also chosen such that the value of the year fits in
 241      * an {@code int}.
 242      */
 243     public static final Instant MAX = Instant.ofEpochSecond(MAX_SECOND, 999_999_999);
 244 
 245     /**
 246      * Serialization version.
 247      */

 248     private static final long serialVersionUID = -665713676816604388L;
 249 
 250     /**
 251      * The number of seconds from the epoch of 1970-01-01T00:00:00Z.
 252      */
 253     private final long seconds;
 254     /**
 255      * The number of nanoseconds, later along the time-line, from the seconds field.
 256      * This is always positive, and never exceeds 999,999,999.
 257      */
 258     private final int nanos;
 259 
 260     //-----------------------------------------------------------------------
 261     /**
 262      * Obtains the current instant from the system clock.
 263      * &lt;p&gt;
 264      * This will query the {@link Clock#systemUTC() system UTC clock} to
 265      * obtain the current instant.
 266      * &lt;p&gt;
 267      * Using this method will prevent the ability to use an alternate time-source for
</pre>
<hr />
<pre>
1325      * @return an ISO-8601 representation of this instant, not null
1326      */
1327     @Override
1328     public String toString() {
1329         return DateTimeFormatter.ISO_INSTANT.format(this);
1330     }
1331 
1332     // -----------------------------------------------------------------------
1333     /**
1334      * Writes the object using a
1335      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1336      * @serialData
1337      * &lt;pre&gt;
1338      *  out.writeByte(2);  // identifies an Instant
1339      *  out.writeLong(seconds);
1340      *  out.writeInt(nanos);
1341      * &lt;/pre&gt;
1342      *
1343      * @return the instance of {@code Ser}, not null
1344      */

1345     private Object writeReplace() {
1346         return new Ser(Ser.INSTANT_TYPE, this);
1347     }
1348 
1349     /**
1350      * Defend against malicious streams.
1351      *
1352      * @param s the stream to read
1353      * @throws InvalidObjectException always
1354      */

1355     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1356         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1357     }
1358 
1359     void writeExternal(DataOutput out) throws IOException {
1360         out.writeLong(seconds);
1361         out.writeInt(nanos);
1362     }
1363 
1364     static Instant readExternal(DataInput in) throws IOException {
1365         long seconds = in.readLong();
1366         int nanos = in.readInt();
1367         return Instant.ofEpochSecond(seconds, nanos);
1368     }
1369 
1370 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  91 import java.time.temporal.TemporalQuery;
  92 import java.time.temporal.TemporalUnit;
  93 import java.time.temporal.UnsupportedTemporalTypeException;
  94 import java.time.temporal.ValueRange;
  95 import java.util.Objects;
  96 
  97 /**
  98  * An instantaneous point on the time-line.
  99  * &lt;p&gt;
 100  * This class models a single instantaneous point on the time-line.
 101  * This might be used to record event time-stamps in the application.
 102  * &lt;p&gt;
 103  * The range of an instant requires the storage of a number larger than a {@code long}.
 104  * To achieve this, the class stores a {@code long} representing epoch-seconds and an
 105  * {@code int} representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 106  * The epoch-seconds are measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z}
 107  * where instants after the epoch have positive values, and earlier instants have negative values.
 108  * For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
 109  * than a smaller value.
 110  *
<span class="line-modified"> 111  * &lt;h2&gt;Time-scale&lt;/h2&gt;</span>
 112  * &lt;p&gt;
 113  * The length of the solar day is the standard way that humans measure time.
 114  * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
 115  * forming a 86400 second day.
 116  * &lt;p&gt;
 117  * Modern timekeeping is based on atomic clocks which precisely define an SI second
 118  * relative to the transitions of a Caesium atom. The length of an SI second was defined
 119  * to be very close to the 86400th fraction of a day.
 120  * &lt;p&gt;
 121  * Unfortunately, as the Earth rotates the length of the day varies.
 122  * In addition, over time the average length of the day is getting longer as the Earth slows.
 123  * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
 124  * The actual length of any given day and the amount by which the Earth is slowing
 125  * are not predictable and can only be determined by measurement.
 126  * The UT1 time-scale captures the accurate length of day, but is only available some
 127  * time after the day has completed.
 128  * &lt;p&gt;
 129  * The UTC time-scale is a standard approach to bundle up all the additional fractions
 130  * of a second from UT1 into whole seconds, known as &lt;i&gt;leap-seconds&lt;/i&gt;.
 131  * A leap-second may be added or removed depending on the Earth&#39;s rotational changes.
</pre>
<hr />
<pre>
 228      * which affect the instant in addition to the local date-time.
 229      * The value is also chosen such that the value of the year fits in
 230      * an {@code int}.
 231      */
 232     public static final Instant MIN = Instant.ofEpochSecond(MIN_SECOND, 0);
 233     /**
 234      * The maximum supported {@code Instant}, &#39;1000000000-12-31T23:59:59.999999999Z&#39;.
 235      * This could be used by an application as a &quot;far future&quot; instant.
 236      * &lt;p&gt;
 237      * This is one year later than the maximum {@code LocalDateTime}.
 238      * This provides sufficient values to handle the range of {@code ZoneOffset}
 239      * which affect the instant in addition to the local date-time.
 240      * The value is also chosen such that the value of the year fits in
 241      * an {@code int}.
 242      */
 243     public static final Instant MAX = Instant.ofEpochSecond(MAX_SECOND, 999_999_999);
 244 
 245     /**
 246      * Serialization version.
 247      */
<span class="line-added"> 248     @java.io.Serial</span>
 249     private static final long serialVersionUID = -665713676816604388L;
 250 
 251     /**
 252      * The number of seconds from the epoch of 1970-01-01T00:00:00Z.
 253      */
 254     private final long seconds;
 255     /**
 256      * The number of nanoseconds, later along the time-line, from the seconds field.
 257      * This is always positive, and never exceeds 999,999,999.
 258      */
 259     private final int nanos;
 260 
 261     //-----------------------------------------------------------------------
 262     /**
 263      * Obtains the current instant from the system clock.
 264      * &lt;p&gt;
 265      * This will query the {@link Clock#systemUTC() system UTC clock} to
 266      * obtain the current instant.
 267      * &lt;p&gt;
 268      * Using this method will prevent the ability to use an alternate time-source for
</pre>
<hr />
<pre>
1326      * @return an ISO-8601 representation of this instant, not null
1327      */
1328     @Override
1329     public String toString() {
1330         return DateTimeFormatter.ISO_INSTANT.format(this);
1331     }
1332 
1333     // -----------------------------------------------------------------------
1334     /**
1335      * Writes the object using a
1336      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1337      * @serialData
1338      * &lt;pre&gt;
1339      *  out.writeByte(2);  // identifies an Instant
1340      *  out.writeLong(seconds);
1341      *  out.writeInt(nanos);
1342      * &lt;/pre&gt;
1343      *
1344      * @return the instance of {@code Ser}, not null
1345      */
<span class="line-added">1346     @java.io.Serial</span>
1347     private Object writeReplace() {
1348         return new Ser(Ser.INSTANT_TYPE, this);
1349     }
1350 
1351     /**
1352      * Defend against malicious streams.
1353      *
1354      * @param s the stream to read
1355      * @throws InvalidObjectException always
1356      */
<span class="line-added">1357     @java.io.Serial</span>
1358     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1359         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1360     }
1361 
1362     void writeExternal(DataOutput out) throws IOException {
1363         out.writeLong(seconds);
1364         out.writeInt(nanos);
1365     }
1366 
1367     static Instant readExternal(DataInput in) throws IOException {
1368         long seconds = in.readLong();
1369         int nanos = in.readInt();
1370         return Instant.ofEpochSecond(seconds, nanos);
1371     }
1372 
1373 }
</pre>
</td>
</tr>
</table>
<center><a href="Duration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LocalDate.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/concurrent/Phaser.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent;
  37 
  38 import java.lang.invoke.MethodHandles;
  39 import java.lang.invoke.VarHandle;
  40 import java.util.concurrent.atomic.AtomicReference;
  41 import java.util.concurrent.locks.LockSupport;
  42 
  43 /**
  44  * A reusable synchronization barrier, similar in functionality to
  45  * {@link CyclicBarrier} and {@link CountDownLatch} but supporting
  46  * more flexible usage.
  47  *
  48  * &lt;p&gt;&lt;b&gt;Registration.&lt;/b&gt; Unlike the case for other barriers, the
  49  * number of parties &lt;em&gt;registered&lt;/em&gt; to synchronize on a phaser
  50  * may vary over time.  Tasks may be registered at any time (using
  51  * methods {@link #register}, {@link #bulkRegister}, or forms of
  52  * constructors establishing initial numbers of parties), and
  53  * optionally deregistered upon any arrival (using {@link
  54  * #arriveAndDeregister}).  As is the case with most basic
  55  * synchronization constructs, registration and deregistration affect
  56  * only internal counts; they do not establish any further internal
  57  * bookkeeping, so tasks cannot query whether they are registered.
  58  * (However, you can introduce such bookkeeping by subclassing this
  59  * class.)
  60  *
  61  * &lt;p&gt;&lt;b&gt;Synchronization.&lt;/b&gt; Like a {@code CyclicBarrier}, a {@code
  62  * Phaser} may be repeatedly awaited.  Method {@link
  63  * #arriveAndAwaitAdvance} has effect analogous to {@link
  64  * java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each
  65  * generation of a phaser has an associated phase number. The phase
  66  * number starts at zero, and advances when all parties arrive at the
  67  * phaser, wrapping around to zero after reaching {@code
  68  * Integer.MAX_VALUE}. The use of phase numbers enables independent
  69  * control of actions upon arrival at a phaser and upon awaiting
  70  * others, via two kinds of methods that may be invoked by any
  71  * registered party:
  72  *
  73  * &lt;ul&gt;
  74  *
  75  *   &lt;li&gt;&lt;b&gt;Arrival.&lt;/b&gt; Methods {@link #arrive} and
  76  *       {@link #arriveAndDeregister} record arrival.  These methods
  77  *       do not block, but return an associated &lt;em&gt;arrival phase
  78  *       number&lt;/em&gt;; that is, the phase number of the phaser to which
  79  *       the arrival applied. When the final party for a given phase
  80  *       arrives, an optional action is performed and the phase
  81  *       advances.  These actions are performed by the party
  82  *       triggering a phase advance, and are arranged by overriding
  83  *       method {@link #onAdvance(int, int)}, which also controls
  84  *       termination. Overriding this method is similar to, but more
  85  *       flexible than, providing a barrier action to a {@code
  86  *       CyclicBarrier}.
  87  *
  88  *   &lt;li&gt;&lt;b&gt;Waiting.&lt;/b&gt; Method {@link #awaitAdvance} requires an
  89  *       argument indicating an arrival phase number, and returns when
  90  *       the phaser advances to (or is already at) a different phase.
  91  *       Unlike similar constructions using {@code CyclicBarrier},
  92  *       method {@code awaitAdvance} continues to wait even if the
  93  *       waiting thread is interrupted. Interruptible and timeout
  94  *       versions are also available, but exceptions encountered while
  95  *       tasks wait interruptibly or with timeout do not change the
  96  *       state of the phaser. If necessary, you can perform any
  97  *       associated recovery within handlers of those exceptions,
  98  *       often after invoking {@code forceTermination}.  Phasers may
  99  *       also be used by tasks executing in a {@link ForkJoinPool}.
 100  *       Progress is ensured if the pool&#39;s parallelismLevel can
 101  *       accommodate the maximum number of simultaneously blocked
 102  *       parties.
 103  *
 104  * &lt;/ul&gt;
 105  *
 106  * &lt;p&gt;&lt;b&gt;Termination.&lt;/b&gt; A phaser may enter a &lt;em&gt;termination&lt;/em&gt;
 107  * state, that may be checked using method {@link #isTerminated}. Upon
 108  * termination, all synchronization methods immediately return without
 109  * waiting for advance, as indicated by a negative return value.
 110  * Similarly, attempts to register upon termination have no effect.
 111  * Termination is triggered when an invocation of {@code onAdvance}
 112  * returns {@code true}. The default implementation returns {@code
 113  * true} if a deregistration has caused the number of registered
 114  * parties to become zero.  As illustrated below, when phasers control
 115  * actions with a fixed number of iterations, it is often convenient
 116  * to override this method to cause termination when the current phase
 117  * number reaches a threshold. Method {@link #forceTermination} is
 118  * also available to abruptly release waiting threads and allow them
 119  * to terminate.
 120  *
 121  * &lt;p&gt;&lt;b&gt;Tiering.&lt;/b&gt; Phasers may be &lt;em&gt;tiered&lt;/em&gt; (i.e.,
 122  * constructed in tree structures) to reduce contention. Phasers with
 123  * large numbers of parties that would otherwise experience heavy
 124  * synchronization contention costs may instead be set up so that
 125  * groups of sub-phasers share a common parent.  This may greatly
 126  * increase throughput even though it incurs greater per-operation
 127  * overhead.
 128  *
 129  * &lt;p&gt;In a tree of tiered phasers, registration and deregistration of
 130  * child phasers with their parent are managed automatically.
 131  * Whenever the number of registered parties of a child phaser becomes
 132  * non-zero (as established in the {@link #Phaser(Phaser,int)}
 133  * constructor, {@link #register}, or {@link #bulkRegister}), the
 134  * child phaser is registered with its parent.  Whenever the number of
 135  * registered parties becomes zero as the result of an invocation of
 136  * {@link #arriveAndDeregister}, the child phaser is deregistered
 137  * from its parent.
 138  *
 139  * &lt;p&gt;&lt;b&gt;Monitoring.&lt;/b&gt; While synchronization methods may be invoked
 140  * only by registered parties, the current state of a phaser may be
 141  * monitored by any caller.  At any given moment there are {@link
 142  * #getRegisteredParties} parties in total, of which {@link
 143  * #getArrivedParties} have arrived at the current phase ({@link
 144  * #getPhase}).  When the remaining ({@link #getUnarrivedParties})
 145  * parties arrive, the phase advances.  The values returned by these
 146  * methods may reflect transient states and so are not in general
 147  * useful for synchronization control.  Method {@link #toString}
 148  * returns snapshots of these state queries in a form convenient for
 149  * informal monitoring.
 150  *
 151  * &lt;p&gt;&lt;b&gt;Sample usages:&lt;/b&gt;
 152  *
 153  * &lt;p&gt;A {@code Phaser} may be used instead of a {@code CountDownLatch}
 154  * to control a one-shot action serving a variable number of parties.
 155  * The typical idiom is for the method setting this up to first
 156  * register, then start all the actions, then deregister, as in:
 157  *
 158  * &lt;pre&gt; {@code
 159  * void runTasks(List&lt;Runnable&gt; tasks) {
 160  *   Phaser startingGate = new Phaser(1); // &quot;1&quot; to register self
 161  *   // create and start threads
 162  *   for (Runnable task : tasks) {
 163  *     startingGate.register();
 164  *     new Thread(() -&gt; {
 165  *       startingGate.arriveAndAwaitAdvance();
 166  *       task.run();
 167  *     }).start();
 168  *   }
 169  *
 170  *   // deregister self to allow threads to proceed
 171  *   startingGate.arriveAndDeregister();
 172  * }}&lt;/pre&gt;
 173  *
 174  * &lt;p&gt;One way to cause a set of threads to repeatedly perform actions
 175  * for a given number of iterations is to override {@code onAdvance}:
 176  *
 177  * &lt;pre&gt; {@code
 178  * void startTasks(List&lt;Runnable&gt; tasks, int iterations) {
 179  *   Phaser phaser = new Phaser() {
 180  *     protected boolean onAdvance(int phase, int registeredParties) {
 181  *       return phase &gt;= iterations - 1 || registeredParties == 0;
 182  *     }
 183  *   };
 184  *   phaser.register();
 185  *   for (Runnable task : tasks) {
 186  *     phaser.register();
 187  *     new Thread(() -&gt; {
 188  *       do {
 189  *         task.run();
 190  *         phaser.arriveAndAwaitAdvance();
 191  *       } while (!phaser.isTerminated());
 192  *     }).start();
 193  *   }
 194  *   // allow threads to proceed; don&#39;t wait for them
 195  *   phaser.arriveAndDeregister();
 196  * }}&lt;/pre&gt;
 197  *
 198  * If the main task must later await termination, it
 199  * may re-register and then execute a similar loop:
 200  * &lt;pre&gt; {@code
 201  *   // ...
 202  *   phaser.register();
 203  *   while (!phaser.isTerminated())
 204  *     phaser.arriveAndAwaitAdvance();}&lt;/pre&gt;
 205  *
 206  * &lt;p&gt;Related constructions may be used to await particular phase numbers
 207  * in contexts where you are sure that the phase will never wrap around
 208  * {@code Integer.MAX_VALUE}. For example:
 209  *
 210  * &lt;pre&gt; {@code
 211  * void awaitPhase(Phaser phaser, int phase) {
 212  *   int p = phaser.register(); // assumes caller not already registered
 213  *   while (p &lt; phase) {
 214  *     if (phaser.isTerminated())
 215  *       // ... deal with unexpected termination
 216  *     else
 217  *       p = phaser.arriveAndAwaitAdvance();
 218  *   }
 219  *   phaser.arriveAndDeregister();
 220  * }}&lt;/pre&gt;
 221  *
 222  * &lt;p&gt;To create a set of {@code n} tasks using a tree of phasers, you
 223  * could use code of the following form, assuming a Task class with a
 224  * constructor accepting a {@code Phaser} that it registers with upon
 225  * construction. After invocation of {@code build(new Task[n], 0, n,
 226  * new Phaser())}, these tasks could then be started, for example by
 227  * submitting to a pool:
 228  *
 229  * &lt;pre&gt; {@code
 230  * void build(Task[] tasks, int lo, int hi, Phaser ph) {
 231  *   if (hi - lo &gt; TASKS_PER_PHASER) {
 232  *     for (int i = lo; i &lt; hi; i += TASKS_PER_PHASER) {
 233  *       int j = Math.min(i + TASKS_PER_PHASER, hi);
 234  *       build(tasks, i, j, new Phaser(ph));
 235  *     }
 236  *   } else {
 237  *     for (int i = lo; i &lt; hi; ++i)
 238  *       tasks[i] = new Task(ph);
 239  *       // assumes new Task(ph) performs ph.register()
 240  *   }
 241  * }}&lt;/pre&gt;
 242  *
 243  * The best value of {@code TASKS_PER_PHASER} depends mainly on
 244  * expected synchronization rates. A value as low as four may
 245  * be appropriate for extremely small per-phase task bodies (thus
 246  * high rates), or up to hundreds for extremely large ones.
 247  *
 248  * &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
 249  * maximum number of parties to 65535. Attempts to register additional
 250  * parties result in {@code IllegalStateException}. However, you can and
 251  * should create tiered phasers to accommodate arbitrarily large sets
 252  * of participants.
 253  *
 254  * @since 1.7
 255  * @author Doug Lea
 256  */
 257 public class Phaser {
 258     /*
 259      * This class implements an extension of X10 &quot;clocks&quot;.  Thanks to
 260      * Vijay Saraswat for the idea, and to Vivek Sarkar for
 261      * enhancements to extend functionality.
 262      */
 263 
 264     /**
 265      * Primary state representation, holding four bit-fields:
 266      *
 267      * unarrived  -- the number of parties yet to hit barrier (bits  0-15)
 268      * parties    -- the number of parties to wait            (bits 16-31)
 269      * phase      -- the generation of the barrier            (bits 32-62)
 270      * terminated -- set if barrier is terminated             (bit  63 / sign)
 271      *
 272      * Except that a phaser with no registered parties is
 273      * distinguished by the otherwise illegal state of having zero
 274      * parties and one unarrived parties (encoded as EMPTY below).
 275      *
 276      * To efficiently maintain atomicity, these values are packed into
 277      * a single (atomic) long. Good performance relies on keeping
 278      * state decoding and encoding simple, and keeping race windows
 279      * short.
 280      *
 281      * All state updates are performed via CAS except initial
 282      * registration of a sub-phaser (i.e., one with a non-null
 283      * parent).  In this (relatively rare) case, we use built-in
 284      * synchronization to lock while first registering with its
 285      * parent.
 286      *
 287      * The phase of a subphaser is allowed to lag that of its
 288      * ancestors until it is actually accessed -- see method
 289      * reconcileState.
 290      */
 291     private volatile long state;
 292 
 293     private static final int  MAX_PARTIES     = 0xffff;
 294     private static final int  MAX_PHASE       = Integer.MAX_VALUE;
 295     private static final int  PARTIES_SHIFT   = 16;
 296     private static final int  PHASE_SHIFT     = 32;
 297     private static final int  UNARRIVED_MASK  = 0xffff;      // to mask ints
 298     private static final long PARTIES_MASK    = 0xffff0000L; // to mask longs
 299     private static final long COUNTS_MASK     = 0xffffffffL;
 300     private static final long TERMINATION_BIT = 1L &lt;&lt; 63;
 301 
 302     // some special values
 303     private static final int  ONE_ARRIVAL     = 1;
 304     private static final int  ONE_PARTY       = 1 &lt;&lt; PARTIES_SHIFT;
 305     private static final int  ONE_DEREGISTER  = ONE_ARRIVAL|ONE_PARTY;
 306     private static final int  EMPTY           = 1;
 307 
 308     // The following unpacking methods are usually manually inlined
 309 
 310     private static int unarrivedOf(long s) {
 311         int counts = (int)s;
 312         return (counts == EMPTY) ? 0 : (counts &amp; UNARRIVED_MASK);
 313     }
 314 
 315     private static int partiesOf(long s) {
 316         return (int)s &gt;&gt;&gt; PARTIES_SHIFT;
 317     }
 318 
 319     private static int phaseOf(long s) {
 320         return (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 321     }
 322 
 323     private static int arrivedOf(long s) {
 324         int counts = (int)s;
 325         return (counts == EMPTY) ? 0 :
 326             (counts &gt;&gt;&gt; PARTIES_SHIFT) - (counts &amp; UNARRIVED_MASK);
 327     }
 328 
 329     /**
 330      * The parent of this phaser, or null if none.
 331      */
 332     private final Phaser parent;
 333 
 334     /**
 335      * The root of phaser tree. Equals this if not in a tree.
 336      */
 337     private final Phaser root;
 338 
 339     /**
 340      * Heads of Treiber stacks for waiting threads. To eliminate
 341      * contention when releasing some threads while adding others, we
 342      * use two of them, alternating across even and odd phases.
 343      * Subphasers share queues with root to speed up releases.
 344      */
 345     private final AtomicReference&lt;QNode&gt; evenQ;
 346     private final AtomicReference&lt;QNode&gt; oddQ;
 347 
 348     /**
 349      * Returns message string for bounds exceptions on arrival.
 350      */
 351     private String badArrive(long s) {
 352         return &quot;Attempted arrival of unregistered party for &quot; +
 353             stateToString(s);
 354     }
 355 
 356     /**
 357      * Returns message string for bounds exceptions on registration.
 358      */
 359     private String badRegister(long s) {
 360         return &quot;Attempt to register more than &quot; +
 361             MAX_PARTIES + &quot; parties for &quot; + stateToString(s);
 362     }
 363 
 364     /**
 365      * Main implementation for methods arrive and arriveAndDeregister.
 366      * Manually tuned to speed up and minimize race windows for the
 367      * common case of just decrementing unarrived field.
 368      *
 369      * @param adjust value to subtract from state;
 370      *               ONE_ARRIVAL for arrive,
 371      *               ONE_DEREGISTER for arriveAndDeregister
 372      */
 373     private int doArrive(int adjust) {
 374         final Phaser root = this.root;
 375         for (;;) {
 376             long s = (root == this) ? state : reconcileState();
 377             int phase = (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 378             if (phase &lt; 0)
 379                 return phase;
 380             int counts = (int)s;
 381             int unarrived = (counts == EMPTY) ? 0 : (counts &amp; UNARRIVED_MASK);
 382             if (unarrived &lt;= 0)
 383                 throw new IllegalStateException(badArrive(s));
 384             if (STATE.compareAndSet(this, s, s-=adjust)) {
 385                 if (unarrived == 1) {
 386                     long n = s &amp; PARTIES_MASK;  // base of next state
 387                     int nextUnarrived = (int)n &gt;&gt;&gt; PARTIES_SHIFT;
 388                     if (root == this) {
 389                         if (onAdvance(phase, nextUnarrived))
 390                             n |= TERMINATION_BIT;
 391                         else if (nextUnarrived == 0)
 392                             n |= EMPTY;
 393                         else
 394                             n |= nextUnarrived;
 395                         int nextPhase = (phase + 1) &amp; MAX_PHASE;
 396                         n |= (long)nextPhase &lt;&lt; PHASE_SHIFT;
 397                         STATE.compareAndSet(this, s, n);
 398                         releaseWaiters(phase);
 399                     }
 400                     else if (nextUnarrived == 0) { // propagate deregistration
 401                         phase = parent.doArrive(ONE_DEREGISTER);
 402                         STATE.compareAndSet(this, s, s | EMPTY);
 403                     }
 404                     else
 405                         phase = parent.doArrive(ONE_ARRIVAL);
 406                 }
 407                 return phase;
 408             }
 409         }
 410     }
 411 
 412     /**
 413      * Implementation of register, bulkRegister.
 414      *
 415      * @param registrations number to add to both parties and
 416      * unarrived fields. Must be greater than zero.
 417      */
 418     private int doRegister(int registrations) {
 419         // adjustment to state
 420         long adjust = ((long)registrations &lt;&lt; PARTIES_SHIFT) | registrations;
 421         final Phaser parent = this.parent;
 422         int phase;
 423         for (;;) {
 424             long s = (parent == null) ? state : reconcileState();
 425             int counts = (int)s;
 426             int parties = counts &gt;&gt;&gt; PARTIES_SHIFT;
 427             int unarrived = counts &amp; UNARRIVED_MASK;
 428             if (registrations &gt; MAX_PARTIES - parties)
 429                 throw new IllegalStateException(badRegister(s));
 430             phase = (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 431             if (phase &lt; 0)
 432                 break;
 433             if (counts != EMPTY) {                  // not 1st registration
 434                 if (parent == null || reconcileState() == s) {
 435                     if (unarrived == 0)             // wait out advance
 436                         root.internalAwaitAdvance(phase, null);
 437                     else if (STATE.compareAndSet(this, s, s + adjust))
 438                         break;
 439                 }
 440             }
 441             else if (parent == null) {              // 1st root registration
 442                 long next = ((long)phase &lt;&lt; PHASE_SHIFT) | adjust;
 443                 if (STATE.compareAndSet(this, s, next))
 444                     break;
 445             }
 446             else {
 447                 synchronized (this) {               // 1st sub registration
 448                     if (state == s) {               // recheck under lock
 449                         phase = parent.doRegister(1);
 450                         if (phase &lt; 0)
 451                             break;
 452                         // finish registration whenever parent registration
 453                         // succeeded, even when racing with termination,
 454                         // since these are part of the same &quot;transaction&quot;.
 455                         while (!STATE.weakCompareAndSet
 456                                (this, s,
 457                                 ((long)phase &lt;&lt; PHASE_SHIFT) | adjust)) {
 458                             s = state;
 459                             phase = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT);
 460                             // assert (int)s == EMPTY;
 461                         }
 462                         break;
 463                     }
 464                 }
 465             }
 466         }
 467         return phase;
 468     }
 469 
 470     /**
 471      * Resolves lagged phase propagation from root if necessary.
 472      * Reconciliation normally occurs when root has advanced but
 473      * subphasers have not yet done so, in which case they must finish
 474      * their own advance by setting unarrived to parties (or if
 475      * parties is zero, resetting to unregistered EMPTY state).
 476      *
 477      * @return reconciled state
 478      */
 479     private long reconcileState() {
 480         final Phaser root = this.root;
 481         long s = state;
 482         if (root != this) {
 483             int phase, p;
 484             // CAS to root phase with current parties, tripping unarrived
 485             while ((phase = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT)) !=
 486                    (int)(s &gt;&gt;&gt; PHASE_SHIFT) &amp;&amp;
 487                    !STATE.weakCompareAndSet
 488                    (this, s,
 489                     s = (((long)phase &lt;&lt; PHASE_SHIFT) |
 490                          ((phase &lt; 0) ? (s &amp; COUNTS_MASK) :
 491                           (((p = (int)s &gt;&gt;&gt; PARTIES_SHIFT) == 0) ? EMPTY :
 492                            ((s &amp; PARTIES_MASK) | p))))))
 493                 s = state;
 494         }
 495         return s;
 496     }
 497 
 498     /**
 499      * Creates a new phaser with no initially registered parties, no
 500      * parent, and initial phase number 0. Any thread using this
 501      * phaser will need to first register for it.
 502      */
 503     public Phaser() {
 504         this(null, 0);
 505     }
 506 
 507     /**
 508      * Creates a new phaser with the given number of registered
 509      * unarrived parties, no parent, and initial phase number 0.
 510      *
 511      * @param parties the number of parties required to advance to the
 512      * next phase
 513      * @throws IllegalArgumentException if parties less than zero
 514      * or greater than the maximum number of parties supported
 515      */
 516     public Phaser(int parties) {
 517         this(null, parties);
 518     }
 519 
 520     /**
 521      * Equivalent to {@link #Phaser(Phaser, int) Phaser(parent, 0)}.
 522      *
 523      * @param parent the parent phaser
 524      */
 525     public Phaser(Phaser parent) {
 526         this(parent, 0);
 527     }
 528 
 529     /**
 530      * Creates a new phaser with the given parent and number of
 531      * registered unarrived parties.  When the given parent is non-null
 532      * and the given number of parties is greater than zero, this
 533      * child phaser is registered with its parent.
 534      *
 535      * @param parent the parent phaser
 536      * @param parties the number of parties required to advance to the
 537      * next phase
 538      * @throws IllegalArgumentException if parties less than zero
 539      * or greater than the maximum number of parties supported
 540      */
 541     public Phaser(Phaser parent, int parties) {
 542         if (parties &gt;&gt;&gt; PARTIES_SHIFT != 0)
 543             throw new IllegalArgumentException(&quot;Illegal number of parties&quot;);
 544         int phase = 0;
 545         this.parent = parent;
 546         if (parent != null) {
 547             final Phaser root = parent.root;
 548             this.root = root;
 549             this.evenQ = root.evenQ;
 550             this.oddQ = root.oddQ;
 551             if (parties != 0)
 552                 phase = parent.doRegister(1);
 553         }
 554         else {
 555             this.root = this;
 556             this.evenQ = new AtomicReference&lt;QNode&gt;();
 557             this.oddQ = new AtomicReference&lt;QNode&gt;();
 558         }
 559         this.state = (parties == 0) ? (long)EMPTY :
 560             ((long)phase &lt;&lt; PHASE_SHIFT) |
 561             ((long)parties &lt;&lt; PARTIES_SHIFT) |
 562             ((long)parties);
 563     }
 564 
 565     /**
 566      * Adds a new unarrived party to this phaser.  If an ongoing
 567      * invocation of {@link #onAdvance} is in progress, this method
 568      * may await its completion before returning.  If this phaser has
 569      * a parent, and this phaser previously had no registered parties,
 570      * this child phaser is also registered with its parent. If
 571      * this phaser is terminated, the attempt to register has
 572      * no effect, and a negative value is returned.
 573      *
 574      * @return the arrival phase number to which this registration
 575      * applied.  If this value is negative, then this phaser has
 576      * terminated, in which case registration has no effect.
 577      * @throws IllegalStateException if attempting to register more
 578      * than the maximum supported number of parties
 579      */
 580     public int register() {
 581         return doRegister(1);
 582     }
 583 
 584     /**
 585      * Adds the given number of new unarrived parties to this phaser.
 586      * If an ongoing invocation of {@link #onAdvance} is in progress,
 587      * this method may await its completion before returning.  If this
 588      * phaser has a parent, and the given number of parties is greater
 589      * than zero, and this phaser previously had no registered
 590      * parties, this child phaser is also registered with its parent.
 591      * If this phaser is terminated, the attempt to register has no
 592      * effect, and a negative value is returned.
 593      *
 594      * @param parties the number of additional parties required to
 595      * advance to the next phase
 596      * @return the arrival phase number to which this registration
 597      * applied.  If this value is negative, then this phaser has
 598      * terminated, in which case registration has no effect.
 599      * @throws IllegalStateException if attempting to register more
 600      * than the maximum supported number of parties
 601      * @throws IllegalArgumentException if {@code parties &lt; 0}
 602      */
 603     public int bulkRegister(int parties) {
 604         if (parties &lt; 0)
 605             throw new IllegalArgumentException();
 606         if (parties == 0)
 607             return getPhase();
 608         return doRegister(parties);
 609     }
 610 
 611     /**
 612      * Arrives at this phaser, without waiting for others to arrive.
 613      *
 614      * &lt;p&gt;It is a usage error for an unregistered party to invoke this
 615      * method.  However, this error may result in an {@code
 616      * IllegalStateException} only upon some subsequent operation on
 617      * this phaser, if ever.
 618      *
 619      * @return the arrival phase number, or a negative value if terminated
 620      * @throws IllegalStateException if not terminated and the number
 621      * of unarrived parties would become negative
 622      */
 623     public int arrive() {
 624         return doArrive(ONE_ARRIVAL);
 625     }
 626 
 627     /**
 628      * Arrives at this phaser and deregisters from it without waiting
 629      * for others to arrive. Deregistration reduces the number of
 630      * parties required to advance in future phases.  If this phaser
 631      * has a parent, and deregistration causes this phaser to have
 632      * zero parties, this phaser is also deregistered from its parent.
 633      *
 634      * &lt;p&gt;It is a usage error for an unregistered party to invoke this
 635      * method.  However, this error may result in an {@code
 636      * IllegalStateException} only upon some subsequent operation on
 637      * this phaser, if ever.
 638      *
 639      * @return the arrival phase number, or a negative value if terminated
 640      * @throws IllegalStateException if not terminated and the number
 641      * of registered or unarrived parties would become negative
 642      */
 643     public int arriveAndDeregister() {
 644         return doArrive(ONE_DEREGISTER);
 645     }
 646 
 647     /**
 648      * Arrives at this phaser and awaits others. Equivalent in effect
 649      * to {@code awaitAdvance(arrive())}.  If you need to await with
 650      * interruption or timeout, you can arrange this with an analogous
 651      * construction using one of the other forms of the {@code
 652      * awaitAdvance} method.  If instead you need to deregister upon
 653      * arrival, use {@code awaitAdvance(arriveAndDeregister())}.
 654      *
 655      * &lt;p&gt;It is a usage error for an unregistered party to invoke this
 656      * method.  However, this error may result in an {@code
 657      * IllegalStateException} only upon some subsequent operation on
 658      * this phaser, if ever.
 659      *
 660      * @return the arrival phase number, or the (negative)
 661      * {@linkplain #getPhase() current phase} if terminated
 662      * @throws IllegalStateException if not terminated and the number
 663      * of unarrived parties would become negative
 664      */
 665     public int arriveAndAwaitAdvance() {
 666         // Specialization of doArrive+awaitAdvance eliminating some reads/paths
 667         final Phaser root = this.root;
 668         for (;;) {
 669             long s = (root == this) ? state : reconcileState();
 670             int phase = (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 671             if (phase &lt; 0)
 672                 return phase;
 673             int counts = (int)s;
 674             int unarrived = (counts == EMPTY) ? 0 : (counts &amp; UNARRIVED_MASK);
 675             if (unarrived &lt;= 0)
 676                 throw new IllegalStateException(badArrive(s));
 677             if (STATE.compareAndSet(this, s, s -= ONE_ARRIVAL)) {
 678                 if (unarrived &gt; 1)
 679                     return root.internalAwaitAdvance(phase, null);
 680                 if (root != this)
 681                     return parent.arriveAndAwaitAdvance();
 682                 long n = s &amp; PARTIES_MASK;  // base of next state
 683                 int nextUnarrived = (int)n &gt;&gt;&gt; PARTIES_SHIFT;
 684                 if (onAdvance(phase, nextUnarrived))
 685                     n |= TERMINATION_BIT;
 686                 else if (nextUnarrived == 0)
 687                     n |= EMPTY;
 688                 else
 689                     n |= nextUnarrived;
 690                 int nextPhase = (phase + 1) &amp; MAX_PHASE;
 691                 n |= (long)nextPhase &lt;&lt; PHASE_SHIFT;
 692                 if (!STATE.compareAndSet(this, s, n))
 693                     return (int)(state &gt;&gt;&gt; PHASE_SHIFT); // terminated
 694                 releaseWaiters(phase);
 695                 return nextPhase;
 696             }
 697         }
 698     }
 699 
 700     /**
 701      * Awaits the phase of this phaser to advance from the given phase
 702      * value, returning immediately if the current phase is not equal
 703      * to the given phase value or this phaser is terminated.
 704      *
 705      * @param phase an arrival phase number, or negative value if
 706      * terminated; this argument is normally the value returned by a
 707      * previous call to {@code arrive} or {@code arriveAndDeregister}.
 708      * @return the next arrival phase number, or the argument if it is
 709      * negative, or the (negative) {@linkplain #getPhase() current phase}
 710      * if terminated
 711      */
 712     public int awaitAdvance(int phase) {
 713         final Phaser root = this.root;
 714         long s = (root == this) ? state : reconcileState();
 715         int p = (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 716         if (phase &lt; 0)
 717             return phase;
 718         if (p == phase)
 719             return root.internalAwaitAdvance(phase, null);
 720         return p;
 721     }
 722 
 723     /**
 724      * Awaits the phase of this phaser to advance from the given phase
 725      * value, throwing {@code InterruptedException} if interrupted
 726      * while waiting, or returning immediately if the current phase is
 727      * not equal to the given phase value or this phaser is
 728      * terminated.
 729      *
 730      * @param phase an arrival phase number, or negative value if
 731      * terminated; this argument is normally the value returned by a
 732      * previous call to {@code arrive} or {@code arriveAndDeregister}.
 733      * @return the next arrival phase number, or the argument if it is
 734      * negative, or the (negative) {@linkplain #getPhase() current phase}
 735      * if terminated
 736      * @throws InterruptedException if thread interrupted while waiting
 737      */
 738     public int awaitAdvanceInterruptibly(int phase)
 739         throws InterruptedException {
 740         final Phaser root = this.root;
 741         long s = (root == this) ? state : reconcileState();
 742         int p = (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 743         if (phase &lt; 0)
 744             return phase;
 745         if (p == phase) {
 746             QNode node = new QNode(this, phase, true, false, 0L);
 747             p = root.internalAwaitAdvance(phase, node);
 748             if (node.wasInterrupted)
 749                 throw new InterruptedException();
 750         }
 751         return p;
 752     }
 753 
 754     /**
 755      * Awaits the phase of this phaser to advance from the given phase
 756      * value or the given timeout to elapse, throwing {@code
 757      * InterruptedException} if interrupted while waiting, or
 758      * returning immediately if the current phase is not equal to the
 759      * given phase value or this phaser is terminated.
 760      *
 761      * @param phase an arrival phase number, or negative value if
 762      * terminated; this argument is normally the value returned by a
 763      * previous call to {@code arrive} or {@code arriveAndDeregister}.
 764      * @param timeout how long to wait before giving up, in units of
 765      *        {@code unit}
 766      * @param unit a {@code TimeUnit} determining how to interpret the
 767      *        {@code timeout} parameter
 768      * @return the next arrival phase number, or the argument if it is
 769      * negative, or the (negative) {@linkplain #getPhase() current phase}
 770      * if terminated
 771      * @throws InterruptedException if thread interrupted while waiting
 772      * @throws TimeoutException if timed out while waiting
 773      */
 774     public int awaitAdvanceInterruptibly(int phase,
 775                                          long timeout, TimeUnit unit)
 776         throws InterruptedException, TimeoutException {
 777         long nanos = unit.toNanos(timeout);
 778         final Phaser root = this.root;
 779         long s = (root == this) ? state : reconcileState();
 780         int p = (int)(s &gt;&gt;&gt; PHASE_SHIFT);
 781         if (phase &lt; 0)
 782             return phase;
 783         if (p == phase) {
 784             QNode node = new QNode(this, phase, true, true, nanos);
 785             p = root.internalAwaitAdvance(phase, node);
 786             if (node.wasInterrupted)
 787                 throw new InterruptedException();
 788             else if (p == phase)
 789                 throw new TimeoutException();
 790         }
 791         return p;
 792     }
 793 
 794     /**
 795      * Forces this phaser to enter termination state.  Counts of
 796      * registered parties are unaffected.  If this phaser is a member
 797      * of a tiered set of phasers, then all of the phasers in the set
 798      * are terminated.  If this phaser is already terminated, this
 799      * method has no effect.  This method may be useful for
 800      * coordinating recovery after one or more tasks encounter
 801      * unexpected exceptions.
 802      */
 803     public void forceTermination() {
 804         // Only need to change root state
 805         final Phaser root = this.root;
 806         long s;
 807         while ((s = root.state) &gt;= 0) {
 808             if (STATE.compareAndSet(root, s, s | TERMINATION_BIT)) {
 809                 // signal all threads
 810                 releaseWaiters(0); // Waiters on evenQ
 811                 releaseWaiters(1); // Waiters on oddQ
 812                 return;
 813             }
 814         }
 815     }
 816 
 817     /**
 818      * Returns the current phase number. The maximum phase number is
 819      * {@code Integer.MAX_VALUE}, after which it restarts at
 820      * zero. Upon termination, the phase number is negative,
 821      * in which case the prevailing phase prior to termination
 822      * may be obtained via {@code getPhase() + Integer.MIN_VALUE}.
 823      *
 824      * @return the phase number, or a negative value if terminated
 825      */
 826     public final int getPhase() {
 827         return (int)(root.state &gt;&gt;&gt; PHASE_SHIFT);
 828     }
 829 
 830     /**
 831      * Returns the number of parties registered at this phaser.
 832      *
 833      * @return the number of parties
 834      */
 835     public int getRegisteredParties() {
 836         return partiesOf(state);
 837     }
 838 
 839     /**
 840      * Returns the number of registered parties that have arrived at
 841      * the current phase of this phaser. If this phaser has terminated,
 842      * the returned value is meaningless and arbitrary.
 843      *
 844      * @return the number of arrived parties
 845      */
 846     public int getArrivedParties() {
 847         return arrivedOf(reconcileState());
 848     }
 849 
 850     /**
 851      * Returns the number of registered parties that have not yet
 852      * arrived at the current phase of this phaser. If this phaser has
 853      * terminated, the returned value is meaningless and arbitrary.
 854      *
 855      * @return the number of unarrived parties
 856      */
 857     public int getUnarrivedParties() {
 858         return unarrivedOf(reconcileState());
 859     }
 860 
 861     /**
 862      * Returns the parent of this phaser, or {@code null} if none.
 863      *
 864      * @return the parent of this phaser, or {@code null} if none
 865      */
 866     public Phaser getParent() {
 867         return parent;
 868     }
 869 
 870     /**
 871      * Returns the root ancestor of this phaser, which is the same as
 872      * this phaser if it has no parent.
 873      *
 874      * @return the root ancestor of this phaser
 875      */
 876     public Phaser getRoot() {
 877         return root;
 878     }
 879 
 880     /**
 881      * Returns {@code true} if this phaser has been terminated.
 882      *
 883      * @return {@code true} if this phaser has been terminated
 884      */
 885     public boolean isTerminated() {
 886         return root.state &lt; 0L;
 887     }
 888 
 889     /**
 890      * Overridable method to perform an action upon impending phase
 891      * advance, and to control termination. This method is invoked
 892      * upon arrival of the party advancing this phaser (when all other
 893      * waiting parties are dormant).  If this method returns {@code
 894      * true}, this phaser will be set to a final termination state
 895      * upon advance, and subsequent calls to {@link #isTerminated}
 896      * will return true. Any (unchecked) Exception or Error thrown by
 897      * an invocation of this method is propagated to the party
 898      * attempting to advance this phaser, in which case no advance
 899      * occurs.
 900      *
 901      * &lt;p&gt;The arguments to this method provide the state of the phaser
 902      * prevailing for the current transition.  The effects of invoking
 903      * arrival, registration, and waiting methods on this phaser from
 904      * within {@code onAdvance} are unspecified and should not be
 905      * relied on.
 906      *
 907      * &lt;p&gt;If this phaser is a member of a tiered set of phasers, then
 908      * {@code onAdvance} is invoked only for its root phaser on each
 909      * advance.
 910      *
 911      * &lt;p&gt;To support the most common use cases, the default
 912      * implementation of this method returns {@code true} when the
 913      * number of registered parties has become zero as the result of a
 914      * party invoking {@code arriveAndDeregister}.  You can disable
 915      * this behavior, thus enabling continuation upon future
 916      * registrations, by overriding this method to always return
 917      * {@code false}:
 918      *
 919      * &lt;pre&gt; {@code
 920      * Phaser phaser = new Phaser() {
 921      *   protected boolean onAdvance(int phase, int parties) { return false; }
 922      * }}&lt;/pre&gt;
 923      *
 924      * @param phase the current phase number on entry to this method,
 925      * before this phaser is advanced
 926      * @param registeredParties the current number of registered parties
 927      * @return {@code true} if this phaser should terminate
 928      */
 929     protected boolean onAdvance(int phase, int registeredParties) {
 930         return registeredParties == 0;
 931     }
 932 
 933     /**
 934      * Returns a string identifying this phaser, as well as its
 935      * state.  The state, in brackets, includes the String {@code
 936      * &quot;phase = &quot;} followed by the phase number, {@code &quot;parties = &quot;}
 937      * followed by the number of registered parties, and {@code
 938      * &quot;arrived = &quot;} followed by the number of arrived parties.
 939      *
 940      * @return a string identifying this phaser, as well as its state
 941      */
 942     public String toString() {
 943         return stateToString(reconcileState());
 944     }
 945 
 946     /**
 947      * Implementation of toString and string-based error messages.
 948      */
 949     private String stateToString(long s) {
 950         return super.toString() +
 951             &quot;[phase = &quot; + phaseOf(s) +
 952             &quot; parties = &quot; + partiesOf(s) +
 953             &quot; arrived = &quot; + arrivedOf(s) + &quot;]&quot;;
 954     }
 955 
 956     // Waiting mechanics
 957 
 958     /**
 959      * Removes and signals threads from queue for phase.
 960      */
 961     private void releaseWaiters(int phase) {
 962         QNode q;   // first element of queue
 963         Thread t;  // its thread
 964         AtomicReference&lt;QNode&gt; head = (phase &amp; 1) == 0 ? evenQ : oddQ;
 965         while ((q = head.get()) != null &amp;&amp;
 966                q.phase != (int)(root.state &gt;&gt;&gt; PHASE_SHIFT)) {
 967             if (head.compareAndSet(q, q.next) &amp;&amp;
 968                 (t = q.thread) != null) {
 969                 q.thread = null;
 970                 LockSupport.unpark(t);
 971             }
 972         }
 973     }
 974 
 975     /**
 976      * Variant of releaseWaiters that additionally tries to remove any
 977      * nodes no longer waiting for advance due to timeout or
 978      * interrupt. Currently, nodes are removed only if they are at
 979      * head of queue, which suffices to reduce memory footprint in
 980      * most usages.
 981      *
 982      * @return current phase on exit
 983      */
 984     private int abortWait(int phase) {
 985         AtomicReference&lt;QNode&gt; head = (phase &amp; 1) == 0 ? evenQ : oddQ;
 986         for (;;) {
 987             Thread t;
 988             QNode q = head.get();
 989             int p = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT);
 990             if (q == null || ((t = q.thread) != null &amp;&amp; q.phase == p))
 991                 return p;
 992             if (head.compareAndSet(q, q.next) &amp;&amp; t != null) {
 993                 q.thread = null;
 994                 LockSupport.unpark(t);
 995             }
 996         }
 997     }
 998 
 999     /** The number of CPUs, for spin control */
1000     private static final int NCPU = Runtime.getRuntime().availableProcessors();
1001 
1002     /**
1003      * The number of times to spin before blocking while waiting for
1004      * advance, per arrival while waiting. On multiprocessors, fully
1005      * blocking and waking up a large number of threads all at once is
1006      * usually a very slow process, so we use rechargeable spins to
1007      * avoid it when threads regularly arrive: When a thread in
1008      * internalAwaitAdvance notices another arrival before blocking,
1009      * and there appear to be enough CPUs available, it spins
1010      * SPINS_PER_ARRIVAL more times before blocking. The value trades
1011      * off good-citizenship vs big unnecessary slowdowns.
1012      */
1013     static final int SPINS_PER_ARRIVAL = (NCPU &lt; 2) ? 1 : 1 &lt;&lt; 8;
1014 
1015     /**
1016      * Possibly blocks and waits for phase to advance unless aborted.
1017      * Call only on root phaser.
1018      *
1019      * @param phase current phase
1020      * @param node if non-null, the wait node to track interrupt and timeout;
1021      * if null, denotes noninterruptible wait
1022      * @return current phase
1023      */
1024     private int internalAwaitAdvance(int phase, QNode node) {
1025         // assert root == this;
1026         releaseWaiters(phase-1);          // ensure old queue clean
1027         boolean queued = false;           // true when node is enqueued
1028         int lastUnarrived = 0;            // to increase spins upon change
1029         int spins = SPINS_PER_ARRIVAL;
1030         long s;
1031         int p;
1032         while ((p = (int)((s = state) &gt;&gt;&gt; PHASE_SHIFT)) == phase) {
1033             if (node == null) {           // spinning in noninterruptible mode
1034                 int unarrived = (int)s &amp; UNARRIVED_MASK;
1035                 if (unarrived != lastUnarrived &amp;&amp;
1036                     (lastUnarrived = unarrived) &lt; NCPU)
1037                     spins += SPINS_PER_ARRIVAL;
1038                 boolean interrupted = Thread.interrupted();
1039                 if (interrupted || --spins &lt; 0) { // need node to record intr
1040                     node = new QNode(this, phase, false, false, 0L);
1041                     node.wasInterrupted = interrupted;
1042                 }
1043                 else
1044                     Thread.onSpinWait();
1045             }
1046             else if (node.isReleasable()) // done or aborted
1047                 break;
1048             else if (!queued) {           // push onto queue
1049                 AtomicReference&lt;QNode&gt; head = (phase &amp; 1) == 0 ? evenQ : oddQ;
1050                 QNode q = node.next = head.get();
1051                 if ((q == null || q.phase == phase) &amp;&amp;
1052                     (int)(state &gt;&gt;&gt; PHASE_SHIFT) == phase) // avoid stale enq
1053                     queued = head.compareAndSet(q, node);
1054             }
1055             else {
1056                 try {
1057                     ForkJoinPool.managedBlock(node);
1058                 } catch (InterruptedException cantHappen) {
1059                     node.wasInterrupted = true;
1060                 }
1061             }
1062         }
1063 
1064         if (node != null) {
1065             if (node.thread != null)
1066                 node.thread = null;       // avoid need for unpark()
1067             if (node.wasInterrupted &amp;&amp; !node.interruptible)
1068                 Thread.currentThread().interrupt();
1069             if (p == phase &amp;&amp; (p = (int)(state &gt;&gt;&gt; PHASE_SHIFT)) == phase)
1070                 return abortWait(phase); // possibly clean up on abort
1071         }
1072         releaseWaiters(phase);
1073         return p;
1074     }
1075 
1076     /**
1077      * Wait nodes for Treiber stack representing wait queue.
1078      */
1079     static final class QNode implements ForkJoinPool.ManagedBlocker {
1080         final Phaser phaser;
1081         final int phase;
1082         final boolean interruptible;
1083         final boolean timed;
1084         boolean wasInterrupted;
1085         long nanos;
1086         final long deadline;
1087         volatile Thread thread; // nulled to cancel wait
1088         QNode next;
1089 
1090         QNode(Phaser phaser, int phase, boolean interruptible,
1091               boolean timed, long nanos) {
1092             this.phaser = phaser;
1093             this.phase = phase;
1094             this.interruptible = interruptible;
1095             this.nanos = nanos;
1096             this.timed = timed;
1097             this.deadline = timed ? System.nanoTime() + nanos : 0L;
1098             thread = Thread.currentThread();
1099         }
1100 
1101         public boolean isReleasable() {
1102             if (thread == null)
1103                 return true;
1104             if (phaser.getPhase() != phase) {
1105                 thread = null;
1106                 return true;
1107             }
1108             if (Thread.interrupted())
1109                 wasInterrupted = true;
1110             if (wasInterrupted &amp;&amp; interruptible) {
1111                 thread = null;
1112                 return true;
1113             }
1114             if (timed &amp;&amp;
1115                 (nanos &lt;= 0L || (nanos = deadline - System.nanoTime()) &lt;= 0L)) {
1116                 thread = null;
1117                 return true;
1118             }
1119             return false;
1120         }
1121 
1122         public boolean block() {
1123             while (!isReleasable()) {
1124                 if (timed)
1125                     LockSupport.parkNanos(this, nanos);
1126                 else
1127                     LockSupport.park(this);
1128             }
1129             return true;
1130         }
1131     }
1132 
1133     // VarHandle mechanics
1134     private static final VarHandle STATE;
1135     static {
1136         try {
1137             MethodHandles.Lookup l = MethodHandles.lookup();
1138             STATE = l.findVarHandle(Phaser.class, &quot;state&quot;, long.class);
1139         } catch (ReflectiveOperationException e) {
1140             throw new ExceptionInInitializerError(e);
1141         }
1142 
1143         // Reduce the risk of rare disastrous classloading in first call to
1144         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773
1145         Class&lt;?&gt; ensureLoaded = LockSupport.class;
1146     }
1147 }
    </pre>
  </body>
</html>
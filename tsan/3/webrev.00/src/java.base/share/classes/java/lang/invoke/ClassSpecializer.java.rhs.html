<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
<a name="2" id="anc2"></a><span class="line-added">  28 import jdk.internal.access.SharedSecrets;</span>
  29 import jdk.internal.loader.BootLoader;
  30 import jdk.internal.org.objectweb.asm.ClassWriter;
  31 import jdk.internal.org.objectweb.asm.FieldVisitor;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.vm.annotation.Stable;
  34 import sun.invoke.util.BytecodeName;
  35 
  36 import java.lang.reflect.Constructor;
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.security.AccessController;
  40 import java.security.PrivilegedAction;
<a name="3" id="anc3"></a><span class="line-added">  41 import java.security.ProtectionDomain;</span>
  42 import java.util.ArrayList;
  43 import java.util.Collections;
  44 import java.util.List;
  45 import java.util.Objects;
  46 import java.util.concurrent.ConcurrentHashMap;
  47 import java.util.function.Function;
  48 
  49 import static java.lang.invoke.LambdaForm.*;
  50 import static java.lang.invoke.MethodHandleNatives.Constants.REF_getStatic;
  51 import static java.lang.invoke.MethodHandleNatives.Constants.REF_putStatic;
  52 import static java.lang.invoke.MethodHandleStatics.*;
  53 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  54 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  55 
  56 /**
  57  * Class specialization code.
  58  * @param &lt;T&gt; top class under which species classes are created.
  59  * @param &lt;K&gt; key which identifies individual specializations.
  60  * @param &lt;S&gt; species data type.
  61  */
  62 /*non-public*/
  63 abstract class ClassSpecializer&lt;T,K,S extends ClassSpecializer&lt;T,K,S&gt;.SpeciesData&gt; {
  64     private final Class&lt;T&gt; topClass;
  65     private final Class&lt;K&gt; keyType;
  66     private final Class&lt;S&gt; metaType;
  67     private final MemberName sdAccessor;
  68     private final String sdFieldName;
  69     private final List&lt;MemberName&gt; transformMethods;
  70     private final MethodType baseConstructorType;
  71     private final S topSpecies;
  72     private final ConcurrentHashMap&lt;K, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();
  73     private final Factory factory;
  74     private @Stable boolean topClassIsSuper;
  75 
  76     /** Return the top type mirror, for type {@code T} */
  77     public final Class&lt;T&gt; topClass() { return topClass; }
  78 
  79     /** Return the key type mirror, for type {@code K} */
  80     public final Class&lt;K&gt; keyType() { return keyType; }
  81 
  82     /** Return the species metadata type mirror, for type {@code S} */
  83     public final Class&lt;S&gt; metaType() { return metaType; }
  84 
  85     /** Report the leading arguments (if any) required by every species factory.
  86      * Every species factory adds its own field types as additional arguments,
  87      * but these arguments always come first, in every factory method.
  88      */
  89     protected MethodType baseConstructorType() { return baseConstructorType; }
  90 
  91     /** Return the trivial species for the null sequence of arguments. */
  92     protected final S topSpecies() { return topSpecies; }
  93 
  94     /** Return the list of transform methods originally given at creation of this specializer. */
  95     protected final List&lt;MemberName&gt; transformMethods() { return transformMethods; }
  96 
  97     /** Return the factory object used to build and load concrete species code. */
  98     protected final Factory factory() { return factory; }
  99 
 100     /**
 101      * Constructor for this class specializer.
 102      * @param topClass type mirror for T
 103      * @param keyType type mirror for K
 104      * @param metaType type mirror for S
 105      * @param baseConstructorType principal constructor type
 106      * @param sdAccessor the method used to get the speciesData
 107      * @param sdFieldName the name of the species data field, inject the speciesData object
 108      * @param transformMethods optional list of transformMethods
 109      */
 110     protected ClassSpecializer(Class&lt;T&gt; topClass,
 111                                Class&lt;K&gt; keyType,
 112                                Class&lt;S&gt; metaType,
 113                                MethodType baseConstructorType,
 114                                MemberName sdAccessor,
 115                                String sdFieldName,
 116                                List&lt;MemberName&gt; transformMethods) {
 117         this.topClass = topClass;
 118         this.keyType = keyType;
 119         this.metaType = metaType;
 120         this.sdAccessor = sdAccessor;
 121         this.transformMethods = List.copyOf(transformMethods);
 122         this.sdFieldName = sdFieldName;
 123         this.baseConstructorType = baseConstructorType.changeReturnType(void.class);
 124         this.factory = makeFactory();
 125         K tsk = topSpeciesKey();
 126         S topSpecies = null;
 127         if (tsk != null &amp;&amp; topSpecies == null) {
 128             // if there is a key, build the top species if needed:
 129             topSpecies = findSpecies(tsk);
 130         }
 131         this.topSpecies = topSpecies;
 132     }
 133 
 134     // Utilities for subclass constructors:
 135     protected static &lt;T&gt; Constructor&lt;T&gt; reflectConstructor(Class&lt;T&gt; defc, Class&lt;?&gt;... ptypes) {
 136         try {
 137             return defc.getDeclaredConstructor(ptypes);
 138         } catch (NoSuchMethodException ex) {
 139             throw newIAE(defc.getName()+&quot;(&quot;+MethodType.methodType(void.class, ptypes)+&quot;)&quot;, ex);
 140         }
 141     }
 142 
 143     protected static Field reflectField(Class&lt;?&gt; defc, String name) {
 144         try {
 145             return defc.getDeclaredField(name);
 146         } catch (NoSuchFieldException ex) {
 147             throw newIAE(defc.getName()+&quot;.&quot;+name, ex);
 148         }
 149     }
 150 
 151     private static RuntimeException newIAE(String message, Throwable cause) {
 152         return new IllegalArgumentException(message, cause);
 153     }
 154 
 155     private static final Function&lt;Object, Object&gt; CREATE_RESERVATION = new Function&lt;&gt;() {
 156         @Override
 157         public Object apply(Object key) {
 158             return new Object();
 159         }
 160     };
 161 
 162     public final S findSpecies(K key) {
 163         // Note:  Species instantiation may throw VirtualMachineError because of
 164         // code cache overflow.  If this happens the species bytecode may be
 165         // loaded but not linked to its species metadata (with MH&#39;s etc).
 166         // That will cause a throw out of Factory.loadSpecies.
 167         //
 168         // In a later attempt to get the same species, the already-loaded
 169         // class will be present in the system dictionary, causing an
 170         // error when the species generator tries to reload it.
 171         // We try to detect this case and link the pre-existing code.
 172         //
 173         // Although it would be better to start fresh by loading a new
 174         // copy, we have to salvage the previously loaded but broken code.
 175         // (As an alternative, we might spin a new class with a new name,
 176         // or use the anonymous class mechanism.)
 177         //
 178         // In the end, as long as everybody goes through this findSpecies method,
 179         // it will ensure only one SpeciesData will be set successfully on a
 180         // concrete class if ever.
 181         // The concrete class is published via SpeciesData instance
 182         // returned here only after the class and species data are linked together.
 183         Object speciesDataOrReservation = cache.computeIfAbsent(key, CREATE_RESERVATION);
 184         // Separating the creation of a placeholder SpeciesData instance above
 185         // from the loading and linking a real one below ensures we can never
 186         // accidentally call computeIfAbsent recursively.
 187         S speciesData;
 188         if (speciesDataOrReservation.getClass() == Object.class) {
 189             synchronized (speciesDataOrReservation) {
 190                 Object existingSpeciesData = cache.get(key);
 191                 if (existingSpeciesData == speciesDataOrReservation) { // won the race
 192                     // create a new SpeciesData...
 193                     speciesData = newSpeciesData(key);
 194                     // load and link it...
 195                     speciesData = factory.loadSpecies(speciesData);
 196                     if (!cache.replace(key, existingSpeciesData, speciesData)) {
 197                         throw newInternalError(&quot;Concurrent loadSpecies&quot;);
 198                     }
 199                 } else { // lost the race; the retrieved existingSpeciesData is the final
 200                     speciesData = metaType.cast(existingSpeciesData);
 201                 }
 202             }
 203         } else {
 204             speciesData = metaType.cast(speciesDataOrReservation);
 205         }
 206         assert(speciesData != null &amp;&amp; speciesData.isResolved());
 207         return speciesData;
 208     }
 209 
 210     /**
 211      * Meta-data wrapper for concrete subtypes of the top class.
 212      * Each concrete subtype corresponds to a given sequence of basic field types (LIJFD).
 213      * The fields are immutable; their values are fully specified at object construction.
 214      * Each species supplies an array of getter functions which may be used in lambda forms.
 215      * A concrete value is always constructed from the full tuple of its field values,
 216      * accompanied by the required constructor parameters.
 217      * There *may* also be transforms which cloning a species instance and
 218      * either replace a constructor parameter or add one or more new field values.
 219      * The shortest possible species has zero fields.
 220      * Subtypes are not interrelated among themselves by subtyping, even though
 221      * it would appear that a shorter species could serve as a supertype of a
 222      * longer one which extends it.
 223      */
 224     public abstract class SpeciesData {
 225         // Bootstrapping requires circular relations Class -&gt; SpeciesData -&gt; Class
 226         // Therefore, we need non-final links in the chain.  Use @Stable fields.
 227         private final K key;
 228         private final List&lt;Class&lt;?&gt;&gt; fieldTypes;
 229         @Stable private Class&lt;? extends T&gt; speciesCode;
 230         @Stable private List&lt;MethodHandle&gt; factories;
 231         @Stable private List&lt;MethodHandle&gt; getters;
 232         @Stable private List&lt;LambdaForm.NamedFunction&gt; nominalGetters;
 233         @Stable private final MethodHandle[] transformHelpers = new MethodHandle[transformMethods.size()];
 234 
 235         protected SpeciesData(K key) {
 236             this.key = keyType.cast(Objects.requireNonNull(key));
 237             List&lt;Class&lt;?&gt;&gt; types = deriveFieldTypes(key);
 238             this.fieldTypes = List.copyOf(types);
 239         }
 240 
 241         public final K key() {
 242             return key;
 243         }
 244 
 245         protected final List&lt;Class&lt;?&gt;&gt; fieldTypes() {
 246             return fieldTypes;
 247         }
 248 
 249         protected final int fieldCount() {
 250             return fieldTypes.size();
 251         }
 252 
 253         protected ClassSpecializer&lt;T,K,S&gt; outer() {
 254             return ClassSpecializer.this;
 255         }
 256 
 257         protected final boolean isResolved() {
 258             return speciesCode != null &amp;&amp; factories != null &amp;&amp; !factories.isEmpty();
 259         }
 260 
 261         @Override public String toString() {
 262             return metaType.getSimpleName() + &quot;[&quot; + key.toString() + &quot; =&gt; &quot; + (isResolved() ? speciesCode.getSimpleName() : &quot;UNRESOLVED&quot;) + &quot;]&quot;;
 263         }
 264 
 265         @Override
 266         public int hashCode() {
 267             return key.hashCode();
 268         }
 269 
 270         @Override
 271         public boolean equals(Object obj) {
 272             if (!(obj instanceof ClassSpecializer.SpeciesData)) {
 273                 return false;
 274             }
 275             @SuppressWarnings(&quot;rawtypes&quot;)
 276             ClassSpecializer.SpeciesData that = (ClassSpecializer.SpeciesData) obj;
 277             return this.outer() == that.outer() &amp;&amp; this.key.equals(that.key);
 278         }
 279 
 280         /** Throws NPE if this species is not yet resolved. */
 281         protected final Class&lt;? extends T&gt; speciesCode() {
 282             return Objects.requireNonNull(speciesCode);
 283         }
 284 
 285         /**
 286          * Return a {@link MethodHandle} which can get the indexed field of this species.
 287          * The return type is the type of the species field it accesses.
 288          * The argument type is the {@code fieldHolder} class of this species.
 289          */
 290         protected MethodHandle getter(int i) {
 291             return getters.get(i);
 292         }
 293 
 294         /**
 295          * Return a {@link LambdaForm.Name} containing a {@link LambdaForm.NamedFunction} that
 296          * represents a MH bound to a generic invoker, which in turn forwards to the corresponding
 297          * getter.
 298          */
 299         protected LambdaForm.NamedFunction getterFunction(int i) {
 300             LambdaForm.NamedFunction nf = nominalGetters.get(i);
 301             assert(nf.memberDeclaringClassOrNull() == speciesCode());
 302             assert(nf.returnType() == BasicType.basicType(fieldTypes.get(i)));
 303             return nf;
 304         }
 305 
 306         protected List&lt;LambdaForm.NamedFunction&gt; getterFunctions() {
 307             return nominalGetters;
 308         }
 309 
 310         protected List&lt;MethodHandle&gt; getters() {
 311             return getters;
 312         }
 313 
 314         protected MethodHandle factory() {
 315             return factories.get(0);
 316         }
 317 
 318         protected MethodHandle transformHelper(int whichtm) {
 319             MethodHandle mh = transformHelpers[whichtm];
 320             if (mh != null)  return mh;
 321             mh = deriveTransformHelper(transformMethods().get(whichtm), whichtm);
 322             // Do a little type checking before we start using the MH.
 323             // (It will be called with invokeBasic, so this is our only chance.)
 324             final MethodType mt = transformHelperType(whichtm);
 325             mh = mh.asType(mt);
 326             return transformHelpers[whichtm] = mh;
 327         }
 328 
 329         private final MethodType transformHelperType(int whichtm) {
 330             MemberName tm = transformMethods().get(whichtm);
 331             ArrayList&lt;Class&lt;?&gt;&gt; args = new ArrayList&lt;&gt;();
 332             ArrayList&lt;Class&lt;?&gt;&gt; fields = new ArrayList&lt;&gt;();
 333             Collections.addAll(args, tm.getParameterTypes());
 334             fields.addAll(fieldTypes());
 335             List&lt;Class&lt;?&gt;&gt; helperArgs = deriveTransformHelperArguments(tm, whichtm, args, fields);
 336             return MethodType.methodType(tm.getReturnType(), helperArgs);
 337         }
 338 
 339         // Hooks for subclasses:
 340 
 341         /**
 342          * Given a key, derive the list of field types, which all instances of this
 343          * species must store.
 344          */
 345         protected abstract List&lt;Class&lt;?&gt;&gt; deriveFieldTypes(K key);
 346 
 347         /**
 348          * Given the index of a method in the transforms list, supply a factory
 349          * method that takes the arguments of the transform, plus the local fields,
 350          * and produce a value of the required type.
 351          * You can override this to return null or throw if there are no transforms.
 352          * This method exists so that the transforms can be &quot;grown&quot; lazily.
 353          * This is necessary if the transform *adds* a field to an instance,
 354          * which sometimtes requires the creation, on the fly, of an extended species.
 355          * This method is only called once for any particular parameter.
 356          * The species caches the result in a private array.
 357          *
 358          * @param transform the transform being implemented
 359          * @param whichtm the index of that transform in the original list of transforms
 360          * @return the method handle which creates a new result from a mix of transform
 361          * arguments and field values
 362          */
 363         protected abstract MethodHandle deriveTransformHelper(MemberName transform, int whichtm);
 364 
 365         /**
 366          * During code generation, this method is called once per transform to determine
 367          * what is the mix of arguments to hand to the transform-helper.  The bytecode
 368          * which marshals these arguments is open-coded in the species-specific transform.
 369          * The two lists are of opaque objects, which you shouldn&#39;t do anything with besides
 370          * reordering them into the output list.  (They are both mutable, to make editing
 371          * easier.)  The imputed types of the args correspond to the transform&#39;s parameter
 372          * list, while the imputed types of the fields correspond to the species field types.
 373          * After code generation, this method may be called occasionally by error-checking code.
 374          *
 375          * @param transform the transform being implemented
 376          * @param whichtm the index of that transform in the original list of transforms
 377          * @param args a list of opaque objects representing the incoming transform arguments
 378          * @param fields a list of opaque objects representing the field values of the receiver
 379          * @param &lt;X&gt; the common element type of the various lists
 380          * @return a new list
 381          */
 382         protected abstract &lt;X&gt; List&lt;X&gt; deriveTransformHelperArguments(MemberName transform, int whichtm,
 383                                                                       List&lt;X&gt; args, List&lt;X&gt; fields);
 384 
 385         /** Given a key, generate the name of the class which implements the species for that key.
 386          * This algorithm must be stable.
 387          *
 388          * @return class name, which by default is {@code outer().topClass().getName() + &quot;$Species_&quot; + deriveTypeString(key)}
 389          */
 390         protected String deriveClassName() {
 391             return outer().topClass().getName() + &quot;$Species_&quot; + deriveTypeString();
 392         }
 393 
 394         /**
 395          * Default implementation collects basic type characters,
 396          * plus possibly type names, if some types don&#39;t correspond
 397          * to basic types.
 398          *
 399          * @return a string suitable for use in a class name
 400          */
 401         protected String deriveTypeString() {
 402             List&lt;Class&lt;?&gt;&gt; types = fieldTypes();
 403             StringBuilder buf = new StringBuilder();
 404             StringBuilder end = new StringBuilder();
 405             for (Class&lt;?&gt; type : types) {
 406                 BasicType basicType = BasicType.basicType(type);
 407                 if (basicType.basicTypeClass() == type) {
 408                     buf.append(basicType.basicTypeChar());
 409                 } else {
 410                     buf.append(&#39;V&#39;);
 411                     end.append(classSig(type));
 412                 }
 413             }
 414             String typeString;
 415             if (end.length() &gt; 0) {
 416                 typeString = BytecodeName.toBytecodeName(buf.append(&quot;_&quot;).append(end).toString());
 417             } else {
 418                 typeString = buf.toString();
 419             }
 420             return LambdaForm.shortenSignature(typeString);
 421         }
 422 
 423         /**
 424          * Report what immediate super-class to use for the concrete class of this species.
 425          * Normally this is {@code topClass}, but if that is an interface, the factory must override.
 426          * The super-class must provide a constructor which takes the {@code baseConstructorType} arguments, if any.
 427          * This hook also allows the code generator to use more than one canned supertype for species.
 428          *
 429          * @return the super-class of the class to be generated
 430          */
 431         protected Class&lt;? extends T&gt; deriveSuperClass() {
 432             final Class&lt;T&gt; topc = topClass();
 433             if (!topClassIsSuper) {
 434                 try {
 435                     final Constructor&lt;T&gt; con = reflectConstructor(topc, baseConstructorType().parameterArray());
 436                     if (!topc.isInterface() &amp;&amp; !Modifier.isPrivate(con.getModifiers())) {
 437                         topClassIsSuper = true;
 438                     }
 439                 } catch (Exception|InternalError ex) {
 440                     // fall through...
 441                 }
 442                 if (!topClassIsSuper) {
 443                     throw newInternalError(&quot;must override if the top class cannot serve as a super class&quot;);
 444                 }
 445             }
 446             return topc;
 447         }
 448     }
 449 
 450     protected abstract S newSpeciesData(K key);
 451 
 452     protected K topSpeciesKey() {
 453         return null;  // null means don&#39;t report a top species
 454     }
 455 
 456     /**
 457      * Code generation support for instances.
 458      * Subclasses can modify the behavior.
 459      */
 460     public class Factory {
<a name="4" id="anc4"></a><span class="line-added"> 461         /**</span>
<span class="line-added"> 462          * Constructs a factory.</span>
<span class="line-added"> 463          */</span>
<span class="line-added"> 464         Factory() {}</span>
<span class="line-added"> 465 </span>
 466         /**
 467          * Get a concrete subclass of the top class for a given combination of bound types.
 468          *
 469          * @param speciesData the species requiring the class, not yet linked
 470          * @return a linked version of the same species
 471          */
 472         S loadSpecies(S speciesData) {
 473             String className = speciesData.deriveClassName();
 474             assert(className.indexOf(&#39;/&#39;) &lt; 0) : className;
 475             Class&lt;?&gt; salvage = null;
 476             try {
 477                 salvage = BootLoader.loadClassOrNull(className);
 478                 if (TRACE_RESOLVE &amp;&amp; salvage != null) {
 479                     // Used by jlink species pregeneration plugin, see
 480                     // jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin
 481                     System.out.println(&quot;[SPECIES_RESOLVE] &quot; + className + &quot; (salvaged)&quot;);
 482                 }
 483             } catch (Error ex) {
 484                 if (TRACE_RESOLVE) {
 485                     System.out.println(&quot;[SPECIES_FRESOLVE] &quot; + className + &quot; (Error) &quot; + ex.getMessage());
 486                 }
 487             }
 488             final Class&lt;? extends T&gt; speciesCode;
 489             if (salvage != null) {
 490                 speciesCode = salvage.asSubclass(topClass());
 491                 linkSpeciesDataToCode(speciesData, speciesCode);
 492                 linkCodeToSpeciesData(speciesCode, speciesData, true);
 493             } else {
 494                 // Not pregenerated, generate the class
 495                 try {
 496                     speciesCode = generateConcreteSpeciesCode(className, speciesData);
 497                     if (TRACE_RESOLVE) {
 498                         // Used by jlink species pregeneration plugin, see
 499                         // jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin
 500                         System.out.println(&quot;[SPECIES_RESOLVE] &quot; + className + &quot; (generated)&quot;);
 501                     }
 502                     // This operation causes a lot of churn:
 503                     linkSpeciesDataToCode(speciesData, speciesCode);
 504                     // This operation commits the relation, but causes little churn:
 505                     linkCodeToSpeciesData(speciesCode, speciesData, false);
 506                 } catch (Error ex) {
 507                     if (TRACE_RESOLVE) {
 508                         System.out.println(&quot;[SPECIES_RESOLVE] &quot; + className + &quot; (Error #2)&quot; );
 509                     }
 510                     // We can get here if there is a race condition loading a class.
 511                     // Or maybe we are out of resources.  Back out of the CHM.get and retry.
 512                     throw ex;
 513                 }
 514             }
 515 
 516             if (!speciesData.isResolved()) {
 517                 throw newInternalError(&quot;bad species class linkage for &quot; + className + &quot;: &quot; + speciesData);
 518             }
 519             assert(speciesData == loadSpeciesDataFromCode(speciesCode));
 520             return speciesData;
 521         }
 522 
 523         /**
 524          * Generate a concrete subclass of the top class for a given combination of bound types.
 525          *
 526          * A concrete species subclass roughly matches the following schema:
 527          *
 528          * &lt;pre&gt;
 529          * class Species_[[types]] extends [[T]] {
 530          *     final [[S]] speciesData() { return ... }
 531          *     static [[T]] make([[fields]]) { return ... }
 532          *     [[fields]]
 533          *     final [[T]] transform([[args]]) { return ... }
 534          * }
 535          * &lt;/pre&gt;
 536          *
 537          * The {@code [[types]]} signature is precisely the key for the species.
 538          *
 539          * The {@code [[fields]]} section consists of one field definition per character in
 540          * the type signature, adhering to the naming schema described in the definition of
 541          * {@link #chooseFieldName}.
 542          *
 543          * For example, a concrete species for two references and one integral bound value
 544          * has a shape like the following:
 545          *
 546          * &lt;pre&gt;
<a name="5" id="anc5"></a><span class="line-modified"> 547          * class TopClass {</span>
<span class="line-modified"> 548          *     ...</span>
<span class="line-modified"> 549          *     private static final class Species_LLI extends TopClass {</span>
<span class="line-modified"> 550          *         final Object argL0;</span>
<span class="line-modified"> 551          *         final Object argL1;</span>
<span class="line-modified"> 552          *         final int argI2;</span>
<span class="line-modified"> 553          *         private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified"> 554          *             super(ctarg, ...);</span>
<span class="line-modified"> 555          *             this.argL0 = argL0;</span>
<span class="line-modified"> 556          *             this.argL1 = argL1;</span>
<span class="line-modified"> 557          *             this.argI2 = argI2;</span>
<span class="line-modified"> 558          *         }</span>
<span class="line-modified"> 559          *         final SpeciesData speciesData() { return BMH_SPECIES; }</span>
<span class="line-modified"> 560          *         &amp;#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards</span>
<span class="line-modified"> 561          *         static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified"> 562          *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified"> 563          *         }</span>
<span class="line-modified"> 564          *         final TopClass copyWith(CT ctarg, ...) {</span>
<span class="line-modified"> 565          *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified"> 566          *         }</span>
<span class="line-modified"> 567          *         // two transforms, for the sake of illustration:</span>
<span class="line-modified"> 568          *         final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {</span>
<span class="line-modified"> 569          *             return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-modified"> 570          *         }</span>
<span class="line-modified"> 571          *         final TopClass copyWithExtendI(CT ctarg, ..., int narg) {</span>
<span class="line-added"> 572          *             return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-added"> 573          *         }</span>
 574          *     }
 575          * }
 576          * &lt;/pre&gt;
 577          *
 578          * @param className of the species
 579          * @param speciesData what species we are generating
 580          * @return the generated concrete TopClass class
 581          */
 582         Class&lt;? extends T&gt; generateConcreteSpeciesCode(String className, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {
 583             byte[] classFile = generateConcreteSpeciesCodeFile(className, speciesData);
 584 
 585             // load class
 586             InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);
<a name="6" id="anc6"></a><span class="line-modified"> 587             ClassLoader cl = topClass.getClassLoader();</span>
<span class="line-modified"> 588             ProtectionDomain pd = null;</span>
<span class="line-modified"> 589             if (cl != null) {</span>
<span class="line-modified"> 590                 pd = AccessController.doPrivileged(</span>
<span class="line-modified"> 591                         new PrivilegedAction&lt;&gt;() {</span>
<span class="line-modified"> 592                             @Override</span>
<span class="line-modified"> 593                             public ProtectionDomain run() {</span>
<span class="line-modified"> 594                                 return topClass().getProtectionDomain();</span>
<span class="line-modified"> 595                             }</span>
<span class="line-modified"> 596                         });</span>
<span class="line-modified"> 597             }</span>
<span class="line-modified"> 598             Class&lt;?&gt; speciesCode = SharedSecrets.getJavaLangAccess()</span>
<span class="line-modified"> 599                     .defineClass(cl, className, classFile, pd, &quot;_ClassSpecializer_generateConcreteSpeciesCode&quot;);</span>
 600             return speciesCode.asSubclass(topClass());
 601         }
 602 
 603         // These are named like constants because there is only one per specialization scheme:
 604         private final String SPECIES_DATA = classBCName(metaType);
 605         private final String SPECIES_DATA_SIG = classSig(SPECIES_DATA);
 606         private final String SPECIES_DATA_NAME = sdAccessor.getName();
 607         private final int SPECIES_DATA_MODS = sdAccessor.getModifiers();
 608         private final List&lt;String&gt; TRANSFORM_NAMES;  // derived from transformMethods
 609         private final List&lt;MethodType&gt; TRANSFORM_TYPES;
 610         private final List&lt;Integer&gt; TRANSFORM_MODS;
 611         {
 612             // Tear apart transformMethods to get the names, types, and modifiers.
 613             List&lt;String&gt; tns = new ArrayList&lt;&gt;();
 614             List&lt;MethodType&gt; tts = new ArrayList&lt;&gt;();
 615             List&lt;Integer&gt; tms = new ArrayList&lt;&gt;();
 616             for (int i = 0; i &lt; transformMethods.size(); i++) {
 617                 MemberName tm = transformMethods.get(i);
 618                 tns.add(tm.getName());
 619                 final MethodType tt = tm.getMethodType();
 620                 tts.add(tt);
 621                 tms.add(tm.getModifiers());
 622             }
 623             TRANSFORM_NAMES = List.of(tns.toArray(new String[0]));
 624             TRANSFORM_TYPES = List.of(tts.toArray(new MethodType[0]));
 625             TRANSFORM_MODS = List.of(tms.toArray(new Integer[0]));
 626         }
 627         private static final int ACC_PPP = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
 628 
<a name="7" id="anc7"></a><span class="line-modified"> 629         /*non-public*/</span>
<span class="line-added"> 630         byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {</span>
 631             final String className = classBCName(className0);
 632             final String superClassName = classBCName(speciesData.deriveSuperClass());
 633 
 634             final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 635             final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
 636             cw.visit(V1_6, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);
 637 
 638             final String sourceFile = className.substring(className.lastIndexOf(&#39;.&#39;)+1);
 639             cw.visitSource(sourceFile, null);
 640 
 641             // emit static types and BMH_SPECIES fields
 642             FieldVisitor fw = cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, sdFieldName, SPECIES_DATA_SIG, null, null);
 643             fw.visitAnnotation(STABLE_SIG, true);
 644             fw.visitEnd();
 645 
 646             // handy holder for dealing with groups of typed values (ctor arguments and fields)
 647             class Var {
 648                 final int index;
 649                 final String name;
 650                 final Class&lt;?&gt; type;
 651                 final String desc;
 652                 final BasicType basicType;
 653                 final int slotIndex;
 654                 Var(int index, int slotIndex) {
 655                     this.index = index;
 656                     this.slotIndex = slotIndex;
 657                     name = null; type = null; desc = null;
 658                     basicType = BasicType.V_TYPE;
 659                 }
 660                 Var(String name, Class&lt;?&gt; type, Var prev) {
 661                     int slotIndex = prev.nextSlotIndex();
 662                     int index = prev.nextIndex();
 663                     if (name == null)  name = &quot;x&quot;;
 664                     if (name.endsWith(&quot;#&quot;))
 665                         name = name.substring(0, name.length()-1) + index;
 666                     assert(!type.equals(void.class));
 667                     String desc = classSig(type);
 668                     BasicType basicType = BasicType.basicType(type);
 669                     this.index = index;
 670                     this.name = name;
 671                     this.type = type;
 672                     this.desc = desc;
 673                     this.basicType = basicType;
 674                     this.slotIndex = slotIndex;
 675                 }
 676                 Var lastOf(List&lt;Var&gt; vars) {
 677                     int n = vars.size();
 678                     return (n == 0 ? this : vars.get(n-1));
 679                 }
 680                 &lt;X&gt; List&lt;Var&gt; fromTypes(List&lt;X&gt; types) {
 681                     Var prev = this;
 682                     ArrayList&lt;Var&gt; result = new ArrayList&lt;&gt;(types.size());
 683                     int i = 0;
 684                     for (X x : types) {
 685                         String vn = name;
 686                         Class&lt;?&gt; vt;
 687                         if (x instanceof Class) {
 688                             vt = (Class&lt;?&gt;) x;
 689                             // make the names friendlier if debugging
 690                             assert((vn = vn + &quot;_&quot; + (i++)) != null);
 691                         } else {
 692                             @SuppressWarnings(&quot;unchecked&quot;)
 693                             Var v = (Var) x;
 694                             vn = v.name;
 695                             vt = v.type;
 696                         }
 697                         prev = new Var(vn, vt, prev);
 698                         result.add(prev);
 699                     }
 700                     return result;
 701                 }
 702 
 703                 int slotSize() { return basicType.basicTypeSlots(); }
 704                 int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }
 705                 int nextSlotIndex() { return slotIndex &gt;= 0 ? slotIndex + slotSize() : slotIndex; }
 706                 boolean isInHeap() { return slotIndex &lt; 0; }
 707                 void emitVarInstruction(int asmop, MethodVisitor mv) {
 708                     if (asmop == ALOAD)
 709                         asmop = typeLoadOp(basicType.basicTypeChar());
 710                     else
 711                         throw new AssertionError(&quot;bad op=&quot;+asmop+&quot; for desc=&quot;+desc);
 712                     mv.visitVarInsn(asmop, slotIndex);
 713                 }
 714                 public void emitFieldInsn(int asmop, MethodVisitor mv) {
 715                     mv.visitFieldInsn(asmop, className, name, desc);
 716                 }
 717             }
 718 
 719             final Var NO_THIS = new Var(0, 0),
 720                     AFTER_THIS = new Var(0, 1),
 721                     IN_HEAP = new Var(0, -1);
 722 
 723             // figure out the field types
 724             final List&lt;Class&lt;?&gt;&gt; fieldTypes = speciesData.fieldTypes();
 725             final List&lt;Var&gt; fields = new ArrayList&lt;&gt;(fieldTypes.size());
 726             {
 727                 Var nextF = IN_HEAP;
 728                 for (Class&lt;?&gt; ft : fieldTypes) {
 729                     String fn = chooseFieldName(ft, nextF.nextIndex());
 730                     nextF = new Var(fn, ft, nextF);
 731                     fields.add(nextF);
 732                 }
 733             }
 734 
 735             // emit bound argument fields
 736             for (Var field : fields) {
 737                 cw.visitField(ACC_FINAL, field.name, field.desc, null, null).visitEnd();
 738             }
 739 
 740             MethodVisitor mv;
 741 
 742             // emit implementation of speciesData()
 743             mv = cw.visitMethod((SPECIES_DATA_MODS &amp; ACC_PPP) + ACC_FINAL,
 744                     SPECIES_DATA_NAME, &quot;()&quot; + SPECIES_DATA_SIG, null, null);
 745             mv.visitCode();
 746             mv.visitFieldInsn(GETSTATIC, className, sdFieldName, SPECIES_DATA_SIG);
 747             mv.visitInsn(ARETURN);
 748             mv.visitMaxs(0, 0);
 749             mv.visitEnd();
 750 
 751             // figure out the constructor arguments
 752             MethodType superCtorType = ClassSpecializer.this.baseConstructorType();
 753             MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);
 754 
 755             // emit constructor
 756             {
 757                 mv = cw.visitMethod(ACC_PRIVATE,
 758                         &quot;&lt;init&gt;&quot;, methodSig(thisCtorType), null, null);
 759                 mv.visitCode();
 760                 mv.visitVarInsn(ALOAD, 0); // this
 761 
 762                 final List&lt;Var&gt; ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());
 763                 for (Var ca : ctorArgs) {
 764                     ca.emitVarInstruction(ALOAD, mv);
 765                 }
 766 
 767                 // super(ca...)
 768                 mv.visitMethodInsn(INVOKESPECIAL, superClassName,
 769                         &quot;&lt;init&gt;&quot;, methodSig(superCtorType), false);
 770 
 771                 // store down fields
 772                 Var lastFV = AFTER_THIS.lastOf(ctorArgs);
 773                 for (Var f : fields) {
 774                     // this.argL1 = argL1
 775                     mv.visitVarInsn(ALOAD, 0);  // this
 776                     lastFV = new Var(f.name, f.type, lastFV);
 777                     lastFV.emitVarInstruction(ALOAD, mv);
 778                     f.emitFieldInsn(PUTFIELD, mv);
 779                 }
 780 
 781                 mv.visitInsn(RETURN);
 782                 mv.visitMaxs(0, 0);
 783                 mv.visitEnd();
 784             }
 785 
 786             // emit make()  ...factory method wrapping constructor
 787             {
 788                 MethodType ftryType = thisCtorType.changeReturnType(topClass());
 789                 mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_STATIC,
 790                         &quot;make&quot;, methodSig(ftryType), null, null);
 791                 mv.visitCode();
 792                 // make instance
 793                 mv.visitTypeInsn(NEW, className);
 794                 mv.visitInsn(DUP);
 795                 // load factory method arguments:  ctarg... and arg...
 796                 for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {
 797                     v.emitVarInstruction(ALOAD, mv);
 798                 }
 799 
 800                 // finally, invoke the constructor and return
 801                 mv.visitMethodInsn(INVOKESPECIAL, className,
 802                         &quot;&lt;init&gt;&quot;, methodSig(thisCtorType), false);
 803                 mv.visitInsn(ARETURN);
 804                 mv.visitMaxs(0, 0);
 805                 mv.visitEnd();
 806             }
 807 
 808             // For each transform, emit the customized override of the transform method.
 809             // This method mixes together some incoming arguments (from the transform&#39;s
 810             // static type signature) with the field types themselves, and passes
 811             // the resulting mish-mosh of values to a method handle produced by
 812             // the species itself.  (Typically this method handle is the factory
 813             // method of this species or a related one.)
 814             for (int whichtm = 0; whichtm &lt; TRANSFORM_NAMES.size(); whichtm++) {
 815                 final String     TNAME = TRANSFORM_NAMES.get(whichtm);
 816                 final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);
 817                 final int        TMODS = TRANSFORM_MODS.get(whichtm);
 818                 mv = cw.visitMethod((TMODS &amp; ACC_PPP) | ACC_FINAL,
 819                         TNAME, TTYPE.toMethodDescriptorString(), null, E_THROWABLE);
 820                 mv.visitCode();
 821                 // return a call to the corresponding &quot;transform helper&quot;, something like this:
 822                 //   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)
 823                 mv.visitFieldInsn(GETSTATIC, className,
 824                         sdFieldName, SPECIES_DATA_SIG);
 825                 emitIntConstant(whichtm, mv);
 826                 mv.visitMethodInsn(INVOKEVIRTUAL, SPECIES_DATA,
 827                         &quot;transformHelper&quot;, &quot;(I)&quot; + MH_SIG, false);
 828 
 829                 List&lt;Var&gt; targs = AFTER_THIS.fromTypes(TTYPE.parameterList());
 830                 List&lt;Var&gt; tfields = new ArrayList&lt;&gt;(fields);
 831                 // mix them up and load them for the transform helper:
 832                 List&lt;Var&gt; helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);
 833                 List&lt;Class&lt;?&gt;&gt; helperTypes = new ArrayList&lt;&gt;(helperArgs.size());
 834                 for (Var ha : helperArgs) {
 835                     helperTypes.add(ha.basicType.basicTypeClass());
 836                     if (ha.isInHeap()) {
 837                         assert(tfields.contains(ha));
 838                         mv.visitVarInsn(ALOAD, 0);
 839                         ha.emitFieldInsn(GETFIELD, mv);
 840                     } else {
 841                         assert(targs.contains(ha));
 842                         ha.emitVarInstruction(ALOAD, mv);
 843                     }
 844                 }
 845 
 846                 // jump into the helper (which is probably a factory method)
 847                 final Class&lt;?&gt; rtype = TTYPE.returnType();
 848                 final BasicType rbt = BasicType.basicType(rtype);
 849                 MethodType invokeBasicType = MethodType.methodType(rbt.basicTypeClass(), helperTypes);
 850                 mv.visitMethodInsn(INVOKEVIRTUAL, MH,
 851                         &quot;invokeBasic&quot;, methodSig(invokeBasicType), false);
 852                 if (rbt == BasicType.L_TYPE) {
 853                     mv.visitTypeInsn(CHECKCAST, classBCName(rtype));
 854                     mv.visitInsn(ARETURN);
 855                 } else {
 856                     throw newInternalError(&quot;NYI: transform of type &quot;+rtype);
 857                 }
 858                 mv.visitMaxs(0, 0);
 859                 mv.visitEnd();
 860             }
 861 
 862             cw.visitEnd();
 863 
 864             return cw.toByteArray();
 865         }
 866 
 867         private int typeLoadOp(char t) {
 868             switch (t) {
 869             case &#39;L&#39;: return ALOAD;
 870             case &#39;I&#39;: return ILOAD;
 871             case &#39;J&#39;: return LLOAD;
 872             case &#39;F&#39;: return FLOAD;
 873             case &#39;D&#39;: return DLOAD;
 874             default : throw newInternalError(&quot;unrecognized type &quot; + t);
 875             }
 876         }
 877 
 878         private void emitIntConstant(int con, MethodVisitor mv) {
 879             if (ICONST_M1 - ICONST_0 &lt;= con &amp;&amp; con &lt;= ICONST_5 - ICONST_0)
 880                 mv.visitInsn(ICONST_0 + con);
 881             else if (con == (byte) con)
 882                 mv.visitIntInsn(BIPUSH, con);
 883             else if (con == (short) con)
 884                 mv.visitIntInsn(SIPUSH, con);
 885             else {
 886                 mv.visitLdcInsn(con);
 887             }
 888 
 889         }
 890 
 891         //
 892         // Getter MH generation.
 893         //
 894 
 895         private MethodHandle findGetter(Class&lt;?&gt; speciesCode, List&lt;Class&lt;?&gt;&gt; types, int index) {
 896             Class&lt;?&gt; fieldType = types.get(index);
 897             String fieldName = chooseFieldName(fieldType, index);
 898             try {
 899                 return IMPL_LOOKUP.findGetter(speciesCode, fieldName, fieldType);
 900             } catch (NoSuchFieldException | IllegalAccessException e) {
 901                 throw newInternalError(e);
 902             }
 903         }
 904 
 905         private List&lt;MethodHandle&gt; findGetters(Class&lt;?&gt; speciesCode, List&lt;Class&lt;?&gt;&gt; types) {
 906             MethodHandle[] mhs = new MethodHandle[types.size()];
 907             for (int i = 0; i &lt; mhs.length; ++i) {
 908                 mhs[i] = findGetter(speciesCode, types, i);
 909                 assert(mhs[i].internalMemberName().getDeclaringClass() == speciesCode);
 910             }
 911             return List.of(mhs);
 912         }
 913 
 914         private List&lt;MethodHandle&gt; findFactories(Class&lt;? extends T&gt; speciesCode, List&lt;Class&lt;?&gt;&gt; types) {
 915             MethodHandle[] mhs = new MethodHandle[1];
 916             mhs[0] = findFactory(speciesCode, types);
 917             return List.of(mhs);
 918         }
 919 
 920         List&lt;LambdaForm.NamedFunction&gt; makeNominalGetters(List&lt;Class&lt;?&gt;&gt; types, List&lt;MethodHandle&gt; getters) {
 921             LambdaForm.NamedFunction[] nfs = new LambdaForm.NamedFunction[types.size()];
 922             for (int i = 0; i &lt; nfs.length; ++i) {
 923                 nfs[i] = new LambdaForm.NamedFunction(getters.get(i));
 924             }
 925             return List.of(nfs);
 926         }
 927 
 928         //
 929         // Auxiliary methods.
 930         //
 931 
 932         protected void linkSpeciesDataToCode(ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData, Class&lt;? extends T&gt; speciesCode) {
 933             speciesData.speciesCode = speciesCode.asSubclass(topClass);
 934             final List&lt;Class&lt;?&gt;&gt; types = speciesData.fieldTypes;
 935             speciesData.factories = this.findFactories(speciesCode, types);
 936             speciesData.getters = this.findGetters(speciesCode, types);
 937             speciesData.nominalGetters = this.makeNominalGetters(types, speciesData.getters);
 938         }
 939 
 940         private Field reflectSDField(Class&lt;? extends T&gt; speciesCode) {
 941             final Field field = reflectField(speciesCode, sdFieldName);
 942             assert(field.getType() == metaType);
 943             assert(Modifier.isStatic(field.getModifiers()));
 944             return field;
 945         }
 946 
 947         private S readSpeciesDataFromCode(Class&lt;? extends T&gt; speciesCode) {
 948             try {
 949                 MemberName sdField = IMPL_LOOKUP.resolveOrFail(REF_getStatic, speciesCode, sdFieldName, metaType);
 950                 Object base = MethodHandleNatives.staticFieldBase(sdField);
 951                 long offset = MethodHandleNatives.staticFieldOffset(sdField);
 952                 UNSAFE.loadFence();
 953                 return metaType.cast(UNSAFE.getReference(base, offset));
 954             } catch (Error err) {
 955                 throw err;
 956             } catch (Exception ex) {
 957                 throw newInternalError(&quot;Failed to load speciesData from speciesCode: &quot; + speciesCode.getName(), ex);
 958             } catch (Throwable t) {
 959                 throw uncaughtException(t);
 960             }
 961         }
 962 
 963         protected S loadSpeciesDataFromCode(Class&lt;? extends T&gt; speciesCode) {
 964             if (speciesCode == topClass()) {
 965                 return topSpecies;
 966             }
 967             S result = readSpeciesDataFromCode(speciesCode);
 968             if (result.outer() != ClassSpecializer.this) {
 969                 throw newInternalError(&quot;wrong class&quot;);
 970             }
 971             return result;
 972         }
 973 
 974         protected void linkCodeToSpeciesData(Class&lt;? extends T&gt; speciesCode, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData, boolean salvage) {
 975             try {
 976                 assert(readSpeciesDataFromCode(speciesCode) == null ||
 977                     (salvage &amp;&amp; readSpeciesDataFromCode(speciesCode).equals(speciesData)));
 978 
 979                 MemberName sdField = IMPL_LOOKUP.resolveOrFail(REF_putStatic, speciesCode, sdFieldName, metaType);
 980                 Object base = MethodHandleNatives.staticFieldBase(sdField);
 981                 long offset = MethodHandleNatives.staticFieldOffset(sdField);
 982                 UNSAFE.storeFence();
 983                 UNSAFE.putReference(base, offset, speciesData);
 984                 UNSAFE.storeFence();
 985             } catch (Error err) {
 986                 throw err;
 987             } catch (Exception ex) {
 988                 throw newInternalError(&quot;Failed to link speciesData to speciesCode: &quot; + speciesCode.getName(), ex);
 989             } catch (Throwable t) {
 990                 throw uncaughtException(t);
 991             }
 992         }
 993 
 994         /**
 995          * Field names in concrete species classes adhere to this pattern:
 996          * type + index, where type is a single character (L, I, J, F, D).
 997          * The factory subclass can customize this.
 998          * The name is purely cosmetic, since it applies to a private field.
 999          */
1000         protected String chooseFieldName(Class&lt;?&gt; type, int index) {
1001             BasicType bt = BasicType.basicType(type);
1002             return &quot;&quot; + bt.basicTypeChar() + index;
1003         }
1004 
1005         MethodHandle findFactory(Class&lt;? extends T&gt; speciesCode, List&lt;Class&lt;?&gt;&gt; types) {
1006             final MethodType type = baseConstructorType().changeReturnType(topClass()).appendParameterTypes(types);
1007             try {
1008                 return IMPL_LOOKUP.findStatic(speciesCode, &quot;make&quot;, type);
1009             } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | TypeNotPresentException e) {
1010                 throw newInternalError(e);
1011             }
1012         }
1013     }
1014 
1015     /** Hook that virtualizes the Factory class, allowing subclasses to extend it. */
1016     protected Factory makeFactory() {
1017         return new Factory();
1018     }
1019 
1020 
1021     // Other misc helpers:
1022     private static final String MH = &quot;java/lang/invoke/MethodHandle&quot;;
1023     private static final String MH_SIG = &quot;L&quot; + MH + &quot;;&quot;;
1024     private static final String STABLE = &quot;jdk/internal/vm/annotation/Stable&quot;;
1025     private static final String STABLE_SIG = &quot;L&quot; + STABLE + &quot;;&quot;;
1026     private static final String[] E_THROWABLE = new String[] { &quot;java/lang/Throwable&quot; };
1027     static {
1028         assert(MH_SIG.equals(classSig(MethodHandle.class)));
1029         assert(MH.equals(classBCName(MethodHandle.class)));
1030     }
1031 
1032     static String methodSig(MethodType mt) {
1033         return mt.toMethodDescriptorString();
1034     }
1035     static String classSig(Class&lt;?&gt; cls) {
1036         if (cls.isPrimitive() || cls.isArray())
1037             return MethodType.methodType(cls).toMethodDescriptorString().substring(2);
1038         return classSig(classBCName(cls));
1039     }
1040     static String classSig(String bcName) {
1041         assert(bcName.indexOf(&#39;.&#39;) &lt; 0);
1042         assert(!bcName.endsWith(&quot;;&quot;));
1043         assert(!bcName.startsWith(&quot;[&quot;));
1044         return &quot;L&quot; + bcName + &quot;;&quot;;
1045     }
1046     static String classBCName(Class&lt;?&gt; cls) {
1047         return classBCName(className(cls));
1048     }
1049     static String classBCName(String str) {
1050         assert(str.indexOf(&#39;/&#39;) &lt; 0) : str;
1051         return str.replace(&#39;.&#39;, &#39;/&#39;);
1052     }
1053     static String className(Class&lt;?&gt; cls) {
1054         assert(!cls.isArray() &amp;&amp; !cls.isPrimitive());
1055         return cls.getName();
1056     }
1057 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
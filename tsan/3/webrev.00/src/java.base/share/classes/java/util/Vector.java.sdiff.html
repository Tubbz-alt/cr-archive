<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Vector.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="UnknownFormatFlagsException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="concurrent/ArrayBlockingQueue.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Vector.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.StreamCorruptedException;
  31 import java.util.function.Consumer;
  32 import java.util.function.Predicate;
  33 import java.util.function.UnaryOperator;
  34 


  35 /**
  36  * The {@code Vector} class implements a growable array of
  37  * objects. Like an array, it contains components that can be
  38  * accessed using an integer index. However, the size of a
  39  * {@code Vector} can grow or shrink as needed to accommodate
  40  * adding and removing items after the {@code Vector} has been created.
  41  *
  42  * &lt;p&gt;Each vector tries to optimize storage management by maintaining a
  43  * {@code capacity} and a {@code capacityIncrement}. The
  44  * {@code capacity} is always at least as large as the vector
  45  * size; it is usually larger because as components are added to the
  46  * vector, the vector&#39;s storage increases in chunks the size of
  47  * {@code capacityIncrement}. An application can increase the
  48  * capacity of a vector before inserting a large number of
  49  * components; this reduces the amount of incremental reallocation.
  50  *
  51  * &lt;p id=&quot;fail-fast&quot;&gt;
  52  * The iterators returned by this class&#39;s {@link #iterator() iterator} and
  53  * {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:
  54  * if the vector is structurally modified at any time after the iterator is
</pre>
<hr />
<pre>
  83  *
  84  * @author  Lee Boynton
  85  * @author  Jonathan Payne
  86  * @see Collection
  87  * @see LinkedList
  88  * @since   1.0
  89  */
  90 public class Vector&lt;E&gt;
  91     extends AbstractList&lt;E&gt;
  92     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
  93 {
  94     /**
  95      * The array buffer into which the components of the vector are
  96      * stored. The capacity of the vector is the length of this array buffer,
  97      * and is at least large enough to contain all the vector&#39;s elements.
  98      *
  99      * &lt;p&gt;Any array elements following the last element in the Vector are null.
 100      *
 101      * @serial
 102      */

 103     protected Object[] elementData;
 104 
 105     /**
 106      * The number of valid components in this {@code Vector} object.
 107      * Components {@code elementData[0]} through
 108      * {@code elementData[elementCount-1]} are the actual items.
 109      *
 110      * @serial
 111      */
 112     protected int elementCount;
 113 
 114     /**
 115      * The amount by which the capacity of the vector is automatically
 116      * incremented when its size becomes greater than its capacity.  If
 117      * the capacity increment is less than or equal to zero, the capacity
 118      * of the vector is doubled each time it needs to grow.
 119      *
 120      * @serial
 121      */
 122     protected int capacityIncrement;
 123 
 124     /** use serialVersionUID from JDK 1.0.2 for interoperability */

 125     private static final long serialVersionUID = -2767605614048989439L;
 126 
 127     /**
 128      * Constructs an empty vector with the specified initial capacity and
 129      * capacity increment.
 130      *
 131      * @param   initialCapacity     the initial capacity of the vector
 132      * @param   capacityIncrement   the amount by which the capacity is
 133      *                              increased when the vector overflows
 134      * @throws IllegalArgumentException if the specified initial capacity
 135      *         is negative
 136      */
 137     public Vector(int initialCapacity, int capacityIncrement) {
 138         super();
 139         if (initialCapacity &lt; 0)
 140             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
 141                                                initialCapacity);
 142         this.elementData = new Object[initialCapacity];
 143         this.capacityIncrement = capacityIncrement;
 144     }
</pre>
<hr />
<pre>
 224      * &lt;p&gt;If the current capacity of this vector is less than
 225      * {@code minCapacity}, then its capacity is increased by replacing its
 226      * internal data array, kept in the field {@code elementData}, with a
 227      * larger one.  The size of the new data array will be the old size plus
 228      * {@code capacityIncrement}, unless the value of
 229      * {@code capacityIncrement} is less than or equal to zero, in which case
 230      * the new capacity will be twice the old capacity; but if this new size
 231      * is still smaller than {@code minCapacity}, then the new capacity will
 232      * be {@code minCapacity}.
 233      *
 234      * @param minCapacity the desired minimum capacity
 235      */
 236     public synchronized void ensureCapacity(int minCapacity) {
 237         if (minCapacity &gt; 0) {
 238             modCount++;
 239             if (minCapacity &gt; elementData.length)
 240                 grow(minCapacity);
 241         }
 242     }
 243 
<span class="line-removed"> 244     /**</span>
<span class="line-removed"> 245      * The maximum size of array to allocate (unless necessary).</span>
<span class="line-removed"> 246      * Some VMs reserve some header words in an array.</span>
<span class="line-removed"> 247      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed"> 248      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed"> 249      */</span>
<span class="line-removed"> 250     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed"> 251 </span>
 252     /**
 253      * Increases the capacity to ensure that it can hold at least the
 254      * number of elements specified by the minimum capacity argument.
 255      *
 256      * @param minCapacity the desired minimum capacity
 257      * @throws OutOfMemoryError if minCapacity is less than zero
 258      */
 259     private Object[] grow(int minCapacity) {
<span class="line-modified"> 260         return elementData = Arrays.copyOf(elementData,</span>
<span class="line-modified"> 261                                            newCapacity(minCapacity));</span>




 262     }
 263 
 264     private Object[] grow() {
 265         return grow(elementCount + 1);
 266     }
 267 
<span class="line-removed"> 268     /**</span>
<span class="line-removed"> 269      * Returns a capacity at least as large as the given minimum capacity.</span>
<span class="line-removed"> 270      * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span>
<span class="line-removed"> 271      * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span>
<span class="line-removed"> 272      *</span>
<span class="line-removed"> 273      * @param minCapacity the desired minimum capacity</span>
<span class="line-removed"> 274      * @throws OutOfMemoryError if minCapacity is less than zero</span>
<span class="line-removed"> 275      */</span>
<span class="line-removed"> 276     private int newCapacity(int minCapacity) {</span>
<span class="line-removed"> 277         // overflow-conscious code</span>
<span class="line-removed"> 278         int oldCapacity = elementData.length;</span>
<span class="line-removed"> 279         int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span>
<span class="line-removed"> 280                                          capacityIncrement : oldCapacity);</span>
<span class="line-removed"> 281         if (newCapacity - minCapacity &lt;= 0) {</span>
<span class="line-removed"> 282             if (minCapacity &lt; 0) // overflow</span>
<span class="line-removed"> 283                 throw new OutOfMemoryError();</span>
<span class="line-removed"> 284             return minCapacity;</span>
<span class="line-removed"> 285         }</span>
<span class="line-removed"> 286         return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)</span>
<span class="line-removed"> 287             ? newCapacity</span>
<span class="line-removed"> 288             : hugeCapacity(minCapacity);</span>
<span class="line-removed"> 289     }</span>
<span class="line-removed"> 290 </span>
<span class="line-removed"> 291     private static int hugeCapacity(int minCapacity) {</span>
<span class="line-removed"> 292         if (minCapacity &lt; 0) // overflow</span>
<span class="line-removed"> 293             throw new OutOfMemoryError();</span>
<span class="line-removed"> 294         return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span>
<span class="line-removed"> 295             Integer.MAX_VALUE :</span>
<span class="line-removed"> 296             MAX_ARRAY_SIZE;</span>
<span class="line-removed"> 297     }</span>
<span class="line-removed"> 298 </span>
 299     /**
 300      * Sets the size of this vector. If the new size is greater than the
 301      * current size, new {@code null} items are added to the end of
 302      * the vector. If the new size is less than the current size, all
 303      * components at index {@code newSize} and greater are discarded.
 304      *
 305      * @param  newSize   the new size of this vector
 306      * @throws ArrayIndexOutOfBoundsException if the new size is negative
 307      */
 308     public synchronized void setSize(int newSize) {
 309         modCount++;
 310         if (newSize &gt; elementData.length)
 311             grow(newSize);
 312         final Object[] es = elementData;
 313         for (int to = elementCount, i = newSize; i &lt; to; i++)
 314             es[i] = null;
 315         elementCount = newSize;
 316     }
 317 
 318     /**
</pre>
<hr />
<pre>
1165     }
1166 
1167     /** Erases the gap from lo to hi, by sliding down following elements. */
1168     private void shiftTailOverGap(Object[] es, int lo, int hi) {
1169         System.arraycopy(es, hi, es, lo, elementCount - hi);
1170         for (int to = elementCount, i = (elementCount -= hi - lo); i &lt; to; i++)
1171             es[i] = null;
1172     }
1173 
1174     /**
1175      * Loads a {@code Vector} instance from a stream
1176      * (that is, deserializes it).
1177      * This method performs checks to ensure the consistency
1178      * of the fields.
1179      *
1180      * @param in the stream
1181      * @throws java.io.IOException if an I/O error occurs
1182      * @throws ClassNotFoundException if the stream contains data
1183      *         of a non-existing class
1184      */

1185     private void readObject(ObjectInputStream in)
1186             throws IOException, ClassNotFoundException {
1187         ObjectInputStream.GetField gfields = in.readFields();
1188         int count = gfields.get(&quot;elementCount&quot;, 0);
1189         Object[] data = (Object[])gfields.get(&quot;elementData&quot;, null);
1190         if (count &lt; 0 || data == null || count &gt; data.length) {
1191             throw new StreamCorruptedException(&quot;Inconsistent vector internals&quot;);
1192         }
1193         elementCount = count;
1194         elementData = data.clone();
1195     }
1196 
1197     /**
1198      * Saves the state of the {@code Vector} instance to a stream
1199      * (that is, serializes it).
1200      * This method performs synchronization to ensure the consistency
1201      * of the serialized data.
1202      *
1203      * @param s the stream
1204      * @throws java.io.IOException if an I/O error occurs
1205      */

1206     private void writeObject(java.io.ObjectOutputStream s)
1207             throws java.io.IOException {
1208         final java.io.ObjectOutputStream.PutField fields = s.putFields();
1209         final Object[] data;
1210         synchronized (this) {
1211             fields.put(&quot;capacityIncrement&quot;, capacityIncrement);
1212             fields.put(&quot;elementCount&quot;, elementCount);
1213             data = elementData.clone();
1214         }
1215         fields.put(&quot;elementData&quot;, data);
1216         s.writeFields();
1217     }
1218 
1219     /**
1220      * Returns a list iterator over the elements in this list (in proper
1221      * sequence), starting at the specified position in the list.
1222      * The specified index indicates the first element that would be
1223      * returned by an initial call to {@link ListIterator#next next}.
1224      * An initial call to {@link ListIterator#previous previous} would
1225      * return the element with the specified index minus one.
</pre>
<hr />
<pre>
1385         final int size = elementCount;
1386         for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
1387             action.accept(elementAt(es, i));
1388         if (modCount != expectedModCount)
1389             throw new ConcurrentModificationException();
1390     }
1391 
1392     /**
1393      * @throws NullPointerException {@inheritDoc}
1394      */
1395     @Override
1396     public synchronized void replaceAll(UnaryOperator&lt;E&gt; operator) {
1397         Objects.requireNonNull(operator);
1398         final int expectedModCount = modCount;
1399         final Object[] es = elementData;
1400         final int size = elementCount;
1401         for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
1402             es[i] = operator.apply(elementAt(es, i));
1403         if (modCount != expectedModCount)
1404             throw new ConcurrentModificationException();

1405         modCount++;
1406     }
1407 
1408     @SuppressWarnings(&quot;unchecked&quot;)
1409     @Override
1410     public synchronized void sort(Comparator&lt;? super E&gt; c) {
1411         final int expectedModCount = modCount;
1412         Arrays.sort((E[]) elementData, 0, elementCount, c);
1413         if (modCount != expectedModCount)
1414             throw new ConcurrentModificationException();
1415         modCount++;
1416     }
1417 
1418     /**
1419      * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
1420      * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
1421      * list.
1422      *
1423      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
1424      * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.StreamCorruptedException;
  31 import java.util.function.Consumer;
  32 import java.util.function.Predicate;
  33 import java.util.function.UnaryOperator;
  34 
<span class="line-added">  35 import jdk.internal.util.ArraysSupport;</span>
<span class="line-added">  36 </span>
  37 /**
  38  * The {@code Vector} class implements a growable array of
  39  * objects. Like an array, it contains components that can be
  40  * accessed using an integer index. However, the size of a
  41  * {@code Vector} can grow or shrink as needed to accommodate
  42  * adding and removing items after the {@code Vector} has been created.
  43  *
  44  * &lt;p&gt;Each vector tries to optimize storage management by maintaining a
  45  * {@code capacity} and a {@code capacityIncrement}. The
  46  * {@code capacity} is always at least as large as the vector
  47  * size; it is usually larger because as components are added to the
  48  * vector, the vector&#39;s storage increases in chunks the size of
  49  * {@code capacityIncrement}. An application can increase the
  50  * capacity of a vector before inserting a large number of
  51  * components; this reduces the amount of incremental reallocation.
  52  *
  53  * &lt;p id=&quot;fail-fast&quot;&gt;
  54  * The iterators returned by this class&#39;s {@link #iterator() iterator} and
  55  * {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:
  56  * if the vector is structurally modified at any time after the iterator is
</pre>
<hr />
<pre>
  85  *
  86  * @author  Lee Boynton
  87  * @author  Jonathan Payne
  88  * @see Collection
  89  * @see LinkedList
  90  * @since   1.0
  91  */
  92 public class Vector&lt;E&gt;
  93     extends AbstractList&lt;E&gt;
  94     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
  95 {
  96     /**
  97      * The array buffer into which the components of the vector are
  98      * stored. The capacity of the vector is the length of this array buffer,
  99      * and is at least large enough to contain all the vector&#39;s elements.
 100      *
 101      * &lt;p&gt;Any array elements following the last element in the Vector are null.
 102      *
 103      * @serial
 104      */
<span class="line-added"> 105     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
 106     protected Object[] elementData;
 107 
 108     /**
 109      * The number of valid components in this {@code Vector} object.
 110      * Components {@code elementData[0]} through
 111      * {@code elementData[elementCount-1]} are the actual items.
 112      *
 113      * @serial
 114      */
 115     protected int elementCount;
 116 
 117     /**
 118      * The amount by which the capacity of the vector is automatically
 119      * incremented when its size becomes greater than its capacity.  If
 120      * the capacity increment is less than or equal to zero, the capacity
 121      * of the vector is doubled each time it needs to grow.
 122      *
 123      * @serial
 124      */
 125     protected int capacityIncrement;
 126 
 127     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added"> 128     @java.io.Serial</span>
 129     private static final long serialVersionUID = -2767605614048989439L;
 130 
 131     /**
 132      * Constructs an empty vector with the specified initial capacity and
 133      * capacity increment.
 134      *
 135      * @param   initialCapacity     the initial capacity of the vector
 136      * @param   capacityIncrement   the amount by which the capacity is
 137      *                              increased when the vector overflows
 138      * @throws IllegalArgumentException if the specified initial capacity
 139      *         is negative
 140      */
 141     public Vector(int initialCapacity, int capacityIncrement) {
 142         super();
 143         if (initialCapacity &lt; 0)
 144             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
 145                                                initialCapacity);
 146         this.elementData = new Object[initialCapacity];
 147         this.capacityIncrement = capacityIncrement;
 148     }
</pre>
<hr />
<pre>
 228      * &lt;p&gt;If the current capacity of this vector is less than
 229      * {@code minCapacity}, then its capacity is increased by replacing its
 230      * internal data array, kept in the field {@code elementData}, with a
 231      * larger one.  The size of the new data array will be the old size plus
 232      * {@code capacityIncrement}, unless the value of
 233      * {@code capacityIncrement} is less than or equal to zero, in which case
 234      * the new capacity will be twice the old capacity; but if this new size
 235      * is still smaller than {@code minCapacity}, then the new capacity will
 236      * be {@code minCapacity}.
 237      *
 238      * @param minCapacity the desired minimum capacity
 239      */
 240     public synchronized void ensureCapacity(int minCapacity) {
 241         if (minCapacity &gt; 0) {
 242             modCount++;
 243             if (minCapacity &gt; elementData.length)
 244                 grow(minCapacity);
 245         }
 246     }
 247 








 248     /**
 249      * Increases the capacity to ensure that it can hold at least the
 250      * number of elements specified by the minimum capacity argument.
 251      *
 252      * @param minCapacity the desired minimum capacity
 253      * @throws OutOfMemoryError if minCapacity is less than zero
 254      */
 255     private Object[] grow(int minCapacity) {
<span class="line-modified"> 256         int oldCapacity = elementData.length;</span>
<span class="line-modified"> 257         int newCapacity = ArraysSupport.newLength(oldCapacity,</span>
<span class="line-added"> 258                 minCapacity - oldCapacity, /* minimum growth */</span>
<span class="line-added"> 259                 capacityIncrement &gt; 0 ? capacityIncrement : oldCapacity</span>
<span class="line-added"> 260                                            /* preferred growth */);</span>
<span class="line-added"> 261         return elementData = Arrays.copyOf(elementData, newCapacity);</span>
 262     }
 263 
 264     private Object[] grow() {
 265         return grow(elementCount + 1);
 266     }
 267 































 268     /**
 269      * Sets the size of this vector. If the new size is greater than the
 270      * current size, new {@code null} items are added to the end of
 271      * the vector. If the new size is less than the current size, all
 272      * components at index {@code newSize} and greater are discarded.
 273      *
 274      * @param  newSize   the new size of this vector
 275      * @throws ArrayIndexOutOfBoundsException if the new size is negative
 276      */
 277     public synchronized void setSize(int newSize) {
 278         modCount++;
 279         if (newSize &gt; elementData.length)
 280             grow(newSize);
 281         final Object[] es = elementData;
 282         for (int to = elementCount, i = newSize; i &lt; to; i++)
 283             es[i] = null;
 284         elementCount = newSize;
 285     }
 286 
 287     /**
</pre>
<hr />
<pre>
1134     }
1135 
1136     /** Erases the gap from lo to hi, by sliding down following elements. */
1137     private void shiftTailOverGap(Object[] es, int lo, int hi) {
1138         System.arraycopy(es, hi, es, lo, elementCount - hi);
1139         for (int to = elementCount, i = (elementCount -= hi - lo); i &lt; to; i++)
1140             es[i] = null;
1141     }
1142 
1143     /**
1144      * Loads a {@code Vector} instance from a stream
1145      * (that is, deserializes it).
1146      * This method performs checks to ensure the consistency
1147      * of the fields.
1148      *
1149      * @param in the stream
1150      * @throws java.io.IOException if an I/O error occurs
1151      * @throws ClassNotFoundException if the stream contains data
1152      *         of a non-existing class
1153      */
<span class="line-added">1154     @java.io.Serial</span>
1155     private void readObject(ObjectInputStream in)
1156             throws IOException, ClassNotFoundException {
1157         ObjectInputStream.GetField gfields = in.readFields();
1158         int count = gfields.get(&quot;elementCount&quot;, 0);
1159         Object[] data = (Object[])gfields.get(&quot;elementData&quot;, null);
1160         if (count &lt; 0 || data == null || count &gt; data.length) {
1161             throw new StreamCorruptedException(&quot;Inconsistent vector internals&quot;);
1162         }
1163         elementCount = count;
1164         elementData = data.clone();
1165     }
1166 
1167     /**
1168      * Saves the state of the {@code Vector} instance to a stream
1169      * (that is, serializes it).
1170      * This method performs synchronization to ensure the consistency
1171      * of the serialized data.
1172      *
1173      * @param s the stream
1174      * @throws java.io.IOException if an I/O error occurs
1175      */
<span class="line-added">1176     @java.io.Serial</span>
1177     private void writeObject(java.io.ObjectOutputStream s)
1178             throws java.io.IOException {
1179         final java.io.ObjectOutputStream.PutField fields = s.putFields();
1180         final Object[] data;
1181         synchronized (this) {
1182             fields.put(&quot;capacityIncrement&quot;, capacityIncrement);
1183             fields.put(&quot;elementCount&quot;, elementCount);
1184             data = elementData.clone();
1185         }
1186         fields.put(&quot;elementData&quot;, data);
1187         s.writeFields();
1188     }
1189 
1190     /**
1191      * Returns a list iterator over the elements in this list (in proper
1192      * sequence), starting at the specified position in the list.
1193      * The specified index indicates the first element that would be
1194      * returned by an initial call to {@link ListIterator#next next}.
1195      * An initial call to {@link ListIterator#previous previous} would
1196      * return the element with the specified index minus one.
</pre>
<hr />
<pre>
1356         final int size = elementCount;
1357         for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
1358             action.accept(elementAt(es, i));
1359         if (modCount != expectedModCount)
1360             throw new ConcurrentModificationException();
1361     }
1362 
1363     /**
1364      * @throws NullPointerException {@inheritDoc}
1365      */
1366     @Override
1367     public synchronized void replaceAll(UnaryOperator&lt;E&gt; operator) {
1368         Objects.requireNonNull(operator);
1369         final int expectedModCount = modCount;
1370         final Object[] es = elementData;
1371         final int size = elementCount;
1372         for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
1373             es[i] = operator.apply(elementAt(es, i));
1374         if (modCount != expectedModCount)
1375             throw new ConcurrentModificationException();
<span class="line-added">1376         // TODO(8203662): remove increment of modCount from ...</span>
1377         modCount++;
1378     }
1379 
1380     @SuppressWarnings(&quot;unchecked&quot;)
1381     @Override
1382     public synchronized void sort(Comparator&lt;? super E&gt; c) {
1383         final int expectedModCount = modCount;
1384         Arrays.sort((E[]) elementData, 0, elementCount, c);
1385         if (modCount != expectedModCount)
1386             throw new ConcurrentModificationException();
1387         modCount++;
1388     }
1389 
1390     /**
1391      * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
1392      * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
1393      * list.
1394      *
1395      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
1396      * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
</pre>
</td>
</tr>
</table>
<center><a href="UnknownFormatFlagsException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="concurrent/ArrayBlockingQueue.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/IdentityHashMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.lang.reflect.Array;
  29 import java.util.function.BiConsumer;
  30 import java.util.function.BiFunction;
  31 import java.util.function.Consumer;
  32 import jdk.internal.access.SharedSecrets;
  33 
  34 /**
  35  * This class implements the {@code Map} interface with a hash table, using
  36  * reference-equality in place of object-equality when comparing keys (and
  37  * values).  In other words, in an {@code IdentityHashMap}, two keys
  38  * {@code k1} and {@code k2} are considered equal if and only if
  39  * {@code (k1==k2)}.  (In normal {@code Map} implementations (like
  40  * {@code HashMap}) two keys {@code k1} and {@code k2} are considered equal
  41  * if and only if {@code (k1==null ? k2==null : k1.equals(k2))}.)
  42  *
  43  * &lt;p&gt;&lt;b&gt;This class is &lt;i&gt;not&lt;/i&gt; a general-purpose {@code Map}
  44  * implementation!  While this class implements the {@code Map} interface, it
  45  * intentionally violates {@code Map&#39;s} general contract, which mandates the
  46  * use of the {@code equals} method when comparing objects.  This class is
  47  * designed for use only in the rare cases wherein reference-equality
  48  * semantics are required.&lt;/b&gt;
  49  *
  50  * &lt;p&gt;A typical use of this class is &lt;i&gt;topology-preserving object graph
  51  * transformations&lt;/i&gt;, such as serialization or deep-copying.  To perform such
  52  * a transformation, a program must maintain a &quot;node table&quot; that keeps track
  53  * of all the object references that have already been processed.  The node
  54  * table must not equate distinct objects even if they happen to be equal.
  55  * Another typical use of this class is to maintain &lt;i&gt;proxy objects&lt;/i&gt;.  For
  56  * example, a debugging facility might wish to maintain a proxy object for
  57  * each object in the program being debugged.
  58  *
  59  * &lt;p&gt;This class provides all of the optional map operations, and permits
  60  * {@code null} values and the {@code null} key.  This class makes no
  61  * guarantees as to the order of the map; in particular, it does not guarantee
  62  * that the order will remain constant over time.
  63  *
  64  * &lt;p&gt;This class provides constant-time performance for the basic
  65  * operations ({@code get} and {@code put}), assuming the system
  66  * identity hash function ({@link System#identityHashCode(Object)})
  67  * disperses elements properly among the buckets.
  68  *
  69  * &lt;p&gt;This class has one tuning parameter (which affects performance but not
  70  * semantics): &lt;i&gt;expected maximum size&lt;/i&gt;.  This parameter is the maximum
  71  * number of key-value mappings that the map is expected to hold.  Internally,
  72  * this parameter is used to determine the number of buckets initially
  73  * comprising the hash table.  The precise relationship between the expected
  74  * maximum size and the number of buckets is unspecified.
  75  *
  76  * &lt;p&gt;If the size of the map (the number of key-value mappings) sufficiently
  77  * exceeds the expected maximum size, the number of buckets is increased.
  78  * Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so
  79  * it pays to create identity hash maps with a sufficiently large expected
  80  * maximum size.  On the other hand, iteration over collection views requires
  81  * time proportional to the number of buckets in the hash table, so it
  82  * pays not to set the expected maximum size too high if you are especially
  83  * concerned with iteration performance or memory usage.
  84  *
  85  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
  86  * If multiple threads access an identity hash map concurrently, and at
  87  * least one of the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt;
  88  * be synchronized externally.  (A structural modification is any operation
  89  * that adds or deletes one or more mappings; merely changing the value
  90  * associated with a key that an instance already contains is not a
  91  * structural modification.)  This is typically accomplished by
  92  * synchronizing on some object that naturally encapsulates the map.
  93  *
  94  * If no such object exists, the map should be &quot;wrapped&quot; using the
  95  * {@link Collections#synchronizedMap Collections.synchronizedMap}
  96  * method.  This is best done at creation time, to prevent accidental
  97  * unsynchronized access to the map:&lt;pre&gt;
  98  *   Map m = Collections.synchronizedMap(new IdentityHashMap(...));&lt;/pre&gt;
  99  *
 100  * &lt;p&gt;The iterators returned by the {@code iterator} method of the
 101  * collections returned by all of this class&#39;s &quot;collection view
 102  * methods&quot; are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified
 103  * at any time after the iterator is created, in any way except
 104  * through the iterator&#39;s own {@code remove} method, the iterator
 105  * will throw a {@link ConcurrentModificationException}.  Thus, in the
 106  * face of concurrent modification, the iterator fails quickly and
 107  * cleanly, rather than risking arbitrary, non-deterministic behavior
 108  * at an undetermined time in the future.
 109  *
 110  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 111  * as it is, generally speaking, impossible to make any hard guarantees in the
 112  * presence of unsynchronized concurrent modification.  Fail-fast iterators
 113  * throw {@code ConcurrentModificationException} on a best-effort basis.
 114  * Therefore, it would be wrong to write a program that depended on this
 115  * exception for its correctness: &lt;i&gt;fail-fast iterators should be used only
 116  * to detect bugs.&lt;/i&gt;
 117  *
<a name="2" id="anc2"></a>






 118  * &lt;p&gt;This class is a member of the
 119  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 120  * Java Collections Framework&lt;/a&gt;.
 121  *
<a name="3" id="anc3"></a><span class="line-added"> 122  * @implNote</span>
<span class="line-added"> 123  * &lt;p&gt;This is a simple &lt;i&gt;linear-probe&lt;/i&gt; hash table,</span>
<span class="line-added"> 124  * as described for example in texts by Sedgewick and Knuth.  The array</span>
<span class="line-added"> 125  * contains alternating keys and values, with keys at even indexes and values</span>
<span class="line-added"> 126  * at odd indexes. (This arrangement has better locality for large</span>
<span class="line-added"> 127  * tables than does using separate arrays.)  For many Java implementations</span>
<span class="line-added"> 128  * and operation mixes, this class will yield better performance than</span>
<span class="line-added"> 129  * {@link HashMap}, which uses &lt;i&gt;chaining&lt;/i&gt; rather than linear-probing.</span>
<span class="line-added"> 130  *</span>
 131  * @see     System#identityHashCode(Object)
 132  * @see     Object#hashCode()
 133  * @see     Collection
 134  * @see     Map
 135  * @see     HashMap
 136  * @see     TreeMap
 137  * @author  Doug Lea and Josh Bloch
 138  * @since   1.4
 139  */
 140 
 141 public class IdentityHashMap&lt;K,V&gt;
 142     extends AbstractMap&lt;K,V&gt;
 143     implements Map&lt;K,V&gt;, java.io.Serializable, Cloneable
 144 {
 145     /**
 146      * The initial capacity used by the no-args constructor.
 147      * MUST be a power of two.  The value 32 corresponds to the
 148      * (specified) expected maximum size of 21, given a load factor
 149      * of 2/3.
 150      */
 151     private static final int DEFAULT_CAPACITY = 32;
 152 
 153     /**
 154      * The minimum capacity, used if a lower value is implicitly specified
 155      * by either of the constructors with arguments.  The value 4 corresponds
 156      * to an expected maximum size of 2, given a load factor of 2/3.
 157      * MUST be a power of two.
 158      */
 159     private static final int MINIMUM_CAPACITY = 4;
 160 
 161     /**
 162      * The maximum capacity, used if a higher value is implicitly specified
 163      * by either of the constructors with arguments.
 164      * MUST be a power of two &lt;= 1&lt;&lt;29.
 165      *
 166      * In fact, the map can hold no more than MAXIMUM_CAPACITY-1 items
 167      * because it has to have at least one slot with the key == null
 168      * in order to avoid infinite loops in get(), put(), remove()
 169      */
 170     private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 29;
 171 
 172     /**
 173      * The table, resized as necessary. Length MUST always be a power of two.
 174      */
 175     transient Object[] table; // non-private to simplify nested class access
 176 
 177     /**
 178      * The number of key-value mappings contained in this identity hash map.
 179      *
 180      * @serial
 181      */
 182     int size;
 183 
 184     /**
 185      * The number of modifications, to support fast-fail iterators
 186      */
 187     transient int modCount;
 188 
 189     /**
 190      * Value representing null keys inside tables.
 191      */
 192     static final Object NULL_KEY = new Object();
 193 
 194     /**
 195      * Use NULL_KEY for key if it is null.
 196      */
 197     private static Object maskNull(Object key) {
 198         return (key == null ? NULL_KEY : key);
 199     }
 200 
 201     /**
 202      * Returns internal representation of null key back to caller as null.
 203      */
 204     static final Object unmaskNull(Object key) {
 205         return (key == NULL_KEY ? null : key);
 206     }
 207 
 208     /**
 209      * Constructs a new, empty identity hash map with a default expected
 210      * maximum size (21).
 211      */
 212     public IdentityHashMap() {
 213         init(DEFAULT_CAPACITY);
 214     }
 215 
 216     /**
 217      * Constructs a new, empty map with the specified expected maximum size.
 218      * Putting more than the expected number of key-value mappings into
 219      * the map may cause the internal data structure to grow, which may be
 220      * somewhat time-consuming.
 221      *
 222      * @param expectedMaxSize the expected maximum size of the map
 223      * @throws IllegalArgumentException if {@code expectedMaxSize} is negative
 224      */
 225     public IdentityHashMap(int expectedMaxSize) {
 226         if (expectedMaxSize &lt; 0)
 227             throw new IllegalArgumentException(&quot;expectedMaxSize is negative: &quot;
 228                                                + expectedMaxSize);
 229         init(capacity(expectedMaxSize));
 230     }
 231 
 232     /**
 233      * Returns the appropriate capacity for the given expected maximum size.
 234      * Returns the smallest power of two between MINIMUM_CAPACITY and
 235      * MAXIMUM_CAPACITY, inclusive, that is greater than (3 *
 236      * expectedMaxSize)/2, if such a number exists.  Otherwise returns
 237      * MAXIMUM_CAPACITY.
 238      */
 239     private static int capacity(int expectedMaxSize) {
 240         // assert expectedMaxSize &gt;= 0;
 241         return
 242             (expectedMaxSize &gt; MAXIMUM_CAPACITY / 3) ? MAXIMUM_CAPACITY :
 243             (expectedMaxSize &lt;= 2 * MINIMUM_CAPACITY / 3) ? MINIMUM_CAPACITY :
 244             Integer.highestOneBit(expectedMaxSize + (expectedMaxSize &lt;&lt; 1));
 245     }
 246 
 247     /**
 248      * Initializes object to be an empty map with the specified initial
 249      * capacity, which is assumed to be a power of two between
 250      * MINIMUM_CAPACITY and MAXIMUM_CAPACITY inclusive.
 251      */
 252     private void init(int initCapacity) {
 253         // assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2
 254         // assert initCapacity &gt;= MINIMUM_CAPACITY;
 255         // assert initCapacity &lt;= MAXIMUM_CAPACITY;
 256 
 257         table = new Object[2 * initCapacity];
 258     }
 259 
 260     /**
 261      * Constructs a new identity hash map containing the keys-value mappings
 262      * in the specified map.
 263      *
 264      * @param m the map whose mappings are to be placed into this map
 265      * @throws NullPointerException if the specified map is null
 266      */
 267     public IdentityHashMap(Map&lt;? extends K, ? extends V&gt; m) {
 268         // Allow for a bit of growth
 269         this((int) ((1 + m.size()) * 1.1));
 270         putAll(m);
 271     }
 272 
 273     /**
 274      * Returns the number of key-value mappings in this identity hash map.
 275      *
 276      * @return the number of key-value mappings in this map
 277      */
 278     public int size() {
 279         return size;
 280     }
 281 
 282     /**
 283      * Returns {@code true} if this identity hash map contains no key-value
 284      * mappings.
 285      *
 286      * @return {@code true} if this identity hash map contains no key-value
 287      *         mappings
 288      */
 289     public boolean isEmpty() {
 290         return size == 0;
 291     }
 292 
 293     /**
 294      * Returns index for Object x.
 295      */
 296     private static int hash(Object x, int length) {
 297         int h = System.identityHashCode(x);
<a name="4" id="anc4"></a><span class="line-modified"> 298         // Multiply by -254 to use the hash LSB and to ensure index is even</span>
 299         return ((h &lt;&lt; 1) - (h &lt;&lt; 8)) &amp; (length - 1);
 300     }
 301 
 302     /**
 303      * Circularly traverses table of size len.
 304      */
 305     private static int nextKeyIndex(int i, int len) {
 306         return (i + 2 &lt; len ? i + 2 : 0);
 307     }
 308 
 309     /**
 310      * Returns the value to which the specified key is mapped,
 311      * or {@code null} if this map contains no mapping for the key.
 312      *
 313      * &lt;p&gt;More formally, if this map contains a mapping from a key
 314      * {@code k} to a value {@code v} such that {@code (key == k)},
 315      * then this method returns {@code v}; otherwise it returns
 316      * {@code null}.  (There can be at most one such mapping.)
 317      *
 318      * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
 319      * indicate that the map contains no mapping for the key; it&#39;s also
 320      * possible that the map explicitly maps the key to {@code null}.
 321      * The {@link #containsKey containsKey} operation may be used to
 322      * distinguish these two cases.
 323      *
 324      * @see #put(Object, Object)
 325      */
 326     @SuppressWarnings(&quot;unchecked&quot;)
 327     public V get(Object key) {
 328         Object k = maskNull(key);
 329         Object[] tab = table;
 330         int len = tab.length;
 331         int i = hash(k, len);
 332         while (true) {
 333             Object item = tab[i];
 334             if (item == k)
 335                 return (V) tab[i + 1];
 336             if (item == null)
 337                 return null;
 338             i = nextKeyIndex(i, len);
 339         }
 340     }
 341 
 342     /**
 343      * Tests whether the specified object reference is a key in this identity
 344      * hash map.
 345      *
 346      * @param   key   possible key
 347      * @return  {@code true} if the specified object reference is a key
 348      *          in this map
 349      * @see     #containsValue(Object)
 350      */
 351     public boolean containsKey(Object key) {
 352         Object k = maskNull(key);
 353         Object[] tab = table;
 354         int len = tab.length;
 355         int i = hash(k, len);
 356         while (true) {
 357             Object item = tab[i];
 358             if (item == k)
 359                 return true;
 360             if (item == null)
 361                 return false;
 362             i = nextKeyIndex(i, len);
 363         }
 364     }
 365 
 366     /**
 367      * Tests whether the specified object reference is a value in this identity
 368      * hash map.
 369      *
 370      * @param value value whose presence in this map is to be tested
 371      * @return {@code true} if this map maps one or more keys to the
 372      *         specified object reference
 373      * @see     #containsKey(Object)
 374      */
 375     public boolean containsValue(Object value) {
 376         Object[] tab = table;
 377         for (int i = 1; i &lt; tab.length; i += 2)
 378             if (tab[i] == value &amp;&amp; tab[i - 1] != null)
 379                 return true;
 380 
 381         return false;
 382     }
 383 
 384     /**
 385      * Tests if the specified key-value mapping is in the map.
 386      *
 387      * @param   key   possible key
 388      * @param   value possible value
 389      * @return  {@code true} if and only if the specified key-value
 390      *          mapping is in the map
 391      */
 392     private boolean containsMapping(Object key, Object value) {
 393         Object k = maskNull(key);
 394         Object[] tab = table;
 395         int len = tab.length;
 396         int i = hash(k, len);
 397         while (true) {
 398             Object item = tab[i];
 399             if (item == k)
 400                 return tab[i + 1] == value;
 401             if (item == null)
 402                 return false;
 403             i = nextKeyIndex(i, len);
 404         }
 405     }
 406 
 407     /**
 408      * Associates the specified value with the specified key in this identity
 409      * hash map.  If the map previously contained a mapping for the key, the
 410      * old value is replaced.
 411      *
 412      * @param key the key with which the specified value is to be associated
 413      * @param value the value to be associated with the specified key
 414      * @return the previous value associated with {@code key}, or
 415      *         {@code null} if there was no mapping for {@code key}.
 416      *         (A {@code null} return can also indicate that the map
 417      *         previously associated {@code null} with {@code key}.)
 418      * @see     Object#equals(Object)
 419      * @see     #get(Object)
 420      * @see     #containsKey(Object)
 421      */
 422     public V put(K key, V value) {
 423         final Object k = maskNull(key);
 424 
 425         retryAfterResize: for (;;) {
 426             final Object[] tab = table;
 427             final int len = tab.length;
 428             int i = hash(k, len);
 429 
 430             for (Object item; (item = tab[i]) != null;
 431                  i = nextKeyIndex(i, len)) {
 432                 if (item == k) {
 433                     @SuppressWarnings(&quot;unchecked&quot;)
 434                         V oldValue = (V) tab[i + 1];
 435                     tab[i + 1] = value;
 436                     return oldValue;
 437                 }
 438             }
 439 
 440             final int s = size + 1;
 441             // Use optimized form of 3 * s.
 442             // Next capacity is len, 2 * current capacity.
 443             if (s + (s &lt;&lt; 1) &gt; len &amp;&amp; resize(len))
 444                 continue retryAfterResize;
 445 
 446             modCount++;
 447             tab[i] = k;
 448             tab[i + 1] = value;
 449             size = s;
 450             return null;
 451         }
 452     }
 453 
 454     /**
 455      * Resizes the table if necessary to hold given capacity.
 456      *
 457      * @param newCapacity the new capacity, must be a power of two.
 458      * @return whether a resize did in fact take place
 459      */
 460     private boolean resize(int newCapacity) {
 461         // assert (newCapacity &amp; -newCapacity) == newCapacity; // power of 2
 462         int newLength = newCapacity * 2;
 463 
 464         Object[] oldTable = table;
 465         int oldLength = oldTable.length;
 466         if (oldLength == 2 * MAXIMUM_CAPACITY) { // can&#39;t expand any further
 467             if (size == MAXIMUM_CAPACITY - 1)
 468                 throw new IllegalStateException(&quot;Capacity exhausted.&quot;);
 469             return false;
 470         }
 471         if (oldLength &gt;= newLength)
 472             return false;
 473 
 474         Object[] newTable = new Object[newLength];
 475 
 476         for (int j = 0; j &lt; oldLength; j += 2) {
 477             Object key = oldTable[j];
 478             if (key != null) {
 479                 Object value = oldTable[j+1];
 480                 oldTable[j] = null;
 481                 oldTable[j+1] = null;
 482                 int i = hash(key, newLength);
 483                 while (newTable[i] != null)
 484                     i = nextKeyIndex(i, newLength);
 485                 newTable[i] = key;
 486                 newTable[i + 1] = value;
 487             }
 488         }
 489         table = newTable;
 490         return true;
 491     }
 492 
 493     /**
 494      * Copies all of the mappings from the specified map to this map.
 495      * These mappings will replace any mappings that this map had for
 496      * any of the keys currently in the specified map.
 497      *
 498      * @param m mappings to be stored in this map
 499      * @throws NullPointerException if the specified map is null
 500      */
 501     public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
 502         int n = m.size();
 503         if (n == 0)
 504             return;
 505         if (n &gt; size)
 506             resize(capacity(n)); // conservatively pre-expand
 507 
 508         for (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
 509             put(e.getKey(), e.getValue());
 510     }
 511 
 512     /**
 513      * Removes the mapping for this key from this map if present.
 514      *
 515      * @param key key whose mapping is to be removed from the map
 516      * @return the previous value associated with {@code key}, or
 517      *         {@code null} if there was no mapping for {@code key}.
 518      *         (A {@code null} return can also indicate that the map
 519      *         previously associated {@code null} with {@code key}.)
 520      */
 521     public V remove(Object key) {
 522         Object k = maskNull(key);
 523         Object[] tab = table;
 524         int len = tab.length;
 525         int i = hash(k, len);
 526 
 527         while (true) {
 528             Object item = tab[i];
 529             if (item == k) {
 530                 modCount++;
 531                 size--;
 532                 @SuppressWarnings(&quot;unchecked&quot;)
 533                     V oldValue = (V) tab[i + 1];
 534                 tab[i + 1] = null;
 535                 tab[i] = null;
 536                 closeDeletion(i);
 537                 return oldValue;
 538             }
 539             if (item == null)
 540                 return null;
 541             i = nextKeyIndex(i, len);
 542         }
 543     }
 544 
 545     /**
 546      * Removes the specified key-value mapping from the map if it is present.
 547      *
 548      * @param   key   possible key
 549      * @param   value possible value
 550      * @return  {@code true} if and only if the specified key-value
 551      *          mapping was in the map
 552      */
 553     private boolean removeMapping(Object key, Object value) {
 554         Object k = maskNull(key);
 555         Object[] tab = table;
 556         int len = tab.length;
 557         int i = hash(k, len);
 558 
 559         while (true) {
 560             Object item = tab[i];
 561             if (item == k) {
 562                 if (tab[i + 1] != value)
 563                     return false;
 564                 modCount++;
 565                 size--;
 566                 tab[i] = null;
 567                 tab[i + 1] = null;
 568                 closeDeletion(i);
 569                 return true;
 570             }
 571             if (item == null)
 572                 return false;
 573             i = nextKeyIndex(i, len);
 574         }
 575     }
 576 
 577     /**
 578      * Rehash all possibly-colliding entries following a
 579      * deletion. This preserves the linear-probe
 580      * collision properties required by get, put, etc.
 581      *
 582      * @param d the index of a newly empty deleted slot
 583      */
 584     private void closeDeletion(int d) {
 585         // Adapted from Knuth Section 6.4 Algorithm R
 586         Object[] tab = table;
 587         int len = tab.length;
 588 
 589         // Look for items to swap into newly vacated slot
 590         // starting at index immediately following deletion,
 591         // and continuing until a null slot is seen, indicating
 592         // the end of a run of possibly-colliding keys.
 593         Object item;
 594         for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;
 595              i = nextKeyIndex(i, len) ) {
 596             // The following test triggers if the item at slot i (which
 597             // hashes to be at slot r) should take the spot vacated by d.
 598             // If so, we swap it in, and then continue with d now at the
 599             // newly vacated i.  This process will terminate when we hit
 600             // the null slot at the end of this run.
 601             // The test is messy because we are using a circular table.
 602             int r = hash(item, len);
 603             if ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) {
 604                 tab[d] = item;
 605                 tab[d + 1] = tab[i + 1];
 606                 tab[i] = null;
 607                 tab[i + 1] = null;
 608                 d = i;
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Removes all of the mappings from this map.
 615      * The map will be empty after this call returns.
 616      */
 617     public void clear() {
 618         modCount++;
 619         Object[] tab = table;
 620         for (int i = 0; i &lt; tab.length; i++)
 621             tab[i] = null;
 622         size = 0;
 623     }
 624 
 625     /**
 626      * Compares the specified object with this map for equality.  Returns
 627      * {@code true} if the given object is also a map and the two maps
 628      * represent identical object-reference mappings.  More formally, this
 629      * map is equal to another map {@code m} if and only if
 630      * {@code this.entrySet().equals(m.entrySet())}.
 631      *
 632      * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of this map it is
 633      * possible that the symmetry and transitivity requirements of the
 634      * {@code Object.equals} contract may be violated if this map is compared
 635      * to a normal map.  However, the {@code Object.equals} contract is
 636      * guaranteed to hold among {@code IdentityHashMap} instances.&lt;/b&gt;
 637      *
 638      * @param  o object to be compared for equality with this map
 639      * @return {@code true} if the specified object is equal to this map
 640      * @see Object#equals(Object)
 641      */
 642     public boolean equals(Object o) {
 643         if (o == this) {
 644             return true;
 645         } else if (o instanceof IdentityHashMap) {
 646             IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;
 647             if (m.size() != size)
 648                 return false;
 649 
 650             Object[] tab = m.table;
 651             for (int i = 0; i &lt; tab.length; i+=2) {
 652                 Object k = tab[i];
 653                 if (k != null &amp;&amp; !containsMapping(k, tab[i + 1]))
 654                     return false;
 655             }
 656             return true;
 657         } else if (o instanceof Map) {
 658             Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;
 659             return entrySet().equals(m.entrySet());
 660         } else {
 661             return false;  // o is not a Map
 662         }
 663     }
 664 
 665     /**
 666      * Returns the hash code value for this map.  The hash code of a map is
 667      * defined to be the sum of the hash codes of each entry in the map&#39;s
 668      * {@code entrySet()} view.  This ensures that {@code m1.equals(m2)}
 669      * implies that {@code m1.hashCode()==m2.hashCode()} for any two
 670      * {@code IdentityHashMap} instances {@code m1} and {@code m2}, as
 671      * required by the general contract of {@link Object#hashCode}.
 672      *
 673      * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the
 674      * {@code Map.Entry} instances in the set returned by this map&#39;s
 675      * {@code entrySet} method, it is possible that the contractual
 676      * requirement of {@code Object.hashCode} mentioned in the previous
 677      * paragraph will be violated if one of the two objects being compared is
 678      * an {@code IdentityHashMap} instance and the other is a normal map.&lt;/b&gt;
 679      *
 680      * @return the hash code value for this map
 681      * @see Object#equals(Object)
 682      * @see #equals(Object)
 683      */
 684     public int hashCode() {
 685         int result = 0;
 686         Object[] tab = table;
 687         for (int i = 0; i &lt; tab.length; i +=2) {
 688             Object key = tab[i];
 689             if (key != null) {
 690                 Object k = unmaskNull(key);
 691                 result += System.identityHashCode(k) ^
 692                           System.identityHashCode(tab[i + 1]);
 693             }
 694         }
 695         return result;
 696     }
 697 
 698     /**
 699      * Returns a shallow copy of this identity hash map: the keys and values
 700      * themselves are not cloned.
 701      *
 702      * @return a shallow copy of this map
 703      */
 704     public Object clone() {
 705         try {
 706             IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) super.clone();
 707             m.entrySet = null;
 708             m.table = table.clone();
 709             return m;
 710         } catch (CloneNotSupportedException e) {
 711             throw new InternalError(e);
 712         }
 713     }
 714 
 715     private abstract class IdentityHashMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {
 716         int index = (size != 0 ? 0 : table.length); // current slot.
 717         int expectedModCount = modCount; // to support fast-fail
 718         int lastReturnedIndex = -1;      // to allow remove()
 719         boolean indexValid; // To avoid unnecessary next computation
 720         Object[] traversalTable = table; // reference to main table or copy
 721 
 722         public boolean hasNext() {
 723             Object[] tab = traversalTable;
 724             for (int i = index; i &lt; tab.length; i+=2) {
 725                 Object key = tab[i];
 726                 if (key != null) {
 727                     index = i;
 728                     return indexValid = true;
 729                 }
 730             }
 731             index = tab.length;
 732             return false;
 733         }
 734 
 735         protected int nextIndex() {
 736             if (modCount != expectedModCount)
 737                 throw new ConcurrentModificationException();
 738             if (!indexValid &amp;&amp; !hasNext())
 739                 throw new NoSuchElementException();
 740 
 741             indexValid = false;
 742             lastReturnedIndex = index;
 743             index += 2;
 744             return lastReturnedIndex;
 745         }
 746 
 747         public void remove() {
 748             if (lastReturnedIndex == -1)
 749                 throw new IllegalStateException();
 750             if (modCount != expectedModCount)
 751                 throw new ConcurrentModificationException();
 752 
 753             expectedModCount = ++modCount;
 754             int deletedSlot = lastReturnedIndex;
 755             lastReturnedIndex = -1;
 756             // back up index to revisit new contents after deletion
 757             index = deletedSlot;
 758             indexValid = false;
 759 
 760             // Removal code proceeds as in closeDeletion except that
 761             // it must catch the rare case where an element already
 762             // seen is swapped into a vacant slot that will be later
 763             // traversed by this iterator. We cannot allow future
 764             // next() calls to return it again.  The likelihood of
 765             // this occurring under 2/3 load factor is very slim, but
 766             // when it does happen, we must make a copy of the rest of
 767             // the table to use for the rest of the traversal. Since
 768             // this can only happen when we are near the end of the table,
 769             // even in these rare cases, this is not very expensive in
 770             // time or space.
 771 
 772             Object[] tab = traversalTable;
 773             int len = tab.length;
 774 
 775             int d = deletedSlot;
 776             Object key = tab[d];
 777             tab[d] = null;        // vacate the slot
 778             tab[d + 1] = null;
 779 
 780             // If traversing a copy, remove in real table.
 781             // We can skip gap-closure on copy.
 782             if (tab != IdentityHashMap.this.table) {
 783                 IdentityHashMap.this.remove(key);
 784                 expectedModCount = modCount;
 785                 return;
 786             }
 787 
 788             size--;
 789 
 790             Object item;
 791             for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;
 792                  i = nextKeyIndex(i, len)) {
 793                 int r = hash(item, len);
 794                 // See closeDeletion for explanation of this conditional
 795                 if ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) ||
 796                     (r &lt;= d &amp;&amp; d &lt;= i)) {
 797 
 798                     // If we are about to swap an already-seen element
 799                     // into a slot that may later be returned by next(),
 800                     // then clone the rest of table for use in future
 801                     // next() calls. It is OK that our copy will have
 802                     // a gap in the &quot;wrong&quot; place, since it will never
 803                     // be used for searching anyway.
 804 
 805                     if (i &lt; deletedSlot &amp;&amp; d &gt;= deletedSlot &amp;&amp;
 806                         traversalTable == IdentityHashMap.this.table) {
 807                         int remaining = len - deletedSlot;
 808                         Object[] newTable = new Object[remaining];
 809                         System.arraycopy(tab, deletedSlot,
 810                                          newTable, 0, remaining);
 811                         traversalTable = newTable;
 812                         index = 0;
 813                     }
 814 
 815                     tab[d] = item;
 816                     tab[d + 1] = tab[i + 1];
 817                     tab[i] = null;
 818                     tab[i + 1] = null;
 819                     d = i;
 820                 }
 821             }
 822         }
 823     }
 824 
 825     private class KeyIterator extends IdentityHashMapIterator&lt;K&gt; {
 826         @SuppressWarnings(&quot;unchecked&quot;)
 827         public K next() {
 828             return (K) unmaskNull(traversalTable[nextIndex()]);
 829         }
 830     }
 831 
 832     private class ValueIterator extends IdentityHashMapIterator&lt;V&gt; {
 833         @SuppressWarnings(&quot;unchecked&quot;)
 834         public V next() {
 835             return (V) traversalTable[nextIndex() + 1];
 836         }
 837     }
 838 
 839     private class EntryIterator
 840         extends IdentityHashMapIterator&lt;Map.Entry&lt;K,V&gt;&gt;
 841     {
 842         private Entry lastReturnedEntry;
 843 
 844         public Map.Entry&lt;K,V&gt; next() {
 845             lastReturnedEntry = new Entry(nextIndex());
 846             return lastReturnedEntry;
 847         }
 848 
 849         public void remove() {
 850             lastReturnedIndex =
 851                 ((null == lastReturnedEntry) ? -1 : lastReturnedEntry.index);
 852             super.remove();
 853             lastReturnedEntry.index = lastReturnedIndex;
 854             lastReturnedEntry = null;
 855         }
 856 
 857         private class Entry implements Map.Entry&lt;K,V&gt; {
 858             private int index;
 859 
 860             private Entry(int index) {
 861                 this.index = index;
 862             }
 863 
 864             @SuppressWarnings(&quot;unchecked&quot;)
 865             public K getKey() {
 866                 checkIndexForEntryUse();
 867                 return (K) unmaskNull(traversalTable[index]);
 868             }
 869 
 870             @SuppressWarnings(&quot;unchecked&quot;)
 871             public V getValue() {
 872                 checkIndexForEntryUse();
 873                 return (V) traversalTable[index+1];
 874             }
 875 
 876             @SuppressWarnings(&quot;unchecked&quot;)
 877             public V setValue(V value) {
 878                 checkIndexForEntryUse();
 879                 V oldValue = (V) traversalTable[index+1];
 880                 traversalTable[index+1] = value;
 881                 // if shadowing, force into main table
 882                 if (traversalTable != IdentityHashMap.this.table)
 883                     put((K) traversalTable[index], value);
 884                 return oldValue;
 885             }
 886 
 887             public boolean equals(Object o) {
 888                 if (index &lt; 0)
 889                     return super.equals(o);
 890 
 891                 if (!(o instanceof Map.Entry))
 892                     return false;
 893                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
 894                 return (e.getKey() == unmaskNull(traversalTable[index]) &amp;&amp;
 895                        e.getValue() == traversalTable[index+1]);
 896             }
 897 
 898             public int hashCode() {
 899                 if (lastReturnedIndex &lt; 0)
 900                     return super.hashCode();
 901 
 902                 return (System.identityHashCode(unmaskNull(traversalTable[index])) ^
 903                        System.identityHashCode(traversalTable[index+1]));
 904             }
 905 
 906             public String toString() {
 907                 if (index &lt; 0)
 908                     return super.toString();
 909 
 910                 return (unmaskNull(traversalTable[index]) + &quot;=&quot;
 911                         + traversalTable[index+1]);
 912             }
 913 
 914             private void checkIndexForEntryUse() {
 915                 if (index &lt; 0)
 916                     throw new IllegalStateException(&quot;Entry was removed&quot;);
 917             }
 918         }
 919     }
 920 
 921     // Views
 922 
 923     /**
 924      * This field is initialized to contain an instance of the entry set
 925      * view the first time this view is requested.  The view is stateless,
 926      * so there&#39;s no reason to create more than one.
 927      */
 928     private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
 929 
 930     /**
 931      * Returns an identity-based set view of the keys contained in this map.
 932      * The set is backed by the map, so changes to the map are reflected in
 933      * the set, and vice-versa.  If the map is modified while an iteration
 934      * over the set is in progress, the results of the iteration are
 935      * undefined.  The set supports element removal, which removes the
 936      * corresponding mapping from the map, via the {@code Iterator.remove},
 937      * {@code Set.remove}, {@code removeAll}, {@code retainAll}, and
 938      * {@code clear} methods.  It does not support the {@code add} or
 939      * {@code addAll} methods.
 940      *
 941      * &lt;p&gt;&lt;b&gt;While the object returned by this method implements the
 942      * {@code Set} interface, it does &lt;i&gt;not&lt;/i&gt; obey {@code Set&#39;s} general
 943      * contract.  Like its backing map, the set returned by this method
 944      * defines element equality as reference-equality rather than
 945      * object-equality.  This affects the behavior of its {@code contains},
 946      * {@code remove}, {@code containsAll}, {@code equals}, and
 947      * {@code hashCode} methods.&lt;/b&gt;
 948      *
 949      * &lt;p&gt;&lt;b&gt;The {@code equals} method of the returned set returns {@code true}
 950      * only if the specified object is a set containing exactly the same
 951      * object references as the returned set.  The symmetry and transitivity
 952      * requirements of the {@code Object.equals} contract may be violated if
 953      * the set returned by this method is compared to a normal set.  However,
 954      * the {@code Object.equals} contract is guaranteed to hold among sets
 955      * returned by this method.&lt;/b&gt;
 956      *
 957      * &lt;p&gt;The {@code hashCode} method of the returned set returns the sum of
 958      * the &lt;i&gt;identity hashcodes&lt;/i&gt; of the elements in the set, rather than
 959      * the sum of their hashcodes.  This is mandated by the change in the
 960      * semantics of the {@code equals} method, in order to enforce the
 961      * general contract of the {@code Object.hashCode} method among sets
 962      * returned by this method.
 963      *
 964      * @return an identity-based set view of the keys contained in this map
 965      * @see Object#equals(Object)
 966      * @see System#identityHashCode(Object)
 967      */
 968     public Set&lt;K&gt; keySet() {
 969         Set&lt;K&gt; ks = keySet;
 970         if (ks == null) {
 971             ks = new KeySet();
 972             keySet = ks;
 973         }
 974         return ks;
 975     }
 976 
 977     private class KeySet extends AbstractSet&lt;K&gt; {
 978         public Iterator&lt;K&gt; iterator() {
 979             return new KeyIterator();
 980         }
 981         public int size() {
 982             return size;
 983         }
 984         public boolean contains(Object o) {
 985             return containsKey(o);
 986         }
 987         public boolean remove(Object o) {
 988             int oldSize = size;
 989             IdentityHashMap.this.remove(o);
 990             return size != oldSize;
 991         }
 992         /*
 993          * Must revert from AbstractSet&#39;s impl to AbstractCollection&#39;s, as
 994          * the former contains an optimization that results in incorrect
 995          * behavior when c is a smaller &quot;normal&quot; (non-identity-based) Set.
 996          */
 997         public boolean removeAll(Collection&lt;?&gt; c) {
 998             Objects.requireNonNull(c);
 999             boolean modified = false;
1000             for (Iterator&lt;K&gt; i = iterator(); i.hasNext(); ) {
1001                 if (c.contains(i.next())) {
1002                     i.remove();
1003                     modified = true;
1004                 }
1005             }
1006             return modified;
1007         }
1008         public void clear() {
1009             IdentityHashMap.this.clear();
1010         }
1011         public int hashCode() {
1012             int result = 0;
1013             for (K key : this)
1014                 result += System.identityHashCode(key);
1015             return result;
1016         }
1017         public Object[] toArray() {
1018             return toArray(new Object[0]);
1019         }
1020         @SuppressWarnings(&quot;unchecked&quot;)
1021         public &lt;T&gt; T[] toArray(T[] a) {
1022             int expectedModCount = modCount;
1023             int size = size();
1024             if (a.length &lt; size)
1025                 a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
1026             Object[] tab = table;
1027             int ti = 0;
1028             for (int si = 0; si &lt; tab.length; si += 2) {
1029                 Object key;
1030                 if ((key = tab[si]) != null) { // key present ?
1031                     // more elements than expected -&gt; concurrent modification from other thread
1032                     if (ti &gt;= size) {
1033                         throw new ConcurrentModificationException();
1034                     }
1035                     a[ti++] = (T) unmaskNull(key); // unmask key
1036                 }
1037             }
1038             // fewer elements than expected or concurrent modification from other thread detected
1039             if (ti &lt; size || expectedModCount != modCount) {
1040                 throw new ConcurrentModificationException();
1041             }
1042             // final null marker as per spec
1043             if (ti &lt; a.length) {
1044                 a[ti] = null;
1045             }
1046             return a;
1047         }
1048 
1049         public Spliterator&lt;K&gt; spliterator() {
1050             return new KeySpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);
1051         }
1052     }
1053 
1054     /**
1055      * Returns a {@link Collection} view of the values contained in this map.
1056      * The collection is backed by the map, so changes to the map are
1057      * reflected in the collection, and vice-versa.  If the map is
1058      * modified while an iteration over the collection is in progress,
1059      * the results of the iteration are undefined.  The collection
1060      * supports element removal, which removes the corresponding
1061      * mapping from the map, via the {@code Iterator.remove},
1062      * {@code Collection.remove}, {@code removeAll},
1063      * {@code retainAll} and {@code clear} methods.  It does not
1064      * support the {@code add} or {@code addAll} methods.
1065      *
1066      * &lt;p&gt;&lt;b&gt;While the object returned by this method implements the
1067      * {@code Collection} interface, it does &lt;i&gt;not&lt;/i&gt; obey
1068      * {@code Collection&#39;s} general contract.  Like its backing map,
1069      * the collection returned by this method defines element equality as
1070      * reference-equality rather than object-equality.  This affects the
1071      * behavior of its {@code contains}, {@code remove} and
1072      * {@code containsAll} methods.&lt;/b&gt;
1073      */
1074     public Collection&lt;V&gt; values() {
1075         Collection&lt;V&gt; vs = values;
1076         if (vs == null) {
1077             vs = new Values();
1078             values = vs;
1079         }
1080         return vs;
1081     }
1082 
1083     private class Values extends AbstractCollection&lt;V&gt; {
1084         public Iterator&lt;V&gt; iterator() {
1085             return new ValueIterator();
1086         }
1087         public int size() {
1088             return size;
1089         }
1090         public boolean contains(Object o) {
1091             return containsValue(o);
1092         }
1093         public boolean remove(Object o) {
1094             for (Iterator&lt;V&gt; i = iterator(); i.hasNext(); ) {
1095                 if (i.next() == o) {
1096                     i.remove();
1097                     return true;
1098                 }
1099             }
1100             return false;
1101         }
1102         public void clear() {
1103             IdentityHashMap.this.clear();
1104         }
1105         public Object[] toArray() {
1106             return toArray(new Object[0]);
1107         }
1108         @SuppressWarnings(&quot;unchecked&quot;)
1109         public &lt;T&gt; T[] toArray(T[] a) {
1110             int expectedModCount = modCount;
1111             int size = size();
1112             if (a.length &lt; size)
1113                 a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
1114             Object[] tab = table;
1115             int ti = 0;
1116             for (int si = 0; si &lt; tab.length; si += 2) {
1117                 if (tab[si] != null) { // key present ?
1118                     // more elements than expected -&gt; concurrent modification from other thread
1119                     if (ti &gt;= size) {
1120                         throw new ConcurrentModificationException();
1121                     }
1122                     a[ti++] = (T) tab[si+1]; // copy value
1123                 }
1124             }
1125             // fewer elements than expected or concurrent modification from other thread detected
1126             if (ti &lt; size || expectedModCount != modCount) {
1127                 throw new ConcurrentModificationException();
1128             }
1129             // final null marker as per spec
1130             if (ti &lt; a.length) {
1131                 a[ti] = null;
1132             }
1133             return a;
1134         }
1135 
1136         public Spliterator&lt;V&gt; spliterator() {
1137             return new ValueSpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);
1138         }
1139     }
1140 
1141     /**
1142      * Returns a {@link Set} view of the mappings contained in this map.
1143      * Each element in the returned set is a reference-equality-based
1144      * {@code Map.Entry}.  The set is backed by the map, so changes
1145      * to the map are reflected in the set, and vice-versa.  If the
1146      * map is modified while an iteration over the set is in progress,
1147      * the results of the iteration are undefined.  The set supports
1148      * element removal, which removes the corresponding mapping from
1149      * the map, via the {@code Iterator.remove}, {@code Set.remove},
1150      * {@code removeAll}, {@code retainAll} and {@code clear}
1151      * methods.  It does not support the {@code add} or
1152      * {@code addAll} methods.
1153      *
1154      * &lt;p&gt;Like the backing map, the {@code Map.Entry} objects in the set
1155      * returned by this method define key and value equality as
1156      * reference-equality rather than object-equality.  This affects the
1157      * behavior of the {@code equals} and {@code hashCode} methods of these
1158      * {@code Map.Entry} objects.  A reference-equality based {@code Map.Entry
1159      * e} is equal to an object {@code o} if and only if {@code o} is a
1160      * {@code Map.Entry} and {@code e.getKey()==o.getKey() &amp;&amp;
1161      * e.getValue()==o.getValue()}.  To accommodate these equals
1162      * semantics, the {@code hashCode} method returns
1163      * {@code System.identityHashCode(e.getKey()) ^
1164      * System.identityHashCode(e.getValue())}.
1165      *
1166      * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the
1167      * {@code Map.Entry} instances in the set returned by this method,
1168      * it is possible that the symmetry and transitivity requirements of
1169      * the {@link Object#equals(Object)} contract may be violated if any of
1170      * the entries in the set is compared to a normal map entry, or if
1171      * the set returned by this method is compared to a set of normal map
1172      * entries (such as would be returned by a call to this method on a normal
1173      * map).  However, the {@code Object.equals} contract is guaranteed to
1174      * hold among identity-based map entries, and among sets of such entries.
1175      * &lt;/b&gt;
1176      *
1177      * @return a set view of the identity-mappings contained in this map
1178      */
1179     public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1180         Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
1181         if (es != null)
1182             return es;
1183         else
1184             return entrySet = new EntrySet();
1185     }
1186 
1187     private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
1188         public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
1189             return new EntryIterator();
1190         }
1191         public boolean contains(Object o) {
1192             if (!(o instanceof Map.Entry))
1193                 return false;
1194             Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;
1195             return containsMapping(entry.getKey(), entry.getValue());
1196         }
1197         public boolean remove(Object o) {
1198             if (!(o instanceof Map.Entry))
1199                 return false;
1200             Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;
1201             return removeMapping(entry.getKey(), entry.getValue());
1202         }
1203         public int size() {
1204             return size;
1205         }
1206         public void clear() {
1207             IdentityHashMap.this.clear();
1208         }
1209         /*
1210          * Must revert from AbstractSet&#39;s impl to AbstractCollection&#39;s, as
1211          * the former contains an optimization that results in incorrect
1212          * behavior when c is a smaller &quot;normal&quot; (non-identity-based) Set.
1213          */
1214         public boolean removeAll(Collection&lt;?&gt; c) {
1215             Objects.requireNonNull(c);
1216             boolean modified = false;
1217             for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = iterator(); i.hasNext(); ) {
1218                 if (c.contains(i.next())) {
1219                     i.remove();
1220                     modified = true;
1221                 }
1222             }
1223             return modified;
1224         }
1225 
1226         public Object[] toArray() {
1227             return toArray(new Object[0]);
1228         }
1229 
1230         @SuppressWarnings(&quot;unchecked&quot;)
1231         public &lt;T&gt; T[] toArray(T[] a) {
1232             int expectedModCount = modCount;
1233             int size = size();
1234             if (a.length &lt; size)
1235                 a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
1236             Object[] tab = table;
1237             int ti = 0;
1238             for (int si = 0; si &lt; tab.length; si += 2) {
1239                 Object key;
1240                 if ((key = tab[si]) != null) { // key present ?
1241                     // more elements than expected -&gt; concurrent modification from other thread
1242                     if (ti &gt;= size) {
1243                         throw new ConcurrentModificationException();
1244                     }
1245                     a[ti++] = (T) new AbstractMap.SimpleEntry&lt;&gt;(unmaskNull(key), tab[si + 1]);
1246                 }
1247             }
1248             // fewer elements than expected or concurrent modification from other thread detected
1249             if (ti &lt; size || expectedModCount != modCount) {
1250                 throw new ConcurrentModificationException();
1251             }
1252             // final null marker as per spec
1253             if (ti &lt; a.length) {
1254                 a[ti] = null;
1255             }
1256             return a;
1257         }
1258 
1259         public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
1260             return new EntrySpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);
1261         }
1262     }
1263 
<a name="5" id="anc5"></a><span class="line-modified">1264     @java.io.Serial</span>
1265     private static final long serialVersionUID = 8188218128353913216L;
1266 
1267     /**
1268      * Saves the state of the {@code IdentityHashMap} instance to a stream
1269      * (i.e., serializes it).
1270      *
1271      * @serialData The &lt;i&gt;size&lt;/i&gt; of the HashMap (the number of key-value
1272      *          mappings) ({@code int}), followed by the key (Object) and
1273      *          value (Object) for each key-value mapping represented by the
1274      *          IdentityHashMap.  The key-value mappings are emitted in no
1275      *          particular order.
1276      */
<a name="6" id="anc6"></a><span class="line-added">1277     @java.io.Serial</span>
1278     private void writeObject(java.io.ObjectOutputStream s)
1279         throws java.io.IOException  {
1280         // Write out and any hidden stuff
1281         s.defaultWriteObject();
1282 
1283         // Write out size (number of Mappings)
1284         s.writeInt(size);
1285 
1286         // Write out keys and values (alternating)
1287         Object[] tab = table;
1288         for (int i = 0; i &lt; tab.length; i += 2) {
1289             Object key = tab[i];
1290             if (key != null) {
1291                 s.writeObject(unmaskNull(key));
1292                 s.writeObject(tab[i + 1]);
1293             }
1294         }
1295     }
1296 
1297     /**
1298      * Reconstitutes the {@code IdentityHashMap} instance from a stream (i.e.,
1299      * deserializes it).
1300      */
<a name="7" id="anc7"></a><span class="line-added">1301     @java.io.Serial</span>
1302     private void readObject(java.io.ObjectInputStream s)
1303         throws java.io.IOException, ClassNotFoundException  {
1304         // Read in any hidden stuff
1305         s.defaultReadObject();
1306 
1307         // Read in size (number of Mappings)
1308         int size = s.readInt();
1309         if (size &lt; 0)
1310             throw new java.io.StreamCorruptedException
1311                 (&quot;Illegal mappings count: &quot; + size);
1312         int cap = capacity(size);
1313         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, cap);
1314         init(cap);
1315 
1316         // Read the keys and values, and put the mappings in the table
1317         for (int i=0; i&lt;size; i++) {
1318             @SuppressWarnings(&quot;unchecked&quot;)
1319                 K key = (K) s.readObject();
1320             @SuppressWarnings(&quot;unchecked&quot;)
1321                 V value = (V) s.readObject();
1322             putForCreate(key, value);
1323         }
1324     }
1325 
1326     /**
1327      * The put method for readObject.  It does not resize the table,
1328      * update modCount, etc.
1329      */
1330     private void putForCreate(K key, V value)
1331         throws java.io.StreamCorruptedException
1332     {
1333         Object k = maskNull(key);
1334         Object[] tab = table;
1335         int len = tab.length;
1336         int i = hash(k, len);
1337 
1338         Object item;
1339         while ( (item = tab[i]) != null) {
1340             if (item == k)
1341                 throw new java.io.StreamCorruptedException();
1342             i = nextKeyIndex(i, len);
1343         }
1344         tab[i] = k;
1345         tab[i + 1] = value;
1346     }
1347 
1348     @SuppressWarnings(&quot;unchecked&quot;)
1349     @Override
1350     public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
1351         Objects.requireNonNull(action);
1352         int expectedModCount = modCount;
1353 
1354         Object[] t = table;
1355         for (int index = 0; index &lt; t.length; index += 2) {
1356             Object k = t[index];
1357             if (k != null) {
1358                 action.accept((K) unmaskNull(k), (V) t[index + 1]);
1359             }
1360 
1361             if (modCount != expectedModCount) {
1362                 throw new ConcurrentModificationException();
1363             }
1364         }
1365     }
1366 
1367     @SuppressWarnings(&quot;unchecked&quot;)
1368     @Override
1369     public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
1370         Objects.requireNonNull(function);
1371         int expectedModCount = modCount;
1372 
1373         Object[] t = table;
1374         for (int index = 0; index &lt; t.length; index += 2) {
1375             Object k = t[index];
1376             if (k != null) {
1377                 t[index + 1] = function.apply((K) unmaskNull(k), (V) t[index + 1]);
1378             }
1379 
1380             if (modCount != expectedModCount) {
1381                 throw new ConcurrentModificationException();
1382             }
1383         }
1384     }
1385 
1386     /**
1387      * Similar form as array-based Spliterators, but skips blank elements,
1388      * and guestimates size as decreasing by half per split.
1389      */
1390     static class IdentityHashMapSpliterator&lt;K,V&gt; {
1391         final IdentityHashMap&lt;K,V&gt; map;
1392         int index;             // current index, modified on advance/split
1393         int fence;             // -1 until first use; then one past last index
1394         int est;               // size estimate
1395         int expectedModCount;  // initialized when fence set
1396 
1397         IdentityHashMapSpliterator(IdentityHashMap&lt;K,V&gt; map, int origin,
1398                                    int fence, int est, int expectedModCount) {
1399             this.map = map;
1400             this.index = origin;
1401             this.fence = fence;
1402             this.est = est;
1403             this.expectedModCount = expectedModCount;
1404         }
1405 
1406         final int getFence() { // initialize fence and size on first use
1407             int hi;
1408             if ((hi = fence) &lt; 0) {
1409                 est = map.size;
1410                 expectedModCount = map.modCount;
1411                 hi = fence = map.table.length;
1412             }
1413             return hi;
1414         }
1415 
1416         public final long estimateSize() {
1417             getFence(); // force init
1418             return (long) est;
1419         }
1420     }
1421 
1422     static final class KeySpliterator&lt;K,V&gt;
1423         extends IdentityHashMapSpliterator&lt;K,V&gt;
1424         implements Spliterator&lt;K&gt; {
1425         KeySpliterator(IdentityHashMap&lt;K,V&gt; map, int origin, int fence, int est,
1426                        int expectedModCount) {
1427             super(map, origin, fence, est, expectedModCount);
1428         }
1429 
1430         public KeySpliterator&lt;K,V&gt; trySplit() {
1431             int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;
1432             return (lo &gt;= mid) ? null :
1433                 new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1434                                      expectedModCount);
1435         }
1436 
1437         @SuppressWarnings(&quot;unchecked&quot;)
1438         public void forEachRemaining(Consumer&lt;? super K&gt; action) {
1439             if (action == null)
1440                 throw new NullPointerException();
1441             int i, hi, mc; Object key;
1442             IdentityHashMap&lt;K,V&gt; m; Object[] a;
1443             if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;
1444                 (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {
1445                 for (; i &lt; hi; i += 2) {
1446                     if ((key = a[i]) != null)
1447                         action.accept((K)unmaskNull(key));
1448                 }
1449                 if (m.modCount == expectedModCount)
1450                     return;
1451             }
1452             throw new ConcurrentModificationException();
1453         }
1454 
1455         @SuppressWarnings(&quot;unchecked&quot;)
1456         public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
1457             if (action == null)
1458                 throw new NullPointerException();
1459             Object[] a = map.table;
1460             int hi = getFence();
1461             while (index &lt; hi) {
1462                 Object key = a[index];
1463                 index += 2;
1464                 if (key != null) {
1465                     action.accept((K)unmaskNull(key));
1466                     if (map.modCount != expectedModCount)
1467                         throw new ConcurrentModificationException();
1468                     return true;
1469                 }
1470             }
1471             return false;
1472         }
1473 
1474         public int characteristics() {
1475             return (fence &lt; 0 || est == map.size ? SIZED : 0) | Spliterator.DISTINCT;
1476         }
1477     }
1478 
1479     static final class ValueSpliterator&lt;K,V&gt;
1480         extends IdentityHashMapSpliterator&lt;K,V&gt;
1481         implements Spliterator&lt;V&gt; {
1482         ValueSpliterator(IdentityHashMap&lt;K,V&gt; m, int origin, int fence, int est,
1483                          int expectedModCount) {
1484             super(m, origin, fence, est, expectedModCount);
1485         }
1486 
1487         public ValueSpliterator&lt;K,V&gt; trySplit() {
1488             int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;
1489             return (lo &gt;= mid) ? null :
1490                 new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1491                                        expectedModCount);
1492         }
1493 
1494         public void forEachRemaining(Consumer&lt;? super V&gt; action) {
1495             if (action == null)
1496                 throw new NullPointerException();
1497             int i, hi, mc;
1498             IdentityHashMap&lt;K,V&gt; m; Object[] a;
1499             if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;
1500                 (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {
1501                 for (; i &lt; hi; i += 2) {
1502                     if (a[i] != null) {
1503                         @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[i+1];
1504                         action.accept(v);
1505                     }
1506                 }
1507                 if (m.modCount == expectedModCount)
1508                     return;
1509             }
1510             throw new ConcurrentModificationException();
1511         }
1512 
1513         public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
1514             if (action == null)
1515                 throw new NullPointerException();
1516             Object[] a = map.table;
1517             int hi = getFence();
1518             while (index &lt; hi) {
1519                 Object key = a[index];
1520                 @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[index+1];
1521                 index += 2;
1522                 if (key != null) {
1523                     action.accept(v);
1524                     if (map.modCount != expectedModCount)
1525                         throw new ConcurrentModificationException();
1526                     return true;
1527                 }
1528             }
1529             return false;
1530         }
1531 
1532         public int characteristics() {
1533             return (fence &lt; 0 || est == map.size ? SIZED : 0);
1534         }
1535 
1536     }
1537 
1538     static final class EntrySpliterator&lt;K,V&gt;
1539         extends IdentityHashMapSpliterator&lt;K,V&gt;
1540         implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1541         EntrySpliterator(IdentityHashMap&lt;K,V&gt; m, int origin, int fence, int est,
1542                          int expectedModCount) {
1543             super(m, origin, fence, est, expectedModCount);
1544         }
1545 
1546         public EntrySpliterator&lt;K,V&gt; trySplit() {
1547             int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;
1548             return (lo &gt;= mid) ? null :
1549                 new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1550                                        expectedModCount);
1551         }
1552 
1553         public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K, V&gt;&gt; action) {
1554             if (action == null)
1555                 throw new NullPointerException();
1556             int i, hi, mc;
1557             IdentityHashMap&lt;K,V&gt; m; Object[] a;
1558             if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;
1559                 (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {
1560                 for (; i &lt; hi; i += 2) {
1561                     Object key = a[i];
1562                     if (key != null) {
1563                         @SuppressWarnings(&quot;unchecked&quot;) K k =
1564                             (K)unmaskNull(key);
1565                         @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[i+1];
1566                         action.accept
1567                             (new AbstractMap.SimpleImmutableEntry&lt;&gt;(k, v));
1568 
1569                     }
1570                 }
1571                 if (m.modCount == expectedModCount)
1572                     return;
1573             }
1574             throw new ConcurrentModificationException();
1575         }
1576 
1577         public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
1578             if (action == null)
1579                 throw new NullPointerException();
1580             Object[] a = map.table;
1581             int hi = getFence();
1582             while (index &lt; hi) {
1583                 Object key = a[index];
1584                 @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[index+1];
1585                 index += 2;
1586                 if (key != null) {
1587                     @SuppressWarnings(&quot;unchecked&quot;) K k =
1588                         (K)unmaskNull(key);
1589                     action.accept
1590                         (new AbstractMap.SimpleImmutableEntry&lt;&gt;(k, v));
1591                     if (map.modCount != expectedModCount)
1592                         throw new ConcurrentModificationException();
1593                     return true;
1594                 }
1595             }
1596             return false;
1597         }
1598 
1599         public int characteristics() {
1600             return (fence &lt; 0 || est == map.size ? SIZED : 0) | Spliterator.DISTINCT;
1601         }
1602     }
1603 
1604 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Currency.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ConcurrentModificationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Date.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Currency.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  38 import java.text.SimpleDateFormat;
  39 import java.util.concurrent.ConcurrentHashMap;
  40 import java.util.concurrent.ConcurrentMap;
  41 import java.util.regex.Pattern;
  42 import java.util.regex.Matcher;
  43 import java.util.spi.CurrencyNameProvider;
  44 import java.util.stream.Collectors;
  45 
  46 import jdk.internal.util.StaticProperty;
  47 import sun.util.locale.provider.CalendarDataUtility;
  48 import sun.util.locale.provider.LocaleServiceProviderPool;
  49 import sun.util.logging.PlatformLogger;
  50 
  51 
  52 /**
  53  * Represents a currency. Currencies are identified by their ISO 4217 currency
  54  * codes. Visit the &lt;a href=&quot;http://www.iso.org/iso/home/standards/currency_codes.htm&quot;&gt;
  55  * ISO web site&lt;/a&gt; for more information.
  56  * &lt;p&gt;
  57  * The class is designed so that there&#39;s never more than one
<span class="line-modified">  58  * &lt;code&gt;Currency&lt;/code&gt; instance for any given currency. Therefore, there&#39;s</span>
<span class="line-modified">  59  * no public constructor. You obtain a &lt;code&gt;Currency&lt;/code&gt; instance using</span>
<span class="line-modified">  60  * the &lt;code&gt;getInstance&lt;/code&gt; methods.</span>
  61  * &lt;p&gt;
  62  * Users can supersede the Java runtime currency data by means of the system
  63  * property {@systemProperty java.util.currency.data}. If this system property is
  64  * defined then its value is the location of a properties file, the contents of
  65  * which are key/value pairs of the ISO 3166 country codes and the ISO 4217
  66  * currency data respectively.  The value part consists of three ISO 4217 values
  67  * of a currency, i.e., an alphabetic code, a numeric code, and a minor unit.
  68  * Those three ISO 4217 values are separated by commas.
  69  * The lines which start with &#39;#&#39;s are considered comment lines. An optional UTC
  70  * timestamp may be specified per currency entry if users need to specify a
  71  * cutover date indicating when the new data comes into effect. The timestamp is
  72  * appended to the end of the currency properties and uses a comma as a separator.
  73  * If a UTC datestamp is present and valid, the JRE will only use the new currency
  74  * properties if the current UTC date is later than the date specified at class
  75  * loading time. The format of the timestamp must be of ISO 8601 format :
  76  * {@code &#39;yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;}. For example,
  77  * &lt;p&gt;
  78  * &lt;code&gt;
  79  * #Sample currency properties&lt;br&gt;
  80  * JP=JPZ,999,0
</pre>
<hr />
<pre>
  96  * &lt;p&gt;
  97  * Where syntactically malformed entries are encountered, the entry is ignored
  98  * and the remainder of entries in file are processed. For instances where duplicate
  99  * country code entries exist, the behavior of the Currency information for that
 100  * {@code Currency} is undefined and the remainder of entries in file are processed.
 101  * &lt;p&gt;
 102  * If multiple property entries with same currency code but different numeric code
 103  * and/or minor unit are encountered, those entries are ignored and the remainder
 104  * of entries in file are processed.
 105  *
 106  * &lt;p&gt;
 107  * It is recommended to use {@link java.math.BigDecimal} class while dealing
 108  * with {@code Currency} or monetary values as it provides better handling of floating
 109  * point numbers and their operations.
 110  *
 111  * @see java.math.BigDecimal
 112  * @since 1.4
 113  */
 114 public final class Currency implements Serializable {
 115 

 116     private static final long serialVersionUID = -158308464356906721L;
 117 
 118     /**
 119      * ISO 4217 currency code for this currency.
 120      *
 121      * @serial
 122      */
 123     private final String currencyCode;
 124 
 125     /**
 126      * Default fraction digits for this currency.
 127      * Set from currency data tables.
 128      */
 129     private final transient int defaultFractionDigits;
 130 
 131     /**
 132      * ISO 4217 numeric code for this currency.
 133      * Set from currency data tables.
 134      */
 135     private final transient int numericCode;
</pre>
<hr />
<pre>
 256                                 = getValidCurrencyData(props, propertiesPattern);
 257                         currencyEntries.forEach(Currency::replaceCurrencyData);
 258                     }
 259                 } catch (IOException e) {
 260                     CurrencyProperty.info(&quot;currency.properties is ignored&quot;
 261                             + &quot; because of an IOException&quot;, e);
 262                 }
 263                 return null;
 264             }
 265         });
 266     }
 267 
 268     /**
 269      * Constants for retrieving localized names from the name providers.
 270      */
 271     private static final int SYMBOL = 0;
 272     private static final int DISPLAYNAME = 1;
 273 
 274 
 275     /**
<span class="line-modified"> 276      * Constructs a &lt;code&gt;Currency&lt;/code&gt; instance. The constructor is private</span>
 277      * so that we can insure that there&#39;s never more than one instance for a
 278      * given currency.
 279      */
 280     private Currency(String currencyCode, int defaultFractionDigits, int numericCode) {
 281         this.currencyCode = currencyCode;
 282         this.defaultFractionDigits = defaultFractionDigits;
 283         this.numericCode = numericCode;
 284     }
 285 
 286     /**
<span class="line-modified"> 287      * Returns the &lt;code&gt;Currency&lt;/code&gt; instance for the given currency code.</span>
 288      *
 289      * @param currencyCode the ISO 4217 code of the currency
<span class="line-modified"> 290      * @return the &lt;code&gt;Currency&lt;/code&gt; instance for the given currency code</span>
<span class="line-modified"> 291      * @exception NullPointerException if &lt;code&gt;currencyCode&lt;/code&gt; is null</span>
<span class="line-modified"> 292      * @exception IllegalArgumentException if &lt;code&gt;currencyCode&lt;/code&gt; is not</span>
 293      * a supported ISO 4217 code.
 294      */
 295     public static Currency getInstance(String currencyCode) {
 296         return getInstance(currencyCode, Integer.MIN_VALUE, 0);
 297     }
 298 
 299     private static Currency getInstance(String currencyCode, int defaultFractionDigits,
 300         int numericCode) {
 301         // Try to look up the currency code in the instances table.
 302         // This does the null pointer check as a side effect.
 303         // Also, if there already is an entry, the currencyCode must be valid.
 304         Currency instance = instances.get(currencyCode);
 305         if (instance != null) {
 306             return instance;
 307         }
 308 
 309         if (defaultFractionDigits == Integer.MIN_VALUE) {
 310             // Currency code not internally generated, need to verify first
 311             // A currency code must have 3 characters and exist in the main table
 312             // or in the list of other currencies.
</pre>
<hr />
<pre>
 332                 }
 333             }
 334 
 335             if (!found) {
 336                 OtherCurrencyEntry ocEntry = OtherCurrencyEntry.findEntry(currencyCode);
 337                 if (ocEntry == null) {
 338                     throw new IllegalArgumentException();
 339                 }
 340                 defaultFractionDigits = ocEntry.fraction;
 341                 numericCode = ocEntry.numericCode;
 342             }
 343         }
 344 
 345         Currency currencyVal =
 346             new Currency(currencyCode, defaultFractionDigits, numericCode);
 347         instance = instances.putIfAbsent(currencyCode, currencyVal);
 348         return (instance != null ? instance : currencyVal);
 349     }
 350 
 351     /**
<span class="line-modified"> 352      * Returns the &lt;code&gt;Currency&lt;/code&gt; instance for the country of the</span>
 353      * given locale. The language and variant components of the locale
 354      * are ignored. The result may vary over time, as countries change their
 355      * currencies. For example, for the original member countries of the
 356      * European Monetary Union, the method returns the old national currencies
 357      * until December 31, 2001, and the Euro from January 1, 2002, local time
 358      * of the respective countries.
 359      * &lt;p&gt;
 360      * If the specified {@code locale} contains &quot;cu&quot; and/or &quot;rg&quot;
 361      * &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
 362      * the instance returned from this method reflects
 363      * the values specified with those extensions. If both &quot;cu&quot; and &quot;rg&quot; are
 364      * specified, the currency from the &quot;cu&quot; extension supersedes the implicit one
 365      * from the &quot;rg&quot; extension.
 366      * &lt;p&gt;
<span class="line-modified"> 367      * The method returns &lt;code&gt;null&lt;/code&gt; for territories that don&#39;t</span>
 368      * have a currency, such as Antarctica.
 369      *
<span class="line-modified"> 370      * @param locale the locale for whose country a &lt;code&gt;Currency&lt;/code&gt;</span>
 371      * instance is needed
<span class="line-modified"> 372      * @return the &lt;code&gt;Currency&lt;/code&gt; instance for the country of the given</span>
 373      * locale, or {@code null}
<span class="line-modified"> 374      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt;</span>
 375      * is {@code null}
<span class="line-modified"> 376      * @exception IllegalArgumentException if the country of the given {@code locale}</span>
 377      * is not a supported ISO 3166 country code.
 378      */
 379     public static Currency getInstance(Locale locale) {
 380         // check for locale overrides
 381         String override = locale.getUnicodeLocaleType(&quot;cu&quot;);
 382         if (override != null) {
 383             try {
 384                 return getInstance(override.toUpperCase(Locale.ROOT));
 385             } catch (IllegalArgumentException iae) {
 386                 // override currency is invalid. Fall through.
 387             }
 388         }
 389 
 390         String country = CalendarDataUtility.findRegionOverride(locale).getCountry();
 391 
 392         if (country == null || !country.matches(&quot;^[a-zA-Z]{2}$&quot;)) {
 393             throw new IllegalArgumentException();
 394         }
 395 
 396         char char1 = country.charAt(0);
</pre>
<hr />
<pre>
 519      *     {@link Locale.Category#DISPLAY DISPLAY} locale
 520      */
 521     public String getSymbol() {
 522         return getSymbol(Locale.getDefault(Locale.Category.DISPLAY));
 523     }
 524 
 525     /**
 526      * Gets the symbol of this currency for the specified locale.
 527      * For example, for the US Dollar, the symbol is &quot;$&quot; if the specified
 528      * locale is the US, while for other locales it may be &quot;US$&quot;. If no
 529      * symbol can be determined, the ISO 4217 currency code is returned.
 530      * &lt;p&gt;
 531      * If the specified {@code locale} contains &quot;rg&quot; (region override)
 532      * &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
 533      * the symbol returned from this method reflects
 534      * the value specified with that extension.
 535      *
 536      * @param locale the locale for which a display name for this currency is
 537      * needed
 538      * @return the symbol of this currency for the specified locale
<span class="line-modified"> 539      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
 540      */
 541     public String getSymbol(Locale locale) {
 542         LocaleServiceProviderPool pool =
 543             LocaleServiceProviderPool.getPool(CurrencyNameProvider.class);
 544         locale = CalendarDataUtility.findRegionOverride(locale);
 545         String symbol = pool.getLocalizedObject(
 546                                 CurrencyNameGetter.INSTANCE,
 547                                 locale, currencyCode, SYMBOL);
 548         if (symbol != null) {
 549             return symbol;
 550         }
 551 
 552         // use currency code as symbol of last resort
 553         return currencyCode;
 554     }
 555 
 556     /**
 557      * Gets the default number of fraction digits used with this currency.
 558      * Note that the number of fraction digits is the same as ISO 4217&#39;s
 559      * minor unit for the currency.
</pre>
<hr />
<pre>
 614      * This is equivalent to calling
 615      * {@link #getDisplayName(Locale)
 616      *     getDisplayName(Locale.getDefault(Locale.Category.DISPLAY))}.
 617      *
 618      * @return the display name of this currency for the default
 619      *     {@link Locale.Category#DISPLAY DISPLAY} locale
 620      * @since 1.7
 621      */
 622     public String getDisplayName() {
 623         return getDisplayName(Locale.getDefault(Locale.Category.DISPLAY));
 624     }
 625 
 626     /**
 627      * Gets the name that is suitable for displaying this currency for
 628      * the specified locale.  If there is no suitable display name found
 629      * for the specified locale, the ISO 4217 currency code is returned.
 630      *
 631      * @param locale the locale for which a display name for this currency is
 632      * needed
 633      * @return the display name of this currency for the specified locale
<span class="line-modified"> 634      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
 635      * @since 1.7
 636      */
 637     public String getDisplayName(Locale locale) {
 638         LocaleServiceProviderPool pool =
 639             LocaleServiceProviderPool.getPool(CurrencyNameProvider.class);
 640         String result = pool.getLocalizedObject(
 641                                 CurrencyNameGetter.INSTANCE,
 642                                 locale, currencyCode, DISPLAYNAME);
 643         if (result != null) {
 644             return result;
 645         }
 646 
 647         // use currency code as symbol of last resort
 648         return currencyCode;
 649     }
 650 
 651     /**
 652      * Returns the ISO 4217 currency code of this currency.
 653      *
 654      * @return the ISO 4217 currency code of this currency
 655      */
 656     @Override
 657     public String toString() {
 658         return currencyCode;
 659     }
 660 
 661     /**
 662      * Resolves instances being deserialized to a single instance per currency.
 663      */

 664     private Object readResolve() {
 665         return getInstance(currencyCode);
 666     }
 667 
 668     /**
 669      * Gets the main table entry for the country whose country code consists
 670      * of char1 and char2.
 671      */
 672     private static int getMainTableEntry(char char1, char char2) {
 673         if (char1 &lt; &#39;A&#39; || char1 &gt; &#39;Z&#39; || char2 &lt; &#39;A&#39; || char2 &gt; &#39;Z&#39;) {
 674             throw new IllegalArgumentException();
 675         }
 676         return mainTable[(char1 - &#39;A&#39;) * A_TO_Z + (char2 - &#39;A&#39;)];
 677     }
 678 
 679     /**
 680      * Sets the main table entry for the country whose country code consists
 681      * of char1 and char2.
 682      */
 683     private static void setMainTableEntry(char char1, char char2, int entry) {
</pre>
<hr />
<pre>
1178             long time = format.parse(s.trim()).getTime();
1179             return System.currentTimeMillis() &gt; time;
1180 
1181         }
1182 
1183         private static void info(String message, Throwable t) {
1184             PlatformLogger logger = PlatformLogger
1185                     .getLogger(&quot;java.util.Currency&quot;);
1186             if (logger.isLoggable(PlatformLogger.Level.INFO)) {
1187                 if (t != null) {
1188                     logger.info(message, t);
1189                 } else {
1190                     logger.info(message);
1191                 }
1192             }
1193         }
1194 
1195     }
1196 
1197 }
<span class="line-removed">1198 </span>
<span class="line-removed">1199 </span>
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  38 import java.text.SimpleDateFormat;
  39 import java.util.concurrent.ConcurrentHashMap;
  40 import java.util.concurrent.ConcurrentMap;
  41 import java.util.regex.Pattern;
  42 import java.util.regex.Matcher;
  43 import java.util.spi.CurrencyNameProvider;
  44 import java.util.stream.Collectors;
  45 
  46 import jdk.internal.util.StaticProperty;
  47 import sun.util.locale.provider.CalendarDataUtility;
  48 import sun.util.locale.provider.LocaleServiceProviderPool;
  49 import sun.util.logging.PlatformLogger;
  50 
  51 
  52 /**
  53  * Represents a currency. Currencies are identified by their ISO 4217 currency
  54  * codes. Visit the &lt;a href=&quot;http://www.iso.org/iso/home/standards/currency_codes.htm&quot;&gt;
  55  * ISO web site&lt;/a&gt; for more information.
  56  * &lt;p&gt;
  57  * The class is designed so that there&#39;s never more than one
<span class="line-modified">  58  * {@code Currency} instance for any given currency. Therefore, there&#39;s</span>
<span class="line-modified">  59  * no public constructor. You obtain a {@code Currency} instance using</span>
<span class="line-modified">  60  * the {@code getInstance} methods.</span>
  61  * &lt;p&gt;
  62  * Users can supersede the Java runtime currency data by means of the system
  63  * property {@systemProperty java.util.currency.data}. If this system property is
  64  * defined then its value is the location of a properties file, the contents of
  65  * which are key/value pairs of the ISO 3166 country codes and the ISO 4217
  66  * currency data respectively.  The value part consists of three ISO 4217 values
  67  * of a currency, i.e., an alphabetic code, a numeric code, and a minor unit.
  68  * Those three ISO 4217 values are separated by commas.
  69  * The lines which start with &#39;#&#39;s are considered comment lines. An optional UTC
  70  * timestamp may be specified per currency entry if users need to specify a
  71  * cutover date indicating when the new data comes into effect. The timestamp is
  72  * appended to the end of the currency properties and uses a comma as a separator.
  73  * If a UTC datestamp is present and valid, the JRE will only use the new currency
  74  * properties if the current UTC date is later than the date specified at class
  75  * loading time. The format of the timestamp must be of ISO 8601 format :
  76  * {@code &#39;yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;}. For example,
  77  * &lt;p&gt;
  78  * &lt;code&gt;
  79  * #Sample currency properties&lt;br&gt;
  80  * JP=JPZ,999,0
</pre>
<hr />
<pre>
  96  * &lt;p&gt;
  97  * Where syntactically malformed entries are encountered, the entry is ignored
  98  * and the remainder of entries in file are processed. For instances where duplicate
  99  * country code entries exist, the behavior of the Currency information for that
 100  * {@code Currency} is undefined and the remainder of entries in file are processed.
 101  * &lt;p&gt;
 102  * If multiple property entries with same currency code but different numeric code
 103  * and/or minor unit are encountered, those entries are ignored and the remainder
 104  * of entries in file are processed.
 105  *
 106  * &lt;p&gt;
 107  * It is recommended to use {@link java.math.BigDecimal} class while dealing
 108  * with {@code Currency} or monetary values as it provides better handling of floating
 109  * point numbers and their operations.
 110  *
 111  * @see java.math.BigDecimal
 112  * @since 1.4
 113  */
 114 public final class Currency implements Serializable {
 115 
<span class="line-added"> 116     @java.io.Serial</span>
 117     private static final long serialVersionUID = -158308464356906721L;
 118 
 119     /**
 120      * ISO 4217 currency code for this currency.
 121      *
 122      * @serial
 123      */
 124     private final String currencyCode;
 125 
 126     /**
 127      * Default fraction digits for this currency.
 128      * Set from currency data tables.
 129      */
 130     private final transient int defaultFractionDigits;
 131 
 132     /**
 133      * ISO 4217 numeric code for this currency.
 134      * Set from currency data tables.
 135      */
 136     private final transient int numericCode;
</pre>
<hr />
<pre>
 257                                 = getValidCurrencyData(props, propertiesPattern);
 258                         currencyEntries.forEach(Currency::replaceCurrencyData);
 259                     }
 260                 } catch (IOException e) {
 261                     CurrencyProperty.info(&quot;currency.properties is ignored&quot;
 262                             + &quot; because of an IOException&quot;, e);
 263                 }
 264                 return null;
 265             }
 266         });
 267     }
 268 
 269     /**
 270      * Constants for retrieving localized names from the name providers.
 271      */
 272     private static final int SYMBOL = 0;
 273     private static final int DISPLAYNAME = 1;
 274 
 275 
 276     /**
<span class="line-modified"> 277      * Constructs a {@code Currency} instance. The constructor is private</span>
 278      * so that we can insure that there&#39;s never more than one instance for a
 279      * given currency.
 280      */
 281     private Currency(String currencyCode, int defaultFractionDigits, int numericCode) {
 282         this.currencyCode = currencyCode;
 283         this.defaultFractionDigits = defaultFractionDigits;
 284         this.numericCode = numericCode;
 285     }
 286 
 287     /**
<span class="line-modified"> 288      * Returns the {@code Currency} instance for the given currency code.</span>
 289      *
 290      * @param currencyCode the ISO 4217 code of the currency
<span class="line-modified"> 291      * @return the {@code Currency} instance for the given currency code</span>
<span class="line-modified"> 292      * @throws    NullPointerException if {@code currencyCode} is null</span>
<span class="line-modified"> 293      * @throws    IllegalArgumentException if {@code currencyCode} is not</span>
 294      * a supported ISO 4217 code.
 295      */
 296     public static Currency getInstance(String currencyCode) {
 297         return getInstance(currencyCode, Integer.MIN_VALUE, 0);
 298     }
 299 
 300     private static Currency getInstance(String currencyCode, int defaultFractionDigits,
 301         int numericCode) {
 302         // Try to look up the currency code in the instances table.
 303         // This does the null pointer check as a side effect.
 304         // Also, if there already is an entry, the currencyCode must be valid.
 305         Currency instance = instances.get(currencyCode);
 306         if (instance != null) {
 307             return instance;
 308         }
 309 
 310         if (defaultFractionDigits == Integer.MIN_VALUE) {
 311             // Currency code not internally generated, need to verify first
 312             // A currency code must have 3 characters and exist in the main table
 313             // or in the list of other currencies.
</pre>
<hr />
<pre>
 333                 }
 334             }
 335 
 336             if (!found) {
 337                 OtherCurrencyEntry ocEntry = OtherCurrencyEntry.findEntry(currencyCode);
 338                 if (ocEntry == null) {
 339                     throw new IllegalArgumentException();
 340                 }
 341                 defaultFractionDigits = ocEntry.fraction;
 342                 numericCode = ocEntry.numericCode;
 343             }
 344         }
 345 
 346         Currency currencyVal =
 347             new Currency(currencyCode, defaultFractionDigits, numericCode);
 348         instance = instances.putIfAbsent(currencyCode, currencyVal);
 349         return (instance != null ? instance : currencyVal);
 350     }
 351 
 352     /**
<span class="line-modified"> 353      * Returns the {@code Currency} instance for the country of the</span>
 354      * given locale. The language and variant components of the locale
 355      * are ignored. The result may vary over time, as countries change their
 356      * currencies. For example, for the original member countries of the
 357      * European Monetary Union, the method returns the old national currencies
 358      * until December 31, 2001, and the Euro from January 1, 2002, local time
 359      * of the respective countries.
 360      * &lt;p&gt;
 361      * If the specified {@code locale} contains &quot;cu&quot; and/or &quot;rg&quot;
 362      * &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
 363      * the instance returned from this method reflects
 364      * the values specified with those extensions. If both &quot;cu&quot; and &quot;rg&quot; are
 365      * specified, the currency from the &quot;cu&quot; extension supersedes the implicit one
 366      * from the &quot;rg&quot; extension.
 367      * &lt;p&gt;
<span class="line-modified"> 368      * The method returns {@code null} for territories that don&#39;t</span>
 369      * have a currency, such as Antarctica.
 370      *
<span class="line-modified"> 371      * @param locale the locale for whose country a {@code Currency}</span>
 372      * instance is needed
<span class="line-modified"> 373      * @return the {@code Currency} instance for the country of the given</span>
 374      * locale, or {@code null}
<span class="line-modified"> 375      * @throws    NullPointerException if {@code locale}</span>
 376      * is {@code null}
<span class="line-modified"> 377      * @throws    IllegalArgumentException if the country of the given {@code locale}</span>
 378      * is not a supported ISO 3166 country code.
 379      */
 380     public static Currency getInstance(Locale locale) {
 381         // check for locale overrides
 382         String override = locale.getUnicodeLocaleType(&quot;cu&quot;);
 383         if (override != null) {
 384             try {
 385                 return getInstance(override.toUpperCase(Locale.ROOT));
 386             } catch (IllegalArgumentException iae) {
 387                 // override currency is invalid. Fall through.
 388             }
 389         }
 390 
 391         String country = CalendarDataUtility.findRegionOverride(locale).getCountry();
 392 
 393         if (country == null || !country.matches(&quot;^[a-zA-Z]{2}$&quot;)) {
 394             throw new IllegalArgumentException();
 395         }
 396 
 397         char char1 = country.charAt(0);
</pre>
<hr />
<pre>
 520      *     {@link Locale.Category#DISPLAY DISPLAY} locale
 521      */
 522     public String getSymbol() {
 523         return getSymbol(Locale.getDefault(Locale.Category.DISPLAY));
 524     }
 525 
 526     /**
 527      * Gets the symbol of this currency for the specified locale.
 528      * For example, for the US Dollar, the symbol is &quot;$&quot; if the specified
 529      * locale is the US, while for other locales it may be &quot;US$&quot;. If no
 530      * symbol can be determined, the ISO 4217 currency code is returned.
 531      * &lt;p&gt;
 532      * If the specified {@code locale} contains &quot;rg&quot; (region override)
 533      * &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
 534      * the symbol returned from this method reflects
 535      * the value specified with that extension.
 536      *
 537      * @param locale the locale for which a display name for this currency is
 538      * needed
 539      * @return the symbol of this currency for the specified locale
<span class="line-modified"> 540      * @throws    NullPointerException if {@code locale} is null</span>
 541      */
 542     public String getSymbol(Locale locale) {
 543         LocaleServiceProviderPool pool =
 544             LocaleServiceProviderPool.getPool(CurrencyNameProvider.class);
 545         locale = CalendarDataUtility.findRegionOverride(locale);
 546         String symbol = pool.getLocalizedObject(
 547                                 CurrencyNameGetter.INSTANCE,
 548                                 locale, currencyCode, SYMBOL);
 549         if (symbol != null) {
 550             return symbol;
 551         }
 552 
 553         // use currency code as symbol of last resort
 554         return currencyCode;
 555     }
 556 
 557     /**
 558      * Gets the default number of fraction digits used with this currency.
 559      * Note that the number of fraction digits is the same as ISO 4217&#39;s
 560      * minor unit for the currency.
</pre>
<hr />
<pre>
 615      * This is equivalent to calling
 616      * {@link #getDisplayName(Locale)
 617      *     getDisplayName(Locale.getDefault(Locale.Category.DISPLAY))}.
 618      *
 619      * @return the display name of this currency for the default
 620      *     {@link Locale.Category#DISPLAY DISPLAY} locale
 621      * @since 1.7
 622      */
 623     public String getDisplayName() {
 624         return getDisplayName(Locale.getDefault(Locale.Category.DISPLAY));
 625     }
 626 
 627     /**
 628      * Gets the name that is suitable for displaying this currency for
 629      * the specified locale.  If there is no suitable display name found
 630      * for the specified locale, the ISO 4217 currency code is returned.
 631      *
 632      * @param locale the locale for which a display name for this currency is
 633      * needed
 634      * @return the display name of this currency for the specified locale
<span class="line-modified"> 635      * @throws    NullPointerException if {@code locale} is null</span>
 636      * @since 1.7
 637      */
 638     public String getDisplayName(Locale locale) {
 639         LocaleServiceProviderPool pool =
 640             LocaleServiceProviderPool.getPool(CurrencyNameProvider.class);
 641         String result = pool.getLocalizedObject(
 642                                 CurrencyNameGetter.INSTANCE,
 643                                 locale, currencyCode, DISPLAYNAME);
 644         if (result != null) {
 645             return result;
 646         }
 647 
 648         // use currency code as symbol of last resort
 649         return currencyCode;
 650     }
 651 
 652     /**
 653      * Returns the ISO 4217 currency code of this currency.
 654      *
 655      * @return the ISO 4217 currency code of this currency
 656      */
 657     @Override
 658     public String toString() {
 659         return currencyCode;
 660     }
 661 
 662     /**
 663      * Resolves instances being deserialized to a single instance per currency.
 664      */
<span class="line-added"> 665     @java.io.Serial</span>
 666     private Object readResolve() {
 667         return getInstance(currencyCode);
 668     }
 669 
 670     /**
 671      * Gets the main table entry for the country whose country code consists
 672      * of char1 and char2.
 673      */
 674     private static int getMainTableEntry(char char1, char char2) {
 675         if (char1 &lt; &#39;A&#39; || char1 &gt; &#39;Z&#39; || char2 &lt; &#39;A&#39; || char2 &gt; &#39;Z&#39;) {
 676             throw new IllegalArgumentException();
 677         }
 678         return mainTable[(char1 - &#39;A&#39;) * A_TO_Z + (char2 - &#39;A&#39;)];
 679     }
 680 
 681     /**
 682      * Sets the main table entry for the country whose country code consists
 683      * of char1 and char2.
 684      */
 685     private static void setMainTableEntry(char char1, char char2, int entry) {
</pre>
<hr />
<pre>
1180             long time = format.parse(s.trim()).getTime();
1181             return System.currentTimeMillis() &gt; time;
1182 
1183         }
1184 
1185         private static void info(String message, Throwable t) {
1186             PlatformLogger logger = PlatformLogger
1187                     .getLogger(&quot;java.util.Currency&quot;);
1188             if (logger.isLoggable(PlatformLogger.Level.INFO)) {
1189                 if (t != null) {
1190                     logger.info(message, t);
1191                 } else {
1192                     logger.info(message);
1193                 }
1194             }
1195         }
1196 
1197     }
1198 
1199 }


</pre>
</td>
</tr>
</table>
<center><a href="ConcurrentModificationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Date.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
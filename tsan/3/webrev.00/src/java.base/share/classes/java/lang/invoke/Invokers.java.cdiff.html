<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/Invokers.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LambdaConversionException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/Invokers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 56,29 ***</span>
              INV_LIMIT          =  3;
  
      /** Compute and cache information common to all collecting adapters
       *  that implement members of the erasure-family of the given erased type.
       */
<span class="line-modified">!     /*non-public*/ Invokers(MethodType targetType) {</span>
          this.targetType = targetType;
      }
  
<span class="line-modified">!     /*non-public*/ MethodHandle exactInvoker() {</span>
          MethodHandle invoker = cachedInvoker(INV_EXACT);
          if (invoker != null)  return invoker;
          invoker = makeExactOrGeneralInvoker(true);
          return setCachedInvoker(INV_EXACT, invoker);
      }
  
<span class="line-modified">!     /*non-public*/ MethodHandle genericInvoker() {</span>
          MethodHandle invoker = cachedInvoker(INV_GENERIC);
          if (invoker != null)  return invoker;
          invoker = makeExactOrGeneralInvoker(false);
          return setCachedInvoker(INV_GENERIC, invoker);
      }
  
<span class="line-modified">!     /*non-public*/ MethodHandle basicInvoker() {</span>
          MethodHandle invoker = cachedInvoker(INV_BASIC);
          if (invoker != null)  return invoker;
          MethodType basicType = targetType.basicType();
          if (basicType != targetType) {
              // double cache; not used significantly
<span class="line-new-header">--- 56,33 ---</span>
              INV_LIMIT          =  3;
  
      /** Compute and cache information common to all collecting adapters
       *  that implement members of the erasure-family of the given erased type.
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     Invokers(MethodType targetType) {</span>
          this.targetType = targetType;
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodHandle exactInvoker() {</span>
          MethodHandle invoker = cachedInvoker(INV_EXACT);
          if (invoker != null)  return invoker;
          invoker = makeExactOrGeneralInvoker(true);
          return setCachedInvoker(INV_EXACT, invoker);
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodHandle genericInvoker() {</span>
          MethodHandle invoker = cachedInvoker(INV_GENERIC);
          if (invoker != null)  return invoker;
          invoker = makeExactOrGeneralInvoker(false);
          return setCachedInvoker(INV_GENERIC, invoker);
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodHandle basicInvoker() {</span>
          MethodHandle invoker = cachedInvoker(INV_BASIC);
          if (invoker != null)  return invoker;
          MethodType basicType = targetType.basicType();
          if (basicType != targetType) {
              // double cache; not used significantly
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,16 ***</span>
              invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_BASIC_INV, invoker);
          }
          return setCachedInvoker(INV_BASIC, invoker);
      }
  
<span class="line-modified">!     /*non-public*/ MethodHandle varHandleMethodInvoker(VarHandle.AccessMode ak) {</span>
          // TODO cache invoker
          return makeVarHandleMethodInvoker(ak, false);
      }
  
<span class="line-modified">!     /*non-public*/ MethodHandle varHandleMethodExactInvoker(VarHandle.AccessMode ak) {</span>
          // TODO cache invoker
          return makeVarHandleMethodInvoker(ak, true);
      }
  
      private MethodHandle cachedInvoker(int idx) {
<span class="line-new-header">--- 96,18 ---</span>
              invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_BASIC_INV, invoker);
          }
          return setCachedInvoker(INV_BASIC, invoker);
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodHandle varHandleMethodInvoker(VarHandle.AccessMode ak) {</span>
          // TODO cache invoker
          return makeVarHandleMethodInvoker(ak, false);
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodHandle varHandleMethodExactInvoker(VarHandle.AccessMode ak) {</span>
          // TODO cache invoker
          return makeVarHandleMethodInvoker(ak, true);
      }
  
      private MethodHandle cachedInvoker(int idx) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,11 ***</span>
              invoker.form.compileToBytecode();
          }
      }
  
      // This next one is called from LambdaForm.NamedFunction.&lt;init&gt;.
<span class="line-modified">!     /*non-public*/ static MemberName invokeBasicMethod(MethodType basicType) {</span>
          assert(basicType == basicType.basicType());
          try {
              //Lookup.findVirtual(MethodHandle.class, name, type);
              return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, &quot;invokeBasic&quot;, basicType);
          } catch (ReflectiveOperationException ex) {
<span class="line-new-header">--- 157,12 ---</span>
              invoker.form.compileToBytecode();
          }
      }
  
      // This next one is called from LambdaForm.NamedFunction.&lt;init&gt;.
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static MemberName invokeBasicMethod(MethodType basicType) {</span>
          assert(basicType == basicType.basicType());
          try {
              //Lookup.findVirtual(MethodHandle.class, name, type);
              return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, &quot;invokeBasic&quot;, basicType);
          } catch (ReflectiveOperationException ex) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,11 ***</span>
       * The invoker target type is the post-spread type {@code (TYPEOF(uarg*), TYPEOF(sarg*))=&gt;RT}.
       * All the {@code sarg}s must have a common type {@code C}.  (If there are none, {@code Object} is assumed.}
       * @param leadingArgCount the number of unchanged (non-spread) arguments
       * @return {@code invoker.invokeExact(mh, uarg*, C[]{sarg*}) := (RT)mh.invoke(uarg*, sarg*)}
       */
<span class="line-modified">!     /*non-public*/ MethodHandle spreadInvoker(int leadingArgCount) {</span>
          int spreadArgCount = targetType.parameterCount() - leadingArgCount;
          MethodType postSpreadType = targetType;
          Class&lt;?&gt; argArrayType = impliedRestargType(postSpreadType, leadingArgCount);
          if (postSpreadType.parameterSlotCount() &lt;= MethodType.MAX_MH_INVOKER_ARITY) {
              return genericInvoker().asSpreader(argArrayType, spreadArgCount);
<span class="line-new-header">--- 195,12 ---</span>
       * The invoker target type is the post-spread type {@code (TYPEOF(uarg*), TYPEOF(sarg*))=&gt;RT}.
       * All the {@code sarg}s must have a common type {@code C}.  (If there are none, {@code Object} is assumed.}
       * @param leadingArgCount the number of unchanged (non-spread) arguments
       * @return {@code invoker.invokeExact(mh, uarg*, C[]{sarg*}) := (RT)mh.invoke(uarg*, sarg*)}
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodHandle spreadInvoker(int leadingArgCount) {</span>
          int spreadArgCount = targetType.parameterCount() - leadingArgCount;
          MethodType postSpreadType = targetType;
          Class&lt;?&gt; argArrayType = impliedRestargType(postSpreadType, leadingArgCount);
          if (postSpreadType.parameterSlotCount() &lt;= MethodType.MAX_MH_INVOKER_ARITY) {
              return genericInvoker().asSpreader(argArrayType, spreadArgCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,13 ***</span>
          }
          lform.prepare();
          return lform;
      }
  
<span class="line-removed">-     /*non-public*/ static</span>
      @ForceInline
<span class="line-modified">!     MethodHandle checkVarHandleGenericType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>
          // Test for exact match on invoker types
          // TODO match with erased types and add cast of return value to lambda form
          MethodHandle mh = handle.getMethodHandle(ad.mode);
          if (mh.type() == ad.symbolicMethodTypeInvoker) {
              return mh;
<span class="line-new-header">--- 451,13 ---</span>
          }
          lform.prepare();
          return lform;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static MethodHandle checkVarHandleGenericType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>
          // Test for exact match on invoker types
          // TODO match with erased types and add cast of return value to lambda form
          MethodHandle mh = handle.getMethodHandle(ad.mode);
          if (mh.type() == ad.symbolicMethodTypeInvoker) {
              return mh;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,43 ***</span>
          else {
              return mh.asType(ad.symbolicMethodTypeInvoker);
          }
      }
  
<span class="line-removed">-     /*non-public*/ static</span>
      @ForceInline
<span class="line-modified">!     MethodHandle checkVarHandleExactType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>
          MethodHandle mh = handle.getMethodHandle(ad.mode);
          MethodType mt = mh.type();
          if (mt != ad.symbolicMethodTypeInvoker) {
              throw newWrongMethodTypeException(mt, ad.symbolicMethodTypeInvoker);
          }
          return mh;
      }
  
<span class="line-modified">!     /*non-public*/ static</span>
<span class="line-modified">!     WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {</span>
          // FIXME: merge with JVM logic for throwing WMTE
          return new WrongMethodTypeException(&quot;expected &quot;+expected+&quot; but found &quot;+actual);
      }
  
      /** Static definition of MethodHandle.invokeExact checking code. */
<span class="line-removed">-     /*non-public*/ static</span>
      @ForceInline
<span class="line-modified">!     void checkExactType(MethodHandle mh, MethodType expected) {</span>
          MethodType actual = mh.type();
          if (actual != expected)
              throw newWrongMethodTypeException(expected, actual);
      }
  
      /** Static definition of MethodHandle.invokeGeneric checking code.
       * Directly returns the type-adjusted MH to invoke, as follows:
       * {@code (R)MH.invoke(a*) =&gt; MH.asType(TYPEOF(a*:R)).invokeBasic(a*)}
       */
<span class="line-removed">-     /*non-public*/ static</span>
      @ForceInline
<span class="line-modified">!     MethodHandle checkGenericType(MethodHandle mh,  MethodType expected) {</span>
          return mh.asType(expected);
          /* Maybe add more paths here.  Possible optimizations:
           * for (R)MH.invoke(a*),
           * let MT0 = TYPEOF(a*:R), MT1 = MH.type
           *
<span class="line-new-header">--- 465,43 ---</span>
          else {
              return mh.asType(ad.symbolicMethodTypeInvoker);
          }
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static MethodHandle checkVarHandleExactType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>
          MethodHandle mh = handle.getMethodHandle(ad.mode);
          MethodType mt = mh.type();
          if (mt != ad.symbolicMethodTypeInvoker) {
              throw newWrongMethodTypeException(mt, ad.symbolicMethodTypeInvoker);
          }
          return mh;
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-modified">!     static WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {</span>
          // FIXME: merge with JVM logic for throwing WMTE
          return new WrongMethodTypeException(&quot;expected &quot;+expected+&quot; but found &quot;+actual);
      }
  
      /** Static definition of MethodHandle.invokeExact checking code. */
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static void checkExactType(MethodHandle mh, MethodType expected) {</span>
          MethodType actual = mh.type();
          if (actual != expected)
              throw newWrongMethodTypeException(expected, actual);
      }
  
      /** Static definition of MethodHandle.invokeGeneric checking code.
       * Directly returns the type-adjusted MH to invoke, as follows:
       * {@code (R)MH.invoke(a*) =&gt; MH.asType(TYPEOF(a*:R)).invokeBasic(a*)}
       */
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static MethodHandle checkGenericType(MethodHandle mh,  MethodType expected) {</span>
          return mh.asType(expected);
          /* Maybe add more paths here.  Possible optimizations:
           * for (R)MH.invoke(a*),
           * let MT0 = TYPEOF(a*:R), MT1 = MH.type
           *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 557,28 ***</span>
          lform = mtype.form().setCachedLambdaForm(which, lform);
          return lform;
      }
  
      /** Static definition of MethodHandle.invokeGeneric checking code. */
<span class="line-removed">-     /*non-public*/ static</span>
      @ForceInline
<span class="line-modified">!     MethodHandle getCallSiteTarget(CallSite site) {</span>
          return site.getTarget();
      }
  
<span class="line-removed">-     /*non-public*/ static</span>
      @ForceInline
<span class="line-modified">!     void checkCustomized(MethodHandle mh) {</span>
          if (MethodHandleImpl.isCompileConstant(mh)) return;
          if (mh.form.customized == null) {
              maybeCustomize(mh);
          }
      }
  
<span class="line-removed">-     /*non-public*/ static</span>
      @DontInline
<span class="line-modified">!     void maybeCustomize(MethodHandle mh) {</span>
          byte count = mh.customizationCount;
          if (count &gt;= CUSTOMIZE_THRESHOLD) {
              mh.customize();
          } else {
              mh.customizationCount = (byte)(count+1);
<span class="line-new-header">--- 565,28 ---</span>
          lform = mtype.form().setCachedLambdaForm(which, lform);
          return lform;
      }
  
      /** Static definition of MethodHandle.invokeGeneric checking code. */
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static MethodHandle getCallSiteTarget(CallSite site) {</span>
          return site.getTarget();
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static void checkCustomized(MethodHandle mh) {</span>
          if (MethodHandleImpl.isCompileConstant(mh)) return;
          if (mh.form.customized == null) {
              maybeCustomize(mh);
          }
      }
  
      @DontInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static void maybeCustomize(MethodHandle mh) {</span>
          byte count = mh.customizationCount;
          if (count &gt;= CUSTOMIZE_THRESHOLD) {
              mh.customize();
          } else {
              mh.customizationCount = (byte)(count+1);
</pre>
<center><a href="InvokerBytecodeGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LambdaConversionException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
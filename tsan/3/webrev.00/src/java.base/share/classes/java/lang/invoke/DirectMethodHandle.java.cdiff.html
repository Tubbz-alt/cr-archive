<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantCallSite.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="GenerateJLIClassesHelper.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 304,25 ***</span>
              lform.compileToBytecode();
      }
  
      /** Static wrapper for DirectMethodHandle.internalMemberName. */
      @ForceInline
<span class="line-modified">!     /*non-public*/ static Object internalMemberName(Object mh) {</span>
          return ((DirectMethodHandle)mh).member;
      }
  
      /** Static wrapper for DirectMethodHandle.internalMemberName.
       * This one also forces initialization.
       */
<span class="line-modified">!     /*non-public*/ static Object internalMemberNameEnsureInit(Object mh) {</span>
          DirectMethodHandle dmh = (DirectMethodHandle)mh;
          dmh.ensureInitialized();
          return dmh.member;
      }
  
<span class="line-modified">!     /*non-public*/ static</span>
<span class="line-modified">!     boolean shouldBeInitialized(MemberName member) {</span>
          switch (member.getReferenceKind()) {
          case REF_invokeStatic:
          case REF_getStatic:
          case REF_putStatic:
          case REF_newInvokeSpecial:
<span class="line-new-header">--- 304,27 ---</span>
              lform.compileToBytecode();
      }
  
      /** Static wrapper for DirectMethodHandle.internalMemberName. */
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object internalMemberName(Object mh) {</span>
          return ((DirectMethodHandle)mh).member;
      }
  
      /** Static wrapper for DirectMethodHandle.internalMemberName.
       * This one also forces initialization.
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object internalMemberNameEnsureInit(Object mh) {</span>
          DirectMethodHandle dmh = (DirectMethodHandle)mh;
          dmh.ensureInitialized();
          return dmh.member;
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-modified">!     static boolean shouldBeInitialized(MemberName member) {</span>
          switch (member.getReferenceKind()) {
          case REF_invokeStatic:
          case REF_getStatic:
          case REF_putStatic:
          case REF_newInvokeSpecial:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,11 ***</span>
          // put it into the final state
          EnsureInitialized.INSTANCE.remove(defc);
          return true;
      }
  
<span class="line-modified">!     /*non-public*/ static void ensureInitialized(Object mh) {</span>
          ((DirectMethodHandle)mh).ensureInitialized();
      }
  
      /** This subclass represents invokespecial instructions. */
      static class Special extends DirectMethodHandle {
<span class="line-new-header">--- 396,12 ---</span>
          // put it into the final state
          EnsureInitialized.INSTANCE.remove(defc);
          return true;
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static void ensureInitialized(Object mh) {</span>
          ((DirectMethodHandle)mh).ensureInitialized();
      }
  
      /** This subclass represents invokespecial instructions. */
      static class Special extends DirectMethodHandle {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,16 ***</span>
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
              return new Constructor(mt, lf, member, initMethod, instanceClass);
          }
      }
  
<span class="line-modified">!     /*non-public*/ static Object constructorMethod(Object mh) {</span>
          Constructor dmh = (Constructor)mh;
          return dmh.initMethod;
      }
  
<span class="line-modified">!     /*non-public*/ static Object allocateInstance(Object mh) throws InstantiationException {</span>
          Constructor dmh = (Constructor)mh;
          return UNSAFE.allocateInstance(dmh.instanceClass);
      }
  
      /** This subclass handles non-static field references. */
<span class="line-new-header">--- 473,18 ---</span>
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
              return new Constructor(mt, lf, member, initMethod, instanceClass);
          }
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object constructorMethod(Object mh) {</span>
          Constructor dmh = (Constructor)mh;
          return dmh.initMethod;
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object allocateInstance(Object mh) throws InstantiationException {</span>
          Constructor dmh = (Constructor)mh;
          return UNSAFE.allocateInstance(dmh.instanceClass);
      }
  
      /** This subclass handles non-static field references. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,18 ***</span>
              return new Accessor(mt, lf, member, fieldOffset);
          }
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/ static long fieldOffset(Object accessorObj) {</span>
          // Note: We return a long because that is what Unsafe.getObject likes.
          // We store a plain int because it is more compact.
          return ((Accessor)accessorObj).fieldOffset;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/ static Object checkBase(Object obj) {</span>
          // Note that the object&#39;s class has already been verified,
          // since the parameter type of the Accessor method handle
          // is either member.getDeclaringClass or a subclass.
          // This was verified in DirectMethodHandle.make.
          // Therefore, the only remaining check is for null.
<span class="line-new-header">--- 506,20 ---</span>
              return new Accessor(mt, lf, member, fieldOffset);
          }
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static long fieldOffset(Object accessorObj) {</span>
          // Note: We return a long because that is what Unsafe.getObject likes.
          // We store a plain int because it is more compact.
          return ((Accessor)accessorObj).fieldOffset;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object checkBase(Object obj) {</span>
          // Note that the object&#39;s class has already been verified,
          // since the parameter type of the Accessor method handle
          // is either member.getDeclaringClass or a subclass.
          // This was verified in DirectMethodHandle.make.
          // Therefore, the only remaining check is for null.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,26 ***</span>
              return new StaticAccessor(mt, lf, member, staticBase, staticOffset);
          }
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/ static Object nullCheck(Object obj) {</span>
          return Objects.requireNonNull(obj);
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/ static Object staticBase(Object accessorObj) {</span>
          return ((StaticAccessor)accessorObj).staticBase;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/ static long staticOffset(Object accessorObj) {</span>
          return ((StaticAccessor)accessorObj).staticOffset;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/ static Object checkCast(Object mh, Object obj) {</span>
          return ((DirectMethodHandle) mh).checkCast(obj);
      }
  
      Object checkCast(Object obj) {
          return member.getReturnType().cast(obj);
<span class="line-new-header">--- 550,30 ---</span>
              return new StaticAccessor(mt, lf, member, staticBase, staticOffset);
          }
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object nullCheck(Object obj) {</span>
          return Objects.requireNonNull(obj);
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object staticBase(Object accessorObj) {</span>
          return ((StaticAccessor)accessorObj).staticBase;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static long staticOffset(Object accessorObj) {</span>
          return ((StaticAccessor)accessorObj).staticOffset;
      }
  
      @ForceInline
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Object checkCast(Object mh, Object obj) {</span>
          return ((DirectMethodHandle) mh).checkCast(obj);
      }
  
      Object checkCast(Object obj) {
          return member.getReturnType().cast(obj);
</pre>
<center><a href="ConstantCallSite.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="GenerateJLIClassesHelper.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
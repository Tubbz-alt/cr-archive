<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/charset/Charset.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio.charset;
 27 
 28 import jdk.internal.misc.VM;
 29 import sun.nio.cs.ThreadLocalCoders;
 30 import sun.security.action.GetPropertyAction;
 31 
 32 import java.nio.ByteBuffer;
 33 import java.nio.CharBuffer;
 34 import java.nio.charset.spi.CharsetProvider;
 35 import java.security.AccessController;
 36 import java.security.PrivilegedAction;
 37 import java.util.Arrays;
 38 import java.util.Collections;
 39 import java.util.HashSet;
 40 import java.util.Iterator;
 41 import java.util.Locale;
 42 import java.util.Map;
 43 import java.util.NoSuchElementException;
 44 import java.util.Objects;
 45 import java.util.ServiceConfigurationError;
 46 import java.util.ServiceLoader;
 47 import java.util.Set;
 48 import java.util.SortedMap;
 49 import java.util.TreeMap;
 50 
 51 
 52 /**
 53  * A named mapping between sequences of sixteen-bit Unicode &lt;a
 54  * href=&quot;../../lang/Character.html#unicode&quot;&gt;code units&lt;/a&gt; and sequences of
 55  * bytes.  This class defines methods for creating decoders and encoders and
 56  * for retrieving the various names associated with a charset.  Instances of
 57  * this class are immutable.
 58  *
 59  * &lt;p&gt; This class also defines static methods for testing whether a particular
 60  * charset is supported, for locating charset instances by name, and for
 61  * constructing a map that contains every charset for which support is
 62  * available in the current Java virtual machine.  Support for new charsets can
 63  * be added via the service-provider interface defined in the {@link
 64  * java.nio.charset.spi.CharsetProvider} class.
 65  *
 66  * &lt;p&gt; All of the methods defined in this class are safe for use by multiple
 67  * concurrent threads.
 68  *
 69  *
<a name="2" id="anc2"></a><span class="line-modified"> 70  * &lt;h2&gt;&lt;a id=&quot;names&quot;&gt;Charset names&lt;/a&gt;&lt;/h2&gt;</span>

 71  *
 72  * &lt;p&gt; Charsets are named by strings composed of the following characters:
 73  *
 74  * &lt;ul&gt;
 75  *
 76  *   &lt;li&gt; The uppercase letters {@code &#39;A&#39;} through {@code &#39;Z&#39;}
 77  *        (&lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u005a&#39;&lt;/code&gt;),
 78  *
 79  *   &lt;li&gt; The lowercase letters {@code &#39;a&#39;} through {@code &#39;z&#39;}
 80  *        (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u007a&#39;&lt;/code&gt;),
 81  *
 82  *   &lt;li&gt; The digits {@code &#39;0&#39;} through {@code &#39;9&#39;}
 83  *        (&lt;code&gt;&#39;&amp;#92;u0030&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u0039&#39;&lt;/code&gt;),
 84  *
 85  *   &lt;li&gt; The dash character {@code &#39;-&#39;}
 86  *        (&lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;,&amp;nbsp;&lt;small&gt;HYPHEN-MINUS&lt;/small&gt;),
 87  *
 88  *   &lt;li&gt; The plus character {@code &#39;+&#39;}
 89  *        (&lt;code&gt;&#39;&amp;#92;u002b&#39;&lt;/code&gt;,&amp;nbsp;&lt;small&gt;PLUS SIGN&lt;/small&gt;),
 90  *
 91  *   &lt;li&gt; The period character {@code &#39;.&#39;}
 92  *        (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;,&amp;nbsp;&lt;small&gt;FULL STOP&lt;/small&gt;),
 93  *
 94  *   &lt;li&gt; The colon character {@code &#39;:&#39;}
 95  *        (&lt;code&gt;&#39;&amp;#92;u003a&#39;&lt;/code&gt;,&amp;nbsp;&lt;small&gt;COLON&lt;/small&gt;), and
 96  *
 97  *   &lt;li&gt; The underscore character {@code &#39;_&#39;}
 98  *        (&lt;code&gt;&#39;&amp;#92;u005f&#39;&lt;/code&gt;,&amp;nbsp;&lt;small&gt;LOW&amp;nbsp;LINE&lt;/small&gt;).
 99  *
100  * &lt;/ul&gt;
101  *
102  * A charset name must begin with either a letter or a digit.  The empty string
103  * is not a legal charset name.  Charset names are not case-sensitive; that is,
104  * case is always ignored when comparing charset names.  Charset names
105  * generally follow the conventions documented in &lt;a
106  * href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2278:&amp;nbsp;IANA Charset
107  * Registration Procedures&lt;/i&gt;&lt;/a&gt;.
108  *
109  * &lt;p&gt; Every charset has a &lt;i&gt;canonical name&lt;/i&gt; and may also have one or more
110  * &lt;i&gt;aliases&lt;/i&gt;.  The canonical name is returned by the {@link #name() name} method
111  * of this class.  Canonical names are, by convention, usually in upper case.
112  * The aliases of a charset are returned by the {@link #aliases() aliases}
113  * method.
114  *
115  * &lt;p&gt;&lt;a id=&quot;hn&quot;&gt;Some charsets have an &lt;i&gt;historical name&lt;/i&gt; that is defined for
116  * compatibility with previous versions of the Java platform.&lt;/a&gt;  A charset&#39;s
117  * historical name is either its canonical name or one of its aliases.  The
118  * historical name is returned by the {@code getEncoding()} methods of the
119  * {@link java.io.InputStreamReader#getEncoding InputStreamReader} and {@link
120  * java.io.OutputStreamWriter#getEncoding OutputStreamWriter} classes.
121  *
122  * &lt;p&gt;&lt;a id=&quot;iana&quot;&gt; &lt;/a&gt;If a charset listed in the &lt;a
123  * href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset
124  * Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then
125  * its canonical name must be the name listed in the registry. Many charsets
126  * are given more than one name in the registry, in which case the registry
127  * identifies one of the names as &lt;i&gt;MIME-preferred&lt;/i&gt;.  If a charset has more
128  * than one registry name then its canonical name must be the MIME-preferred
129  * name and the other names in the registry must be valid aliases.  If a
130  * supported charset is not listed in the IANA registry then its canonical name
131  * must begin with one of the strings {@code &quot;X-&quot;} or {@code &quot;x-&quot;}.
132  *
133  * &lt;p&gt; The IANA charset registry does change over time, and so the canonical
134  * name and the aliases of a particular charset may also change over time.  To
135  * ensure compatibility it is recommended that no alias ever be removed from a
136  * charset, and that if the canonical name of a charset is changed then its
137  * previous canonical name be made into an alias.
138  *
139  *
<a name="3" id="anc3"></a><span class="line-modified">140  * &lt;h2&gt;&lt;a id=&quot;standard&quot;&gt;Standard charsets&lt;/a&gt;&lt;/h2&gt;</span>
141  *
142  *
<a name="4" id="anc4"></a><span class="line-modified">143  * &lt;p&gt; Every implementation of the Java platform is required to support the</span>
<span class="line-modified">144  * following standard charsets.  Consult the release documentation for your</span>

145  * implementation to see if any other charsets are supported.  The behavior
146  * of such optional charsets may differ between implementations.
147  *
148  * &lt;blockquote&gt;&lt;table class=&quot;striped&quot; style=&quot;width:80%&quot;&gt;
149  * &lt;caption style=&quot;display:none&quot;&gt;Description of standard charsets&lt;/caption&gt;
150  * &lt;thead&gt;
151  * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Charset&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
152  * &lt;/thead&gt;
153  * &lt;tbody&gt;
154  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code US-ASCII}&lt;/th&gt;
155  *     &lt;td&gt;Seven-bit ASCII, a.k.a. {@code ISO646-US},
156  *         a.k.a. the Basic Latin block of the Unicode character set&lt;/td&gt;&lt;/tr&gt;
157  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;&lt;code&gt;ISO-8859-1&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/th&gt;
158  *     &lt;td&gt;ISO Latin Alphabet No. 1, a.k.a. {@code ISO-LATIN-1}&lt;/td&gt;&lt;/tr&gt;
159  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code UTF-8}&lt;/th&gt;
160  *     &lt;td&gt;Eight-bit UCS Transformation Format&lt;/td&gt;&lt;/tr&gt;
161  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code UTF-16BE}&lt;/th&gt;
162  *     &lt;td&gt;Sixteen-bit UCS Transformation Format,
163  *         big-endian byte&amp;nbsp;order&lt;/td&gt;&lt;/tr&gt;
164  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code UTF-16LE}&lt;/th&gt;
165  *     &lt;td&gt;Sixteen-bit UCS Transformation Format,
166  *         little-endian byte&amp;nbsp;order&lt;/td&gt;&lt;/tr&gt;
167  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code UTF-16}&lt;/th&gt;
168  *     &lt;td&gt;Sixteen-bit UCS Transformation Format,
169  *         byte&amp;nbsp;order identified by an optional byte-order mark&lt;/td&gt;&lt;/tr&gt;
170  * &lt;/tbody&gt;
171  * &lt;/table&gt;&lt;/blockquote&gt;
172  *
173  * &lt;p&gt; The {@code UTF-8} charset is specified by &lt;a
174  * href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279&lt;/i&gt;&lt;/a&gt;; the
175  * transformation format upon which it is based is specified in
176  * Amendment&amp;nbsp;2 of ISO&amp;nbsp;10646-1 and is also described in the &lt;a
177  * href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;Unicode
178  * Standard&lt;/i&gt;&lt;/a&gt;.
179  *
180  * &lt;p&gt; The {@code UTF-16} charsets are specified by &lt;a
181  * href=&quot;http://www.ietf.org/rfc/rfc2781.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2781&lt;/i&gt;&lt;/a&gt;; the
182  * transformation formats upon which they are based are specified in
183  * Amendment&amp;nbsp;1 of ISO&amp;nbsp;10646-1 and are also described in the &lt;a
184  * href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;Unicode
185  * Standard&lt;/i&gt;&lt;/a&gt;.
186  *
187  * &lt;p&gt; The {@code UTF-16} charsets use sixteen-bit quantities and are
188  * therefore sensitive to byte order.  In these encodings the byte order of a
189  * stream may be indicated by an initial &lt;i&gt;byte-order mark&lt;/i&gt; represented by
190  * the Unicode character &lt;code&gt;&#39;&amp;#92;uFEFF&#39;&lt;/code&gt;.  Byte-order marks are handled
191  * as follows:
192  *
193  * &lt;ul&gt;
194  *
195  *   &lt;li&gt;&lt;p&gt; When decoding, the {@code UTF-16BE} and {@code UTF-16LE}
196  *   charsets interpret the initial byte-order marks as a &lt;small&gt;ZERO-WIDTH
197  *   NON-BREAKING SPACE&lt;/small&gt;; when encoding, they do not write
198  *   byte-order marks. &lt;/p&gt;&lt;/li&gt;
199 
200  *
201  *   &lt;li&gt;&lt;p&gt; When decoding, the {@code UTF-16} charset interprets the
202  *   byte-order mark at the beginning of the input stream to indicate the
203  *   byte-order of the stream but defaults to big-endian if there is no
204  *   byte-order mark; when encoding, it uses big-endian byte order and writes
205  *   a big-endian byte-order mark. &lt;/p&gt;&lt;/li&gt;
206  *
207  * &lt;/ul&gt;
208  *
209  * In any case, byte order marks occurring after the first element of an
210  * input sequence are not omitted since the same code is used to represent
211  * &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;.
212  *
213  * &lt;p&gt; Every instance of the Java virtual machine has a default charset, which
214  * may or may not be one of the standard charsets.  The default charset is
215  * determined during virtual-machine startup and typically depends upon the
216  * locale and charset being used by the underlying operating system. &lt;/p&gt;
217  *
<a name="5" id="anc5"></a><span class="line-modified">218  * &lt;p&gt; The {@link StandardCharsets} class defines constants for each of the</span>
219  * standard charsets.
220  *
221  * &lt;h2&gt;Terminology&lt;/h2&gt;
222  *
223  * &lt;p&gt; The name of this class is taken from the terms used in
224  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2278&lt;/i&gt;&lt;/a&gt;.
225  * In that document a &lt;i&gt;charset&lt;/i&gt; is defined as the combination of
226  * one or more coded character sets and a character-encoding scheme.
227  * (This definition is confusing; some other software systems define
228  * &lt;i&gt;charset&lt;/i&gt; as a synonym for &lt;i&gt;coded character set&lt;/i&gt;.)
229  *
230  * &lt;p&gt; A &lt;i&gt;coded character set&lt;/i&gt; is a mapping between a set of abstract
231  * characters and a set of integers.  US-ASCII, ISO&amp;nbsp;8859-1,
232  * JIS&amp;nbsp;X&amp;nbsp;0201, and Unicode are examples of coded character sets.
233  *
234  * &lt;p&gt; Some standards have defined a &lt;i&gt;character set&lt;/i&gt; to be simply a
235  * set of abstract characters without an associated assigned numbering.
236  * An alphabet is an example of such a character set.  However, the subtle
237  * distinction between &lt;i&gt;character set&lt;/i&gt; and &lt;i&gt;coded character set&lt;/i&gt;
238  * is rarely used in practice; the former has become a short form for the
239  * latter, including in the Java API specification.
240  *
241  * &lt;p&gt; A &lt;i&gt;character-encoding scheme&lt;/i&gt; is a mapping between one or more
242  * coded character sets and a set of octet (eight-bit byte) sequences.
243  * UTF-8, UTF-16, ISO&amp;nbsp;2022, and EUC are examples of
244  * character-encoding schemes.  Encoding schemes are often associated with
245  * a particular coded character set; UTF-8, for example, is used only to
246  * encode Unicode.  Some schemes, however, are associated with multiple
247  * coded character sets; EUC, for example, can be used to encode
248  * characters in a variety of Asian coded character sets.
249  *
250  * &lt;p&gt; When a coded character set is used exclusively with a single
251  * character-encoding scheme then the corresponding charset is usually
252  * named for the coded character set; otherwise a charset is usually named
253  * for the encoding scheme and, possibly, the locale of the coded
254  * character sets that it supports.  Hence {@code US-ASCII} is both the
255  * name of a coded character set and of the charset that encodes it, while
256  * {@code EUC-JP} is the name of the charset that encodes the
257  * JIS&amp;nbsp;X&amp;nbsp;0201, JIS&amp;nbsp;X&amp;nbsp;0208, and JIS&amp;nbsp;X&amp;nbsp;0212
258  * coded character sets for the Japanese language.
259  *
260  * &lt;p&gt; The native character encoding of the Java programming language is
261  * UTF-16.  A charset in the Java platform therefore defines a mapping
262  * between sequences of sixteen-bit UTF-16 code units (that is, sequences
263  * of chars) and sequences of bytes. &lt;/p&gt;
264  *
265  *
266  * @author Mark Reinhold
267  * @author JSR-51 Expert Group
268  * @since 1.4
269  *
270  * @see CharsetDecoder
271  * @see CharsetEncoder
272  * @see java.nio.charset.spi.CharsetProvider
273  * @see java.lang.Character
274  */
275 
276 public abstract class Charset
277     implements Comparable&lt;Charset&gt;
278 {
279 
280     /* -- Static methods -- */
281 
282     /**
283      * Checks that the given string is a legal charset name. &lt;/p&gt;
284      *
285      * @param  s
286      *         A purported charset name
287      *
288      * @throws  IllegalCharsetNameException
289      *          If the given name is not a legal charset name
290      */
291     private static void checkName(String s) {
292         int n = s.length();
293         if (n == 0) {
294             throw new IllegalCharsetNameException(s);
295         }
296         for (int i = 0; i &lt; n; i++) {
297             char c = s.charAt(i);
298             if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) continue;
299             if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) continue;
300             if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) continue;
301             if (c == &#39;-&#39; &amp;&amp; i != 0) continue;
302             if (c == &#39;+&#39; &amp;&amp; i != 0) continue;
303             if (c == &#39;:&#39; &amp;&amp; i != 0) continue;
304             if (c == &#39;_&#39; &amp;&amp; i != 0) continue;
305             if (c == &#39;.&#39; &amp;&amp; i != 0) continue;
306             throw new IllegalCharsetNameException(s);
307         }
308     }
309 
310     /* The standard set of charsets */
311     private static final CharsetProvider standardProvider
312         = new sun.nio.cs.StandardCharsets();
313 
314     private static final String[] zeroAliases = new String[0];
315 
316     // Cache of the most-recently-returned charsets,
317     // along with the names that were used to find them
318     //
319     private static volatile Object[] cache1; // &quot;Level 1&quot; cache
320     private static volatile Object[] cache2; // &quot;Level 2&quot; cache
321 
322     private static void cache(String charsetName, Charset cs) {
323         cache2 = cache1;
324         cache1 = new Object[] { charsetName, cs };
325     }
326 
327     // Creates an iterator that walks over the available providers, ignoring
328     // those whose lookup or instantiation causes a security exception to be
329     // thrown.  Should be invoked with full privileges.
330     //
331     private static Iterator&lt;CharsetProvider&gt; providers() {
332         return new Iterator&lt;&gt;() {
333                 ClassLoader cl = ClassLoader.getSystemClassLoader();
334                 ServiceLoader&lt;CharsetProvider&gt; sl =
335                     ServiceLoader.load(CharsetProvider.class, cl);
336                 Iterator&lt;CharsetProvider&gt; i = sl.iterator();
337                 CharsetProvider next = null;
338 
339                 private boolean getNext() {
340                     while (next == null) {
341                         try {
342                             if (!i.hasNext())
343                                 return false;
344                             next = i.next();
345                         } catch (ServiceConfigurationError sce) {
346                             if (sce.getCause() instanceof SecurityException) {
347                                 // Ignore security exceptions
348                                 continue;
349                             }
350                             throw sce;
351                         }
352                     }
353                     return true;
354                 }
355 
356                 public boolean hasNext() {
357                     return getNext();
358                 }
359 
360                 public CharsetProvider next() {
361                     if (!getNext())
362                         throw new NoSuchElementException();
363                     CharsetProvider n = next;
364                     next = null;
365                     return n;
366                 }
367 
368                 public void remove() {
369                     throw new UnsupportedOperationException();
370                 }
371 
372             };
373     }
374 
375     // Thread-local gate to prevent recursive provider lookups
376     private static ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt; gate =
377             new ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt;();
378 
379     private static Charset lookupViaProviders(final String charsetName) {
380 
381         // The runtime startup sequence looks up standard charsets as a
382         // consequence of the VM&#39;s invocation of System.initializeSystemClass
383         // in order to, e.g., set system properties and encode filenames.  At
384         // that point the application class loader has not been initialized,
385         // however, so we can&#39;t look for providers because doing so will cause
386         // that loader to be prematurely initialized with incomplete
387         // information.
388         //
389         if (!VM.isBooted())
390             return null;
391 
392         if (gate.get() != null)
393             // Avoid recursive provider lookups
394             return null;
395         try {
396             gate.set(gate);
397 
398             return AccessController.doPrivileged(
399                 new PrivilegedAction&lt;&gt;() {
400                     public Charset run() {
401                         for (Iterator&lt;CharsetProvider&gt; i = providers();
402                              i.hasNext();) {
403                             CharsetProvider cp = i.next();
404                             Charset cs = cp.charsetForName(charsetName);
405                             if (cs != null)
406                                 return cs;
407                         }
408                         return null;
409                     }
410                 });
411 
412         } finally {
413             gate.set(null);
414         }
415     }
416 
417     /* The extended set of charsets */
418     private static class ExtendedProviderHolder {
419         static final CharsetProvider[] extendedProviders = extendedProviders();
420         // returns ExtendedProvider, if installed
421         private static CharsetProvider[] extendedProviders() {
422             return AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
423                     public CharsetProvider[] run() {
424                         CharsetProvider[] cps = new CharsetProvider[1];
425                         int n = 0;
426                         ServiceLoader&lt;CharsetProvider&gt; sl =
427                             ServiceLoader.loadInstalled(CharsetProvider.class);
428                         for (CharsetProvider cp : sl) {
429                             if (n + 1 &gt; cps.length) {
430                                 cps = Arrays.copyOf(cps, cps.length &lt;&lt; 1);
431                             }
432                             cps[n++] = cp;
433                         }
434                         return n == cps.length ? cps : Arrays.copyOf(cps, n);
435                     }});
436         }
437     }
438 
439     private static Charset lookupExtendedCharset(String charsetName) {
440         if (!VM.isBooted())  // see lookupViaProviders()
441             return null;
442         CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;
443         for (CharsetProvider cp : ecps) {
444             Charset cs = cp.charsetForName(charsetName);
445             if (cs != null)
446                 return cs;
447         }
448         return null;
449     }
450 
451     private static Charset lookup(String charsetName) {
452         if (charsetName == null)
453             throw new IllegalArgumentException(&quot;Null charset name&quot;);
454         Object[] a;
455         if ((a = cache1) != null &amp;&amp; charsetName.equals(a[0]))
456             return (Charset)a[1];
457         // We expect most programs to use one Charset repeatedly.
458         // We convey a hint to this effect to the VM by putting the
459         // level 1 cache miss code in a separate method.
460         return lookup2(charsetName);
461     }
462 
463     private static Charset lookup2(String charsetName) {
464         Object[] a;
465         if ((a = cache2) != null &amp;&amp; charsetName.equals(a[0])) {
466             cache2 = cache1;
467             cache1 = a;
468             return (Charset)a[1];
469         }
470         Charset cs;
471         if ((cs = standardProvider.charsetForName(charsetName)) != null ||
472             (cs = lookupExtendedCharset(charsetName))           != null ||
473             (cs = lookupViaProviders(charsetName))              != null)
474         {
475             cache(charsetName, cs);
476             return cs;
477         }
478 
479         /* Only need to check the name if we didn&#39;t find a charset for it */
480         checkName(charsetName);
481         return null;
482     }
483 
484     /**
485      * Tells whether the named charset is supported.
486      *
487      * @param  charsetName
488      *         The name of the requested charset; may be either
489      *         a canonical name or an alias
490      *
491      * @return  {@code true} if, and only if, support for the named charset
492      *          is available in the current Java virtual machine
493      *
494      * @throws IllegalCharsetNameException
495      *         If the given charset name is illegal
496      *
497      * @throws  IllegalArgumentException
498      *          If the given {@code charsetName} is null
499      */
500     public static boolean isSupported(String charsetName) {
501         return (lookup(charsetName) != null);
502     }
503 
504     /**
505      * Returns a charset object for the named charset.
506      *
507      * @param  charsetName
508      *         The name of the requested charset; may be either
509      *         a canonical name or an alias
510      *
511      * @return  A charset object for the named charset
512      *
513      * @throws  IllegalCharsetNameException
514      *          If the given charset name is illegal
515      *
516      * @throws  IllegalArgumentException
517      *          If the given {@code charsetName} is null
518      *
519      * @throws  UnsupportedCharsetException
520      *          If no support for the named charset is available
521      *          in this instance of the Java virtual machine
522      */
523     public static Charset forName(String charsetName) {
524         Charset cs = lookup(charsetName);
525         if (cs != null)
526             return cs;
527         throw new UnsupportedCharsetException(charsetName);
528     }
529 
530     // Fold charsets from the given iterator into the given map, ignoring
531     // charsets whose names already have entries in the map.
532     //
533     private static void put(Iterator&lt;Charset&gt; i, Map&lt;String,Charset&gt; m) {
534         while (i.hasNext()) {
535             Charset cs = i.next();
536             if (!m.containsKey(cs.name()))
537                 m.put(cs.name(), cs);
538         }
539     }
540 
541     /**
542      * Constructs a sorted map from canonical charset names to charset objects.
543      *
544      * &lt;p&gt; The map returned by this method will have one entry for each charset
545      * for which support is available in the current Java virtual machine.  If
546      * two or more supported charsets have the same canonical name then the
547      * resulting map will contain just one of them; which one it will contain
548      * is not specified. &lt;/p&gt;
549      *
550      * &lt;p&gt; The invocation of this method, and the subsequent use of the
551      * resulting map, may cause time-consuming disk or network I/O operations
552      * to occur.  This method is provided for applications that need to
553      * enumerate all of the available charsets, for example to allow user
554      * charset selection.  This method is not used by the {@link #forName
555      * forName} method, which instead employs an efficient incremental lookup
556      * algorithm.
557      *
558      * &lt;p&gt; This method may return different results at different times if new
559      * charset providers are dynamically made available to the current Java
560      * virtual machine.  In the absence of such changes, the charsets returned
561      * by this method are exactly those that can be retrieved via the {@link
562      * #forName forName} method.  &lt;/p&gt;
563      *
564      * @return An immutable, case-insensitive map from canonical charset names
565      *         to charset objects
566      */
567     public static SortedMap&lt;String,Charset&gt; availableCharsets() {
568         return AccessController.doPrivileged(
569             new PrivilegedAction&lt;&gt;() {
570                 public SortedMap&lt;String,Charset&gt; run() {
571                     TreeMap&lt;String,Charset&gt; m =
572                         new TreeMap&lt;&gt;(
573                             String.CASE_INSENSITIVE_ORDER);
574                     put(standardProvider.charsets(), m);
575                     CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;
576                     for (CharsetProvider ecp :ecps) {
577                         put(ecp.charsets(), m);
578                     }
579                     for (Iterator&lt;CharsetProvider&gt; i = providers(); i.hasNext();) {
580                         CharsetProvider cp = i.next();
581                         put(cp.charsets(), m);
582                     }
583                     return Collections.unmodifiableSortedMap(m);
584                 }
585             });
586     }
587 
588     private static volatile Charset defaultCharset;
589 
590     /**
591      * Returns the default charset of this Java virtual machine.
592      *
593      * &lt;p&gt; The default charset is determined during virtual-machine startup and
594      * typically depends upon the locale and charset of the underlying
595      * operating system.
596      *
597      * @return  A charset object for the default charset
598      *
599      * @since 1.5
600      */
601     public static Charset defaultCharset() {
602         if (defaultCharset == null) {
603             synchronized (Charset.class) {
604                 String csn = GetPropertyAction
605                         .privilegedGetProperty(&quot;file.encoding&quot;);
606                 Charset cs = lookup(csn);
607                 if (cs != null)
608                     defaultCharset = cs;
609                 else
610                     defaultCharset = sun.nio.cs.UTF_8.INSTANCE;
611             }
612         }
613         return defaultCharset;
614     }
615 
616 
617     /* -- Instance fields and methods -- */
618 
619     private final String name;          // tickles a bug in oldjavac
620     private final String[] aliases;     // tickles a bug in oldjavac
621     private Set&lt;String&gt; aliasSet = null;
622 
623     /**
624      * Initializes a new charset with the given canonical name and alias
625      * set.
626      *
627      * @param  canonicalName
628      *         The canonical name of this charset
629      *
630      * @param  aliases
631      *         An array of this charset&#39;s aliases, or null if it has no aliases
632      *
633      * @throws IllegalCharsetNameException
634      *         If the canonical name or any of the aliases are illegal
635      */
636     protected Charset(String canonicalName, String[] aliases) {
637         String[] as = Objects.requireNonNullElse(aliases, zeroAliases);
638 
639         // Skip checks for the standard, built-in Charsets we always load
640         // during initialization.
641         if (canonicalName != &quot;ISO-8859-1&quot;
642                 &amp;&amp; canonicalName != &quot;US-ASCII&quot;
643                 &amp;&amp; canonicalName != &quot;UTF-8&quot;) {
644             checkName(canonicalName);
645             for (int i = 0; i &lt; as.length; i++) {
646                 checkName(as[i]);
647             }
648         }
649         this.name = canonicalName;
650         this.aliases = as;
651     }
652 
653     /**
654      * Returns this charset&#39;s canonical name.
655      *
656      * @return  The canonical name of this charset
657      */
658     public final String name() {
659         return name;
660     }
661 
662     /**
663      * Returns a set containing this charset&#39;s aliases.
664      *
665      * @return  An immutable set of this charset&#39;s aliases
666      */
667     public final Set&lt;String&gt; aliases() {
668         if (aliasSet != null)
669             return aliasSet;
670         int n = aliases.length;
671         HashSet&lt;String&gt; hs = new HashSet&lt;&gt;(n);
672         for (int i = 0; i &lt; n; i++)
673             hs.add(aliases[i]);
674         aliasSet = Collections.unmodifiableSet(hs);
675         return aliasSet;
676     }
677 
678     /**
679      * Returns this charset&#39;s human-readable name for the default locale.
680      *
681      * &lt;p&gt; The default implementation of this method simply returns this
682      * charset&#39;s canonical name.  Concrete subclasses of this class may
683      * override this method in order to provide a localized display name. &lt;/p&gt;
684      *
685      * @return  The display name of this charset in the default locale
686      */
687     public String displayName() {
688         return name;
689     }
690 
691     /**
692      * Tells whether or not this charset is registered in the &lt;a
693      * href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA Charset
694      * Registry&lt;/a&gt;.
695      *
696      * @return  {@code true} if, and only if, this charset is known by its
697      *          implementor to be registered with the IANA
698      */
699     public final boolean isRegistered() {
700         return !name.startsWith(&quot;X-&quot;) &amp;&amp; !name.startsWith(&quot;x-&quot;);
701     }
702 
703     /**
704      * Returns this charset&#39;s human-readable name for the given locale.
705      *
706      * &lt;p&gt; The default implementation of this method simply returns this
707      * charset&#39;s canonical name.  Concrete subclasses of this class may
708      * override this method in order to provide a localized display name. &lt;/p&gt;
709      *
710      * @param  locale
711      *         The locale for which the display name is to be retrieved
712      *
713      * @return  The display name of this charset in the given locale
714      */
715     public String displayName(Locale locale) {
716         return name;
717     }
718 
719     /**
720      * Tells whether or not this charset contains the given charset.
721      *
722      * &lt;p&gt; A charset &lt;i&gt;C&lt;/i&gt; is said to &lt;i&gt;contain&lt;/i&gt; a charset &lt;i&gt;D&lt;/i&gt; if,
723      * and only if, every character representable in &lt;i&gt;D&lt;/i&gt; is also
724      * representable in &lt;i&gt;C&lt;/i&gt;.  If this relationship holds then it is
725      * guaranteed that every string that can be encoded in &lt;i&gt;D&lt;/i&gt; can also be
726      * encoded in &lt;i&gt;C&lt;/i&gt; without performing any replacements.
727      *
728      * &lt;p&gt; That &lt;i&gt;C&lt;/i&gt; contains &lt;i&gt;D&lt;/i&gt; does not imply that each character
729      * representable in &lt;i&gt;C&lt;/i&gt; by a particular byte sequence is represented
730      * in &lt;i&gt;D&lt;/i&gt; by the same byte sequence, although sometimes this is the
731      * case.
732      *
733      * &lt;p&gt; Every charset contains itself.
734      *
735      * &lt;p&gt; This method computes an approximation of the containment relation:
736      * If it returns {@code true} then the given charset is known to be
737      * contained by this charset; if it returns {@code false}, however, then
738      * it is not necessarily the case that the given charset is not contained
739      * in this charset.
740      *
741      * @param   cs
742      *          The given charset
743      *
744      * @return  {@code true} if the given charset is contained in this charset
745      */
746     public abstract boolean contains(Charset cs);
747 
748     /**
749      * Constructs a new decoder for this charset.
750      *
751      * @return  A new decoder for this charset
752      */
753     public abstract CharsetDecoder newDecoder();
754 
755     /**
756      * Constructs a new encoder for this charset.
757      *
758      * @return  A new encoder for this charset
759      *
760      * @throws  UnsupportedOperationException
761      *          If this charset does not support encoding
762      */
763     public abstract CharsetEncoder newEncoder();
764 
765     /**
766      * Tells whether or not this charset supports encoding.
767      *
768      * &lt;p&gt; Nearly all charsets support encoding.  The primary exceptions are
769      * special-purpose &lt;i&gt;auto-detect&lt;/i&gt; charsets whose decoders can determine
770      * which of several possible encoding schemes is in use by examining the
771      * input byte sequence.  Such charsets do not support encoding because
772      * there is no way to determine which encoding should be used on output.
773      * Implementations of such charsets should override this method to return
774      * {@code false}. &lt;/p&gt;
775      *
776      * @return  {@code true} if, and only if, this charset supports encoding
777      */
778     public boolean canEncode() {
779         return true;
780     }
781 
782     /**
783      * Convenience method that decodes bytes in this charset into Unicode
784      * characters.
785      *
786      * &lt;p&gt; An invocation of this method upon a charset {@code cs} returns the
787      * same result as the expression
788      *
789      * &lt;pre&gt;
790      *     cs.newDecoder()
791      *       .onMalformedInput(CodingErrorAction.REPLACE)
792      *       .onUnmappableCharacter(CodingErrorAction.REPLACE)
793      *       .decode(bb); &lt;/pre&gt;
794      *
795      * except that it is potentially more efficient because it can cache
796      * decoders between successive invocations.
797      *
798      * &lt;p&gt; This method always replaces malformed-input and unmappable-character
799      * sequences with this charset&#39;s default replacement byte array.  In order
800      * to detect such sequences, use the {@link
801      * CharsetDecoder#decode(java.nio.ByteBuffer)} method directly.  &lt;/p&gt;
802      *
803      * @param  bb  The byte buffer to be decoded
804      *
805      * @return  A char buffer containing the decoded characters
806      */
807     public final CharBuffer decode(ByteBuffer bb) {
808         try {
809             return ThreadLocalCoders.decoderFor(this)
810                 .onMalformedInput(CodingErrorAction.REPLACE)
811                 .onUnmappableCharacter(CodingErrorAction.REPLACE)
812                 .decode(bb);
813         } catch (CharacterCodingException x) {
814             throw new Error(x);         // Can&#39;t happen
815         }
816     }
817 
818     /**
819      * Convenience method that encodes Unicode characters into bytes in this
820      * charset.
821      *
822      * &lt;p&gt; An invocation of this method upon a charset {@code cs} returns the
823      * same result as the expression
824      *
825      * &lt;pre&gt;
826      *     cs.newEncoder()
827      *       .onMalformedInput(CodingErrorAction.REPLACE)
828      *       .onUnmappableCharacter(CodingErrorAction.REPLACE)
829      *       .encode(bb); &lt;/pre&gt;
830      *
831      * except that it is potentially more efficient because it can cache
832      * encoders between successive invocations.
833      *
834      * &lt;p&gt; This method always replaces malformed-input and unmappable-character
835      * sequences with this charset&#39;s default replacement string.  In order to
836      * detect such sequences, use the {@link
837      * CharsetEncoder#encode(java.nio.CharBuffer)} method directly.  &lt;/p&gt;
838      *
839      * @param  cb  The char buffer to be encoded
840      *
841      * @return  A byte buffer containing the encoded characters
842      */
843     public final ByteBuffer encode(CharBuffer cb) {
844         try {
845             return ThreadLocalCoders.encoderFor(this)
846                 .onMalformedInput(CodingErrorAction.REPLACE)
847                 .onUnmappableCharacter(CodingErrorAction.REPLACE)
848                 .encode(cb);
849         } catch (CharacterCodingException x) {
850             throw new Error(x);         // Can&#39;t happen
851         }
852     }
853 
854     /**
855      * Convenience method that encodes a string into bytes in this charset.
856      *
857      * &lt;p&gt; An invocation of this method upon a charset {@code cs} returns the
858      * same result as the expression
859      *
860      * &lt;pre&gt;
861      *     cs.encode(CharBuffer.wrap(s)); &lt;/pre&gt;
862      *
863      * @param  str  The string to be encoded
864      *
865      * @return  A byte buffer containing the encoded characters
866      */
867     public final ByteBuffer encode(String str) {
868         return encode(CharBuffer.wrap(str));
869     }
870 
871     /**
872      * Compares this charset to another.
873      *
874      * &lt;p&gt; Charsets are ordered by their canonical names, without regard to
875      * case. &lt;/p&gt;
876      *
877      * @param  that
878      *         The charset to which this charset is to be compared
879      *
880      * @return A negative integer, zero, or a positive integer as this charset
881      *         is less than, equal to, or greater than the specified charset
882      */
883     public final int compareTo(Charset that) {
884         return (name().compareToIgnoreCase(that.name()));
885     }
886 
887     /**
888      * Computes a hashcode for this charset.
889      *
890      * @return  An integer hashcode
891      */
892     public final int hashCode() {
893         return name().hashCode();
894     }
895 
896     /**
897      * Tells whether or not this object is equal to another.
898      *
899      * &lt;p&gt; Two charsets are equal if, and only if, they have the same canonical
900      * names.  A charset is never equal to any other type of object.  &lt;/p&gt;
901      *
902      * @return  {@code true} if, and only if, this charset is equal to the
903      *          given object
904      */
905     public final boolean equals(Object ob) {
906         if (!(ob instanceof Charset))
907             return false;
908         if (this == ob)
909             return true;
910         return name.equals(((Charset)ob).name());
911     }
912 
913     /**
914      * Returns a string describing this charset.
915      *
916      * @return  A string describing this charset
917      */
918     public final String toString() {
919         return name();
920     }
921 
922 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
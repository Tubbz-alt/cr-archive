<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.util;
  26 
<a name="2" id="anc2"></a><span class="line-removed">  27 import java.util.concurrent.RecursiveAction;</span>
  28 import java.util.concurrent.CountedCompleter;
  29 
  30 /**
  31  * Helper utilities for the parallel sort methods in Arrays.parallelSort.
  32  *
  33  * For each primitive type, plus Object, we define a static class to
  34  * contain the Sorter and Merger implementations for that type:
  35  *
  36  * Sorter classes based mainly on CilkSort
  37  * &lt;A href=&quot;http://supertech.lcs.mit.edu/cilk/&quot;&gt; Cilk&lt;/A&gt;:
  38  * Basic algorithm:
<a name="3" id="anc3"></a><span class="line-modified">  39  * if array size is small, just use a sequential quicksort (via Arrays.sort)</span>
  40  *         Otherwise:
  41  *         1. Break array in half.
  42  *         2. For each half,
  43  *             a. break the half in half (i.e., quarters),
  44  *             b. sort the quarters
  45  *             c. merge them together
  46  *         3. merge together the two halves.
  47  *
  48  * One reason for splitting in quarters is that this guarantees that
  49  * the final sort is in the main array, not the workspace array.
  50  * (workspace and main swap roles on each subsort step.)  Leaf-level
  51  * sorts use the associated sequential sort.
  52  *
  53  * Merger classes perform merging for Sorter.  They are structured
  54  * such that if the underlying sort is stable (as is true for
  55  * TimSort), then so is the full sort.  If big enough, they split the
  56  * largest of the two partitions in half, find the greatest point in
  57  * smaller partition less than the beginning of the second half of
  58  * larger via binary search; and then merge in parallel the two
  59  * partitions.  In part to ensure tasks are triggered in
  60  * stability-preserving order, the current CountedCompleter design
  61  * requires some little tasks to serve as place holders for triggering
  62  * completion tasks.  These classes (EmptyCompleter and Relay) don&#39;t
  63  * need to keep track of the arrays, and are never themselves forked,
  64  * so don&#39;t hold any task state.
  65  *
<a name="4" id="anc4"></a><span class="line-removed">  66  * The primitive class versions (FJByte... FJDouble) are</span>
<span class="line-removed">  67  * identical to each other except for type declarations.</span>
<span class="line-removed">  68  *</span>
  69  * The base sequential sorts rely on non-public versions of TimSort,
<a name="5" id="anc5"></a><span class="line-modified">  70  * ComparableTimSort, and DualPivotQuicksort sort methods that accept</span>
<span class="line-modified">  71  * temp workspace array slices that we will have already allocated, so</span>
<span class="line-modified">  72  * avoids redundant allocation. (Except for DualPivotQuicksort byte[]</span>
<span class="line-removed">  73  * sort, that does not ever use a workspace array.)</span>
  74  */
  75 /*package*/ class ArraysParallelSortHelpers {
  76 
  77     /*
  78      * Style note: The task classes have a lot of parameters, that are
  79      * stored as task fields and copied to local variables and used in
  80      * compute() methods, We pack these into as few lines as possible,
  81      * and hoist consistency checks among them before main loops, to
  82      * reduce distraction.
  83      */
  84 
  85     /**
  86      * A placeholder task for Sorters, used for the lowest
  87      * quartile task, that does not need to maintain array state.
  88      */
  89     static final class EmptyCompleter extends CountedCompleter&lt;Void&gt; {
<a name="6" id="anc6"></a>
  90         static final long serialVersionUID = 2446542900576103244L;
  91         EmptyCompleter(CountedCompleter&lt;?&gt; p) { super(p); }
  92         public final void compute() { }
  93     }
  94 
  95     /**
  96      * A trigger for secondary merge of two merges
  97      */
  98     static final class Relay extends CountedCompleter&lt;Void&gt; {
<a name="7" id="anc7"></a>
  99         static final long serialVersionUID = 2446542900576103244L;
 100         final CountedCompleter&lt;?&gt; task;
 101         Relay(CountedCompleter&lt;?&gt; task) {
 102             super(null, 1);
 103             this.task = task;
 104         }
 105         public final void compute() { }
 106         public final void onCompletion(CountedCompleter&lt;?&gt; t) {
 107             task.compute();
 108         }
 109     }
 110 
 111     /** Object + Comparator support class */
 112     static final class FJObject {
 113         static final class Sorter&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
<a name="8" id="anc8"></a>
 114             static final long serialVersionUID = 2446542900576103244L;
<a name="9" id="anc9"></a><span class="line-modified"> 115             final T[] a, w;</span>



 116             final int base, size, wbase, gran;
<a name="10" id="anc10"></a>
 117             Comparator&lt;? super T&gt; comparator;
 118             Sorter(CountedCompleter&lt;?&gt; par, T[] a, T[] w, int base, int size,
 119                    int wbase, int gran,
 120                    Comparator&lt;? super T&gt; comparator) {
 121                 super(par);
 122                 this.a = a; this.w = w; this.base = base; this.size = size;
 123                 this.wbase = wbase; this.gran = gran;
 124                 this.comparator = comparator;
 125             }
 126             public final void compute() {
 127                 CountedCompleter&lt;?&gt; s = this;
 128                 Comparator&lt;? super T&gt; c = this.comparator;
 129                 T[] a = this.a, w = this.w; // localize all params
 130                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;
 131                 while (n &gt; g) {
 132                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles
 133                     Relay fc = new Relay(new Merger&lt;&gt;(s, w, a, wb, h,
 134                                                       wb+h, n-h, b, g, c));
 135                     Relay rc = new Relay(new Merger&lt;&gt;(fc, a, w, b+h, q,
 136                                                       b+u, n-u, wb+h, g, c));
 137                     new Sorter&lt;&gt;(rc, a, w, b+u, n-u, wb+u, g, c).fork();
<a name="11" id="anc11"></a><span class="line-modified"> 138                     new Sorter&lt;&gt;(rc, a, w, b+h, q, wb+h, g, c).fork();;</span>
 139                     Relay bc = new Relay(new Merger&lt;&gt;(fc, a, w, b, q,
 140                                                       b+q, h-q, wb, g, c));
 141                     new Sorter&lt;&gt;(bc, a, w, b+q, h-q, wb+q, g, c).fork();
 142                     s = new EmptyCompleter(bc);
 143                     n = q;
 144                 }
 145                 TimSort.sort(a, b, b + n, c, w, wb, n);
 146                 s.tryComplete();
 147             }
 148         }
 149 
 150         static final class Merger&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
<a name="12" id="anc12"></a>
 151             static final long serialVersionUID = 2446542900576103244L;
<a name="13" id="anc13"></a><span class="line-modified"> 152             final T[] a, w; // main and workspace arrays</span>




 153             final int lbase, lsize, rbase, rsize, wbase, gran;
<a name="14" id="anc14"></a>
 154             Comparator&lt;? super T&gt; comparator;
 155             Merger(CountedCompleter&lt;?&gt; par, T[] a, T[] w,
 156                    int lbase, int lsize, int rbase,
 157                    int rsize, int wbase, int gran,
 158                    Comparator&lt;? super T&gt; comparator) {
 159                 super(par);
 160                 this.a = a; this.w = w;
 161                 this.lbase = lbase; this.lsize = lsize;
 162                 this.rbase = rbase; this.rsize = rsize;
 163                 this.wbase = wbase; this.gran = gran;
 164                 this.comparator = comparator;
 165             }
 166 
 167             public final void compute() {
 168                 Comparator&lt;? super T&gt; c = this.comparator;
 169                 T[] a = this.a, w = this.w; // localize all params
 170                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,
 171                     rn = this.rsize, k = this.wbase, g = this.gran;
 172                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0 ||
 173                     c == null)
 174                     throw new IllegalStateException(); // hoist checks
 175                 for (int lh, rh;;) {  // split larger, find point in smaller
 176                     if (ln &gt;= rn) {
 177                         if (ln &lt;= g)
 178                             break;
 179                         rh = rn;
 180                         T split = a[(lh = ln &gt;&gt;&gt; 1) + lb];
 181                         for (int lo = 0; lo &lt; rh; ) {
 182                             int rm = (lo + rh) &gt;&gt;&gt; 1;
 183                             if (c.compare(split, a[rm + rb]) &lt;= 0)
 184                                 rh = rm;
 185                             else
 186                                 lo = rm + 1;
 187                         }
 188                     }
 189                     else {
 190                         if (rn &lt;= g)
 191                             break;
 192                         lh = ln;
 193                         T split = a[(rh = rn &gt;&gt;&gt; 1) + rb];
 194                         for (int lo = 0; lo &lt; lh; ) {
 195                             int lm = (lo + lh) &gt;&gt;&gt; 1;
 196                             if (c.compare(split, a[lm + lb]) &lt;= 0)
 197                                 lh = lm;
 198                             else
 199                                 lo = lm + 1;
 200                         }
 201                     }
 202                     Merger&lt;T&gt; m = new Merger&lt;&gt;(this, a, w, lb + lh, ln - lh,
 203                                                rb + rh, rn - rh,
 204                                                k + lh + rh, g, c);
 205                     rn = rh;
 206                     ln = lh;
 207                     addToPendingCount(1);
 208                     m.fork();
 209                 }
 210 
 211                 int lf = lb + ln, rf = rb + rn; // index bounds
 212                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {
 213                     T t, al, ar;
 214                     if (c.compare((al = a[lb]), (ar = a[rb])) &lt;= 0) {
 215                         lb++; t = al;
 216                     }
 217                     else {
 218                         rb++; t = ar;
 219                     }
 220                     w[k++] = t;
 221                 }
 222                 if (rb &lt; rf)
 223                     System.arraycopy(a, rb, w, k, rf - rb);
 224                 else if (lb &lt; lf)
 225                     System.arraycopy(a, lb, w, k, lf - lb);
 226 
 227                 tryComplete();
 228             }
<a name="15" id="anc15"></a><span class="line-removed"> 229 </span>
<span class="line-removed"> 230         }</span>
<span class="line-removed"> 231     } // FJObject</span>
<span class="line-removed"> 232 </span>
<span class="line-removed"> 233     /** byte support class */</span>
<span class="line-removed"> 234     static final class FJByte {</span>
<span class="line-removed"> 235         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 236             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 237             final byte[] a, w;</span>
<span class="line-removed"> 238             final int base, size, wbase, gran;</span>
<span class="line-removed"> 239             Sorter(CountedCompleter&lt;?&gt; par, byte[] a, byte[] w, int base,</span>
<span class="line-removed"> 240                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 241                 super(par);</span>
<span class="line-removed"> 242                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 243                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 244             }</span>
<span class="line-removed"> 245             public final void compute() {</span>
<span class="line-removed"> 246                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 247                 byte[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 248                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 249                 while (n &gt; g) {</span>
<span class="line-removed"> 250                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 251                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 252                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 253                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 254                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 255                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 256                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 257                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 258                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 259                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 260                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 261                     n = q;</span>
<span class="line-removed"> 262                 }</span>
<span class="line-removed"> 263                 DualPivotQuicksort.sort(a, b, b + n - 1);</span>
<span class="line-removed"> 264                 s.tryComplete();</span>
<span class="line-removed"> 265             }</span>
<span class="line-removed"> 266         }</span>
<span class="line-removed"> 267 </span>
<span class="line-removed"> 268         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 269             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 270             final byte[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 271             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 272             Merger(CountedCompleter&lt;?&gt; par, byte[] a, byte[] w,</span>
<span class="line-removed"> 273                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 274                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 275                 super(par);</span>
<span class="line-removed"> 276                 this.a = a; this.w = w;</span>
<span class="line-removed"> 277                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 278                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 279                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 280             }</span>
<span class="line-removed"> 281 </span>
<span class="line-removed"> 282             public final void compute() {</span>
<span class="line-removed"> 283                 byte[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 284                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 285                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 286                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 287                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 288                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 289                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 290                         if (ln &lt;= g)</span>
<span class="line-removed"> 291                             break;</span>
<span class="line-removed"> 292                         rh = rn;</span>
<span class="line-removed"> 293                         byte split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 294                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 295                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 296                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 297                                 rh = rm;</span>
<span class="line-removed"> 298                             else</span>
<span class="line-removed"> 299                                 lo = rm + 1;</span>
<span class="line-removed"> 300                         }</span>
<span class="line-removed"> 301                     }</span>
<span class="line-removed"> 302                     else {</span>
<span class="line-removed"> 303                         if (rn &lt;= g)</span>
<span class="line-removed"> 304                             break;</span>
<span class="line-removed"> 305                         lh = ln;</span>
<span class="line-removed"> 306                         byte split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 307                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 308                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 309                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 310                                 lh = lm;</span>
<span class="line-removed"> 311                             else</span>
<span class="line-removed"> 312                                 lo = lm + 1;</span>
<span class="line-removed"> 313                         }</span>
<span class="line-removed"> 314                     }</span>
<span class="line-removed"> 315                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 316                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 317                                           k + lh + rh, g);</span>
<span class="line-removed"> 318                     rn = rh;</span>
<span class="line-removed"> 319                     ln = lh;</span>
<span class="line-removed"> 320                     addToPendingCount(1);</span>
<span class="line-removed"> 321                     m.fork();</span>
<span class="line-removed"> 322                 }</span>
<span class="line-removed"> 323 </span>
<span class="line-removed"> 324                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 325                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 326                     byte t, al, ar;</span>
<span class="line-removed"> 327                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 328                         lb++; t = al;</span>
<span class="line-removed"> 329                     }</span>
<span class="line-removed"> 330                     else {</span>
<span class="line-removed"> 331                         rb++; t = ar;</span>
<span class="line-removed"> 332                     }</span>
<span class="line-removed"> 333                     w[k++] = t;</span>
<span class="line-removed"> 334                 }</span>
<span class="line-removed"> 335                 if (rb &lt; rf)</span>
<span class="line-removed"> 336                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed"> 337                 else if (lb &lt; lf)</span>
<span class="line-removed"> 338                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed"> 339                 tryComplete();</span>
<span class="line-removed"> 340             }</span>
<span class="line-removed"> 341         }</span>
<span class="line-removed"> 342     } // FJByte</span>
<span class="line-removed"> 343 </span>
<span class="line-removed"> 344     /** char support class */</span>
<span class="line-removed"> 345     static final class FJChar {</span>
<span class="line-removed"> 346         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 347             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 348             final char[] a, w;</span>
<span class="line-removed"> 349             final int base, size, wbase, gran;</span>
<span class="line-removed"> 350             Sorter(CountedCompleter&lt;?&gt; par, char[] a, char[] w, int base,</span>
<span class="line-removed"> 351                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 352                 super(par);</span>
<span class="line-removed"> 353                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 354                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 355             }</span>
<span class="line-removed"> 356             public final void compute() {</span>
<span class="line-removed"> 357                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 358                 char[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 359                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 360                 while (n &gt; g) {</span>
<span class="line-removed"> 361                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 362                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 363                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 364                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 365                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 366                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 367                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 368                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 369                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 370                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 371                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 372                     n = q;</span>
<span class="line-removed"> 373                 }</span>
<span class="line-removed"> 374                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed"> 375                 s.tryComplete();</span>
<span class="line-removed"> 376             }</span>
<span class="line-removed"> 377         }</span>
<span class="line-removed"> 378 </span>
<span class="line-removed"> 379         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 380             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 381             final char[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 382             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 383             Merger(CountedCompleter&lt;?&gt; par, char[] a, char[] w,</span>
<span class="line-removed"> 384                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 385                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 386                 super(par);</span>
<span class="line-removed"> 387                 this.a = a; this.w = w;</span>
<span class="line-removed"> 388                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 389                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 390                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 391             }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393             public final void compute() {</span>
<span class="line-removed"> 394                 char[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 395                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 396                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 397                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 398                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 399                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 400                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 401                         if (ln &lt;= g)</span>
<span class="line-removed"> 402                             break;</span>
<span class="line-removed"> 403                         rh = rn;</span>
<span class="line-removed"> 404                         char split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 405                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 406                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 407                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 408                                 rh = rm;</span>
<span class="line-removed"> 409                             else</span>
<span class="line-removed"> 410                                 lo = rm + 1;</span>
<span class="line-removed"> 411                         }</span>
<span class="line-removed"> 412                     }</span>
<span class="line-removed"> 413                     else {</span>
<span class="line-removed"> 414                         if (rn &lt;= g)</span>
<span class="line-removed"> 415                             break;</span>
<span class="line-removed"> 416                         lh = ln;</span>
<span class="line-removed"> 417                         char split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 418                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 419                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 420                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 421                                 lh = lm;</span>
<span class="line-removed"> 422                             else</span>
<span class="line-removed"> 423                                 lo = lm + 1;</span>
<span class="line-removed"> 424                         }</span>
<span class="line-removed"> 425                     }</span>
<span class="line-removed"> 426                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 427                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 428                                           k + lh + rh, g);</span>
<span class="line-removed"> 429                     rn = rh;</span>
<span class="line-removed"> 430                     ln = lh;</span>
<span class="line-removed"> 431                     addToPendingCount(1);</span>
<span class="line-removed"> 432                     m.fork();</span>
<span class="line-removed"> 433                 }</span>
<span class="line-removed"> 434 </span>
<span class="line-removed"> 435                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 436                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 437                     char t, al, ar;</span>
<span class="line-removed"> 438                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 439                         lb++; t = al;</span>
<span class="line-removed"> 440                     }</span>
<span class="line-removed"> 441                     else {</span>
<span class="line-removed"> 442                         rb++; t = ar;</span>
<span class="line-removed"> 443                     }</span>
<span class="line-removed"> 444                     w[k++] = t;</span>
<span class="line-removed"> 445                 }</span>
<span class="line-removed"> 446                 if (rb &lt; rf)</span>
<span class="line-removed"> 447                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed"> 448                 else if (lb &lt; lf)</span>
<span class="line-removed"> 449                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed"> 450                 tryComplete();</span>
<span class="line-removed"> 451             }</span>
<span class="line-removed"> 452         }</span>
<span class="line-removed"> 453     } // FJChar</span>
<span class="line-removed"> 454 </span>
<span class="line-removed"> 455     /** short support class */</span>
<span class="line-removed"> 456     static final class FJShort {</span>
<span class="line-removed"> 457         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 458             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 459             final short[] a, w;</span>
<span class="line-removed"> 460             final int base, size, wbase, gran;</span>
<span class="line-removed"> 461             Sorter(CountedCompleter&lt;?&gt; par, short[] a, short[] w, int base,</span>
<span class="line-removed"> 462                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 463                 super(par);</span>
<span class="line-removed"> 464                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 465                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 466             }</span>
<span class="line-removed"> 467             public final void compute() {</span>
<span class="line-removed"> 468                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 469                 short[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 470                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 471                 while (n &gt; g) {</span>
<span class="line-removed"> 472                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 473                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 474                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 475                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 476                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 477                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 478                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 479                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 480                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 481                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 482                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 483                     n = q;</span>
<span class="line-removed"> 484                 }</span>
<span class="line-removed"> 485                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed"> 486                 s.tryComplete();</span>
<span class="line-removed"> 487             }</span>
<span class="line-removed"> 488         }</span>
<span class="line-removed"> 489 </span>
<span class="line-removed"> 490         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 491             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 492             final short[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 493             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 494             Merger(CountedCompleter&lt;?&gt; par, short[] a, short[] w,</span>
<span class="line-removed"> 495                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 496                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 497                 super(par);</span>
<span class="line-removed"> 498                 this.a = a; this.w = w;</span>
<span class="line-removed"> 499                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 500                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 501                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 502             }</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504             public final void compute() {</span>
<span class="line-removed"> 505                 short[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 506                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 507                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 508                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 509                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 510                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 511                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 512                         if (ln &lt;= g)</span>
<span class="line-removed"> 513                             break;</span>
<span class="line-removed"> 514                         rh = rn;</span>
<span class="line-removed"> 515                         short split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 516                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 517                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 518                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 519                                 rh = rm;</span>
<span class="line-removed"> 520                             else</span>
<span class="line-removed"> 521                                 lo = rm + 1;</span>
<span class="line-removed"> 522                         }</span>
<span class="line-removed"> 523                     }</span>
<span class="line-removed"> 524                     else {</span>
<span class="line-removed"> 525                         if (rn &lt;= g)</span>
<span class="line-removed"> 526                             break;</span>
<span class="line-removed"> 527                         lh = ln;</span>
<span class="line-removed"> 528                         short split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 529                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 530                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 531                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 532                                 lh = lm;</span>
<span class="line-removed"> 533                             else</span>
<span class="line-removed"> 534                                 lo = lm + 1;</span>
<span class="line-removed"> 535                         }</span>
<span class="line-removed"> 536                     }</span>
<span class="line-removed"> 537                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 538                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 539                                           k + lh + rh, g);</span>
<span class="line-removed"> 540                     rn = rh;</span>
<span class="line-removed"> 541                     ln = lh;</span>
<span class="line-removed"> 542                     addToPendingCount(1);</span>
<span class="line-removed"> 543                     m.fork();</span>
<span class="line-removed"> 544                 }</span>
<span class="line-removed"> 545 </span>
<span class="line-removed"> 546                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 547                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 548                     short t, al, ar;</span>
<span class="line-removed"> 549                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 550                         lb++; t = al;</span>
<span class="line-removed"> 551                     }</span>
<span class="line-removed"> 552                     else {</span>
<span class="line-removed"> 553                         rb++; t = ar;</span>
<span class="line-removed"> 554                     }</span>
<span class="line-removed"> 555                     w[k++] = t;</span>
<span class="line-removed"> 556                 }</span>
<span class="line-removed"> 557                 if (rb &lt; rf)</span>
<span class="line-removed"> 558                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed"> 559                 else if (lb &lt; lf)</span>
<span class="line-removed"> 560                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed"> 561                 tryComplete();</span>
<span class="line-removed"> 562             }</span>
<span class="line-removed"> 563         }</span>
<span class="line-removed"> 564     } // FJShort</span>
<span class="line-removed"> 565 </span>
<span class="line-removed"> 566     /** int support class */</span>
<span class="line-removed"> 567     static final class FJInt {</span>
<span class="line-removed"> 568         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 569             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 570             final int[] a, w;</span>
<span class="line-removed"> 571             final int base, size, wbase, gran;</span>
<span class="line-removed"> 572             Sorter(CountedCompleter&lt;?&gt; par, int[] a, int[] w, int base,</span>
<span class="line-removed"> 573                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 574                 super(par);</span>
<span class="line-removed"> 575                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 576                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 577             }</span>
<span class="line-removed"> 578             public final void compute() {</span>
<span class="line-removed"> 579                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 580                 int[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 581                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 582                 while (n &gt; g) {</span>
<span class="line-removed"> 583                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 584                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 585                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 586                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 587                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 588                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 589                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 590                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 591                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 592                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 593                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 594                     n = q;</span>
<span class="line-removed"> 595                 }</span>
<span class="line-removed"> 596                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed"> 597                 s.tryComplete();</span>
<span class="line-removed"> 598             }</span>
 599         }
<a name="16" id="anc16"></a><span class="line-modified"> 600 </span>
<span class="line-removed"> 601         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 602             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 603             final int[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 604             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 605             Merger(CountedCompleter&lt;?&gt; par, int[] a, int[] w,</span>
<span class="line-removed"> 606                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 607                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 608                 super(par);</span>
<span class="line-removed"> 609                 this.a = a; this.w = w;</span>
<span class="line-removed"> 610                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 611                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 612                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 613             }</span>
<span class="line-removed"> 614 </span>
<span class="line-removed"> 615             public final void compute() {</span>
<span class="line-removed"> 616                 int[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 617                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 618                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 619                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 620                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 621                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 622                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 623                         if (ln &lt;= g)</span>
<span class="line-removed"> 624                             break;</span>
<span class="line-removed"> 625                         rh = rn;</span>
<span class="line-removed"> 626                         int split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 627                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 628                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 629                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 630                                 rh = rm;</span>
<span class="line-removed"> 631                             else</span>
<span class="line-removed"> 632                                 lo = rm + 1;</span>
<span class="line-removed"> 633                         }</span>
<span class="line-removed"> 634                     }</span>
<span class="line-removed"> 635                     else {</span>
<span class="line-removed"> 636                         if (rn &lt;= g)</span>
<span class="line-removed"> 637                             break;</span>
<span class="line-removed"> 638                         lh = ln;</span>
<span class="line-removed"> 639                         int split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 640                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 641                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 642                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 643                                 lh = lm;</span>
<span class="line-removed"> 644                             else</span>
<span class="line-removed"> 645                                 lo = lm + 1;</span>
<span class="line-removed"> 646                         }</span>
<span class="line-removed"> 647                     }</span>
<span class="line-removed"> 648                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 649                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 650                                           k + lh + rh, g);</span>
<span class="line-removed"> 651                     rn = rh;</span>
<span class="line-removed"> 652                     ln = lh;</span>
<span class="line-removed"> 653                     addToPendingCount(1);</span>
<span class="line-removed"> 654                     m.fork();</span>
<span class="line-removed"> 655                 }</span>
<span class="line-removed"> 656 </span>
<span class="line-removed"> 657                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 658                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 659                     int t, al, ar;</span>
<span class="line-removed"> 660                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 661                         lb++; t = al;</span>
<span class="line-removed"> 662                     }</span>
<span class="line-removed"> 663                     else {</span>
<span class="line-removed"> 664                         rb++; t = ar;</span>
<span class="line-removed"> 665                     }</span>
<span class="line-removed"> 666                     w[k++] = t;</span>
<span class="line-removed"> 667                 }</span>
<span class="line-removed"> 668                 if (rb &lt; rf)</span>
<span class="line-removed"> 669                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed"> 670                 else if (lb &lt; lf)</span>
<span class="line-removed"> 671                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed"> 672                 tryComplete();</span>
<span class="line-removed"> 673             }</span>
<span class="line-removed"> 674         }</span>
<span class="line-removed"> 675     } // FJInt</span>
<span class="line-removed"> 676 </span>
<span class="line-removed"> 677     /** long support class */</span>
<span class="line-removed"> 678     static final class FJLong {</span>
<span class="line-removed"> 679         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 680             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 681             final long[] a, w;</span>
<span class="line-removed"> 682             final int base, size, wbase, gran;</span>
<span class="line-removed"> 683             Sorter(CountedCompleter&lt;?&gt; par, long[] a, long[] w, int base,</span>
<span class="line-removed"> 684                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 685                 super(par);</span>
<span class="line-removed"> 686                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 687                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 688             }</span>
<span class="line-removed"> 689             public final void compute() {</span>
<span class="line-removed"> 690                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 691                 long[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 692                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 693                 while (n &gt; g) {</span>
<span class="line-removed"> 694                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 695                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 696                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 697                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 698                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 699                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 700                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 701                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 702                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 703                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 704                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 705                     n = q;</span>
<span class="line-removed"> 706                 }</span>
<span class="line-removed"> 707                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed"> 708                 s.tryComplete();</span>
<span class="line-removed"> 709             }</span>
<span class="line-removed"> 710         }</span>
<span class="line-removed"> 711 </span>
<span class="line-removed"> 712         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 713             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 714             final long[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 715             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 716             Merger(CountedCompleter&lt;?&gt; par, long[] a, long[] w,</span>
<span class="line-removed"> 717                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 718                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 719                 super(par);</span>
<span class="line-removed"> 720                 this.a = a; this.w = w;</span>
<span class="line-removed"> 721                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 722                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 723                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 724             }</span>
<span class="line-removed"> 725 </span>
<span class="line-removed"> 726             public final void compute() {</span>
<span class="line-removed"> 727                 long[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 728                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 729                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 730                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 731                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 732                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 733                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 734                         if (ln &lt;= g)</span>
<span class="line-removed"> 735                             break;</span>
<span class="line-removed"> 736                         rh = rn;</span>
<span class="line-removed"> 737                         long split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 738                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 739                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 740                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 741                                 rh = rm;</span>
<span class="line-removed"> 742                             else</span>
<span class="line-removed"> 743                                 lo = rm + 1;</span>
<span class="line-removed"> 744                         }</span>
<span class="line-removed"> 745                     }</span>
<span class="line-removed"> 746                     else {</span>
<span class="line-removed"> 747                         if (rn &lt;= g)</span>
<span class="line-removed"> 748                             break;</span>
<span class="line-removed"> 749                         lh = ln;</span>
<span class="line-removed"> 750                         long split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 751                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 752                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 753                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 754                                 lh = lm;</span>
<span class="line-removed"> 755                             else</span>
<span class="line-removed"> 756                                 lo = lm + 1;</span>
<span class="line-removed"> 757                         }</span>
<span class="line-removed"> 758                     }</span>
<span class="line-removed"> 759                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 760                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 761                                           k + lh + rh, g);</span>
<span class="line-removed"> 762                     rn = rh;</span>
<span class="line-removed"> 763                     ln = lh;</span>
<span class="line-removed"> 764                     addToPendingCount(1);</span>
<span class="line-removed"> 765                     m.fork();</span>
<span class="line-removed"> 766                 }</span>
<span class="line-removed"> 767 </span>
<span class="line-removed"> 768                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 769                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 770                     long t, al, ar;</span>
<span class="line-removed"> 771                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 772                         lb++; t = al;</span>
<span class="line-removed"> 773                     }</span>
<span class="line-removed"> 774                     else {</span>
<span class="line-removed"> 775                         rb++; t = ar;</span>
<span class="line-removed"> 776                     }</span>
<span class="line-removed"> 777                     w[k++] = t;</span>
<span class="line-removed"> 778                 }</span>
<span class="line-removed"> 779                 if (rb &lt; rf)</span>
<span class="line-removed"> 780                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed"> 781                 else if (lb &lt; lf)</span>
<span class="line-removed"> 782                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed"> 783                 tryComplete();</span>
<span class="line-removed"> 784             }</span>
<span class="line-removed"> 785         }</span>
<span class="line-removed"> 786     } // FJLong</span>
<span class="line-removed"> 787 </span>
<span class="line-removed"> 788     /** float support class */</span>
<span class="line-removed"> 789     static final class FJFloat {</span>
<span class="line-removed"> 790         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 791             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 792             final float[] a, w;</span>
<span class="line-removed"> 793             final int base, size, wbase, gran;</span>
<span class="line-removed"> 794             Sorter(CountedCompleter&lt;?&gt; par, float[] a, float[] w, int base,</span>
<span class="line-removed"> 795                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 796                 super(par);</span>
<span class="line-removed"> 797                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 798                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 799             }</span>
<span class="line-removed"> 800             public final void compute() {</span>
<span class="line-removed"> 801                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 802                 float[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 803                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 804                 while (n &gt; g) {</span>
<span class="line-removed"> 805                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 806                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 807                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 808                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 809                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 810                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 811                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 812                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 813                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 814                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 815                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 816                     n = q;</span>
<span class="line-removed"> 817                 }</span>
<span class="line-removed"> 818                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed"> 819                 s.tryComplete();</span>
<span class="line-removed"> 820             }</span>
<span class="line-removed"> 821         }</span>
<span class="line-removed"> 822 </span>
<span class="line-removed"> 823         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 824             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 825             final float[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 826             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 827             Merger(CountedCompleter&lt;?&gt; par, float[] a, float[] w,</span>
<span class="line-removed"> 828                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 829                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 830                 super(par);</span>
<span class="line-removed"> 831                 this.a = a; this.w = w;</span>
<span class="line-removed"> 832                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 833                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 834                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 835             }</span>
<span class="line-removed"> 836 </span>
<span class="line-removed"> 837             public final void compute() {</span>
<span class="line-removed"> 838                 float[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 839                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 840                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 841                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 842                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 843                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 844                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 845                         if (ln &lt;= g)</span>
<span class="line-removed"> 846                             break;</span>
<span class="line-removed"> 847                         rh = rn;</span>
<span class="line-removed"> 848                         float split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 849                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 850                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 851                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 852                                 rh = rm;</span>
<span class="line-removed"> 853                             else</span>
<span class="line-removed"> 854                                 lo = rm + 1;</span>
<span class="line-removed"> 855                         }</span>
<span class="line-removed"> 856                     }</span>
<span class="line-removed"> 857                     else {</span>
<span class="line-removed"> 858                         if (rn &lt;= g)</span>
<span class="line-removed"> 859                             break;</span>
<span class="line-removed"> 860                         lh = ln;</span>
<span class="line-removed"> 861                         float split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 862                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 863                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 864                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 865                                 lh = lm;</span>
<span class="line-removed"> 866                             else</span>
<span class="line-removed"> 867                                 lo = lm + 1;</span>
<span class="line-removed"> 868                         }</span>
<span class="line-removed"> 869                     }</span>
<span class="line-removed"> 870                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 871                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 872                                           k + lh + rh, g);</span>
<span class="line-removed"> 873                     rn = rh;</span>
<span class="line-removed"> 874                     ln = lh;</span>
<span class="line-removed"> 875                     addToPendingCount(1);</span>
<span class="line-removed"> 876                     m.fork();</span>
<span class="line-removed"> 877                 }</span>
<span class="line-removed"> 878 </span>
<span class="line-removed"> 879                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 880                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 881                     float t, al, ar;</span>
<span class="line-removed"> 882                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 883                         lb++; t = al;</span>
<span class="line-removed"> 884                     }</span>
<span class="line-removed"> 885                     else {</span>
<span class="line-removed"> 886                         rb++; t = ar;</span>
<span class="line-removed"> 887                     }</span>
<span class="line-removed"> 888                     w[k++] = t;</span>
<span class="line-removed"> 889                 }</span>
<span class="line-removed"> 890                 if (rb &lt; rf)</span>
<span class="line-removed"> 891                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed"> 892                 else if (lb &lt; lf)</span>
<span class="line-removed"> 893                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed"> 894                 tryComplete();</span>
<span class="line-removed"> 895             }</span>
<span class="line-removed"> 896         }</span>
<span class="line-removed"> 897     } // FJFloat</span>
<span class="line-removed"> 898 </span>
<span class="line-removed"> 899     /** double support class */</span>
<span class="line-removed"> 900     static final class FJDouble {</span>
<span class="line-removed"> 901         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 902             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 903             final double[] a, w;</span>
<span class="line-removed"> 904             final int base, size, wbase, gran;</span>
<span class="line-removed"> 905             Sorter(CountedCompleter&lt;?&gt; par, double[] a, double[] w, int base,</span>
<span class="line-removed"> 906                    int size, int wbase, int gran) {</span>
<span class="line-removed"> 907                 super(par);</span>
<span class="line-removed"> 908                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed"> 909                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 910             }</span>
<span class="line-removed"> 911             public final void compute() {</span>
<span class="line-removed"> 912                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed"> 913                 double[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 914                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed"> 915                 while (n &gt; g) {</span>
<span class="line-removed"> 916                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed"> 917                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed"> 918                                                     wb+h, n-h, b, g));</span>
<span class="line-removed"> 919                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed"> 920                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed"> 921                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed"> 922                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed"> 923                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed"> 924                                                     b+q, h-q, wb, g));</span>
<span class="line-removed"> 925                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed"> 926                     s = new EmptyCompleter(bc);</span>
<span class="line-removed"> 927                     n = q;</span>
<span class="line-removed"> 928                 }</span>
<span class="line-removed"> 929                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed"> 930                 s.tryComplete();</span>
<span class="line-removed"> 931             }</span>
<span class="line-removed"> 932         }</span>
<span class="line-removed"> 933 </span>
<span class="line-removed"> 934         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed"> 935             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed"> 936             final double[] a, w; // main and workspace arrays</span>
<span class="line-removed"> 937             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed"> 938             Merger(CountedCompleter&lt;?&gt; par, double[] a, double[] w,</span>
<span class="line-removed"> 939                    int lbase, int lsize, int rbase,</span>
<span class="line-removed"> 940                    int rsize, int wbase, int gran) {</span>
<span class="line-removed"> 941                 super(par);</span>
<span class="line-removed"> 942                 this.a = a; this.w = w;</span>
<span class="line-removed"> 943                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed"> 944                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed"> 945                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed"> 946             }</span>
<span class="line-removed"> 947 </span>
<span class="line-removed"> 948             public final void compute() {</span>
<span class="line-removed"> 949                 double[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed"> 950                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed"> 951                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed"> 952                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed"> 953                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed"> 954                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed"> 955                     if (ln &gt;= rn) {</span>
<span class="line-removed"> 956                         if (ln &lt;= g)</span>
<span class="line-removed"> 957                             break;</span>
<span class="line-removed"> 958                         rh = rn;</span>
<span class="line-removed"> 959                         double split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed"> 960                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed"> 961                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 962                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed"> 963                                 rh = rm;</span>
<span class="line-removed"> 964                             else</span>
<span class="line-removed"> 965                                 lo = rm + 1;</span>
<span class="line-removed"> 966                         }</span>
<span class="line-removed"> 967                     }</span>
<span class="line-removed"> 968                     else {</span>
<span class="line-removed"> 969                         if (rn &lt;= g)</span>
<span class="line-removed"> 970                             break;</span>
<span class="line-removed"> 971                         lh = ln;</span>
<span class="line-removed"> 972                         double split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed"> 973                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed"> 974                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed"> 975                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed"> 976                                 lh = lm;</span>
<span class="line-removed"> 977                             else</span>
<span class="line-removed"> 978                                 lo = lm + 1;</span>
<span class="line-removed"> 979                         }</span>
<span class="line-removed"> 980                     }</span>
<span class="line-removed"> 981                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed"> 982                                           rb + rh, rn - rh,</span>
<span class="line-removed"> 983                                           k + lh + rh, g);</span>
<span class="line-removed"> 984                     rn = rh;</span>
<span class="line-removed"> 985                     ln = lh;</span>
<span class="line-removed"> 986                     addToPendingCount(1);</span>
<span class="line-removed"> 987                     m.fork();</span>
<span class="line-removed"> 988                 }</span>
<span class="line-removed"> 989 </span>
<span class="line-removed"> 990                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed"> 991                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed"> 992                     double t, al, ar;</span>
<span class="line-removed"> 993                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed"> 994                         lb++; t = al;</span>
<span class="line-removed"> 995                     }</span>
<span class="line-removed"> 996                     else {</span>
<span class="line-removed"> 997                         rb++; t = ar;</span>
<span class="line-removed"> 998                     }</span>
<span class="line-removed"> 999                     w[k++] = t;</span>
<span class="line-removed">1000                 }</span>
<span class="line-removed">1001                 if (rb &lt; rf)</span>
<span class="line-removed">1002                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">1003                 else if (lb &lt; lf)</span>
<span class="line-removed">1004                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">1005                 tryComplete();</span>
<span class="line-removed">1006             }</span>
<span class="line-removed">1007         }</span>
<span class="line-removed">1008     } // FJDouble</span>
<span class="line-removed">1009 </span>
1010 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
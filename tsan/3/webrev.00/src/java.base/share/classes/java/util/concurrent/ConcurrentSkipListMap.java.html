<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListMap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent;
  37 
  38 import java.lang.invoke.MethodHandles;
  39 import java.lang.invoke.VarHandle;
  40 import java.io.Serializable;
  41 import java.util.AbstractCollection;
  42 import java.util.AbstractMap;
  43 import java.util.AbstractSet;
  44 import java.util.ArrayList;
  45 import java.util.Collection;
  46 import java.util.Collections;
  47 import java.util.Comparator;
  48 import java.util.Iterator;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.NavigableSet;
  52 import java.util.NoSuchElementException;
  53 import java.util.Set;
  54 import java.util.SortedMap;
  55 import java.util.Spliterator;
  56 import java.util.function.BiConsumer;
  57 import java.util.function.BiFunction;
  58 import java.util.function.Consumer;
  59 import java.util.function.Function;
  60 import java.util.function.Predicate;
  61 import java.util.concurrent.atomic.LongAdder;
  62 
  63 /**
  64  * A scalable concurrent {@link ConcurrentNavigableMap} implementation.
  65  * The map is sorted according to the {@linkplain Comparable natural
  66  * ordering} of its keys, or by a {@link Comparator} provided at map
  67  * creation time, depending on which constructor is used.
  68  *
  69  * &lt;p&gt;This class implements a concurrent variant of &lt;a
  70  * href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_top&quot;&gt;SkipLists&lt;/a&gt;
  71  * providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the
  72  * {@code containsKey}, {@code get}, {@code put} and
  73  * {@code remove} operations and their variants.  Insertion, removal,
  74  * update, and access operations safely execute concurrently by
  75  * multiple threads.
  76  *
  77  * &lt;p&gt;Iterators and spliterators are
  78  * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
  79  *
  80  * &lt;p&gt;Ascending key ordered views and their iterators are faster than
  81  * descending ones.
  82  *
  83  * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
  84  * and its views represent snapshots of mappings at the time they were
  85  * produced. They do &lt;em&gt;not&lt;/em&gt; support the {@code Entry.setValue}
  86  * method. (Note however that it is possible to change mappings in the
  87  * associated map using {@code put}, {@code putIfAbsent}, or
  88  * {@code replace}, depending on exactly which effect you need.)
  89  *
  90  * &lt;p&gt;Beware that bulk operations {@code putAll}, {@code equals},
  91  * {@code toArray}, {@code containsValue}, and {@code clear} are
  92  * &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an
  93  * iterator operating concurrently with a {@code putAll} operation
  94  * might view only some of the added elements.
  95  *
  96  * &lt;p&gt;This class and its views and iterators implement all of the
  97  * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}
  98  * interfaces. Like most other concurrent collections, this class does
  99  * &lt;em&gt;not&lt;/em&gt; permit the use of {@code null} keys or values because some
 100  * null return values cannot be reliably distinguished from the absence of
 101  * elements.
 102  *
 103  * &lt;p&gt;This class is a member of the
 104  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 105  * Java Collections Framework&lt;/a&gt;.
 106  *
 107  * @author Doug Lea
 108  * @param &lt;K&gt; the type of keys maintained by this map
 109  * @param &lt;V&gt; the type of mapped values
 110  * @since 1.6
 111  */
 112 public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
 113     implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable {
 114     /*
 115      * This class implements a tree-like two-dimensionally linked skip
 116      * list in which the index levels are represented in separate
 117      * nodes from the base nodes holding data.  There are two reasons
 118      * for taking this approach instead of the usual array-based
 119      * structure: 1) Array based implementations seem to encounter
 120      * more complexity and overhead 2) We can use cheaper algorithms
 121      * for the heavily-traversed index lists than can be used for the
 122      * base lists.  Here&#39;s a picture of some of the basics for a
 123      * possible list with 2 levels of index:
 124      *
 125      * Head nodes          Index nodes
 126      * +-+    right        +-+                      +-+
 127      * |2|----------------&gt;| |---------------------&gt;| |-&gt;null
 128      * +-+                 +-+                      +-+
 129      *  | down              |                        |
 130      *  v                   v                        v
 131      * +-+            +-+  +-+       +-+            +-+       +-+
 132      * |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null
 133      * +-+            +-+  +-+       +-+            +-+       +-+
 134      *  v              |    |         |              |         |
 135      * Nodes  next     v    v         v              v         v
 136      * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
 137      * | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null
 138      * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
 139      *
 140      * The base lists use a variant of the HM linked ordered set
 141      * algorithm. See Tim Harris, &quot;A pragmatic implementation of
 142      * non-blocking linked lists&quot;
 143      * http://www.cl.cam.ac.uk/~tlh20/publications.html and Maged
 144      * Michael &quot;High Performance Dynamic Lock-Free Hash Tables and
 145      * List-Based Sets&quot;
 146      * http://www.research.ibm.com/people/m/michael/pubs.htm.  The
 147      * basic idea in these lists is to mark the &quot;next&quot; pointers of
 148      * deleted nodes when deleting to avoid conflicts with concurrent
 149      * insertions, and when traversing to keep track of triples
 150      * (predecessor, node, successor) in order to detect when and how
 151      * to unlink these deleted nodes.
 152      *
 153      * Rather than using mark-bits to mark list deletions (which can
 154      * be slow and space-intensive using AtomicMarkedReference), nodes
 155      * use direct CAS&#39;able next pointers.  On deletion, instead of
 156      * marking a pointer, they splice in another node that can be
 157      * thought of as standing for a marked pointer (see method
 158      * unlinkNode).  Using plain nodes acts roughly like &quot;boxed&quot;
 159      * implementations of marked pointers, but uses new nodes only
 160      * when nodes are deleted, not for every link.  This requires less
 161      * space and supports faster traversal. Even if marked references
 162      * were better supported by JVMs, traversal using this technique
 163      * might still be faster because any search need only read ahead
 164      * one more node than otherwise required (to check for trailing
 165      * marker) rather than unmasking mark bits or whatever on each
 166      * read.
 167      *
 168      * This approach maintains the essential property needed in the HM
 169      * algorithm of changing the next-pointer of a deleted node so
 170      * that any other CAS of it will fail, but implements the idea by
 171      * changing the pointer to point to a different node (with
 172      * otherwise illegal null fields), not by marking it.  While it
 173      * would be possible to further squeeze space by defining marker
 174      * nodes not to have key/value fields, it isn&#39;t worth the extra
 175      * type-testing overhead.  The deletion markers are rarely
 176      * encountered during traversal, are easily detected via null
 177      * checks that are needed anyway, and are normally quickly garbage
 178      * collected. (Note that this technique would not work well in
 179      * systems without garbage collection.)
 180      *
 181      * In addition to using deletion markers, the lists also use
 182      * nullness of value fields to indicate deletion, in a style
 183      * similar to typical lazy-deletion schemes.  If a node&#39;s value is
 184      * null, then it is considered logically deleted and ignored even
 185      * though it is still reachable.
 186      *
 187      * Here&#39;s the sequence of events for a deletion of node n with
 188      * predecessor b and successor f, initially:
 189      *
 190      *        +------+       +------+      +------+
 191      *   ...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...
 192      *        +------+       +------+      +------+
 193      *
 194      * 1. CAS n&#39;s value field from non-null to null.
 195      *    Traversals encountering a node with null value ignore it.
 196      *    However, ongoing insertions and deletions might still modify
 197      *    n&#39;s next pointer.
 198      *
 199      * 2. CAS n&#39;s next pointer to point to a new marker node.
 200      *    From this point on, no other nodes can be appended to n.
 201      *    which avoids deletion errors in CAS-based linked lists.
 202      *
 203      *        +------+       +------+      +------+       +------+
 204      *   ...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...
 205      *        +------+       +------+      +------+       +------+
 206      *
 207      * 3. CAS b&#39;s next pointer over both n and its marker.
 208      *    From this point on, no new traversals will encounter n,
 209      *    and it can eventually be GCed.
 210      *        +------+                                    +------+
 211      *   ...  |   b  |-----------------------------------&gt;|   f  | ...
 212      *        +------+                                    +------+
 213      *
 214      * A failure at step 1 leads to simple retry due to a lost race
 215      * with another operation. Steps 2-3 can fail because some other
 216      * thread noticed during a traversal a node with null value and
 217      * helped out by marking and/or unlinking.  This helping-out
 218      * ensures that no thread can become stuck waiting for progress of
 219      * the deleting thread.
 220      *
 221      * Skip lists add indexing to this scheme, so that the base-level
 222      * traversals start close to the locations being found, inserted
 223      * or deleted -- usually base level traversals only traverse a few
 224      * nodes. This doesn&#39;t change the basic algorithm except for the
 225      * need to make sure base traversals start at predecessors (here,
 226      * b) that are not (structurally) deleted, otherwise retrying
 227      * after processing the deletion.
 228      *
 229      * Index levels are maintained using CAS to link and unlink
 230      * successors (&quot;right&quot; fields).  Races are allowed in index-list
 231      * operations that can (rarely) fail to link in a new index node.
 232      * (We can&#39;t do this of course for data nodes.)  However, even
 233      * when this happens, the index lists correctly guide search.
 234      * This can impact performance, but since skip lists are
 235      * probabilistic anyway, the net result is that under contention,
 236      * the effective &quot;p&quot; value may be lower than its nominal value.
 237      *
 238      * Index insertion and deletion sometimes require a separate
 239      * traversal pass occurring after the base-level action, to add or
 240      * remove index nodes.  This adds to single-threaded overhead, but
 241      * improves contended multithreaded performance by narrowing
 242      * interference windows, and allows deletion to ensure that all
 243      * index nodes will be made unreachable upon return from a public
 244      * remove operation, thus avoiding unwanted garbage retention.
 245      *
 246      * Indexing uses skip list parameters that maintain good search
 247      * performance while using sparser-than-usual indices: The
 248      * hardwired parameters k=1, p=0.5 (see method doPut) mean that
 249      * about one-quarter of the nodes have indices. Of those that do,
 250      * half have one level, a quarter have two, and so on (see Pugh&#39;s
 251      * Skip List Cookbook, sec 3.4), up to a maximum of 62 levels
 252      * (appropriate for up to 2^63 elements).  The expected total
 253      * space requirement for a map is slightly less than for the
 254      * current implementation of java.util.TreeMap.
 255      *
 256      * Changing the level of the index (i.e, the height of the
 257      * tree-like structure) also uses CAS.  Creation of an index with
 258      * height greater than the current level adds a level to the head
 259      * index by CAS&#39;ing on a new top-most head. To maintain good
 260      * performance after a lot of removals, deletion methods
 261      * heuristically try to reduce the height if the topmost levels
 262      * appear to be empty.  This may encounter races in which it is
 263      * possible (but rare) to reduce and &quot;lose&quot; a level just as it is
 264      * about to contain an index (that will then never be
 265      * encountered). This does no structural harm, and in practice
 266      * appears to be a better option than allowing unrestrained growth
 267      * of levels.
 268      *
 269      * This class provides concurrent-reader-style memory consistency,
 270      * ensuring that read-only methods report status and/or values no
 271      * staler than those holding at method entry. This is done by
 272      * performing all publication and structural updates using
 273      * (volatile) CAS, placing an acquireFence in a few access
 274      * methods, and ensuring that linked objects are transitively
 275      * acquired via dependent reads (normally once) unless performing
 276      * a volatile-mode CAS operation (that also acts as an acquire and
 277      * release).  This form of fence-hoisting is similar to RCU and
 278      * related techniques (see McKenney&#39;s online book
 279      * https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html)
 280      * It minimizes overhead that may otherwise occur when using so
 281      * many volatile-mode reads. Using explicit acquireFences is
 282      * logistically easier than targeting particular fields to be read
 283      * in acquire mode: fences are just hoisted up as far as possible,
 284      * to the entry points or loop headers of a few methods. A
 285      * potential disadvantage is that these few remaining fences are
 286      * not easily optimized away by compilers under exclusively
 287      * single-thread use.  It requires some care to avoid volatile
 288      * mode reads of other fields. (Note that the memory semantics of
 289      * a reference dependently read in plain mode exactly once are
 290      * equivalent to those for atomic opaque mode.)  Iterators and
 291      * other traversals encounter each node and value exactly once.
 292      * Other operations locate an element (or position to insert an
 293      * element) via a sequence of dereferences. This search is broken
 294      * into two parts. Method findPredecessor (and its specialized
 295      * embeddings) searches index nodes only, returning a base-level
 296      * predecessor of the key. Callers carry out the base-level
 297      * search, restarting if encountering a marker preventing link
 298      * modification.  In some cases, it is possible to encounter a
 299      * node multiple times while descending levels. For mutative
 300      * operations, the reported value is validated using CAS (else
 301      * retrying), preserving linearizability with respect to each
 302      * other. Others may return any (non-null) value holding in the
 303      * course of the method call.  (Search-based methods also include
 304      * some useless-looking explicit null checks designed to allow
 305      * more fields to be nulled out upon removal, to reduce floating
 306      * garbage, but which is not currently done, pending discovery of
 307      * a way to do this with less impact on other operations.)
 308      *
 309      * To produce random values without interference across threads,
 310      * we use within-JDK thread local random support (via the
 311      * &quot;secondary seed&quot;, to avoid interference with user-level
 312      * ThreadLocalRandom.)
 313      *
 314      * For explanation of algorithms sharing at least a couple of
 315      * features with this one, see Mikhail Fomitchev&#39;s thesis
 316      * (http://www.cs.yorku.ca/~mikhail/), Keir Fraser&#39;s thesis
 317      * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell&#39;s
 318      * thesis (http://www.cs.chalmers.se/~phs/).
 319      *
 320      * Notation guide for local variables
 321      * Node:         b, n, f, p for  predecessor, node, successor, aux
 322      * Index:        q, r, d    for index node, right, down.
 323      * Head:         h
 324      * Keys:         k, key
 325      * Values:       v, value
 326      * Comparisons:  c
 327      */
 328 
 329     private static final long serialVersionUID = -8627078645895051609L;
 330 
 331     /**
 332      * The comparator used to maintain order in this map, or null if
 333      * using natural ordering.  (Non-private to simplify access in
 334      * nested classes.)
 335      * @serial
 336      */
 337     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
 338     final Comparator&lt;? super K&gt; comparator;
 339 
 340     /** Lazily initialized topmost index of the skiplist. */
 341     private transient Index&lt;K,V&gt; head;
 342     /** Lazily initialized element count */
 343     private transient LongAdder adder;
 344     /** Lazily initialized key set */
 345     private transient KeySet&lt;K,V&gt; keySet;
 346     /** Lazily initialized values collection */
 347     private transient Values&lt;K,V&gt; values;
 348     /** Lazily initialized entry set */
 349     private transient EntrySet&lt;K,V&gt; entrySet;
 350     /** Lazily initialized descending map */
 351     private transient SubMap&lt;K,V&gt; descendingMap;
 352 
 353     /**
 354      * Nodes hold keys and values, and are singly linked in sorted
 355      * order, possibly with some intervening marker nodes. The list is
 356      * headed by a header node accessible as head.node. Headers and
 357      * marker nodes have null keys. The val field (but currently not
 358      * the key field) is nulled out upon deletion.
 359      */
 360     static final class Node&lt;K,V&gt; {
 361         final K key; // currently, never detached
 362         V val;
 363         Node&lt;K,V&gt; next;
 364         Node(K key, V value, Node&lt;K,V&gt; next) {
 365             this.key = key;
 366             this.val = value;
 367             this.next = next;
 368         }
 369     }
 370 
 371     /**
 372      * Index nodes represent the levels of the skip list.
 373      */
 374     static final class Index&lt;K,V&gt; {
 375         final Node&lt;K,V&gt; node;  // currently, never detached
 376         final Index&lt;K,V&gt; down;
 377         Index&lt;K,V&gt; right;
 378         Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) {
 379             this.node = node;
 380             this.down = down;
 381             this.right = right;
 382         }
 383     }
 384 
 385     /* ----------------  Utilities -------------- */
 386 
 387     /**
 388      * Compares using comparator or natural ordering if null.
 389      * Called only by methods that have performed required type checks.
 390      */
 391     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 392     static int cpr(Comparator c, Object x, Object y) {
 393         return (c != null) ? c.compare(x, y) : ((Comparable)x).compareTo(y);
 394     }
 395 
 396     /**
 397      * Returns the header for base node list, or null if uninitialized
 398      */
 399     final Node&lt;K,V&gt; baseHead() {
 400         Index&lt;K,V&gt; h;
 401         VarHandle.acquireFence();
 402         return ((h = head) == null) ? null : h.node;
 403     }
 404 
 405     /**
 406      * Tries to unlink deleted node n from predecessor b (if both
 407      * exist), by first splicing in a marker if not already present.
 408      * Upon return, node n is sure to be unlinked from b, possibly
 409      * via the actions of some other thread.
 410      *
 411      * @param b if nonnull, predecessor
 412      * @param n if nonnull, node known to be deleted
 413      */
 414     static &lt;K,V&gt; void unlinkNode(Node&lt;K,V&gt; b, Node&lt;K,V&gt; n) {
 415         if (b != null &amp;&amp; n != null) {
 416             Node&lt;K,V&gt; f, p;
 417             for (;;) {
 418                 if ((f = n.next) != null &amp;&amp; f.key == null) {
 419                     p = f.next;               // already marked
 420                     break;
 421                 }
 422                 else if (NEXT.compareAndSet(n, f,
 423                                             new Node&lt;K,V&gt;(null, null, f))) {
 424                     p = f;                    // add marker
 425                     break;
 426                 }
 427             }
 428             NEXT.compareAndSet(b, n, p);
 429         }
 430     }
 431 
 432     /**
 433      * Adds to element count, initializing adder if necessary
 434      *
 435      * @param c count to add
 436      */
 437     private void addCount(long c) {
 438         LongAdder a;
 439         do {} while ((a = adder) == null &amp;&amp;
 440                      !ADDER.compareAndSet(this, null, a = new LongAdder()));
 441         a.add(c);
 442     }
 443 
 444     /**
 445      * Returns element count, initializing adder if necessary.
 446      */
 447     final long getAdderCount() {
 448         LongAdder a; long c;
 449         do {} while ((a = adder) == null &amp;&amp;
 450                      !ADDER.compareAndSet(this, null, a = new LongAdder()));
 451         return ((c = a.sum()) &lt;= 0L) ? 0L : c; // ignore transient negatives
 452     }
 453 
 454     /* ---------------- Traversal -------------- */
 455 
 456     /**
 457      * Returns an index node with key strictly less than given key.
 458      * Also unlinks indexes to deleted nodes found along the way.
 459      * Callers rely on this side-effect of clearing indices to deleted
 460      * nodes.
 461      *
 462      * @param key if nonnull the key
 463      * @return a predecessor node of key, or null if uninitialized or null key
 464      */
 465     private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) {
 466         Index&lt;K,V&gt; q;
 467         VarHandle.acquireFence();
 468         if ((q = head) == null || key == null)
 469             return null;
 470         else {
 471             for (Index&lt;K,V&gt; r, d;;) {
 472                 while ((r = q.right) != null) {
 473                     Node&lt;K,V&gt; p; K k;
 474                     if ((p = r.node) == null || (k = p.key) == null ||
 475                         p.val == null)  // unlink index to deleted node
 476                         RIGHT.compareAndSet(q, r, r.right);
 477                     else if (cpr(cmp, key, k) &gt; 0)
 478                         q = r;
 479                     else
 480                         break;
 481                 }
 482                 if ((d = q.down) != null)
 483                     q = d;
 484                 else
 485                     return q.node;
 486             }
 487         }
 488     }
 489 
 490     /**
 491      * Returns node holding key or null if no such, clearing out any
 492      * deleted nodes seen along the way.  Repeatedly traverses at
 493      * base-level looking for key starting at predecessor returned
 494      * from findPredecessor, processing base-level deletions as
 495      * encountered. Restarts occur, at traversal step encountering
 496      * node n, if n&#39;s key field is null, indicating it is a marker, so
 497      * its predecessor is deleted before continuing, which we help do
 498      * by re-finding a valid predecessor.  The traversal loops in
 499      * doPut, doRemove, and findNear all include the same checks.
 500      *
 501      * @param key the key
 502      * @return node holding key, or null if no such
 503      */
 504     private Node&lt;K,V&gt; findNode(Object key) {
 505         if (key == null)
 506             throw new NullPointerException(); // don&#39;t postpone errors
 507         Comparator&lt;? super K&gt; cmp = comparator;
 508         Node&lt;K,V&gt; b;
 509         outer: while ((b = findPredecessor(key, cmp)) != null) {
 510             for (;;) {
 511                 Node&lt;K,V&gt; n; K k; V v; int c;
 512                 if ((n = b.next) == null)
 513                     break outer;               // empty
 514                 else if ((k = n.key) == null)
 515                     break;                     // b is deleted
 516                 else if ((v = n.val) == null)
 517                     unlinkNode(b, n);          // n is deleted
 518                 else if ((c = cpr(cmp, key, k)) &gt; 0)
 519                     b = n;
 520                 else if (c == 0)
 521                     return n;
 522                 else
 523                     break outer;
 524             }
 525         }
 526         return null;
 527     }
 528 
 529     /**
 530      * Gets value for key. Same idea as findNode, except skips over
 531      * deletions and markers, and returns first encountered value to
 532      * avoid possibly inconsistent rereads.
 533      *
 534      * @param key the key
 535      * @return the value, or null if absent
 536      */
 537     private V doGet(Object key) {
 538         Index&lt;K,V&gt; q;
 539         VarHandle.acquireFence();
 540         if (key == null)
 541             throw new NullPointerException();
 542         Comparator&lt;? super K&gt; cmp = comparator;
 543         V result = null;
 544         if ((q = head) != null) {
 545             outer: for (Index&lt;K,V&gt; r, d;;) {
 546                 while ((r = q.right) != null) {
 547                     Node&lt;K,V&gt; p; K k; V v; int c;
 548                     if ((p = r.node) == null || (k = p.key) == null ||
 549                         (v = p.val) == null)
 550                         RIGHT.compareAndSet(q, r, r.right);
 551                     else if ((c = cpr(cmp, key, k)) &gt; 0)
 552                         q = r;
 553                     else if (c == 0) {
 554                         result = v;
 555                         break outer;
 556                     }
 557                     else
 558                         break;
 559                 }
 560                 if ((d = q.down) != null)
 561                     q = d;
 562                 else {
 563                     Node&lt;K,V&gt; b, n;
 564                     if ((b = q.node) != null) {
 565                         while ((n = b.next) != null) {
 566                             V v; int c;
 567                             K k = n.key;
 568                             if ((v = n.val) == null || k == null ||
 569                                 (c = cpr(cmp, key, k)) &gt; 0)
 570                                 b = n;
 571                             else {
 572                                 if (c == 0)
 573                                     result = v;
 574                                 break;
 575                             }
 576                         }
 577                     }
 578                     break;
 579                 }
 580             }
 581         }
 582         return result;
 583     }
 584 
 585     /* ---------------- Insertion -------------- */
 586 
 587     /**
 588      * Main insertion method.  Adds element if not present, or
 589      * replaces value if present and onlyIfAbsent is false.
 590      *
 591      * @param key the key
 592      * @param value the value that must be associated with key
 593      * @param onlyIfAbsent if should not insert if already present
 594      * @return the old value, or null if newly inserted
 595      */
 596     private V doPut(K key, V value, boolean onlyIfAbsent) {
 597         if (key == null)
 598             throw new NullPointerException();
 599         Comparator&lt;? super K&gt; cmp = comparator;
 600         for (;;) {
 601             Index&lt;K,V&gt; h; Node&lt;K,V&gt; b;
 602             VarHandle.acquireFence();
 603             int levels = 0;                    // number of levels descended
 604             if ((h = head) == null) {          // try to initialize
 605                 Node&lt;K,V&gt; base = new Node&lt;K,V&gt;(null, null, null);
 606                 h = new Index&lt;K,V&gt;(base, null, null);
 607                 b = (HEAD.compareAndSet(this, null, h)) ? base : null;
 608             }
 609             else {
 610                 for (Index&lt;K,V&gt; q = h, r, d;;) { // count while descending
 611                     while ((r = q.right) != null) {
 612                         Node&lt;K,V&gt; p; K k;
 613                         if ((p = r.node) == null || (k = p.key) == null ||
 614                             p.val == null)
 615                             RIGHT.compareAndSet(q, r, r.right);
 616                         else if (cpr(cmp, key, k) &gt; 0)
 617                             q = r;
 618                         else
 619                             break;
 620                     }
 621                     if ((d = q.down) != null) {
 622                         ++levels;
 623                         q = d;
 624                     }
 625                     else {
 626                         b = q.node;
 627                         break;
 628                     }
 629                 }
 630             }
 631             if (b != null) {
 632                 Node&lt;K,V&gt; z = null;              // new node, if inserted
 633                 for (;;) {                       // find insertion point
 634                     Node&lt;K,V&gt; n, p; K k; V v; int c;
 635                     if ((n = b.next) == null) {
 636                         if (b.key == null)       // if empty, type check key now
 637                             cpr(cmp, key, key);
 638                         c = -1;
 639                     }
 640                     else if ((k = n.key) == null)
 641                         break;                   // can&#39;t append; restart
 642                     else if ((v = n.val) == null) {
 643                         unlinkNode(b, n);
 644                         c = 1;
 645                     }
 646                     else if ((c = cpr(cmp, key, k)) &gt; 0)
 647                         b = n;
 648                     else if (c == 0 &amp;&amp;
 649                              (onlyIfAbsent || VAL.compareAndSet(n, v, value)))
 650                         return v;
 651 
 652                     if (c &lt; 0 &amp;&amp;
 653                         NEXT.compareAndSet(b, n,
 654                                            p = new Node&lt;K,V&gt;(key, value, n))) {
 655                         z = p;
 656                         break;
 657                     }
 658                 }
 659 
 660                 if (z != null) {
 661                     int lr = ThreadLocalRandom.nextSecondarySeed();
 662                     if ((lr &amp; 0x3) == 0) {       // add indices with 1/4 prob
 663                         int hr = ThreadLocalRandom.nextSecondarySeed();
 664                         long rnd = ((long)hr &lt;&lt; 32) | ((long)lr &amp; 0xffffffffL);
 665                         int skips = levels;      // levels to descend before add
 666                         Index&lt;K,V&gt; x = null;
 667                         for (;;) {               // create at most 62 indices
 668                             x = new Index&lt;K,V&gt;(z, x, null);
 669                             if (rnd &gt;= 0L || --skips &lt; 0)
 670                                 break;
 671                             else
 672                                 rnd &lt;&lt;= 1;
 673                         }
 674                         if (addIndices(h, skips, x, cmp) &amp;&amp; skips &lt; 0 &amp;&amp;
 675                             head == h) {         // try to add new level
 676                             Index&lt;K,V&gt; hx = new Index&lt;K,V&gt;(z, x, null);
 677                             Index&lt;K,V&gt; nh = new Index&lt;K,V&gt;(h.node, h, hx);
 678                             HEAD.compareAndSet(this, h, nh);
 679                         }
 680                         if (z.val == null)       // deleted while adding indices
 681                             findPredecessor(key, cmp); // clean
 682                     }
 683                     addCount(1L);
 684                     return null;
 685                 }
 686             }
 687         }
 688     }
 689 
 690     /**
 691      * Add indices after an insertion. Descends iteratively to the
 692      * highest level of insertion, then recursively, to chain index
 693      * nodes to lower ones. Returns null on (staleness) failure,
 694      * disabling higher-level insertions. Recursion depths are
 695      * exponentially less probable.
 696      *
 697      * @param q starting index for current level
 698      * @param skips levels to skip before inserting
 699      * @param x index for this insertion
 700      * @param cmp comparator
 701      */
 702     static &lt;K,V&gt; boolean addIndices(Index&lt;K,V&gt; q, int skips, Index&lt;K,V&gt; x,
 703                                     Comparator&lt;? super K&gt; cmp) {
 704         Node&lt;K,V&gt; z; K key;
 705         if (x != null &amp;&amp; (z = x.node) != null &amp;&amp; (key = z.key) != null &amp;&amp;
 706             q != null) {                            // hoist checks
 707             boolean retrying = false;
 708             for (;;) {                              // find splice point
 709                 Index&lt;K,V&gt; r, d; int c;
 710                 if ((r = q.right) != null) {
 711                     Node&lt;K,V&gt; p; K k;
 712                     if ((p = r.node) == null || (k = p.key) == null ||
 713                         p.val == null) {
 714                         RIGHT.compareAndSet(q, r, r.right);
 715                         c = 0;
 716                     }
 717                     else if ((c = cpr(cmp, key, k)) &gt; 0)
 718                         q = r;
 719                     else if (c == 0)
 720                         break;                      // stale
 721                 }
 722                 else
 723                     c = -1;
 724 
 725                 if (c &lt; 0) {
 726                     if ((d = q.down) != null &amp;&amp; skips &gt; 0) {
 727                         --skips;
 728                         q = d;
 729                     }
 730                     else if (d != null &amp;&amp; !retrying &amp;&amp;
 731                              !addIndices(d, 0, x.down, cmp))
 732                         break;
 733                     else {
 734                         x.right = r;
 735                         if (RIGHT.compareAndSet(q, r, x))
 736                             return true;
 737                         else
 738                             retrying = true;         // re-find splice point
 739                     }
 740                 }
 741             }
 742         }
 743         return false;
 744     }
 745 
 746     /* ---------------- Deletion -------------- */
 747 
 748     /**
 749      * Main deletion method. Locates node, nulls value, appends a
 750      * deletion marker, unlinks predecessor, removes associated index
 751      * nodes, and possibly reduces head index level.
 752      *
 753      * @param key the key
 754      * @param value if non-null, the value that must be
 755      * associated with key
 756      * @return the node, or null if not found
 757      */
 758     final V doRemove(Object key, Object value) {
 759         if (key == null)
 760             throw new NullPointerException();
 761         Comparator&lt;? super K&gt; cmp = comparator;
 762         V result = null;
 763         Node&lt;K,V&gt; b;
 764         outer: while ((b = findPredecessor(key, cmp)) != null &amp;&amp;
 765                       result == null) {
 766             for (;;) {
 767                 Node&lt;K,V&gt; n; K k; V v; int c;
 768                 if ((n = b.next) == null)
 769                     break outer;
 770                 else if ((k = n.key) == null)
 771                     break;
 772                 else if ((v = n.val) == null)
 773                     unlinkNode(b, n);
 774                 else if ((c = cpr(cmp, key, k)) &gt; 0)
 775                     b = n;
 776                 else if (c &lt; 0)
 777                     break outer;
 778                 else if (value != null &amp;&amp; !value.equals(v))
 779                     break outer;
 780                 else if (VAL.compareAndSet(n, v, null)) {
 781                     result = v;
 782                     unlinkNode(b, n);
 783                     break; // loop to clean up
 784                 }
 785             }
 786         }
 787         if (result != null) {
 788             tryReduceLevel();
 789             addCount(-1L);
 790         }
 791         return result;
 792     }
 793 
 794     /**
 795      * Possibly reduce head level if it has no nodes.  This method can
 796      * (rarely) make mistakes, in which case levels can disappear even
 797      * though they are about to contain index nodes. This impacts
 798      * performance, not correctness.  To minimize mistakes as well as
 799      * to reduce hysteresis, the level is reduced by one only if the
 800      * topmost three levels look empty. Also, if the removed level
 801      * looks non-empty after CAS, we try to change it back quick
 802      * before anyone notices our mistake! (This trick works pretty
 803      * well because this method will practically never make mistakes
 804      * unless current thread stalls immediately before first CAS, in
 805      * which case it is very unlikely to stall again immediately
 806      * afterwards, so will recover.)
 807      *
 808      * We put up with all this rather than just let levels grow
 809      * because otherwise, even a small map that has undergone a large
 810      * number of insertions and removals will have a lot of levels,
 811      * slowing down access more than would an occasional unwanted
 812      * reduction.
 813      */
 814     private void tryReduceLevel() {
 815         Index&lt;K,V&gt; h, d, e;
 816         if ((h = head) != null &amp;&amp; h.right == null &amp;&amp;
 817             (d = h.down) != null &amp;&amp; d.right == null &amp;&amp;
 818             (e = d.down) != null &amp;&amp; e.right == null &amp;&amp;
 819             HEAD.compareAndSet(this, h, d) &amp;&amp;
 820             h.right != null)   // recheck
 821             HEAD.compareAndSet(this, d, h);  // try to backout
 822     }
 823 
 824     /* ---------------- Finding and removing first element -------------- */
 825 
 826     /**
 827      * Gets first valid node, unlinking deleted nodes if encountered.
 828      * @return first node or null if empty
 829      */
 830     final Node&lt;K,V&gt; findFirst() {
 831         Node&lt;K,V&gt; b, n;
 832         if ((b = baseHead()) != null) {
 833             while ((n = b.next) != null) {
 834                 if (n.val == null)
 835                     unlinkNode(b, n);
 836                 else
 837                     return n;
 838             }
 839         }
 840         return null;
 841     }
 842 
 843     /**
 844      * Entry snapshot version of findFirst
 845      */
 846     final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; findFirstEntry() {
 847         Node&lt;K,V&gt; b, n; V v;
 848         if ((b = baseHead()) != null) {
 849             while ((n = b.next) != null) {
 850                 if ((v = n.val) == null)
 851                     unlinkNode(b, n);
 852                 else
 853                     return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
 854             }
 855         }
 856         return null;
 857     }
 858 
 859     /**
 860      * Removes first entry; returns its snapshot.
 861      * @return null if empty, else snapshot of first entry
 862      */
 863     private AbstractMap.SimpleImmutableEntry&lt;K,V&gt; doRemoveFirstEntry() {
 864         Node&lt;K,V&gt; b, n; V v;
 865         if ((b = baseHead()) != null) {
 866             while ((n = b.next) != null) {
 867                 if ((v = n.val) == null || VAL.compareAndSet(n, v, null)) {
 868                     K k = n.key;
 869                     unlinkNode(b, n);
 870                     if (v != null) {
 871                         tryReduceLevel();
 872                         findPredecessor(k, comparator); // clean index
 873                         addCount(-1L);
 874                         return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
 875                     }
 876                 }
 877             }
 878         }
 879         return null;
 880     }
 881 
 882     /* ---------------- Finding and removing last element -------------- */
 883 
 884     /**
 885      * Specialized version of find to get last valid node.
 886      * @return last node or null if empty
 887      */
 888     final Node&lt;K,V&gt; findLast() {
 889         outer: for (;;) {
 890             Index&lt;K,V&gt; q; Node&lt;K,V&gt; b;
 891             VarHandle.acquireFence();
 892             if ((q = head) == null)
 893                 break;
 894             for (Index&lt;K,V&gt; r, d;;) {
 895                 while ((r = q.right) != null) {
 896                     Node&lt;K,V&gt; p;
 897                     if ((p = r.node) == null || p.val == null)
 898                         RIGHT.compareAndSet(q, r, r.right);
 899                     else
 900                         q = r;
 901                 }
 902                 if ((d = q.down) != null)
 903                     q = d;
 904                 else {
 905                     b = q.node;
 906                     break;
 907                 }
 908             }
 909             if (b != null) {
 910                 for (;;) {
 911                     Node&lt;K,V&gt; n;
 912                     if ((n = b.next) == null) {
 913                         if (b.key == null) // empty
 914                             break outer;
 915                         else
 916                             return b;
 917                     }
 918                     else if (n.key == null)
 919                         break;
 920                     else if (n.val == null)
 921                         unlinkNode(b, n);
 922                     else
 923                         b = n;
 924                 }
 925             }
 926         }
 927         return null;
 928     }
 929 
 930     /**
 931      * Entry version of findLast
 932      * @return Entry for last node or null if empty
 933      */
 934     final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; findLastEntry() {
 935         for (;;) {
 936             Node&lt;K,V&gt; n; V v;
 937             if ((n = findLast()) == null)
 938                 return null;
 939             if ((v = n.val) != null)
 940                 return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
 941         }
 942     }
 943 
 944     /**
 945      * Removes last entry; returns its snapshot.
 946      * Specialized variant of doRemove.
 947      * @return null if empty, else snapshot of last entry
 948      */
 949     private Map.Entry&lt;K,V&gt; doRemoveLastEntry() {
 950         outer: for (;;) {
 951             Index&lt;K,V&gt; q; Node&lt;K,V&gt; b;
 952             VarHandle.acquireFence();
 953             if ((q = head) == null)
 954                 break;
 955             for (;;) {
 956                 Index&lt;K,V&gt; d, r; Node&lt;K,V&gt; p;
 957                 while ((r = q.right) != null) {
 958                     if ((p = r.node) == null || p.val == null)
 959                         RIGHT.compareAndSet(q, r, r.right);
 960                     else if (p.next != null)
 961                         q = r;  // continue only if a successor
 962                     else
 963                         break;
 964                 }
 965                 if ((d = q.down) != null)
 966                     q = d;
 967                 else {
 968                     b = q.node;
 969                     break;
 970                 }
 971             }
 972             if (b != null) {
 973                 for (;;) {
 974                     Node&lt;K,V&gt; n; K k; V v;
 975                     if ((n = b.next) == null) {
 976                         if (b.key == null) // empty
 977                             break outer;
 978                         else
 979                             break; // retry
 980                     }
 981                     else if ((k = n.key) == null)
 982                         break;
 983                     else if ((v = n.val) == null)
 984                         unlinkNode(b, n);
 985                     else if (n.next != null)
 986                         b = n;
 987                     else if (VAL.compareAndSet(n, v, null)) {
 988                         unlinkNode(b, n);
 989                         tryReduceLevel();
 990                         findPredecessor(k, comparator); // clean index
 991                         addCount(-1L);
 992                         return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
 993                     }
 994                 }
 995             }
 996         }
 997         return null;
 998     }
 999 
1000     /* ---------------- Relational operations -------------- */
1001 
1002     // Control values OR&#39;ed as arguments to findNear
1003 
1004     private static final int EQ = 1;
1005     private static final int LT = 2;
1006     private static final int GT = 0; // Actually checked as !LT
1007 
1008     /**
1009      * Utility for ceiling, floor, lower, higher methods.
1010      * @param key the key
1011      * @param rel the relation -- OR&#39;ed combination of EQ, LT, GT
1012      * @return nearest node fitting relation, or null if no such
1013      */
1014     final Node&lt;K,V&gt; findNear(K key, int rel, Comparator&lt;? super K&gt; cmp) {
1015         if (key == null)
1016             throw new NullPointerException();
1017         Node&lt;K,V&gt; result;
1018         outer: for (Node&lt;K,V&gt; b;;) {
1019             if ((b = findPredecessor(key, cmp)) == null) {
1020                 result = null;
1021                 break;                   // empty
1022             }
1023             for (;;) {
1024                 Node&lt;K,V&gt; n; K k; int c;
1025                 if ((n = b.next) == null) {
1026                     result = ((rel &amp; LT) != 0 &amp;&amp; b.key != null) ? b : null;
1027                     break outer;
1028                 }
1029                 else if ((k = n.key) == null)
1030                     break;
1031                 else if (n.val == null)
1032                     unlinkNode(b, n);
1033                 else if (((c = cpr(cmp, key, k)) == 0 &amp;&amp; (rel &amp; EQ) != 0) ||
1034                          (c &lt; 0 &amp;&amp; (rel &amp; LT) == 0)) {
1035                     result = n;
1036                     break outer;
1037                 }
1038                 else if (c &lt;= 0 &amp;&amp; (rel &amp; LT) != 0) {
1039                     result = (b.key != null) ? b : null;
1040                     break outer;
1041                 }
1042                 else
1043                     b = n;
1044             }
1045         }
1046         return result;
1047     }
1048 
1049     /**
1050      * Variant of findNear returning SimpleImmutableEntry
1051      * @param key the key
1052      * @param rel the relation -- OR&#39;ed combination of EQ, LT, GT
1053      * @return Entry fitting relation, or null if no such
1054      */
1055     final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; findNearEntry(K key, int rel,
1056                                                               Comparator&lt;? super K&gt; cmp) {
1057         for (;;) {
1058             Node&lt;K,V&gt; n; V v;
1059             if ((n = findNear(key, rel, cmp)) == null)
1060                 return null;
1061             if ((v = n.val) != null)
1062                 return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
1063         }
1064     }
1065 
1066     /* ---------------- Constructors -------------- */
1067 
1068     /**
1069      * Constructs a new, empty map, sorted according to the
1070      * {@linkplain Comparable natural ordering} of the keys.
1071      */
1072     public ConcurrentSkipListMap() {
1073         this.comparator = null;
1074     }
1075 
1076     /**
1077      * Constructs a new, empty map, sorted according to the specified
1078      * comparator.
1079      *
1080      * @param comparator the comparator that will be used to order this map.
1081      *        If {@code null}, the {@linkplain Comparable natural
1082      *        ordering} of the keys will be used.
1083      */
1084     public ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) {
1085         this.comparator = comparator;
1086     }
1087 
1088     /**
1089      * Constructs a new map containing the same mappings as the given map,
1090      * sorted according to the {@linkplain Comparable natural ordering} of
1091      * the keys.
1092      *
1093      * @param  m the map whose mappings are to be placed in this map
1094      * @throws ClassCastException if the keys in {@code m} are not
1095      *         {@link Comparable}, or are not mutually comparable
1096      * @throws NullPointerException if the specified map or any of its keys
1097      *         or values are null
1098      */
1099     public ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m) {
1100         this.comparator = null;
1101         putAll(m);
1102     }
1103 
1104     /**
1105      * Constructs a new map containing the same mappings and using the
1106      * same ordering as the specified sorted map.
1107      *
1108      * @param m the sorted map whose mappings are to be placed in this
1109      *        map, and whose comparator is to be used to sort this map
1110      * @throws NullPointerException if the specified sorted map or any of
1111      *         its keys or values are null
1112      */
1113     public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) {
1114         this.comparator = m.comparator();
1115         buildFromSorted(m); // initializes transients
1116     }
1117 
1118     /**
1119      * Returns a shallow copy of this {@code ConcurrentSkipListMap}
1120      * instance. (The keys and values themselves are not cloned.)
1121      *
1122      * @return a shallow copy of this map
1123      */
1124     public ConcurrentSkipListMap&lt;K,V&gt; clone() {
1125         try {
1126             @SuppressWarnings(&quot;unchecked&quot;)
1127             ConcurrentSkipListMap&lt;K,V&gt; clone =
1128                 (ConcurrentSkipListMap&lt;K,V&gt;) super.clone();
1129             clone.keySet = null;
1130             clone.entrySet = null;
1131             clone.values = null;
1132             clone.descendingMap = null;
1133             clone.adder = null;
1134             clone.buildFromSorted(this);
1135             return clone;
1136         } catch (CloneNotSupportedException e) {
1137             throw new InternalError();
1138         }
1139     }
1140 
1141     /**
1142      * Streamlined bulk insertion to initialize from elements of
1143      * given sorted map.  Call only from constructor or clone
1144      * method.
1145      */
1146     private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) {
1147         if (map == null)
1148             throw new NullPointerException();
1149         Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it =
1150             map.entrySet().iterator();
1151 
1152         /*
1153          * Add equally spaced indices at log intervals, using the bits
1154          * of count during insertion. The maximum possible resulting
1155          * level is less than the number of bits in a long (64). The
1156          * preds array tracks the current rightmost node at each
1157          * level.
1158          */
1159         @SuppressWarnings(&quot;unchecked&quot;)
1160         Index&lt;K,V&gt;[] preds = (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[64];
1161         Node&lt;K,V&gt; bp = new Node&lt;K,V&gt;(null, null, null);
1162         Index&lt;K,V&gt; h = preds[0] = new Index&lt;K,V&gt;(bp, null, null);
1163         long count = 0;
1164 
1165         while (it.hasNext()) {
1166             Map.Entry&lt;? extends K, ? extends V&gt; e = it.next();
1167             K k = e.getKey();
1168             V v = e.getValue();
1169             if (k == null || v == null)
1170                 throw new NullPointerException();
1171             Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null);
1172             bp = bp.next = z;
1173             if ((++count &amp; 3L) == 0L) {
1174                 long m = count &gt;&gt;&gt; 2;
1175                 int i = 0;
1176                 Index&lt;K,V&gt; idx = null, q;
1177                 do {
1178                     idx = new Index&lt;K,V&gt;(z, idx, null);
1179                     if ((q = preds[i]) == null)
1180                         preds[i] = h = new Index&lt;K,V&gt;(h.node, h, idx);
1181                     else
1182                         preds[i] = q.right = idx;
1183                 } while (++i &lt; preds.length &amp;&amp; ((m &gt;&gt;&gt;= 1) &amp; 1L) != 0L);
1184             }
1185         }
1186         if (count != 0L) {
1187             VarHandle.releaseFence(); // emulate volatile stores
1188             addCount(count);
1189             head = h;
1190             VarHandle.fullFence();
1191         }
1192     }
1193 
1194     /* ---------------- Serialization -------------- */
1195 
1196     /**
1197      * Saves this map to a stream (that is, serializes it).
1198      *
1199      * @param s the stream
1200      * @throws java.io.IOException if an I/O error occurs
1201      * @serialData The key (Object) and value (Object) for each
1202      * key-value mapping represented by the map, followed by
1203      * {@code null}. The key-value mappings are emitted in key-order
1204      * (as determined by the Comparator, or by the keys&#39; natural
1205      * ordering if no Comparator).
1206      */
1207     private void writeObject(java.io.ObjectOutputStream s)
1208         throws java.io.IOException {
1209         // Write out the Comparator and any hidden stuff
1210         s.defaultWriteObject();
1211 
1212         // Write out keys and values (alternating)
1213         Node&lt;K,V&gt; b, n; V v;
1214         if ((b = baseHead()) != null) {
1215             while ((n = b.next) != null) {
1216                 if ((v = n.val) != null) {
1217                     s.writeObject(n.key);
1218                     s.writeObject(v);
1219                 }
1220                 b = n;
1221             }
1222         }
1223         s.writeObject(null);
1224     }
1225 
1226     /**
1227      * Reconstitutes this map from a stream (that is, deserializes it).
1228      * @param s the stream
1229      * @throws ClassNotFoundException if the class of a serialized object
1230      *         could not be found
1231      * @throws java.io.IOException if an I/O error occurs
1232      */
1233     @SuppressWarnings(&quot;unchecked&quot;)
1234     private void readObject(final java.io.ObjectInputStream s)
1235         throws java.io.IOException, ClassNotFoundException {
1236         // Read in the Comparator and any hidden stuff
1237         s.defaultReadObject();
1238 
1239         // Same idea as buildFromSorted
1240         @SuppressWarnings(&quot;unchecked&quot;)
1241         Index&lt;K,V&gt;[] preds = (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[64];
1242         Node&lt;K,V&gt; bp = new Node&lt;K,V&gt;(null, null, null);
1243         Index&lt;K,V&gt; h = preds[0] = new Index&lt;K,V&gt;(bp, null, null);
1244         Comparator&lt;? super K&gt; cmp = comparator;
1245         K prevKey = null;
1246         long count = 0;
1247 
1248         for (;;) {
1249             K k = (K)s.readObject();
1250             if (k == null)
1251                 break;
1252             V v = (V)s.readObject();
1253             if (v == null)
1254                 throw new NullPointerException();
1255             if (prevKey != null &amp;&amp; cpr(cmp, prevKey, k) &gt; 0)
1256                 throw new IllegalStateException(&quot;out of order&quot;);
1257             prevKey = k;
1258             Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null);
1259             bp = bp.next = z;
1260             if ((++count &amp; 3L) == 0L) {
1261                 long m = count &gt;&gt;&gt; 2;
1262                 int i = 0;
1263                 Index&lt;K,V&gt; idx = null, q;
1264                 do {
1265                     idx = new Index&lt;K,V&gt;(z, idx, null);
1266                     if ((q = preds[i]) == null)
1267                         preds[i] = h = new Index&lt;K,V&gt;(h.node, h, idx);
1268                     else
1269                         preds[i] = q.right = idx;
1270                 } while (++i &lt; preds.length &amp;&amp; ((m &gt;&gt;&gt;= 1) &amp; 1L) != 0L);
1271             }
1272         }
1273         if (count != 0L) {
1274             VarHandle.releaseFence();
1275             addCount(count);
1276             head = h;
1277             VarHandle.fullFence();
1278         }
1279     }
1280 
1281     /* ------ Map API methods ------ */
1282 
1283     /**
1284      * Returns {@code true} if this map contains a mapping for the specified
1285      * key.
1286      *
1287      * @param key key whose presence in this map is to be tested
1288      * @return {@code true} if this map contains a mapping for the specified key
1289      * @throws ClassCastException if the specified key cannot be compared
1290      *         with the keys currently in the map
1291      * @throws NullPointerException if the specified key is null
1292      */
1293     public boolean containsKey(Object key) {
1294         return doGet(key) != null;
1295     }
1296 
1297     /**
1298      * Returns the value to which the specified key is mapped,
1299      * or {@code null} if this map contains no mapping for the key.
1300      *
1301      * &lt;p&gt;More formally, if this map contains a mapping from a key
1302      * {@code k} to a value {@code v} such that {@code key} compares
1303      * equal to {@code k} according to the map&#39;s ordering, then this
1304      * method returns {@code v}; otherwise it returns {@code null}.
1305      * (There can be at most one such mapping.)
1306      *
1307      * @throws ClassCastException if the specified key cannot be compared
1308      *         with the keys currently in the map
1309      * @throws NullPointerException if the specified key is null
1310      */
1311     public V get(Object key) {
1312         return doGet(key);
1313     }
1314 
1315     /**
1316      * Returns the value to which the specified key is mapped,
1317      * or the given defaultValue if this map contains no mapping for the key.
1318      *
1319      * @param key the key
1320      * @param defaultValue the value to return if this map contains
1321      * no mapping for the given key
1322      * @return the mapping for the key, if present; else the defaultValue
1323      * @throws NullPointerException if the specified key is null
1324      * @since 1.8
1325      */
1326     public V getOrDefault(Object key, V defaultValue) {
1327         V v;
1328         return (v = doGet(key)) == null ? defaultValue : v;
1329     }
1330 
1331     /**
1332      * Associates the specified value with the specified key in this map.
1333      * If the map previously contained a mapping for the key, the old
1334      * value is replaced.
1335      *
1336      * @param key key with which the specified value is to be associated
1337      * @param value value to be associated with the specified key
1338      * @return the previous value associated with the specified key, or
1339      *         {@code null} if there was no mapping for the key
1340      * @throws ClassCastException if the specified key cannot be compared
1341      *         with the keys currently in the map
1342      * @throws NullPointerException if the specified key or value is null
1343      */
1344     public V put(K key, V value) {
1345         if (value == null)
1346             throw new NullPointerException();
1347         return doPut(key, value, false);
1348     }
1349 
1350     /**
1351      * Removes the mapping for the specified key from this map if present.
1352      *
1353      * @param  key key for which mapping should be removed
1354      * @return the previous value associated with the specified key, or
1355      *         {@code null} if there was no mapping for the key
1356      * @throws ClassCastException if the specified key cannot be compared
1357      *         with the keys currently in the map
1358      * @throws NullPointerException if the specified key is null
1359      */
1360     public V remove(Object key) {
1361         return doRemove(key, null);
1362     }
1363 
1364     /**
1365      * Returns {@code true} if this map maps one or more keys to the
1366      * specified value.  This operation requires time linear in the
1367      * map size. Additionally, it is possible for the map to change
1368      * during execution of this method, in which case the returned
1369      * result may be inaccurate.
1370      *
1371      * @param value value whose presence in this map is to be tested
1372      * @return {@code true} if a mapping to {@code value} exists;
1373      *         {@code false} otherwise
1374      * @throws NullPointerException if the specified value is null
1375      */
1376     public boolean containsValue(Object value) {
1377         if (value == null)
1378             throw new NullPointerException();
1379         Node&lt;K,V&gt; b, n; V v;
1380         if ((b = baseHead()) != null) {
1381             while ((n = b.next) != null) {
1382                 if ((v = n.val) != null &amp;&amp; value.equals(v))
1383                     return true;
1384                 else
1385                     b = n;
1386             }
1387         }
1388         return false;
1389     }
1390 
1391     /**
1392      * {@inheritDoc}
1393      */
1394     public int size() {
1395         long c;
1396         return ((baseHead() == null) ? 0 :
1397                 ((c = getAdderCount()) &gt;= Integer.MAX_VALUE) ?
1398                 Integer.MAX_VALUE : (int) c);
1399     }
1400 
1401     /**
1402      * {@inheritDoc}
1403      */
1404     public boolean isEmpty() {
1405         return findFirst() == null;
1406     }
1407 
1408     /**
1409      * Removes all of the mappings from this map.
1410      */
1411     public void clear() {
1412         Index&lt;K,V&gt; h, r, d; Node&lt;K,V&gt; b;
1413         VarHandle.acquireFence();
1414         while ((h = head) != null) {
1415             if ((r = h.right) != null)        // remove indices
1416                 RIGHT.compareAndSet(h, r, null);
1417             else if ((d = h.down) != null)    // remove levels
1418                 HEAD.compareAndSet(this, h, d);
1419             else {
1420                 long count = 0L;
1421                 if ((b = h.node) != null) {    // remove nodes
1422                     Node&lt;K,V&gt; n; V v;
1423                     while ((n = b.next) != null) {
1424                         if ((v = n.val) != null &amp;&amp;
1425                             VAL.compareAndSet(n, v, null)) {
1426                             --count;
1427                             v = null;
1428                         }
1429                         if (v == null)
1430                             unlinkNode(b, n);
1431                     }
1432                 }
1433                 if (count != 0L)
1434                     addCount(count);
1435                 else
1436                     break;
1437             }
1438         }
1439     }
1440 
1441     /**
1442      * If the specified key is not already associated with a value,
1443      * attempts to compute its value using the given mapping function
1444      * and enters it into this map unless {@code null}.  The function
1445      * is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only
1446      * if the value is not present.
1447      *
1448      * @param key key with which the specified value is to be associated
1449      * @param mappingFunction the function to compute a value
1450      * @return the current (existing or computed) value associated with
1451      *         the specified key, or null if the computed value is null
1452      * @throws NullPointerException if the specified key is null
1453      *         or the mappingFunction is null
1454      * @since 1.8
1455      */
1456     public V computeIfAbsent(K key,
1457                              Function&lt;? super K, ? extends V&gt; mappingFunction) {
1458         if (key == null || mappingFunction == null)
1459             throw new NullPointerException();
1460         V v, p, r;
1461         if ((v = doGet(key)) == null &amp;&amp;
1462             (r = mappingFunction.apply(key)) != null)
1463             v = (p = doPut(key, r, true)) == null ? r : p;
1464         return v;
1465     }
1466 
1467     /**
1468      * If the value for the specified key is present, attempts to
1469      * compute a new mapping given the key and its current mapped
1470      * value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied
1471      * once atomically.
1472      *
1473      * @param key key with which a value may be associated
1474      * @param remappingFunction the function to compute a value
1475      * @return the new value associated with the specified key, or null if none
1476      * @throws NullPointerException if the specified key is null
1477      *         or the remappingFunction is null
1478      * @since 1.8
1479      */
1480     public V computeIfPresent(K key,
1481                               BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1482         if (key == null || remappingFunction == null)
1483             throw new NullPointerException();
1484         Node&lt;K,V&gt; n; V v;
1485         while ((n = findNode(key)) != null) {
1486             if ((v = n.val) != null) {
1487                 V r = remappingFunction.apply(key, v);
1488                 if (r != null) {
1489                     if (VAL.compareAndSet(n, v, r))
1490                         return r;
1491                 }
1492                 else if (doRemove(key, v) != null)
1493                     break;
1494             }
1495         }
1496         return null;
1497     }
1498 
1499     /**
1500      * Attempts to compute a mapping for the specified key and its
1501      * current mapped value (or {@code null} if there is no current
1502      * mapping). The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied
1503      * once atomically.
1504      *
1505      * @param key key with which the specified value is to be associated
1506      * @param remappingFunction the function to compute a value
1507      * @return the new value associated with the specified key, or null if none
1508      * @throws NullPointerException if the specified key is null
1509      *         or the remappingFunction is null
1510      * @since 1.8
1511      */
1512     public V compute(K key,
1513                      BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1514         if (key == null || remappingFunction == null)
1515             throw new NullPointerException();
1516         for (;;) {
1517             Node&lt;K,V&gt; n; V v; V r;
1518             if ((n = findNode(key)) == null) {
1519                 if ((r = remappingFunction.apply(key, null)) == null)
1520                     break;
1521                 if (doPut(key, r, true) == null)
1522                     return r;
1523             }
1524             else if ((v = n.val) != null) {
1525                 if ((r = remappingFunction.apply(key, v)) != null) {
1526                     if (VAL.compareAndSet(n, v, r))
1527                         return r;
1528                 }
1529                 else if (doRemove(key, v) != null)
1530                     break;
1531             }
1532         }
1533         return null;
1534     }
1535 
1536     /**
1537      * If the specified key is not already associated with a value,
1538      * associates it with the given value.  Otherwise, replaces the
1539      * value with the results of the given remapping function, or
1540      * removes if {@code null}. The function is &lt;em&gt;NOT&lt;/em&gt;
1541      * guaranteed to be applied once atomically.
1542      *
1543      * @param key key with which the specified value is to be associated
1544      * @param value the value to use if absent
1545      * @param remappingFunction the function to recompute a value if present
1546      * @return the new value associated with the specified key, or null if none
1547      * @throws NullPointerException if the specified key or value is null
1548      *         or the remappingFunction is null
1549      * @since 1.8
1550      */
1551     public V merge(K key, V value,
1552                    BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
1553         if (key == null || value == null || remappingFunction == null)
1554             throw new NullPointerException();
1555         for (;;) {
1556             Node&lt;K,V&gt; n; V v; V r;
1557             if ((n = findNode(key)) == null) {
1558                 if (doPut(key, value, true) == null)
1559                     return value;
1560             }
1561             else if ((v = n.val) != null) {
1562                 if ((r = remappingFunction.apply(v, value)) != null) {
1563                     if (VAL.compareAndSet(n, v, r))
1564                         return r;
1565                 }
1566                 else if (doRemove(key, v) != null)
1567                     return null;
1568             }
1569         }
1570     }
1571 
1572     /* ---------------- View methods -------------- */
1573 
1574     /*
1575      * Note: Lazy initialization works for views because view classes
1576      * are stateless/immutable so it doesn&#39;t matter wrt correctness if
1577      * more than one is created (which will only rarely happen).  Even
1578      * so, the following idiom conservatively ensures that the method
1579      * returns the one it created if it does so, not one created by
1580      * another racing thread.
1581      */
1582 
1583     /**
1584      * Returns a {@link NavigableSet} view of the keys contained in this map.
1585      *
1586      * &lt;p&gt;The set&#39;s iterator returns the keys in ascending order.
1587      * The set&#39;s spliterator additionally reports {@link Spliterator#CONCURRENT},
1588      * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and
1589      * {@link Spliterator#ORDERED}, with an encounter order that is ascending
1590      * key order.
1591      *
1592      * &lt;p&gt;The {@linkplain Spliterator#getComparator() spliterator&#39;s comparator}
1593      * is {@code null} if the {@linkplain #comparator() map&#39;s comparator}
1594      * is {@code null}.
1595      * Otherwise, the spliterator&#39;s comparator is the same as or imposes the
1596      * same total ordering as the map&#39;s comparator.
1597      *
1598      * &lt;p&gt;The set is backed by the map, so changes to the map are
1599      * reflected in the set, and vice-versa.  The set supports element
1600      * removal, which removes the corresponding mapping from the map,
1601      * via the {@code Iterator.remove}, {@code Set.remove},
1602      * {@code removeAll}, {@code retainAll}, and {@code clear}
1603      * operations.  It does not support the {@code add} or {@code addAll}
1604      * operations.
1605      *
1606      * &lt;p&gt;The view&#39;s iterators and spliterators are
1607      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
1608      *
1609      * &lt;p&gt;This method is equivalent to method {@code navigableKeySet}.
1610      *
1611      * @return a navigable set view of the keys in this map
1612      */
1613     public NavigableSet&lt;K&gt; keySet() {
1614         KeySet&lt;K,V&gt; ks;
1615         if ((ks = keySet) != null) return ks;
1616         return keySet = new KeySet&lt;&gt;(this);
1617     }
1618 
1619     public NavigableSet&lt;K&gt; navigableKeySet() {
1620         KeySet&lt;K,V&gt; ks;
1621         if ((ks = keySet) != null) return ks;
1622         return keySet = new KeySet&lt;&gt;(this);
1623     }
1624 
1625     /**
1626      * Returns a {@link Collection} view of the values contained in this map.
1627      * &lt;p&gt;The collection&#39;s iterator returns the values in ascending order
1628      * of the corresponding keys. The collections&#39;s spliterator additionally
1629      * reports {@link Spliterator#CONCURRENT}, {@link Spliterator#NONNULL} and
1630      * {@link Spliterator#ORDERED}, with an encounter order that is ascending
1631      * order of the corresponding keys.
1632      *
1633      * &lt;p&gt;The collection is backed by the map, so changes to the map are
1634      * reflected in the collection, and vice-versa.  The collection
1635      * supports element removal, which removes the corresponding
1636      * mapping from the map, via the {@code Iterator.remove},
1637      * {@code Collection.remove}, {@code removeAll},
1638      * {@code retainAll} and {@code clear} operations.  It does not
1639      * support the {@code add} or {@code addAll} operations.
1640      *
1641      * &lt;p&gt;The view&#39;s iterators and spliterators are
1642      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
1643      */
1644     public Collection&lt;V&gt; values() {
1645         Values&lt;K,V&gt; vs;
1646         if ((vs = values) != null) return vs;
1647         return values = new Values&lt;&gt;(this);
1648     }
1649 
1650     /**
1651      * Returns a {@link Set} view of the mappings contained in this map.
1652      *
1653      * &lt;p&gt;The set&#39;s iterator returns the entries in ascending key order.  The
1654      * set&#39;s spliterator additionally reports {@link Spliterator#CONCURRENT},
1655      * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and
1656      * {@link Spliterator#ORDERED}, with an encounter order that is ascending
1657      * key order.
1658      *
1659      * &lt;p&gt;The set is backed by the map, so changes to the map are
1660      * reflected in the set, and vice-versa.  The set supports element
1661      * removal, which removes the corresponding mapping from the map,
1662      * via the {@code Iterator.remove}, {@code Set.remove},
1663      * {@code removeAll}, {@code retainAll} and {@code clear}
1664      * operations.  It does not support the {@code add} or
1665      * {@code addAll} operations.
1666      *
1667      * &lt;p&gt;The view&#39;s iterators and spliterators are
1668      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
1669      *
1670      * &lt;p&gt;The {@code Map.Entry} elements traversed by the {@code iterator}
1671      * or {@code spliterator} do &lt;em&gt;not&lt;/em&gt; support the {@code setValue}
1672      * operation.
1673      *
1674      * @return a set view of the mappings contained in this map,
1675      *         sorted in ascending key order
1676      */
1677     public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1678         EntrySet&lt;K,V&gt; es;
1679         if ((es = entrySet) != null) return es;
1680         return entrySet = new EntrySet&lt;K,V&gt;(this);
1681     }
1682 
1683     public ConcurrentNavigableMap&lt;K,V&gt; descendingMap() {
1684         ConcurrentNavigableMap&lt;K,V&gt; dm;
1685         if ((dm = descendingMap) != null) return dm;
1686         return descendingMap =
1687             new SubMap&lt;K,V&gt;(this, null, false, null, false, true);
1688     }
1689 
1690     public NavigableSet&lt;K&gt; descendingKeySet() {
1691         return descendingMap().navigableKeySet();
1692     }
1693 
1694     /* ---------------- AbstractMap Overrides -------------- */
1695 
1696     /**
1697      * Compares the specified object with this map for equality.
1698      * Returns {@code true} if the given object is also a map and the
1699      * two maps represent the same mappings.  More formally, two maps
1700      * {@code m1} and {@code m2} represent the same mappings if
1701      * {@code m1.entrySet().equals(m2.entrySet())}.  This
1702      * operation may return misleading results if either map is
1703      * concurrently modified during execution of this method.
1704      *
1705      * @param o object to be compared for equality with this map
1706      * @return {@code true} if the specified object is equal to this map
1707      */
1708     public boolean equals(Object o) {
1709         if (o == this)
1710             return true;
1711         if (!(o instanceof Map))
1712             return false;
1713         Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;
1714         try {
1715             Comparator&lt;? super K&gt; cmp = comparator;
1716             // See JDK-8223553 for Iterator type wildcard rationale
1717             Iterator&lt;? extends Map.Entry&lt;?,?&gt;&gt; it = m.entrySet().iterator();
1718             if (m instanceof SortedMap &amp;&amp;
1719                 ((SortedMap&lt;?,?&gt;)m).comparator() == cmp) {
1720                 Node&lt;K,V&gt; b, n;
1721                 if ((b = baseHead()) != null) {
1722                     while ((n = b.next) != null) {
1723                         K k; V v;
1724                         if ((v = n.val) != null &amp;&amp; (k = n.key) != null) {
1725                             if (!it.hasNext())
1726                                 return false;
1727                             Map.Entry&lt;?,?&gt; e = it.next();
1728                             Object mk = e.getKey();
1729                             Object mv = e.getValue();
1730                             if (mk == null || mv == null)
1731                                 return false;
1732                             try {
1733                                 if (cpr(cmp, k, mk) != 0)
1734                                     return false;
1735                             } catch (ClassCastException cce) {
1736                                 return false;
1737                             }
1738                             if (!mv.equals(v))
1739                                 return false;
1740                         }
1741                         b = n;
1742                     }
1743                 }
1744                 return !it.hasNext();
1745             }
1746             else {
1747                 while (it.hasNext()) {
1748                     V v;
1749                     Map.Entry&lt;?,?&gt; e = it.next();
1750                     Object mk = e.getKey();
1751                     Object mv = e.getValue();
1752                     if (mk == null || mv == null ||
1753                         (v = get(mk)) == null || !v.equals(mv))
1754                         return false;
1755                 }
1756                 Node&lt;K,V&gt; b, n;
1757                 if ((b = baseHead()) != null) {
1758                     K k; V v; Object mv;
1759                     while ((n = b.next) != null) {
1760                         if ((v = n.val) != null &amp;&amp; (k = n.key) != null &amp;&amp;
1761                             ((mv = m.get(k)) == null || !mv.equals(v)))
1762                             return false;
1763                         b = n;
1764                     }
1765                 }
1766                 return true;
1767             }
1768         } catch (ClassCastException | NullPointerException unused) {
1769             return false;
1770         }
1771     }
1772 
1773     /* ------ ConcurrentMap API methods ------ */
1774 
1775     /**
1776      * {@inheritDoc}
1777      *
1778      * @return the previous value associated with the specified key,
1779      *         or {@code null} if there was no mapping for the key
1780      * @throws ClassCastException if the specified key cannot be compared
1781      *         with the keys currently in the map
1782      * @throws NullPointerException if the specified key or value is null
1783      */
1784     public V putIfAbsent(K key, V value) {
1785         if (value == null)
1786             throw new NullPointerException();
1787         return doPut(key, value, true);
1788     }
1789 
1790     /**
1791      * {@inheritDoc}
1792      *
1793      * @throws ClassCastException if the specified key cannot be compared
1794      *         with the keys currently in the map
1795      * @throws NullPointerException if the specified key is null
1796      */
1797     public boolean remove(Object key, Object value) {
1798         if (key == null)
1799             throw new NullPointerException();
1800         return value != null &amp;&amp; doRemove(key, value) != null;
1801     }
1802 
1803     /**
1804      * {@inheritDoc}
1805      *
1806      * @throws ClassCastException if the specified key cannot be compared
1807      *         with the keys currently in the map
1808      * @throws NullPointerException if any of the arguments are null
1809      */
1810     public boolean replace(K key, V oldValue, V newValue) {
1811         if (key == null || oldValue == null || newValue == null)
1812             throw new NullPointerException();
1813         for (;;) {
1814             Node&lt;K,V&gt; n; V v;
1815             if ((n = findNode(key)) == null)
1816                 return false;
1817             if ((v = n.val) != null) {
1818                 if (!oldValue.equals(v))
1819                     return false;
1820                 if (VAL.compareAndSet(n, v, newValue))
1821                     return true;
1822             }
1823         }
1824     }
1825 
1826     /**
1827      * {@inheritDoc}
1828      *
1829      * @return the previous value associated with the specified key,
1830      *         or {@code null} if there was no mapping for the key
1831      * @throws ClassCastException if the specified key cannot be compared
1832      *         with the keys currently in the map
1833      * @throws NullPointerException if the specified key or value is null
1834      */
1835     public V replace(K key, V value) {
1836         if (key == null || value == null)
1837             throw new NullPointerException();
1838         for (;;) {
1839             Node&lt;K,V&gt; n; V v;
1840             if ((n = findNode(key)) == null)
1841                 return null;
1842             if ((v = n.val) != null &amp;&amp; VAL.compareAndSet(n, v, value))
1843                 return v;
1844         }
1845     }
1846 
1847     /* ------ SortedMap API methods ------ */
1848 
1849     public Comparator&lt;? super K&gt; comparator() {
1850         return comparator;
1851     }
1852 
1853     /**
1854      * @throws NoSuchElementException {@inheritDoc}
1855      */
1856     public K firstKey() {
1857         Node&lt;K,V&gt; n = findFirst();
1858         if (n == null)
1859             throw new NoSuchElementException();
1860         return n.key;
1861     }
1862 
1863     /**
1864      * @throws NoSuchElementException {@inheritDoc}
1865      */
1866     public K lastKey() {
1867         Node&lt;K,V&gt; n = findLast();
1868         if (n == null)
1869             throw new NoSuchElementException();
1870         return n.key;
1871     }
1872 
1873     /**
1874      * @throws ClassCastException {@inheritDoc}
1875      * @throws NullPointerException if {@code fromKey} or {@code toKey} is null
1876      * @throws IllegalArgumentException {@inheritDoc}
1877      */
1878     public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey,
1879                                               boolean fromInclusive,
1880                                               K toKey,
1881                                               boolean toInclusive) {
1882         if (fromKey == null || toKey == null)
1883             throw new NullPointerException();
1884         return new SubMap&lt;K,V&gt;
1885             (this, fromKey, fromInclusive, toKey, toInclusive, false);
1886     }
1887 
1888     /**
1889      * @throws ClassCastException {@inheritDoc}
1890      * @throws NullPointerException if {@code toKey} is null
1891      * @throws IllegalArgumentException {@inheritDoc}
1892      */
1893     public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey,
1894                                                boolean inclusive) {
1895         if (toKey == null)
1896             throw new NullPointerException();
1897         return new SubMap&lt;K,V&gt;
1898             (this, null, false, toKey, inclusive, false);
1899     }
1900 
1901     /**
1902      * @throws ClassCastException {@inheritDoc}
1903      * @throws NullPointerException if {@code fromKey} is null
1904      * @throws IllegalArgumentException {@inheritDoc}
1905      */
1906     public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey,
1907                                                boolean inclusive) {
1908         if (fromKey == null)
1909             throw new NullPointerException();
1910         return new SubMap&lt;K,V&gt;
1911             (this, fromKey, inclusive, null, false, false);
1912     }
1913 
1914     /**
1915      * @throws ClassCastException {@inheritDoc}
1916      * @throws NullPointerException if {@code fromKey} or {@code toKey} is null
1917      * @throws IllegalArgumentException {@inheritDoc}
1918      */
1919     public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
1920         return subMap(fromKey, true, toKey, false);
1921     }
1922 
1923     /**
1924      * @throws ClassCastException {@inheritDoc}
1925      * @throws NullPointerException if {@code toKey} is null
1926      * @throws IllegalArgumentException {@inheritDoc}
1927      */
1928     public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey) {
1929         return headMap(toKey, false);
1930     }
1931 
1932     /**
1933      * @throws ClassCastException {@inheritDoc}
1934      * @throws NullPointerException if {@code fromKey} is null
1935      * @throws IllegalArgumentException {@inheritDoc}
1936      */
1937     public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey) {
1938         return tailMap(fromKey, true);
1939     }
1940 
1941     /* ---------------- Relational operations -------------- */
1942 
1943     /**
1944      * Returns a key-value mapping associated with the greatest key
1945      * strictly less than the given key, or {@code null} if there is
1946      * no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support the
1947      * {@code Entry.setValue} method.
1948      *
1949      * @throws ClassCastException {@inheritDoc}
1950      * @throws NullPointerException if the specified key is null
1951      */
1952     public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
1953         return findNearEntry(key, LT, comparator);
1954     }
1955 
1956     /**
1957      * @throws ClassCastException {@inheritDoc}
1958      * @throws NullPointerException if the specified key is null
1959      */
1960     public K lowerKey(K key) {
1961         Node&lt;K,V&gt; n = findNear(key, LT, comparator);
1962         return (n == null) ? null : n.key;
1963     }
1964 
1965     /**
1966      * Returns a key-value mapping associated with the greatest key
1967      * less than or equal to the given key, or {@code null} if there
1968      * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
1969      * the {@code Entry.setValue} method.
1970      *
1971      * @param key the key
1972      * @throws ClassCastException {@inheritDoc}
1973      * @throws NullPointerException if the specified key is null
1974      */
1975     public Map.Entry&lt;K,V&gt; floorEntry(K key) {
1976         return findNearEntry(key, LT|EQ, comparator);
1977     }
1978 
1979     /**
1980      * @param key the key
1981      * @throws ClassCastException {@inheritDoc}
1982      * @throws NullPointerException if the specified key is null
1983      */
1984     public K floorKey(K key) {
1985         Node&lt;K,V&gt; n = findNear(key, LT|EQ, comparator);
1986         return (n == null) ? null : n.key;
1987     }
1988 
1989     /**
1990      * Returns a key-value mapping associated with the least key
1991      * greater than or equal to the given key, or {@code null} if
1992      * there is no such entry. The returned entry does &lt;em&gt;not&lt;/em&gt;
1993      * support the {@code Entry.setValue} method.
1994      *
1995      * @throws ClassCastException {@inheritDoc}
1996      * @throws NullPointerException if the specified key is null
1997      */
1998     public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
1999         return findNearEntry(key, GT|EQ, comparator);
2000     }
2001 
2002     /**
2003      * @throws ClassCastException {@inheritDoc}
2004      * @throws NullPointerException if the specified key is null
2005      */
2006     public K ceilingKey(K key) {
2007         Node&lt;K,V&gt; n = findNear(key, GT|EQ, comparator);
2008         return (n == null) ? null : n.key;
2009     }
2010 
2011     /**
2012      * Returns a key-value mapping associated with the least key
2013      * strictly greater than the given key, or {@code null} if there
2014      * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
2015      * the {@code Entry.setValue} method.
2016      *
2017      * @param key the key
2018      * @throws ClassCastException {@inheritDoc}
2019      * @throws NullPointerException if the specified key is null
2020      */
2021     public Map.Entry&lt;K,V&gt; higherEntry(K key) {
2022         return findNearEntry(key, GT, comparator);
2023     }
2024 
2025     /**
2026      * @param key the key
2027      * @throws ClassCastException {@inheritDoc}
2028      * @throws NullPointerException if the specified key is null
2029      */
2030     public K higherKey(K key) {
2031         Node&lt;K,V&gt; n = findNear(key, GT, comparator);
2032         return (n == null) ? null : n.key;
2033     }
2034 
2035     /**
2036      * Returns a key-value mapping associated with the least
2037      * key in this map, or {@code null} if the map is empty.
2038      * The returned entry does &lt;em&gt;not&lt;/em&gt; support
2039      * the {@code Entry.setValue} method.
2040      */
2041     public Map.Entry&lt;K,V&gt; firstEntry() {
2042         return findFirstEntry();
2043     }
2044 
2045     /**
2046      * Returns a key-value mapping associated with the greatest
2047      * key in this map, or {@code null} if the map is empty.
2048      * The returned entry does &lt;em&gt;not&lt;/em&gt; support
2049      * the {@code Entry.setValue} method.
2050      */
2051     public Map.Entry&lt;K,V&gt; lastEntry() {
2052         return findLastEntry();
2053     }
2054 
2055     /**
2056      * Removes and returns a key-value mapping associated with
2057      * the least key in this map, or {@code null} if the map is empty.
2058      * The returned entry does &lt;em&gt;not&lt;/em&gt; support
2059      * the {@code Entry.setValue} method.
2060      */
2061     public Map.Entry&lt;K,V&gt; pollFirstEntry() {
2062         return doRemoveFirstEntry();
2063     }
2064 
2065     /**
2066      * Removes and returns a key-value mapping associated with
2067      * the greatest key in this map, or {@code null} if the map is empty.
2068      * The returned entry does &lt;em&gt;not&lt;/em&gt; support
2069      * the {@code Entry.setValue} method.
2070      */
2071     public Map.Entry&lt;K,V&gt; pollLastEntry() {
2072         return doRemoveLastEntry();
2073     }
2074 
2075     /* ---------------- Iterators -------------- */
2076 
2077     /**
2078      * Base of iterator classes
2079      */
2080     abstract class Iter&lt;T&gt; implements Iterator&lt;T&gt; {
2081         /** the last node returned by next() */
2082         Node&lt;K,V&gt; lastReturned;
2083         /** the next node to return from next(); */
2084         Node&lt;K,V&gt; next;
2085         /** Cache of next value field to maintain weak consistency */
2086         V nextValue;
2087 
2088         /** Initializes ascending iterator for entire range. */
2089         Iter() {
2090             advance(baseHead());
2091         }
2092 
2093         public final boolean hasNext() {
2094             return next != null;
2095         }
2096 
2097         /** Advances next to higher entry. */
2098         final void advance(Node&lt;K,V&gt; b) {
2099             Node&lt;K,V&gt; n = null;
2100             V v = null;
2101             if ((lastReturned = b) != null) {
2102                 while ((n = b.next) != null &amp;&amp; (v = n.val) == null)
2103                     b = n;
2104             }
2105             nextValue = v;
2106             next = n;
2107         }
2108 
2109         public final void remove() {
2110             Node&lt;K,V&gt; n; K k;
2111             if ((n = lastReturned) == null || (k = n.key) == null)
2112                 throw new IllegalStateException();
2113             // It would not be worth all of the overhead to directly
2114             // unlink from here. Using remove is fast enough.
2115             ConcurrentSkipListMap.this.remove(k);
2116             lastReturned = null;
2117         }
2118     }
2119 
2120     final class ValueIterator extends Iter&lt;V&gt; {
2121         public V next() {
2122             V v;
2123             if ((v = nextValue) == null)
2124                 throw new NoSuchElementException();
2125             advance(next);
2126             return v;
2127         }
2128     }
2129 
2130     final class KeyIterator extends Iter&lt;K&gt; {
2131         public K next() {
2132             Node&lt;K,V&gt; n;
2133             if ((n = next) == null)
2134                 throw new NoSuchElementException();
2135             K k = n.key;
2136             advance(n);
2137             return k;
2138         }
2139     }
2140 
2141     final class EntryIterator extends Iter&lt;Map.Entry&lt;K,V&gt;&gt; {
2142         public Map.Entry&lt;K,V&gt; next() {
2143             Node&lt;K,V&gt; n;
2144             if ((n = next) == null)
2145                 throw new NoSuchElementException();
2146             K k = n.key;
2147             V v = nextValue;
2148             advance(n);
2149             return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
2150         }
2151     }
2152 
2153     /* ---------------- View Classes -------------- */
2154 
2155     /*
2156      * View classes are static, delegating to a ConcurrentNavigableMap
2157      * to allow use by SubMaps, which outweighs the ugliness of
2158      * needing type-tests for Iterator methods.
2159      */
2160 
2161     static final &lt;E&gt; List&lt;E&gt; toList(Collection&lt;E&gt; c) {
2162         // Using size() here would be a pessimization.
2163         ArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;();
2164         for (E e : c)
2165             list.add(e);
2166         return list;
2167     }
2168 
2169     static final class KeySet&lt;K,V&gt;
2170             extends AbstractSet&lt;K&gt; implements NavigableSet&lt;K&gt; {
2171         final ConcurrentNavigableMap&lt;K,V&gt; m;
2172         KeySet(ConcurrentNavigableMap&lt;K,V&gt; map) { m = map; }
2173         public int size() { return m.size(); }
2174         public boolean isEmpty() { return m.isEmpty(); }
2175         public boolean contains(Object o) { return m.containsKey(o); }
2176         public boolean remove(Object o) { return m.remove(o) != null; }
2177         public void clear() { m.clear(); }
2178         public K lower(K e) { return m.lowerKey(e); }
2179         public K floor(K e) { return m.floorKey(e); }
2180         public K ceiling(K e) { return m.ceilingKey(e); }
2181         public K higher(K e) { return m.higherKey(e); }
2182         public Comparator&lt;? super K&gt; comparator() { return m.comparator(); }
2183         public K first() { return m.firstKey(); }
2184         public K last() { return m.lastKey(); }
2185         public K pollFirst() {
2186             Map.Entry&lt;K,V&gt; e = m.pollFirstEntry();
2187             return (e == null) ? null : e.getKey();
2188         }
2189         public K pollLast() {
2190             Map.Entry&lt;K,V&gt; e = m.pollLastEntry();
2191             return (e == null) ? null : e.getKey();
2192         }
2193         public Iterator&lt;K&gt; iterator() {
2194             return (m instanceof ConcurrentSkipListMap)
2195                 ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).new KeyIterator()
2196                 : ((SubMap&lt;K,V&gt;)m).new SubMapKeyIterator();
2197         }
2198         public boolean equals(Object o) {
2199             if (o == this)
2200                 return true;
2201             if (!(o instanceof Set))
2202                 return false;
2203             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
2204             try {
2205                 return containsAll(c) &amp;&amp; c.containsAll(this);
2206             } catch (ClassCastException | NullPointerException unused) {
2207                 return false;
2208             }
2209         }
2210         public Object[] toArray()     { return toList(this).toArray();  }
2211         public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }
2212         public Iterator&lt;K&gt; descendingIterator() {
2213             return descendingSet().iterator();
2214         }
2215         public NavigableSet&lt;K&gt; subSet(K fromElement,
2216                                       boolean fromInclusive,
2217                                       K toElement,
2218                                       boolean toInclusive) {
2219             return new KeySet&lt;&gt;(m.subMap(fromElement, fromInclusive,
2220                                          toElement,   toInclusive));
2221         }
2222         public NavigableSet&lt;K&gt; headSet(K toElement, boolean inclusive) {
2223             return new KeySet&lt;&gt;(m.headMap(toElement, inclusive));
2224         }
2225         public NavigableSet&lt;K&gt; tailSet(K fromElement, boolean inclusive) {
2226             return new KeySet&lt;&gt;(m.tailMap(fromElement, inclusive));
2227         }
2228         public NavigableSet&lt;K&gt; subSet(K fromElement, K toElement) {
2229             return subSet(fromElement, true, toElement, false);
2230         }
2231         public NavigableSet&lt;K&gt; headSet(K toElement) {
2232             return headSet(toElement, false);
2233         }
2234         public NavigableSet&lt;K&gt; tailSet(K fromElement) {
2235             return tailSet(fromElement, true);
2236         }
2237         public NavigableSet&lt;K&gt; descendingSet() {
2238             return new KeySet&lt;&gt;(m.descendingMap());
2239         }
2240 
2241         public Spliterator&lt;K&gt; spliterator() {
2242             return (m instanceof ConcurrentSkipListMap)
2243                 ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).keySpliterator()
2244                 : ((SubMap&lt;K,V&gt;)m).new SubMapKeyIterator();
2245         }
2246     }
2247 
2248     static final class Values&lt;K,V&gt; extends AbstractCollection&lt;V&gt; {
2249         final ConcurrentNavigableMap&lt;K,V&gt; m;
2250         Values(ConcurrentNavigableMap&lt;K,V&gt; map) {
2251             m = map;
2252         }
2253         public Iterator&lt;V&gt; iterator() {
2254             return (m instanceof ConcurrentSkipListMap)
2255                 ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).new ValueIterator()
2256                 : ((SubMap&lt;K,V&gt;)m).new SubMapValueIterator();
2257         }
2258         public int size() { return m.size(); }
2259         public boolean isEmpty() { return m.isEmpty(); }
2260         public boolean contains(Object o) { return m.containsValue(o); }
2261         public void clear() { m.clear(); }
2262         public Object[] toArray()     { return toList(this).toArray();  }
2263         public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }
2264 
2265         public Spliterator&lt;V&gt; spliterator() {
2266             return (m instanceof ConcurrentSkipListMap)
2267                 ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).valueSpliterator()
2268                 : ((SubMap&lt;K,V&gt;)m).new SubMapValueIterator();
2269         }
2270 
2271         public boolean removeIf(Predicate&lt;? super V&gt; filter) {
2272             if (filter == null) throw new NullPointerException();
2273             if (m instanceof ConcurrentSkipListMap)
2274                 return ((ConcurrentSkipListMap&lt;K,V&gt;)m).removeValueIf(filter);
2275             // else use iterator
2276             Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it =
2277                 ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
2278             boolean removed = false;
2279             while (it.hasNext()) {
2280                 Map.Entry&lt;K,V&gt; e = it.next();
2281                 V v = e.getValue();
2282                 if (filter.test(v) &amp;&amp; m.remove(e.getKey(), v))
2283                     removed = true;
2284             }
2285             return removed;
2286         }
2287     }
2288 
2289     static final class EntrySet&lt;K,V&gt; extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
2290         final ConcurrentNavigableMap&lt;K,V&gt; m;
2291         EntrySet(ConcurrentNavigableMap&lt;K,V&gt; map) {
2292             m = map;
2293         }
2294         public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2295             return (m instanceof ConcurrentSkipListMap)
2296                 ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).new EntryIterator()
2297                 : ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
2298         }
2299 
2300         public boolean contains(Object o) {
2301             if (!(o instanceof Map.Entry))
2302                 return false;
2303             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
2304             V v = m.get(e.getKey());
2305             return v != null &amp;&amp; v.equals(e.getValue());
2306         }
2307         public boolean remove(Object o) {
2308             if (!(o instanceof Map.Entry))
2309                 return false;
2310             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
2311             return m.remove(e.getKey(),
2312                             e.getValue());
2313         }
2314         public boolean isEmpty() {
2315             return m.isEmpty();
2316         }
2317         public int size() {
2318             return m.size();
2319         }
2320         public void clear() {
2321             m.clear();
2322         }
2323         public boolean equals(Object o) {
2324             if (o == this)
2325                 return true;
2326             if (!(o instanceof Set))
2327                 return false;
2328             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
2329             try {
2330                 return containsAll(c) &amp;&amp; c.containsAll(this);
2331             } catch (ClassCastException | NullPointerException unused) {
2332                 return false;
2333             }
2334         }
2335         public Object[] toArray()     { return toList(this).toArray();  }
2336         public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }
2337 
2338         public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
2339             return (m instanceof ConcurrentSkipListMap)
2340                 ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).entrySpliterator()
2341                 : ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
2342         }
2343         public boolean removeIf(Predicate&lt;? super Entry&lt;K,V&gt;&gt; filter) {
2344             if (filter == null) throw new NullPointerException();
2345             if (m instanceof ConcurrentSkipListMap)
2346                 return ((ConcurrentSkipListMap&lt;K,V&gt;)m).removeEntryIf(filter);
2347             // else use iterator
2348             Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it =
2349                 ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
2350             boolean removed = false;
2351             while (it.hasNext()) {
2352                 Map.Entry&lt;K,V&gt; e = it.next();
2353                 if (filter.test(e) &amp;&amp; m.remove(e.getKey(), e.getValue()))
2354                     removed = true;
2355             }
2356             return removed;
2357         }
2358     }
2359 
2360     /**
2361      * Submaps returned by {@link ConcurrentSkipListMap} submap operations
2362      * represent a subrange of mappings of their underlying maps.
2363      * Instances of this class support all methods of their underlying
2364      * maps, differing in that mappings outside their range are ignored,
2365      * and attempts to add mappings outside their ranges result in {@link
2366      * IllegalArgumentException}.  Instances of this class are constructed
2367      * only using the {@code subMap}, {@code headMap}, and {@code tailMap}
2368      * methods of their underlying maps.
2369      *
2370      * @serial include
2371      */
2372     static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
2373         implements ConcurrentNavigableMap&lt;K,V&gt;, Serializable {
2374         private static final long serialVersionUID = -7647078645895051609L;
2375 
2376         /** Underlying map */
2377         final ConcurrentSkipListMap&lt;K,V&gt; m;
2378         /** lower bound key, or null if from start */
2379         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
2380         private final K lo;
2381         /** upper bound key, or null if to end */
2382         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
2383         private final K hi;
2384         /** inclusion flag for lo */
2385         private final boolean loInclusive;
2386         /** inclusion flag for hi */
2387         private final boolean hiInclusive;
2388         /** direction */
2389         final boolean isDescending;
2390 
2391         // Lazily initialized view holders
2392         private transient KeySet&lt;K,V&gt; keySetView;
2393         private transient Values&lt;K,V&gt; valuesView;
2394         private transient EntrySet&lt;K,V&gt; entrySetView;
2395 
2396         /**
2397          * Creates a new submap, initializing all fields.
2398          */
2399         SubMap(ConcurrentSkipListMap&lt;K,V&gt; map,
2400                K fromKey, boolean fromInclusive,
2401                K toKey, boolean toInclusive,
2402                boolean isDescending) {
2403             Comparator&lt;? super K&gt; cmp = map.comparator;
2404             if (fromKey != null &amp;&amp; toKey != null &amp;&amp;
2405                 cpr(cmp, fromKey, toKey) &gt; 0)
2406                 throw new IllegalArgumentException(&quot;inconsistent range&quot;);
2407             this.m = map;
2408             this.lo = fromKey;
2409             this.hi = toKey;
2410             this.loInclusive = fromInclusive;
2411             this.hiInclusive = toInclusive;
2412             this.isDescending = isDescending;
2413         }
2414 
2415         /* ----------------  Utilities -------------- */
2416 
2417         boolean tooLow(Object key, Comparator&lt;? super K&gt; cmp) {
2418             int c;
2419             return (lo != null &amp;&amp; ((c = cpr(cmp, key, lo)) &lt; 0 ||
2420                                    (c == 0 &amp;&amp; !loInclusive)));
2421         }
2422 
2423         boolean tooHigh(Object key, Comparator&lt;? super K&gt; cmp) {
2424             int c;
2425             return (hi != null &amp;&amp; ((c = cpr(cmp, key, hi)) &gt; 0 ||
2426                                    (c == 0 &amp;&amp; !hiInclusive)));
2427         }
2428 
2429         boolean inBounds(Object key, Comparator&lt;? super K&gt; cmp) {
2430             return !tooLow(key, cmp) &amp;&amp; !tooHigh(key, cmp);
2431         }
2432 
2433         void checkKeyBounds(K key, Comparator&lt;? super K&gt; cmp) {
2434             if (key == null)
2435                 throw new NullPointerException();
2436             if (!inBounds(key, cmp))
2437                 throw new IllegalArgumentException(&quot;key out of range&quot;);
2438         }
2439 
2440         /**
2441          * Returns true if node key is less than upper bound of range.
2442          */
2443         boolean isBeforeEnd(ConcurrentSkipListMap.Node&lt;K,V&gt; n,
2444                             Comparator&lt;? super K&gt; cmp) {
2445             if (n == null)
2446                 return false;
2447             if (hi == null)
2448                 return true;
2449             K k = n.key;
2450             if (k == null) // pass by markers and headers
2451                 return true;
2452             int c = cpr(cmp, k, hi);
2453             return c &lt; 0 || (c == 0 &amp;&amp; hiInclusive);
2454         }
2455 
2456         /**
2457          * Returns lowest node. This node might not be in range, so
2458          * most usages need to check bounds.
2459          */
2460         ConcurrentSkipListMap.Node&lt;K,V&gt; loNode(Comparator&lt;? super K&gt; cmp) {
2461             if (lo == null)
2462                 return m.findFirst();
2463             else if (loInclusive)
2464                 return m.findNear(lo, GT|EQ, cmp);
2465             else
2466                 return m.findNear(lo, GT, cmp);
2467         }
2468 
2469         /**
2470          * Returns highest node. This node might not be in range, so
2471          * most usages need to check bounds.
2472          */
2473         ConcurrentSkipListMap.Node&lt;K,V&gt; hiNode(Comparator&lt;? super K&gt; cmp) {
2474             if (hi == null)
2475                 return m.findLast();
2476             else if (hiInclusive)
2477                 return m.findNear(hi, LT|EQ, cmp);
2478             else
2479                 return m.findNear(hi, LT, cmp);
2480         }
2481 
2482         /**
2483          * Returns lowest absolute key (ignoring directionality).
2484          */
2485         K lowestKey() {
2486             Comparator&lt;? super K&gt; cmp = m.comparator;
2487             ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
2488             if (isBeforeEnd(n, cmp))
2489                 return n.key;
2490             else
2491                 throw new NoSuchElementException();
2492         }
2493 
2494         /**
2495          * Returns highest absolute key (ignoring directionality).
2496          */
2497         K highestKey() {
2498             Comparator&lt;? super K&gt; cmp = m.comparator;
2499             ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);
2500             if (n != null) {
2501                 K last = n.key;
2502                 if (inBounds(last, cmp))
2503                     return last;
2504             }
2505             throw new NoSuchElementException();
2506         }
2507 
2508         Map.Entry&lt;K,V&gt; lowestEntry() {
2509             Comparator&lt;? super K&gt; cmp = m.comparator;
2510             for (;;) {
2511                 ConcurrentSkipListMap.Node&lt;K,V&gt; n; V v;
2512                 if ((n = loNode(cmp)) == null || !isBeforeEnd(n, cmp))
2513                     return null;
2514                 else if ((v = n.val) != null)
2515                     return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
2516             }
2517         }
2518 
2519         Map.Entry&lt;K,V&gt; highestEntry() {
2520             Comparator&lt;? super K&gt; cmp = m.comparator;
2521             for (;;) {
2522                 ConcurrentSkipListMap.Node&lt;K,V&gt; n; V v;
2523                 if ((n = hiNode(cmp)) == null || !inBounds(n.key, cmp))
2524                     return null;
2525                 else if ((v = n.val) != null)
2526                     return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
2527             }
2528         }
2529 
2530         Map.Entry&lt;K,V&gt; removeLowest() {
2531             Comparator&lt;? super K&gt; cmp = m.comparator;
2532             for (;;) {
2533                 ConcurrentSkipListMap.Node&lt;K,V&gt; n; K k; V v;
2534                 if ((n = loNode(cmp)) == null)
2535                     return null;
2536                 else if (!inBounds((k = n.key), cmp))
2537                     return null;
2538                 else if ((v = m.doRemove(k, null)) != null)
2539                     return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
2540             }
2541         }
2542 
2543         Map.Entry&lt;K,V&gt; removeHighest() {
2544             Comparator&lt;? super K&gt; cmp = m.comparator;
2545             for (;;) {
2546                 ConcurrentSkipListMap.Node&lt;K,V&gt; n; K k; V v;
2547                 if ((n = hiNode(cmp)) == null)
2548                     return null;
2549                 else if (!inBounds((k = n.key), cmp))
2550                     return null;
2551                 else if ((v = m.doRemove(k, null)) != null)
2552                     return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
2553             }
2554         }
2555 
2556         /**
2557          * Submap version of ConcurrentSkipListMap.findNearEntry.
2558          */
2559         Map.Entry&lt;K,V&gt; getNearEntry(K key, int rel) {
2560             Comparator&lt;? super K&gt; cmp = m.comparator;
2561             if (isDescending) { // adjust relation for direction
2562                 if ((rel &amp; LT) == 0)
2563                     rel |= LT;
2564                 else
2565                     rel &amp;= ~LT;
2566             }
2567             if (tooLow(key, cmp))
2568                 return ((rel &amp; LT) != 0) ? null : lowestEntry();
2569             if (tooHigh(key, cmp))
2570                 return ((rel &amp; LT) != 0) ? highestEntry() : null;
2571             AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e =
2572                 m.findNearEntry(key, rel, cmp);
2573             if (e == null || !inBounds(e.getKey(), cmp))
2574                 return null;
2575             else
2576                 return e;
2577         }
2578 
2579         // Almost the same as getNearEntry, except for keys
2580         K getNearKey(K key, int rel) {
2581             Comparator&lt;? super K&gt; cmp = m.comparator;
2582             if (isDescending) { // adjust relation for direction
2583                 if ((rel &amp; LT) == 0)
2584                     rel |= LT;
2585                 else
2586                     rel &amp;= ~LT;
2587             }
2588             if (tooLow(key, cmp)) {
2589                 if ((rel &amp; LT) == 0) {
2590                     ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
2591                     if (isBeforeEnd(n, cmp))
2592                         return n.key;
2593                 }
2594                 return null;
2595             }
2596             if (tooHigh(key, cmp)) {
2597                 if ((rel &amp; LT) != 0) {
2598                     ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);
2599                     if (n != null) {
2600                         K last = n.key;
2601                         if (inBounds(last, cmp))
2602                             return last;
2603                     }
2604                 }
2605                 return null;
2606             }
2607             for (;;) {
2608                 Node&lt;K,V&gt; n = m.findNear(key, rel, cmp);
2609                 if (n == null || !inBounds(n.key, cmp))
2610                     return null;
2611                 if (n.val != null)
2612                     return n.key;
2613             }
2614         }
2615 
2616         /* ----------------  Map API methods -------------- */
2617 
2618         public boolean containsKey(Object key) {
2619             if (key == null) throw new NullPointerException();
2620             return inBounds(key, m.comparator) &amp;&amp; m.containsKey(key);
2621         }
2622 
2623         public V get(Object key) {
2624             if (key == null) throw new NullPointerException();
2625             return (!inBounds(key, m.comparator)) ? null : m.get(key);
2626         }
2627 
2628         public V put(K key, V value) {
2629             checkKeyBounds(key, m.comparator);
2630             return m.put(key, value);
2631         }
2632 
2633         public V remove(Object key) {
2634             return (!inBounds(key, m.comparator)) ? null : m.remove(key);
2635         }
2636 
2637         public int size() {
2638             Comparator&lt;? super K&gt; cmp = m.comparator;
2639             long count = 0;
2640             for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
2641                  isBeforeEnd(n, cmp);
2642                  n = n.next) {
2643                 if (n.val != null)
2644                     ++count;
2645             }
2646             return count &gt;= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)count;
2647         }
2648 
2649         public boolean isEmpty() {
2650             Comparator&lt;? super K&gt; cmp = m.comparator;
2651             return !isBeforeEnd(loNode(cmp), cmp);
2652         }
2653 
2654         public boolean containsValue(Object value) {
2655             if (value == null)
2656                 throw new NullPointerException();
2657             Comparator&lt;? super K&gt; cmp = m.comparator;
2658             for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
2659                  isBeforeEnd(n, cmp);
2660                  n = n.next) {
2661                 V v = n.val;
2662                 if (v != null &amp;&amp; value.equals(v))
2663                     return true;
2664             }
2665             return false;
2666         }
2667 
2668         public void clear() {
2669             Comparator&lt;? super K&gt; cmp = m.comparator;
2670             for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
2671                  isBeforeEnd(n, cmp);
2672                  n = n.next) {
2673                 if (n.val != null)
2674                     m.remove(n.key);
2675             }
2676         }
2677 
2678         /* ----------------  ConcurrentMap API methods -------------- */
2679 
2680         public V putIfAbsent(K key, V value) {
2681             checkKeyBounds(key, m.comparator);
2682             return m.putIfAbsent(key, value);
2683         }
2684 
2685         public boolean remove(Object key, Object value) {
2686             return inBounds(key, m.comparator) &amp;&amp; m.remove(key, value);
2687         }
2688 
2689         public boolean replace(K key, V oldValue, V newValue) {
2690             checkKeyBounds(key, m.comparator);
2691             return m.replace(key, oldValue, newValue);
2692         }
2693 
2694         public V replace(K key, V value) {
2695             checkKeyBounds(key, m.comparator);
2696             return m.replace(key, value);
2697         }
2698 
2699         /* ----------------  SortedMap API methods -------------- */
2700 
2701         public Comparator&lt;? super K&gt; comparator() {
2702             Comparator&lt;? super K&gt; cmp = m.comparator();
2703             if (isDescending)
2704                 return Collections.reverseOrder(cmp);
2705             else
2706                 return cmp;
2707         }
2708 
2709         /**
2710          * Utility to create submaps, where given bounds override
2711          * unbounded(null) ones and/or are checked against bounded ones.
2712          */
2713         SubMap&lt;K,V&gt; newSubMap(K fromKey, boolean fromInclusive,
2714                               K toKey, boolean toInclusive) {
2715             Comparator&lt;? super K&gt; cmp = m.comparator;
2716             if (isDescending) { // flip senses
2717                 K tk = fromKey;
2718                 fromKey = toKey;
2719                 toKey = tk;
2720                 boolean ti = fromInclusive;
2721                 fromInclusive = toInclusive;
2722                 toInclusive = ti;
2723             }
2724             if (lo != null) {
2725                 if (fromKey == null) {
2726                     fromKey = lo;
2727                     fromInclusive = loInclusive;
2728                 }
2729                 else {
2730                     int c = cpr(cmp, fromKey, lo);
2731                     if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive &amp;&amp; fromInclusive))
2732                         throw new IllegalArgumentException(&quot;key out of range&quot;);
2733                 }
2734             }
2735             if (hi != null) {
2736                 if (toKey == null) {
2737                     toKey = hi;
2738                     toInclusive = hiInclusive;
2739                 }
2740                 else {
2741                     int c = cpr(cmp, toKey, hi);
2742                     if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive &amp;&amp; toInclusive))
2743                         throw new IllegalArgumentException(&quot;key out of range&quot;);
2744                 }
2745             }
2746             return new SubMap&lt;K,V&gt;(m, fromKey, fromInclusive,
2747                                    toKey, toInclusive, isDescending);
2748         }
2749 
2750         public SubMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
2751                                   K toKey, boolean toInclusive) {
2752             if (fromKey == null || toKey == null)
2753                 throw new NullPointerException();
2754             return newSubMap(fromKey, fromInclusive, toKey, toInclusive);
2755         }
2756 
2757         public SubMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
2758             if (toKey == null)
2759                 throw new NullPointerException();
2760             return newSubMap(null, false, toKey, inclusive);
2761         }
2762 
2763         public SubMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
2764             if (fromKey == null)
2765                 throw new NullPointerException();
2766             return newSubMap(fromKey, inclusive, null, false);
2767         }
2768 
2769         public SubMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
2770             return subMap(fromKey, true, toKey, false);
2771         }
2772 
2773         public SubMap&lt;K,V&gt; headMap(K toKey) {
2774             return headMap(toKey, false);
2775         }
2776 
2777         public SubMap&lt;K,V&gt; tailMap(K fromKey) {
2778             return tailMap(fromKey, true);
2779         }
2780 
2781         public SubMap&lt;K,V&gt; descendingMap() {
2782             return new SubMap&lt;K,V&gt;(m, lo, loInclusive,
2783                                    hi, hiInclusive, !isDescending);
2784         }
2785 
2786         /* ----------------  Relational methods -------------- */
2787 
2788         public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
2789             return getNearEntry(key, GT|EQ);
2790         }
2791 
2792         public K ceilingKey(K key) {
2793             return getNearKey(key, GT|EQ);
2794         }
2795 
2796         public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
2797             return getNearEntry(key, LT);
2798         }
2799 
2800         public K lowerKey(K key) {
2801             return getNearKey(key, LT);
2802         }
2803 
2804         public Map.Entry&lt;K,V&gt; floorEntry(K key) {
2805             return getNearEntry(key, LT|EQ);
2806         }
2807 
2808         public K floorKey(K key) {
2809             return getNearKey(key, LT|EQ);
2810         }
2811 
2812         public Map.Entry&lt;K,V&gt; higherEntry(K key) {
2813             return getNearEntry(key, GT);
2814         }
2815 
2816         public K higherKey(K key) {
2817             return getNearKey(key, GT);
2818         }
2819 
2820         public K firstKey() {
2821             return isDescending ? highestKey() : lowestKey();
2822         }
2823 
2824         public K lastKey() {
2825             return isDescending ? lowestKey() : highestKey();
2826         }
2827 
2828         public Map.Entry&lt;K,V&gt; firstEntry() {
2829             return isDescending ? highestEntry() : lowestEntry();
2830         }
2831 
2832         public Map.Entry&lt;K,V&gt; lastEntry() {
2833             return isDescending ? lowestEntry() : highestEntry();
2834         }
2835 
2836         public Map.Entry&lt;K,V&gt; pollFirstEntry() {
2837             return isDescending ? removeHighest() : removeLowest();
2838         }
2839 
2840         public Map.Entry&lt;K,V&gt; pollLastEntry() {
2841             return isDescending ? removeLowest() : removeHighest();
2842         }
2843 
2844         /* ---------------- Submap Views -------------- */
2845 
2846         public NavigableSet&lt;K&gt; keySet() {
2847             KeySet&lt;K,V&gt; ks;
2848             if ((ks = keySetView) != null) return ks;
2849             return keySetView = new KeySet&lt;&gt;(this);
2850         }
2851 
2852         public NavigableSet&lt;K&gt; navigableKeySet() {
2853             KeySet&lt;K,V&gt; ks;
2854             if ((ks = keySetView) != null) return ks;
2855             return keySetView = new KeySet&lt;&gt;(this);
2856         }
2857 
2858         public Collection&lt;V&gt; values() {
2859             Values&lt;K,V&gt; vs;
2860             if ((vs = valuesView) != null) return vs;
2861             return valuesView = new Values&lt;&gt;(this);
2862         }
2863 
2864         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2865             EntrySet&lt;K,V&gt; es;
2866             if ((es = entrySetView) != null) return es;
2867             return entrySetView = new EntrySet&lt;K,V&gt;(this);
2868         }
2869 
2870         public NavigableSet&lt;K&gt; descendingKeySet() {
2871             return descendingMap().navigableKeySet();
2872         }
2873 
2874         /**
2875          * Variant of main Iter class to traverse through submaps.
2876          * Also serves as back-up Spliterator for views.
2877          */
2878         abstract class SubMapIter&lt;T&gt; implements Iterator&lt;T&gt;, Spliterator&lt;T&gt; {
2879             /** the last node returned by next() */
2880             Node&lt;K,V&gt; lastReturned;
2881             /** the next node to return from next(); */
2882             Node&lt;K,V&gt; next;
2883             /** Cache of next value field to maintain weak consistency */
2884             V nextValue;
2885 
2886             SubMapIter() {
2887                 VarHandle.acquireFence();
2888                 Comparator&lt;? super K&gt; cmp = m.comparator;
2889                 for (;;) {
2890                     next = isDescending ? hiNode(cmp) : loNode(cmp);
2891                     if (next == null)
2892                         break;
2893                     V x = next.val;
2894                     if (x != null) {
2895                         if (! inBounds(next.key, cmp))
2896                             next = null;
2897                         else
2898                             nextValue = x;
2899                         break;
2900                     }
2901                 }
2902             }
2903 
2904             public final boolean hasNext() {
2905                 return next != null;
2906             }
2907 
2908             final void advance() {
2909                 if (next == null)
2910                     throw new NoSuchElementException();
2911                 lastReturned = next;
2912                 if (isDescending)
2913                     descend();
2914                 else
2915                     ascend();
2916             }
2917 
2918             private void ascend() {
2919                 Comparator&lt;? super K&gt; cmp = m.comparator;
2920                 for (;;) {
2921                     next = next.next;
2922                     if (next == null)
2923                         break;
2924                     V x = next.val;
2925                     if (x != null) {
2926                         if (tooHigh(next.key, cmp))
2927                             next = null;
2928                         else
2929                             nextValue = x;
2930                         break;
2931                     }
2932                 }
2933             }
2934 
2935             private void descend() {
2936                 Comparator&lt;? super K&gt; cmp = m.comparator;
2937                 for (;;) {
2938                     next = m.findNear(lastReturned.key, LT, cmp);
2939                     if (next == null)
2940                         break;
2941                     V x = next.val;
2942                     if (x != null) {
2943                         if (tooLow(next.key, cmp))
2944                             next = null;
2945                         else
2946                             nextValue = x;
2947                         break;
2948                     }
2949                 }
2950             }
2951 
2952             public void remove() {
2953                 Node&lt;K,V&gt; l = lastReturned;
2954                 if (l == null)
2955                     throw new IllegalStateException();
2956                 m.remove(l.key);
2957                 lastReturned = null;
2958             }
2959 
2960             public Spliterator&lt;T&gt; trySplit() {
2961                 return null;
2962             }
2963 
2964             public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
2965                 if (hasNext()) {
2966                     action.accept(next());
2967                     return true;
2968                 }
2969                 return false;
2970             }
2971 
2972             public void forEachRemaining(Consumer&lt;? super T&gt; action) {
2973                 while (hasNext())
2974                     action.accept(next());
2975             }
2976 
2977             public long estimateSize() {
2978                 return Long.MAX_VALUE;
2979             }
2980 
2981         }
2982 
2983         final class SubMapValueIterator extends SubMapIter&lt;V&gt; {
2984             public V next() {
2985                 V v = nextValue;
2986                 advance();
2987                 return v;
2988             }
2989             public int characteristics() {
2990                 return 0;
2991             }
2992         }
2993 
2994         final class SubMapKeyIterator extends SubMapIter&lt;K&gt; {
2995             public K next() {
2996                 Node&lt;K,V&gt; n = next;
2997                 advance();
2998                 return n.key;
2999             }
3000             public int characteristics() {
3001                 return Spliterator.DISTINCT | Spliterator.ORDERED |
3002                     Spliterator.SORTED;
3003             }
3004             public final Comparator&lt;? super K&gt; getComparator() {
3005                 return SubMap.this.comparator();
3006             }
3007         }
3008 
3009         final class SubMapEntryIterator extends SubMapIter&lt;Map.Entry&lt;K,V&gt;&gt; {
3010             public Map.Entry&lt;K,V&gt; next() {
3011                 Node&lt;K,V&gt; n = next;
3012                 V v = nextValue;
3013                 advance();
3014                 return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
3015             }
3016             public int characteristics() {
3017                 return Spliterator.DISTINCT;
3018             }
3019         }
3020     }
3021 
3022     // default Map method overrides
3023 
3024     public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
3025         if (action == null) throw new NullPointerException();
3026         Node&lt;K,V&gt; b, n; V v;
3027         if ((b = baseHead()) != null) {
3028             while ((n = b.next) != null) {
3029                 if ((v = n.val) != null)
3030                     action.accept(n.key, v);
3031                 b = n;
3032             }
3033         }
3034     }
3035 
3036     public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
3037         if (function == null) throw new NullPointerException();
3038         Node&lt;K,V&gt; b, n; V v;
3039         if ((b = baseHead()) != null) {
3040             while ((n = b.next) != null) {
3041                 while ((v = n.val) != null) {
3042                     V r = function.apply(n.key, v);
3043                     if (r == null) throw new NullPointerException();
3044                     if (VAL.compareAndSet(n, v, r))
3045                         break;
3046                 }
3047                 b = n;
3048             }
3049         }
3050     }
3051 
3052     /**
3053      * Helper method for EntrySet.removeIf.
3054      */
3055     boolean removeEntryIf(Predicate&lt;? super Entry&lt;K,V&gt;&gt; function) {
3056         if (function == null) throw new NullPointerException();
3057         boolean removed = false;
3058         Node&lt;K,V&gt; b, n; V v;
3059         if ((b = baseHead()) != null) {
3060             while ((n = b.next) != null) {
3061                 if ((v = n.val) != null) {
3062                     K k = n.key;
3063                     Map.Entry&lt;K,V&gt; e = new AbstractMap.SimpleImmutableEntry&lt;&gt;(k, v);
3064                     if (function.test(e) &amp;&amp; remove(k, v))
3065                         removed = true;
3066                 }
3067                 b = n;
3068             }
3069         }
3070         return removed;
3071     }
3072 
3073     /**
3074      * Helper method for Values.removeIf.
3075      */
3076     boolean removeValueIf(Predicate&lt;? super V&gt; function) {
3077         if (function == null) throw new NullPointerException();
3078         boolean removed = false;
3079         Node&lt;K,V&gt; b, n; V v;
3080         if ((b = baseHead()) != null) {
3081             while ((n = b.next) != null) {
3082                 if ((v = n.val) != null &amp;&amp; function.test(v) &amp;&amp; remove(n.key, v))
3083                     removed = true;
3084                 b = n;
3085             }
3086         }
3087         return removed;
3088     }
3089 
3090     /**
3091      * Base class providing common structure for Spliterators.
3092      * (Although not all that much common functionality; as usual for
3093      * view classes, details annoyingly vary in key, value, and entry
3094      * subclasses in ways that are not worth abstracting out for
3095      * internal classes.)
3096      *
3097      * The basic split strategy is to recursively descend from top
3098      * level, row by row, descending to next row when either split
3099      * off, or the end of row is encountered. Control of the number of
3100      * splits relies on some statistical estimation: The expected
3101      * remaining number of elements of a skip list when advancing
3102      * either across or down decreases by about 25%.
3103      */
3104     abstract static class CSLMSpliterator&lt;K,V&gt; {
3105         final Comparator&lt;? super K&gt; comparator;
3106         final K fence;     // exclusive upper bound for keys, or null if to end
3107         Index&lt;K,V&gt; row;    // the level to split out
3108         Node&lt;K,V&gt; current; // current traversal node; initialize at origin
3109         long est;          // size estimate
3110         CSLMSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
3111                         Node&lt;K,V&gt; origin, K fence, long est) {
3112             this.comparator = comparator; this.row = row;
3113             this.current = origin; this.fence = fence; this.est = est;
3114         }
3115 
3116         public final long estimateSize() { return est; }
3117     }
3118 
3119     static final class KeySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
3120         implements Spliterator&lt;K&gt; {
3121         KeySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
3122                        Node&lt;K,V&gt; origin, K fence, long est) {
3123             super(comparator, row, origin, fence, est);
3124         }
3125 
3126         public KeySpliterator&lt;K,V&gt; trySplit() {
3127             Node&lt;K,V&gt; e; K ek;
3128             Comparator&lt;? super K&gt; cmp = comparator;
3129             K f = fence;
3130             if ((e = current) != null &amp;&amp; (ek = e.key) != null) {
3131                 for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {
3132                     Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;
3133                     if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;
3134                         (n = b.next) != null &amp;&amp; n.val != null &amp;&amp;
3135                         (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;
3136                         (f == null || cpr(cmp, sk, f) &lt; 0)) {
3137                         current = n;
3138                         Index&lt;K,V&gt; r = q.down;
3139                         row = (s.right != null) ? s : s.down;
3140                         est -= est &gt;&gt;&gt; 2;
3141                         return new KeySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);
3142                     }
3143                 }
3144             }
3145             return null;
3146         }
3147 
3148         public void forEachRemaining(Consumer&lt;? super K&gt; action) {
3149             if (action == null) throw new NullPointerException();
3150             Comparator&lt;? super K&gt; cmp = comparator;
3151             K f = fence;
3152             Node&lt;K,V&gt; e = current;
3153             current = null;
3154             for (; e != null; e = e.next) {
3155                 K k;
3156                 if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)
3157                     break;
3158                 if (e.val != null)
3159                     action.accept(k);
3160             }
3161         }
3162 
3163         public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
3164             if (action == null) throw new NullPointerException();
3165             Comparator&lt;? super K&gt; cmp = comparator;
3166             K f = fence;
3167             Node&lt;K,V&gt; e = current;
3168             for (; e != null; e = e.next) {
3169                 K k;
3170                 if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {
3171                     e = null;
3172                     break;
3173                 }
3174                 if (e.val != null) {
3175                     current = e.next;
3176                     action.accept(k);
3177                     return true;
3178                 }
3179             }
3180             current = e;
3181             return false;
3182         }
3183 
3184         public int characteristics() {
3185             return Spliterator.DISTINCT | Spliterator.SORTED |
3186                 Spliterator.ORDERED | Spliterator.CONCURRENT |
3187                 Spliterator.NONNULL;
3188         }
3189 
3190         public final Comparator&lt;? super K&gt; getComparator() {
3191             return comparator;
3192         }
3193     }
3194     // factory method for KeySpliterator
3195     final KeySpliterator&lt;K,V&gt; keySpliterator() {
3196         Index&lt;K,V&gt; h; Node&lt;K,V&gt; n; long est;
3197         VarHandle.acquireFence();
3198         if ((h = head) == null) {
3199             n = null;
3200             est = 0L;
3201         }
3202         else {
3203             n = h.node;
3204             est = getAdderCount();
3205         }
3206         return new KeySpliterator&lt;K,V&gt;(comparator, h, n, null, est);
3207     }
3208 
3209     static final class ValueSpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
3210         implements Spliterator&lt;V&gt; {
3211         ValueSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
3212                        Node&lt;K,V&gt; origin, K fence, long est) {
3213             super(comparator, row, origin, fence, est);
3214         }
3215 
3216         public ValueSpliterator&lt;K,V&gt; trySplit() {
3217             Node&lt;K,V&gt; e; K ek;
3218             Comparator&lt;? super K&gt; cmp = comparator;
3219             K f = fence;
3220             if ((e = current) != null &amp;&amp; (ek = e.key) != null) {
3221                 for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {
3222                     Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;
3223                     if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;
3224                         (n = b.next) != null &amp;&amp; n.val != null &amp;&amp;
3225                         (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;
3226                         (f == null || cpr(cmp, sk, f) &lt; 0)) {
3227                         current = n;
3228                         Index&lt;K,V&gt; r = q.down;
3229                         row = (s.right != null) ? s : s.down;
3230                         est -= est &gt;&gt;&gt; 2;
3231                         return new ValueSpliterator&lt;K,V&gt;(cmp, r, e, sk, est);
3232                     }
3233                 }
3234             }
3235             return null;
3236         }
3237 
3238         public void forEachRemaining(Consumer&lt;? super V&gt; action) {
3239             if (action == null) throw new NullPointerException();
3240             Comparator&lt;? super K&gt; cmp = comparator;
3241             K f = fence;
3242             Node&lt;K,V&gt; e = current;
3243             current = null;
3244             for (; e != null; e = e.next) {
3245                 K k; V v;
3246                 if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)
3247                     break;
3248                 if ((v = e.val) != null)
3249                     action.accept(v);
3250             }
3251         }
3252 
3253         public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
3254             if (action == null) throw new NullPointerException();
3255             Comparator&lt;? super K&gt; cmp = comparator;
3256             K f = fence;
3257             Node&lt;K,V&gt; e = current;
3258             for (; e != null; e = e.next) {
3259                 K k; V v;
3260                 if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {
3261                     e = null;
3262                     break;
3263                 }
3264                 if ((v = e.val) != null) {
3265                     current = e.next;
3266                     action.accept(v);
3267                     return true;
3268                 }
3269             }
3270             current = e;
3271             return false;
3272         }
3273 
3274         public int characteristics() {
3275             return Spliterator.CONCURRENT | Spliterator.ORDERED |
3276                 Spliterator.NONNULL;
3277         }
3278     }
3279 
3280     // Almost the same as keySpliterator()
3281     final ValueSpliterator&lt;K,V&gt; valueSpliterator() {
3282         Index&lt;K,V&gt; h; Node&lt;K,V&gt; n; long est;
3283         VarHandle.acquireFence();
3284         if ((h = head) == null) {
3285             n = null;
3286             est = 0L;
3287         }
3288         else {
3289             n = h.node;
3290             est = getAdderCount();
3291         }
3292         return new ValueSpliterator&lt;K,V&gt;(comparator, h, n, null, est);
3293     }
3294 
3295     static final class EntrySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
3296         implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
3297         EntrySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
3298                          Node&lt;K,V&gt; origin, K fence, long est) {
3299             super(comparator, row, origin, fence, est);
3300         }
3301 
3302         public EntrySpliterator&lt;K,V&gt; trySplit() {
3303             Node&lt;K,V&gt; e; K ek;
3304             Comparator&lt;? super K&gt; cmp = comparator;
3305             K f = fence;
3306             if ((e = current) != null &amp;&amp; (ek = e.key) != null) {
3307                 for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {
3308                     Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;
3309                     if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;
3310                         (n = b.next) != null &amp;&amp; n.val != null &amp;&amp;
3311                         (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;
3312                         (f == null || cpr(cmp, sk, f) &lt; 0)) {
3313                         current = n;
3314                         Index&lt;K,V&gt; r = q.down;
3315                         row = (s.right != null) ? s : s.down;
3316                         est -= est &gt;&gt;&gt; 2;
3317                         return new EntrySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);
3318                     }
3319                 }
3320             }
3321             return null;
3322         }
3323 
3324         public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
3325             if (action == null) throw new NullPointerException();
3326             Comparator&lt;? super K&gt; cmp = comparator;
3327             K f = fence;
3328             Node&lt;K,V&gt; e = current;
3329             current = null;
3330             for (; e != null; e = e.next) {
3331                 K k; V v;
3332                 if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)
3333                     break;
3334                 if ((v = e.val) != null) {
3335                     action.accept
3336                         (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v));
3337                 }
3338             }
3339         }
3340 
3341         public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
3342             if (action == null) throw new NullPointerException();
3343             Comparator&lt;? super K&gt; cmp = comparator;
3344             K f = fence;
3345             Node&lt;K,V&gt; e = current;
3346             for (; e != null; e = e.next) {
3347                 K k; V v;
3348                 if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {
3349                     e = null;
3350                     break;
3351                 }
3352                 if ((v = e.val) != null) {
3353                     current = e.next;
3354                     action.accept
3355                         (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v));
3356                     return true;
3357                 }
3358             }
3359             current = e;
3360             return false;
3361         }
3362 
3363         public int characteristics() {
3364             return Spliterator.DISTINCT | Spliterator.SORTED |
3365                 Spliterator.ORDERED | Spliterator.CONCURRENT |
3366                 Spliterator.NONNULL;
3367         }
3368 
3369         public final Comparator&lt;Map.Entry&lt;K,V&gt;&gt; getComparator() {
3370             // Adapt or create a key-based comparator
3371             if (comparator != null) {
3372                 return Map.Entry.comparingByKey(comparator);
3373             }
3374             else {
3375                 return (Comparator&lt;Map.Entry&lt;K,V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {
3376                     @SuppressWarnings(&quot;unchecked&quot;)
3377                     Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();
3378                     return k1.compareTo(e2.getKey());
3379                 };
3380             }
3381         }
3382     }
3383 
3384     // Almost the same as keySpliterator()
3385     final EntrySpliterator&lt;K,V&gt; entrySpliterator() {
3386         Index&lt;K,V&gt; h; Node&lt;K,V&gt; n; long est;
3387         VarHandle.acquireFence();
3388         if ((h = head) == null) {
3389             n = null;
3390             est = 0L;
3391         }
3392         else {
3393             n = h.node;
3394             est = getAdderCount();
3395         }
3396         return new EntrySpliterator&lt;K,V&gt;(comparator, h, n, null, est);
3397     }
3398 
3399     // VarHandle mechanics
3400     private static final VarHandle HEAD;
3401     private static final VarHandle ADDER;
3402     private static final VarHandle NEXT;
3403     private static final VarHandle VAL;
3404     private static final VarHandle RIGHT;
3405     static {
3406         try {
3407             MethodHandles.Lookup l = MethodHandles.lookup();
3408             HEAD = l.findVarHandle(ConcurrentSkipListMap.class, &quot;head&quot;,
3409                                    Index.class);
3410             ADDER = l.findVarHandle(ConcurrentSkipListMap.class, &quot;adder&quot;,
3411                                     LongAdder.class);
3412             NEXT = l.findVarHandle(Node.class, &quot;next&quot;, Node.class);
3413             VAL = l.findVarHandle(Node.class, &quot;val&quot;, Object.class);
3414             RIGHT = l.findVarHandle(Index.class, &quot;right&quot;, Index.class);
3415         } catch (ReflectiveOperationException e) {
3416             throw new ExceptionInInitializerError(e);
3417         }
3418     }
3419 }
    </pre>
  </body>
</html>
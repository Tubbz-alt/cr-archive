<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/Heap-X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Direct-X-Buffer.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MappedByteBuffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/Heap-X-Buffer.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #warn This file is preprocessed before being compiled
 27 
 28 package java.nio;
 29 
 30 import java.util.Objects;

 31 
 32 /**
 33 #if[rw]
 34  * A read/write Heap$Type$Buffer.
 35 #else[rw]
 36  * A read-only Heap$Type$Buffer.  This class extends the corresponding
 37  * read/write class, overriding the mutation methods to throw a {@link
 38  * ReadOnlyBufferException} and overriding the view-buffer methods to return an
 39  * instance of this class rather than of the superclass.
 40 #end[rw]
 41  */
 42 
 43 class Heap$Type$Buffer$RW$
 44     extends {#if[ro]?Heap}$Type$Buffer
 45 {
 46     // Cached array base offset
 47     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);
 48 
 49     // Cached array base offset
 50     private static final long ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale($type$[].class);
 51 
 52     // For speed these fields are actually declared in X-Buffer;
 53     // these declarations are here as documentation
 54     /*
 55 #if[rw]
 56     protected final $type$[] hb;
 57     protected final int offset;
 58 #end[rw]
 59     */
 60 
<span class="line-modified"> 61     Heap$Type$Buffer$RW$(int cap, int lim) {            // package-private</span>
 62 #if[rw]
<span class="line-modified"> 63         super(-1, 0, lim, cap, new $type$[cap], 0);</span>
 64         /*
 65         hb = new $type$[cap];
 66         offset = 0;
 67         */
 68         this.address = ARRAY_BASE_OFFSET;
 69 #else[rw]
<span class="line-modified"> 70         super(cap, lim);</span>
 71         this.isReadOnly = true;
 72 #end[rw]
 73     }
 74 
<span class="line-modified"> 75     Heap$Type$Buffer$RW$($type$[] buf, int off, int len) { // package-private</span>
 76 #if[rw]
<span class="line-modified"> 77         super(-1, off, off + len, buf.length, buf, 0);</span>
 78         /*
 79         hb = buf;
 80         offset = 0;
 81         */
 82         this.address = ARRAY_BASE_OFFSET;
 83 #else[rw]
<span class="line-modified"> 84         super(buf, off, len);</span>
 85         this.isReadOnly = true;
 86 #end[rw]
 87     }
 88 
 89     protected Heap$Type$Buffer$RW$($type$[] buf,
 90                                    int mark, int pos, int lim, int cap,
<span class="line-modified"> 91                                    int off)</span>
 92     {
 93 #if[rw]
<span class="line-modified"> 94         super(mark, pos, lim, cap, buf, off);</span>
 95         /*
 96         hb = buf;
 97         offset = off;
 98         */
 99         this.address = ARRAY_BASE_OFFSET + off * ARRAY_INDEX_SCALE;
100 #else[rw]
<span class="line-modified">101         super(buf, mark, pos, lim, cap, off);</span>
102         this.isReadOnly = true;
103 #end[rw]
104     }
105 
106     public $Type$Buffer slice() {
107         int rem = this.remaining();
108         return new Heap$Type$Buffer$RW$(hb,
109                                         -1,
110                                         0,
111                                         rem,
112                                         rem,
<span class="line-modified">113                                         this.position() + offset);</span>
114     }
115 
116     @Override
117     public $Type$Buffer slice(int index, int length) {
118         Objects.checkFromIndexSize(index, length, limit());
119         return new Heap$Type$Buffer$RW$(hb,
120                                         -1,
121                                         0,
122                                         length,
123                                         length,
<span class="line-modified">124                                         index + offset);</span>
125     }
126 
127     public $Type$Buffer duplicate() {
128         return new Heap$Type$Buffer$RW$(hb,
129                                         this.markValue(),
130                                         this.position(),
131                                         this.limit(),
132                                         this.capacity(),
<span class="line-modified">133                                         offset);</span>
134     }
135 
136     public $Type$Buffer asReadOnlyBuffer() {
137 #if[rw]
138         return new Heap$Type$BufferR(hb,
139                                      this.markValue(),
140                                      this.position(),
141                                      this.limit(),
142                                      this.capacity(),
<span class="line-modified">143                                      offset);</span>
144 #else[rw]
145         return duplicate();
146 #end[rw]
147     }
148 
149 #if[rw]
150 
151     protected int ix(int i) {
152         return i + offset;
153     }
154 
155 #if[byte]
156     private long byteOffset(long i) {
157         return address + i;
158     }
159 #end[byte]
160 
161     public $type$ get() {

162         return hb[ix(nextGetIndex())];
163     }
164 
165     public $type$ get(int i) {

166         return hb[ix(checkIndex(i))];
167     }
168 
169 #if[streamableType]
170     $type$ getUnchecked(int i) {
<span class="line-modified">171 	return hb[ix(i)];</span>
172     }
173 #end[streamableType]
174 
175     public $Type$Buffer get($type$[] dst, int offset, int length) {
<span class="line-modified">176         checkBounds(offset, length, dst.length);</span>

177         int pos = position();
178         if (length &gt; limit() - pos)
179             throw new BufferUnderflowException();
180         System.arraycopy(hb, ix(pos), dst, offset, length);
181         position(pos + length);
182         return this;
183     }
184 
185     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {

186         Objects.checkFromIndexSize(index, length, limit());
187         Objects.checkFromIndexSize(offset, length, dst.length);
188         System.arraycopy(hb, ix(index), dst, offset, length);
189         return this;
190     }
191 
192     public boolean isDirect() {
193         return false;
194     }
195 
196 #end[rw]
197 
198     public boolean isReadOnly() {
199         return {#if[rw]?false:true};
200     }
201 
202     public $Type$Buffer put($type$ x) {
203 #if[rw]

204         hb[ix(nextPutIndex())] = x;
205         return this;
206 #else[rw]
207         throw new ReadOnlyBufferException();
208 #end[rw]
209     }
210 
211     public $Type$Buffer put(int i, $type$ x) {
212 #if[rw]

213         hb[ix(checkIndex(i))] = x;
214         return this;
215 #else[rw]
216         throw new ReadOnlyBufferException();
217 #end[rw]
218     }
219 
220     public $Type$Buffer put($type$[] src, int offset, int length) {
221 #if[rw]
<span class="line-modified">222         checkBounds(offset, length, src.length);</span>

223         int pos = position();
224         if (length &gt; limit() - pos)
225             throw new BufferOverflowException();
226         System.arraycopy(src, offset, hb, ix(pos), length);
227         position(pos + length);
228         return this;
229 #else[rw]
230         throw new ReadOnlyBufferException();
231 #end[rw]
232     }
233 
234     public $Type$Buffer put($Type$Buffer src) {
235 #if[rw]

236         if (src instanceof Heap$Type$Buffer) {
237             if (src == this)
238                 throw createSameBufferException();
239             Heap$Type$Buffer sb = (Heap$Type$Buffer)src;
240             int pos = position();
241             int sbpos = sb.position();
242             int n = sb.limit() - sbpos;
243             if (n &gt; limit() - pos)
244                 throw new BufferOverflowException();
245             System.arraycopy(sb.hb, sb.ix(sbpos),
246                              hb, ix(pos), n);
247             sb.position(sbpos + n);
248             position(pos + n);
249         } else if (src.isDirect()) {
250             int n = src.remaining();
251             int pos = position();
252             if (n &gt; limit() - pos)
253                 throw new BufferOverflowException();
254             src.get(hb, ix(pos), n);
255             position(pos + n);
256         } else {
257             super.put(src);
258         }
259         return this;
260 #else[rw]
261         throw new ReadOnlyBufferException();
262 #end[rw]
263     }
264 
265     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
266 #if[rw]

267         Objects.checkFromIndexSize(index, length, limit());
268         Objects.checkFromIndexSize(offset, length, src.length);
269         System.arraycopy(src, offset, hb, ix(index), length);
270         return this;
271 #else[rw]
272         throw new ReadOnlyBufferException();
273 #end[rw]
274     }
275 
276 #if[char]
277 
278     public $Type$Buffer put(String src, int start, int end) {

279         int length = end - start;
<span class="line-modified">280         checkBounds(start, length, src.length());</span>
281         if (isReadOnly())
282             throw new ReadOnlyBufferException();
283         int pos = position();
284         int lim = limit();
285         int rem = (pos &lt;= lim) ? lim - pos : 0;
286         if (length &gt; rem)
287             throw new BufferOverflowException();
288         src.getChars(start, end, hb, ix(pos));
289         position(pos + length);
290         return this;
291     }
292 
293 #end[char]
294 
295     public $Type$Buffer compact() {
296 #if[rw]
297         int pos = position();
298         int rem = limit() - pos;
299         System.arraycopy(hb, ix(pos), hb, ix(0), rem);
300         position(rem);
</pre>
<hr />
<pre>
310 
311 #if[byte]
312 
313     byte _get(int i) {                          // package-private
314         return hb[i];
315     }
316 
317     void _put(int i, byte b) {                  // package-private
318 #if[rw]
319         hb[i] = b;
320 #else[rw]
321         throw new ReadOnlyBufferException();
322 #end[rw]
323     }
324 
325     // char
326 
327 #if[rw]
328 
329     public char getChar() {

330         return UNSAFE.getCharUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);
331     }
332 
333     public char getChar(int i) {
334         return UNSAFE.getCharUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);
335     }
336 
337 #end[rw]
338 
339     public $Type$Buffer putChar(char x) {
340 #if[rw]

341         UNSAFE.putCharUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);
342         return this;
343 #else[rw]
344         throw new ReadOnlyBufferException();
345 #end[rw]
346     }
347 
348     public $Type$Buffer putChar(int i, char x) {
349 #if[rw]

350         UNSAFE.putCharUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
351         return this;
352 #else[rw]
353         throw new ReadOnlyBufferException();
354 #end[rw]
355     }
356 
357     public CharBuffer asCharBuffer() {
358         int pos = position();
359         int size = (limit() - pos) &gt;&gt; 1;
360         long addr = address + pos;
361         return (bigEndian
362                 ? (CharBuffer)(new ByteBufferAsCharBuffer$RW$B(this,
363                                                                -1,
364                                                                0,
365                                                                size,
366                                                                size,
<span class="line-modified">367                                                                addr))</span>
368                 : (CharBuffer)(new ByteBufferAsCharBuffer$RW$L(this,
369                                                                -1,
370                                                                0,
371                                                                size,
372                                                                size,
<span class="line-modified">373                                                                addr)));</span>
374     }
375 
376 
377     // short
378 
379 #if[rw]
380 
381     public short getShort() {

382         return UNSAFE.getShortUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);
383     }
384 
385     public short getShort(int i) {

386         return UNSAFE.getShortUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);
387     }
388 
389 #end[rw]
390 
391     public $Type$Buffer putShort(short x) {
392 #if[rw]

393         UNSAFE.putShortUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);
394         return this;
395 #else[rw]
396         throw new ReadOnlyBufferException();
397 #end[rw]
398     }
399 
400     public $Type$Buffer putShort(int i, short x) {
401 #if[rw]

402         UNSAFE.putShortUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
403         return this;
404 #else[rw]
405         throw new ReadOnlyBufferException();
406 #end[rw]
407     }
408 
409     public ShortBuffer asShortBuffer() {
410         int pos = position();
411         int size = (limit() - pos) &gt;&gt; 1;
412         long addr = address + pos;
413         return (bigEndian
414                 ? (ShortBuffer)(new ByteBufferAsShortBuffer$RW$B(this,
415                                                                  -1,
416                                                                  0,
417                                                                  size,
418                                                                  size,
<span class="line-modified">419                                                                  addr))</span>
420                 : (ShortBuffer)(new ByteBufferAsShortBuffer$RW$L(this,
421                                                                  -1,
422                                                                  0,
423                                                                  size,
424                                                                  size,
<span class="line-modified">425                                                                  addr)));</span>
426     }
427 
428 
429     // int
430 
431 #if[rw]
432 
433     public int getInt() {

434         return UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);
435     }
436 
437     public int getInt(int i) {

438         return UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);
439     }
440 
441 #end[rw]
442 
443     public $Type$Buffer putInt(int x) {
444 #if[rw]

445         UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), x, bigEndian);
446         return this;
447 #else[rw]
448         throw new ReadOnlyBufferException();
449 #end[rw]
450     }
451 
452     public $Type$Buffer putInt(int i, int x) {
453 #if[rw]

454         UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), x, bigEndian);
455         return this;
456 #else[rw]
457         throw new ReadOnlyBufferException();
458 #end[rw]
459     }
460 
461     public IntBuffer asIntBuffer() {
462         int pos = position();
463         int size = (limit() - pos) &gt;&gt; 2;
464         long addr = address + pos;
465         return (bigEndian
466                 ? (IntBuffer)(new ByteBufferAsIntBuffer$RW$B(this,
467                                                              -1,
468                                                              0,
469                                                              size,
470                                                              size,
<span class="line-modified">471                                                              addr))</span>
472                 : (IntBuffer)(new ByteBufferAsIntBuffer$RW$L(this,
473                                                              -1,
474                                                              0,
475                                                              size,
476                                                              size,
<span class="line-modified">477                                                              addr)));</span>
478     }
479 
480 
481     // long
482 
483 #if[rw]
484 
485     public long getLong() {

486         return UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);
487     }
488 
489     public long getLong(int i) {

490         return UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);
491     }
492 
493 #end[rw]
494 
495     public $Type$Buffer putLong(long x) {
496 #if[rw]

497         UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), x, bigEndian);
498         return this;
499 #else[rw]
500         throw new ReadOnlyBufferException();
501 #end[rw]
502     }
503 
504     public $Type$Buffer putLong(int i, long x) {
505 #if[rw]

506         UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), x, bigEndian);
507         return this;
508 #else[rw]
509         throw new ReadOnlyBufferException();
510 #end[rw]
511     }
512 
513     public LongBuffer asLongBuffer() {
514         int pos = position();
515         int size = (limit() - pos) &gt;&gt; 3;
516         long addr = address + pos;
517         return (bigEndian
518                 ? (LongBuffer)(new ByteBufferAsLongBuffer$RW$B(this,
519                                                                -1,
520                                                                0,
521                                                                size,
522                                                                size,
<span class="line-modified">523                                                                addr))</span>
524                 : (LongBuffer)(new ByteBufferAsLongBuffer$RW$L(this,
525                                                                -1,
526                                                                0,
527                                                                size,
528                                                                size,
<span class="line-modified">529                                                                addr)));</span>
530     }
531 
532 
533     // float
534 
535 #if[rw]
536 
537     public float getFloat() {

538         int x = UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);
539         return Float.intBitsToFloat(x);
540     }
541 
542     public float getFloat(int i) {

543         int x = UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);
544         return Float.intBitsToFloat(x);
545     }
546 
547 #end[rw]
548 
549     public $Type$Buffer putFloat(float x) {
550 #if[rw]

551         int y = Float.floatToRawIntBits(x);
552         UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), y, bigEndian);
553         return this;
554 #else[rw]
555         throw new ReadOnlyBufferException();
556 #end[rw]
557     }
558 
559     public $Type$Buffer putFloat(int i, float x) {
560 #if[rw]

561         int y = Float.floatToRawIntBits(x);
562         UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), y, bigEndian);
563         return this;
564 #else[rw]
565         throw new ReadOnlyBufferException();
566 #end[rw]
567     }
568 
569     public FloatBuffer asFloatBuffer() {
570         int pos = position();
571         int size = (limit() - pos) &gt;&gt; 2;
572         long addr = address + pos;
573         return (bigEndian
574                 ? (FloatBuffer)(new ByteBufferAsFloatBuffer$RW$B(this,
575                                                                  -1,
576                                                                  0,
577                                                                  size,
578                                                                  size,
<span class="line-modified">579                                                                  addr))</span>
580                 : (FloatBuffer)(new ByteBufferAsFloatBuffer$RW$L(this,
581                                                                  -1,
582                                                                  0,
583                                                                  size,
584                                                                  size,
<span class="line-modified">585                                                                  addr)));</span>
586     }
587 
588 
589     // double
590 
591 #if[rw]
592 
593     public double getDouble() {

594         long x = UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);
595         return Double.longBitsToDouble(x);
596     }
597 
598     public double getDouble(int i) {

599         long x = UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);
600         return Double.longBitsToDouble(x);
601     }
602 
603 #end[rw]
604 
605     public $Type$Buffer putDouble(double x) {
606 #if[rw]

607         long y = Double.doubleToRawLongBits(x);
608         UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), y, bigEndian);
609         return this;
610 #else[rw]
611         throw new ReadOnlyBufferException();
612 #end[rw]
613     }
614 
615     public $Type$Buffer putDouble(int i, double x) {
616 #if[rw]

617         long y = Double.doubleToRawLongBits(x);
618         UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), y, bigEndian);
619         return this;
620 #else[rw]
621         throw new ReadOnlyBufferException();
622 #end[rw]
623     }
624 
625     public DoubleBuffer asDoubleBuffer() {
626         int pos = position();
627         int size = (limit() - pos) &gt;&gt; 3;
628         long addr = address + pos;
629         return (bigEndian
630                 ? (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$B(this,
631                                                                    -1,
632                                                                    0,
633                                                                    size,
634                                                                    size,
<span class="line-modified">635                                                                    addr))</span>
636                 : (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$L(this,
637                                                                    -1,
638                                                                    0,
639                                                                    size,
640                                                                    size,
<span class="line-modified">641                                                                    addr)));</span>
642     }
643 
644 
645 #end[byte]
646 
647 
648 #if[char]
649 
650     String toString(int start, int end) {               // package-private
651         try {
652             return new String(hb, start + offset, end - start);
653         } catch (StringIndexOutOfBoundsException x) {
654             throw new IndexOutOfBoundsException();
655         }
656     }
657 
658 
659     // --- Methods to support CharSequence ---
660 
661     public CharBuffer subSequence(int start, int end) {
<span class="line-removed">662         if ((start &lt; 0)</span>
<span class="line-removed">663             || (end &gt; length())</span>
<span class="line-removed">664             || (start &gt; end))</span>
<span class="line-removed">665             throw new IndexOutOfBoundsException();</span>
666         int pos = position();

667         return new HeapCharBuffer$RW$(hb,
668                                       -1,
669                                       pos + start,
670                                       pos + end,
671                                       capacity(),
<span class="line-modified">672                                       offset);</span>
673     }
674 
675 #end[char]
676 
677 
678 #if[!byte]
679 
680     public ByteOrder order() {
681         return ByteOrder.nativeOrder();
682     }
683 #end[!byte]
684 #if[char]
685 
686     ByteOrder charRegionOrder() {
687         return order();
688     }
689 #end[char]
690 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #warn This file is preprocessed before being compiled
 27 
 28 package java.nio;
 29 
 30 import java.util.Objects;
<span class="line-added"> 31 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
 32 
 33 /**
 34 #if[rw]
 35  * A read/write Heap$Type$Buffer.
 36 #else[rw]
 37  * A read-only Heap$Type$Buffer.  This class extends the corresponding
 38  * read/write class, overriding the mutation methods to throw a {@link
 39  * ReadOnlyBufferException} and overriding the view-buffer methods to return an
 40  * instance of this class rather than of the superclass.
 41 #end[rw]
 42  */
 43 
 44 class Heap$Type$Buffer$RW$
 45     extends {#if[ro]?Heap}$Type$Buffer
 46 {
 47     // Cached array base offset
 48     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);
 49 
 50     // Cached array base offset
 51     private static final long ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale($type$[].class);
 52 
 53     // For speed these fields are actually declared in X-Buffer;
 54     // these declarations are here as documentation
 55     /*
 56 #if[rw]
 57     protected final $type$[] hb;
 58     protected final int offset;
 59 #end[rw]
 60     */
 61 
<span class="line-modified"> 62     Heap$Type$Buffer$RW$(int cap, int lim, MemorySegmentProxy segment) {            // package-private</span>
 63 #if[rw]
<span class="line-modified"> 64         super(-1, 0, lim, cap, new $type$[cap], 0, segment);</span>
 65         /*
 66         hb = new $type$[cap];
 67         offset = 0;
 68         */
 69         this.address = ARRAY_BASE_OFFSET;
 70 #else[rw]
<span class="line-modified"> 71         super(cap, lim, segment);</span>
 72         this.isReadOnly = true;
 73 #end[rw]
 74     }
 75 
<span class="line-modified"> 76     Heap$Type$Buffer$RW$($type$[] buf, int off, int len, MemorySegmentProxy segment) { // package-private</span>
 77 #if[rw]
<span class="line-modified"> 78         super(-1, off, off + len, buf.length, buf, 0, segment);</span>
 79         /*
 80         hb = buf;
 81         offset = 0;
 82         */
 83         this.address = ARRAY_BASE_OFFSET;
 84 #else[rw]
<span class="line-modified"> 85         super(buf, off, len, segment);</span>
 86         this.isReadOnly = true;
 87 #end[rw]
 88     }
 89 
 90     protected Heap$Type$Buffer$RW$($type$[] buf,
 91                                    int mark, int pos, int lim, int cap,
<span class="line-modified"> 92                                    int off, MemorySegmentProxy segment)</span>
 93     {
 94 #if[rw]
<span class="line-modified"> 95         super(mark, pos, lim, cap, buf, off, segment);</span>
 96         /*
 97         hb = buf;
 98         offset = off;
 99         */
100         this.address = ARRAY_BASE_OFFSET + off * ARRAY_INDEX_SCALE;
101 #else[rw]
<span class="line-modified">102         super(buf, mark, pos, lim, cap, off, segment);</span>
103         this.isReadOnly = true;
104 #end[rw]
105     }
106 
107     public $Type$Buffer slice() {
108         int rem = this.remaining();
109         return new Heap$Type$Buffer$RW$(hb,
110                                         -1,
111                                         0,
112                                         rem,
113                                         rem,
<span class="line-modified">114                                         this.position() + offset, segment);</span>
115     }
116 
117     @Override
118     public $Type$Buffer slice(int index, int length) {
119         Objects.checkFromIndexSize(index, length, limit());
120         return new Heap$Type$Buffer$RW$(hb,
121                                         -1,
122                                         0,
123                                         length,
124                                         length,
<span class="line-modified">125                                         index + offset, segment);</span>
126     }
127 
128     public $Type$Buffer duplicate() {
129         return new Heap$Type$Buffer$RW$(hb,
130                                         this.markValue(),
131                                         this.position(),
132                                         this.limit(),
133                                         this.capacity(),
<span class="line-modified">134                                         offset, segment);</span>
135     }
136 
137     public $Type$Buffer asReadOnlyBuffer() {
138 #if[rw]
139         return new Heap$Type$BufferR(hb,
140                                      this.markValue(),
141                                      this.position(),
142                                      this.limit(),
143                                      this.capacity(),
<span class="line-modified">144                                      offset, segment);</span>
145 #else[rw]
146         return duplicate();
147 #end[rw]
148     }
149 
150 #if[rw]
151 
152     protected int ix(int i) {
153         return i + offset;
154     }
155 
156 #if[byte]
157     private long byteOffset(long i) {
158         return address + i;
159     }
160 #end[byte]
161 
162     public $type$ get() {
<span class="line-added">163         checkSegment();</span>
164         return hb[ix(nextGetIndex())];
165     }
166 
167     public $type$ get(int i) {
<span class="line-added">168         checkSegment();</span>
169         return hb[ix(checkIndex(i))];
170     }
171 
172 #if[streamableType]
173     $type$ getUnchecked(int i) {
<span class="line-modified">174     return hb[ix(i)];</span>
175     }
176 #end[streamableType]
177 
178     public $Type$Buffer get($type$[] dst, int offset, int length) {
<span class="line-modified">179         checkSegment();</span>
<span class="line-added">180         Objects.checkFromIndexSize(offset, length, dst.length);</span>
181         int pos = position();
182         if (length &gt; limit() - pos)
183             throw new BufferUnderflowException();
184         System.arraycopy(hb, ix(pos), dst, offset, length);
185         position(pos + length);
186         return this;
187     }
188 
189     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
<span class="line-added">190         checkSegment();</span>
191         Objects.checkFromIndexSize(index, length, limit());
192         Objects.checkFromIndexSize(offset, length, dst.length);
193         System.arraycopy(hb, ix(index), dst, offset, length);
194         return this;
195     }
196 
197     public boolean isDirect() {
198         return false;
199     }
200 
201 #end[rw]
202 
203     public boolean isReadOnly() {
204         return {#if[rw]?false:true};
205     }
206 
207     public $Type$Buffer put($type$ x) {
208 #if[rw]
<span class="line-added">209         checkSegment();</span>
210         hb[ix(nextPutIndex())] = x;
211         return this;
212 #else[rw]
213         throw new ReadOnlyBufferException();
214 #end[rw]
215     }
216 
217     public $Type$Buffer put(int i, $type$ x) {
218 #if[rw]
<span class="line-added">219         checkSegment();</span>
220         hb[ix(checkIndex(i))] = x;
221         return this;
222 #else[rw]
223         throw new ReadOnlyBufferException();
224 #end[rw]
225     }
226 
227     public $Type$Buffer put($type$[] src, int offset, int length) {
228 #if[rw]
<span class="line-modified">229         checkSegment();</span>
<span class="line-added">230         Objects.checkFromIndexSize(offset, length, src.length);</span>
231         int pos = position();
232         if (length &gt; limit() - pos)
233             throw new BufferOverflowException();
234         System.arraycopy(src, offset, hb, ix(pos), length);
235         position(pos + length);
236         return this;
237 #else[rw]
238         throw new ReadOnlyBufferException();
239 #end[rw]
240     }
241 
242     public $Type$Buffer put($Type$Buffer src) {
243 #if[rw]
<span class="line-added">244         checkSegment();</span>
245         if (src instanceof Heap$Type$Buffer) {
246             if (src == this)
247                 throw createSameBufferException();
248             Heap$Type$Buffer sb = (Heap$Type$Buffer)src;
249             int pos = position();
250             int sbpos = sb.position();
251             int n = sb.limit() - sbpos;
252             if (n &gt; limit() - pos)
253                 throw new BufferOverflowException();
254             System.arraycopy(sb.hb, sb.ix(sbpos),
255                              hb, ix(pos), n);
256             sb.position(sbpos + n);
257             position(pos + n);
258         } else if (src.isDirect()) {
259             int n = src.remaining();
260             int pos = position();
261             if (n &gt; limit() - pos)
262                 throw new BufferOverflowException();
263             src.get(hb, ix(pos), n);
264             position(pos + n);
265         } else {
266             super.put(src);
267         }
268         return this;
269 #else[rw]
270         throw new ReadOnlyBufferException();
271 #end[rw]
272     }
273 
274     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
275 #if[rw]
<span class="line-added">276         checkSegment();</span>
277         Objects.checkFromIndexSize(index, length, limit());
278         Objects.checkFromIndexSize(offset, length, src.length);
279         System.arraycopy(src, offset, hb, ix(index), length);
280         return this;
281 #else[rw]
282         throw new ReadOnlyBufferException();
283 #end[rw]
284     }
285 
286 #if[char]
287 
288     public $Type$Buffer put(String src, int start, int end) {
<span class="line-added">289         checkSegment();</span>
290         int length = end - start;
<span class="line-modified">291         Objects.checkFromIndexSize(start, length, src.length());</span>
292         if (isReadOnly())
293             throw new ReadOnlyBufferException();
294         int pos = position();
295         int lim = limit();
296         int rem = (pos &lt;= lim) ? lim - pos : 0;
297         if (length &gt; rem)
298             throw new BufferOverflowException();
299         src.getChars(start, end, hb, ix(pos));
300         position(pos + length);
301         return this;
302     }
303 
304 #end[char]
305 
306     public $Type$Buffer compact() {
307 #if[rw]
308         int pos = position();
309         int rem = limit() - pos;
310         System.arraycopy(hb, ix(pos), hb, ix(0), rem);
311         position(rem);
</pre>
<hr />
<pre>
321 
322 #if[byte]
323 
324     byte _get(int i) {                          // package-private
325         return hb[i];
326     }
327 
328     void _put(int i, byte b) {                  // package-private
329 #if[rw]
330         hb[i] = b;
331 #else[rw]
332         throw new ReadOnlyBufferException();
333 #end[rw]
334     }
335 
336     // char
337 
338 #if[rw]
339 
340     public char getChar() {
<span class="line-added">341         checkSegment();</span>
342         return UNSAFE.getCharUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);
343     }
344 
345     public char getChar(int i) {
346         return UNSAFE.getCharUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);
347     }
348 
349 #end[rw]
350 
351     public $Type$Buffer putChar(char x) {
352 #if[rw]
<span class="line-added">353         checkSegment();</span>
354         UNSAFE.putCharUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);
355         return this;
356 #else[rw]
357         throw new ReadOnlyBufferException();
358 #end[rw]
359     }
360 
361     public $Type$Buffer putChar(int i, char x) {
362 #if[rw]
<span class="line-added">363         checkSegment();</span>
364         UNSAFE.putCharUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
365         return this;
366 #else[rw]
367         throw new ReadOnlyBufferException();
368 #end[rw]
369     }
370 
371     public CharBuffer asCharBuffer() {
372         int pos = position();
373         int size = (limit() - pos) &gt;&gt; 1;
374         long addr = address + pos;
375         return (bigEndian
376                 ? (CharBuffer)(new ByteBufferAsCharBuffer$RW$B(this,
377                                                                -1,
378                                                                0,
379                                                                size,
380                                                                size,
<span class="line-modified">381                                                                addr, segment))</span>
382                 : (CharBuffer)(new ByteBufferAsCharBuffer$RW$L(this,
383                                                                -1,
384                                                                0,
385                                                                size,
386                                                                size,
<span class="line-modified">387                                                                addr, segment)));</span>
388     }
389 
390 
391     // short
392 
393 #if[rw]
394 
395     public short getShort() {
<span class="line-added">396         checkSegment();</span>
397         return UNSAFE.getShortUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);
398     }
399 
400     public short getShort(int i) {
<span class="line-added">401         checkSegment();</span>
402         return UNSAFE.getShortUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);
403     }
404 
405 #end[rw]
406 
407     public $Type$Buffer putShort(short x) {
408 #if[rw]
<span class="line-added">409         checkSegment();</span>
410         UNSAFE.putShortUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);
411         return this;
412 #else[rw]
413         throw new ReadOnlyBufferException();
414 #end[rw]
415     }
416 
417     public $Type$Buffer putShort(int i, short x) {
418 #if[rw]
<span class="line-added">419         checkSegment();</span>
420         UNSAFE.putShortUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
421         return this;
422 #else[rw]
423         throw new ReadOnlyBufferException();
424 #end[rw]
425     }
426 
427     public ShortBuffer asShortBuffer() {
428         int pos = position();
429         int size = (limit() - pos) &gt;&gt; 1;
430         long addr = address + pos;
431         return (bigEndian
432                 ? (ShortBuffer)(new ByteBufferAsShortBuffer$RW$B(this,
433                                                                  -1,
434                                                                  0,
435                                                                  size,
436                                                                  size,
<span class="line-modified">437                                                                  addr, segment))</span>
438                 : (ShortBuffer)(new ByteBufferAsShortBuffer$RW$L(this,
439                                                                  -1,
440                                                                  0,
441                                                                  size,
442                                                                  size,
<span class="line-modified">443                                                                  addr, segment)));</span>
444     }
445 
446 
447     // int
448 
449 #if[rw]
450 
451     public int getInt() {
<span class="line-added">452         checkSegment();</span>
453         return UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);
454     }
455 
456     public int getInt(int i) {
<span class="line-added">457         checkSegment();</span>
458         return UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);
459     }
460 
461 #end[rw]
462 
463     public $Type$Buffer putInt(int x) {
464 #if[rw]
<span class="line-added">465         checkSegment();</span>
466         UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), x, bigEndian);
467         return this;
468 #else[rw]
469         throw new ReadOnlyBufferException();
470 #end[rw]
471     }
472 
473     public $Type$Buffer putInt(int i, int x) {
474 #if[rw]
<span class="line-added">475         checkSegment();</span>
476         UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), x, bigEndian);
477         return this;
478 #else[rw]
479         throw new ReadOnlyBufferException();
480 #end[rw]
481     }
482 
483     public IntBuffer asIntBuffer() {
484         int pos = position();
485         int size = (limit() - pos) &gt;&gt; 2;
486         long addr = address + pos;
487         return (bigEndian
488                 ? (IntBuffer)(new ByteBufferAsIntBuffer$RW$B(this,
489                                                              -1,
490                                                              0,
491                                                              size,
492                                                              size,
<span class="line-modified">493                                                              addr, segment))</span>
494                 : (IntBuffer)(new ByteBufferAsIntBuffer$RW$L(this,
495                                                              -1,
496                                                              0,
497                                                              size,
498                                                              size,
<span class="line-modified">499                                                              addr, segment)));</span>
500     }
501 
502 
503     // long
504 
505 #if[rw]
506 
507     public long getLong() {
<span class="line-added">508         checkSegment();</span>
509         return UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);
510     }
511 
512     public long getLong(int i) {
<span class="line-added">513         checkSegment();</span>
514         return UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);
515     }
516 
517 #end[rw]
518 
519     public $Type$Buffer putLong(long x) {
520 #if[rw]
<span class="line-added">521         checkSegment();</span>
522         UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), x, bigEndian);
523         return this;
524 #else[rw]
525         throw new ReadOnlyBufferException();
526 #end[rw]
527     }
528 
529     public $Type$Buffer putLong(int i, long x) {
530 #if[rw]
<span class="line-added">531         checkSegment();</span>
532         UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), x, bigEndian);
533         return this;
534 #else[rw]
535         throw new ReadOnlyBufferException();
536 #end[rw]
537     }
538 
539     public LongBuffer asLongBuffer() {
540         int pos = position();
541         int size = (limit() - pos) &gt;&gt; 3;
542         long addr = address + pos;
543         return (bigEndian
544                 ? (LongBuffer)(new ByteBufferAsLongBuffer$RW$B(this,
545                                                                -1,
546                                                                0,
547                                                                size,
548                                                                size,
<span class="line-modified">549                                                                addr, segment))</span>
550                 : (LongBuffer)(new ByteBufferAsLongBuffer$RW$L(this,
551                                                                -1,
552                                                                0,
553                                                                size,
554                                                                size,
<span class="line-modified">555                                                                addr, segment)));</span>
556     }
557 
558 
559     // float
560 
561 #if[rw]
562 
563     public float getFloat() {
<span class="line-added">564         checkSegment();</span>
565         int x = UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);
566         return Float.intBitsToFloat(x);
567     }
568 
569     public float getFloat(int i) {
<span class="line-added">570         checkSegment();</span>
571         int x = UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);
572         return Float.intBitsToFloat(x);
573     }
574 
575 #end[rw]
576 
577     public $Type$Buffer putFloat(float x) {
578 #if[rw]
<span class="line-added">579         checkSegment();</span>
580         int y = Float.floatToRawIntBits(x);
581         UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), y, bigEndian);
582         return this;
583 #else[rw]
584         throw new ReadOnlyBufferException();
585 #end[rw]
586     }
587 
588     public $Type$Buffer putFloat(int i, float x) {
589 #if[rw]
<span class="line-added">590         checkSegment();</span>
591         int y = Float.floatToRawIntBits(x);
592         UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), y, bigEndian);
593         return this;
594 #else[rw]
595         throw new ReadOnlyBufferException();
596 #end[rw]
597     }
598 
599     public FloatBuffer asFloatBuffer() {
600         int pos = position();
601         int size = (limit() - pos) &gt;&gt; 2;
602         long addr = address + pos;
603         return (bigEndian
604                 ? (FloatBuffer)(new ByteBufferAsFloatBuffer$RW$B(this,
605                                                                  -1,
606                                                                  0,
607                                                                  size,
608                                                                  size,
<span class="line-modified">609                                                                  addr, segment))</span>
610                 : (FloatBuffer)(new ByteBufferAsFloatBuffer$RW$L(this,
611                                                                  -1,
612                                                                  0,
613                                                                  size,
614                                                                  size,
<span class="line-modified">615                                                                  addr, segment)));</span>
616     }
617 
618 
619     // double
620 
621 #if[rw]
622 
623     public double getDouble() {
<span class="line-added">624         checkSegment();</span>
625         long x = UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);
626         return Double.longBitsToDouble(x);
627     }
628 
629     public double getDouble(int i) {
<span class="line-added">630         checkSegment();</span>
631         long x = UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);
632         return Double.longBitsToDouble(x);
633     }
634 
635 #end[rw]
636 
637     public $Type$Buffer putDouble(double x) {
638 #if[rw]
<span class="line-added">639         checkSegment();</span>
640         long y = Double.doubleToRawLongBits(x);
641         UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), y, bigEndian);
642         return this;
643 #else[rw]
644         throw new ReadOnlyBufferException();
645 #end[rw]
646     }
647 
648     public $Type$Buffer putDouble(int i, double x) {
649 #if[rw]
<span class="line-added">650         checkSegment();</span>
651         long y = Double.doubleToRawLongBits(x);
652         UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), y, bigEndian);
653         return this;
654 #else[rw]
655         throw new ReadOnlyBufferException();
656 #end[rw]
657     }
658 
659     public DoubleBuffer asDoubleBuffer() {
660         int pos = position();
661         int size = (limit() - pos) &gt;&gt; 3;
662         long addr = address + pos;
663         return (bigEndian
664                 ? (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$B(this,
665                                                                    -1,
666                                                                    0,
667                                                                    size,
668                                                                    size,
<span class="line-modified">669                                                                    addr, segment))</span>
670                 : (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$L(this,
671                                                                    -1,
672                                                                    0,
673                                                                    size,
674                                                                    size,
<span class="line-modified">675                                                                    addr, segment)));</span>
676     }
677 
678 
679 #end[byte]
680 
681 
682 #if[char]
683 
684     String toString(int start, int end) {               // package-private
685         try {
686             return new String(hb, start + offset, end - start);
687         } catch (StringIndexOutOfBoundsException x) {
688             throw new IndexOutOfBoundsException();
689         }
690     }
691 
692 
693     // --- Methods to support CharSequence ---
694 
695     public CharBuffer subSequence(int start, int end) {




696         int pos = position();
<span class="line-added">697         Objects.checkFromToIndex(start, end, limit() - pos);</span>
698         return new HeapCharBuffer$RW$(hb,
699                                       -1,
700                                       pos + start,
701                                       pos + end,
702                                       capacity(),
<span class="line-modified">703                                       offset, segment);</span>
704     }
705 
706 #end[char]
707 
708 
709 #if[!byte]
710 
711     public ByteOrder order() {
712         return ByteOrder.nativeOrder();
713     }
714 #end[!byte]
715 #if[char]
716 
717     ByteOrder charRegionOrder() {
718         return order();
719     }
720 #end[char]
721 }
</pre>
</td>
</tr>
</table>
<center><a href="Direct-X-Buffer.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MappedByteBuffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Long.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="LiveStackFrame.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Math.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Long.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 396,33 ***</span>
              return new String(buf, UTF16);
          }
      }
  
      /**
<span class="line-modified">!      * Format a long (treated as unsigned) into a character buffer. If</span>
       * {@code len} exceeds the formatted ASCII representation of {@code val},
       * {@code buf} will be padded with leading zeroes.
       *
       * @param val the unsigned long to format
       * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified">!      * @param buf the character buffer to write to</span>
       * @param offset the offset in the destination buffer to start at
       * @param len the number of characters to write
       */
<span class="line-modified">! </span>
<span class="line-removed">-     /** byte[]/LATIN1 version    */</span>
<span class="line-removed">-     static void formatUnsignedLong0(long val, int shift, byte[] buf, int offset, int len) {</span>
          int charPos = offset + len;
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              buf[--charPos] = (byte)Integer.digits[((int) val) &amp; mask];
              val &gt;&gt;&gt;= shift;
          } while (charPos &gt; offset);
      }
  
<span class="line-modified">!     /** byte[]/UTF16 version    */</span>
      private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {
          int charPos = offset + len;
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
<span class="line-new-header">--- 396,41 ---</span>
              return new String(buf, UTF16);
          }
      }
  
      /**
<span class="line-modified">!      * Format a long (treated as unsigned) into a byte buffer (LATIN1 version). If</span>
       * {@code len} exceeds the formatted ASCII representation of {@code val},
       * {@code buf} will be padded with leading zeroes.
       *
       * @param val the unsigned long to format
       * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified">!      * @param buf the byte buffer to write to</span>
       * @param offset the offset in the destination buffer to start at
       * @param len the number of characters to write
       */
<span class="line-modified">!     private static void formatUnsignedLong0(long val, int shift, byte[] buf, int offset, int len) {</span>
          int charPos = offset + len;
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              buf[--charPos] = (byte)Integer.digits[((int) val) &amp; mask];
              val &gt;&gt;&gt;= shift;
          } while (charPos &gt; offset);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Format a long (treated as unsigned) into a byte buffer (UTF16 version). If</span>
<span class="line-added">+      * {@code len} exceeds the formatted ASCII representation of {@code val},</span>
<span class="line-added">+      * {@code buf} will be padded with leading zeroes.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param val the unsigned long to format</span>
<span class="line-added">+      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)</span>
<span class="line-added">+      * @param buf the byte buffer to write to</span>
<span class="line-added">+      * @param offset the offset in the destination buffer to start at</span>
<span class="line-added">+      * @param len the number of characters to write</span>
<span class="line-added">+      */</span>
      private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {
          int charPos = offset + len;
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,11 ***</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         s = Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          if (radix &lt; Character.MIN_RADIX) {
<span class="line-new-header">--- 745,11 ---</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          if (radix &lt; Character.MIN_RADIX) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,11 ***</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         s = Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          int start = beginIndex, len = endIndex - beginIndex;
<span class="line-new-header">--- 991,11 ---</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          int start = beginIndex, len = endIndex - beginIndex;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1337,29 ***</span>
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code byte} after
       * a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversions</span>
       */
      public byte byteValue() {
          return (byte)value;
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code short} after
       * a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversions</span>
       */
      public short shortValue() {
          return (short)value;
      }
  
      /**
       * Returns the value of this {@code Long} as an {@code int} after
       * a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversions</span>
       */
      public int intValue() {
          return (int)value;
      }
  
<span class="line-new-header">--- 1345,29 ---</span>
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code byte} after
       * a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public byte byteValue() {
          return (byte)value;
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code short} after
       * a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public short shortValue() {
          return (short)value;
      }
  
      /**
       * Returns the value of this {@code Long} as an {@code int} after
       * a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public int intValue() {
          return (int)value;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1373,20 ***</span>
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code float} after
       * a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversions</span>
       */
      public float floatValue() {
          return (float)value;
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code double}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversions</span>
       */
      public double doubleValue() {
          return (double)value;
      }
  
<span class="line-new-header">--- 1381,20 ---</span>
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code float} after
       * a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversion</span>
       */
      public float floatValue() {
          return (float)value;
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code double}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversion</span>
       */
      public double doubleValue() {
          return (double)value;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1990,7 ***</span>
<span class="line-new-header">--- 1998,8 ---</span>
      public Long resolveConstantDesc(MethodHandles.Lookup lookup) {
          return this;
      }
  
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">+     @java.io.Serial</span>
      @Native private static final long serialVersionUID = 4290774380558885855L;
  }
</pre>
<center><a href="LiveStackFrame.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Math.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
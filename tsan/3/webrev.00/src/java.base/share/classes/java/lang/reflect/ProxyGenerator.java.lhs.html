<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
<a name="2" id="anc2"></a><span class="line-modified">  28 import java.io.ByteArrayOutputStream;</span>
<span class="line-modified">  29 import java.io.DataOutputStream;</span>
<span class="line-modified">  30 import java.io.File;</span>



  31 import java.io.IOException;
<a name="3" id="anc3"></a><span class="line-modified">  32 import java.io.OutputStream;</span>
<span class="line-removed">  33 import java.lang.reflect.Array;</span>
<span class="line-removed">  34 import java.lang.reflect.Method;</span>
  35 import java.nio.file.Files;
  36 import java.nio.file.Path;
  37 import java.util.ArrayList;
<a name="4" id="anc4"></a>
  38 import java.util.HashMap;
<a name="5" id="anc5"></a>
  39 import java.util.LinkedList;
  40 import java.util.List;
  41 import java.util.ListIterator;
  42 import java.util.Map;
<a name="6" id="anc6"></a><span class="line-modified">  43 import sun.security.action.GetBooleanAction;</span>

  44 
  45 /**
  46  * ProxyGenerator contains the code to generate a dynamic proxy class
  47  * for the java.lang.reflect.Proxy API.
<a name="7" id="anc7"></a><span class="line-modified">  48  *</span>
<span class="line-modified">  49  * The external interfaces to ProxyGenerator is the static</span>
  50  * &quot;generateProxyClass&quot; method.
<a name="8" id="anc8"></a><span class="line-removed">  51  *</span>
<span class="line-removed">  52  * @author      Peter Jones</span>
<span class="line-removed">  53  * @since       1.3</span>
  54  */
<a name="9" id="anc9"></a><span class="line-modified">  55 class ProxyGenerator {</span>
<span class="line-removed">  56     /*</span>
<span class="line-removed">  57      * In the comments below, &quot;JVMS&quot; refers to The Java Virtual Machine</span>
<span class="line-removed">  58      * Specification Second Edition and &quot;JLS&quot; refers to the original</span>
<span class="line-removed">  59      * version of The Java Language Specification, unless otherwise</span>
<span class="line-removed">  60      * specified.</span>
<span class="line-removed">  61      */</span>
  62 
<a name="10" id="anc10"></a><span class="line-modified">  63     /* generate 1.5-era class file version */</span>
<span class="line-modified">  64     private static final int CLASSFILE_MAJOR_VERSION = 49;</span>
<span class="line-modified">  65     private static final int CLASSFILE_MINOR_VERSION = 0;</span>




  66 
<a name="11" id="anc11"></a><span class="line-modified">  67     /*</span>
<span class="line-modified">  68      * beginning of constants copied from</span>
<span class="line-modified">  69      * sun.tools.java.RuntimeConstants (which no longer exists):</span>
<span class="line-removed">  70      */</span>
  71 
<a name="12" id="anc12"></a><span class="line-modified">  72     /* constant pool tags */</span>
<span class="line-modified">  73     private static final int CONSTANT_UTF8              = 1;</span>
<span class="line-modified">  74     private static final int CONSTANT_UNICODE           = 2;</span>
<span class="line-removed">  75     private static final int CONSTANT_INTEGER           = 3;</span>
<span class="line-removed">  76     private static final int CONSTANT_FLOAT             = 4;</span>
<span class="line-removed">  77     private static final int CONSTANT_LONG              = 5;</span>
<span class="line-removed">  78     private static final int CONSTANT_DOUBLE            = 6;</span>
<span class="line-removed">  79     private static final int CONSTANT_CLASS             = 7;</span>
<span class="line-removed">  80     private static final int CONSTANT_STRING            = 8;</span>
<span class="line-removed">  81     private static final int CONSTANT_FIELD             = 9;</span>
<span class="line-removed">  82     private static final int CONSTANT_METHOD            = 10;</span>
<span class="line-removed">  83     private static final int CONSTANT_INTERFACEMETHOD   = 11;</span>
<span class="line-removed">  84     private static final int CONSTANT_NAMEANDTYPE       = 12;</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86     /* access and modifier flags */</span>
<span class="line-removed">  87     private static final int ACC_PUBLIC                 = 0x00000001;</span>
<span class="line-removed">  88     private static final int ACC_PRIVATE                = 0x00000002;</span>
<span class="line-removed">  89 //  private static final int ACC_PROTECTED              = 0x00000004;</span>
<span class="line-removed">  90     private static final int ACC_STATIC                 = 0x00000008;</span>
<span class="line-removed">  91     private static final int ACC_FINAL                  = 0x00000010;</span>
<span class="line-removed">  92 //  private static final int ACC_SYNCHRONIZED           = 0x00000020;</span>
<span class="line-removed">  93 //  private static final int ACC_VOLATILE               = 0x00000040;</span>
<span class="line-removed">  94 //  private static final int ACC_TRANSIENT              = 0x00000080;</span>
<span class="line-removed">  95 //  private static final int ACC_NATIVE                 = 0x00000100;</span>
<span class="line-removed">  96 //  private static final int ACC_INTERFACE              = 0x00000200;</span>
<span class="line-removed">  97 //  private static final int ACC_ABSTRACT               = 0x00000400;</span>
<span class="line-removed">  98     private static final int ACC_SUPER                  = 0x00000020;</span>
<span class="line-removed">  99 //  private static final int ACC_STRICT                 = 0x00000800;</span>
<span class="line-removed"> 100 </span>
<span class="line-removed"> 101     /* opcodes */</span>
<span class="line-removed"> 102 //  private static final int opc_nop                    = 0;</span>
<span class="line-removed"> 103     private static final int opc_aconst_null            = 1;</span>
<span class="line-removed"> 104 //  private static final int opc_iconst_m1              = 2;</span>
<span class="line-removed"> 105     private static final int opc_iconst_0               = 3;</span>
<span class="line-removed"> 106 //  private static final int opc_iconst_1               = 4;</span>
<span class="line-removed"> 107 //  private static final int opc_iconst_2               = 5;</span>
<span class="line-removed"> 108 //  private static final int opc_iconst_3               = 6;</span>
<span class="line-removed"> 109 //  private static final int opc_iconst_4               = 7;</span>
<span class="line-removed"> 110 //  private static final int opc_iconst_5               = 8;</span>
<span class="line-removed"> 111 //  private static final int opc_lconst_0               = 9;</span>
<span class="line-removed"> 112 //  private static final int opc_lconst_1               = 10;</span>
<span class="line-removed"> 113 //  private static final int opc_fconst_0               = 11;</span>
<span class="line-removed"> 114 //  private static final int opc_fconst_1               = 12;</span>
<span class="line-removed"> 115 //  private static final int opc_fconst_2               = 13;</span>
<span class="line-removed"> 116 //  private static final int opc_dconst_0               = 14;</span>
<span class="line-removed"> 117 //  private static final int opc_dconst_1               = 15;</span>
<span class="line-removed"> 118     private static final int opc_bipush                 = 16;</span>
<span class="line-removed"> 119     private static final int opc_sipush                 = 17;</span>
<span class="line-removed"> 120     private static final int opc_ldc                    = 18;</span>
<span class="line-removed"> 121     private static final int opc_ldc_w                  = 19;</span>
<span class="line-removed"> 122 //  private static final int opc_ldc2_w                 = 20;</span>
<span class="line-removed"> 123     private static final int opc_iload                  = 21;</span>
<span class="line-removed"> 124     private static final int opc_lload                  = 22;</span>
<span class="line-removed"> 125     private static final int opc_fload                  = 23;</span>
<span class="line-removed"> 126     private static final int opc_dload                  = 24;</span>
<span class="line-removed"> 127     private static final int opc_aload                  = 25;</span>
<span class="line-removed"> 128     private static final int opc_iload_0                = 26;</span>
<span class="line-removed"> 129 //  private static final int opc_iload_1                = 27;</span>
<span class="line-removed"> 130 //  private static final int opc_iload_2                = 28;</span>
<span class="line-removed"> 131 //  private static final int opc_iload_3                = 29;</span>
<span class="line-removed"> 132     private static final int opc_lload_0                = 30;</span>
<span class="line-removed"> 133 //  private static final int opc_lload_1                = 31;</span>
<span class="line-removed"> 134 //  private static final int opc_lload_2                = 32;</span>
<span class="line-removed"> 135 //  private static final int opc_lload_3                = 33;</span>
<span class="line-removed"> 136     private static final int opc_fload_0                = 34;</span>
<span class="line-removed"> 137 //  private static final int opc_fload_1                = 35;</span>
<span class="line-removed"> 138 //  private static final int opc_fload_2                = 36;</span>
<span class="line-removed"> 139 //  private static final int opc_fload_3                = 37;</span>
<span class="line-removed"> 140     private static final int opc_dload_0                = 38;</span>
<span class="line-removed"> 141 //  private static final int opc_dload_1                = 39;</span>
<span class="line-removed"> 142 //  private static final int opc_dload_2                = 40;</span>
<span class="line-removed"> 143 //  private static final int opc_dload_3                = 41;</span>
<span class="line-removed"> 144     private static final int opc_aload_0                = 42;</span>
<span class="line-removed"> 145 //  private static final int opc_aload_1                = 43;</span>
<span class="line-removed"> 146 //  private static final int opc_aload_2                = 44;</span>
<span class="line-removed"> 147 //  private static final int opc_aload_3                = 45;</span>
<span class="line-removed"> 148 //  private static final int opc_iaload                 = 46;</span>
<span class="line-removed"> 149 //  private static final int opc_laload                 = 47;</span>
<span class="line-removed"> 150 //  private static final int opc_faload                 = 48;</span>
<span class="line-removed"> 151 //  private static final int opc_daload                 = 49;</span>
<span class="line-removed"> 152 //  private static final int opc_aaload                 = 50;</span>
<span class="line-removed"> 153 //  private static final int opc_baload                 = 51;</span>
<span class="line-removed"> 154 //  private static final int opc_caload                 = 52;</span>
<span class="line-removed"> 155 //  private static final int opc_saload                 = 53;</span>
<span class="line-removed"> 156 //  private static final int opc_istore                 = 54;</span>
<span class="line-removed"> 157 //  private static final int opc_lstore                 = 55;</span>
<span class="line-removed"> 158 //  private static final int opc_fstore                 = 56;</span>
<span class="line-removed"> 159 //  private static final int opc_dstore                 = 57;</span>
<span class="line-removed"> 160     private static final int opc_astore                 = 58;</span>
<span class="line-removed"> 161 //  private static final int opc_istore_0               = 59;</span>
<span class="line-removed"> 162 //  private static final int opc_istore_1               = 60;</span>
<span class="line-removed"> 163 //  private static final int opc_istore_2               = 61;</span>
<span class="line-removed"> 164 //  private static final int opc_istore_3               = 62;</span>
<span class="line-removed"> 165 //  private static final int opc_lstore_0               = 63;</span>
<span class="line-removed"> 166 //  private static final int opc_lstore_1               = 64;</span>
<span class="line-removed"> 167 //  private static final int opc_lstore_2               = 65;</span>
<span class="line-removed"> 168 //  private static final int opc_lstore_3               = 66;</span>
<span class="line-removed"> 169 //  private static final int opc_fstore_0               = 67;</span>
<span class="line-removed"> 170 //  private static final int opc_fstore_1               = 68;</span>
<span class="line-removed"> 171 //  private static final int opc_fstore_2               = 69;</span>
<span class="line-removed"> 172 //  private static final int opc_fstore_3               = 70;</span>
<span class="line-removed"> 173 //  private static final int opc_dstore_0               = 71;</span>
<span class="line-removed"> 174 //  private static final int opc_dstore_1               = 72;</span>
<span class="line-removed"> 175 //  private static final int opc_dstore_2               = 73;</span>
<span class="line-removed"> 176 //  private static final int opc_dstore_3               = 74;</span>
<span class="line-removed"> 177     private static final int opc_astore_0               = 75;</span>
<span class="line-removed"> 178 //  private static final int opc_astore_1               = 76;</span>
<span class="line-removed"> 179 //  private static final int opc_astore_2               = 77;</span>
<span class="line-removed"> 180 //  private static final int opc_astore_3               = 78;</span>
<span class="line-removed"> 181 //  private static final int opc_iastore                = 79;</span>
<span class="line-removed"> 182 //  private static final int opc_lastore                = 80;</span>
<span class="line-removed"> 183 //  private static final int opc_fastore                = 81;</span>
<span class="line-removed"> 184 //  private static final int opc_dastore                = 82;</span>
<span class="line-removed"> 185     private static final int opc_aastore                = 83;</span>
<span class="line-removed"> 186 //  private static final int opc_bastore                = 84;</span>
<span class="line-removed"> 187 //  private static final int opc_castore                = 85;</span>
<span class="line-removed"> 188 //  private static final int opc_sastore                = 86;</span>
<span class="line-removed"> 189     private static final int opc_pop                    = 87;</span>
<span class="line-removed"> 190 //  private static final int opc_pop2                   = 88;</span>
<span class="line-removed"> 191     private static final int opc_dup                    = 89;</span>
<span class="line-removed"> 192 //  private static final int opc_dup_x1                 = 90;</span>
<span class="line-removed"> 193 //  private static final int opc_dup_x2                 = 91;</span>
<span class="line-removed"> 194 //  private static final int opc_dup2                   = 92;</span>
<span class="line-removed"> 195 //  private static final int opc_dup2_x1                = 93;</span>
<span class="line-removed"> 196 //  private static final int opc_dup2_x2                = 94;</span>
<span class="line-removed"> 197 //  private static final int opc_swap                   = 95;</span>
<span class="line-removed"> 198 //  private static final int opc_iadd                   = 96;</span>
<span class="line-removed"> 199 //  private static final int opc_ladd                   = 97;</span>
<span class="line-removed"> 200 //  private static final int opc_fadd                   = 98;</span>
<span class="line-removed"> 201 //  private static final int opc_dadd                   = 99;</span>
<span class="line-removed"> 202 //  private static final int opc_isub                   = 100;</span>
<span class="line-removed"> 203 //  private static final int opc_lsub                   = 101;</span>
<span class="line-removed"> 204 //  private static final int opc_fsub                   = 102;</span>
<span class="line-removed"> 205 //  private static final int opc_dsub                   = 103;</span>
<span class="line-removed"> 206 //  private static final int opc_imul                   = 104;</span>
<span class="line-removed"> 207 //  private static final int opc_lmul                   = 105;</span>
<span class="line-removed"> 208 //  private static final int opc_fmul                   = 106;</span>
<span class="line-removed"> 209 //  private static final int opc_dmul                   = 107;</span>
<span class="line-removed"> 210 //  private static final int opc_idiv                   = 108;</span>
<span class="line-removed"> 211 //  private static final int opc_ldiv                   = 109;</span>
<span class="line-removed"> 212 //  private static final int opc_fdiv                   = 110;</span>
<span class="line-removed"> 213 //  private static final int opc_ddiv                   = 111;</span>
<span class="line-removed"> 214 //  private static final int opc_irem                   = 112;</span>
<span class="line-removed"> 215 //  private static final int opc_lrem                   = 113;</span>
<span class="line-removed"> 216 //  private static final int opc_frem                   = 114;</span>
<span class="line-removed"> 217 //  private static final int opc_drem                   = 115;</span>
<span class="line-removed"> 218 //  private static final int opc_ineg                   = 116;</span>
<span class="line-removed"> 219 //  private static final int opc_lneg                   = 117;</span>
<span class="line-removed"> 220 //  private static final int opc_fneg                   = 118;</span>
<span class="line-removed"> 221 //  private static final int opc_dneg                   = 119;</span>
<span class="line-removed"> 222 //  private static final int opc_ishl                   = 120;</span>
<span class="line-removed"> 223 //  private static final int opc_lshl                   = 121;</span>
<span class="line-removed"> 224 //  private static final int opc_ishr                   = 122;</span>
<span class="line-removed"> 225 //  private static final int opc_lshr                   = 123;</span>
<span class="line-removed"> 226 //  private static final int opc_iushr                  = 124;</span>
<span class="line-removed"> 227 //  private static final int opc_lushr                  = 125;</span>
<span class="line-removed"> 228 //  private static final int opc_iand                   = 126;</span>
<span class="line-removed"> 229 //  private static final int opc_land                   = 127;</span>
<span class="line-removed"> 230 //  private static final int opc_ior                    = 128;</span>
<span class="line-removed"> 231 //  private static final int opc_lor                    = 129;</span>
<span class="line-removed"> 232 //  private static final int opc_ixor                   = 130;</span>
<span class="line-removed"> 233 //  private static final int opc_lxor                   = 131;</span>
<span class="line-removed"> 234 //  private static final int opc_iinc                   = 132;</span>
<span class="line-removed"> 235 //  private static final int opc_i2l                    = 133;</span>
<span class="line-removed"> 236 //  private static final int opc_i2f                    = 134;</span>
<span class="line-removed"> 237 //  private static final int opc_i2d                    = 135;</span>
<span class="line-removed"> 238 //  private static final int opc_l2i                    = 136;</span>
<span class="line-removed"> 239 //  private static final int opc_l2f                    = 137;</span>
<span class="line-removed"> 240 //  private static final int opc_l2d                    = 138;</span>
<span class="line-removed"> 241 //  private static final int opc_f2i                    = 139;</span>
<span class="line-removed"> 242 //  private static final int opc_f2l                    = 140;</span>
<span class="line-removed"> 243 //  private static final int opc_f2d                    = 141;</span>
<span class="line-removed"> 244 //  private static final int opc_d2i                    = 142;</span>
<span class="line-removed"> 245 //  private static final int opc_d2l                    = 143;</span>
<span class="line-removed"> 246 //  private static final int opc_d2f                    = 144;</span>
<span class="line-removed"> 247 //  private static final int opc_i2b                    = 145;</span>
<span class="line-removed"> 248 //  private static final int opc_i2c                    = 146;</span>
<span class="line-removed"> 249 //  private static final int opc_i2s                    = 147;</span>
<span class="line-removed"> 250 //  private static final int opc_lcmp                   = 148;</span>
<span class="line-removed"> 251 //  private static final int opc_fcmpl                  = 149;</span>
<span class="line-removed"> 252 //  private static final int opc_fcmpg                  = 150;</span>
<span class="line-removed"> 253 //  private static final int opc_dcmpl                  = 151;</span>
<span class="line-removed"> 254 //  private static final int opc_dcmpg                  = 152;</span>
<span class="line-removed"> 255 //  private static final int opc_ifeq                   = 153;</span>
<span class="line-removed"> 256 //  private static final int opc_ifne                   = 154;</span>
<span class="line-removed"> 257 //  private static final int opc_iflt                   = 155;</span>
<span class="line-removed"> 258 //  private static final int opc_ifge                   = 156;</span>
<span class="line-removed"> 259 //  private static final int opc_ifgt                   = 157;</span>
<span class="line-removed"> 260 //  private static final int opc_ifle                   = 158;</span>
<span class="line-removed"> 261 //  private static final int opc_if_icmpeq              = 159;</span>
<span class="line-removed"> 262 //  private static final int opc_if_icmpne              = 160;</span>
<span class="line-removed"> 263 //  private static final int opc_if_icmplt              = 161;</span>
<span class="line-removed"> 264 //  private static final int opc_if_icmpge              = 162;</span>
<span class="line-removed"> 265 //  private static final int opc_if_icmpgt              = 163;</span>
<span class="line-removed"> 266 //  private static final int opc_if_icmple              = 164;</span>
<span class="line-removed"> 267 //  private static final int opc_if_acmpeq              = 165;</span>
<span class="line-removed"> 268 //  private static final int opc_if_acmpne              = 166;</span>
<span class="line-removed"> 269 //  private static final int opc_goto                   = 167;</span>
<span class="line-removed"> 270 //  private static final int opc_jsr                    = 168;</span>
<span class="line-removed"> 271 //  private static final int opc_ret                    = 169;</span>
<span class="line-removed"> 272 //  private static final int opc_tableswitch            = 170;</span>
<span class="line-removed"> 273 //  private static final int opc_lookupswitch           = 171;</span>
<span class="line-removed"> 274     private static final int opc_ireturn                = 172;</span>
<span class="line-removed"> 275     private static final int opc_lreturn                = 173;</span>
<span class="line-removed"> 276     private static final int opc_freturn                = 174;</span>
<span class="line-removed"> 277     private static final int opc_dreturn                = 175;</span>
<span class="line-removed"> 278     private static final int opc_areturn                = 176;</span>
<span class="line-removed"> 279     private static final int opc_return                 = 177;</span>
<span class="line-removed"> 280     private static final int opc_getstatic              = 178;</span>
<span class="line-removed"> 281     private static final int opc_putstatic              = 179;</span>
<span class="line-removed"> 282     private static final int opc_getfield               = 180;</span>
<span class="line-removed"> 283 //  private static final int opc_putfield               = 181;</span>
<span class="line-removed"> 284     private static final int opc_invokevirtual          = 182;</span>
<span class="line-removed"> 285     private static final int opc_invokespecial          = 183;</span>
<span class="line-removed"> 286     private static final int opc_invokestatic           = 184;</span>
<span class="line-removed"> 287     private static final int opc_invokeinterface        = 185;</span>
<span class="line-removed"> 288     private static final int opc_new                    = 187;</span>
<span class="line-removed"> 289 //  private static final int opc_newarray               = 188;</span>
<span class="line-removed"> 290     private static final int opc_anewarray              = 189;</span>
<span class="line-removed"> 291 //  private static final int opc_arraylength            = 190;</span>
<span class="line-removed"> 292     private static final int opc_athrow                 = 191;</span>
<span class="line-removed"> 293     private static final int opc_checkcast              = 192;</span>
<span class="line-removed"> 294 //  private static final int opc_instanceof             = 193;</span>
<span class="line-removed"> 295 //  private static final int opc_monitorenter           = 194;</span>
<span class="line-removed"> 296 //  private static final int opc_monitorexit            = 195;</span>
<span class="line-removed"> 297     private static final int opc_wide                   = 196;</span>
<span class="line-removed"> 298 //  private static final int opc_multianewarray         = 197;</span>
<span class="line-removed"> 299 //  private static final int opc_ifnull                 = 198;</span>
<span class="line-removed"> 300 //  private static final int opc_ifnonnull              = 199;</span>
<span class="line-removed"> 301 //  private static final int opc_goto_w                 = 200;</span>
<span class="line-removed"> 302 //  private static final int opc_jsr_w                  = 201;</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     // end of constants copied from sun.tools.java.RuntimeConstants</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     /** name of the superclass of proxy classes */</span>
<span class="line-removed"> 307     private static final String superclassName = &quot;java/lang/reflect/Proxy&quot;;</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309     /** name of field for storing a proxy instance&#39;s invocation handler */</span>
<span class="line-removed"> 310     private static final String handlerFieldName = &quot;h&quot;;</span>
 311 
<a name="13" id="anc13"></a><span class="line-modified"> 312     /** debugging flag for saving generated class files */</span>
<span class="line-modified"> 313     private static final boolean saveGeneratedFiles =</span>
<span class="line-modified"> 314         java.security.AccessController.doPrivileged(</span>
<span class="line-modified"> 315             new GetBooleanAction(</span>
<span class="line-modified"> 316                 &quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;)).booleanValue();</span>

 317 
 318     /**
<a name="14" id="anc14"></a><span class="line-modified"> 319      * Generate a public proxy class given a name and a list of proxy interfaces.</span>
 320      */
<a name="15" id="anc15"></a><span class="line-modified"> 321     static byte[] generateProxyClass(final String name,</span>
<span class="line-removed"> 322                                      Class&lt;?&gt;[] interfaces) {</span>
<span class="line-removed"> 323         return generateProxyClass(name, interfaces, (ACC_PUBLIC | ACC_FINAL | ACC_SUPER));</span>
<span class="line-removed"> 324     }</span>
 325 
 326     /**
<a name="16" id="anc16"></a><span class="line-modified"> 327      * Generate a proxy class given a name and a list of proxy interfaces.</span>
<span class="line-modified"> 328      *</span>
<span class="line-modified"> 329      * @param name        the class name of the proxy class</span>
<span class="line-removed"> 330      * @param interfaces  proxy interfaces</span>
<span class="line-removed"> 331      * @param accessFlags access flags of the proxy class</span>
<span class="line-removed"> 332     */</span>
<span class="line-removed"> 333     static byte[] generateProxyClass(final String name,</span>
<span class="line-removed"> 334                                      Class&lt;?&gt;[] interfaces,</span>
<span class="line-removed"> 335                                      int accessFlags)</span>
<span class="line-removed"> 336     {</span>
<span class="line-removed"> 337         ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);</span>
<span class="line-removed"> 338         final byte[] classFile = gen.generateClassFile();</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340         if (saveGeneratedFiles) {</span>
 341             java.security.AccessController.doPrivileged(
<a name="17" id="anc17"></a><span class="line-modified"> 342             new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified"> 343                 public Void run() {</span>
<span class="line-removed"> 344                     try {</span>
<span class="line-removed"> 345                         int i = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-removed"> 346                         Path path;</span>
<span class="line-removed"> 347                         if (i &gt; 0) {</span>
<span class="line-removed"> 348                             Path dir = Path.of(name.substring(0, i).replace(&#39;.&#39;, File.separatorChar));</span>
<span class="line-removed"> 349                             Files.createDirectories(dir);</span>
<span class="line-removed"> 350                             path = dir.resolve(name.substring(i+1, name.length()) + &quot;.class&quot;);</span>
<span class="line-removed"> 351                         } else {</span>
<span class="line-removed"> 352                             path = Path.of(name + &quot;.class&quot;);</span>
<span class="line-removed"> 353                         }</span>
<span class="line-removed"> 354                         Files.write(path, classFile);</span>
<span class="line-removed"> 355                         return null;</span>
<span class="line-removed"> 356                     } catch (IOException e) {</span>
<span class="line-removed"> 357                         throw new InternalError(</span>
<span class="line-removed"> 358                             &quot;I/O exception saving generated file: &quot; + e);</span>
<span class="line-removed"> 359                     }</span>
<span class="line-removed"> 360                 }</span>
<span class="line-removed"> 361             });</span>
<span class="line-removed"> 362         }</span>
 363 
<a name="18" id="anc18"></a><span class="line-modified"> 364         return classFile;</span>
<span class="line-modified"> 365     }</span>


 366 
<a name="19" id="anc19"></a><span class="line-removed"> 367     /* preloaded Method objects for methods in java.lang.Object */</span>
<span class="line-removed"> 368     private static Method hashCodeMethod;</span>
<span class="line-removed"> 369     private static Method equalsMethod;</span>
<span class="line-removed"> 370     private static Method toStringMethod;</span>
 371     static {
 372         try {
<a name="20" id="anc20"></a><span class="line-modified"> 373             hashCodeMethod = Object.class.getMethod(&quot;hashCode&quot;);</span>
<span class="line-modified"> 374             equalsMethod =</span>
<span class="line-modified"> 375                 Object.class.getMethod(&quot;equals&quot;, new Class&lt;?&gt;[] { Object.class });</span>
<span class="line-removed"> 376             toStringMethod = Object.class.getMethod(&quot;toString&quot;);</span>
 377         } catch (NoSuchMethodException e) {
 378             throw new NoSuchMethodError(e.getMessage());
 379         }
 380     }
 381 
<a name="21" id="anc21"></a><span class="line-modified"> 382     /** name of proxy class */</span>
<span class="line-modified"> 383     private String className;</span>
<span class="line-modified"> 384 </span>
<span class="line-modified"> 385     /** proxy interfaces */</span>
<span class="line-removed"> 386     private Class&lt;?&gt;[] interfaces;</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388     /** proxy class access flags */</span>
<span class="line-removed"> 389     private int accessFlags;</span>
 390 
<a name="22" id="anc22"></a><span class="line-modified"> 391     /** constant pool of class being generated */</span>
<span class="line-modified"> 392     private ConstantPool cp = new ConstantPool();</span>


 393 
<a name="23" id="anc23"></a><span class="line-modified"> 394     /** FieldInfo struct for each field of generated class */</span>
<span class="line-modified"> 395     private List&lt;FieldInfo&gt; fields = new ArrayList&lt;&gt;();</span>


 396 
<a name="24" id="anc24"></a><span class="line-modified"> 397     /** MethodInfo struct for each method of generated class */</span>
<span class="line-modified"> 398     private List&lt;MethodInfo&gt; methods = new ArrayList&lt;&gt;();</span>


 399 
 400     /**
<a name="25" id="anc25"></a><span class="line-modified"> 401      * maps method signature string to list of ProxyMethod objects for</span>
<span class="line-modified"> 402      * proxy methods with that signature</span>

 403      */
<a name="26" id="anc26"></a><span class="line-modified"> 404     private Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods = new HashMap&lt;&gt;();</span>
 405 
<a name="27" id="anc27"></a><span class="line-modified"> 406     /** count of ProxyMethod objects added to proxyMethods */</span>
<span class="line-modified"> 407     private int proxyMethodCount = 0;</span>



 408 
 409     /**
 410      * Construct a ProxyGenerator to generate a proxy class with the
 411      * specified name and for the given interfaces.
<a name="28" id="anc28"></a><span class="line-modified"> 412      *</span>
 413      * A ProxyGenerator object contains the state for the ongoing
 414      * generation of a particular proxy class.
 415      */
<a name="29" id="anc29"></a><span class="line-modified"> 416     private ProxyGenerator(String className, Class&lt;?&gt;[] interfaces, int accessFlags) {</span>



 417         this.className = className;
 418         this.interfaces = interfaces;
 419         this.accessFlags = accessFlags;
 420     }
 421 
 422     /**
<a name="30" id="anc30"></a><span class="line-modified"> 423      * Generate a class file for the proxy class.  This method drives the</span>
<span class="line-modified"> 424      * class file generation process.</span>



 425      */
<a name="31" id="anc31"></a><span class="line-modified"> 426     private byte[] generateClassFile() {</span>
<span class="line-modified"> 427 </span>
<span class="line-modified"> 428         /* ============================================================</span>
<span class="line-modified"> 429          * Step 1: Assemble ProxyMethod objects for all methods to</span>
<span class="line-modified"> 430          * generate proxy dispatching code for.</span>
<span class="line-modified"> 431          */</span>
<span class="line-removed"> 432 </span>
<span class="line-removed"> 433         /*</span>
<span class="line-removed"> 434          * Record that proxy methods are needed for the hashCode, equals,</span>
<span class="line-removed"> 435          * and toString methods of java.lang.Object.  This is done before</span>
<span class="line-removed"> 436          * the methods from the proxy interfaces so that the methods from</span>
<span class="line-removed"> 437          * java.lang.Object take precedence over duplicate methods in the</span>
<span class="line-removed"> 438          * proxy interfaces.</span>
<span class="line-removed"> 439          */</span>
<span class="line-removed"> 440         addProxyMethod(hashCodeMethod, Object.class);</span>
<span class="line-removed"> 441         addProxyMethod(equalsMethod, Object.class);</span>
<span class="line-removed"> 442         addProxyMethod(toStringMethod, Object.class);</span>
<span class="line-removed"> 443 </span>
<span class="line-removed"> 444         /*</span>
<span class="line-removed"> 445          * Now record all of the methods from the proxy interfaces, giving</span>
<span class="line-removed"> 446          * earlier interfaces precedence over later ones with duplicate</span>
<span class="line-removed"> 447          * methods.</span>
<span class="line-removed"> 448          */</span>
<span class="line-removed"> 449         for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-removed"> 450             for (Method m : intf.getMethods()) {</span>
<span class="line-removed"> 451                 if (!Modifier.isStatic(m.getModifiers())) {</span>
<span class="line-removed"> 452                     addProxyMethod(m, intf);</span>
<span class="line-removed"> 453                 }</span>
<span class="line-removed"> 454             }</span>
<span class="line-removed"> 455         }</span>
<span class="line-removed"> 456 </span>
<span class="line-removed"> 457         /*</span>
<span class="line-removed"> 458          * For each set of proxy methods with the same signature,</span>
<span class="line-removed"> 459          * verify that the methods&#39; return types are compatible.</span>
<span class="line-removed"> 460          */</span>
<span class="line-removed"> 461         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-removed"> 462             checkReturnTypes(sigmethods);</span>
<span class="line-removed"> 463         }</span>
<span class="line-removed"> 464 </span>
<span class="line-removed"> 465         /* ============================================================</span>
<span class="line-removed"> 466          * Step 2: Assemble FieldInfo and MethodInfo structs for all of</span>
<span class="line-removed"> 467          * fields and methods in the class we are generating.</span>
<span class="line-removed"> 468          */</span>
<span class="line-removed"> 469         try {</span>
<span class="line-removed"> 470             methods.add(generateConstructor());</span>
<span class="line-removed"> 471 </span>
<span class="line-removed"> 472             for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-removed"> 473                 for (ProxyMethod pm : sigmethods) {</span>
<span class="line-removed"> 474 </span>
<span class="line-removed"> 475                     // add static field for method&#39;s Method object</span>
<span class="line-removed"> 476                     fields.add(new FieldInfo(pm.methodFieldName,</span>
<span class="line-removed"> 477                         &quot;Ljava/lang/reflect/Method;&quot;,</span>
<span class="line-removed"> 478                          ACC_PRIVATE | ACC_STATIC));</span>
<span class="line-removed"> 479 </span>
<span class="line-removed"> 480                     // generate code for proxy method and add it</span>
<span class="line-removed"> 481                     methods.add(pm.generateMethod());</span>
<span class="line-removed"> 482                 }</span>
<span class="line-removed"> 483             }</span>
<span class="line-removed"> 484 </span>
<span class="line-removed"> 485             methods.add(generateStaticInitializer());</span>
<span class="line-removed"> 486 </span>
<span class="line-removed"> 487         } catch (IOException e) {</span>
<span class="line-removed"> 488             throw new InternalError(&quot;unexpected I/O Exception&quot;, e);</span>
<span class="line-removed"> 489         }</span>
<span class="line-removed"> 490 </span>
<span class="line-removed"> 491         if (methods.size() &gt; 65535) {</span>
<span class="line-removed"> 492             throw new IllegalArgumentException(&quot;method limit exceeded&quot;);</span>
<span class="line-removed"> 493         }</span>
<span class="line-removed"> 494         if (fields.size() &gt; 65535) {</span>
<span class="line-removed"> 495             throw new IllegalArgumentException(&quot;field limit exceeded&quot;);</span>
<span class="line-removed"> 496         }</span>
<span class="line-removed"> 497 </span>
<span class="line-removed"> 498         /* ============================================================</span>
<span class="line-removed"> 499          * Step 3: Write the final class file.</span>
<span class="line-removed"> 500          */</span>
<span class="line-removed"> 501 </span>
<span class="line-removed"> 502         /*</span>
<span class="line-removed"> 503          * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed"> 504          * following items before starting to write the final class file.</span>
<span class="line-removed"> 505          */</span>
<span class="line-removed"> 506         cp.getClass(dotToSlash(className));</span>
<span class="line-removed"> 507         cp.getClass(superclassName);</span>
<span class="line-removed"> 508         for (Class&lt;?&gt; intf: interfaces) {</span>
<span class="line-removed"> 509             cp.getClass(dotToSlash(intf.getName()));</span>
<span class="line-removed"> 510         }</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512         /*</span>
<span class="line-removed"> 513          * Disallow new constant pool additions beyond this point, since</span>
<span class="line-removed"> 514          * we are about to write the final constant pool table.</span>
<span class="line-removed"> 515          */</span>
<span class="line-removed"> 516         cp.setReadOnly();</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518         ByteArrayOutputStream bout = new ByteArrayOutputStream();</span>
<span class="line-removed"> 519         DataOutputStream dout = new DataOutputStream(bout);</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521         try {</span>
<span class="line-removed"> 522             /*</span>
<span class="line-removed"> 523              * Write all the items of the &quot;ClassFile&quot; structure.</span>
<span class="line-removed"> 524              * See JVMS section 4.1.</span>
<span class="line-removed"> 525              */</span>
<span class="line-removed"> 526                                         // u4 magic;</span>
<span class="line-removed"> 527             dout.writeInt(0xCAFEBABE);</span>
<span class="line-removed"> 528                                         // u2 minor_version;</span>
<span class="line-removed"> 529             dout.writeShort(CLASSFILE_MINOR_VERSION);</span>
<span class="line-removed"> 530                                         // u2 major_version;</span>
<span class="line-removed"> 531             dout.writeShort(CLASSFILE_MAJOR_VERSION);</span>
<span class="line-removed"> 532 </span>
<span class="line-removed"> 533             cp.write(dout);             // (write constant pool)</span>
<span class="line-removed"> 534 </span>
<span class="line-removed"> 535                                         // u2 access_flags;</span>
<span class="line-removed"> 536             dout.writeShort(accessFlags);</span>
<span class="line-removed"> 537                                         // u2 this_class;</span>
<span class="line-removed"> 538             dout.writeShort(cp.getClass(dotToSlash(className)));</span>
<span class="line-removed"> 539                                         // u2 super_class;</span>
<span class="line-removed"> 540             dout.writeShort(cp.getClass(superclassName));</span>
<span class="line-removed"> 541 </span>
<span class="line-removed"> 542                                         // u2 interfaces_count;</span>
<span class="line-removed"> 543             dout.writeShort(interfaces.length);</span>
<span class="line-removed"> 544                                         // u2 interfaces[interfaces_count];</span>
<span class="line-removed"> 545             for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-removed"> 546                 dout.writeShort(cp.getClass(</span>
<span class="line-removed"> 547                     dotToSlash(intf.getName())));</span>
<span class="line-removed"> 548             }</span>
<span class="line-removed"> 549 </span>
<span class="line-removed"> 550                                         // u2 fields_count;</span>
<span class="line-removed"> 551             dout.writeShort(fields.size());</span>
<span class="line-removed"> 552                                         // field_info fields[fields_count];</span>
<span class="line-removed"> 553             for (FieldInfo f : fields) {</span>
<span class="line-removed"> 554                 f.write(dout);</span>
<span class="line-removed"> 555             }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557                                         // u2 methods_count;</span>
<span class="line-removed"> 558             dout.writeShort(methods.size());</span>
<span class="line-removed"> 559                                         // method_info methods[methods_count];</span>
<span class="line-removed"> 560             for (MethodInfo m : methods) {</span>
<span class="line-removed"> 561                 m.write(dout);</span>
<span class="line-removed"> 562             }</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564                                          // u2 attributes_count;</span>
<span class="line-removed"> 565             dout.writeShort(0); // (no ClassFile attributes for proxy classes)</span>
 566 
<a name="32" id="anc32"></a><span class="line-modified"> 567         } catch (IOException e) {</span>
<span class="line-modified"> 568             throw new InternalError(&quot;unexpected I/O Exception&quot;, e);</span>




















 569         }
 570 
<a name="33" id="anc33"></a><span class="line-modified"> 571         return bout.toByteArray();</span>
 572     }
 573 
 574     /**
<a name="34" id="anc34"></a><span class="line-modified"> 575      * Add another method to be proxied, either by creating a new</span>
<span class="line-removed"> 576      * ProxyMethod object or augmenting an old one for a duplicate</span>
<span class="line-removed"> 577      * method.</span>
 578      *
<a name="35" id="anc35"></a><span class="line-modified"> 579      * &quot;fromClass&quot; indicates the proxy interface that the method was</span>
<span class="line-modified"> 580      * found through, which may be different from (a subinterface of)</span>
<span class="line-removed"> 581      * the method&#39;s &quot;declaring class&quot;.  Note that the first Method</span>
<span class="line-removed"> 582      * object passed for a given name and descriptor identifies the</span>
<span class="line-removed"> 583      * Method object (and thus the declaring class) that will be</span>
<span class="line-removed"> 584      * passed to the invocation handler&#39;s &quot;invoke&quot; method for a given</span>
<span class="line-removed"> 585      * set of duplicate methods.</span>
 586      */
<a name="36" id="anc36"></a><span class="line-modified"> 587     private void addProxyMethod(Method m, Class&lt;?&gt; fromClass) {</span>
<span class="line-modified"> 588         String name = m.getName();</span>
<span class="line-modified"> 589         Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span>
<span class="line-modified"> 590         Class&lt;?&gt; returnType = m.getReturnType();</span>
<span class="line-modified"> 591         Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span>
<span class="line-modified"> 592 </span>
<span class="line-modified"> 593         String sig = name + getParameterDescriptors(parameterTypes);</span>
<span class="line-modified"> 594         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.get(sig);</span>
<span class="line-removed"> 595         if (sigmethods != null) {</span>
<span class="line-removed"> 596             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-removed"> 597                 if (returnType == pm.returnType) {</span>
<span class="line-removed"> 598                     /*</span>
<span class="line-removed"> 599                      * Found a match: reduce exception types to the</span>
<span class="line-removed"> 600                      * greatest set of exceptions that can thrown</span>
<span class="line-removed"> 601                      * compatibly with the throws clauses of both</span>
<span class="line-removed"> 602                      * overridden methods.</span>
<span class="line-removed"> 603                      */</span>
<span class="line-removed"> 604                     List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;&gt;();</span>
<span class="line-removed"> 605                     collectCompatibleTypes(</span>
<span class="line-removed"> 606                         exceptionTypes, pm.exceptionTypes, legalExceptions);</span>
<span class="line-removed"> 607                     collectCompatibleTypes(</span>
<span class="line-removed"> 608                         pm.exceptionTypes, exceptionTypes, legalExceptions);</span>
<span class="line-removed"> 609                     pm.exceptionTypes = new Class&lt;?&gt;[legalExceptions.size()];</span>
<span class="line-removed"> 610                     pm.exceptionTypes =</span>
<span class="line-removed"> 611                         legalExceptions.toArray(pm.exceptionTypes);</span>
<span class="line-removed"> 612                     return;</span>
<span class="line-removed"> 613                 }</span>
<span class="line-removed"> 614             }</span>
<span class="line-removed"> 615         } else {</span>
<span class="line-removed"> 616             sigmethods = new ArrayList&lt;&gt;(3);</span>
<span class="line-removed"> 617             proxyMethods.put(sig, sigmethods);</span>
<span class="line-removed"> 618         }</span>
<span class="line-removed"> 619         sigmethods.add(new ProxyMethod(name, parameterTypes, returnType,</span>
<span class="line-removed"> 620                                        exceptionTypes, fromClass));</span>
 621     }
 622 
 623     /**
 624      * For a given set of proxy methods with the same signature, check
 625      * that their return types are compatible according to the Proxy
 626      * specification.
 627      *
 628      * Specifically, if there is more than one such method, then all
 629      * of the return types must be reference types, and there must be
 630      * one return type that is assignable to each of the rest of them.
 631      */
 632     private static void checkReturnTypes(List&lt;ProxyMethod&gt; methods) {
 633         /*
 634          * If there is only one method with a given signature, there
 635          * cannot be a conflict.  This is the only case in which a
 636          * primitive (or void) return type is allowed.
 637          */
 638         if (methods.size() &lt; 2) {
 639             return;
 640         }
 641 
 642         /*
 643          * List of return types that are not yet known to be
 644          * assignable from (&quot;covered&quot; by) any of the others.
 645          */
 646         LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;&gt;();
 647 
<a name="37" id="anc37"></a><span class="line-modified"> 648     nextNewReturnType:</span>
 649         for (ProxyMethod pm : methods) {
 650             Class&lt;?&gt; newReturnType = pm.returnType;
 651             if (newReturnType.isPrimitive()) {
 652                 throw new IllegalArgumentException(
<a name="38" id="anc38"></a><span class="line-modified"> 653                     &quot;methods with same signature &quot; +</span>
<span class="line-modified"> 654                     getFriendlyMethodSignature(pm.methodName,</span>
<span class="line-modified"> 655                                                pm.parameterTypes) +</span>
<span class="line-modified"> 656                     &quot; but incompatible return types: &quot; +</span>
<span class="line-removed"> 657                     newReturnType.getName() + &quot; and others&quot;);</span>
 658             }
 659             boolean added = false;
 660 
 661             /*
 662              * Compare the new return type to the existing uncovered
 663              * return types.
 664              */
 665             ListIterator&lt;Class&lt;?&gt;&gt; liter = uncoveredReturnTypes.listIterator();
 666             while (liter.hasNext()) {
 667                 Class&lt;?&gt; uncoveredReturnType = liter.next();
 668 
 669                 /*
 670                  * If an existing uncovered return type is assignable
 671                  * to this new one, then we can forget the new one.
 672                  */
 673                 if (newReturnType.isAssignableFrom(uncoveredReturnType)) {
 674                     assert !added;
 675                     continue nextNewReturnType;
 676                 }
 677 
 678                 /*
 679                  * If the new return type is assignable to an existing
 680                  * uncovered one, then should replace the existing one
 681                  * with the new one (or just forget the existing one,
 682                  * if the new one has already be put in the list).
 683                  */
 684                 if (uncoveredReturnType.isAssignableFrom(newReturnType)) {
 685                     // (we can assume that each return type is unique)
 686                     if (!added) {
 687                         liter.set(newReturnType);
 688                         added = true;
 689                     } else {
 690                         liter.remove();
 691                     }
 692                 }
 693             }
 694 
 695             /*
 696              * If we got through the list of existing uncovered return
 697              * types without an assignability relationship, then add
 698              * the new return type to the list of uncovered ones.
 699              */
 700             if (!added) {
 701                 uncoveredReturnTypes.add(newReturnType);
 702             }
 703         }
 704 
 705         /*
 706          * We shouldn&#39;t end up with more than one return type that is
 707          * not assignable from any of the others.
 708          */
 709         if (uncoveredReturnTypes.size() &gt; 1) {
 710             ProxyMethod pm = methods.get(0);
 711             throw new IllegalArgumentException(
<a name="39" id="anc39"></a><span class="line-modified"> 712                 &quot;methods with same signature &quot; +</span>
<span class="line-modified"> 713                 getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) +</span>
<span class="line-modified"> 714                 &quot; but incompatible return types: &quot; + uncoveredReturnTypes);</span>
 715         }
 716     }
 717 
 718     /**
<a name="40" id="anc40"></a><span class="line-modified"> 719      * A FieldInfo object contains information about a particular field</span>
<span class="line-modified"> 720      * in the class being generated.  The class mirrors the data items of</span>
<span class="line-modified"> 721      * the &quot;field_info&quot; structure of the class file format (see JVMS 4.5).</span>
















 722      */
<a name="41" id="anc41"></a><span class="line-modified"> 723     private class FieldInfo {</span>
<span class="line-modified"> 724         public int accessFlags;</span>
<span class="line-modified"> 725         public String name;</span>
<span class="line-removed"> 726         public String descriptor;</span>
<span class="line-removed"> 727 </span>
<span class="line-removed"> 728         public FieldInfo(String name, String descriptor, int accessFlags) {</span>
<span class="line-removed"> 729             this.name = name;</span>
<span class="line-removed"> 730             this.descriptor = descriptor;</span>
<span class="line-removed"> 731             this.accessFlags = accessFlags;</span>
 732 
<a name="42" id="anc42"></a><span class="line-modified"> 733             /*</span>
<span class="line-modified"> 734              * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed"> 735              * following items before starting to write the final class file.</span>
<span class="line-removed"> 736              */</span>
<span class="line-removed"> 737             cp.getUtf8(name);</span>
<span class="line-removed"> 738             cp.getUtf8(descriptor);</span>
<span class="line-removed"> 739         }</span>
 740 
<a name="43" id="anc43"></a><span class="line-modified"> 741         public void write(DataOutputStream out) throws IOException {</span>















 742             /*
<a name="44" id="anc44"></a><span class="line-modified"> 743              * Write all the items of the &quot;field_info&quot; structure.</span>
<span class="line-modified"> 744              * See JVMS section 4.5.</span>
 745              */
<a name="45" id="anc45"></a><span class="line-modified"> 746                                         // u2 access_flags;</span>
<span class="line-modified"> 747             out.writeShort(accessFlags);</span>
<span class="line-modified"> 748                                         // u2 name_index;</span>
<span class="line-modified"> 749             out.writeShort(cp.getUtf8(name));</span>
<span class="line-modified"> 750                                         // u2 descriptor_index;</span>
<span class="line-modified"> 751             out.writeShort(cp.getUtf8(descriptor));</span>
<span class="line-modified"> 752                                         // u2 attributes_count;</span>
<span class="line-modified"> 753             out.writeShort(0);  // (no field_info attributes for proxy classes)</span>












 754         }
<a name="46" id="anc46"></a>
 755     }
 756 
 757     /**
<a name="47" id="anc47"></a><span class="line-modified"> 758      * An ExceptionTableEntry object holds values for the data items of</span>
<span class="line-modified"> 759      * an entry in the &quot;exception_table&quot; item of the &quot;Code&quot; attribute of</span>
<span class="line-modified"> 760      * &quot;method_info&quot; structures (see JVMS 4.7.3).</span>


 761      */
<a name="48" id="anc48"></a><span class="line-modified"> 762     private static class ExceptionTableEntry {</span>
<span class="line-modified"> 763         public short startPc;</span>
<span class="line-modified"> 764         public short endPc;</span>
<span class="line-removed"> 765         public short handlerPc;</span>
<span class="line-removed"> 766         public short catchType;</span>
<span class="line-removed"> 767 </span>
<span class="line-removed"> 768         public ExceptionTableEntry(short startPc, short endPc,</span>
<span class="line-removed"> 769                                    short handlerPc, short catchType)</span>
<span class="line-removed"> 770         {</span>
<span class="line-removed"> 771             this.startPc = startPc;</span>
<span class="line-removed"> 772             this.endPc = endPc;</span>
<span class="line-removed"> 773             this.handlerPc = handlerPc;</span>
<span class="line-removed"> 774             this.catchType = catchType;</span>
<span class="line-removed"> 775         }</span>
<span class="line-removed"> 776     };</span>
 777 
 778     /**
<a name="49" id="anc49"></a><span class="line-modified"> 779      * A MethodInfo object contains information about a particular method</span>
<span class="line-modified"> 780      * in the class being generated.  This class mirrors the data items of</span>
<span class="line-modified"> 781      * the &quot;method_info&quot; structure of the class file format (see JVMS 4.6).</span>




 782      */
<a name="50" id="anc50"></a><span class="line-modified"> 783     private class MethodInfo {</span>
<span class="line-modified"> 784         public int accessFlags;</span>
<span class="line-modified"> 785         public String name;</span>
<span class="line-modified"> 786         public String descriptor;</span>
<span class="line-modified"> 787         public short maxStack;</span>
<span class="line-removed"> 788         public short maxLocals;</span>
<span class="line-removed"> 789         public ByteArrayOutputStream code = new ByteArrayOutputStream();</span>
<span class="line-removed"> 790         public List&lt;ExceptionTableEntry&gt; exceptionTable =</span>
<span class="line-removed"> 791             new ArrayList&lt;ExceptionTableEntry&gt;();</span>
<span class="line-removed"> 792         public short[] declaredExceptions;</span>
<span class="line-removed"> 793 </span>
<span class="line-removed"> 794         public MethodInfo(String name, String descriptor, int accessFlags) {</span>
<span class="line-removed"> 795             this.name = name;</span>
<span class="line-removed"> 796             this.descriptor = descriptor;</span>
<span class="line-removed"> 797             this.accessFlags = accessFlags;</span>
<span class="line-removed"> 798 </span>
<span class="line-removed"> 799             /*</span>
<span class="line-removed"> 800              * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed"> 801              * following items before starting to write the final class file.</span>
<span class="line-removed"> 802              */</span>
<span class="line-removed"> 803             cp.getUtf8(name);</span>
<span class="line-removed"> 804             cp.getUtf8(descriptor);</span>
<span class="line-removed"> 805             cp.getUtf8(&quot;Code&quot;);</span>
<span class="line-removed"> 806             cp.getUtf8(&quot;Exceptions&quot;);</span>
 807         }
<a name="51" id="anc51"></a>
 808 
<a name="52" id="anc52"></a><span class="line-modified"> 809         public void write(DataOutputStream out) throws IOException {</span>
<span class="line-modified"> 810             /*</span>
<span class="line-modified"> 811              * Write all the items of the &quot;method_info&quot; structure.</span>
<span class="line-modified"> 812              * See JVMS section 4.6.</span>
<span class="line-modified"> 813              */</span>
<span class="line-modified"> 814                                         // u2 access_flags;</span>
<span class="line-modified"> 815             out.writeShort(accessFlags);</span>
<span class="line-modified"> 816                                         // u2 name_index;</span>
<span class="line-modified"> 817             out.writeShort(cp.getUtf8(name));</span>
<span class="line-modified"> 818                                         // u2 descriptor_index;</span>
<span class="line-modified"> 819             out.writeShort(cp.getUtf8(descriptor));</span>
<span class="line-modified"> 820                                         // u2 attributes_count;</span>
<span class="line-modified"> 821             out.writeShort(2);  // (two method_info attributes:)</span>
<span class="line-modified"> 822 </span>
<span class="line-modified"> 823             // Write &quot;Code&quot; attribute. See JVMS section 4.7.3.</span>
<span class="line-modified"> 824 </span>
<span class="line-modified"> 825                                         // u2 attribute_name_index;</span>
<span class="line-modified"> 826             out.writeShort(cp.getUtf8(&quot;Code&quot;));</span>
<span class="line-modified"> 827                                         // u4 attribute_length;</span>
<span class="line-modified"> 828             out.writeInt(12 + code.size() + 8 * exceptionTable.size());</span>
<span class="line-removed"> 829                                         // u2 max_stack;</span>
<span class="line-removed"> 830             out.writeShort(maxStack);</span>
<span class="line-removed"> 831                                         // u2 max_locals;</span>
<span class="line-removed"> 832             out.writeShort(maxLocals);</span>
<span class="line-removed"> 833                                         // u2 code_length;</span>
<span class="line-removed"> 834             out.writeInt(code.size());</span>
<span class="line-removed"> 835                                         // u1 code[code_length];</span>
<span class="line-removed"> 836             code.writeTo(out);</span>
<span class="line-removed"> 837                                         // u2 exception_table_length;</span>
<span class="line-removed"> 838             out.writeShort(exceptionTable.size());</span>
<span class="line-removed"> 839             for (ExceptionTableEntry e : exceptionTable) {</span>
<span class="line-removed"> 840                                         // u2 start_pc;</span>
<span class="line-removed"> 841                 out.writeShort(e.startPc);</span>
<span class="line-removed"> 842                                         // u2 end_pc;</span>
<span class="line-removed"> 843                 out.writeShort(e.endPc);</span>
<span class="line-removed"> 844                                         // u2 handler_pc;</span>
<span class="line-removed"> 845                 out.writeShort(e.handlerPc);</span>
<span class="line-removed"> 846                                         // u2 catch_type;</span>
<span class="line-removed"> 847                 out.writeShort(e.catchType);</span>
<span class="line-removed"> 848             }</span>
<span class="line-removed"> 849                                         // u2 attributes_count;</span>
<span class="line-removed"> 850             out.writeShort(0);</span>
<span class="line-removed"> 851 </span>
<span class="line-removed"> 852             // write &quot;Exceptions&quot; attribute.  See JVMS section 4.7.4.</span>
<span class="line-removed"> 853 </span>
<span class="line-removed"> 854                                         // u2 attribute_name_index;</span>
<span class="line-removed"> 855             out.writeShort(cp.getUtf8(&quot;Exceptions&quot;));</span>
<span class="line-removed"> 856                                         // u4 attributes_length;</span>
<span class="line-removed"> 857             out.writeInt(2 + 2 * declaredExceptions.length);</span>
<span class="line-removed"> 858                                         // u2 number_of_exceptions;</span>
<span class="line-removed"> 859             out.writeShort(declaredExceptions.length);</span>
<span class="line-removed"> 860                         // u2 exception_index_table[number_of_exceptions];</span>
<span class="line-removed"> 861             for (short value : declaredExceptions) {</span>
<span class="line-removed"> 862                 out.writeShort(value);</span>
 863             }
 864         }
<a name="53" id="anc53"></a><span class="line-removed"> 865 </span>
 866     }
 867 
 868     /**
<a name="54" id="anc54"></a><span class="line-modified"> 869      * A ProxyMethod object represents a proxy method in the proxy class</span>
<span class="line-modified"> 870      * being generated: a method whose implementation will encode and</span>
<span class="line-modified"> 871      * dispatch invocations to the proxy instance&#39;s invocation handler.</span>


 872      */
<a name="55" id="anc55"></a><span class="line-modified"> 873     private class ProxyMethod {</span>
<span class="line-modified"> 874 </span>
<span class="line-modified"> 875         public String methodName;</span>
<span class="line-removed"> 876         public Class&lt;?&gt;[] parameterTypes;</span>
<span class="line-removed"> 877         public Class&lt;?&gt; returnType;</span>
<span class="line-removed"> 878         public Class&lt;?&gt;[] exceptionTypes;</span>
<span class="line-removed"> 879         public Class&lt;?&gt; fromClass;</span>
<span class="line-removed"> 880         public String methodFieldName;</span>
 881 
<a name="56" id="anc56"></a><span class="line-modified"> 882         private ProxyMethod(String methodName, Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-modified"> 883                             Class&lt;?&gt; returnType, Class&lt;?&gt;[] exceptionTypes,</span>
<span class="line-modified"> 884                             Class&lt;?&gt; fromClass)</span>
<span class="line-modified"> 885         {</span>
<span class="line-modified"> 886             this.methodName = methodName;</span>
<span class="line-modified"> 887             this.parameterTypes = parameterTypes;</span>
<span class="line-modified"> 888             this.returnType = returnType;</span>
<span class="line-removed"> 889             this.exceptionTypes = exceptionTypes;</span>
<span class="line-removed"> 890             this.fromClass = fromClass;</span>
<span class="line-removed"> 891             this.methodFieldName = &quot;m&quot; + proxyMethodCount++;</span>
<span class="line-removed"> 892         }</span>
 893 
<a name="57" id="anc57"></a><span class="line-modified"> 894         /**</span>
<span class="line-modified"> 895          * Return a MethodInfo object for this method, including generating</span>
<span class="line-modified"> 896          * the code and exception table entry.</span>



 897          */
<a name="58" id="anc58"></a><span class="line-modified"> 898         private MethodInfo generateMethod() throws IOException {</span>
<span class="line-modified"> 899             String desc = getMethodDescriptor(parameterTypes, returnType);</span>
<span class="line-modified"> 900             MethodInfo minfo = new MethodInfo(methodName, desc,</span>
<span class="line-removed"> 901                 ACC_PUBLIC | ACC_FINAL);</span>
 902 
<a name="59" id="anc59"></a><span class="line-modified"> 903             int[] parameterSlot = new int[parameterTypes.length];</span>
<span class="line-modified"> 904             int nextSlot = 1;</span>
<span class="line-modified"> 905             for (int i = 0; i &lt; parameterSlot.length; i++) {</span>
<span class="line-modified"> 906                 parameterSlot[i] = nextSlot;</span>
<span class="line-modified"> 907                 nextSlot += getWordsPerType(parameterTypes[i]);</span>



 908             }
<a name="60" id="anc60"></a><span class="line-modified"> 909             int localSlot0 = nextSlot;</span>
<span class="line-removed"> 910             short pc, tryBegin = 0, tryEnd;</span>
<span class="line-removed"> 911 </span>
<span class="line-removed"> 912             DataOutputStream out = new DataOutputStream(minfo.code);</span>
<span class="line-removed"> 913 </span>
<span class="line-removed"> 914             code_aload(0, out);</span>
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916             out.writeByte(opc_getfield);</span>
<span class="line-removed"> 917             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed"> 918                 superclassName,</span>
<span class="line-removed"> 919                 handlerFieldName, &quot;Ljava/lang/reflect/InvocationHandler;&quot;));</span>
 920 
<a name="61" id="anc61"></a><span class="line-modified"> 921             code_aload(0, out);</span>






 922 
<a name="62" id="anc62"></a><span class="line-modified"> 923             out.writeByte(opc_getstatic);</span>
<span class="line-removed"> 924             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed"> 925                 dotToSlash(className),</span>
<span class="line-removed"> 926                 methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));</span>
 927 
<a name="63" id="anc63"></a><span class="line-modified"> 928             if (parameterTypes.length &gt; 0) {</span>




 929 
<a name="64" id="anc64"></a><span class="line-modified"> 930                 code_ipush(parameterTypes.length, out);</span>



 931 
<a name="65" id="anc65"></a><span class="line-modified"> 932                 out.writeByte(opc_anewarray);</span>
<span class="line-removed"> 933                 out.writeShort(cp.getClass(&quot;java/lang/Object&quot;));</span>
 934 
<a name="66" id="anc66"></a><span class="line-modified"> 935                 for (int i = 0; i &lt; parameterTypes.length; i++) {</span>

 936 
<a name="67" id="anc67"></a><span class="line-modified"> 937                     out.writeByte(opc_dup);</span>















 938 
<a name="68" id="anc68"></a><span class="line-modified"> 939                     code_ipush(i, out);</span>























 940 
<a name="69" id="anc69"></a><span class="line-modified"> 941                     codeWrapArgument(parameterTypes[i], parameterSlot[i], out);</span>










 942 
<a name="70" id="anc70"></a><span class="line-modified"> 943                     out.writeByte(opc_aastore);</span>
<span class="line-modified"> 944                 }</span>
<span class="line-modified"> 945             } else {</span>















 946 
<a name="71" id="anc71"></a><span class="line-modified"> 947                 out.writeByte(opc_aconst_null);</span>
<span class="line-modified"> 948             }</span>




















































 949 
<a name="72" id="anc72"></a><span class="line-modified"> 950             out.writeByte(opc_invokeinterface);</span>
<span class="line-modified"> 951             out.writeShort(cp.getInterfaceMethodRef(</span>
<span class="line-modified"> 952                 &quot;java/lang/reflect/InvocationHandler&quot;,</span>
<span class="line-modified"> 953                 &quot;invoke&quot;,</span>
<span class="line-modified"> 954                 &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +</span>
<span class="line-modified"> 955                     &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;));</span>
<span class="line-removed"> 956             out.writeByte(4);</span>
<span class="line-removed"> 957             out.writeByte(0);</span>
 958 
<a name="73" id="anc73"></a><span class="line-modified"> 959             if (returnType == void.class) {</span>






 960 
<a name="74" id="anc74"></a><span class="line-modified"> 961                 out.writeByte(opc_pop);</span>










 962 
<a name="75" id="anc75"></a><span class="line-modified"> 963                 out.writeByte(opc_return);</span>










 964 
<a name="76" id="anc76"></a><span class="line-modified"> 965             } else {</span>








 966 
<a name="77" id="anc77"></a><span class="line-modified"> 967                 codeUnwrapReturnValue(returnType, out);</span>




 968             }
 969 
<a name="78" id="anc78"></a><span class="line-modified"> 970             tryEnd = pc = (short) minfo.code.size();</span>




 971 
 972             List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
 973             if (catchList.size() &gt; 0) {
<a name="79" id="anc79"></a><span class="line-removed"> 974 </span>
 975                 for (Class&lt;?&gt; ex : catchList) {
<a name="80" id="anc80"></a><span class="line-modified"> 976                     minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-modified"> 977                         tryBegin, tryEnd, pc,</span>
<span class="line-removed"> 978                         cp.getClass(dotToSlash(ex.getName()))));</span>
 979                 }
 980 
<a name="81" id="anc81"></a><span class="line-modified"> 981                 out.writeByte(opc_athrow);</span>
<span class="line-modified"> 982 </span>
<span class="line-modified"> 983                 pc = (short) minfo.code.size();</span>
<span class="line-modified"> 984 </span>
<span class="line-removed"> 985                 minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed"> 986                     tryBegin, tryEnd, pc, cp.getClass(&quot;java/lang/Throwable&quot;)));</span>
<span class="line-removed"> 987 </span>
<span class="line-removed"> 988                 code_astore(localSlot0, out);</span>
<span class="line-removed"> 989 </span>
<span class="line-removed"> 990                 out.writeByte(opc_new);</span>
<span class="line-removed"> 991                 out.writeShort(cp.getClass(</span>
<span class="line-removed"> 992                     &quot;java/lang/reflect/UndeclaredThrowableException&quot;));</span>
<span class="line-removed"> 993 </span>
<span class="line-removed"> 994                 out.writeByte(opc_dup);</span>
 995 
<a name="82" id="anc82"></a><span class="line-modified"> 996                 code_aload(localSlot0, out);</span>





 997 
<a name="83" id="anc83"></a><span class="line-modified"> 998                 out.writeByte(opc_invokespecial);</span>












 999 
<a name="84" id="anc84"></a><span class="line-modified">1000                 out.writeShort(cp.getMethodRef(</span>
<span class="line-modified">1001                     &quot;java/lang/reflect/UndeclaredThrowableException&quot;,</span>
<span class="line-modified">1002                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;));</span>

1003 
<a name="85" id="anc85"></a><span class="line-modified">1004                 out.writeByte(opc_athrow);</span>




1005             }
1006 
<a name="86" id="anc86"></a><span class="line-modified">1007             if (minfo.code.size() &gt; 65535) {</span>
<span class="line-removed">1008                 throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);</span>
<span class="line-removed">1009             }</span>
1010 
<a name="87" id="anc87"></a><span class="line-modified">1011             minfo.maxStack = 10;</span>
<span class="line-modified">1012             minfo.maxLocals = (short) (localSlot0 + 1);</span>
<span class="line-modified">1013             minfo.declaredExceptions = new short[exceptionTypes.length];</span>
<span class="line-removed">1014             for (int i = 0; i &lt; exceptionTypes.length; i++) {</span>
<span class="line-removed">1015                 minfo.declaredExceptions[i] = cp.getClass(</span>
<span class="line-removed">1016                     dotToSlash(exceptionTypes[i].getName()));</span>
<span class="line-removed">1017             }</span>
1018 
<a name="88" id="anc88"></a><span class="line-modified">1019             return minfo;</span>










1020         }
1021 
1022         /**
1023          * Generate code for wrapping an argument of the given type
1024          * whose value can be found at the specified local variable
1025          * index, in order for it to be passed (as an Object) to the
<a name="89" id="anc89"></a><span class="line-modified">1026          * invocation handler&#39;s &quot;invoke&quot; method.  The code is written</span>
<span class="line-removed">1027          * to the supplied stream.</span>
1028          */
<a name="90" id="anc90"></a><span class="line-modified">1029         private void codeWrapArgument(Class&lt;?&gt; type, int slot,</span>
<span class="line-removed">1030                                       DataOutputStream out)</span>
<span class="line-removed">1031             throws IOException</span>
<span class="line-removed">1032         {</span>
1033             if (type.isPrimitive()) {
1034                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
1035 
1036                 if (type == int.class ||
<a name="91" id="anc91"></a><span class="line-modified">1037                     type == boolean.class ||</span>
<span class="line-modified">1038                     type == byte.class ||</span>
<span class="line-modified">1039                     type == char.class ||</span>
<span class="line-modified">1040                     type == short.class)</span>
<span class="line-modified">1041                 {</span>
<span class="line-removed">1042                     code_iload(slot, out);</span>
1043                 } else if (type == long.class) {
<a name="92" id="anc92"></a><span class="line-modified">1044                     code_lload(slot, out);</span>
1045                 } else if (type == float.class) {
<a name="93" id="anc93"></a><span class="line-modified">1046                     code_fload(slot, out);</span>
1047                 } else if (type == double.class) {
<a name="94" id="anc94"></a><span class="line-modified">1048                     code_dload(slot, out);</span>
1049                 } else {
1050                     throw new AssertionError();
1051                 }
<a name="95" id="anc95"></a><span class="line-modified">1052 </span>
<span class="line-modified">1053                 out.writeByte(opc_invokestatic);</span>
<span class="line-removed">1054                 out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1055                     prim.wrapperClassName,</span>
<span class="line-removed">1056                     &quot;valueOf&quot;, prim.wrapperValueOfDesc));</span>
<span class="line-removed">1057 </span>
1058             } else {
<a name="96" id="anc96"></a><span class="line-modified">1059 </span>
<span class="line-removed">1060                 code_aload(slot, out);</span>
1061             }
1062         }
1063 
1064         /**
1065          * Generate code for unwrapping a return value of the given
1066          * type from the invocation handler&#39;s &quot;invoke&quot; method (as type
<a name="97" id="anc97"></a><span class="line-modified">1067          * Object) to its correct type.  The code is written to the</span>
<span class="line-removed">1068          * supplied stream.</span>
1069          */
<a name="98" id="anc98"></a><span class="line-modified">1070         private void codeUnwrapReturnValue(Class&lt;?&gt; type, DataOutputStream out)</span>
<span class="line-removed">1071             throws IOException</span>
<span class="line-removed">1072         {</span>
1073             if (type.isPrimitive()) {
1074                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
1075 
<a name="99" id="anc99"></a><span class="line-modified">1076                 out.writeByte(opc_checkcast);</span>
<span class="line-modified">1077                 out.writeShort(cp.getClass(prim.wrapperClassName));</span>
<span class="line-modified">1078 </span>
<span class="line-modified">1079                 out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">1080                 out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1081                     prim.wrapperClassName,</span>
<span class="line-removed">1082                     prim.unwrapMethodName, prim.unwrapMethodDesc));</span>
1083 
1084                 if (type == int.class ||
<a name="100" id="anc100"></a><span class="line-modified">1085                     type == boolean.class ||</span>
<span class="line-modified">1086                     type == byte.class ||</span>
<span class="line-modified">1087                     type == char.class ||</span>
<span class="line-modified">1088                     type == short.class)</span>
<span class="line-modified">1089                 {</span>
<span class="line-removed">1090                     out.writeByte(opc_ireturn);</span>
1091                 } else if (type == long.class) {
<a name="101" id="anc101"></a><span class="line-modified">1092                     out.writeByte(opc_lreturn);</span>
1093                 } else if (type == float.class) {
<a name="102" id="anc102"></a><span class="line-modified">1094                     out.writeByte(opc_freturn);</span>
1095                 } else if (type == double.class) {
<a name="103" id="anc103"></a><span class="line-modified">1096                     out.writeByte(opc_dreturn);</span>
1097                 } else {
1098                     throw new AssertionError();
1099                 }
<a name="104" id="anc104"></a><span class="line-removed">1100 </span>
1101             } else {
<a name="105" id="anc105"></a><span class="line-modified">1102 </span>
<span class="line-modified">1103                 out.writeByte(opc_checkcast);</span>
<span class="line-removed">1104                 out.writeShort(cp.getClass(dotToSlash(type.getName())));</span>
<span class="line-removed">1105 </span>
<span class="line-removed">1106                 out.writeByte(opc_areturn);</span>
1107             }
1108         }
1109 
1110         /**
1111          * Generate code for initializing the static field that stores
<a name="106" id="anc106"></a><span class="line-modified">1112          * the Method object for this proxy method.  The code is written</span>
<span class="line-removed">1113          * to the supplied stream.</span>
1114          */
<a name="107" id="anc107"></a><span class="line-modified">1115         private void codeFieldInitialization(DataOutputStream out)</span>
<span class="line-modified">1116             throws IOException</span>
<span class="line-removed">1117         {</span>
<span class="line-removed">1118             codeClassForName(fromClass, out);</span>
1119 
<a name="108" id="anc108"></a><span class="line-modified">1120             code_ldc(cp.getString(methodName), out);</span>
1121 
<a name="109" id="anc109"></a><span class="line-modified">1122             code_ipush(parameterTypes.length, out);</span>
1123 
<a name="110" id="anc110"></a><span class="line-modified">1124             out.writeByte(opc_anewarray);</span>
<span class="line-removed">1125             out.writeShort(cp.getClass(&quot;java/lang/Class&quot;));</span>
1126 
<a name="111" id="anc111"></a>
1127             for (int i = 0; i &lt; parameterTypes.length; i++) {
<a name="112" id="anc112"></a><span class="line-modified">1128 </span>
<span class="line-modified">1129                 out.writeByte(opc_dup);</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131                 code_ipush(i, out);</span>
1132 
1133                 if (parameterTypes[i].isPrimitive()) {
1134                     PrimitiveTypeInfo prim =
<a name="113" id="anc113"></a><span class="line-modified">1135                         PrimitiveTypeInfo.get(parameterTypes[i]);</span>
<span class="line-modified">1136 </span>
<span class="line-modified">1137                     out.writeByte(opc_getstatic);</span>
<span class="line-removed">1138                     out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">1139                         prim.wrapperClassName, &quot;TYPE&quot;, &quot;Ljava/lang/Class;&quot;));</span>
<span class="line-removed">1140 </span>
1141                 } else {
<a name="114" id="anc114"></a><span class="line-modified">1142                     codeClassForName(parameterTypes[i], out);</span>
1143                 }
<a name="115" id="anc115"></a><span class="line-modified">1144 </span>
<span class="line-removed">1145                 out.writeByte(opc_aastore);</span>
1146             }
<a name="116" id="anc116"></a>





1147 
<a name="117" id="anc117"></a><span class="line-modified">1148             out.writeByte(opc_invokevirtual);</span>
<span class="line-modified">1149             out.writeShort(cp.getMethodRef(</span>
<span class="line-modified">1150                 &quot;java/lang/Class&quot;,</span>
<span class="line-removed">1151                 &quot;getMethod&quot;,</span>
<span class="line-removed">1152                 &quot;(Ljava/lang/String;[Ljava/lang/Class;)&quot; +</span>
<span class="line-removed">1153                 &quot;Ljava/lang/reflect/Method;&quot;));</span>
<span class="line-removed">1154 </span>
<span class="line-removed">1155             out.writeByte(opc_putstatic);</span>
<span class="line-removed">1156             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">1157                 dotToSlash(className),</span>
<span class="line-removed">1158                 methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));</span>
1159         }
<a name="118" id="anc118"></a><span class="line-removed">1160     }</span>
<span class="line-removed">1161 </span>
<span class="line-removed">1162     /**</span>
<span class="line-removed">1163      * Generate the constructor method for the proxy class.</span>
<span class="line-removed">1164      */</span>
<span class="line-removed">1165     private MethodInfo generateConstructor() throws IOException {</span>
<span class="line-removed">1166         MethodInfo minfo = new MethodInfo(</span>
<span class="line-removed">1167             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,</span>
<span class="line-removed">1168             ACC_PUBLIC);</span>
<span class="line-removed">1169 </span>
<span class="line-removed">1170         DataOutputStream out = new DataOutputStream(minfo.code);</span>
<span class="line-removed">1171 </span>
<span class="line-removed">1172         code_aload(0, out);</span>
1173 
<a name="119" id="anc119"></a><span class="line-modified">1174         code_aload(1, out);</span>
<span class="line-modified">1175 </span>
<span class="line-modified">1176         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">1177         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1178             superclassName,</span>
<span class="line-removed">1179             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;));</span>
<span class="line-removed">1180 </span>
<span class="line-removed">1181         out.writeByte(opc_return);</span>
<span class="line-removed">1182 </span>
<span class="line-removed">1183         minfo.maxStack = 10;</span>
<span class="line-removed">1184         minfo.maxLocals = 2;</span>
<span class="line-removed">1185         minfo.declaredExceptions = new short[0];</span>
<span class="line-removed">1186 </span>
<span class="line-removed">1187         return minfo;</span>
<span class="line-removed">1188     }</span>
<span class="line-removed">1189 </span>
<span class="line-removed">1190     /**</span>
<span class="line-removed">1191      * Generate the static initializer method for the proxy class.</span>
<span class="line-removed">1192      */</span>
<span class="line-removed">1193     private MethodInfo generateStaticInitializer() throws IOException {</span>
<span class="line-removed">1194         MethodInfo minfo = new MethodInfo(</span>
<span class="line-removed">1195             &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, ACC_STATIC);</span>
<span class="line-removed">1196 </span>
<span class="line-removed">1197         int localSlot0 = 1;</span>
<span class="line-removed">1198         short pc, tryBegin = 0, tryEnd;</span>
1199 
<a name="120" id="anc120"></a><span class="line-modified">1200         DataOutputStream out = new DataOutputStream(minfo.code);</span>











1201 
<a name="121" id="anc121"></a><span class="line-modified">1202         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-modified">1203             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-modified">1204                 pm.codeFieldInitialization(out);</span>












1205             }
1206         }
1207 
<a name="122" id="anc122"></a><span class="line-modified">1208         out.writeByte(opc_return);</span>
<span class="line-modified">1209 </span>
<span class="line-modified">1210         tryEnd = pc = (short) minfo.code.size();</span>
<span class="line-removed">1211 </span>
<span class="line-removed">1212         minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">1213             tryBegin, tryEnd, pc,</span>
<span class="line-removed">1214             cp.getClass(&quot;java/lang/NoSuchMethodException&quot;)));</span>
<span class="line-removed">1215 </span>
<span class="line-removed">1216         code_astore(localSlot0, out);</span>
<span class="line-removed">1217 </span>
<span class="line-removed">1218         out.writeByte(opc_new);</span>
<span class="line-removed">1219         out.writeShort(cp.getClass(&quot;java/lang/NoSuchMethodError&quot;));</span>
<span class="line-removed">1220 </span>
<span class="line-removed">1221         out.writeByte(opc_dup);</span>
<span class="line-removed">1222 </span>
<span class="line-removed">1223         code_aload(localSlot0, out);</span>
<span class="line-removed">1224 </span>
<span class="line-removed">1225         out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">1226         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1227             &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));</span>
<span class="line-removed">1228 </span>
<span class="line-removed">1229         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">1230         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1231             &quot;java/lang/NoSuchMethodError&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));</span>
<span class="line-removed">1232 </span>
<span class="line-removed">1233         out.writeByte(opc_athrow);</span>
<span class="line-removed">1234 </span>
<span class="line-removed">1235         pc = (short) minfo.code.size();</span>
<span class="line-removed">1236 </span>
<span class="line-removed">1237         minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">1238             tryBegin, tryEnd, pc,</span>
<span class="line-removed">1239             cp.getClass(&quot;java/lang/ClassNotFoundException&quot;)));</span>
<span class="line-removed">1240 </span>
<span class="line-removed">1241         code_astore(localSlot0, out);</span>
<span class="line-removed">1242 </span>
<span class="line-removed">1243         out.writeByte(opc_new);</span>
<span class="line-removed">1244         out.writeShort(cp.getClass(&quot;java/lang/NoClassDefFoundError&quot;));</span>
<span class="line-removed">1245 </span>
<span class="line-removed">1246         out.writeByte(opc_dup);</span>
<span class="line-removed">1247 </span>
<span class="line-removed">1248         code_aload(localSlot0, out);</span>
<span class="line-removed">1249 </span>
<span class="line-removed">1250         out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">1251         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1252             &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));</span>
<span class="line-removed">1253 </span>
<span class="line-removed">1254         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">1255         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1256             &quot;java/lang/NoClassDefFoundError&quot;,</span>
<span class="line-removed">1257             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));</span>
<span class="line-removed">1258 </span>
<span class="line-removed">1259         out.writeByte(opc_athrow);</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261         if (minfo.code.size() &gt; 65535) {</span>
<span class="line-removed">1262             throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);</span>
1263         }
<a name="123" id="anc123"></a><span class="line-removed">1264 </span>
<span class="line-removed">1265         minfo.maxStack = 10;</span>
<span class="line-removed">1266         minfo.maxLocals = (short) (localSlot0 + 1);</span>
<span class="line-removed">1267         minfo.declaredExceptions = new short[0];</span>
<span class="line-removed">1268 </span>
<span class="line-removed">1269         return minfo;</span>
1270     }
1271 
<a name="124" id="anc124"></a><span class="line-modified">1272 </span>
<span class="line-modified">1273     /*</span>
<span class="line-modified">1274      * =============== Code Generation Utility Methods ===============</span>
<span class="line-modified">1275      */</span>
<span class="line-removed">1276 </span>
<span class="line-removed">1277     /*</span>
<span class="line-removed">1278      * The following methods generate code for the load or store operation</span>
<span class="line-removed">1279      * indicated by their name for the given local variable.  The code is</span>
<span class="line-removed">1280      * written to the supplied stream.</span>
1281      */
<a name="125" id="anc125"></a>
1282 
<a name="126" id="anc126"></a><span class="line-modified">1283     private void code_iload(int lvar, DataOutputStream out)</span>
<span class="line-removed">1284         throws IOException</span>
<span class="line-removed">1285     {</span>
<span class="line-removed">1286         codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out);</span>
<span class="line-removed">1287     }</span>
<span class="line-removed">1288 </span>
<span class="line-removed">1289     private void code_lload(int lvar, DataOutputStream out)</span>
<span class="line-removed">1290         throws IOException</span>
<span class="line-removed">1291     {</span>
<span class="line-removed">1292         codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out);</span>
<span class="line-removed">1293     }</span>
<span class="line-removed">1294 </span>
<span class="line-removed">1295     private void code_fload(int lvar, DataOutputStream out)</span>
<span class="line-removed">1296         throws IOException</span>
<span class="line-removed">1297     {</span>
<span class="line-removed">1298         codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out);</span>
<span class="line-removed">1299     }</span>
1300 
<a name="127" id="anc127"></a><span class="line-modified">1301     private void code_dload(int lvar, DataOutputStream out)</span>
<span class="line-modified">1302         throws IOException</span>
<span class="line-modified">1303     {</span>
<span class="line-modified">1304         codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out);</span>
<span class="line-modified">1305     }</span>





1306 
<a name="128" id="anc128"></a><span class="line-modified">1307     private void code_aload(int lvar, DataOutputStream out)</span>
<span class="line-modified">1308         throws IOException</span>
<span class="line-modified">1309     {</span>
<span class="line-modified">1310         codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out);</span>
<span class="line-modified">1311     }</span>











1312 
<a name="129" id="anc129"></a><span class="line-modified">1313 //  private void code_istore(int lvar, DataOutputStream out)</span>
<span class="line-modified">1314 //      throws IOException</span>
<span class="line-removed">1315 //  {</span>
<span class="line-removed">1316 //      codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out);</span>
<span class="line-removed">1317 //  }</span>
<span class="line-removed">1318 </span>
<span class="line-removed">1319 //  private void code_lstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1320 //      throws IOException</span>
<span class="line-removed">1321 //  {</span>
<span class="line-removed">1322 //      codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out);</span>
<span class="line-removed">1323 //  }</span>
<span class="line-removed">1324 </span>
<span class="line-removed">1325 //  private void code_fstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1326 //      throws IOException</span>
<span class="line-removed">1327 //  {</span>
<span class="line-removed">1328 //      codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out);</span>
<span class="line-removed">1329 //  }</span>
<span class="line-removed">1330 </span>
<span class="line-removed">1331 //  private void code_dstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1332 //      throws IOException</span>
<span class="line-removed">1333 //  {</span>
<span class="line-removed">1334 //      codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out);</span>
<span class="line-removed">1335 //  }</span>
<span class="line-removed">1336 </span>
<span class="line-removed">1337     private void code_astore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1338         throws IOException</span>
<span class="line-removed">1339     {</span>
<span class="line-removed">1340         codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out);</span>
<span class="line-removed">1341     }</span>
1342 
<a name="130" id="anc130"></a><span class="line-modified">1343     /**</span>
<span class="line-modified">1344      * Generate code for a load or store instruction for the given local</span>
<span class="line-removed">1345      * variable.  The code is written to the supplied stream.</span>
<span class="line-removed">1346      *</span>
<span class="line-removed">1347      * &quot;opcode&quot; indicates the opcode form of the desired load or store</span>
<span class="line-removed">1348      * instruction that takes an explicit local variable index, and</span>
<span class="line-removed">1349      * &quot;opcode_0&quot; indicates the corresponding form of the instruction</span>
<span class="line-removed">1350      * with the implicit index 0.</span>
<span class="line-removed">1351      */</span>
<span class="line-removed">1352     private void codeLocalLoadStore(int lvar, int opcode, int opcode_0,</span>
<span class="line-removed">1353                                     DataOutputStream out)</span>
<span class="line-removed">1354         throws IOException</span>
<span class="line-removed">1355     {</span>
<span class="line-removed">1356         assert lvar &gt;= 0 &amp;&amp; lvar &lt;= 0xFFFF;</span>
<span class="line-removed">1357         if (lvar &lt;= 3) {</span>
<span class="line-removed">1358             out.writeByte(opcode_0 + lvar);</span>
<span class="line-removed">1359         } else if (lvar &lt;= 0xFF) {</span>
<span class="line-removed">1360             out.writeByte(opcode);</span>
<span class="line-removed">1361             out.writeByte(lvar &amp; 0xFF);</span>
<span class="line-removed">1362         } else {</span>
<span class="line-removed">1363             /*</span>
<span class="line-removed">1364              * Use the &quot;wide&quot; instruction modifier for local variable</span>
<span class="line-removed">1365              * indexes that do not fit into an unsigned byte.</span>
1366              */
<a name="131" id="anc131"></a><span class="line-modified">1367             out.writeByte(opc_wide);</span>
<span class="line-modified">1368             out.writeByte(opcode);</span>
<span class="line-modified">1369             out.writeShort(lvar &amp; 0xFFFF);</span>
<span class="line-modified">1370         }</span>
<span class="line-modified">1371     }</span>
<span class="line-modified">1372 </span>
<span class="line-modified">1373     /**</span>
<span class="line-modified">1374      * Generate code for an &quot;ldc&quot; instruction for the given constant pool</span>
<span class="line-removed">1375      * index (the &quot;ldc_w&quot; instruction is used if the index does not fit</span>
<span class="line-removed">1376      * into an unsigned byte).  The code is written to the supplied stream.</span>
<span class="line-removed">1377      */</span>
<span class="line-removed">1378     private void code_ldc(int index, DataOutputStream out)</span>
<span class="line-removed">1379         throws IOException</span>
<span class="line-removed">1380     {</span>
<span class="line-removed">1381         assert index &gt;= 0 &amp;&amp; index &lt;= 0xFFFF;</span>
<span class="line-removed">1382         if (index &lt;= 0xFF) {</span>
<span class="line-removed">1383             out.writeByte(opc_ldc);</span>
<span class="line-removed">1384             out.writeByte(index &amp; 0xFF);</span>
<span class="line-removed">1385         } else {</span>
<span class="line-removed">1386             out.writeByte(opc_ldc_w);</span>
<span class="line-removed">1387             out.writeShort(index &amp; 0xFFFF);</span>
1388         }
<a name="132" id="anc132"></a><span class="line-removed">1389     }</span>
1390 
<a name="133" id="anc133"></a><span class="line-modified">1391     /**</span>
<span class="line-modified">1392      * Generate code to push a constant integer value on to the operand</span>
<span class="line-modified">1393      * stack, using the &quot;iconst_&lt;i&gt;&quot;, &quot;bipush&quot;, or &quot;sipush&quot; instructions</span>
<span class="line-removed">1394      * depending on the size of the value.  The code is written to the</span>
<span class="line-removed">1395      * supplied stream.</span>
<span class="line-removed">1396      */</span>
<span class="line-removed">1397     private void code_ipush(int value, DataOutputStream out)</span>
<span class="line-removed">1398         throws IOException</span>
<span class="line-removed">1399     {</span>
<span class="line-removed">1400         if (value &gt;= -1 &amp;&amp; value &lt;= 5) {</span>
<span class="line-removed">1401             out.writeByte(opc_iconst_0 + value);</span>
<span class="line-removed">1402         } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">1403             out.writeByte(opc_bipush);</span>
<span class="line-removed">1404             out.writeByte(value &amp; 0xFF);</span>
<span class="line-removed">1405         } else if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">1406             out.writeByte(opc_sipush);</span>
<span class="line-removed">1407             out.writeShort(value &amp; 0xFFFF);</span>
<span class="line-removed">1408         } else {</span>
<span class="line-removed">1409             throw new AssertionError();</span>
<span class="line-removed">1410         }</span>
<span class="line-removed">1411     }</span>
<span class="line-removed">1412 </span>
<span class="line-removed">1413     /**</span>
<span class="line-removed">1414      * Generate code to invoke the Class.forName with the name of the given</span>
<span class="line-removed">1415      * class to get its Class object at runtime.  The code is written to</span>
<span class="line-removed">1416      * the supplied stream.  Note that the code generated by this method</span>
<span class="line-removed">1417      * may cause the checked ClassNotFoundException to be thrown.</span>
<span class="line-removed">1418      */</span>
<span class="line-removed">1419     private void codeClassForName(Class&lt;?&gt; cl, DataOutputStream out)</span>
<span class="line-removed">1420         throws IOException</span>
<span class="line-removed">1421     {</span>
<span class="line-removed">1422         code_ldc(cp.getString(cl.getName()), out);</span>
<span class="line-removed">1423 </span>
<span class="line-removed">1424         out.writeByte(opc_invokestatic);</span>
<span class="line-removed">1425         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1426             &quot;java/lang/Class&quot;,</span>
<span class="line-removed">1427             &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;));</span>
<span class="line-removed">1428     }</span>
<span class="line-removed">1429 </span>
<span class="line-removed">1430 </span>
<span class="line-removed">1431     /*</span>
<span class="line-removed">1432      * ==================== General Utility Methods ====================</span>
<span class="line-removed">1433      */</span>
<span class="line-removed">1434 </span>
<span class="line-removed">1435     /**</span>
<span class="line-removed">1436      * Convert a fully qualified class name that uses &#39;.&#39; as the package</span>
<span class="line-removed">1437      * separator, the external representation used by the Java language</span>
<span class="line-removed">1438      * and APIs, to a fully qualified class name that uses &#39;/&#39; as the</span>
<span class="line-removed">1439      * package separator, the representation used in the class file</span>
<span class="line-removed">1440      * format (see JVMS section 4.2).</span>
<span class="line-removed">1441      */</span>
<span class="line-removed">1442     private static String dotToSlash(String name) {</span>
<span class="line-removed">1443         return name.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">1444     }</span>
<span class="line-removed">1445 </span>
<span class="line-removed">1446     /**</span>
<span class="line-removed">1447      * Return the &quot;method descriptor&quot; string for a method with the given</span>
<span class="line-removed">1448      * parameter types and return type.  See JVMS section 4.3.3.</span>
<span class="line-removed">1449      */</span>
<span class="line-removed">1450     private static String getMethodDescriptor(Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-removed">1451                                               Class&lt;?&gt; returnType)</span>
<span class="line-removed">1452     {</span>
<span class="line-removed">1453         return getParameterDescriptors(parameterTypes) +</span>
<span class="line-removed">1454             ((returnType == void.class) ? &quot;V&quot; : getFieldType(returnType));</span>
<span class="line-removed">1455     }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457     /**</span>
<span class="line-removed">1458      * Return the list of &quot;parameter descriptor&quot; strings enclosed in</span>
<span class="line-removed">1459      * parentheses corresponding to the given parameter types (in other</span>
<span class="line-removed">1460      * words, a method descriptor without a return descriptor).  This</span>
<span class="line-removed">1461      * string is useful for constructing string keys for methods without</span>
<span class="line-removed">1462      * regard to their return type.</span>
<span class="line-removed">1463      */</span>
<span class="line-removed">1464     private static String getParameterDescriptors(Class&lt;?&gt;[] parameterTypes) {</span>
<span class="line-removed">1465         StringBuilder desc = new StringBuilder(&quot;(&quot;);</span>
<span class="line-removed">1466         for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-removed">1467             desc.append(getFieldType(parameterTypes[i]));</span>
<span class="line-removed">1468         }</span>
<span class="line-removed">1469         desc.append(&#39;)&#39;);</span>
<span class="line-removed">1470         return desc.toString();</span>
<span class="line-removed">1471     }</span>
<span class="line-removed">1472 </span>
<span class="line-removed">1473     /**</span>
<span class="line-removed">1474      * Return the &quot;field type&quot; string for the given type, appropriate for</span>
<span class="line-removed">1475      * a field descriptor, a parameter descriptor, or a return descriptor</span>
<span class="line-removed">1476      * other than &quot;void&quot;.  See JVMS section 4.3.2.</span>
<span class="line-removed">1477      */</span>
<span class="line-removed">1478     private static String getFieldType(Class&lt;?&gt; type) {</span>
<span class="line-removed">1479         if (type.isPrimitive()) {</span>
<span class="line-removed">1480             return PrimitiveTypeInfo.get(type).baseTypeString;</span>
<span class="line-removed">1481         } else if (type.isArray()) {</span>
<span class="line-removed">1482             /*</span>
<span class="line-removed">1483              * According to JLS 20.3.2, the getName() method on Class does</span>
<span class="line-removed">1484              * return the VM type descriptor format for array classes (only);</span>
<span class="line-removed">1485              * using that should be quicker than the otherwise obvious code:</span>
<span class="line-removed">1486              *</span>
<span class="line-removed">1487              *     return &quot;[&quot; + getTypeDescriptor(type.getComponentType());</span>
<span class="line-removed">1488              */</span>
<span class="line-removed">1489             return type.getName().replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">1490         } else {</span>
<span class="line-removed">1491             return &quot;L&quot; + dotToSlash(type.getName()) + &quot;;&quot;;</span>
<span class="line-removed">1492         }</span>
<span class="line-removed">1493     }</span>
<span class="line-removed">1494 </span>
<span class="line-removed">1495     /**</span>
<span class="line-removed">1496      * Returns a human-readable string representing the signature of a</span>
<span class="line-removed">1497      * method with the given name and parameter types.</span>
<span class="line-removed">1498      */</span>
<span class="line-removed">1499     private static String getFriendlyMethodSignature(String name,</span>
<span class="line-removed">1500                                                      Class&lt;?&gt;[] parameterTypes)</span>
<span class="line-removed">1501     {</span>
<span class="line-removed">1502         StringBuilder sig = new StringBuilder(name);</span>
<span class="line-removed">1503         sig.append(&#39;(&#39;);</span>
<span class="line-removed">1504         for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-removed">1505             if (i &gt; 0) {</span>
<span class="line-removed">1506                 sig.append(&#39;,&#39;);</span>
<span class="line-removed">1507             }</span>
<span class="line-removed">1508             Class&lt;?&gt; parameterType = parameterTypes[i];</span>
<span class="line-removed">1509             int dimensions = 0;</span>
<span class="line-removed">1510             while (parameterType.isArray()) {</span>
<span class="line-removed">1511                 parameterType = parameterType.getComponentType();</span>
<span class="line-removed">1512                 dimensions++;</span>
<span class="line-removed">1513             }</span>
<span class="line-removed">1514             sig.append(parameterType.getName());</span>
<span class="line-removed">1515             while (dimensions-- &gt; 0) {</span>
<span class="line-removed">1516                 sig.append(&quot;[]&quot;);</span>
<span class="line-removed">1517             }</span>
<span class="line-removed">1518         }</span>
<span class="line-removed">1519         sig.append(&#39;)&#39;);</span>
<span class="line-removed">1520         return sig.toString();</span>
<span class="line-removed">1521     }</span>
<span class="line-removed">1522 </span>
<span class="line-removed">1523     /**</span>
<span class="line-removed">1524      * Return the number of abstract &quot;words&quot;, or consecutive local variable</span>
<span class="line-removed">1525      * indexes, required to contain a value of the given type.  See JVMS</span>
<span class="line-removed">1526      * section 3.6.1.</span>
<span class="line-removed">1527      *</span>
<span class="line-removed">1528      * Note that the original version of the JVMS contained a definition of</span>
<span class="line-removed">1529      * this abstract notion of a &quot;word&quot; in section 3.4, but that definition</span>
<span class="line-removed">1530      * was removed for the second edition.</span>
<span class="line-removed">1531      */</span>
<span class="line-removed">1532     private static int getWordsPerType(Class&lt;?&gt; type) {</span>
<span class="line-removed">1533         if (type == long.class || type == double.class) {</span>
<span class="line-removed">1534             return 2;</span>
<span class="line-removed">1535         } else {</span>
<span class="line-removed">1536             return 1;</span>
<span class="line-removed">1537         }</span>
<span class="line-removed">1538     }</span>
<span class="line-removed">1539 </span>
<span class="line-removed">1540     /**</span>
<span class="line-removed">1541      * Add to the given list all of the types in the &quot;from&quot; array that</span>
<span class="line-removed">1542      * are not already contained in the list and are assignable to at</span>
<span class="line-removed">1543      * least one of the types in the &quot;with&quot; array.</span>
<span class="line-removed">1544      *</span>
<span class="line-removed">1545      * This method is useful for computing the greatest common set of</span>
<span class="line-removed">1546      * declared exceptions from duplicate methods inherited from</span>
<span class="line-removed">1547      * different interfaces.</span>
<span class="line-removed">1548      */</span>
<span class="line-removed">1549     private static void collectCompatibleTypes(Class&lt;?&gt;[] from,</span>
<span class="line-removed">1550                                                Class&lt;?&gt;[] with,</span>
<span class="line-removed">1551                                                List&lt;Class&lt;?&gt;&gt; list)</span>
<span class="line-removed">1552     {</span>
<span class="line-removed">1553         for (Class&lt;?&gt; fc: from) {</span>
<span class="line-removed">1554             if (!list.contains(fc)) {</span>
<span class="line-removed">1555                 for (Class&lt;?&gt; wc: with) {</span>
<span class="line-removed">1556                     if (wc.isAssignableFrom(fc)) {</span>
<span class="line-removed">1557                         list.add(fc);</span>
<span class="line-removed">1558                         break;</span>
<span class="line-removed">1559                     }</span>
<span class="line-removed">1560                 }</span>
<span class="line-removed">1561             }</span>
<span class="line-removed">1562         }</span>
<span class="line-removed">1563     }</span>
<span class="line-removed">1564 </span>
<span class="line-removed">1565     /**</span>
<span class="line-removed">1566      * Given the exceptions declared in the throws clause of a proxy method,</span>
<span class="line-removed">1567      * compute the exceptions that need to be caught from the invocation</span>
<span class="line-removed">1568      * handler&#39;s invoke method and rethrown intact in the method&#39;s</span>
<span class="line-removed">1569      * implementation before catching other Throwables and wrapping them</span>
<span class="line-removed">1570      * in UndeclaredThrowableExceptions.</span>
<span class="line-removed">1571      *</span>
<span class="line-removed">1572      * The exceptions to be caught are returned in a List object.  Each</span>
<span class="line-removed">1573      * exception in the returned list is guaranteed to not be a subclass of</span>
<span class="line-removed">1574      * any of the other exceptions in the list, so the catch blocks for</span>
<span class="line-removed">1575      * these exceptions may be generated in any order relative to each other.</span>
<span class="line-removed">1576      *</span>
<span class="line-removed">1577      * Error and RuntimeException are each always contained by the returned</span>
<span class="line-removed">1578      * list (if none of their superclasses are contained), since those</span>
<span class="line-removed">1579      * unchecked exceptions should always be rethrown intact, and thus their</span>
<span class="line-removed">1580      * subclasses will never appear in the returned list.</span>
<span class="line-removed">1581      *</span>
<span class="line-removed">1582      * The returned List will be empty if java.lang.Throwable is in the</span>
<span class="line-removed">1583      * given list of declared exceptions, indicating that no exceptions</span>
<span class="line-removed">1584      * need to be caught.</span>
<span class="line-removed">1585      */</span>
<span class="line-removed">1586     private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {</span>
<span class="line-removed">1587         List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;&gt;();</span>
<span class="line-removed">1588                                                 // unique exceptions to catch</span>
<span class="line-removed">1589 </span>
<span class="line-removed">1590         uniqueList.add(Error.class);            // always catch/rethrow these</span>
<span class="line-removed">1591         uniqueList.add(RuntimeException.class);</span>
<span class="line-removed">1592 </span>
<span class="line-removed">1593     nextException:</span>
<span class="line-removed">1594         for (Class&lt;?&gt; ex: exceptions) {</span>
<span class="line-removed">1595             if (ex.isAssignableFrom(Throwable.class)) {</span>
<span class="line-removed">1596                 /*</span>
<span class="line-removed">1597                  * If Throwable is declared to be thrown by the proxy method,</span>
<span class="line-removed">1598                  * then no catch blocks are necessary, because the invoke</span>
<span class="line-removed">1599                  * can, at most, throw Throwable anyway.</span>
<span class="line-removed">1600                  */</span>
<span class="line-removed">1601                 uniqueList.clear();</span>
<span class="line-removed">1602                 break;</span>
<span class="line-removed">1603             } else if (!Throwable.class.isAssignableFrom(ex)) {</span>
<span class="line-removed">1604                 /*</span>
<span class="line-removed">1605                  * Ignore types that cannot be thrown by the invoke method.</span>
<span class="line-removed">1606                  */</span>
<span class="line-removed">1607                 continue;</span>
<span class="line-removed">1608             }</span>
<span class="line-removed">1609             /*</span>
<span class="line-removed">1610              * Compare this exception against the current list of</span>
<span class="line-removed">1611              * exceptions that need to be caught:</span>
<span class="line-removed">1612              */</span>
<span class="line-removed">1613             for (int j = 0; j &lt; uniqueList.size();) {</span>
<span class="line-removed">1614                 Class&lt;?&gt; ex2 = uniqueList.get(j);</span>
<span class="line-removed">1615                 if (ex2.isAssignableFrom(ex)) {</span>
<span class="line-removed">1616                     /*</span>
<span class="line-removed">1617                      * if a superclass of this exception is already on</span>
<span class="line-removed">1618                      * the list to catch, then ignore this one and continue;</span>
<span class="line-removed">1619                      */</span>
<span class="line-removed">1620                     continue nextException;</span>
<span class="line-removed">1621                 } else if (ex.isAssignableFrom(ex2)) {</span>
<span class="line-removed">1622                     /*</span>
<span class="line-removed">1623                      * if a subclass of this exception is on the list</span>
<span class="line-removed">1624                      * to catch, then remove it;</span>
<span class="line-removed">1625                      */</span>
<span class="line-removed">1626                     uniqueList.remove(j);</span>
<span class="line-removed">1627                 } else {</span>
<span class="line-removed">1628                     j++;        // else continue comparing.</span>
<span class="line-removed">1629                 }</span>
<span class="line-removed">1630             }</span>
<span class="line-removed">1631             // This exception is unique (so far): add it to the list to catch.</span>
<span class="line-removed">1632             uniqueList.add(ex);</span>
<span class="line-removed">1633         }</span>
<span class="line-removed">1634         return uniqueList;</span>
<span class="line-removed">1635     }</span>
<span class="line-removed">1636 </span>
<span class="line-removed">1637     /**</span>
<span class="line-removed">1638      * A PrimitiveTypeInfo object contains assorted information about</span>
<span class="line-removed">1639      * a primitive type in its public fields.  The struct for a particular</span>
<span class="line-removed">1640      * primitive type can be obtained using the static &quot;get&quot; method.</span>
<span class="line-removed">1641      */</span>
<span class="line-removed">1642     private static class PrimitiveTypeInfo {</span>
<span class="line-removed">1643 </span>
<span class="line-removed">1644         /** &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2) */</span>
<span class="line-removed">1645         public String baseTypeString;</span>
<span class="line-removed">1646 </span>
<span class="line-removed">1647         /** name of corresponding wrapper class */</span>
<span class="line-removed">1648         public String wrapperClassName;</span>
<span class="line-removed">1649 </span>
<span class="line-removed">1650         /** method descriptor for wrapper class &quot;valueOf&quot; factory method */</span>
<span class="line-removed">1651         public String wrapperValueOfDesc;</span>
<span class="line-removed">1652 </span>
<span class="line-removed">1653         /** name of wrapper class method for retrieving primitive value */</span>
<span class="line-removed">1654         public String unwrapMethodName;</span>
<span class="line-removed">1655 </span>
<span class="line-removed">1656         /** descriptor of same method */</span>
<span class="line-removed">1657         public String unwrapMethodDesc;</span>
<span class="line-removed">1658 </span>
<span class="line-removed">1659         private static Map&lt;Class&lt;?&gt;,PrimitiveTypeInfo&gt; table = new HashMap&lt;&gt;();</span>
<span class="line-removed">1660         static {</span>
<span class="line-removed">1661             add(byte.class, Byte.class);</span>
<span class="line-removed">1662             add(char.class, Character.class);</span>
<span class="line-removed">1663             add(double.class, Double.class);</span>
<span class="line-removed">1664             add(float.class, Float.class);</span>
<span class="line-removed">1665             add(int.class, Integer.class);</span>
<span class="line-removed">1666             add(long.class, Long.class);</span>
<span class="line-removed">1667             add(short.class, Short.class);</span>
<span class="line-removed">1668             add(boolean.class, Boolean.class);</span>
<span class="line-removed">1669         }</span>
<span class="line-removed">1670 </span>
<span class="line-removed">1671         private static void add(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-removed">1672             table.put(primitiveClass,</span>
<span class="line-removed">1673                       new PrimitiveTypeInfo(primitiveClass, wrapperClass));</span>
<span class="line-removed">1674         }</span>
<span class="line-removed">1675 </span>
<span class="line-removed">1676         private PrimitiveTypeInfo(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-removed">1677             assert primitiveClass.isPrimitive();</span>
<span class="line-removed">1678 </span>
<span class="line-removed">1679             baseTypeString =</span>
<span class="line-removed">1680                 Array.newInstance(primitiveClass, 0)</span>
<span class="line-removed">1681                 .getClass().getName().substring(1);</span>
<span class="line-removed">1682             wrapperClassName = dotToSlash(wrapperClass.getName());</span>
<span class="line-removed">1683             wrapperValueOfDesc =</span>
<span class="line-removed">1684                 &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;</span>
<span class="line-removed">1685             unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;</span>
<span class="line-removed">1686             unwrapMethodDesc = &quot;()&quot; + baseTypeString;</span>
1687         }
1688 
1689         public static PrimitiveTypeInfo get(Class&lt;?&gt; cl) {
1690             return table.get(cl);
1691         }
1692     }
<a name="134" id="anc134"></a><span class="line-removed">1693 </span>
<span class="line-removed">1694 </span>
<span class="line-removed">1695     /**</span>
<span class="line-removed">1696      * A ConstantPool object represents the constant pool of a class file</span>
<span class="line-removed">1697      * being generated.  This representation of a constant pool is designed</span>
<span class="line-removed">1698      * specifically for use by ProxyGenerator; in particular, it assumes</span>
<span class="line-removed">1699      * that constant pool entries will not need to be resorted (for example,</span>
<span class="line-removed">1700      * by their type, as the Java compiler does), so that the final index</span>
<span class="line-removed">1701      * value can be assigned and used when an entry is first created.</span>
<span class="line-removed">1702      *</span>
<span class="line-removed">1703      * Note that new entries cannot be created after the constant pool has</span>
<span class="line-removed">1704      * been written to a class file.  To prevent such logic errors, a</span>
<span class="line-removed">1705      * ConstantPool instance can be marked &quot;read only&quot;, so that further</span>
<span class="line-removed">1706      * attempts to add new entries will fail with a runtime exception.</span>
<span class="line-removed">1707      *</span>
<span class="line-removed">1708      * See JVMS section 4.4 for more information about the constant pool</span>
<span class="line-removed">1709      * of a class file.</span>
<span class="line-removed">1710      */</span>
<span class="line-removed">1711     private static class ConstantPool {</span>
<span class="line-removed">1712 </span>
<span class="line-removed">1713         /**</span>
<span class="line-removed">1714          * list of constant pool entries, in constant pool index order.</span>
<span class="line-removed">1715          *</span>
<span class="line-removed">1716          * This list is used when writing the constant pool to a stream</span>
<span class="line-removed">1717          * and for assigning the next index value.  Note that element 0</span>
<span class="line-removed">1718          * of this list corresponds to constant pool index 1.</span>
<span class="line-removed">1719          */</span>
<span class="line-removed">1720         private List&lt;Entry&gt; pool = new ArrayList&lt;&gt;(32);</span>
<span class="line-removed">1721 </span>
<span class="line-removed">1722         /**</span>
<span class="line-removed">1723          * maps constant pool data of all types to constant pool indexes.</span>
<span class="line-removed">1724          *</span>
<span class="line-removed">1725          * This map is used to look up the index of an existing entry for</span>
<span class="line-removed">1726          * values of all types.</span>
<span class="line-removed">1727          */</span>
<span class="line-removed">1728         private Map&lt;Object,Integer&gt; map = new HashMap&lt;&gt;(16);</span>
<span class="line-removed">1729 </span>
<span class="line-removed">1730         /** true if no new constant pool entries may be added */</span>
<span class="line-removed">1731         private boolean readOnly = false;</span>
<span class="line-removed">1732 </span>
<span class="line-removed">1733         /**</span>
<span class="line-removed">1734          * Get or assign the index for a CONSTANT_Utf8 entry.</span>
<span class="line-removed">1735          */</span>
<span class="line-removed">1736         public short getUtf8(String s) {</span>
<span class="line-removed">1737             if (s == null) {</span>
<span class="line-removed">1738                 throw new NullPointerException();</span>
<span class="line-removed">1739             }</span>
<span class="line-removed">1740             return getValue(s);</span>
<span class="line-removed">1741         }</span>
<span class="line-removed">1742 </span>
<span class="line-removed">1743         /**</span>
<span class="line-removed">1744          * Get or assign the index for a CONSTANT_Integer entry.</span>
<span class="line-removed">1745          */</span>
<span class="line-removed">1746         public short getInteger(int i) {</span>
<span class="line-removed">1747             return getValue(i);</span>
<span class="line-removed">1748         }</span>
<span class="line-removed">1749 </span>
<span class="line-removed">1750         /**</span>
<span class="line-removed">1751          * Get or assign the index for a CONSTANT_Float entry.</span>
<span class="line-removed">1752          */</span>
<span class="line-removed">1753         public short getFloat(float f) {</span>
<span class="line-removed">1754             return getValue(f);</span>
<span class="line-removed">1755         }</span>
<span class="line-removed">1756 </span>
<span class="line-removed">1757         /**</span>
<span class="line-removed">1758          * Get or assign the index for a CONSTANT_Class entry.</span>
<span class="line-removed">1759          */</span>
<span class="line-removed">1760         public short getClass(String name) {</span>
<span class="line-removed">1761             short utf8Index = getUtf8(name);</span>
<span class="line-removed">1762             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1763                 CONSTANT_CLASS, utf8Index));</span>
<span class="line-removed">1764         }</span>
<span class="line-removed">1765 </span>
<span class="line-removed">1766         /**</span>
<span class="line-removed">1767          * Get or assign the index for a CONSTANT_String entry.</span>
<span class="line-removed">1768          */</span>
<span class="line-removed">1769         public short getString(String s) {</span>
<span class="line-removed">1770             short utf8Index = getUtf8(s);</span>
<span class="line-removed">1771             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1772                 CONSTANT_STRING, utf8Index));</span>
<span class="line-removed">1773         }</span>
<span class="line-removed">1774 </span>
<span class="line-removed">1775         /**</span>
<span class="line-removed">1776          * Get or assign the index for a CONSTANT_FieldRef entry.</span>
<span class="line-removed">1777          */</span>
<span class="line-removed">1778         public short getFieldRef(String className,</span>
<span class="line-removed">1779                                  String name, String descriptor)</span>
<span class="line-removed">1780         {</span>
<span class="line-removed">1781             short classIndex = getClass(className);</span>
<span class="line-removed">1782             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">1783             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1784                 CONSTANT_FIELD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">1785         }</span>
<span class="line-removed">1786 </span>
<span class="line-removed">1787         /**</span>
<span class="line-removed">1788          * Get or assign the index for a CONSTANT_MethodRef entry.</span>
<span class="line-removed">1789          */</span>
<span class="line-removed">1790         public short getMethodRef(String className,</span>
<span class="line-removed">1791                                   String name, String descriptor)</span>
<span class="line-removed">1792         {</span>
<span class="line-removed">1793             short classIndex = getClass(className);</span>
<span class="line-removed">1794             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">1795             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1796                 CONSTANT_METHOD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">1797         }</span>
<span class="line-removed">1798 </span>
<span class="line-removed">1799         /**</span>
<span class="line-removed">1800          * Get or assign the index for a CONSTANT_InterfaceMethodRef entry.</span>
<span class="line-removed">1801          */</span>
<span class="line-removed">1802         public short getInterfaceMethodRef(String className, String name,</span>
<span class="line-removed">1803                                            String descriptor)</span>
<span class="line-removed">1804         {</span>
<span class="line-removed">1805             short classIndex = getClass(className);</span>
<span class="line-removed">1806             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">1807             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1808                 CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">1809         }</span>
<span class="line-removed">1810 </span>
<span class="line-removed">1811         /**</span>
<span class="line-removed">1812          * Get or assign the index for a CONSTANT_NameAndType entry.</span>
<span class="line-removed">1813          */</span>
<span class="line-removed">1814         public short getNameAndType(String name, String descriptor) {</span>
<span class="line-removed">1815             short nameIndex = getUtf8(name);</span>
<span class="line-removed">1816             short descriptorIndex = getUtf8(descriptor);</span>
<span class="line-removed">1817             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1818                 CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex));</span>
<span class="line-removed">1819         }</span>
<span class="line-removed">1820 </span>
<span class="line-removed">1821         /**</span>
<span class="line-removed">1822          * Set this ConstantPool instance to be &quot;read only&quot;.</span>
<span class="line-removed">1823          *</span>
<span class="line-removed">1824          * After this method has been called, further requests to get</span>
<span class="line-removed">1825          * an index for a non-existent entry will cause an InternalError</span>
<span class="line-removed">1826          * to be thrown instead of creating of the entry.</span>
<span class="line-removed">1827          */</span>
<span class="line-removed">1828         public void setReadOnly() {</span>
<span class="line-removed">1829             readOnly = true;</span>
<span class="line-removed">1830         }</span>
<span class="line-removed">1831 </span>
<span class="line-removed">1832         /**</span>
<span class="line-removed">1833          * Write this constant pool to a stream as part of</span>
<span class="line-removed">1834          * the class file format.</span>
<span class="line-removed">1835          *</span>
<span class="line-removed">1836          * This consists of writing the &quot;constant_pool_count&quot; and</span>
<span class="line-removed">1837          * &quot;constant_pool[]&quot; items of the &quot;ClassFile&quot; structure, as</span>
<span class="line-removed">1838          * described in JVMS section 4.1.</span>
<span class="line-removed">1839          */</span>
<span class="line-removed">1840         public void write(OutputStream out) throws IOException {</span>
<span class="line-removed">1841             DataOutputStream dataOut = new DataOutputStream(out);</span>
<span class="line-removed">1842 </span>
<span class="line-removed">1843             // constant_pool_count: number of entries plus one</span>
<span class="line-removed">1844             dataOut.writeShort(pool.size() + 1);</span>
<span class="line-removed">1845 </span>
<span class="line-removed">1846             for (Entry e : pool) {</span>
<span class="line-removed">1847                 e.write(dataOut);</span>
<span class="line-removed">1848             }</span>
<span class="line-removed">1849         }</span>
<span class="line-removed">1850 </span>
<span class="line-removed">1851         /**</span>
<span class="line-removed">1852          * Add a new constant pool entry and return its index.</span>
<span class="line-removed">1853          */</span>
<span class="line-removed">1854         private short addEntry(Entry entry) {</span>
<span class="line-removed">1855             pool.add(entry);</span>
<span class="line-removed">1856             /*</span>
<span class="line-removed">1857              * Note that this way of determining the index of the</span>
<span class="line-removed">1858              * added entry is wrong if this pool supports</span>
<span class="line-removed">1859              * CONSTANT_Long or CONSTANT_Double entries.</span>
<span class="line-removed">1860              */</span>
<span class="line-removed">1861             if (pool.size() &gt;= 65535) {</span>
<span class="line-removed">1862                 throw new IllegalArgumentException(</span>
<span class="line-removed">1863                     &quot;constant pool size limit exceeded&quot;);</span>
<span class="line-removed">1864             }</span>
<span class="line-removed">1865             return (short) pool.size();</span>
<span class="line-removed">1866         }</span>
<span class="line-removed">1867 </span>
<span class="line-removed">1868         /**</span>
<span class="line-removed">1869          * Get or assign the index for an entry of a type that contains</span>
<span class="line-removed">1870          * a direct value.  The type of the given object determines the</span>
<span class="line-removed">1871          * type of the desired entry as follows:</span>
<span class="line-removed">1872          *</span>
<span class="line-removed">1873          *      java.lang.String        CONSTANT_Utf8</span>
<span class="line-removed">1874          *      java.lang.Integer       CONSTANT_Integer</span>
<span class="line-removed">1875          *      java.lang.Float         CONSTANT_Float</span>
<span class="line-removed">1876          *      java.lang.Long          CONSTANT_Long</span>
<span class="line-removed">1877          *      java.lang.Double        CONSTANT_DOUBLE</span>
<span class="line-removed">1878          */</span>
<span class="line-removed">1879         private short getValue(Object key) {</span>
<span class="line-removed">1880             Integer index = map.get(key);</span>
<span class="line-removed">1881             if (index != null) {</span>
<span class="line-removed">1882                 return index.shortValue();</span>
<span class="line-removed">1883             } else {</span>
<span class="line-removed">1884                 if (readOnly) {</span>
<span class="line-removed">1885                     throw new InternalError(</span>
<span class="line-removed">1886                         &quot;late constant pool addition: &quot; + key);</span>
<span class="line-removed">1887                 }</span>
<span class="line-removed">1888                 short i = addEntry(new ValueEntry(key));</span>
<span class="line-removed">1889                 map.put(key, (int)i);</span>
<span class="line-removed">1890                 return i;</span>
<span class="line-removed">1891             }</span>
<span class="line-removed">1892         }</span>
<span class="line-removed">1893 </span>
<span class="line-removed">1894         /**</span>
<span class="line-removed">1895          * Get or assign the index for an entry of a type that contains</span>
<span class="line-removed">1896          * references to other constant pool entries.</span>
<span class="line-removed">1897          */</span>
<span class="line-removed">1898         private short getIndirect(IndirectEntry e) {</span>
<span class="line-removed">1899             Integer index = map.get(e);</span>
<span class="line-removed">1900             if (index != null) {</span>
<span class="line-removed">1901                 return index.shortValue();</span>
<span class="line-removed">1902             } else {</span>
<span class="line-removed">1903                 if (readOnly) {</span>
<span class="line-removed">1904                     throw new InternalError(&quot;late constant pool addition&quot;);</span>
<span class="line-removed">1905                 }</span>
<span class="line-removed">1906                 short i = addEntry(e);</span>
<span class="line-removed">1907                 map.put(e, (int)i);</span>
<span class="line-removed">1908                 return i;</span>
<span class="line-removed">1909             }</span>
<span class="line-removed">1910         }</span>
<span class="line-removed">1911 </span>
<span class="line-removed">1912         /**</span>
<span class="line-removed">1913          * Entry is the abstact superclass of all constant pool entry types</span>
<span class="line-removed">1914          * that can be stored in the &quot;pool&quot; list; its purpose is to define a</span>
<span class="line-removed">1915          * common method for writing constant pool entries to a class file.</span>
<span class="line-removed">1916          */</span>
<span class="line-removed">1917         private abstract static class Entry {</span>
<span class="line-removed">1918             public abstract void write(DataOutputStream out)</span>
<span class="line-removed">1919                 throws IOException;</span>
<span class="line-removed">1920         }</span>
<span class="line-removed">1921 </span>
<span class="line-removed">1922         /**</span>
<span class="line-removed">1923          * ValueEntry represents a constant pool entry of a type that</span>
<span class="line-removed">1924          * contains a direct value (see the comments for the &quot;getValue&quot;</span>
<span class="line-removed">1925          * method for a list of such types).</span>
<span class="line-removed">1926          *</span>
<span class="line-removed">1927          * ValueEntry objects are not used as keys for their entries in the</span>
<span class="line-removed">1928          * Map &quot;map&quot;, so no useful hashCode or equals methods are defined.</span>
<span class="line-removed">1929          */</span>
<span class="line-removed">1930         private static class ValueEntry extends Entry {</span>
<span class="line-removed">1931             private Object value;</span>
<span class="line-removed">1932 </span>
<span class="line-removed">1933             public ValueEntry(Object value) {</span>
<span class="line-removed">1934                 this.value = value;</span>
<span class="line-removed">1935             }</span>
<span class="line-removed">1936 </span>
<span class="line-removed">1937             public void write(DataOutputStream out) throws IOException {</span>
<span class="line-removed">1938                 if (value instanceof String) {</span>
<span class="line-removed">1939                     out.writeByte(CONSTANT_UTF8);</span>
<span class="line-removed">1940                     out.writeUTF((String) value);</span>
<span class="line-removed">1941                 } else if (value instanceof Integer) {</span>
<span class="line-removed">1942                     out.writeByte(CONSTANT_INTEGER);</span>
<span class="line-removed">1943                     out.writeInt(((Integer) value).intValue());</span>
<span class="line-removed">1944                 } else if (value instanceof Float) {</span>
<span class="line-removed">1945                     out.writeByte(CONSTANT_FLOAT);</span>
<span class="line-removed">1946                     out.writeFloat(((Float) value).floatValue());</span>
<span class="line-removed">1947                 } else if (value instanceof Long) {</span>
<span class="line-removed">1948                     out.writeByte(CONSTANT_LONG);</span>
<span class="line-removed">1949                     out.writeLong(((Long) value).longValue());</span>
<span class="line-removed">1950                 } else if (value instanceof Double) {</span>
<span class="line-removed">1951                     out.writeDouble(CONSTANT_DOUBLE);</span>
<span class="line-removed">1952                     out.writeDouble(((Double) value).doubleValue());</span>
<span class="line-removed">1953                 } else {</span>
<span class="line-removed">1954                     throw new InternalError(&quot;bogus value entry: &quot; + value);</span>
<span class="line-removed">1955                 }</span>
<span class="line-removed">1956             }</span>
<span class="line-removed">1957         }</span>
<span class="line-removed">1958 </span>
<span class="line-removed">1959         /**</span>
<span class="line-removed">1960          * IndirectEntry represents a constant pool entry of a type that</span>
<span class="line-removed">1961          * references other constant pool entries, i.e., the following types:</span>
<span class="line-removed">1962          *</span>
<span class="line-removed">1963          *      CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref,</span>
<span class="line-removed">1964          *      CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and</span>
<span class="line-removed">1965          *      CONSTANT_NameAndType.</span>
<span class="line-removed">1966          *</span>
<span class="line-removed">1967          * Each of these entry types contains either one or two indexes of</span>
<span class="line-removed">1968          * other constant pool entries.</span>
<span class="line-removed">1969          *</span>
<span class="line-removed">1970          * IndirectEntry objects are used as the keys for their entries in</span>
<span class="line-removed">1971          * the Map &quot;map&quot;, so the hashCode and equals methods are overridden</span>
<span class="line-removed">1972          * to allow matching.</span>
<span class="line-removed">1973          */</span>
<span class="line-removed">1974         private static class IndirectEntry extends Entry {</span>
<span class="line-removed">1975             private int tag;</span>
<span class="line-removed">1976             private short index0;</span>
<span class="line-removed">1977             private short index1;</span>
<span class="line-removed">1978 </span>
<span class="line-removed">1979             /**</span>
<span class="line-removed">1980              * Construct an IndirectEntry for a constant pool entry type</span>
<span class="line-removed">1981              * that contains one index of another entry.</span>
<span class="line-removed">1982              */</span>
<span class="line-removed">1983             public IndirectEntry(int tag, short index) {</span>
<span class="line-removed">1984                 this.tag = tag;</span>
<span class="line-removed">1985                 this.index0 = index;</span>
<span class="line-removed">1986                 this.index1 = 0;</span>
<span class="line-removed">1987             }</span>
<span class="line-removed">1988 </span>
<span class="line-removed">1989             /**</span>
<span class="line-removed">1990              * Construct an IndirectEntry for a constant pool entry type</span>
<span class="line-removed">1991              * that contains two indexes for other entries.</span>
<span class="line-removed">1992              */</span>
<span class="line-removed">1993             public IndirectEntry(int tag, short index0, short index1) {</span>
<span class="line-removed">1994                 this.tag = tag;</span>
<span class="line-removed">1995                 this.index0 = index0;</span>
<span class="line-removed">1996                 this.index1 = index1;</span>
<span class="line-removed">1997             }</span>
<span class="line-removed">1998 </span>
<span class="line-removed">1999             public void write(DataOutputStream out) throws IOException {</span>
<span class="line-removed">2000                 out.writeByte(tag);</span>
<span class="line-removed">2001                 out.writeShort(index0);</span>
<span class="line-removed">2002                 /*</span>
<span class="line-removed">2003                  * If this entry type contains two indexes, write</span>
<span class="line-removed">2004                  * out the second, too.</span>
<span class="line-removed">2005                  */</span>
<span class="line-removed">2006                 if (tag == CONSTANT_FIELD ||</span>
<span class="line-removed">2007                     tag == CONSTANT_METHOD ||</span>
<span class="line-removed">2008                     tag == CONSTANT_INTERFACEMETHOD ||</span>
<span class="line-removed">2009                     tag == CONSTANT_NAMEANDTYPE)</span>
<span class="line-removed">2010                 {</span>
<span class="line-removed">2011                     out.writeShort(index1);</span>
<span class="line-removed">2012                 }</span>
<span class="line-removed">2013             }</span>
<span class="line-removed">2014 </span>
<span class="line-removed">2015             public int hashCode() {</span>
<span class="line-removed">2016                 return tag + index0 + index1;</span>
<span class="line-removed">2017             }</span>
<span class="line-removed">2018 </span>
<span class="line-removed">2019             public boolean equals(Object obj) {</span>
<span class="line-removed">2020                 if (obj instanceof IndirectEntry) {</span>
<span class="line-removed">2021                     IndirectEntry other = (IndirectEntry) obj;</span>
<span class="line-removed">2022                     if (tag == other.tag &amp;&amp;</span>
<span class="line-removed">2023                         index0 == other.index0 &amp;&amp; index1 == other.index1)</span>
<span class="line-removed">2024                     {</span>
<span class="line-removed">2025                         return true;</span>
<span class="line-removed">2026                     }</span>
<span class="line-removed">2027                 }</span>
<span class="line-removed">2028                 return false;</span>
<span class="line-removed">2029             }</span>
<span class="line-removed">2030         }</span>
<span class="line-removed">2031     }</span>
2032 }
<a name="135" id="anc135"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="135" type="hidden" />
</body>
</html>
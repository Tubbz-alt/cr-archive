diff a/src/java.base/share/classes/java/io/ObjectInputStream.java b/src/java.base/share/classes/java/io/ObjectInputStream.java
--- a/src/java.base/share/classes/java/io/ObjectInputStream.java
+++ b/src/java.base/share/classes/java/io/ObjectInputStream.java
@@ -24,11 +24,13 @@
  */
 
 package java.io;
 
 import java.io.ObjectStreamClass.WeakClassKey;
+import java.io.ObjectStreamClass.RecordSupport;
 import java.lang.System.Logger;
+import java.lang.invoke.MethodHandle;
 import java.lang.ref.ReferenceQueue;
 import java.lang.reflect.Array;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
 import java.security.AccessControlContext;
@@ -72,11 +74,11 @@
  * Machine.  Classes are loaded as required using the standard mechanisms.
  *
  * <p>Only objects that support the java.io.Serializable or
  * java.io.Externalizable interface can be read from streams.
  *
- * <p>The method <code>readObject</code> is used to read an object from the
+ * <p>The method {@code readObject} is used to read an object from the
  * stream.  Java's safe casting should be used to get the desired type.  In
  * Java, strings and arrays are objects and are treated as objects during
  * serialization. When read they need to be cast to the expected type.
  *
  * <p>Primitive data types can be read from the stream using the appropriate
@@ -155,11 +157,11 @@
  * behave in the same manner--if the stream is already positioned at the end of
  * data written by the corresponding writeExternal method, object reads will
  * throw OptionalDataExceptions with eof set to true, bytewise reads will
  * return -1, and primitive reads will throw EOFExceptions.  Note that this
  * behavior does not hold for streams written with the old
- * <code>ObjectStreamConstants.PROTOCOL_VERSION_1</code> protocol, in which the
+ * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the
  * end of data written by writeExternal methods is not demarcated, and hence
  * cannot be detected.
  *
  * <p>The readObjectNoData method is responsible for initializing the state of
  * the object for its particular class in the event that the serialization
@@ -206,20 +208,53 @@
  * <p>Enum constants are deserialized differently than ordinary serializable or
  * externalizable objects.  The serialized form of an enum constant consists
  * solely of its name; field values of the constant are not transmitted.  To
  * deserialize an enum constant, ObjectInputStream reads the constant name from
  * the stream; the deserialized constant is then obtained by calling the static
- * method <code>Enum.valueOf(Class, String)</code> with the enum constant's
+ * method {@code Enum.valueOf(Class, String)} with the enum constant's
  * base type and the received constant name as arguments.  Like other
  * serializable or externalizable objects, enum constants can function as the
  * targets of back references appearing subsequently in the serialization
  * stream.  The process by which enum constants are deserialized cannot be
  * customized: any class-specific readObject, readObjectNoData, and readResolve
  * methods defined by enum types are ignored during deserialization.
  * Similarly, any serialPersistentFields or serialVersionUID field declarations
  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
  *
+ * @implSpec
+ * <a id="record-serialization"></a>
+ * Records are serialized differently than ordinary serializable or externalizable
+ * objects. The serialized form of a record object is a sequence of values derived
+ * from the record components. The stream format of a record object is the same as
+ * that of an ordinary object in the stream. During deserialization, if the local
+ * class equivalent of the specified stream class descriptor is a record class,
+ * then first the stream fields are read and reconstructed to serve as the record's
+ * component values; and second, a record object is created by invoking the
+ * record's <i>canonical</i> constructor with the component values as arguments (or the
+ * default value for component's type if a component value is absent from the
+ * stream).
+ * Like other serializable or externalizable objects, record objects can function
+ * as the target of back references appearing subsequently in the serialization
+ * stream. However, a cycle in the graph where the record object is referred to,
+ * either directly or transitively, by one of its components, is not preserved.
+ * The record components are deserialized prior to the invocation of the record
+ * constructor, hence this limitation (see
+ * <a href="{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references">
+ * [Section 1.14, "Circular References"</a> for additional information).
+ * The process by which record objects are serialized or externalized cannot be
+ * customized; any class-specific writeObject, readObject, readObjectNoData,
+ * writeExternal, and readExternal methods defined by record classes are
+ * ignored during serialization and deserialization. However, a substitute object
+ * to be serialized or a designate replacement may be specified, by the
+ * writeReplace and readResolve methods, respectively.  Any
+ * serialPersistentFields field declaration is ignored. Documenting serializable
+ * fields and data for record classes is unnecessary, since there is no variation
+ * in the serial form, other than whether a substitute or replacement object is
+ * used. The serialVersionUID of a record class is 0L unless explicitly
+ * declared. The requirement for matching serialVersionUID values is waived for
+ * record classes.
+ *
  * @author      Mike Warres
  * @author      Roger Riggs
  * @see java.io.DataInput
  * @see java.io.ObjectOutputStream
  * @see java.io.Serializable
@@ -333,11 +368,11 @@
      * @param   in input stream to read from
      * @throws  StreamCorruptedException if the stream header is incorrect
      * @throws  IOException if an I/O error occurs while reading stream header
      * @throws  SecurityException if untrusted subclass illegally overrides
      *          security-sensitive methods
-     * @throws  NullPointerException if <code>in</code> is <code>null</code>
+     * @throws  NullPointerException if {@code in} is {@code null}
      * @see     ObjectInputStream#ObjectInputStream()
      * @see     ObjectInputStream#readFields()
      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
      */
     public ObjectInputStream(InputStream in) throws IOException {
@@ -358,16 +393,16 @@
      *
      * <p>The serialization filter is initialized to the value of
      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
      *
      * <p>If there is a security manager installed, this method first calls the
-     * security manager's <code>checkPermission</code> method with the
-     * <code>SerializablePermission("enableSubclassImplementation")</code>
+     * security manager's {@code checkPermission} method with the
+     * {@code SerializablePermission("enableSubclassImplementation")}
      * permission to ensure it's ok to enable subclassing.
      *
      * @throws  SecurityException if a security manager exists and its
-     *          <code>checkPermission</code> method denies enabling
+     *          {@code checkPermission} method denies enabling
      *          subclassing.
      * @throws  IOException if an I/O error occurs while creating this stream
      * @see SecurityManager#checkPermission
      * @see java.io.SerializablePermission
      */
@@ -416,20 +451,54 @@
      * @throws  OptionalDataException Primitive data was found in the
      *          stream instead of objects.
      * @throws  IOException Any of the usual Input/Output related exceptions.
      */
     public final Object readObject()
+        throws IOException, ClassNotFoundException {
+        return readObject(Object.class);
+    }
+
+    /**
+     * Reads a String and only a string.
+     *
+     * @return  the String read
+     * @throws  EOFException If end of file is reached.
+     * @throws  IOException If other I/O error has occurred.
+     */
+    private String readString() throws IOException {
+        try {
+            return (String) readObject(String.class);
+        } catch (ClassNotFoundException cnf) {
+            throw new IllegalStateException(cnf);
+        }
+    }
+
+    /**
+     * Internal method to read an object from the ObjectInputStream of the expected type.
+     * Called only from {@code readObject()} and {@code readString()}.
+     * Only {@code Object.class} and {@code String.class} are supported.
+     *
+     * @param type the type expected; either Object.class or String.class
+     * @return an object of the type
+     * @throws  IOException Any of the usual Input/Output related exceptions.
+     * @throws  ClassNotFoundException Class of a serialized object cannot be
+     *          found.
+     */
+    private final Object readObject(Class<?> type)
         throws IOException, ClassNotFoundException
     {
         if (enableOverride) {
             return readObjectOverride();
         }
 
+        if (! (type == Object.class || type == String.class))
+            throw new AssertionError("internal error");
+
         // if nested read, passHandle contains handle of enclosing object
         int outerHandle = passHandle;
         try {
-            Object obj = readObject0(false);
+            Object obj = readObject0(type, false);
             handles.markDependency(outerHandle, passHandle);
             ClassNotFoundException ex = handles.lookupException(passHandle);
             if (ex != null) {
                 throw ex;
             }
@@ -445,12 +514,12 @@
             }
         }
     }
 
     /**
-     * This method is called by trusted subclasses of ObjectOutputStream that
-     * constructed ObjectOutputStream using the protected no-arg constructor.
+     * This method is called by trusted subclasses of ObjectInputStream that
+     + constructed ObjectInputStream using the protected no-arg constructor.
      * The subclass is expected to provide an override method with the modifier
      * "final".
      *
      * @return  the Object read from the stream.
      * @throws  ClassNotFoundException Class definition of a serialized object
@@ -520,11 +589,11 @@
      */
     public Object readUnshared() throws IOException, ClassNotFoundException {
         // if nested read, passHandle contains handle of enclosing object
         int outerHandle = passHandle;
         try {
-            Object obj = readObject0(true);
+            Object obj = readObject0(Object.class, true);
             handles.markDependency(outerHandle, passHandle);
             ClassNotFoundException ex = handles.lookupException(passHandle);
             if (ex != null) {
                 throw ex;
             }
@@ -585,11 +654,11 @@
 
     /**
      * Reads the persistent fields from the stream and makes them available by
      * name.
      *
-     * @return  the <code>GetField</code> object representing the persistent
+     * @return  the {@code GetField} object representing the persistent
      *          fields of the object being deserialized
      * @throws  ClassNotFoundException if the class of a serialized object
      *          could not be found.
      * @throws  IOException if an I/O error occurs.
      * @throws  NotActiveException if the stream is not currently reading
@@ -649,40 +718,40 @@
     /**
      * Load the local class equivalent of the specified stream class
      * description.  Subclasses may implement this method to allow classes to
      * be fetched from an alternate source.
      *
-     * <p>The corresponding method in <code>ObjectOutputStream</code> is
-     * <code>annotateClass</code>.  This method will be invoked only once for
+     * <p>The corresponding method in {@code ObjectOutputStream} is
+     * {@code annotateClass}.  This method will be invoked only once for
      * each unique class in the stream.  This method can be implemented by
      * subclasses to use an alternate loading mechanism but must return a
-     * <code>Class</code> object. Once returned, if the class is not an array
+     * {@code Class} object. Once returned, if the class is not an array
      * class, its serialVersionUID is compared to the serialVersionUID of the
      * serialized class, and if there is a mismatch, the deserialization fails
      * and an {@link InvalidClassException} is thrown.
      *
      * <p>The default implementation of this method in
-     * <code>ObjectInputStream</code> returns the result of calling
+     * {@code ObjectInputStream} returns the result of calling
      * <pre>
      *     Class.forName(desc.getName(), false, loader)
      * </pre>
-     * where <code>loader</code> is the first class loader on the current
+     * where {@code loader} is the first class loader on the current
      * thread's stack (starting from the currently executing method) that is
      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
-     * class loader} nor its ancestor; otherwise, <code>loader</code> is the
+     * class loader} nor its ancestor; otherwise, {@code loader} is the
      * <em>platform class loader</em>. If this call results in a
-     * <code>ClassNotFoundException</code> and the name of the passed
-     * <code>ObjectStreamClass</code> instance is the Java language keyword
-     * for a primitive type or void, then the <code>Class</code> object
+     * {@code ClassNotFoundException} and the name of the passed
+     * {@code ObjectStreamClass} instance is the Java language keyword
+     * for a primitive type or void, then the {@code Class} object
      * representing that primitive type or void will be returned
-     * (e.g., an <code>ObjectStreamClass</code> with the name
-     * <code>"int"</code> will be resolved to <code>Integer.TYPE</code>).
-     * Otherwise, the <code>ClassNotFoundException</code> will be thrown to
+     * (e.g., an {@code ObjectStreamClass} with the name
+     * {@code "int"} will be resolved to {@code Integer.TYPE}).
+     * Otherwise, the {@code ClassNotFoundException} will be thrown to
      * the caller of this method.
      *
-     * @param   desc an instance of class <code>ObjectStreamClass</code>
-     * @return  a <code>Class</code> object corresponding to <code>desc</code>
+     * @param   desc an instance of class {@code ObjectStreamClass}
+     * @return  a {@code Class} object corresponding to {@code desc}
      * @throws  IOException any of the usual Input/Output exceptions.
      * @throws  ClassNotFoundException if class of a serialized object cannot
      *          be found.
      */
     protected Class<?> resolveClass(ObjectStreamClass desc)
@@ -709,47 +778,47 @@
      * interfaces and the proxy class.
      *
      * <p>This method is called exactly once for each unique proxy class
      * descriptor in the stream.
      *
-     * <p>The corresponding method in <code>ObjectOutputStream</code> is
-     * <code>annotateProxyClass</code>.  For a given subclass of
-     * <code>ObjectInputStream</code> that overrides this method, the
-     * <code>annotateProxyClass</code> method in the corresponding subclass of
-     * <code>ObjectOutputStream</code> must write any data or objects read by
+     * <p>The corresponding method in {@code ObjectOutputStream} is
+     * {@code annotateProxyClass}.  For a given subclass of
+     * {@code ObjectInputStream} that overrides this method, the
+     * {@code annotateProxyClass} method in the corresponding subclass of
+     * {@code ObjectOutputStream} must write any data or objects read by
      * this method.
      *
      * <p>The default implementation of this method in
-     * <code>ObjectInputStream</code> returns the result of calling
-     * <code>Proxy.getProxyClass</code> with the list of <code>Class</code>
-     * objects for the interfaces that are named in the <code>interfaces</code>
-     * parameter.  The <code>Class</code> object for each interface name
-     * <code>i</code> is the value returned by calling
+     * {@code ObjectInputStream} returns the result of calling
+     * {@code Proxy.getProxyClass} with the list of {@code Class}
+     * objects for the interfaces that are named in the {@code interfaces}
+     * parameter.  The {@code Class} object for each interface name
+     * {@code i} is the value returned by calling
      * <pre>
      *     Class.forName(i, false, loader)
      * </pre>
-     * where <code>loader</code> is the first class loader on the current
+     * where {@code loader} is the first class loader on the current
      * thread's stack (starting from the currently executing method) that is
      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
-     * class loader} nor its ancestor; otherwise, <code>loader</code> is the
+     * class loader} nor its ancestor; otherwise, {@code loader} is the
      * <em>platform class loader</em>.
      * Unless any of the resolved interfaces are non-public, this same value
-     * of <code>loader</code> is also the class loader passed to
-     * <code>Proxy.getProxyClass</code>; if non-public interfaces are present,
+     * of {@code loader} is also the class loader passed to
+     * {@code Proxy.getProxyClass}; if non-public interfaces are present,
      * their class loader is passed instead (if more than one non-public
      * interface class loader is encountered, an
-     * <code>IllegalAccessError</code> is thrown).
-     * If <code>Proxy.getProxyClass</code> throws an
-     * <code>IllegalArgumentException</code>, <code>resolveProxyClass</code>
-     * will throw a <code>ClassNotFoundException</code> containing the
-     * <code>IllegalArgumentException</code>.
+     * {@code IllegalAccessError} is thrown).
+     * If {@code Proxy.getProxyClass} throws an
+     * {@code IllegalArgumentException}, {@code resolveProxyClass}
+     * will throw a {@code ClassNotFoundException} containing the
+     * {@code IllegalArgumentException}.
      *
      * @param interfaces the list of interface names that were
      *                deserialized in the proxy class descriptor
      * @return  a proxy class for the specified interfaces
      * @throws        IOException any exception thrown by the underlying
-     *                <code>InputStream</code>
+     *                {@code InputStream}
      * @throws        ClassNotFoundException if the proxy class or any of the
      *                named interfaces could not be found
      * @see ObjectOutputStream#annotateProxyClass(Class)
      * @since 1.3
      */
@@ -861,11 +930,11 @@
      * The readStreamHeader method is provided to allow subclasses to read and
      * verify their own stream headers. It reads and verifies the magic number
      * and version number.
      *
      * @throws  IOException if there are I/O errors while reading from the
-     *          underlying <code>InputStream</code>
+     *          underlying {@code InputStream}
      * @throws  StreamCorruptedException if control information in the stream
      *          is inconsistent
      */
     protected void readStreamHeader()
         throws IOException, StreamCorruptedException
@@ -882,11 +951,11 @@
      * Read a class descriptor from the serialization stream.  This method is
      * called when the ObjectInputStream expects a class descriptor as the next
      * item in the serialization stream.  Subclasses of ObjectInputStream may
      * override this method to read in class descriptors that have been written
      * in non-standard formats (by subclasses of ObjectOutputStream which have
-     * overridden the <code>writeClassDescriptor</code> method).  By default,
+     * overridden the {@code writeClassDescriptor} method).  By default,
      * this method reads class descriptors according to the format defined in
      * the Object Serialization specification.
      *
      * @return  the class descriptor read
      * @throws  IOException If an I/O error has occurred.
@@ -944,11 +1013,11 @@
     /**
      * Returns the number of bytes that can be read without blocking.
      *
      * @return  the number of available bytes.
      * @throws  IOException if there are I/O errors while reading from the
-     *          underlying <code>InputStream</code>
+     *          underlying {@code InputStream}
      */
     public int available() throws IOException {
         return bin.available();
     }
 
@@ -1127,11 +1196,11 @@
     /**
      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
      *
      * @return  a String copy of the line.
      * @throws  IOException if there are I/O errors while reading from the
-     *          underlying <code>InputStream</code>
+     *          underlying {@code InputStream}
      * @deprecated This method does not properly convert bytes to characters.
      *          see DataInputStream for the details and alternatives.
      */
     @Deprecated
     public String readLine() throws IOException {
@@ -1143,11 +1212,11 @@
      * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
      * format.
      *
      * @return  the String.
      * @throws  IOException if there are I/O errors while reading from the
-     *          underlying <code>InputStream</code>
+     *          underlying {@code InputStream}
      * @throws  UTFDataFormatException if read bytes do not represent a valid
      *          modified UTF-8 encoding of a string
      */
     public String readUTF() throws IOException {
         return bin.readUTF();
@@ -1319,10 +1388,14 @@
 
     /**
      * Provide access to the persistent fields read from the input stream.
      */
     public abstract static class GetField {
+        /**
+         * Constructor for subclasses to call.
+         */
+        public GetField() {}
 
         /**
          * Get the ObjectStreamClass that describes the fields in the stream.
          *
          * @return  the descriptor class that describes the serializable fields
@@ -1334,139 +1407,139 @@
          * stream.
          *
          * @param  name the name of the field
          * @return true, if and only if the named field is defaulted
          * @throws IOException if there are I/O errors while reading from
-         *         the underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if <code>name</code> does not
+         *         the underlying {@code InputStream}
+         * @throws IllegalArgumentException if {@code name} does not
          *         correspond to a serializable field
          */
         public abstract boolean defaulted(String name) throws IOException;
 
         /**
          * Get the value of the named boolean field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>boolean</code> field
+         * @return the value of the named {@code boolean} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract boolean get(String name, boolean val)
             throws IOException;
 
         /**
          * Get the value of the named byte field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>byte</code> field
+         * @return the value of the named {@code byte} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract byte get(String name, byte val) throws IOException;
 
         /**
          * Get the value of the named char field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>char</code> field
+         * @return the value of the named {@code char} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract char get(String name, char val) throws IOException;
 
         /**
          * Get the value of the named short field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>short</code> field
+         * @return the value of the named {@code short} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract short get(String name, short val) throws IOException;
 
         /**
          * Get the value of the named int field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>int</code> field
+         * @return the value of the named {@code int} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract int get(String name, int val) throws IOException;
 
         /**
          * Get the value of the named long field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>long</code> field
+         * @return the value of the named {@code long} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract long get(String name, long val) throws IOException;
 
         /**
          * Get the value of the named float field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>float</code> field
+         * @return the value of the named {@code float} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract float get(String name, float val) throws IOException;
 
         /**
          * Get the value of the named double field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>double</code> field
+         * @return the value of the named {@code double} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract double get(String name, double val) throws IOException;
 
         /**
          * Get the value of the named Object field from the persistent field.
          *
          * @param  name the name of the field
-         * @param  val the default value to use if <code>name</code> does not
+         * @param  val the default value to use if {@code name} does not
          *         have a value
-         * @return the value of the named <code>Object</code> field
+         * @return the value of the named {@code Object} field
          * @throws IOException if there are I/O errors while reading from the
-         *         underlying <code>InputStream</code>
-         * @throws IllegalArgumentException if type of <code>name</code> is
+         *         underlying {@code InputStream}
+         * @throws IllegalArgumentException if type of {@code name} is
          *         not serializable or if the field type is incorrect
          */
         public abstract Object get(String name, Object val) throws IOException;
     }
 
@@ -1536,12 +1609,14 @@
         vlist.clear();
     }
 
     /**
      * Underlying readObject implementation.
+     * @param type a type expected to be deserialized; non-null
+     * @param unshared true if the object can not be a reference to a shared object, otherwise false
      */
-    private Object readObject0(boolean unshared) throws IOException {
+    private Object readObject0(Class<?> type, boolean unshared) throws IOException {
         boolean oldMode = bin.getBlockDataMode();
         if (oldMode) {
             int remain = bin.currentBlockRemaining();
             if (remain > 0) {
                 throw new OptionalDataException(remain);
@@ -1569,33 +1644,52 @@
             switch (tc) {
                 case TC_NULL:
                     return readNull();
 
                 case TC_REFERENCE:
-                    return readHandle(unshared);
+                    // check the type of the existing object
+                    return type.cast(readHandle(unshared));
 
                 case TC_CLASS:
+                    if (type == String.class) {
+                        throw new ClassCastException("Cannot cast a class to java.lang.String");
+                    }
                     return readClass(unshared);
 
                 case TC_CLASSDESC:
                 case TC_PROXYCLASSDESC:
+                    if (type == String.class) {
+                        throw new ClassCastException("Cannot cast a class to java.lang.String");
+                    }
                     return readClassDesc(unshared);
 
                 case TC_STRING:
                 case TC_LONGSTRING:
                     return checkResolve(readString(unshared));
 
                 case TC_ARRAY:
+                    if (type == String.class) {
+                        throw new ClassCastException("Cannot cast an array to java.lang.String");
+                    }
                     return checkResolve(readArray(unshared));
 
                 case TC_ENUM:
+                    if (type == String.class) {
+                        throw new ClassCastException("Cannot cast an enum to java.lang.String");
+                    }
                     return checkResolve(readEnum(unshared));
 
                 case TC_OBJECT:
+                    if (type == String.class) {
+                        throw new ClassCastException("Cannot cast an object to java.lang.String");
+                    }
                     return checkResolve(readOrdinaryObject(unshared));
 
                 case TC_EXCEPTION:
+                    if (type == String.class) {
+                        throw new ClassCastException("Cannot cast an exception to java.lang.String");
+                    }
                     IOException ex = readFatalException();
                     throw new WriteAbortedException("writing aborted", ex);
 
                 case TC_BLOCKDATA:
                 case TC_BLOCKDATALONG:
@@ -1963,11 +2057,11 @@
             handles.markException(arrayHandle, resolveEx);
         }
 
         if (ccl == null) {
             for (int i = 0; i < len; i++) {
-                readObject0(false);
+                readObject0(Object.class, false);
             }
         } else if (ccl.isPrimitive()) {
             if (ccl == Integer.TYPE) {
                 bin.readInts((int[]) array, 0, len);
             } else if (ccl == Byte.TYPE) {
@@ -1988,11 +2082,11 @@
                 throw new InternalError();
             }
         } else {
             Object[] oa = (Object[]) array;
             for (int i = 0; i < len; i++) {
-                oa[i] = readObject0(false);
+                oa[i] = readObject0(Object.class, false);
                 handles.markDependency(arrayHandle, passHandle);
             }
         }
 
         handles.finish(arrayHandle);
@@ -2041,10 +2135,15 @@
         handles.finish(enumHandle);
         passHandle = enumHandle;
         return result;
     }
 
+    @SuppressWarnings("preview")
+    private static boolean isRecord(Class<?> cls) {
+        return cls.isRecord();
+    }
+
     /**
      * Reads and returns "ordinary" (i.e., not a String, Class,
      * ObjectStreamClass, array, or enum constant) object, or null if object's
      * class is unresolvable (in which case a ClassNotFoundException will be
      * associated with object's handle).  Sets passHandle to object's assigned
@@ -2079,11 +2178,16 @@
         ClassNotFoundException resolveEx = desc.getResolveException();
         if (resolveEx != null) {
             handles.markException(passHandle, resolveEx);
         }
 
-        if (desc.isExternalizable()) {
+        final boolean isRecord = cl != null && isRecord(cl) ? true : false;
+        if (isRecord) {
+            assert obj == null;
+            obj = readRecord(desc);
+            handles.setObject(passHandle, obj);
+        } else if (desc.isExternalizable()) {
             readExternalData((Externalizable) obj, desc);
         } else {
             readSerialData(obj, desc);
         }
 
@@ -2165,10 +2269,47 @@
          * externalizable data remains in the stream, a subsequent read will
          * most likely throw a StreamCorruptedException.
          */
     }
 
+    /** Reads a record. */
+    private Object readRecord(ObjectStreamClass desc) throws IOException {
+        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
+        if (slots.length != 1) {
+            // skip any superclass stream field values
+            for (int i = 0; i < slots.length-1; i++) {
+                ObjectStreamClass slotDesc = slots[i].desc;
+                if (slots[i].hasData) {
+                    defaultReadFields(null, slotDesc);
+                }
+            }
+        }
+
+        FieldValues fieldValues = defaultReadFields(null, desc);
+
+        // retrieve the canonical constructor
+        MethodHandle ctrMH = desc.getRecordConstructor();
+
+        // bind the stream field values
+        ctrMH = RecordSupport.bindCtrValues(ctrMH, desc, fieldValues);
+
+        try {
+            return ctrMH.invoke();
+        } catch (Exception e) {
+            InvalidObjectException ioe = new InvalidObjectException(e.getMessage());
+            ioe.initCause(e);
+            throw ioe;
+        } catch (Error e) {
+            throw e;
+        } catch (Throwable t) {
+            ObjectStreamException ose = new InvalidObjectException(
+                    "ReflectiveOperationException during deserialization");
+            ose.initCause(t);
+            throw ose;
+        }
+    }
+
     /**
      * Reads (or attempts to skip, if obj is null or is tagged with a
      * ClassNotFoundException) instance data for each serializable class of
      * object in stream, from superclass to subclass.  Expects that passHandle
      * is set to obj's handle before this method is called.
@@ -2305,17 +2446,17 @@
                     bin.readByte();
                     passHandle = oldHandle;
                     return;
 
                 default:
-                    readObject0(false);
+                    readObject0(Object.class, false);
                     break;
             }
         }
     }
 
-    private class FieldValues {
+    /*package-private*/ class FieldValues {
         final byte[] primValues;
         final Object[] objValues;
 
         FieldValues(byte[] primValues, Object[] objValues) {
             this.primValues = primValues;
@@ -2350,11 +2491,11 @@
             ObjectStreamField[] fields = desc.getFields(false);
             objVals = new Object[numObjFields];
             int numPrimFields = fields.length - objVals.length;
             for (int i = 0; i < objVals.length; i++) {
                 ObjectStreamField f = fields[numPrimFields + i];
-                objVals[i] = readObject0(f.isUnshared());
+                objVals[i] = readObject0(Object.class, f.isUnshared());
                 if (f.getField() != null) {
                     handles.markDependency(objHandle, passHandle);
                 }
             }
             passHandle = objHandle;
@@ -2391,11 +2532,11 @@
     private IOException readFatalException() throws IOException {
         if (bin.readByte() != TC_EXCEPTION) {
             throw new InternalError();
         }
         clear();
-        return (IOException) readObject0(false);
+        return (IOException) readObject0(Object.class, false);
     }
 
     /**
      * If recursion depth is 0, clears internal data structures; otherwise,
      * throws a StreamCorruptedException.  This method is called when a
@@ -2407,26 +2548,10 @@
                 "unexpected reset; recursion depth: " + depth);
         }
         clear();
     }
 
-    /**
-     * Converts specified span of bytes into float values.
-     */
-    // REMIND: remove once hotspot inlines Float.intBitsToFloat
-    private static native void bytesToFloats(byte[] src, int srcpos,
-                                             float[] dst, int dstpos,
-                                             int nfloats);
-
-    /**
-     * Converts specified span of bytes into double values.
-     */
-    // REMIND: remove once hotspot inlines Double.longBitsToDouble
-    private static native void bytesToDoubles(byte[] src, int srcpos,
-                                              double[] dst, int dstpos,
-                                              int ndoubles);
-
     /**
      * Returns the first non-null and non-platform class loader (not counting
      * class loaders of generated reflection implementation classes) up the
      * execution stack, or the platform class loader if only code from the
      * bootstrap and platform class loader is on the stack.
@@ -2529,11 +2654,11 @@
             int oldHandle = passHandle;
             ObjectStreamField[] fields = desc.getFields(false);
             int numPrimFields = fields.length - objVals.length;
             for (int i = 0; i < objVals.length; i++) {
                 objVals[i] =
-                    readObject0(fields[numPrimFields + i].isUnshared());
+                    readObject0(Object.class, fields[numPrimFields + i].isUnshared());
                 objHandles[i] = passHandle;
             }
             passHandle = oldHandle;
         }
 
@@ -3427,26 +3552,28 @@
                 }
             }
         }
 
         void readFloats(float[] v, int off, int len) throws IOException {
-            int span, endoff = off + len;
+            int stop, endoff = off + len;
             while (off < endoff) {
                 if (!blkmode) {
-                    span = Math.min(endoff - off, MAX_BLOCK_SIZE >> 2);
+                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE >> 2);
                     in.readFully(buf, 0, span << 2);
+                    stop = off + span;
                     pos = 0;
                 } else if (end - pos < 4) {
                     v[off++] = din.readFloat();
                     continue;
                 } else {
-                    span = Math.min(endoff - off, ((end - pos) >> 2));
+                    stop = Math.min(endoff, ((end - pos) >> 2));
                 }
 
-                bytesToFloats(buf, pos, v, off, span);
-                off += span;
-                pos += span << 2;
+                while (off < stop) {
+                    v[off++] = Bits.getFloat(buf, pos);
+                    pos += 4;
+                }
             }
         }
 
         void readLongs(long[] v, int off, int len) throws IOException {
             int stop, endoff = off + len;
@@ -3469,26 +3596,28 @@
                 }
             }
         }
 
         void readDoubles(double[] v, int off, int len) throws IOException {
-            int span, endoff = off + len;
+            int stop, endoff = off + len;
             while (off < endoff) {
                 if (!blkmode) {
-                    span = Math.min(endoff - off, MAX_BLOCK_SIZE >> 3);
+                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE >> 3);
                     in.readFully(buf, 0, span << 3);
+                    stop = off + span;
                     pos = 0;
                 } else if (end - pos < 8) {
                     v[off++] = din.readDouble();
                     continue;
                 } else {
-                    span = Math.min(endoff - off, ((end - pos) >> 3));
+                    stop = Math.min(endoff - off, ((end - pos) >> 3));
                 }
 
-                bytesToDoubles(buf, pos, v, off, span);
-                off += span;
-                pos += span << 3;
+                while (off < stop) {
+                    v[off++] = Bits.getDouble(buf, pos);
+                    pos += 8;
+                }
             }
         }
 
         /**
          * Reads in string written in "long" UTF format.  "Long" UTF format is
@@ -4014,8 +4143,9 @@
         }
     }
 
     static {
         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
+        SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);
     }
 
 }

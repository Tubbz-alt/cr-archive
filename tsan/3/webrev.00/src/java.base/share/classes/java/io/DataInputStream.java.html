<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/io/DataInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data input stream lets an application read primitive Java data
 30  * types from an underlying input stream in a machine-independent
 31  * way. An application uses a data output stream to write data that
 32  * can later be read by a data input stream.
 33  * &lt;p&gt;
 34  * DataInputStream is not necessarily safe for multithreaded access.
 35  * Thread safety is optional and is the responsibility of users of
 36  * methods in this class.
 37  *
 38  * @author  Arthur van Hoff
 39  * @see     java.io.DataOutputStream
 40  * @since   1.0
 41  */
 42 public class DataInputStream extends FilterInputStream implements DataInput {
 43 
 44     /**
 45      * Creates a DataInputStream that uses the specified
 46      * underlying InputStream.
 47      *
 48      * @param  in   the specified input stream
 49      */
 50     public DataInputStream(InputStream in) {
 51         super(in);
 52     }
 53 
 54     /**
 55      * working arrays initialized on demand by readUTF
 56      */
 57     private byte bytearr[] = new byte[80];
 58     private char chararr[] = new char[80];
 59 
 60     /**
 61      * Reads some number of bytes from the contained input stream and
 62      * stores them into the buffer array {@code b}. The number of
 63      * bytes actually read is returned as an integer. This method blocks
 64      * until input data is available, end of file is detected, or an
 65      * exception is thrown.
 66      *
 67      * &lt;p&gt;If {@code b} is null, a {@code NullPointerException} is
 68      * thrown. If the length of {@code b} is zero, then no bytes are
 69      * read and {@code 0} is returned; otherwise, there is an attempt
 70      * to read at least one byte. If no byte is available because the
 71      * stream is at end of file, the value {@code -1} is returned;
 72      * otherwise, at least one byte is read and stored into {@code b}.
 73      *
 74      * &lt;p&gt;The first byte read is stored into element {@code b[0]}, the
 75      * next one into {@code b[1]}, and so on. The number of bytes read
 76      * is, at most, equal to the length of {@code b}. Let {@code k}
 77      * be the number of bytes actually read; these bytes will be stored in
 78      * elements {@code b[0]} through {@code b[k-1]}, leaving
 79      * elements {@code b[k]} through {@code b[b.length-1]}
 80      * unaffected.
 81      *
 82      * &lt;p&gt;The {@code read(b)} method has the same effect as:
 83      * &lt;blockquote&gt;&lt;pre&gt;
 84      * read(b, 0, b.length)
 85      * &lt;/pre&gt;&lt;/blockquote&gt;
 86      *
 87      * @param      b   the buffer into which the data is read.
 88      * @return     the total number of bytes read into the buffer, or
 89      *             {@code -1} if there is no more data because the end
 90      *             of the stream has been reached.
 91      * @throws     IOException if the first byte cannot be read for any reason
 92      *             other than end of file, the stream has been closed and the underlying
 93      *             input stream does not support reading after close, or another I/O
 94      *             error occurs.
 95      * @see        java.io.FilterInputStream#in
 96      * @see        java.io.InputStream#read(byte[], int, int)
 97      */
 98     public final int read(byte b[]) throws IOException {
 99         return in.read(b, 0, b.length);
100     }
101 
102     /**
103      * Reads up to {@code len} bytes of data from the contained
104      * input stream into an array of bytes.  An attempt is made to read
105      * as many as {@code len} bytes, but a smaller number may be read,
106      * possibly zero. The number of bytes actually read is returned as an
107      * integer.
108      *
109      * &lt;p&gt; This method blocks until input data is available, end of file is
110      * detected, or an exception is thrown.
111      *
112      * &lt;p&gt; If {@code len} is zero, then no bytes are read and
113      * {@code 0} is returned; otherwise, there is an attempt to read at
114      * least one byte. If no byte is available because the stream is at end of
115      * file, the value {@code -1} is returned; otherwise, at least one
116      * byte is read and stored into {@code b}.
117      *
118      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the
119      * next one into {@code b[off+1]}, and so on. The number of bytes read
120      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of
121      * bytes actually read; these bytes will be stored in elements
122      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},
123      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through
124      * {@code b[off+len-1]} unaffected.
125      *
126      * &lt;p&gt; In every case, elements {@code b[0]} through
127      * {@code b[off]} and elements {@code b[off+len]} through
128      * {@code b[b.length-1]} are unaffected.
129      *
130      * @param      b     the buffer into which the data is read.
131      * @param      off the start offset in the destination array {@code b}
132      * @param      len   the maximum number of bytes read.
133      * @return     the total number of bytes read into the buffer, or
134      *             {@code -1} if there is no more data because the end
135      *             of the stream has been reached.
136      * @throws     NullPointerException If {@code b} is {@code null}.
137      * @throws     IndexOutOfBoundsException If {@code off} is negative,
138      *             {@code len} is negative, or {@code len} is greater than
139      *             {@code b.length - off}
140      * @throws     IOException if the first byte cannot be read for any reason
141      *             other than end of file, the stream has been closed and the underlying
142      *             input stream does not support reading after close, or another I/O
143      *             error occurs.
144      * @see        java.io.FilterInputStream#in
145      * @see        java.io.InputStream#read(byte[], int, int)
146      */
147     public final int read(byte b[], int off, int len) throws IOException {
148         return in.read(b, off, len);
149     }
150 
151     /**
152      * See the general contract of the {@code readFully}
153      * method of {@code DataInput}.
154      * &lt;p&gt;
155      * Bytes
156      * for this operation are read from the contained
157      * input stream.
158      *
159      * @param   b   the buffer into which the data is read.
160      * @throws  NullPointerException if {@code b} is {@code null}.
161      * @throws  EOFException  if this input stream reaches the end before
162      *          reading all the bytes.
163      * @throws  IOException   the stream has been closed and the contained
164      *          input stream does not support reading after close, or
165      *          another I/O error occurs.
166      * @see     java.io.FilterInputStream#in
167      */
168     public final void readFully(byte b[]) throws IOException {
169         readFully(b, 0, b.length);
170     }
171 
172     /**
173      * See the general contract of the {@code readFully}
174      * method of {@code DataInput}.
175      * &lt;p&gt;
176      * Bytes
177      * for this operation are read from the contained
178      * input stream.
179      *
180      * @param      b     the buffer into which the data is read.
181      * @param      off   the start offset in the data array {@code b}.
182      * @param      len   the number of bytes to read.
183      * @throws     NullPointerException if {@code b} is {@code null}.
184      * @throws     IndexOutOfBoundsException if {@code off} is negative,
185      *             {@code len} is negative, or {@code len} is greater than
186      *             {@code b.length - off}.
187      * @throws     EOFException  if this input stream reaches the end before
188      *             reading all the bytes.
189      * @throws     IOException   the stream has been closed and the contained
190      *             input stream does not support reading after close, or
191      *             another I/O error occurs.
192      * @see        java.io.FilterInputStream#in
193      */
194     public final void readFully(byte b[], int off, int len) throws IOException {
195         if (len &lt; 0)
196             throw new IndexOutOfBoundsException();
197         int n = 0;
198         while (n &lt; len) {
199             int count = in.read(b, off + n, len - n);
200             if (count &lt; 0)
201                 throw new EOFException();
202             n += count;
203         }
204     }
205 
206     /**
207      * See the general contract of the {@code skipBytes}
208      * method of {@code DataInput}.
209      * &lt;p&gt;
210      * Bytes for this operation are read from the contained
211      * input stream.
212      *
213      * @param      n   the number of bytes to be skipped.
214      * @return     the actual number of bytes skipped.
215      * @throws     IOException  if the contained input stream does not support
216      *             seek, or the stream has been closed and
217      *             the contained input stream does not support
218      *             reading after close, or another I/O error occurs.
219      */
220     public final int skipBytes(int n) throws IOException {
221         int total = 0;
222         int cur = 0;
223 
224         while ((total&lt;n) &amp;&amp; ((cur = (int) in.skip(n-total)) &gt; 0)) {
225             total += cur;
226         }
227 
228         return total;
229     }
230 
231     /**
232      * See the general contract of the {@code readBoolean}
233      * method of {@code DataInput}.
234      * &lt;p&gt;
235      * Bytes for this operation are read from the contained
236      * input stream.
237      *
238      * @return     the {@code boolean} value read.
239      * @throws     EOFException  if this input stream has reached the end.
240      * @throws     IOException   the stream has been closed and the contained
241      *             input stream does not support reading after close, or
242      *             another I/O error occurs.
243      * @see        java.io.FilterInputStream#in
244      */
245     public final boolean readBoolean() throws IOException {
246         int ch = in.read();
247         if (ch &lt; 0)
248             throw new EOFException();
249         return (ch != 0);
250     }
251 
252     /**
253      * See the general contract of the {@code readByte}
254      * method of {@code DataInput}.
255      * &lt;p&gt;
256      * Bytes
257      * for this operation are read from the contained
258      * input stream.
259      *
260      * @return     the next byte of this input stream as a signed 8-bit
261      *             {@code byte}.
262      * @throws     EOFException  if this input stream has reached the end.
263      * @throws     IOException   the stream has been closed and the contained
264      *             input stream does not support reading after close, or
265      *             another I/O error occurs.
266      * @see        java.io.FilterInputStream#in
267      */
268     public final byte readByte() throws IOException {
269         int ch = in.read();
270         if (ch &lt; 0)
271             throw new EOFException();
272         return (byte)(ch);
273     }
274 
275     /**
276      * See the general contract of the {@code readUnsignedByte}
277      * method of {@code DataInput}.
278      * &lt;p&gt;
279      * Bytes
280      * for this operation are read from the contained
281      * input stream.
282      *
283      * @return     the next byte of this input stream, interpreted as an
284      *             unsigned 8-bit number.
285      * @throws     EOFException  if this input stream has reached the end.
286      * @throws     IOException   the stream has been closed and the contained
287      *             input stream does not support reading after close, or
288      *             another I/O error occurs.
289      * @see         java.io.FilterInputStream#in
290      */
291     public final int readUnsignedByte() throws IOException {
292         int ch = in.read();
293         if (ch &lt; 0)
294             throw new EOFException();
295         return ch;
296     }
297 
298     /**
299      * See the general contract of the {@code readShort}
300      * method of {@code DataInput}.
301      * &lt;p&gt;
302      * Bytes
303      * for this operation are read from the contained
304      * input stream.
305      *
306      * @return     the next two bytes of this input stream, interpreted as a
307      *             signed 16-bit number.
308      * @throws     EOFException  if this input stream reaches the end before
309      *               reading two bytes.
310      * @throws     IOException   the stream has been closed and the contained
311      *             input stream does not support reading after close, or
312      *             another I/O error occurs.
313      * @see        java.io.FilterInputStream#in
314      */
315     public final short readShort() throws IOException {
316         int ch1 = in.read();
317         int ch2 = in.read();
318         if ((ch1 | ch2) &lt; 0)
319             throw new EOFException();
320         return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
321     }
322 
323     /**
324      * See the general contract of the {@code readUnsignedShort}
325      * method of {@code DataInput}.
326      * &lt;p&gt;
327      * Bytes
328      * for this operation are read from the contained
329      * input stream.
330      *
331      * @return     the next two bytes of this input stream, interpreted as an
332      *             unsigned 16-bit integer.
333      * @throws     EOFException  if this input stream reaches the end before
334      *             reading two bytes.
335      * @throws     IOException   the stream has been closed and the contained
336      *             input stream does not support reading after close, or
337      *             another I/O error occurs.
338      * @see        java.io.FilterInputStream#in
339      */
340     public final int readUnsignedShort() throws IOException {
341         int ch1 = in.read();
342         int ch2 = in.read();
343         if ((ch1 | ch2) &lt; 0)
344             throw new EOFException();
345         return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
346     }
347 
348     /**
349      * See the general contract of the {@code readChar}
350      * method of {@code DataInput}.
351      * &lt;p&gt;
352      * Bytes
353      * for this operation are read from the contained
354      * input stream.
355      *
356      * @return     the next two bytes of this input stream, interpreted as a
357      *             {@code char}.
358      * @throws     EOFException  if this input stream reaches the end before
359      *               reading two bytes.
360      * @throws     IOException   the stream has been closed and the contained
361      *             input stream does not support reading after close, or
362      *             another I/O error occurs.
363      * @see        java.io.FilterInputStream#in
364      */
365     public final char readChar() throws IOException {
366         int ch1 = in.read();
367         int ch2 = in.read();
368         if ((ch1 | ch2) &lt; 0)
369             throw new EOFException();
370         return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
371     }
372 
373     /**
374      * See the general contract of the {@code readInt}
375      * method of {@code DataInput}.
376      * &lt;p&gt;
377      * Bytes
378      * for this operation are read from the contained
379      * input stream.
380      *
381      * @return     the next four bytes of this input stream, interpreted as an
382      *             {@code int}.
383      * @throws     EOFException  if this input stream reaches the end before
384      *               reading four bytes.
385      * @throws     IOException   the stream has been closed and the contained
386      *             input stream does not support reading after close, or
387      *             another I/O error occurs.
388      * @see        java.io.FilterInputStream#in
389      */
390     public final int readInt() throws IOException {
391         int ch1 = in.read();
392         int ch2 = in.read();
393         int ch3 = in.read();
394         int ch4 = in.read();
395         if ((ch1 | ch2 | ch3 | ch4) &lt; 0)
396             throw new EOFException();
397         return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));
398     }
399 
400     private byte readBuffer[] = new byte[8];
401 
402     /**
403      * See the general contract of the {@code readLong}
404      * method of {@code DataInput}.
405      * &lt;p&gt;
406      * Bytes
407      * for this operation are read from the contained
408      * input stream.
409      *
410      * @return     the next eight bytes of this input stream, interpreted as a
411      *             {@code long}.
412      * @throws     EOFException  if this input stream reaches the end before
413      *               reading eight bytes.
414      * @throws     IOException   the stream has been closed and the contained
415      *             input stream does not support reading after close, or
416      *             another I/O error occurs.
417      * @see        java.io.FilterInputStream#in
418      */
419     public final long readLong() throws IOException {
420         readFully(readBuffer, 0, 8);
421         return (((long)readBuffer[0] &lt;&lt; 56) +
422                 ((long)(readBuffer[1] &amp; 255) &lt;&lt; 48) +
423                 ((long)(readBuffer[2] &amp; 255) &lt;&lt; 40) +
424                 ((long)(readBuffer[3] &amp; 255) &lt;&lt; 32) +
425                 ((long)(readBuffer[4] &amp; 255) &lt;&lt; 24) +
426                 ((readBuffer[5] &amp; 255) &lt;&lt; 16) +
427                 ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
428                 ((readBuffer[7] &amp; 255) &lt;&lt;  0));
429     }
430 
431     /**
432      * See the general contract of the {@code readFloat}
433      * method of {@code DataInput}.
434      * &lt;p&gt;
435      * Bytes
436      * for this operation are read from the contained
437      * input stream.
438      *
439      * @return     the next four bytes of this input stream, interpreted as a
440      *             {@code float}.
441      * @throws     EOFException  if this input stream reaches the end before
442      *               reading four bytes.
443      * @throws     IOException   the stream has been closed and the contained
444      *             input stream does not support reading after close, or
445      *             another I/O error occurs.
446      * @see        java.io.DataInputStream#readInt()
447      * @see        java.lang.Float#intBitsToFloat(int)
448      */
449     public final float readFloat() throws IOException {
450         return Float.intBitsToFloat(readInt());
451     }
452 
453     /**
454      * See the general contract of the {@code readDouble}
455      * method of {@code DataInput}.
456      * &lt;p&gt;
457      * Bytes
458      * for this operation are read from the contained
459      * input stream.
460      *
461      * @return     the next eight bytes of this input stream, interpreted as a
462      *             {@code double}.
463      * @throws     EOFException  if this input stream reaches the end before
464      *               reading eight bytes.
465      * @throws     IOException   the stream has been closed and the contained
466      *             input stream does not support reading after close, or
467      *             another I/O error occurs.
468      * @see        java.io.DataInputStream#readLong()
469      * @see        java.lang.Double#longBitsToDouble(long)
470      */
471     public final double readDouble() throws IOException {
472         return Double.longBitsToDouble(readLong());
473     }
474 
475     private char lineBuffer[];
476 
477     /**
478      * See the general contract of the {@code readLine}
479      * method of {@code DataInput}.
480      * &lt;p&gt;
481      * Bytes
482      * for this operation are read from the contained
483      * input stream.
484      *
485      * @deprecated This method does not properly convert bytes to characters.
486      * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
487      * {@code BufferedReader.readLine()} method.  Programs that use the
488      * {@code DataInputStream} class to read lines can be converted to use
489      * the {@code BufferedReader} class by replacing code of the form:
490      * &lt;blockquote&gt;&lt;pre&gt;
491      *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
492      * &lt;/pre&gt;&lt;/blockquote&gt;
493      * with:
494      * &lt;blockquote&gt;&lt;pre&gt;
495      *     BufferedReader d
496      *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
497      * &lt;/pre&gt;&lt;/blockquote&gt;
498      *
499      * @return     the next line of text from this input stream.
500      * @throws     IOException  if an I/O error occurs.
501      * @see        java.io.BufferedReader#readLine()
502      * @see        java.io.FilterInputStream#in
503      */
504     @Deprecated
505     public final String readLine() throws IOException {
506         char buf[] = lineBuffer;
507 
508         if (buf == null) {
509             buf = lineBuffer = new char[128];
510         }
511 
512         int room = buf.length;
513         int offset = 0;
514         int c;
515 
516 loop:   while (true) {
517             switch (c = in.read()) {
518               case -1:
519               case &#39;\n&#39;:
520                 break loop;
521 
522               case &#39;\r&#39;:
523                 int c2 = in.read();
524                 if ((c2 != &#39;\n&#39;) &amp;&amp; (c2 != -1)) {
525                     if (!(in instanceof PushbackInputStream)) {
526                         this.in = new PushbackInputStream(in);
527                     }
528                     ((PushbackInputStream)in).unread(c2);
529                 }
530                 break loop;
531 
532               default:
533                 if (--room &lt; 0) {
534                     buf = new char[offset + 128];
535                     room = buf.length - offset - 1;
536                     System.arraycopy(lineBuffer, 0, buf, 0, offset);
537                     lineBuffer = buf;
538                 }
539                 buf[offset++] = (char) c;
540                 break;
541             }
542         }
543         if ((c == -1) &amp;&amp; (offset == 0)) {
544             return null;
545         }
546         return String.copyValueOf(buf, 0, offset);
547     }
548 
549     /**
550      * See the general contract of the {@code readUTF}
551      * method of {@code DataInput}.
552      * &lt;p&gt;
553      * Bytes
554      * for this operation are read from the contained
555      * input stream.
556      *
557      * @return     a Unicode string.
558      * @throws     EOFException  if this input stream reaches the end before
559      *               reading all the bytes.
560      * @throws     IOException   the stream has been closed and the contained
561      *             input stream does not support reading after close, or
562      *             another I/O error occurs.
563      * @throws     UTFDataFormatException if the bytes do not represent a valid
564      *             modified UTF-8 encoding of a string.
565      * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
566      */
567     public final String readUTF() throws IOException {
568         return readUTF(this);
569     }
570 
571     /**
572      * Reads from the
573      * stream {@code in} a representation
574      * of a Unicode  character string encoded in
575      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
576      * this string of characters is then returned as a {@code String}.
577      * The details of the modified UTF-8 representation
578      * are  exactly the same as for the {@code readUTF}
579      * method of {@code DataInput}.
580      *
581      * @param      in   a data input stream.
582      * @return     a Unicode string.
583      * @throws     EOFException            if the input stream reaches the end
584      *               before all the bytes.
585      * @throws     IOException   the stream has been closed and the contained
586      *             input stream does not support reading after close, or
587      *             another I/O error occurs.
588      * @throws     UTFDataFormatException  if the bytes do not represent a
589      *               valid modified UTF-8 encoding of a Unicode string.
590      * @see        java.io.DataInputStream#readUnsignedShort()
591      */
592     public static final String readUTF(DataInput in) throws IOException {
593         int utflen = in.readUnsignedShort();
594         byte[] bytearr = null;
595         char[] chararr = null;
596         if (in instanceof DataInputStream) {
597             DataInputStream dis = (DataInputStream)in;
598             if (dis.bytearr.length &lt; utflen){
599                 dis.bytearr = new byte[utflen*2];
600                 dis.chararr = new char[utflen*2];
601             }
602             chararr = dis.chararr;
603             bytearr = dis.bytearr;
604         } else {
605             bytearr = new byte[utflen];
606             chararr = new char[utflen];
607         }
608 
609         int c, char2, char3;
610         int count = 0;
611         int chararr_count=0;
612 
613         in.readFully(bytearr, 0, utflen);
614 
615         while (count &lt; utflen) {
616             c = (int) bytearr[count] &amp; 0xff;
617             if (c &gt; 127) break;
618             count++;
619             chararr[chararr_count++]=(char)c;
620         }
621 
622         while (count &lt; utflen) {
623             c = (int) bytearr[count] &amp; 0xff;
624             switch (c &gt;&gt; 4) {
625                 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
626                     /* 0xxxxxxx*/
627                     count++;
628                     chararr[chararr_count++]=(char)c;
629                     break;
630                 case 12: case 13:
631                     /* 110x xxxx   10xx xxxx*/
632                     count += 2;
633                     if (count &gt; utflen)
634                         throw new UTFDataFormatException(
635                             &quot;malformed input: partial character at end&quot;);
636                     char2 = (int) bytearr[count-1];
637                     if ((char2 &amp; 0xC0) != 0x80)
638                         throw new UTFDataFormatException(
639                             &quot;malformed input around byte &quot; + count);
640                     chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) |
641                                                     (char2 &amp; 0x3F));
642                     break;
643                 case 14:
644                     /* 1110 xxxx  10xx xxxx  10xx xxxx */
645                     count += 3;
646                     if (count &gt; utflen)
647                         throw new UTFDataFormatException(
648                             &quot;malformed input: partial character at end&quot;);
649                     char2 = (int) bytearr[count-2];
650                     char3 = (int) bytearr[count-1];
651                     if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80))
652                         throw new UTFDataFormatException(
653                             &quot;malformed input around byte &quot; + (count-1));
654                     chararr[chararr_count++]=(char)(((c     &amp; 0x0F) &lt;&lt; 12) |
655                                                     ((char2 &amp; 0x3F) &lt;&lt; 6)  |
656                                                     ((char3 &amp; 0x3F) &lt;&lt; 0));
657                     break;
658                 default:
659                     /* 10xx xxxx,  1111 xxxx */
660                     throw new UTFDataFormatException(
661                         &quot;malformed input around byte &quot; + count);
662             }
663         }
664         // The number of chars produced may be less than utflen
665         return new String(chararr, 0, chararr_count);
666     }
667 }
    </pre>
  </body>
</html>
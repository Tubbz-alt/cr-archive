<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/time/chrono/HijrahChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
  28  *
  29  * All rights reserved.
  30  *
  31  * Redistribution and use in source and binary forms, with or without
  32  * modification, are permitted provided that the following conditions are met:
  33  *
  34  *  * Redistributions of source code must retain the above copyright notice,
  35  *    this list of conditions and the following disclaimer.
  36  *
  37  *  * Redistributions in binary form must reproduce the above copyright notice,
  38  *    this list of conditions and the following disclaimer in the documentation
  39  *    and/or other materials provided with the distribution.
  40  *
  41  *  * Neither the name of JSR-310 nor the names of its contributors
  42  *    may be used to endorse or promote products derived from this software
  43  *    without specific prior written permission.
  44  *
  45  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  46  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  47  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  48  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  49  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  50  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  51  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  52  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  53  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  54  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  55  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  56  */
  57 
  58 package java.time.chrono;
  59 
  60 import static java.time.temporal.ChronoField.EPOCH_DAY;
  61 
  62 import java.io.FilePermission;
  63 import java.io.IOException;
  64 import java.io.InputStream;
  65 import java.io.InvalidObjectException;
  66 import java.io.ObjectInputStream;
  67 import java.io.Serializable;
  68 import java.io.UncheckedIOException;
  69 import java.nio.file.Files;
  70 import java.nio.file.Path;
  71 import java.nio.file.StandardOpenOption;
  72 import java.security.AccessController;
  73 import java.security.PrivilegedAction;
  74 import java.time.Clock;
  75 import java.time.DateTimeException;
  76 import java.time.Instant;
  77 import java.time.LocalDate;
  78 import java.time.ZoneId;
  79 import java.time.format.ResolverStyle;
  80 import java.time.temporal.ChronoField;
  81 import java.time.temporal.TemporalAccessor;
  82 import java.time.temporal.TemporalField;
  83 import java.time.temporal.ValueRange;
  84 import java.util.Arrays;
  85 import java.util.HashMap;
  86 import java.util.List;
  87 import java.util.Map;
  88 import java.util.Properties;
  89 
  90 import sun.util.logging.PlatformLogger;
  91 
  92 /**
  93  * The Hijrah calendar is a lunar calendar supporting Islamic calendars.
  94  * &lt;p&gt;
  95  * The HijrahChronology follows the rules of the Hijrah calendar system. The Hijrah
  96  * calendar has several variants based on differences in when the new moon is
  97  * determined to have occurred and where the observation is made.
  98  * In some variants the length of each month is
  99  * computed algorithmically from the astronomical data for the moon and earth and
 100  * in others the length of the month is determined by an authorized sighting
 101  * of the new moon. For the algorithmically based calendars the calendar
 102  * can project into the future.
 103  * For sighting based calendars only historical data from past
 104  * sightings is available.
 105  * &lt;p&gt;
 106  * The length of each month is 29 or 30 days.
 107  * Ordinary years have 354 days; leap years have 355 days.
 108  *
 109  * &lt;p&gt;
 110  * CLDR and LDML identify variants:
 111  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 112  * &lt;caption style=&quot;display:none&quot;&gt;Variants of Hijrah Calendars&lt;/caption&gt;
 113  * &lt;thead&gt;
 114  * &lt;tr&gt;
 115  * &lt;th scope=&quot;col&quot;&gt;Chronology ID&lt;/th&gt;
 116  * &lt;th scope=&quot;col&quot;&gt;Calendar Type&lt;/th&gt;
 117  * &lt;th scope=&quot;col&quot;&gt;Locale extension, see {@link java.util.Locale}&lt;/th&gt;
 118  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 119  * &lt;/tr&gt;
 120  * &lt;/thead&gt;
 121  * &lt;tbody&gt;
 122  * &lt;tr&gt;
 123  * &lt;th scope=&quot;row&quot;&gt;Hijrah-umalqura&lt;/th&gt;
 124  * &lt;td&gt;islamic-umalqura&lt;/td&gt;
 125  * &lt;td&gt;ca-islamic-umalqura&lt;/td&gt;
 126  * &lt;td&gt;Islamic - Umm Al-Qura calendar of Saudi Arabia&lt;/td&gt;
 127  * &lt;/tr&gt;
 128  * &lt;/tbody&gt;
 129  * &lt;/table&gt;
 130  * &lt;p&gt;Additional variants may be available through {@link Chronology#getAvailableChronologies()}.
 131  *
 132  * &lt;p&gt;Example&lt;/p&gt;
 133  * &lt;p&gt;
 134  * Selecting the chronology from the locale uses {@link Chronology#ofLocale}
 135  * to find the Chronology based on Locale supported BCP 47 extension mechanism
 136  * to request a specific calendar (&quot;ca&quot;). For example,
 137  * &lt;/p&gt;
 138  * &lt;pre&gt;
 139  *      Locale locale = Locale.forLanguageTag(&quot;en-US-u-ca-islamic-umalqura&quot;);
 140  *      Chronology chrono = Chronology.ofLocale(locale);
 141  * &lt;/pre&gt;
 142  *
 143  * @implSpec
 144  * This class is immutable and thread-safe.
 145  *
 146  * @implNote
 147  * Each Hijrah variant is configured individually. Each variant is defined by a
 148  * property resource that defines the {@code ID}, the {@code calendar type},
 149  * the start of the calendar, the alignment with the
 150  * ISO calendar, and the length of each month for a range of years.
 151  * The variants are loaded by HijrahChronology as a resource from
 152  * hijrah-config-&amp;lt;calendar type&amp;gt;.properties.
 153  * &lt;p&gt;
 154  * The Hijrah property resource is a set of properties that describe the calendar.
 155  * The syntax is defined by {@code java.util.Properties#load(Reader)}.
 156  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 157  * &lt;caption style=&quot;display:none&quot;&gt;Configuration of Hijrah Calendar&lt;/caption&gt;
 158  * &lt;thead&gt;
 159  * &lt;tr&gt;
 160  * &lt;th scope=&quot;col&quot;&gt;Property Name&lt;/th&gt;
 161  * &lt;th scope=&quot;col&quot;&gt;Property value&lt;/th&gt;
 162  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 163  * &lt;/tr&gt;
 164  * &lt;/thead&gt;
 165  * &lt;tbody&gt;
 166  * &lt;tr&gt;
 167  * &lt;th scope=&quot;row&quot;&gt;id&lt;/th&gt;
 168  * &lt;td&gt;Chronology Id, for example, &quot;Hijrah-umalqura&quot;&lt;/td&gt;
 169  * &lt;td&gt;The Id of the calendar in common usage&lt;/td&gt;
 170  * &lt;/tr&gt;
 171  * &lt;tr&gt;
 172  * &lt;th scope=&quot;row&quot;&gt;type&lt;/th&gt;
 173  * &lt;td&gt;Calendar type, for example, &quot;islamic-umalqura&quot;&lt;/td&gt;
 174  * &lt;td&gt;LDML defines the calendar types&lt;/td&gt;
 175  * &lt;/tr&gt;
 176  * &lt;tr&gt;
 177  * &lt;th scope=&quot;row&quot;&gt;version&lt;/th&gt;
 178  * &lt;td&gt;Version, for example: &quot;1.8.0_1&quot;&lt;/td&gt;
 179  * &lt;td&gt;The version of the Hijrah variant data&lt;/td&gt;
 180  * &lt;/tr&gt;
 181  * &lt;tr&gt;
 182  * &lt;th scope=&quot;row&quot;&gt;iso-start&lt;/th&gt;
 183  * &lt;td&gt;ISO start date, formatted as {@code yyyy-MM-dd}, for example: &quot;1900-04-30&quot;&lt;/td&gt;
 184  * &lt;td&gt;The ISO date of the first day of the minimum Hijrah year.&lt;/td&gt;
 185  * &lt;/tr&gt;
 186  * &lt;tr&gt;
 187  * &lt;th scope=&quot;row&quot;&gt;yyyy - a numeric 4 digit year, for example &quot;1434&quot;&lt;/th&gt;
 188  * &lt;td&gt;The value is a sequence of 12 month lengths,
 189  * for example: &quot;29 30 29 30 29 30 30 30 29 30 29 29&quot;&lt;/td&gt;
 190  * &lt;td&gt;The lengths of the 12 months of the year separated by whitespace.
 191  * A numeric year property must be present for every year without any gaps.
 192  * The month lengths must be between 29-32 inclusive.
 193  * &lt;/td&gt;
 194  * &lt;/tr&gt;
 195  * &lt;/tbody&gt;
 196  * &lt;/table&gt;
 197  * &lt;p&gt;
 198  * Additional variants may be added by providing configuration properties files in
 199  * {@code &lt;JAVA_HOME&gt;/conf/chronology} directory. The properties
 200  * files should follow the naming convention of
 201  * {@code hijrah-config-&lt;chronology id&gt;_&lt;calendar type&gt;.properties}.
 202  *
 203  * @since 1.8
 204  */
 205 public final class HijrahChronology extends AbstractChronology implements Serializable {
 206 
 207     /**
 208      * The Hijrah Calendar id.
 209      */
 210     private final transient String typeId;
 211     /**
 212      * The Hijrah calendarType.
 213      */
 214     private final transient String calendarType;
 215     /**
 216      * Serialization version.
 217      */
 218     @java.io.Serial
 219     private static final long serialVersionUID = 3127340209035924785L;
 220     /**
 221      * Singleton instance of the Islamic Umm Al-Qura calendar of Saudi Arabia.
 222      * Other Hijrah chronology variants may be available from
 223      * {@link Chronology#getAvailableChronologies}.
 224      */
 225     public static final HijrahChronology INSTANCE;
 226     /**
 227      * Flag to indicate the initialization of configuration data is complete.
 228      * @see #checkCalendarInit()
 229      */
 230     private transient volatile boolean initComplete;
 231     /**
 232      * Array of epoch days indexed by Hijrah Epoch month.
 233      * Computed by {@link #loadCalendarData}.
 234      */
 235     private transient int[] hijrahEpochMonthStartDays;
 236     /**
 237      * The minimum epoch day of this Hijrah calendar.
 238      * Computed by {@link #loadCalendarData}.
 239      */
 240     private transient int minEpochDay;
 241     /**
 242      * The maximum epoch day for which calendar data is available.
 243      * Computed by {@link #loadCalendarData}.
 244      */
 245     private transient int maxEpochDay;
 246     /**
 247      * The minimum epoch month.
 248      * Computed by {@link #loadCalendarData}.
 249      */
 250     private transient int hijrahStartEpochMonth;
 251     /**
 252      * The minimum length of a month.
 253      * Computed by {@link #createEpochMonths}.
 254      */
 255     private transient int minMonthLength;
 256     /**
 257      * The maximum length of a month.
 258      * Computed by {@link #createEpochMonths}.
 259      */
 260     private transient int maxMonthLength;
 261     /**
 262      * The minimum length of a year in days.
 263      * Computed by {@link #createEpochMonths}.
 264      */
 265     private transient int minYearLength;
 266     /**
 267      * The maximum length of a year in days.
 268      * Computed by {@link #createEpochMonths}.
 269      */
 270     private transient int maxYearLength;
 271 
 272     /**
 273      * Prefix of resource names for Hijrah calendar variants.
 274      */
 275     private static final String RESOURCE_PREFIX = &quot;hijrah-config-&quot;;
 276 
 277     /**
 278      * Suffix of resource names for Hijrah calendar variants.
 279      */
 280     private static final String RESOURCE_SUFFIX = &quot;.properties&quot;;
 281 
 282     /**
 283      * Static initialization of the built-in calendars.
 284      * The data is not loaded until it is used.
 285      */
 286     static {
 287         INSTANCE = new HijrahChronology(&quot;Hijrah-umalqura&quot;, &quot;islamic-umalqura&quot;);
 288         // Register it by its aliases
 289         AbstractChronology.registerChrono(INSTANCE, &quot;Hijrah&quot;);
 290         AbstractChronology.registerChrono(INSTANCE, &quot;islamic&quot;);
 291 
 292         // custom config chronologies
 293         CONF_PATH = Path.of(AccessController.doPrivileged((PrivilegedAction&lt;String&gt;)
 294                 () -&gt; System.getProperty(&quot;java.home&quot;)), &quot;conf&quot;, &quot;chronology&quot;);
 295         registerCustomChrono();
 296     }
 297 
 298     /**
 299      * Create a HijrahChronology for the named variant and type.
 300      *
 301      * @param id the id of the calendar
 302      * @param calType the typeId of the calendar
 303      * @throws IllegalArgumentException if the id or typeId is empty
 304      */
 305     private HijrahChronology(String id, String calType) {
 306         if (id.isEmpty()) {
 307             throw new IllegalArgumentException(&quot;calendar id is empty&quot;);
 308         }
 309         if (calType.isEmpty()) {
 310             throw new IllegalArgumentException(&quot;calendar typeId is empty&quot;);
 311         }
 312         this.typeId = id;
 313         this.calendarType = calType;
 314     }
 315 
 316     /**
 317      * Check and ensure that the calendar data has been initialized.
 318      * The initialization check is performed at the boundary between
 319      * public and package methods.  If a public calls another public method
 320      * a check is not necessary in the caller.
 321      * The constructors of HijrahDate call {@link #getEpochDay} or
 322      * {@link #getHijrahDateInfo} so every call from HijrahDate to a
 323      * HijrahChronology via package private methods has been checked.
 324      *
 325      * @throws DateTimeException if the calendar data configuration is
 326      *     malformed or IOExceptions occur loading the data
 327      */
 328     private void checkCalendarInit() {
 329         // Keep this short so it can be inlined for performance
 330         if (initComplete == false) {
 331             loadCalendarData();
 332             initComplete = true;
 333         }
 334     }
 335 
 336     //-----------------------------------------------------------------------
 337     /**
 338      * Gets the ID of the chronology.
 339      * &lt;p&gt;
 340      * The ID uniquely identifies the {@code Chronology}. It can be used to
 341      * lookup the {@code Chronology} using {@link Chronology#of(String)}.
 342      *
 343      * @return the chronology ID, non-null
 344      * @see #getCalendarType()
 345      */
 346     @Override
 347     public String getId() {
 348         return typeId;
 349     }
 350 
 351     /**
 352      * Gets the calendar type of the Islamic calendar.
 353      * &lt;p&gt;
 354      * The calendar type is an identifier defined by the
 355      * &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification.
 356      * It can be used to lookup the {@code Chronology} using {@link Chronology#of(String)}.
 357      *
 358      * @return the calendar system type; non-null if the calendar has
 359      *    a standard type, otherwise null
 360      * @see #getId()
 361      */
 362     @Override
 363     public String getCalendarType() {
 364         return calendarType;
 365     }
 366 
 367     //-----------------------------------------------------------------------
 368     /**
 369      * Obtains a local date in Hijrah calendar system from the
 370      * era, year-of-era, month-of-year and day-of-month fields.
 371      *
 372      * @param era  the Hijrah era, not null
 373      * @param yearOfEra  the year-of-era
 374      * @param month  the month-of-year
 375      * @param dayOfMonth  the day-of-month
 376      * @return the Hijrah local date, not null
 377      * @throws DateTimeException if unable to create the date
 378      * @throws ClassCastException if the {@code era} is not a {@code HijrahEra}
 379      */
 380     @Override
 381     public HijrahDate date(Era era, int yearOfEra, int month, int dayOfMonth) {
 382         return date(prolepticYear(era, yearOfEra), month, dayOfMonth);
 383     }
 384 
 385     /**
 386      * Obtains a local date in Hijrah calendar system from the
 387      * proleptic-year, month-of-year and day-of-month fields.
 388      *
 389      * @param prolepticYear  the proleptic-year
 390      * @param month  the month-of-year
 391      * @param dayOfMonth  the day-of-month
 392      * @return the Hijrah local date, not null
 393      * @throws DateTimeException if unable to create the date
 394      */
 395     @Override
 396     public HijrahDate date(int prolepticYear, int month, int dayOfMonth) {
 397         return HijrahDate.of(this, prolepticYear, month, dayOfMonth);
 398     }
 399 
 400     /**
 401      * Obtains a local date in Hijrah calendar system from the
 402      * era, year-of-era and day-of-year fields.
 403      *
 404      * @param era  the Hijrah era, not null
 405      * @param yearOfEra  the year-of-era
 406      * @param dayOfYear  the day-of-year
 407      * @return the Hijrah local date, not null
 408      * @throws DateTimeException if unable to create the date
 409      * @throws ClassCastException if the {@code era} is not a {@code HijrahEra}
 410      */
 411     @Override
 412     public HijrahDate dateYearDay(Era era, int yearOfEra, int dayOfYear) {
 413         return dateYearDay(prolepticYear(era, yearOfEra), dayOfYear);
 414     }
 415 
 416     /**
 417      * Obtains a local date in Hijrah calendar system from the
 418      * proleptic-year and day-of-year fields.
 419      *
 420      * @param prolepticYear  the proleptic-year
 421      * @param dayOfYear  the day-of-year
 422      * @return the Hijrah local date, not null
 423      * @throws DateTimeException if the value of the year is out of range,
 424      *  or if the day-of-year is invalid for the year
 425      */
 426     @Override
 427     public HijrahDate dateYearDay(int prolepticYear, int dayOfYear) {
 428         HijrahDate date = HijrahDate.of(this, prolepticYear, 1, 1);
 429         if (dayOfYear &gt; date.lengthOfYear()) {
 430             throw new DateTimeException(&quot;Invalid dayOfYear: &quot; + dayOfYear);
 431         }
 432         return date.plusDays(dayOfYear - 1);
 433     }
 434 
 435     /**
 436      * Obtains a local date in the Hijrah calendar system from the epoch-day.
 437      *
 438      * @param epochDay  the epoch day
 439      * @return the Hijrah local date, not null
 440      * @throws DateTimeException if unable to create the date
 441      */
 442     @Override  // override with covariant return type
 443     public HijrahDate dateEpochDay(long epochDay) {
 444         return HijrahDate.ofEpochDay(this, epochDay);
 445     }
 446 
 447     @Override
 448     public HijrahDate dateNow() {
 449         return dateNow(Clock.systemDefaultZone());
 450     }
 451 
 452     @Override
 453     public HijrahDate dateNow(ZoneId zone) {
 454         return dateNow(Clock.system(zone));
 455     }
 456 
 457     @Override
 458     public HijrahDate dateNow(Clock clock) {
 459         return date(LocalDate.now(clock));
 460     }
 461 
 462     @Override
 463     public HijrahDate date(TemporalAccessor temporal) {
 464         if (temporal instanceof HijrahDate) {
 465             return (HijrahDate) temporal;
 466         }
 467         return HijrahDate.ofEpochDay(this, temporal.getLong(EPOCH_DAY));
 468     }
 469 
 470     @Override
 471     @SuppressWarnings(&quot;unchecked&quot;)
 472     public ChronoLocalDateTime&lt;HijrahDate&gt; localDateTime(TemporalAccessor temporal) {
 473         return (ChronoLocalDateTime&lt;HijrahDate&gt;) super.localDateTime(temporal);
 474     }
 475 
 476     @Override
 477     @SuppressWarnings(&quot;unchecked&quot;)
 478     public ChronoZonedDateTime&lt;HijrahDate&gt; zonedDateTime(TemporalAccessor temporal) {
 479         return (ChronoZonedDateTime&lt;HijrahDate&gt;) super.zonedDateTime(temporal);
 480     }
 481 
 482     @Override
 483     @SuppressWarnings(&quot;unchecked&quot;)
 484     public ChronoZonedDateTime&lt;HijrahDate&gt; zonedDateTime(Instant instant, ZoneId zone) {
 485         return (ChronoZonedDateTime&lt;HijrahDate&gt;) super.zonedDateTime(instant, zone);
 486     }
 487 
 488     //-----------------------------------------------------------------------
 489     @Override
 490     public boolean isLeapYear(long prolepticYear) {
 491         checkCalendarInit();
 492         if (prolepticYear &lt; getMinimumYear() || prolepticYear &gt; getMaximumYear()) {
 493             return false;
 494         }
 495         int len = getYearLength((int) prolepticYear);
 496         return (len &gt; 354);
 497     }
 498 
 499     @Override
 500     public int prolepticYear(Era era, int yearOfEra) {
 501         if (era instanceof HijrahEra == false) {
 502             throw new ClassCastException(&quot;Era must be HijrahEra&quot;);
 503         }
 504         return yearOfEra;
 505     }
 506 
 507     /**
 508      * Creates the HijrahEra object from the numeric value.
 509      * The Hijrah calendar system has only one era covering the
 510      * proleptic years greater than zero.
 511      * This method returns the singleton HijrahEra for the value 1.
 512      *
 513      * @param eraValue  the era value
 514      * @return the calendar system era, not null
 515      * @throws DateTimeException if unable to create the era
 516      */
 517     @Override
 518     public HijrahEra eraOf(int eraValue) {
 519         switch (eraValue) {
 520             case 1:
 521                 return HijrahEra.AH;
 522             default:
 523                 throw new DateTimeException(&quot;invalid Hijrah era&quot;);
 524         }
 525     }
 526 
 527     @Override
 528     public List&lt;Era&gt; eras() {
 529         return List.of(HijrahEra.values());
 530     }
 531 
 532     //-----------------------------------------------------------------------
 533     @Override
 534     public ValueRange range(ChronoField field) {
 535         checkCalendarInit();
 536         if (field instanceof ChronoField) {
 537             ChronoField f = field;
 538             switch (f) {
 539                 case DAY_OF_MONTH:
 540                     return ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());
 541                 case DAY_OF_YEAR:
 542                     return ValueRange.of(1, getMaximumDayOfYear());
 543                 case ALIGNED_WEEK_OF_MONTH:
 544                     return ValueRange.of(1, 5);
 545                 case YEAR:
 546                 case YEAR_OF_ERA:
 547                     return ValueRange.of(getMinimumYear(), getMaximumYear());
 548                 case ERA:
 549                     return ValueRange.of(1, 1);
 550                 default:
 551                     return field.range();
 552             }
 553         }
 554         return field.range();
 555     }
 556 
 557     //-----------------------------------------------------------------------
 558     @Override  // override for return type
 559     public HijrahDate resolveDate(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
 560         return (HijrahDate) super.resolveDate(fieldValues, resolverStyle);
 561     }
 562 
 563     //-----------------------------------------------------------------------
 564     /**
 565      * Check the validity of a year.
 566      *
 567      * @param prolepticYear the year to check
 568      */
 569     int checkValidYear(long prolepticYear) {
 570         if (prolepticYear &lt; getMinimumYear() || prolepticYear &gt; getMaximumYear()) {
 571             throw new DateTimeException(&quot;Invalid Hijrah year: &quot; + prolepticYear);
 572         }
 573         return (int) prolepticYear;
 574     }
 575 
 576     void checkValidDayOfYear(int dayOfYear) {
 577         if (dayOfYear &lt; 1 || dayOfYear &gt; getMaximumDayOfYear()) {
 578             throw new DateTimeException(&quot;Invalid Hijrah day of year: &quot; + dayOfYear);
 579         }
 580     }
 581 
 582     void checkValidMonth(int month) {
 583         if (month &lt; 1 || month &gt; 12) {
 584             throw new DateTimeException(&quot;Invalid Hijrah month: &quot; + month);
 585         }
 586     }
 587 
 588     //-----------------------------------------------------------------------
 589     /**
 590      * Returns an array containing the Hijrah year, month and day
 591      * computed from the epoch day.
 592      *
 593      * @param epochDay  the EpochDay
 594      * @return int[0] = YEAR, int[1] = MONTH, int[2] = DATE
 595      */
 596     int[] getHijrahDateInfo(int epochDay) {
 597         checkCalendarInit();    // ensure that the chronology is initialized
 598         if (epochDay &lt; minEpochDay || epochDay &gt;= maxEpochDay) {
 599             throw new DateTimeException(&quot;Hijrah date out of range&quot;);
 600         }
 601 
 602         int epochMonth = epochDayToEpochMonth(epochDay);
 603         int year = epochMonthToYear(epochMonth);
 604         int month = epochMonthToMonth(epochMonth);
 605         int day1 = epochMonthToEpochDay(epochMonth);
 606         int date = epochDay - day1; // epochDay - dayOfEpoch(year, month);
 607 
 608         int dateInfo[] = new int[3];
 609         dateInfo[0] = year;
 610         dateInfo[1] = month + 1; // change to 1-based.
 611         dateInfo[2] = date + 1; // change to 1-based.
 612         return dateInfo;
 613     }
 614 
 615     /**
 616      * Return the epoch day computed from Hijrah year, month, and day.
 617      *
 618      * @param prolepticYear the year to represent, 0-origin
 619      * @param monthOfYear the month-of-year to represent, 1-origin
 620      * @param dayOfMonth the day-of-month to represent, 1-origin
 621      * @return the epoch day
 622      */
 623     long getEpochDay(int prolepticYear, int monthOfYear, int dayOfMonth) {
 624         checkCalendarInit();    // ensure that the chronology is initialized
 625         checkValidMonth(monthOfYear);
 626         int epochMonth = yearToEpochMonth(prolepticYear) + (monthOfYear - 1);
 627         if (epochMonth &lt; 0 || epochMonth &gt;= hijrahEpochMonthStartDays.length) {
 628             throw new DateTimeException(&quot;Invalid Hijrah date, year: &quot; +
 629                     prolepticYear +  &quot;, month: &quot; + monthOfYear);
 630         }
 631         if (dayOfMonth &lt; 1 || dayOfMonth &gt; getMonthLength(prolepticYear, monthOfYear)) {
 632             throw new DateTimeException(&quot;Invalid Hijrah day of month: &quot; + dayOfMonth);
 633         }
 634         return epochMonthToEpochDay(epochMonth) + (dayOfMonth - 1);
 635     }
 636 
 637     /**
 638      * Returns day of year for the year and month.
 639      *
 640      * @param prolepticYear a proleptic year
 641      * @param month a month, 1-origin
 642      * @return the day of year, 1-origin
 643      */
 644     int getDayOfYear(int prolepticYear, int month) {
 645         return yearMonthToDayOfYear(prolepticYear, (month - 1));
 646     }
 647 
 648     /**
 649      * Returns month length for the year and month.
 650      *
 651      * @param prolepticYear a proleptic year
 652      * @param monthOfYear a month, 1-origin.
 653      * @return the length of the month
 654      */
 655     int getMonthLength(int prolepticYear, int monthOfYear) {
 656         int epochMonth = yearToEpochMonth(prolepticYear) + (monthOfYear - 1);
 657         if (epochMonth &lt; 0 || epochMonth &gt;= hijrahEpochMonthStartDays.length) {
 658             throw new DateTimeException(&quot;Invalid Hijrah date, year: &quot; +
 659                     prolepticYear +  &quot;, month: &quot; + monthOfYear);
 660         }
 661         return epochMonthLength(epochMonth);
 662     }
 663 
 664     /**
 665      * Returns year length.
 666      * Note: The 12th month must exist in the data.
 667      *
 668      * @param prolepticYear a proleptic year
 669      * @return year length in days
 670      */
 671     int getYearLength(int prolepticYear) {
 672         return yearMonthToDayOfYear(prolepticYear, 12);
 673     }
 674 
 675     /**
 676      * Return the minimum supported Hijrah year.
 677      *
 678      * @return the minimum
 679      */
 680     int getMinimumYear() {
 681         return epochMonthToYear(0);
 682     }
 683 
 684     /**
 685      * Return the maximum supported Hijrah year.
 686      *
 687      * @return the minimum
 688      */
 689     int getMaximumYear() {
 690         return epochMonthToYear(hijrahEpochMonthStartDays.length - 1) - 1;
 691     }
 692 
 693     /**
 694      * Returns maximum day-of-month.
 695      *
 696      * @return maximum day-of-month
 697      */
 698     int getMaximumMonthLength() {
 699         return maxMonthLength;
 700     }
 701 
 702     /**
 703      * Returns smallest maximum day-of-month.
 704      *
 705      * @return smallest maximum day-of-month
 706      */
 707     int getMinimumMonthLength() {
 708         return minMonthLength;
 709     }
 710 
 711     /**
 712      * Returns maximum day-of-year.
 713      *
 714      * @return maximum day-of-year
 715      */
 716     int getMaximumDayOfYear() {
 717         return maxYearLength;
 718     }
 719 
 720     /**
 721      * Returns smallest maximum day-of-year.
 722      *
 723      * @return smallest maximum day-of-year
 724      */
 725     int getSmallestMaximumDayOfYear() {
 726         return minYearLength;
 727     }
 728 
 729     /**
 730      * Returns the epochMonth found by locating the epochDay in the table. The
 731      * epochMonth is the index in the table
 732      *
 733      * @param epochDay
 734      * @return The index of the element of the start of the month containing the
 735      * epochDay.
 736      */
 737     private int epochDayToEpochMonth(int epochDay) {
 738         // binary search
 739         int ndx = Arrays.binarySearch(hijrahEpochMonthStartDays, epochDay);
 740         if (ndx &lt; 0) {
 741             ndx = -ndx - 2;
 742         }
 743         return ndx;
 744     }
 745 
 746     /**
 747      * Returns the year computed from the epochMonth
 748      *
 749      * @param epochMonth the epochMonth
 750      * @return the Hijrah Year
 751      */
 752     private int epochMonthToYear(int epochMonth) {
 753         return (epochMonth + hijrahStartEpochMonth) / 12;
 754     }
 755 
 756     /**
 757      * Returns the epochMonth for the Hijrah Year.
 758      *
 759      * @param year the HijrahYear
 760      * @return the epochMonth for the beginning of the year.
 761      */
 762     private int yearToEpochMonth(int year) {
 763         return (year * 12) - hijrahStartEpochMonth;
 764     }
 765 
 766     /**
 767      * Returns the Hijrah month from the epochMonth.
 768      *
 769      * @param epochMonth the epochMonth
 770      * @return the month of the Hijrah Year
 771      */
 772     private int epochMonthToMonth(int epochMonth) {
 773         return (epochMonth + hijrahStartEpochMonth) % 12;
 774     }
 775 
 776     /**
 777      * Returns the epochDay for the start of the epochMonth.
 778      *
 779      * @param epochMonth the epochMonth
 780      * @return the epochDay for the start of the epochMonth.
 781      */
 782     private int epochMonthToEpochDay(int epochMonth) {
 783         return hijrahEpochMonthStartDays[epochMonth];
 784 
 785     }
 786 
 787     /**
 788      * Returns the day of year for the requested HijrahYear and month.
 789      *
 790      * @param prolepticYear the Hijrah year
 791      * @param month the Hijrah month
 792      * @return the day of year for the start of the month of the year
 793      */
 794     private int yearMonthToDayOfYear(int prolepticYear, int month) {
 795         int epochMonthFirst = yearToEpochMonth(prolepticYear);
 796         return epochMonthToEpochDay(epochMonthFirst + month)
 797                 - epochMonthToEpochDay(epochMonthFirst);
 798     }
 799 
 800     /**
 801      * Returns the length of the epochMonth. It is computed from the start of
 802      * the following month minus the start of the requested month.
 803      *
 804      * @param epochMonth the epochMonth; assumed to be within range
 805      * @return the length in days of the epochMonth
 806      */
 807     private int epochMonthLength(int epochMonth) {
 808         // The very last entry in the epochMonth table is not the start of a month
 809         return hijrahEpochMonthStartDays[epochMonth + 1]
 810                 - hijrahEpochMonthStartDays[epochMonth];
 811     }
 812 
 813     //-----------------------------------------------------------------------
 814     private static final String KEY_ID = &quot;id&quot;;
 815     private static final String KEY_TYPE = &quot;type&quot;;
 816     private static final String KEY_VERSION = &quot;version&quot;;
 817     private static final String KEY_ISO_START = &quot;iso-start&quot;;
 818     private static final Path CONF_PATH;
 819 
 820     /**
 821      * Return the configuration properties from the resource.
 822      * &lt;p&gt;
 823      * The location of the variant configuration resource is:
 824      * &lt;pre&gt;
 825      *   &quot;/java/time/chrono/&quot; (for &quot;islamic-umalqura&quot; type), or
 826      *   &quot;&lt;JAVA_HOME&gt;/conf/chronology/&quot; +
 827      *   &quot;hijrah-config-&quot; + chronologyId + &quot;_&quot; + calendarType + &quot;.properties&quot;
 828      * &lt;/pre&gt;
 829      *
 830      * @param chronologyId the chronology ID of the calendar variant
 831      * @param calendarType the calendarType of the calendar variant
 832      * @return a Properties containing the properties read from the resource.
 833      * @throws Exception if access to the property resource fails
 834      */
 835     private static Properties readConfigProperties(final String chronologyId, final String calendarType) throws Exception {
 836         String resourceName = RESOURCE_PREFIX + chronologyId + &quot;_&quot; + calendarType + RESOURCE_SUFFIX;
 837         PrivilegedAction&lt;InputStream&gt; getResourceAction =  calendarType.equals(&quot;islamic-umalqura&quot;) ?
 838             () -&gt; HijrahChronology.class.getResourceAsStream(resourceName) :
 839             () -&gt; {
 840                 try {
 841                     return Files.newInputStream(CONF_PATH.resolve(resourceName),
 842                             StandardOpenOption.READ);
 843                 } catch (IOException e) {
 844                     throw new UncheckedIOException(e);
 845                 }
 846             };
 847         FilePermission perm1 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;);
 848         RuntimePermission perm2 = new RuntimePermission(&quot;accessSystemModules&quot;);
 849         try (InputStream is = AccessController.doPrivileged(getResourceAction, null, perm1, perm2)) {
 850             if (is == null) {
 851                 throw new RuntimeException(&quot;Hijrah calendar resource not found: &quot; + resourceName);
 852             }
 853             Properties props = new Properties();
 854             props.load(is);
 855             return props;
 856         }
 857     }
 858 
 859     /**
 860      * Loads and processes the Hijrah calendar properties file for this calendarType.
 861      * The starting Hijrah date and the corresponding ISO date are
 862      * extracted and used to calculate the epochDate offset.
 863      * The version number is identified and ignored.
 864      * Everything else is the data for a year with containing the length of each
 865      * of 12 months.
 866      *
 867      * @throws DateTimeException if initialization of the calendar data from the
 868      *     resource fails
 869      */
 870     private void loadCalendarData() {
 871         try {
 872             Properties props = readConfigProperties(typeId, calendarType);
 873 
 874             Map&lt;Integer, int[]&gt; years = new HashMap&lt;&gt;();
 875             int minYear = Integer.MAX_VALUE;
 876             int maxYear = Integer.MIN_VALUE;
 877             String id = null;
 878             String type = null;
 879             String version = null;
 880             int isoStart = 0;
 881             for (Map.Entry&lt;Object, Object&gt; entry : props.entrySet()) {
 882                 String key = (String) entry.getKey();
 883                 switch (key) {
 884                     case KEY_ID:
 885                         id = (String)entry.getValue();
 886                         break;
 887                     case KEY_TYPE:
 888                         type = (String)entry.getValue();
 889                         break;
 890                     case KEY_VERSION:
 891                         version = (String)entry.getValue();
 892                         break;
 893                     case KEY_ISO_START: {
 894                         int[] ymd = parseYMD((String) entry.getValue());
 895                         isoStart = (int) LocalDate.of(ymd[0], ymd[1], ymd[2]).toEpochDay();
 896                         break;
 897                     }
 898                     default:
 899                         try {
 900                             // Everything else is either a year or invalid
 901                             int year = Integer.parseInt(key);
 902                             int[] months = parseMonths((String) entry.getValue());
 903                             years.put(year, months);
 904                             maxYear = Math.max(maxYear, year);
 905                             minYear = Math.min(minYear, year);
 906                         } catch (NumberFormatException nfe) {
 907                             throw new IllegalArgumentException(&quot;bad key: &quot; + key);
 908                         }
 909                 }
 910             }
 911 
 912             if (!getId().equals(id)) {
 913                 throw new IllegalArgumentException(&quot;Configuration is for a different calendar: &quot; + id);
 914             }
 915             if (!getCalendarType().equals(type)) {
 916                 throw new IllegalArgumentException(&quot;Configuration is for a different calendar type: &quot; + type);
 917             }
 918             if (version == null || version.isEmpty()) {
 919                 throw new IllegalArgumentException(&quot;Configuration does not contain a version&quot;);
 920             }
 921             if (isoStart == 0) {
 922                 throw new IllegalArgumentException(&quot;Configuration does not contain a ISO start date&quot;);
 923             }
 924 
 925             // Now create and validate the array of epochDays indexed by epochMonth
 926             hijrahStartEpochMonth = minYear * 12;
 927             minEpochDay = isoStart;
 928             hijrahEpochMonthStartDays = createEpochMonths(minEpochDay, minYear, maxYear, years);
 929             maxEpochDay = hijrahEpochMonthStartDays[hijrahEpochMonthStartDays.length - 1];
 930 
 931             // Compute the min and max year length in days.
 932             for (int year = minYear; year &lt; maxYear; year++) {
 933                 int length = getYearLength(year);
 934                 minYearLength = Math.min(minYearLength, length);
 935                 maxYearLength = Math.max(maxYearLength, length);
 936             }
 937         } catch (Exception ex) {
 938             // Log error and throw a DateTimeException
 939             PlatformLogger logger = PlatformLogger.getLogger(&quot;java.time.chrono&quot;);
 940             logger.severe(&quot;Unable to initialize Hijrah calendar proxy: &quot; + typeId, ex);
 941             throw new DateTimeException(&quot;Unable to initialize HijrahCalendar: &quot; + typeId, ex);
 942         }
 943     }
 944 
 945     /**
 946      * Converts the map of year to month lengths ranging from minYear to maxYear
 947      * into a linear contiguous array of epochDays. The index is the hijrahMonth
 948      * computed from year and month and offset by minYear. The value of each
 949      * entry is the epochDay corresponding to the first day of the month.
 950      *
 951      * @param minYear The minimum year for which data is provided
 952      * @param maxYear The maximum year for which data is provided
 953      * @param years a Map of year to the array of 12 month lengths
 954      * @return array of epochDays for each month from min to max
 955      */
 956     private int[] createEpochMonths(int epochDay, int minYear, int maxYear, Map&lt;Integer, int[]&gt; years) {
 957         // Compute the size for the array of dates
 958         int numMonths = (maxYear - minYear + 1) * 12 + 1;
 959 
 960         // Initialize the running epochDay as the corresponding ISO Epoch day
 961         int epochMonth = 0; // index into array of epochMonths
 962         int[] epochMonths = new int[numMonths];
 963         minMonthLength = Integer.MAX_VALUE;
 964         maxMonthLength = Integer.MIN_VALUE;
 965 
 966         // Only whole years are valid, any zero&#39;s in the array are illegal
 967         for (int year = minYear; year &lt;= maxYear; year++) {
 968             int[] months = years.get(year);// must not be gaps
 969             for (int month = 0; month &lt; 12; month++) {
 970                 int length = months[month];
 971                 epochMonths[epochMonth++] = epochDay;
 972 
 973                 if (length &lt; 29 || length &gt; 32) {
 974                     throw new IllegalArgumentException(&quot;Invalid month length in year: &quot; + minYear);
 975                 }
 976                 epochDay += length;
 977                 minMonthLength = Math.min(minMonthLength, length);
 978                 maxMonthLength = Math.max(maxMonthLength, length);
 979             }
 980         }
 981 
 982         // Insert the final epochDay
 983         epochMonths[epochMonth++] = epochDay;
 984 
 985         if (epochMonth != epochMonths.length) {
 986             throw new IllegalStateException(&quot;Did not fill epochMonths exactly: ndx = &quot; + epochMonth
 987                     + &quot; should be &quot; + epochMonths.length);
 988         }
 989 
 990         return epochMonths;
 991     }
 992 
 993     /**
 994      * Parses the 12 months lengths from a property value for a specific year.
 995      *
 996      * @param line the value of a year property
 997      * @return an array of int[12] containing the 12 month lengths
 998      * @throws IllegalArgumentException if the number of months is not 12
 999      * @throws NumberFormatException if the 12 tokens are not numbers
1000      */
1001     private int[] parseMonths(String line) {
1002         int[] months = new int[12];
1003         String[] numbers = line.split(&quot;\\s&quot;);
1004         if (numbers.length != 12) {
1005             throw new IllegalArgumentException(&quot;wrong number of months on line: &quot; + Arrays.toString(numbers) + &quot;; count: &quot; + numbers.length);
1006         }
1007         for (int i = 0; i &lt; 12; i++) {
1008             try {
1009                 months[i] = Integer.parseInt(numbers[i]);
1010             } catch (NumberFormatException nfe) {
1011                 throw new IllegalArgumentException(&quot;bad key: &quot; + numbers[i]);
1012             }
1013         }
1014         return months;
1015     }
1016 
1017     /**
1018      * Parse yyyy-MM-dd into a 3 element array [yyyy, mm, dd].
1019      *
1020      * @param string the input string
1021      * @return the 3 element array with year, month, day
1022      */
1023     private int[] parseYMD(String string) {
1024         // yyyy-MM-dd
1025         string = string.trim();
1026         try {
1027             if (string.charAt(4) != &#39;-&#39; || string.charAt(7) != &#39;-&#39;) {
1028                 throw new IllegalArgumentException(&quot;date must be yyyy-MM-dd&quot;);
1029             }
1030             int[] ymd = new int[3];
1031             ymd[0] = Integer.parseInt(string, 0, 4, 10);
1032             ymd[1] = Integer.parseInt(string, 5, 7, 10);
1033             ymd[2] = Integer.parseInt(string, 8, 10, 10);
1034             return ymd;
1035         } catch (NumberFormatException ex) {
1036             throw new IllegalArgumentException(&quot;date must be yyyy-MM-dd&quot;, ex);
1037         }
1038     }
1039 
1040     /**
1041      * Look for Hijrah chronology variant properties files in
1042      * &lt;JAVA_HOME&gt;/conf/chronology directory. Then register its chronology, if any.
1043      */
1044     private static void registerCustomChrono() {
1045         AccessController.doPrivileged(
1046             (PrivilegedAction&lt;Void&gt;)() -&gt; {
1047                 if (Files.isDirectory(CONF_PATH)) {
1048                     try {
1049                         Files.list(CONF_PATH)
1050                             .map(p -&gt; p.getFileName().toString())
1051                             .filter(fn -&gt; fn.matches(&quot;hijrah-config-[^\\.]+\\.properties&quot;))
1052                             .map(fn -&gt; fn.replaceAll(&quot;(hijrah-config-|\\.properties)&quot;, &quot;&quot;))
1053                             .forEach(idtype -&gt; {
1054                                 int delimiterPos = idtype.indexOf(&#39;_&#39;);
1055                                 // &#39;_&#39; should be somewhere in the middle of idtype
1056                                 if (delimiterPos &gt; 1 &amp;&amp; delimiterPos &lt; idtype.length() - 1) {
1057                                     AbstractChronology.registerChrono(
1058                                         new HijrahChronology(
1059                                                 idtype.substring(0, delimiterPos),
1060                                                 idtype.substring(delimiterPos + 1)));
1061                                 } else {
1062                                     PlatformLogger.getLogger(&quot;java.time.chrono&quot;)
1063                                             .warning(&quot;Hijrah custom config init failed.&quot; +
1064                                                     &quot;&#39;&lt;id&gt;_&lt;type&gt;&#39; name convention not followed: &quot; + idtype);
1065                                 }
1066                             });
1067                     } catch (IOException e) {
1068                         PlatformLogger.getLogger(&quot;java.time.chrono&quot;)
1069                                 .warning(&quot;Hijrah custom config init failed.&quot;, e);
1070                     }
1071                 }
1072                 return null;
1073             },
1074             null,
1075             new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;));
1076     }
1077 
1078     //-----------------------------------------------------------------------
1079     /**
1080      * Writes the Chronology using a
1081      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1082      * @serialData
1083      * &lt;pre&gt;
1084      *  out.writeByte(1);     // identifies a Chronology
1085      *  out.writeUTF(getId());
1086      * &lt;/pre&gt;
1087      *
1088      * @return the instance of {@code Ser}, not null
1089      */
1090     @Override
1091     @java.io.Serial
1092     Object writeReplace() {
1093         return super.writeReplace();
1094     }
1095 
1096     /**
1097      * Defend against malicious streams.
1098      *
1099      * @param s the stream to read
1100      * @throws InvalidObjectException always
1101      */
1102     @java.io.Serial
1103     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1104         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1105     }
1106 }
    </pre>
  </body>
</html>
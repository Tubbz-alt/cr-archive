<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/ImmutableCollections.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="IllformedLocaleException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputMismatchException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ImmutableCollections.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,14 ***</span>
       * A &quot;salt&quot; value used for randomizing iteration order. This is initialized once
       * and stays constant for the lifetime of the JVM. It need not be truly random, but
       * it needs to vary sufficiently from one run to the next so that iteration order
       * will vary between JVM runs.
       */
<span class="line-modified">!     static final int SALT;</span>
      static {
<span class="line-modified">!         long nt = System.nanoTime();</span>
<span class="line-modified">!         SALT = (int)((nt &gt;&gt;&gt; 32) ^ nt);</span>
      }
  
      /** No instances. */
      private ImmutableCollections() { }
  
<span class="line-new-header">--- 53,60 ---</span>
       * A &quot;salt&quot; value used for randomizing iteration order. This is initialized once
       * and stays constant for the lifetime of the JVM. It need not be truly random, but
       * it needs to vary sufficiently from one run to the next so that iteration order
       * will vary between JVM runs.
       */
<span class="line-modified">!     private static final long SALT32L;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * For set and map iteration, we will iterate in &quot;reverse&quot; stochastically,</span>
<span class="line-added">+      * decided at bootstrap time.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static final boolean REVERSE;</span>
<span class="line-added">+     static {</span>
<span class="line-added">+         // to generate a reasonably random and well-mixed SALT, use an arbitrary</span>
<span class="line-added">+         // value (a slice of pi), multiply with the System.nanoTime, then pick</span>
<span class="line-added">+         // the mid 32-bits from the product. By picking a SALT value in the</span>
<span class="line-added">+         // [0 ... 0xFFFF_FFFFL == 2^32-1] range, we ensure that for any positive</span>
<span class="line-added">+         // int N, (SALT32L * N) &gt;&gt; 32 is a number in the [0 ... N-1] range. This</span>
<span class="line-added">+         // property will be used to avoid more expensive modulo-based</span>
<span class="line-added">+         // calculations.</span>
<span class="line-added">+         long color = 0x243F_6A88_85A3_08D3L; // slice of pi</span>
<span class="line-added">+         long seed = System.nanoTime();</span>
<span class="line-added">+         SALT32L = (int)((color * seed) &gt;&gt; 16) &amp; 0xFFFF_FFFFL;</span>
<span class="line-added">+         // use the lowest bit to determine if we should reverse iteration</span>
<span class="line-added">+         REVERSE = (SALT32L &amp; 1) == 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Constants following this might be initialized from the CDS archive via</span>
<span class="line-added">+      * this array.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static Object[] archivedObjects;</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final Object EMPTY;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static final ListN&lt;?&gt; EMPTY_LIST;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static final SetN&lt;?&gt; EMPTY_SET;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static final MapN&lt;?,?&gt; EMPTY_MAP;</span>
<span class="line-added">+ </span>
      static {
<span class="line-modified">!         VM.initializeFromArchive(ImmutableCollections.class);</span>
<span class="line-modified">!         if (archivedObjects == null) {</span>
<span class="line-added">+             EMPTY = new Object();</span>
<span class="line-added">+             EMPTY_LIST = new ListN&lt;&gt;();</span>
<span class="line-added">+             EMPTY_SET = new SetN&lt;&gt;();</span>
<span class="line-added">+             EMPTY_MAP = new MapN&lt;&gt;();</span>
<span class="line-added">+             archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             EMPTY = archivedObjects[0];</span>
<span class="line-added">+             EMPTY_LIST = (ListN)archivedObjects[1];</span>
<span class="line-added">+             EMPTY_SET = (SetN)archivedObjects[2];</span>
<span class="line-added">+             EMPTY_MAP = (MapN)archivedObjects[3];</span>
<span class="line-added">+         }</span>
      }
  
      /** No instances. */
      private ImmutableCollections() { }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,15 ***</span>
          } else {
              return (List&lt;E&gt;)List.of(coll.toArray());
          }
      }
  
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     static &lt;E&gt; List&lt;E&gt; emptyList() {</span>
<span class="line-removed">-         return (List&lt;E&gt;) ListN.EMPTY_LIST;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      static abstract class AbstractImmutableList&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;
              implements List&lt;E&gt;, RandomAccess {
  
          // all mutating methods throw UnsupportedOperationException
          @Override public void    add(int index, E element) { throw uoe(); }
<span class="line-new-header">--- 139,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,62 ***</span>
  
          @Stable
          private final E e0;
  
          @Stable
<span class="line-modified">!         private final E e1;</span>
  
          List12(E e0) {
              this.e0 = Objects.requireNonNull(e0);
<span class="line-modified">!             this.e1 = null;</span>
          }
  
          List12(E e0, E e1) {
              this.e0 = Objects.requireNonNull(e0);
              this.e1 = Objects.requireNonNull(e1);
          }
  
          @Override
          public int size() {
<span class="line-modified">!             return e1 != null ? 2 : 1;</span>
          }
  
          @Override
          public E get(int index) {
              if (index == 0) {
                  return e0;
<span class="line-modified">!             } else if (index == 1 &amp;&amp; e1 != null) {</span>
<span class="line-modified">!                 return e1;</span>
              }
              throw outOfBounds(index);
          }
  
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
          private Object writeReplace() {
<span class="line-modified">!             if (e1 == null) {</span>
                  return new CollSer(CollSer.IMM_LIST, e0);
              } else {
                  return new CollSer(CollSer.IMM_LIST, e0, e1);
              }
          }
  
          @Override
          public Object[] toArray() {
<span class="line-modified">!             if (e1 == null) {</span>
                  return new Object[] { e0 };
              } else {
                  return new Object[] { e0, e1 };
              }
          }
  
          @Override
          @SuppressWarnings(&quot;unchecked&quot;)
          public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified">!             int size = e1 == null ? 1 : 2;</span>
              T[] array = a.length &gt;= size ? a :
                      (T[])Array.newInstance(a.getClass().getComponentType(), size);
              array[0] = (T)e0;
              if (size == 2) {
                  array[1] = (T)e1;
<span class="line-new-header">--- 430,72 ---</span>
  
          @Stable
          private final E e0;
  
          @Stable
<span class="line-modified">!         private final Object e1;</span>
  
          List12(E e0) {
              this.e0 = Objects.requireNonNull(e0);
<span class="line-modified">!             // Use EMPTY as a sentinel for an unused element: not using null</span>
<span class="line-added">+             // enable constant folding optimizations over single-element lists</span>
<span class="line-added">+             this.e1 = EMPTY;</span>
          }
  
          List12(E e0, E e1) {
              this.e0 = Objects.requireNonNull(e0);
              this.e1 = Objects.requireNonNull(e1);
          }
  
          @Override
          public int size() {
<span class="line-modified">!             return e1 != EMPTY ? 2 : 1;</span>
          }
  
          @Override
<span class="line-added">+         public boolean isEmpty() {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         @SuppressWarnings(&quot;unchecked&quot;)</span>
          public E get(int index) {
              if (index == 0) {
                  return e0;
<span class="line-modified">!             } else if (index == 1 &amp;&amp; e1 != EMPTY) {</span>
<span class="line-modified">!                 return (E)e1;</span>
              }
              throw outOfBounds(index);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
<span class="line-modified">!             if (e1 == EMPTY) {</span>
                  return new CollSer(CollSer.IMM_LIST, e0);
              } else {
                  return new CollSer(CollSer.IMM_LIST, e0, e1);
              }
          }
  
          @Override
          public Object[] toArray() {
<span class="line-modified">!             if (e1 == EMPTY) {</span>
                  return new Object[] { e0 };
              } else {
                  return new Object[] { e0, e1 };
              }
          }
  
          @Override
          @SuppressWarnings(&quot;unchecked&quot;)
          public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified">!             int size = size();</span>
              T[] array = a.length &gt;= size ? a :
                      (T[])Array.newInstance(a.getClass().getComponentType(), size);
              array[0] = (T)e0;
              if (size == 2) {
                  array[1] = (T)e1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,20 ***</span>
      }
  
      static final class ListN&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
              implements Serializable {
  
<span class="line-removed">-         // EMPTY_LIST may be initialized from the CDS archive.</span>
<span class="line-removed">-         static @Stable List&lt;?&gt; EMPTY_LIST;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             VM.initializeFromArchive(ListN.class);</span>
<span class="line-removed">-             if (EMPTY_LIST == null) {</span>
<span class="line-removed">-                 EMPTY_LIST = new ListN&lt;&gt;();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          @Stable
          private final E[] elements;
  
          @SafeVarargs
          ListN(E... input) {
<span class="line-new-header">--- 508,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 483,11 ***</span>
              elements = tmp;
          }
  
          @Override
          public boolean isEmpty() {
<span class="line-modified">!             return size() == 0;</span>
          }
  
          @Override
          public int size() {
              return elements.length;
<span class="line-new-header">--- 524,11 ---</span>
              elements = tmp;
          }
  
          @Override
          public boolean isEmpty() {
<span class="line-modified">!             return elements.length == 0;</span>
          }
  
          @Override
          public int size() {
              return elements.length;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,14 ***</span>
<span class="line-new-header">--- 537,16 ---</span>
          @Override
          public E get(int index) {
              return elements[index];
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
              return new CollSer(CollSer.IMM_LIST, elements);
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 554,26 ***</span>
  
          @Override
          public abstract int hashCode();
      }
  
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     static &lt;E&gt; Set&lt;E&gt; emptySet() {</span>
<span class="line-removed">-         return (Set&lt;E&gt;) SetN.EMPTY_SET;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
              implements Serializable {
  
          @Stable
<span class="line-modified">!         final E e0;</span>
          @Stable
<span class="line-modified">!         final E e1;</span>
  
          Set12(E e0) {
              this.e0 = Objects.requireNonNull(e0);
<span class="line-modified">!             this.e1 = null;</span>
          }
  
          Set12(E e0, E e1) {
              if (e0.equals(Objects.requireNonNull(e1))) { // implicit nullcheck of e0
                  throw new IllegalArgumentException(&quot;duplicate element: &quot; + e0);
<span class="line-new-header">--- 597,24 ---</span>
  
          @Override
          public abstract int hashCode();
      }
  
      static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
              implements Serializable {
  
          @Stable
<span class="line-modified">!         private final E e0;</span>
<span class="line-added">+ </span>
          @Stable
<span class="line-modified">!         private final Object e1;</span>
  
          Set12(E e0) {
              this.e0 = Objects.requireNonNull(e0);
<span class="line-modified">!             // Use EMPTY as a sentinel for an unused element: not using null</span>
<span class="line-added">+             // enable constant folding optimizations over single-element sets</span>
<span class="line-added">+             this.e1 = EMPTY;</span>
          }
  
          Set12(E e0, E e1) {
              if (e0.equals(Objects.requireNonNull(e1))) { // implicit nullcheck of e0
                  throw new IllegalArgumentException(&quot;duplicate element: &quot; + e0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,80 ***</span>
              this.e1 = e1;
          }
  
          @Override
          public int size() {
<span class="line-modified">!             return (e1 == null) ? 1 : 2;</span>
          }
  
          @Override
          public boolean contains(Object o) {
<span class="line-modified">!             return o.equals(e0) || o.equals(e1); // implicit nullcheck of o</span>
          }
  
          @Override
          public int hashCode() {
<span class="line-modified">!             return e0.hashCode() + (e1 == null ? 0 : e1.hashCode());</span>
          }
  
          @Override
          public Iterator&lt;E&gt; iterator() {
              return new Iterator&lt;&gt;() {
<span class="line-modified">!                 private int idx = size();</span>
  
                  @Override
                  public boolean hasNext() {
                      return idx &gt; 0;
                  }
  
                  @Override
                  public E next() {
                      if (idx == 1) {
                          idx = 0;
<span class="line-modified">!                         return SALT &gt;= 0 || e1 == null ? e0 : e1;</span>
                      } else if (idx == 2) {
                          idx = 1;
<span class="line-modified">!                         return SALT &gt;= 0 ? e1 : e0;</span>
                      } else {
                          throw new NoSuchElementException();
                      }
                  }
              };
          }
  
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
          private Object writeReplace() {
<span class="line-modified">!             if (e1 == null) {</span>
                  return new CollSer(CollSer.IMM_SET, e0);
              } else {
                  return new CollSer(CollSer.IMM_SET, e0, e1);
              }
          }
  
          @Override
          public Object[] toArray() {
<span class="line-modified">!             if (e1 == null) {</span>
                  return new Object[] { e0 };
<span class="line-modified">!             } else if (SALT &gt;= 0) {</span>
                  return new Object[] { e1, e0 };
              } else {
                  return new Object[] { e0, e1 };
              }
          }
  
          @Override
          @SuppressWarnings(&quot;unchecked&quot;)
          public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified">!             int size = e1 == null ? 1 : 2;</span>
              T[] array = a.length &gt;= size ? a :
                      (T[])Array.newInstance(a.getClass().getComponentType(), size);
              if (size == 1) {
                  array[0] = (T)e0;
<span class="line-modified">!             } else if (SALT &gt;= 0) {</span>
                  array[0] = (T)e1;
                  array[1] = (T)e0;
              } else {
                  array[0] = (T)e0;
                  array[1] = (T)e1;
<span class="line-new-header">--- 624,88 ---</span>
              this.e1 = e1;
          }
  
          @Override
          public int size() {
<span class="line-modified">!             return (e1 == EMPTY) ? 1 : 2;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean isEmpty() {</span>
<span class="line-added">+             return false;</span>
          }
  
          @Override
          public boolean contains(Object o) {
<span class="line-modified">!             return o.equals(e0) || e1.equals(o); // implicit nullcheck of o</span>
          }
  
          @Override
          public int hashCode() {
<span class="line-modified">!             return e0.hashCode() + (e1 == EMPTY ? 0 : e1.hashCode());</span>
          }
  
          @Override
          public Iterator&lt;E&gt; iterator() {
              return new Iterator&lt;&gt;() {
<span class="line-modified">!                 private int idx = (e1 == EMPTY) ? 1 : 2;</span>
  
                  @Override
                  public boolean hasNext() {
                      return idx &gt; 0;
                  }
  
                  @Override
<span class="line-added">+                 @SuppressWarnings(&quot;unchecked&quot;)</span>
                  public E next() {
                      if (idx == 1) {
                          idx = 0;
<span class="line-modified">!                         return (REVERSE || e1 == EMPTY) ? e0 : (E)e1;</span>
                      } else if (idx == 2) {
                          idx = 1;
<span class="line-modified">!                         return REVERSE ? (E)e1 : e0;</span>
                      } else {
                          throw new NoSuchElementException();
                      }
                  }
              };
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
<span class="line-modified">!             if (e1 == EMPTY) {</span>
                  return new CollSer(CollSer.IMM_SET, e0);
              } else {
                  return new CollSer(CollSer.IMM_SET, e0, e1);
              }
          }
  
          @Override
          public Object[] toArray() {
<span class="line-modified">!             if (e1 == EMPTY) {</span>
                  return new Object[] { e0 };
<span class="line-modified">!             } else if (REVERSE) {</span>
                  return new Object[] { e1, e0 };
              } else {
                  return new Object[] { e0, e1 };
              }
          }
  
          @Override
          @SuppressWarnings(&quot;unchecked&quot;)
          public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified">!             int size = size();</span>
              T[] array = a.length &gt;= size ? a :
                      (T[])Array.newInstance(a.getClass().getComponentType(), size);
              if (size == 1) {
                  array[0] = (T)e0;
<span class="line-modified">!             } else if (REVERSE) {</span>
                  array[0] = (T)e1;
                  array[1] = (T)e0;
              } else {
                  array[0] = (T)e0;
                  array[1] = (T)e1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,22 ***</span>
       * @param &lt;E&gt; the element type
       */
      static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
              implements Serializable {
  
<span class="line-removed">-         // EMPTY_SET may be initialized from the CDS archive.</span>
<span class="line-removed">-         static @Stable Set&lt;?&gt; EMPTY_SET;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             VM.initializeFromArchive(SetN.class);</span>
<span class="line-removed">-             if (EMPTY_SET == null) {</span>
<span class="line-removed">-                 EMPTY_SET = new SetN&lt;&gt;();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          @Stable
          final E[] elements;
          @Stable
          final int size;
  
          @SafeVarargs
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-new-header">--- 725,13 ---</span>
       * @param &lt;E&gt; the element type
       */
      static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
              implements Serializable {
  
          @Stable
          final E[] elements;
<span class="line-added">+ </span>
          @Stable
          final int size;
  
          @SafeVarargs
          @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 713,10 ***</span>
<span class="line-new-header">--- 753,15 ---</span>
          @Override
          public int size() {
              return size;
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean isEmpty() {</span>
<span class="line-added">+             return size == 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public boolean contains(Object o) {
              Objects.requireNonNull(o);
              return size &gt; 0 &amp;&amp; probe(o) &gt;= 0;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,41 ***</span>
              private int remaining;
  
              private int idx;
  
              SetNIterator() {
<span class="line-modified">!                 remaining = size();</span>
<span class="line-modified">!                 if (remaining &gt; 0) {</span>
<span class="line-modified">!                     idx = Math.floorMod(SALT, elements.length);</span>
<span class="line-modified">!                 }</span>
              }
  
              @Override
              public boolean hasNext() {
                  return remaining &gt; 0;
              }
  
<span class="line-removed">-             private int nextIndex() {</span>
<span class="line-removed">-                 int idx = this.idx;</span>
<span class="line-removed">-                 if (SALT &gt;= 0) {</span>
<span class="line-removed">-                     if (++idx &gt;= elements.length) {</span>
<span class="line-removed">-                         idx = 0;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     if (--idx &lt; 0) {</span>
<span class="line-removed">-                         idx = elements.length - 1;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return this.idx = idx;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              @Override
              public E next() {
                  if (remaining &gt; 0) {
                      E element;
<span class="line-modified">!                     // skip null elements</span>
<span class="line-modified">!                     while ((element = elements[nextIndex()]) == null) {}</span>
                      remaining--;
                      return element;
                  } else {
                      throw new NoSuchElementException();
                  }
<span class="line-new-header">--- 771,40 ---</span>
              private int remaining;
  
              private int idx;
  
              SetNIterator() {
<span class="line-modified">!                 remaining = size;</span>
<span class="line-modified">!                 // pick a starting index in the [0 .. element.length-1] range</span>
<span class="line-modified">!                 // randomly based on SALT32L</span>
<span class="line-modified">!                 idx = (int) ((SALT32L * elements.length) &gt;&gt;&gt; 32);</span>
              }
  
              @Override
              public boolean hasNext() {
                  return remaining &gt; 0;
              }
  
              @Override
              public E next() {
                  if (remaining &gt; 0) {
                      E element;
<span class="line-modified">!                     int idx = this.idx;</span>
<span class="line-modified">!                     int len = elements.length;</span>
<span class="line-added">+                     // step to the next element; skip null elements</span>
<span class="line-added">+                     do {</span>
<span class="line-added">+                         if (REVERSE) {</span>
<span class="line-added">+                             if (++idx &gt;= len) {</span>
<span class="line-added">+                                 idx = 0;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             if (--idx &lt; 0) {</span>
<span class="line-added">+                                 idx = len - 1;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } while ((element = elements[idx]) == null);</span>
<span class="line-added">+                     this.idx = idx;</span>
                      remaining--;
                      return element;
                  } else {
                      throw new NoSuchElementException();
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 799,14 ***</span>
<span class="line-new-header">--- 843,16 ---</span>
                      idx = 0;
                  }
              }
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
              Object[] array = new Object[size];
              int dest = 0;
              for (Object o : elements) {
                  if (o != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,15 ***</span>
          }
      }
  
      // ---------- Map Implementations ----------
  
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     static &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() {</span>
<span class="line-removed">-         return (Map&lt;K,V&gt;) MapN.EMPTY_MAP;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      abstract static class AbstractImmutableMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Serializable {
          @Override public void clear() { throw uoe(); }
          @Override public V compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
          @Override public V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mf) { throw uoe(); }
          @Override public V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
<span class="line-new-header">--- 888,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,10 ***</span>
<span class="line-new-header">--- 902,24 ---</span>
          @Override public V remove(Object key) { throw uoe(); }
          @Override public boolean remove(Object key, Object value) { throw uoe(); }
          @Override public V replace(K key, V value) { throw uoe(); }
          @Override public boolean replace(K key, V oldValue, V newValue) { throw uoe(); }
          @Override public void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; f) { throw uoe(); }
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * @implNote {@code null} values are disallowed in these immutable maps,</span>
<span class="line-added">+          * so we can improve upon the default implementation since a</span>
<span class="line-added">+          * {@code null} return from {@code get(key)} always means the default</span>
<span class="line-added">+          * value should be returned.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public V getOrDefault(Object key, V defaultValue) {</span>
<span class="line-added">+             V v;</span>
<span class="line-added">+             return ((v = get(key)) != null)</span>
<span class="line-added">+                     ? v</span>
<span class="line-added">+                     : defaultValue;</span>
<span class="line-added">+         }</span>
      }
  
      static final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
          @Stable
          private final K k0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 879,24 ***</span>
<span class="line-new-header">--- 934,41 ---</span>
          @Override
          public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
              return Set.of(new KeyValueHolder&lt;&gt;(k0, v0));
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public V get(Object o) {</span>
<span class="line-added">+             return o.equals(k0) ? v0 : null; // implicit nullcheck of o</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public boolean containsKey(Object o) {
              return o.equals(k0); // implicit nullcheck of o
          }
  
          @Override
          public boolean containsValue(Object o) {
              return o.equals(v0); // implicit nullcheck of o
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int size() {</span>
<span class="line-added">+             return 1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean isEmpty() {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @java.io.Serial</span>
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
              return new CollSer(CollSer.IMM_MAP, k0, v0);
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 914,20 ***</span>
       * @param &lt;K&gt; the key type
       * @param &lt;V&gt; the value type
       */
      static final class MapN&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
  
<span class="line-removed">-         // EMPTY_MAP may be initialized from the CDS archive.</span>
<span class="line-removed">-         static @Stable Map&lt;?,?&gt; EMPTY_MAP;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             VM.initializeFromArchive(MapN.class);</span>
<span class="line-removed">-             if (EMPTY_MAP == null) {</span>
<span class="line-removed">-                 EMPTY_MAP = new MapN&lt;&gt;();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          @Stable
          final Object[] table; // pairs of key, value
  
          @Stable
          final int size; // number of pairs
<span class="line-new-header">--- 986,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,31 ***</span>
          @Override
          public int size() {
              return size;
          }
  
          class MapNIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
  
              private int remaining;
  
              private int idx;
  
              MapNIterator() {
<span class="line-modified">!                 remaining = size();</span>
<span class="line-modified">!                 if (remaining &gt; 0) {</span>
<span class="line-modified">!                     idx = Math.floorMod(SALT, table.length &gt;&gt; 1) &lt;&lt; 1;</span>
<span class="line-modified">!                 }</span>
              }
  
              @Override
              public boolean hasNext() {
                  return remaining &gt; 0;
              }
  
              private int nextIndex() {
                  int idx = this.idx;
<span class="line-modified">!                 if (SALT &gt;= 0) {</span>
                      if ((idx += 2) &gt;= table.length) {
                          idx = 0;
                      }
                  } else {
                      if ((idx -= 2) &lt; 0) {
<span class="line-new-header">--- 1068,36 ---</span>
          @Override
          public int size() {
              return size;
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean isEmpty() {</span>
<span class="line-added">+             return size == 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          class MapNIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
  
              private int remaining;
  
              private int idx;
  
              MapNIterator() {
<span class="line-modified">!                 remaining = size;</span>
<span class="line-modified">!                 // pick an even starting index in the [0 .. table.length-1]</span>
<span class="line-modified">!                 // range randomly based on SALT32L</span>
<span class="line-modified">!                 idx = (int) ((SALT32L * (table.length &gt;&gt; 1)) &gt;&gt;&gt; 32) &lt;&lt; 1;</span>
              }
  
              @Override
              public boolean hasNext() {
                  return remaining &gt; 0;
              }
  
              private int nextIndex() {
                  int idx = this.idx;
<span class="line-modified">!                 if (REVERSE) {</span>
                      if ((idx += 2) &gt;= table.length) {
                          idx = 0;
                      }
                  } else {
                      if ((idx -= 2) &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,14 ***</span>
<span class="line-new-header">--- 1155,16 ---</span>
                      idx = 0;
                  }
              }
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
              throw new InvalidObjectException(&quot;not serial proxy&quot;);
          }
  
<span class="line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
              Object[] array = new Object[2 * size];
              int len = table.length;
              int dest = 0;
              for (int i = 0; i &lt; len; i += 2) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1116,10 ***</span>
<span class="line-new-header">--- 1185,11 ---</span>
   *
   * @serial
   * @since 9
   */
  final class CollSer implements Serializable {
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 6309168927139932177L;
  
      static final int IMM_LIST = 1;
      static final int IMM_SET = 2;
      static final int IMM_MAP = 3;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1176,10 ***</span>
<span class="line-new-header">--- 1246,11 ---</span>
       * @throws IOException if an I/O error occurs
       * @throws ClassNotFoundException if a serialized class cannot be loaded
       * @throws InvalidObjectException if the count is negative
       * @since 9
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
          ois.defaultReadObject();
          int len = ois.readInt();
  
          if (len &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1205,10 ***</span>
<span class="line-new-header">--- 1276,11 ---</span>
       *
       * @param oos the ObjectOutputStream to which data is written
       * @throws IOException if an I/O error occurs
       * @since 9
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream oos) throws IOException {
          oos.defaultWriteObject();
          oos.writeInt(array.length);
          for (int i = 0; i &lt; array.length; i++) {
              oos.writeObject(array[i]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1231,10 ***</span>
<span class="line-new-header">--- 1303,11 ---</span>
       * @throws InvalidObjectException if the tag value is illegal or if an exception
       *         is thrown during creation of the collection
       * @throws ObjectStreamException if another serialization error has occurred
       * @since 9
       */
<span class="line-added">+    @java.io.Serial</span>
      private Object readResolve() throws ObjectStreamException {
          try {
              if (array == null) {
                  throw new InvalidObjectException(&quot;null array&quot;);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,11 ***</span>
                      return List.of(array);
                  case IMM_SET:
                      return Set.of(array);
                  case IMM_MAP:
                      if (array.length == 0) {
<span class="line-modified">!                         return ImmutableCollections.emptyMap();</span>
                      } else if (array.length == 2) {
                          return new ImmutableCollections.Map1&lt;&gt;(array[0], array[1]);
                      } else {
                          return new ImmutableCollections.MapN&lt;&gt;(array);
                      }
<span class="line-new-header">--- 1319,11 ---</span>
                      return List.of(array);
                  case IMM_SET:
                      return Set.of(array);
                  case IMM_MAP:
                      if (array.length == 0) {
<span class="line-modified">!                         return ImmutableCollections.EMPTY_MAP;</span>
                      } else if (array.length == 2) {
                          return new ImmutableCollections.Map1&lt;&gt;(array[0], array[1]);
                      } else {
                          return new ImmutableCollections.MapN&lt;&gt;(array);
                      }
</pre>
<center><a href="IllformedLocaleException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputMismatchException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
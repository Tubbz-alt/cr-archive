<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="locks/StampedLock.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../doc-files/coll-designfaq.html.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
209  * unsynchronized collections are preferable when either
210  * collections are unshared, or are accessible only when
211  * holding other locks.
212  *
213  * &lt;p id=&quot;Weakly&quot;&gt;Most concurrent Collection implementations
214  * (including most Queues) also differ from the usual {@code java.util}
215  * conventions in that their {@linkplain java.util.Iterator Iterators}
216  * and {@linkplain java.util.Spliterator Spliterators} provide
217  * &lt;em&gt;weakly consistent&lt;/em&gt; rather than fast-fail traversal:
218  * &lt;ul&gt;
219  * &lt;li&gt;they may proceed concurrently with other operations
220  * &lt;li&gt;they will never throw {@link java.util.ConcurrentModificationException
221  * ConcurrentModificationException}
222  * &lt;li&gt;they are guaranteed to traverse elements as they existed upon
223  * construction exactly once, and may (but are not guaranteed to)
224  * reflect any modifications subsequent to construction.
225  * &lt;/ul&gt;
226  *
227  * &lt;h2 id=&quot;MemoryVisibility&quot;&gt;Memory Consistency Properties&lt;/h2&gt;
228  *
<span class="line-removed">229  * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5&quot;&gt;</span>
230  * Chapter 17 of
<span class="line-modified">231  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;&lt;/a&gt; defines the</span>
232  * &lt;i&gt;happens-before&lt;/i&gt; relation on memory operations such as reads and
233  * writes of shared variables.  The results of a write by one thread are
234  * guaranteed to be visible to a read by another thread only if the write
235  * operation &lt;i&gt;happens-before&lt;/i&gt; the read operation.  The
236  * {@code synchronized} and {@code volatile} constructs, as well as the
237  * {@code Thread.start()} and {@code Thread.join()} methods, can form
238  * &lt;i&gt;happens-before&lt;/i&gt; relationships.  In particular:
239  *
240  * &lt;ul&gt;
241  *   &lt;li&gt;Each action in a thread &lt;i&gt;happens-before&lt;/i&gt; every action in that
242  *   thread that comes later in the program&#39;s order.
243  *
244  *   &lt;li&gt;An unlock ({@code synchronized} block or method exit) of a
245  *   monitor &lt;i&gt;happens-before&lt;/i&gt; every subsequent lock ({@code synchronized}
246  *   block or method entry) of that same monitor.  And because
247  *   the &lt;i&gt;happens-before&lt;/i&gt; relation is transitive, all actions
248  *   of a thread prior to unlocking &lt;i&gt;happen-before&lt;/i&gt; all actions
249  *   subsequent to any thread locking that monitor.
250  *
251  *   &lt;li&gt;A write to a {@code volatile} field &lt;i&gt;happens-before&lt;/i&gt; every
</pre>
<hr />
<pre>
285  *   {@code CountDownLatch.countDown} &lt;i&gt;happen-before&lt;/i&gt; actions
286  *   subsequent to a successful &quot;acquiring&quot; method such as
287  *   {@code Lock.lock}, {@code Semaphore.acquire},
288  *   {@code Condition.await}, and {@code CountDownLatch.await} on the
289  *   same synchronizer object in another thread.
290  *
291  *   &lt;li&gt;For each pair of threads that successfully exchange objects via
292  *   an {@code Exchanger}, actions prior to the {@code exchange()}
293  *   in each thread &lt;i&gt;happen-before&lt;/i&gt; those subsequent to the
294  *   corresponding {@code exchange()} in another thread.
295  *
296  *   &lt;li&gt;Actions prior to calling {@code CyclicBarrier.await} and
297  *   {@code Phaser.awaitAdvance} (as well as its variants)
298  *   &lt;i&gt;happen-before&lt;/i&gt; actions performed by the barrier action, and
299  *   actions performed by the barrier action &lt;i&gt;happen-before&lt;/i&gt; actions
300  *   subsequent to a successful return from the corresponding {@code await}
301  *   in other threads.
302  *
303  * &lt;/ul&gt;
304  *


305  * @since 1.5
306  */
307 package java.util.concurrent;
</pre>
</td>
<td>
<hr />
<pre>
209  * unsynchronized collections are preferable when either
210  * collections are unshared, or are accessible only when
211  * holding other locks.
212  *
213  * &lt;p id=&quot;Weakly&quot;&gt;Most concurrent Collection implementations
214  * (including most Queues) also differ from the usual {@code java.util}
215  * conventions in that their {@linkplain java.util.Iterator Iterators}
216  * and {@linkplain java.util.Spliterator Spliterators} provide
217  * &lt;em&gt;weakly consistent&lt;/em&gt; rather than fast-fail traversal:
218  * &lt;ul&gt;
219  * &lt;li&gt;they may proceed concurrently with other operations
220  * &lt;li&gt;they will never throw {@link java.util.ConcurrentModificationException
221  * ConcurrentModificationException}
222  * &lt;li&gt;they are guaranteed to traverse elements as they existed upon
223  * construction exactly once, and may (but are not guaranteed to)
224  * reflect any modifications subsequent to construction.
225  * &lt;/ul&gt;
226  *
227  * &lt;h2 id=&quot;MemoryVisibility&quot;&gt;Memory Consistency Properties&lt;/h2&gt;
228  *

229  * Chapter 17 of
<span class="line-modified">230  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt; defines the</span>
231  * &lt;i&gt;happens-before&lt;/i&gt; relation on memory operations such as reads and
232  * writes of shared variables.  The results of a write by one thread are
233  * guaranteed to be visible to a read by another thread only if the write
234  * operation &lt;i&gt;happens-before&lt;/i&gt; the read operation.  The
235  * {@code synchronized} and {@code volatile} constructs, as well as the
236  * {@code Thread.start()} and {@code Thread.join()} methods, can form
237  * &lt;i&gt;happens-before&lt;/i&gt; relationships.  In particular:
238  *
239  * &lt;ul&gt;
240  *   &lt;li&gt;Each action in a thread &lt;i&gt;happens-before&lt;/i&gt; every action in that
241  *   thread that comes later in the program&#39;s order.
242  *
243  *   &lt;li&gt;An unlock ({@code synchronized} block or method exit) of a
244  *   monitor &lt;i&gt;happens-before&lt;/i&gt; every subsequent lock ({@code synchronized}
245  *   block or method entry) of that same monitor.  And because
246  *   the &lt;i&gt;happens-before&lt;/i&gt; relation is transitive, all actions
247  *   of a thread prior to unlocking &lt;i&gt;happen-before&lt;/i&gt; all actions
248  *   subsequent to any thread locking that monitor.
249  *
250  *   &lt;li&gt;A write to a {@code volatile} field &lt;i&gt;happens-before&lt;/i&gt; every
</pre>
<hr />
<pre>
284  *   {@code CountDownLatch.countDown} &lt;i&gt;happen-before&lt;/i&gt; actions
285  *   subsequent to a successful &quot;acquiring&quot; method such as
286  *   {@code Lock.lock}, {@code Semaphore.acquire},
287  *   {@code Condition.await}, and {@code CountDownLatch.await} on the
288  *   same synchronizer object in another thread.
289  *
290  *   &lt;li&gt;For each pair of threads that successfully exchange objects via
291  *   an {@code Exchanger}, actions prior to the {@code exchange()}
292  *   in each thread &lt;i&gt;happen-before&lt;/i&gt; those subsequent to the
293  *   corresponding {@code exchange()} in another thread.
294  *
295  *   &lt;li&gt;Actions prior to calling {@code CyclicBarrier.await} and
296  *   {@code Phaser.awaitAdvance} (as well as its variants)
297  *   &lt;i&gt;happen-before&lt;/i&gt; actions performed by the barrier action, and
298  *   actions performed by the barrier action &lt;i&gt;happen-before&lt;/i&gt; actions
299  *   subsequent to a successful return from the corresponding {@code await}
300  *   in other threads.
301  *
302  * &lt;/ul&gt;
303  *
<span class="line-added">304  * @jls 17.4.5 Happens-before Order</span>
<span class="line-added">305  *</span>
306  * @since 1.5
307  */
308 package java.util.concurrent;
</pre>
</td>
</tr>
</table>
<center><a href="locks/StampedLock.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../doc-files/coll-designfaq.html.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
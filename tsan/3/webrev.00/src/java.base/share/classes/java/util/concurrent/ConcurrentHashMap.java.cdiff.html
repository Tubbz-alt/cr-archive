<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompletableFuture.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConcurrentSkipListMap.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 383,11 ***</span>
       * either stay at same index, or move with a power of two
       * offset. We eliminate unnecessary node creation by catching
       * cases where old nodes can be reused because their next fields
       * won&#39;t change.  On average, only about one-sixth of them need
       * cloning when a table doubles. The nodes they replace will be
<span class="line-modified">!      * garbage collectable as soon as they are no longer referenced by</span>
       * any reader thread that may be in the midst of concurrently
       * traversing table.  Upon transfer, the old table bin contains
       * only a special forwarding node (with hash field &quot;MOVED&quot;) that
       * contains the next table as its key. On encountering a
       * forwarding node, access and update operations restart, using
<span class="line-new-header">--- 383,11 ---</span>
       * either stay at same index, or move with a power of two
       * offset. We eliminate unnecessary node creation by catching
       * cases where old nodes can be reused because their next fields
       * won&#39;t change.  On average, only about one-sixth of them need
       * cloning when a table doubles. The nodes they replace will be
<span class="line-modified">!      * garbage collectible as soon as they are no longer referenced by</span>
       * any reader thread that may be in the midst of concurrently
       * traversing table.  Upon transfer, the old table bin contains
       * only a special forwarding node (with hash field &quot;MOVED&quot;) that
       * contains the next table as its key. On encountering a
       * forwarding node, access and update operations restart, using
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1665,15 ***</span>
  
      /**
       * If the specified key is not already associated with a value,
       * attempts to compute its value using the given mapping function
       * and enters it into this map unless {@code null}.  The entire
<span class="line-modified">!      * method invocation is performed atomically, so the function is</span>
<span class="line-modified">!      * applied at most once per key.  Some attempted update operations</span>
<span class="line-modified">!      * on this map by other threads may be blocked while computation</span>
<span class="line-modified">!      * is in progress, so the computation should be short and simple,</span>
<span class="line-modified">!      * and must not attempt to update any other mappings of this map.</span>
       *
       * @param key key with which the specified value is to be associated
       * @param mappingFunction the function to compute a value
       * @return the current (existing or computed) value associated with
       *         the specified key, or null if the computed value is null
<span class="line-new-header">--- 1665,18 ---</span>
  
      /**
       * If the specified key is not already associated with a value,
       * attempts to compute its value using the given mapping function
       * and enters it into this map unless {@code null}.  The entire
<span class="line-modified">!      * method invocation is performed atomically.  The supplied</span>
<span class="line-modified">!      * function is invoked exactly once per invocation of this method</span>
<span class="line-modified">!      * if the key is absent, else not at all.  Some attempted update</span>
<span class="line-modified">!      * operations on this map by other threads may be blocked while</span>
<span class="line-modified">!      * computation is in progress, so the computation should be short</span>
<span class="line-added">+      * and simple.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt;The mapping function must not modify this map during computation.</span>
       *
       * @param key key with which the specified value is to be associated
       * @param mappingFunction the function to compute a value
       * @return the current (existing or computed) value associated with
       *         the specified key, or null if the computed value is null
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1776,14 ***</span>
  
      /**
       * If the value for the specified key is present, attempts to
       * compute a new mapping given the key and its current mapped
       * value.  The entire method invocation is performed atomically.
<span class="line-modified">!      * Some attempted update operations on this map by other threads</span>
<span class="line-modified">!      * may be blocked while computation is in progress, so the</span>
<span class="line-modified">!      * computation should be short and simple, and must not attempt to</span>
<span class="line-modified">!      * update any other mappings of this map.</span>
       *
       * @param key key with which a value may be associated
       * @param remappingFunction the function to compute a value
       * @return the new value associated with the specified key, or null if none
       * @throws NullPointerException if the specified key or remappingFunction
<span class="line-new-header">--- 1779,17 ---</span>
  
      /**
       * If the value for the specified key is present, attempts to
       * compute a new mapping given the key and its current mapped
       * value.  The entire method invocation is performed atomically.
<span class="line-modified">!      * The supplied function is invoked exactly once per invocation of</span>
<span class="line-modified">!      * this method if the key is present, else not at all.  Some</span>
<span class="line-modified">!      * attempted update operations on this map by other threads may be</span>
<span class="line-modified">!      * blocked while computation is in progress, so the computation</span>
<span class="line-added">+      * should be short and simple.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt;The remapping function must not modify this map during computation.</span>
       *
       * @param key key with which a value may be associated
       * @param remappingFunction the function to compute a value
       * @return the new value associated with the specified key, or null if none
       * @throws NullPointerException if the specified key or remappingFunction
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1868,14 ***</span>
  
      /**
       * Attempts to compute a mapping for the specified key and its
       * current mapped value (or {@code null} if there is no current
       * mapping). The entire method invocation is performed atomically.
<span class="line-modified">!      * Some attempted update operations on this map by other threads</span>
<span class="line-modified">!      * may be blocked while computation is in progress, so the</span>
<span class="line-modified">!      * computation should be short and simple, and must not attempt to</span>
<span class="line-modified">!      * update any other mappings of this Map.</span>
       *
       * @param key key with which the specified value is to be associated
       * @param remappingFunction the function to compute a value
       * @return the new value associated with the specified key, or null if none
       * @throws NullPointerException if the specified key or remappingFunction
<span class="line-new-header">--- 1874,16 ---</span>
  
      /**
       * Attempts to compute a mapping for the specified key and its
       * current mapped value (or {@code null} if there is no current
       * mapping). The entire method invocation is performed atomically.
<span class="line-modified">!      * The supplied function is invoked exactly once per invocation of</span>
<span class="line-modified">!      * this method.  Some attempted update operations on this map by</span>
<span class="line-modified">!      * other threads may be blocked while computation is in progress,</span>
<span class="line-modified">!      * so the computation should be short and simple.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt;The remapping function must not modify this map during computation.</span>
       *
       * @param key key with which the specified value is to be associated
       * @param remappingFunction the function to compute a value
       * @return the new value associated with the specified key, or null if none
       * @throws NullPointerException if the specified key or remappingFunction
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3284,13 ***</span>
              if (tr != null &amp;&amp; !checkInvariants(tr))
                  return false;
              return true;
          }
  
<span class="line-removed">-         private static final Unsafe U = Unsafe.getUnsafe();</span>
          private static final long LOCKSTATE
<span class="line-modified">!                 = U.objectFieldOffset(TreeBin.class, &quot;lockState&quot;);</span>
      }
  
      /* ----------------Table Traversal -------------- */
  
      /**
<span class="line-new-header">--- 3292,12 ---</span>
              if (tr != null &amp;&amp; !checkInvariants(tr))
                  return false;
              return true;
          }
  
          private static final long LOCKSTATE
<span class="line-modified">!             = U.objectFieldOffset(TreeBin.class, &quot;lockState&quot;);</span>
      }
  
      /* ----------------Table Traversal -------------- */
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4583,10 ***</span>
<span class="line-new-header">--- 4590,11 ---</span>
       * @since 1.8
       */
      public static class KeySetView&lt;K,V&gt; extends CollectionView&lt;K,V,K&gt;
          implements Set&lt;K&gt;, java.io.Serializable {
          private static final long serialVersionUID = 7249069246763182397L;
<span class="line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final V value;
          KeySetView(ConcurrentHashMap&lt;K,V&gt; map, V value) {  // non-public
              super(map);
              this.value = value;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6343,32 ***</span>
          }
      }
  
      // Unsafe mechanics
      private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">!     private static final long SIZECTL;</span>
<span class="line-modified">!     private static final long TRANSFERINDEX;</span>
<span class="line-modified">!     private static final long BASECOUNT;</span>
<span class="line-modified">!     private static final long CELLSBUSY;</span>
<span class="line-modified">!     private static final long CELLVALUE;</span>
<span class="line-modified">!     private static final int ABASE;</span>
      private static final int ASHIFT;
  
      static {
<span class="line-removed">-         SIZECTL = U.objectFieldOffset</span>
<span class="line-removed">-             (ConcurrentHashMap.class, &quot;sizeCtl&quot;);</span>
<span class="line-removed">-         TRANSFERINDEX = U.objectFieldOffset</span>
<span class="line-removed">-             (ConcurrentHashMap.class, &quot;transferIndex&quot;);</span>
<span class="line-removed">-         BASECOUNT = U.objectFieldOffset</span>
<span class="line-removed">-             (ConcurrentHashMap.class, &quot;baseCount&quot;);</span>
<span class="line-removed">-         CELLSBUSY = U.objectFieldOffset</span>
<span class="line-removed">-             (ConcurrentHashMap.class, &quot;cellsBusy&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         CELLVALUE = U.objectFieldOffset</span>
<span class="line-removed">-             (CounterCell.class, &quot;value&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ABASE = U.arrayBaseOffset(Node[].class);</span>
          int scale = U.arrayIndexScale(Node[].class);
          if ((scale &amp; (scale - 1)) != 0)
              throw new ExceptionInInitializerError(&quot;array index scale not a power of two&quot;);
          ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
  
<span class="line-new-header">--- 6351,24 ---</span>
          }
      }
  
      // Unsafe mechanics
      private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">!     private static final long SIZECTL</span>
<span class="line-modified">!         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;sizeCtl&quot;);</span>
<span class="line-modified">!     private static final long TRANSFERINDEX</span>
<span class="line-modified">!         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;transferIndex&quot;);</span>
<span class="line-modified">!     private static final long BASECOUNT</span>
<span class="line-modified">!         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;baseCount&quot;);</span>
<span class="line-added">+     private static final long CELLSBUSY</span>
<span class="line-added">+         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;cellsBusy&quot;);</span>
<span class="line-added">+     private static final long CELLVALUE</span>
<span class="line-added">+         = U.objectFieldOffset(CounterCell.class, &quot;value&quot;);</span>
<span class="line-added">+     private static final int ABASE = U.arrayBaseOffset(Node[].class);</span>
      private static final int ASHIFT;
  
      static {
          int scale = U.arrayIndexScale(Node[].class);
          if ((scale &amp; (scale - 1)) != 0)
              throw new ExceptionInInitializerError(&quot;array index scale not a power of two&quot;);
          ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
  
</pre>
<center><a href="CompletableFuture.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConcurrentSkipListMap.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
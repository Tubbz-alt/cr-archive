<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/DualPivotQuicksort.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DoubleSummaryStatistics.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DuplicateFormatFlagsException.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/DualPivotQuicksort.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,3159 +23,4139 @@</span>
   * questions.
   */
  
  package java.util;
  
<span class="udiff-line-added">+ import java.util.concurrent.CountedCompleter;</span>
<span class="udiff-line-added">+ import java.util.concurrent.RecursiveTask;</span>
<span class="udiff-line-added">+ </span>
  /**
<span class="udiff-line-modified-removed">-  * This class implements the Dual-Pivot Quicksort algorithm by</span>
<span class="udiff-line-modified-removed">-  * Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm</span>
<span class="udiff-line-modified-removed">-  * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-modified-removed">-  * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+  * This class implements powerful and fully optimized versions, both</span>
<span class="udiff-line-modified-added">+  * sequential and parallel, of the Dual-Pivot Quicksort algorithm by</span>
<span class="udiff-line-modified-added">+  * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+  * offers O(n log(n)) performance on all data sets, and is typically</span>
   * faster than traditional (one-pivot) Quicksort implementations.
   *
<span class="udiff-line-modified-removed">-  * All exposed methods are package-private, designed to be invoked</span>
<span class="udiff-line-modified-removed">-  * from public methods (in class Arrays) after performing any</span>
<span class="udiff-line-modified-removed">-  * necessary array bounds checks and expanding parameters into the</span>
<span class="udiff-line-removed">-  * required forms.</span>
<span class="udiff-line-modified-added">+  * There are also additional algorithms, invoked from the Dual-Pivot</span>
<span class="udiff-line-modified-added">+  * Quicksort, such as mixed insertion sort, merging of runs and heap</span>
<span class="udiff-line-modified-added">+  * sort, counting sort and parallel merge sort.</span>
   *
   * @author Vladimir Yaroslavskiy
   * @author Jon Bentley
   * @author Josh Bloch
<span class="udiff-line-added">+  * @author Doug Lea</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * @version 2018.08.18</span>
   *
<span class="udiff-line-modified-removed">-  * @version 2011.02.11 m765.827.12i:5\7pm</span>
<span class="udiff-line-removed">-  * @since 1.7</span>
<span class="udiff-line-modified-added">+  * @since 1.7 * 14</span>
   */
  final class DualPivotQuicksort {
  
      /**
       * Prevents instantiation.
       */
      private DualPivotQuicksort() {}
  
<span class="udiff-line-modified-removed">-     /*</span>
<span class="udiff-line-modified-removed">-      * Tuning parameters.</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Max array size to use mixed insertion sort.</span>
       */
<span class="udiff-line-added">+     private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;</span>
  
      /**
<span class="udiff-line-modified-removed">-      * The maximum number of runs in merge sort.</span>
<span class="udiff-line-modified-added">+      * Max array size to use insertion sort.</span>
       */
<span class="udiff-line-modified-removed">-     private static final int MAX_RUN_COUNT = 67;</span>
<span class="udiff-line-modified-added">+     private static final int MAX_INSERTION_SORT_SIZE = 44;</span>
  
      /**
<span class="udiff-line-modified-removed">-      * If the length of an array to be sorted is less than this</span>
<span class="udiff-line-removed">-      * constant, Quicksort is used in preference to merge sort.</span>
<span class="udiff-line-modified-added">+      * Min array size to perform sorting in parallel.</span>
       */
<span class="udiff-line-modified-removed">-     private static final int QUICKSORT_THRESHOLD = 286;</span>
<span class="udiff-line-modified-added">+     private static final int MIN_PARALLEL_SORT_SIZE = 4 &lt;&lt; 10;</span>
  
      /**
<span class="udiff-line-modified-removed">-      * If the length of an array to be sorted is less than this</span>
<span class="udiff-line-removed">-      * constant, insertion sort is used in preference to Quicksort.</span>
<span class="udiff-line-modified-added">+      * Min array size to try merging of runs.</span>
       */
<span class="udiff-line-modified-removed">-     private static final int INSERTION_SORT_THRESHOLD = 47;</span>
<span class="udiff-line-modified-added">+     private static final int MIN_TRY_MERGE_SIZE = 4 &lt;&lt; 10;</span>
  
      /**
<span class="udiff-line-modified-removed">-      * If the length of a byte array to be sorted is greater than this</span>
<span class="udiff-line-removed">-      * constant, counting sort is used in preference to insertion sort.</span>
<span class="udiff-line-modified-added">+      * Min size of the first run to continue with scanning.</span>
       */
<span class="udiff-line-modified-removed">-     private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;</span>
<span class="udiff-line-modified-added">+     private static final int MIN_FIRST_RUN_SIZE = 16;</span>
  
      /**
<span class="udiff-line-modified-removed">-      * If the length of a short or char array to be sorted is greater</span>
<span class="udiff-line-removed">-      * than this constant, counting sort is used in preference to Quicksort.</span>
<span class="udiff-line-modified-added">+      * Min factor for the first runs to continue scanning.</span>
       */
<span class="udiff-line-modified-removed">-     private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;</span>
<span class="udiff-line-modified-added">+     private static final int MIN_FIRST_RUNS_FACTOR = 7;</span>
  
<span class="udiff-line-modified-removed">-     /*</span>
<span class="udiff-line-modified-removed">-      * Sorting methods for seven primitive types.</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Max capacity of the index array for tracking runs.</span>
       */
<span class="udiff-line-added">+     private static final int MAX_RUN_CAPACITY = 5 &lt;&lt; 10;</span>
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array using the given</span>
<span class="udiff-line-modified-removed">-      * workspace array slice if possible for merging</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static void sort(int[] a, int left, int right,</span>
<span class="udiff-line-removed">-                      int[] work, int workBase, int workLen) {</span>
<span class="udiff-line-removed">-         // Use Quicksort on small arrays</span>
<span class="udiff-line-removed">-         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="udiff-line-removed">-             sort(a, left, right, true);</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+      * Min number of runs, required by parallel merging.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final int MIN_RUN_COUNT = 4;</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Index run[i] is the start of i-th run</span>
<span class="udiff-line-modified-removed">-          * (ascending or descending sequence).</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-removed">-         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="udiff-line-removed">-         int count = 0; run[0] = left;</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Min array size to use parallel merging of parts.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 &lt;&lt; 10;</span>
  
<span class="udiff-line-modified-removed">-         // Check if the array is nearly sorted</span>
<span class="udiff-line-modified-removed">-         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="udiff-line-modified-removed">-             // Equal items in the beginning of the sequence</span>
<span class="udiff-line-modified-removed">-             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="udiff-line-removed">-                 k++;</span>
<span class="udiff-line-removed">-             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="udiff-line-removed">-             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-removed">-             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-removed">-                 // Transform into an ascending sequence</span>
<span class="udiff-line-removed">-                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="udiff-line-removed">-                     int t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Min size of a byte array to use counting sort.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;</span>
  
<span class="udiff-line-modified-removed">-             // Merge a transformed descending sequence followed by an</span>
<span class="udiff-line-modified-removed">-             // ascending sequence</span>
<span class="udiff-line-modified-removed">-             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="udiff-line-modified-removed">-                 count--;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Min size of a short or char array to use counting sort.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The array is not highly structured,</span>
<span class="udiff-line-modified-removed">-              * use Quicksort instead of merge sort.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-removed">-             if (++count == MAX_RUN_COUNT) {</span>
<span class="udiff-line-removed">-                 sort(a, left, right, true);</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Threshold of mixed insertion sort is incremented by this value.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final int DELTA = 3 &lt;&lt; 1;</span>
  
<span class="udiff-line-modified-removed">-         // These invariants should hold true:</span>
<span class="udiff-line-modified-removed">-         //    run[0] = 0</span>
<span class="udiff-line-modified-removed">-         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Max recursive partitioning depth before using heap sort.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-added">+     private static final int MAX_RECURSION_DEPTH = 64 * DELTA;</span>
  
<span class="udiff-line-modified-removed">-         if (count == 0) {</span>
<span class="udiff-line-modified-removed">-             // A single equal run</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="udiff-line-modified-removed">-             // Either a single ascending or a transformed descending run.</span>
<span class="udiff-line-modified-removed">-             // Always check that a final run is a proper terminator, otherwise</span>
<span class="udiff-line-modified-removed">-             // we have an unterminated trailing run, to handle downstream.</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         right++;</span>
<span class="udiff-line-modified-removed">-         if (run[count] &lt; right) {</span>
<span class="udiff-line-modified-removed">-             // Corner case: the final run is not a terminator. This may happen</span>
<span class="udiff-line-modified-removed">-             // if a final run is an equals run, or there is a single-element run</span>
<span class="udiff-line-removed">-             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="udiff-line-removed">-             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="udiff-line-removed">-             run[++count] = right;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Determine alternation base for merge</span>
<span class="udiff-line-removed">-         byte odd = 0;</span>
<span class="udiff-line-removed">-         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use or create temporary array b for merging</span>
<span class="udiff-line-removed">-         int[] b;                 // temp array; alternates with a</span>
<span class="udiff-line-removed">-         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="udiff-line-removed">-         int blen = right - left; // space needed for b</span>
<span class="udiff-line-removed">-         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="udiff-line-removed">-             work = new int[blen];</span>
<span class="udiff-line-removed">-             workBase = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (odd == 0) {</span>
<span class="udiff-line-removed">-             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="udiff-line-removed">-             b = a;</span>
<span class="udiff-line-removed">-             bo = 0;</span>
<span class="udiff-line-removed">-             a = work;</span>
<span class="udiff-line-removed">-             ao = workBase - left;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             b = work;</span>
<span class="udiff-line-removed">-             ao = 0;</span>
<span class="udiff-line-removed">-             bo = workBase - left;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Merging</span>
<span class="udiff-line-removed">-         for (int last; count &gt; 1; count = last) {</span>
<span class="udiff-line-removed">-             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="udiff-line-removed">-                 int hi = run[k], mi = run[k - 1];</span>
<span class="udiff-line-removed">-                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="udiff-line-removed">-                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[p++ + ao];</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[q++ + ao];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 run[++last] = hi;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if ((count &amp; 1) != 0) {</span>
<span class="udiff-line-removed">-                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="udiff-line-removed">-                     b[i + bo] = a[i + ao]</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-                 run[++last] = right;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             int[] t = a; a = b; b = t;</span>
<span class="udiff-line-removed">-             int o = ao; ao = bo; bo = o;</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Calculates the double depth of parallel merging.</span>
<span class="udiff-line-modified-added">+      * Depth is negative, if tasks split before sorting.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param parallelism the parallelism level</span>
<span class="udiff-line-modified-added">+      * @param size the target size</span>
<span class="udiff-line-modified-added">+      * @return the depth of parallel merging</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static int getDepth(int parallelism, int size) {</span>
<span class="udiff-line-modified-added">+         int depth = 0;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         while ((parallelism &gt;&gt;= 3) &gt; 0 &amp;&amp; (size &gt;&gt;= 2) &gt; 0) {</span>
<span class="udiff-line-modified-added">+             depth -= 2;</span>
          }
<span class="udiff-line-added">+         return depth;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using parallel merge</span>
<span class="udiff-line-added">+      * sort and/or Dual-Pivot Quicksort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * To balance the faster splitting and parallelism of merge sort</span>
<span class="udiff-line-added">+      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="udiff-line-added">+      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="udiff-line-added">+      * the four-way parallel merge is started, still ensuring enough</span>
<span class="udiff-line-added">+      * parallelism to process the partitions.</span>
       *
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void sort(int[] a, int left, int right, boolean leftmost) {</span>
<span class="udiff-line-modified-removed">-         int length = right - left + 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use insertion sort on tiny arrays</span>
<span class="udiff-line-removed">-         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="udiff-line-removed">-             if (leftmost) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Traditional (without sentinel) insertion sort,</span>
<span class="udiff-line-removed">-                  * optimized for server VM, is used in case of</span>
<span class="udiff-line-removed">-                  * the leftmost part.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-removed">-                     int ai = a[i + 1];</span>
<span class="udiff-line-removed">-                     while (ai &lt; a[j]) {</span>
<span class="udiff-line-removed">-                         a[j + 1] = a[j];</span>
<span class="udiff-line-removed">-                         if (j-- == left) {</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[j + 1] = ai;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Skip the longest ascending sequence.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 do {</span>
<span class="udiff-line-removed">-                     if (left &gt;= right) {</span>
<span class="udiff-line-removed">-                         return;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Every element from adjoining part plays the role</span>
<span class="udiff-line-removed">-                  * of sentinel, therefore this allows us to avoid the</span>
<span class="udiff-line-removed">-                  * left range check on each iteration. Moreover, we use</span>
<span class="udiff-line-removed">-                  * the more optimized algorithm, so called pair insertion</span>
<span class="udiff-line-removed">-                  * sort, which is faster (in the context of Quicksort)</span>
<span class="udiff-line-removed">-                  * than traditional implementation of insertion sort.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="udiff-line-removed">-                     int a1 = a[k], a2 = a[left];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     if (a1 &lt; a2) {</span>
<span class="udiff-line-removed">-                         a2 = a1; a1 = a[left];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     while (a1 &lt; a[--k]) {</span>
<span class="udiff-line-removed">-                         a[k + 2] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[++k + 1] = a1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     while (a2 &lt; a[--k]) {</span>
<span class="udiff-line-removed">-                         a[k + 1] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[k + 1] = a2;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 int last = a[right];</span>
<span class="udiff-line-modified-added">+      * @param parallelism the parallelism level</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     static void sort(int[] a, int parallelism, int low, int high) {</span>
<span class="udiff-line-modified-added">+         int size = high - low;</span>
  
<span class="udiff-line-modified-removed">-                 while (last &lt; a[--right]) {</span>
<span class="udiff-line-modified-removed">-                     a[right + 1] = a[right];</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 a[right + 1] = last;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="udiff-line-modified-added">+             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="udiff-line-modified-added">+             int[] b = depth == 0 ? null : new int[size];</span>
<span class="udiff-line-modified-added">+             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             sort(null, a, 0, low, high);</span>
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // Inexpensive approximation of length / 7</span>
<span class="udiff-line-modified-removed">-         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Sort five evenly spaced elements around (and including) the</span>
<span class="udiff-line-modified-removed">-          * center element in the range. These elements will be used for</span>
<span class="udiff-line-modified-removed">-          * pivot selection as described below. The choice for spacing</span>
<span class="udiff-line-modified-removed">-          * these elements was empirically determined to work well on</span>
<span class="udiff-line-modified-removed">-          * a wide variety of inputs.</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-modified-removed">-         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="udiff-line-modified-removed">-         int e2 = e3 - seventh;</span>
<span class="udiff-line-modified-removed">-         int e1 = e2 - seventh;</span>
<span class="udiff-line-modified-removed">-         int e4 = e3 + seventh;</span>
<span class="udiff-line-removed">-         int e5 = e4 + seventh;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Sort these elements using insertion sort</span>
<span class="udiff-line-removed">-         if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="udiff-line-modified-added">+      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param sorter parallel context</span>
<span class="udiff-line-modified-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-modified-added">+      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="udiff-line-modified-added">+      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     static void sort(Sorter sorter, int[] a, int bits, int low, int high) {</span>
<span class="udiff-line-modified-added">+         while (true) {</span>
<span class="udiff-line-modified-added">+             int end = high - 1, size = high - low;</span>
  
<span class="udiff-line-modified-removed">-         if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="udiff-line-modified-added">+                 return;</span>
              }
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Invoke insertion sort on small leftmost part.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="udiff-line-modified-added">+                 insertionSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
              }
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         // Pointers</span>
<span class="udiff-line-modified-removed">-         int less  = left;  // The index of the first element of center part</span>
<span class="udiff-line-modified-removed">-         int great = right; // The index before the first element of right part</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Check if the whole array or large non-leftmost</span>
<span class="udiff-line-modified-added">+              * parts are nearly sorted and then merge runs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="udiff-line-added">+                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-removed">-         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
              /*
<span class="udiff-line-modified-removed">-              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="udiff-line-modified-removed">-              * These values are inexpensive approximations of the first and</span>
<span class="udiff-line-removed">-              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="udiff-line-modified-added">+              * Switch to heap sort if execution</span>
<span class="udiff-line-modified-added">+              * time is becoming quadratic.</span>
               */
<span class="udiff-line-modified-removed">-             int pivot1 = a[e2];</span>
<span class="udiff-line-modified-removed">-             int pivot2 = a[e4];</span>
<span class="udiff-line-modified-added">+             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="udiff-line-modified-added">+                 heapSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
              /*
<span class="udiff-line-modified-removed">-              * The first and the last elements to be sorted are moved to the</span>
<span class="udiff-line-modified-removed">-              * locations formerly occupied by the pivots. When partitioning</span>
<span class="udiff-line-removed">-              * is complete, the pivots are swapped back into their final</span>
<span class="udiff-line-removed">-              * positions, and excluded from subsequent sorting.</span>
<span class="udiff-line-modified-added">+              * Use an inexpensive approximation of the golden ratio</span>
<span class="udiff-line-modified-added">+              * to select five sample elements and determine pivots.</span>
               */
<span class="udiff-line-modified-removed">-             a[e2] = a[left];</span>
<span class="udiff-line-removed">-             a[e4] = a[right];</span>
<span class="udiff-line-modified-added">+             int step = (size &gt;&gt; 3) * 3 + 3;</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Skip elements, which are less or greater than pivot values.</span>
<span class="udiff-line-modified-added">+              * Five elements around (and including) the central element</span>
<span class="udiff-line-added">+              * will be used for pivot selection as described below. The</span>
<span class="udiff-line-added">+              * unequal choice of spacing these elements was empirically</span>
<span class="udiff-line-added">+              * determined to work well on a wide variety of inputs.</span>
               */
<span class="udiff-line-modified-removed">-             while (a[++less] &lt; pivot1);</span>
<span class="udiff-line-modified-removed">-             while (a[--great] &gt; pivot2);</span>
<span class="udiff-line-modified-added">+             int e1 = low + step;</span>
<span class="udiff-line-modified-added">+             int e5 = end - step;</span>
<span class="udiff-line-added">+             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int a3 = a[e3];</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Partitioning:</span>
<span class="udiff-line-modified-added">+              * Sort these elements in place by the combination</span>
<span class="udiff-line-added">+              * of 4-element sorting network and insertion sort.</span>
               *
<span class="udiff-line-modified-removed">-              *   left part           center part                   right part</span>
<span class="udiff-line-modified-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="udiff-line-modified-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              *               ^                          ^       ^</span>
<span class="udiff-line-modified-removed">-              *               |                          |       |</span>
<span class="udiff-line-modified-removed">-              *              less                        k     great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *              all in (left, less)   &lt; pivot1</span>
<span class="udiff-line-removed">-              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="udiff-line-removed">-              *              all in (great, right) &gt; pivot2</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+              *    5 ------o-----------o------------</span>
<span class="udiff-line-modified-added">+              *            |           |</span>
<span class="udiff-line-modified-added">+              *    4 ------|-----o-----o-----o------</span>
<span class="udiff-line-modified-added">+              *            |     |           |</span>
<span class="udiff-line-modified-added">+              *    2 ------o-----|-----o-----o------</span>
<span class="udiff-line-modified-added">+              *                  |     |</span>
<span class="udiff-line-modified-added">+              *    1 ------------o-----o------------</span>
               */
<span class="udiff-line-modified-removed">-             outer:</span>
<span class="udiff-line-modified-removed">-             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-modified-removed">-                 int ak = a[k];</span>
<span class="udiff-line-modified-removed">-                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-modified-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                     /*</span>
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="udiff-line-modified-removed">-                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-removed">-                      */</span>
<span class="udiff-line-modified-removed">-                     a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-modified-removed">-                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-modified-removed">-                     while (a[great] &gt; pivot2) {</span>
<span class="udiff-line-modified-removed">-                         if (great-- == k) {</span>
<span class="udiff-line-modified-removed">-                             break outer;</span>
<span class="udiff-line-modified-removed">-                         }</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+             if (a[e5] &lt; a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-modified-added">+             if (a[e4] &lt; a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+             if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="udiff-line-modified-added">+             if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+             if (a[e4] &lt; a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (a3 &lt; a[e2]) {</span>
<span class="udiff-line-modified-added">+                 if (a3 &lt; a[e1]) {</span>
<span class="udiff-line-modified-added">+                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="udiff-line-modified-added">+                 } else {</span>
<span class="udiff-line-modified-added">+                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+             } else if (a3 &gt; a[e4]) {</span>
<span class="udiff-line-modified-added">+                 if (a3 &gt; a[e5]) {</span>
<span class="udiff-line-modified-added">+                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="udiff-line-modified-added">+                 } else {</span>
<span class="udiff-line-modified-added">+                     a[e3] = a[e4]; a[e4] = a3;</span>
                  }
              }
  
<span class="udiff-line-modified-removed">-             // Swap pivots into their final positions</span>
<span class="udiff-line-modified-removed">-             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="udiff-line-modified-removed">-             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Sort left and right parts recursively, excluding known pivots</span>
<span class="udiff-line-removed">-             sort(a, left, less - 2, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 2, right, false);</span>
<span class="udiff-line-modified-added">+             // Pointers</span>
<span class="udiff-line-modified-added">+             int lower = low; // The index of the last element of the left part</span>
<span class="udiff-line-modified-added">+             int upper = end; // The index of the first element of the right part</span>
  
              /*
<span class="udiff-line-modified-removed">-              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="udiff-line-removed">-              * swap internal pivot values to ends.</span>
<span class="udiff-line-modified-added">+              * Partitioning with 2 pivots in case of different elements.</span>
               */
<span class="udiff-line-modified-removed">-             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="udiff-line-modified-added">+             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="udiff-line-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Skip elements, which are equal to pivot values.</span>
<span class="udiff-line-modified-added">+                  * Use the first and fifth of the five sorted elements as</span>
<span class="udiff-line-added">+                  * the pivots. These values are inexpensive approximation</span>
<span class="udiff-line-added">+                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
                   */
<span class="udiff-line-modified-removed">-                 while (a[less] == pivot1) {</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 int pivot1 = a[e1];</span>
<span class="udiff-line-modified-added">+                 int pivot2 = a[e5];</span>
  
<span class="udiff-line-modified-removed">-                 while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * The first and the last elements to be sorted are moved</span>
<span class="udiff-line-modified-added">+                  * to the locations formerly occupied by the pivots. When</span>
<span class="udiff-line-added">+                  * partitioning is completed, the pivots are swapped back</span>
<span class="udiff-line-added">+                  * into their final positions, and excluded from the next</span>
<span class="udiff-line-added">+                  * subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e1] = a[lower];</span>
<span class="udiff-line-added">+                 a[e5] = a[upper];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Skip elements, which are less or greater than the pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 while (a[++lower] &lt; pivot1);</span>
<span class="udiff-line-added">+                 while (a[--upper] &gt; pivot2);</span>
  
                  /*
<span class="udiff-line-modified-removed">-                  * Partitioning:</span>
<span class="udiff-line-modified-added">+                  * Backward 3-interval partitioning</span>
                   *
<span class="udiff-line-modified-removed">-                  *   left part         center part                  right part</span>
<span class="udiff-line-modified-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="udiff-line-modified-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-                  *              ^                        ^       ^</span>
<span class="udiff-line-modified-removed">-                  *              |                        |       |</span>
<span class="udiff-line-modified-removed">-                  *             less                      k     great</span>
<span class="udiff-line-modified-added">+                  *   left part                 central part          right part</span>
<span class="udiff-line-modified-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-modified-added">+                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="udiff-line-modified-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-modified-added">+                  *             ^       ^                            ^</span>
<span class="udiff-line-modified-added">+                  *             |       |                            |</span>
<span class="udiff-line-modified-added">+                  *           lower     k                          upper</span>
                   *
                   * Invariants:
                   *
<span class="udiff-line-modified-removed">-                  *              all in (*,  less) == pivot1</span>
<span class="udiff-line-modified-removed">-                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="udiff-line-modified-removed">-                  *              all in (great, *) == pivot2</span>
<span class="udiff-line-modified-added">+                  *              all in (low, lower] &lt; pivot1</span>
<span class="udiff-line-modified-added">+                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="udiff-line-modified-added">+                  *              all in [upper, end) &gt; pivot2</span>
                   *
<span class="udiff-line-modified-removed">-                  * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+                  * Pointer k is the last index of ?-part</span>
                   */
<span class="udiff-line-modified-removed">-                 outer:</span>
<span class="udiff-line-removed">-                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-modified-added">+                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
                      int ak = a[k];
<span class="udiff-line-modified-removed">-                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                         a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                         ++less;</span>
<span class="udiff-line-modified-removed">-                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-modified-removed">-                         while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                             if (great-- == k) {</span>
<span class="udiff-line-modified-removed">-                                 break outer;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="udiff-line-modified-added">+                         while (lower &lt; k) {</span>
<span class="udiff-line-modified-added">+                             if (a[++lower] &gt;= pivot1) {</span>
<span class="udiff-line-modified-added">+                                 if (a[lower] &gt; pivot2) {</span>
<span class="udiff-line-modified-added">+                                     a[k] = a[--upper];</span>
<span class="udiff-line-modified-added">+                                     a[upper] = a[lower];</span>
<span class="udiff-line-modified-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     a[k] = a[lower];</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 a[lower] = ak;</span>
<span class="udiff-line-added">+                                 break;</span>
                              }
                          }
<span class="udiff-line-modified-removed">-                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="udiff-line-modified-removed">-                             a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * Even though a[great] equals to pivot1, the</span>
<span class="udiff-line-removed">-                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="udiff-line-removed">-                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="udiff-line-removed">-                              * of different signs. Therefore in float and</span>
<span class="udiff-line-removed">-                              * double sorting methods we have to use more</span>
<span class="udiff-line-removed">-                              * accurate assignment a[less] = a[great].</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             a[less] = pivot1;</span>
<span class="udiff-line-removed">-                             ++less;</span>
<span class="udiff-line-removed">-                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[great];</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         a[great] = ak;</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-modified-added">+                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="udiff-line-modified-added">+                         a[k] = a[--upper];</span>
<span class="udiff-line-modified-added">+                         a[upper] = ak;</span>
                      }
                  }
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Sort center part recursively</span>
<span class="udiff-line-removed">-             sort(a, less, great, false);</span>
  
<span class="udiff-line-modified-removed">-         } else { // Partitioning with one pivot</span>
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Use the third of the five sorted elements as pivot.</span>
<span class="udiff-line-modified-removed">-              * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-removed">-             int pivot = a[e3];</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Swap the pivots into their final positions.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="udiff-line-modified-added">+                 a[end] = a[upper]; a[upper] = pivot2;</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Partitioning degenerates to the traditional 3-way</span>
<span class="udiff-line-modified-removed">-              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              *   left part    center part              right part</span>
<span class="udiff-line-modified-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="udiff-line-modified-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              *              ^              ^        ^</span>
<span class="udiff-line-modified-removed">-              *              |              |        |</span>
<span class="udiff-line-removed">-              *             less            k      great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   all in (left, less)   &lt; pivot</span>
<span class="udiff-line-removed">-              *   all in [less, k)     == pivot</span>
<span class="udiff-line-removed">-              *   all in (great, right) &gt; pivot</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             for (int k = less; k &lt;= great; ++k) {</span>
<span class="udiff-line-removed">-                 if (a[k] == pivot) {</span>
<span class="udiff-line-removed">-                     continue;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 int ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot) {</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // a[great] == pivot</span>
<span class="udiff-line-removed">-                         /*</span>
<span class="udiff-line-removed">-                          * Even though a[great] equals to pivot, the</span>
<span class="udiff-line-removed">-                          * assignment a[k] = pivot may be incorrect,</span>
<span class="udiff-line-removed">-                          * if a[great] and pivot are floating-point</span>
<span class="udiff-line-removed">-                          * zeros of different signs. Therefore in float</span>
<span class="udiff-line-removed">-                          * and double sorting methods we have to use</span>
<span class="udiff-line-removed">-                          * more accurate assignment a[k] = a[great].</span>
<span class="udiff-line-removed">-                          */</span>
<span class="udiff-line-removed">-                         a[k] = pivot;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="udiff-line-modified-added">+                  * excluding known pivots.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-modified-added">+                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="udiff-line-modified-added">+                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="udiff-line-modified-added">+                 } else {</span>
<span class="udiff-line-modified-added">+                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="udiff-line-modified-added">+                     sort(sorter, a, bits | 1, upper + 1, high);</span>
                  }
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Sort left and right parts recursively.</span>
<span class="udiff-line-removed">-              * All elements from center part are equal</span>
<span class="udiff-line-removed">-              * and, therefore, already sorted.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             sort(a, left, less - 1, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 1, right, false);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Sorts the specified range of the array using the given</span>
<span class="udiff-line-removed">-      * workspace array slice if possible for merging</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static void sort(long[] a, int left, int right,</span>
<span class="udiff-line-removed">-                      long[] work, int workBase, int workLen) {</span>
<span class="udiff-line-removed">-         // Use Quicksort on small arrays</span>
<span class="udiff-line-removed">-         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="udiff-line-removed">-             sort(a, left, right, true);</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-removed">-          * Index run[i] is the start of i-th run</span>
<span class="udiff-line-removed">-          * (ascending or descending sequence).</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="udiff-line-removed">-         int count = 0; run[0] = left;</span>
<span class="udiff-line-modified-added">+             } else { // Use single pivot in case of many equal elements</span>
  
<span class="udiff-line-modified-removed">-         // Check if the array is nearly sorted</span>
<span class="udiff-line-modified-removed">-         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="udiff-line-modified-removed">-             // Equal items in the beginning of the sequence</span>
<span class="udiff-line-modified-removed">-             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="udiff-line-modified-removed">-                 k++;</span>
<span class="udiff-line-removed">-             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="udiff-line-removed">-             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-removed">-             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-removed">-                 // Transform into an ascending sequence</span>
<span class="udiff-line-removed">-                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="udiff-line-removed">-                     long t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Use the third of the five sorted elements as the pivot.</span>
<span class="udiff-line-modified-added">+                  * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 int pivot = a[e3];</span>
  
<span class="udiff-line-modified-removed">-             // Merge a transformed descending sequence followed by an</span>
<span class="udiff-line-modified-removed">-             // ascending sequence</span>
<span class="udiff-line-modified-removed">-             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="udiff-line-modified-removed">-                 count--;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * The first element to be sorted is moved to the</span>
<span class="udiff-line-modified-added">+                  * location formerly occupied by the pivot. After</span>
<span class="udiff-line-modified-added">+                  * completion of partitioning the pivot is swapped</span>
<span class="udiff-line-modified-added">+                  * back into its final position, and excluded from</span>
<span class="udiff-line-added">+                  * the next subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e3] = a[lower];</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The array is not highly structured,</span>
<span class="udiff-line-modified-removed">-              * use Quicksort instead of merge sort.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             if (++count == MAX_RUN_COUNT) {</span>
<span class="udiff-line-modified-removed">-                 sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="udiff-line-modified-added">+                  *</span>
<span class="udiff-line-modified-added">+                  *   left part                 central part    right part</span>
<span class="udiff-line-modified-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-modified-added">+                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="udiff-line-modified-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-modified-added">+                  *              ^           ^                ^</span>
<span class="udiff-line-modified-added">+                  *              |           |                |</span>
<span class="udiff-line-added">+                  *            lower         k              upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   all in (low, lower] &lt; pivot</span>
<span class="udiff-line-added">+                  *   all in (k, upper)  == pivot</span>
<span class="udiff-line-added">+                  *   all in [upper, end] &gt; pivot</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     int ak = a[k];</span>
  
<span class="udiff-line-modified-removed">-         // These invariants should hold true:</span>
<span class="udiff-line-modified-removed">-         //    run[0] = 0</span>
<span class="udiff-line-removed">-         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
<span class="udiff-line-modified-added">+                     if (ak != pivot) {</span>
<span class="udiff-line-modified-added">+                         a[k] = pivot;</span>
  
<span class="udiff-line-modified-removed">-         if (count == 0) {</span>
<span class="udiff-line-modified-removed">-             // A single equal run</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="udiff-line-removed">-             // Either a single ascending or a transformed descending run.</span>
<span class="udiff-line-removed">-             // Always check that a final run is a proper terminator, otherwise</span>
<span class="udiff-line-removed">-             // we have an unterminated trailing run, to handle downstream.</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         right++;</span>
<span class="udiff-line-removed">-         if (run[count] &lt; right) {</span>
<span class="udiff-line-removed">-             // Corner case: the final run is not a terminator. This may happen</span>
<span class="udiff-line-removed">-             // if a final run is an equals run, or there is a single-element run</span>
<span class="udiff-line-removed">-             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="udiff-line-removed">-             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="udiff-line-removed">-             run[++count] = right;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Determine alternation base for merge</span>
<span class="udiff-line-removed">-         byte odd = 0;</span>
<span class="udiff-line-removed">-         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use or create temporary array b for merging</span>
<span class="udiff-line-removed">-         long[] b;                 // temp array; alternates with a</span>
<span class="udiff-line-removed">-         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="udiff-line-removed">-         int blen = right - left; // space needed for b</span>
<span class="udiff-line-removed">-         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="udiff-line-removed">-             work = new long[blen];</span>
<span class="udiff-line-removed">-             workBase = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (odd == 0) {</span>
<span class="udiff-line-removed">-             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="udiff-line-removed">-             b = a;</span>
<span class="udiff-line-removed">-             bo = 0;</span>
<span class="udiff-line-removed">-             a = work;</span>
<span class="udiff-line-removed">-             ao = workBase - left;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             b = work;</span>
<span class="udiff-line-removed">-             ao = 0;</span>
<span class="udiff-line-removed">-             bo = workBase - left;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Merging</span>
<span class="udiff-line-removed">-         for (int last; count &gt; 1; count = last) {</span>
<span class="udiff-line-removed">-             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="udiff-line-removed">-                 int hi = run[k], mi = run[k - 1];</span>
<span class="udiff-line-removed">-                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="udiff-line-removed">-                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[p++ + ao];</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[q++ + ao];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 run[++last] = hi;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if ((count &amp; 1) != 0) {</span>
<span class="udiff-line-removed">-                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="udiff-line-removed">-                     b[i + bo] = a[i + ao]</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-                 run[++last] = right;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             long[] t = a; a = b; b = t;</span>
<span class="udiff-line-removed">-             int o = ao; ao = bo; bo = o;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="udiff-line-modified-added">+                             while (a[++lower] &lt; pivot);</span>
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static void sort(long[] a, int left, int right, boolean leftmost) {</span>
<span class="udiff-line-removed">-         int length = right - left + 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use insertion sort on tiny arrays</span>
<span class="udiff-line-removed">-         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="udiff-line-removed">-             if (leftmost) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Traditional (without sentinel) insertion sort,</span>
<span class="udiff-line-removed">-                  * optimized for server VM, is used in case of</span>
<span class="udiff-line-removed">-                  * the leftmost part.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-removed">-                     long ai = a[i + 1];</span>
<span class="udiff-line-removed">-                     while (ai &lt; a[j]) {</span>
<span class="udiff-line-removed">-                         a[j + 1] = a[j];</span>
<span class="udiff-line-removed">-                         if (j-- == left) {</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-modified-added">+                             if (a[lower] &gt; pivot) {</span>
<span class="udiff-line-modified-added">+                                 a[--upper] = a[lower];</span>
<span class="udiff-line-modified-added">+                             }</span>
<span class="udiff-line-modified-added">+                             a[lower] = ak;</span>
<span class="udiff-line-modified-added">+                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="udiff-line-modified-added">+                             a[--upper] = ak;</span>
                          }
                      }
<span class="udiff-line-removed">-                     a[j + 1] = ai;</span>
                  }
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Skip the longest ascending sequence.</span>
<span class="udiff-line-modified-added">+                  * Swap the pivot into its final position.</span>
                   */
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-removed">-                     if (left &gt;= right) {</span>
<span class="udiff-line-removed">-                         return;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="udiff-line-modified-added">+                 a[low] = a[lower]; a[lower] = pivot;</span>
  
                  /*
<span class="udiff-line-modified-removed">-                  * Every element from adjoining part plays the role</span>
<span class="udiff-line-modified-removed">-                  * of sentinel, therefore this allows us to avoid the</span>
<span class="udiff-line-modified-removed">-                  * left range check on each iteration. Moreover, we use</span>
<span class="udiff-line-removed">-                  * the more optimized algorithm, so called pair insertion</span>
<span class="udiff-line-removed">-                  * sort, which is faster (in the context of Quicksort)</span>
<span class="udiff-line-removed">-                  * than traditional implementation of insertion sort.</span>
<span class="udiff-line-modified-added">+                  * Sort the right part (possibly in parallel), excluding</span>
<span class="udiff-line-modified-added">+                  * known pivot. All elements from the central part are</span>
<span class="udiff-line-modified-added">+                  * equal and therefore already sorted.</span>
                   */
<span class="udiff-line-modified-removed">-                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="udiff-line-modified-removed">-                     long a1 = a[k], a2 = a[left];</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-                     if (a1 &lt; a2) {</span>
<span class="udiff-line-removed">-                         a2 = a1; a1 = a[left];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     while (a1 &lt; a[--k]) {</span>
<span class="udiff-line-removed">-                         a[k + 2] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[++k + 1] = a1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     while (a2 &lt; a[--k]) {</span>
<span class="udiff-line-removed">-                         a[k + 1] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[k + 1] = a2;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 long last = a[right];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 while (last &lt; a[--right]) {</span>
<span class="udiff-line-removed">-                     a[right + 1] = a[right];</span>
<span class="udiff-line-modified-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-modified-added">+                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="udiff-line-modified-added">+                 } else {</span>
<span class="udiff-line-modified-added">+                     sort(sorter, a, bits | 1, upper, high);</span>
                  }
<span class="udiff-line-removed">-                 a[right + 1] = last;</span>
              }
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+             high = lower; // Iterate along the left part</span>
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // Inexpensive approximation of length / 7</span>
<span class="udiff-line-modified-removed">-         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Sort five evenly spaced elements around (and including) the</span>
<span class="udiff-line-modified-removed">-          * center element in the range. These elements will be used for</span>
<span class="udiff-line-modified-removed">-          * pivot selection as described below. The choice for spacing</span>
<span class="udiff-line-modified-removed">-          * these elements was empirically determined to work well on</span>
<span class="udiff-line-modified-removed">-          * a wide variety of inputs.</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-modified-removed">-         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="udiff-line-modified-removed">-         int e2 = e3 - seventh;</span>
<span class="udiff-line-modified-removed">-         int e1 = e2 - seventh;</span>
<span class="udiff-line-modified-removed">-         int e4 = e3 + seventh;</span>
<span class="udiff-line-modified-removed">-         int e5 = e4 + seventh;</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="udiff-line-modified-added">+      * pin insertion sort and pair insertion sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="udiff-line-modified-added">+      * from the left part plays the role of sentinel, because it</span>
<span class="udiff-line-modified-added">+      * is less than any elements from the given part. Therefore,</span>
<span class="udiff-line-modified-added">+      * expensive check of the left range can be skipped on each</span>
<span class="udiff-line-modified-added">+      * iteration unless it is the leftmost call.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param end the index of the last element for simple insertion sort</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void mixedInsertionSort(int[] a, int low, int end, int high) {</span>
<span class="udiff-line-added">+         if (end == high) {</span>
  
<span class="udiff-line-modified-removed">-         // Sort these elements using insertion sort</span>
<span class="udiff-line-modified-removed">-         if (a[e2] &lt; a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Invoke simple insertion sort on tiny array.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             for (int i; ++low &lt; end; ) {</span>
<span class="udiff-line-added">+                 int ai = a[i = low];</span>
  
<span class="udiff-line-modified-removed">-         if (a[e3] &lt; a[e2]) { long t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (a[e4] &lt; a[e3]) { long t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (a[e5] &lt; a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-removed">-                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+                 while (ai &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = a[i];</span>
                  }
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
              }
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Pointers</span>
<span class="udiff-line-removed">-         int less  = left;  // The index of the first element of center part</span>
<span class="udiff-line-removed">-         int great = right; // The index before the first element of right part</span>
<span class="udiff-line-modified-added">+         } else {</span>
  
<span class="udiff-line-removed">-         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
              /*
<span class="udiff-line-modified-removed">-              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="udiff-line-modified-removed">-              * These values are inexpensive approximations of the first and</span>
<span class="udiff-line-modified-removed">-              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="udiff-line-modified-added">+              * Start with pin insertion sort on small part.</span>
<span class="udiff-line-modified-added">+              *</span>
<span class="udiff-line-modified-added">+              * Pin insertion sort is extended simple insertion sort.</span>
<span class="udiff-line-added">+              * The main idea of this sort is to put elements larger</span>
<span class="udiff-line-added">+              * than an element called pin to the end of array (the</span>
<span class="udiff-line-added">+              * proper area for such elements). It avoids expensive</span>
<span class="udiff-line-added">+              * movements of these elements through the whole array.</span>
               */
<span class="udiff-line-modified-removed">-             long pivot1 = a[e2];</span>
<span class="udiff-line-removed">-             long pivot2 = a[e4];</span>
<span class="udiff-line-modified-added">+             int pin = a[end];</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The first and the last elements to be sorted are moved to the</span>
<span class="udiff-line-removed">-              * locations formerly occupied by the pivots. When partitioning</span>
<span class="udiff-line-removed">-              * is complete, the pivots are swapped back into their final</span>
<span class="udiff-line-removed">-              * positions, and excluded from subsequent sorting.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             a[e2] = a[left];</span>
<span class="udiff-line-removed">-             a[e4] = a[right];</span>
<span class="udiff-line-modified-added">+             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="udiff-line-modified-added">+                 int ai = a[i = low];</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-removed">-              * Skip elements, which are less or greater than pivot values.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             while (a[++less] &lt; pivot1);</span>
<span class="udiff-line-removed">-             while (a[--great] &gt; pivot2);</span>
<span class="udiff-line-modified-added">+                 if (ai &lt; a[i - 1]) { // Small element</span>
  
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Partitioning:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part           center part                   right part</span>
<span class="udiff-line-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="udiff-line-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-removed">-              *               ^                          ^       ^</span>
<span class="udiff-line-removed">-              *               |                          |       |</span>
<span class="udiff-line-removed">-              *              less                        k     great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *              all in (left, less)   &lt; pivot1</span>
<span class="udiff-line-removed">-              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="udiff-line-removed">-              *              all in (great, right) &gt; pivot2</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             outer:</span>
<span class="udiff-line-removed">-             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-removed">-                 long ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
                      /*
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-added">+                      * Insert small element into sorted part.</span>
                       */
<span class="udiff-line-modified-removed">-                     a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-modified-removed">-                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-modified-removed">-                     while (a[great] &gt; pivot2) {</span>
<span class="udiff-line-removed">-                         if (great-- == k) {</span>
<span class="udiff-line-removed">-                             break outer;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-modified-added">+                     a[i] = a[--i];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-modified-removed">-                         ++less;</span>
<span class="udiff-line-modified-removed">-                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = ai;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * Find element smaller than pin.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     while (a[--p] &gt; pin);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Swap it with large element.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     if (p &gt; i) {</span>
<span class="udiff-line-added">+                         ai = a[p];</span>
<span class="udiff-line-added">+                         a[p] = a[i];</span>
                      }
<span class="udiff-line-added">+ </span>
                      /*
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-added">+                      * Insert small element into sorted part.</span>
                       */
<span class="udiff-line-modified-removed">-                     a[great] = ak;</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = ai;</span>
                  }
              }
  
<span class="udiff-line-removed">-             // Swap pivots into their final positions</span>
<span class="udiff-line-removed">-             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="udiff-line-removed">-             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Sort left and right parts recursively, excluding known pivots</span>
<span class="udiff-line-removed">-             sort(a, left, less - 2, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 2, right, false);</span>
<span class="udiff-line-removed">- </span>
              /*
<span class="udiff-line-modified-removed">-              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="udiff-line-removed">-              * swap internal pivot values to ends.</span>
<span class="udiff-line-modified-added">+              * Continue with pair insertion sort on remain part.</span>
               */
<span class="udiff-line-modified-removed">-             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="udiff-line-modified-added">+             for (int i; low &lt; high; ++low) {</span>
<span class="udiff-line-added">+                 int a1 = a[i = low], a2 = a[++low];</span>
<span class="udiff-line-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Skip elements, which are equal to pivot values.</span>
<span class="udiff-line-modified-added">+                  * Insert two elements per iteration: at first, insert the</span>
<span class="udiff-line-added">+                  * larger element and then insert the smaller element, but</span>
<span class="udiff-line-added">+                  * from the position where the larger element was inserted.</span>
                   */
<span class="udiff-line-modified-removed">-                 while (a[less] == pivot1) {</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 if (a1 &gt; a2) {</span>
  
<span class="udiff-line-modified-removed">-                 while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 2] = a[i];</span>
<span class="udiff-line-modified-added">+                     }</span>
<span class="udiff-line-added">+                     a[++i + 1] = a1;</span>
  
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Partitioning:</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  *   left part         center part                  right part</span>
<span class="udiff-line-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-removed">-                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="udiff-line-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-removed">-                  *              ^                        ^       ^</span>
<span class="udiff-line-removed">-                  *              |                        |       |</span>
<span class="udiff-line-removed">-                  *             less                      k     great</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Invariants:</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  *              all in (*,  less) == pivot1</span>
<span class="udiff-line-removed">-                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="udiff-line-removed">-                  *              all in (great, *) == pivot2</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 outer:</span>
<span class="udiff-line-removed">-                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-removed">-                     long ak = a[k];</span>
<span class="udiff-line-removed">-                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = ak;</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                         while (a[great] == pivot2) {</span>
<span class="udiff-line-removed">-                             if (great-- == k) {</span>
<span class="udiff-line-removed">-                                 break outer;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[less];</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * Even though a[great] equals to pivot1, the</span>
<span class="udiff-line-removed">-                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="udiff-line-removed">-                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="udiff-line-removed">-                              * of different signs. Therefore in float and</span>
<span class="udiff-line-removed">-                              * double sorting methods we have to use more</span>
<span class="udiff-line-removed">-                              * accurate assignment a[less] = a[great].</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             a[less] = pivot1;</span>
<span class="udiff-line-removed">-                             ++less;</span>
<span class="udiff-line-removed">-                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[great];</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         a[great] = ak;</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-modified-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = a2;</span>
  
<span class="udiff-line-modified-removed">-             // Sort center part recursively</span>
<span class="udiff-line-removed">-             sort(a, less, great, false);</span>
<span class="udiff-line-modified-added">+                 } else if (a1 &lt; a[i - 1]) {</span>
  
<span class="udiff-line-modified-removed">-         } else { // Partitioning with one pivot</span>
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-removed">-              * Use the third of the five sorted elements as pivot.</span>
<span class="udiff-line-removed">-              * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             long pivot = a[e3];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Partitioning degenerates to the traditional 3-way</span>
<span class="udiff-line-removed">-              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part    center part              right part</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              *              ^              ^        ^</span>
<span class="udiff-line-removed">-              *              |              |        |</span>
<span class="udiff-line-removed">-              *             less            k      great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   all in (left, less)   &lt; pivot</span>
<span class="udiff-line-removed">-              *   all in [less, k)     == pivot</span>
<span class="udiff-line-removed">-              *   all in (great, right) &gt; pivot</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             for (int k = less; k &lt;= great; ++k) {</span>
<span class="udiff-line-removed">-                 if (a[k] == pivot) {</span>
<span class="udiff-line-removed">-                     continue;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 long ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot) {</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-modified-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 2] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-modified-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // a[great] == pivot</span>
<span class="udiff-line-removed">-                         /*</span>
<span class="udiff-line-removed">-                          * Even though a[great] equals to pivot, the</span>
<span class="udiff-line-removed">-                          * assignment a[k] = pivot may be incorrect,</span>
<span class="udiff-line-removed">-                          * if a[great] and pivot are floating-point</span>
<span class="udiff-line-removed">-                          * zeros of different signs. Therefore in float</span>
<span class="udiff-line-removed">-                          * and double sorting methods we have to use</span>
<span class="udiff-line-removed">-                          * more accurate assignment a[k] = a[great].</span>
<span class="udiff-line-removed">-                          */</span>
<span class="udiff-line-removed">-                         a[k] = pivot;</span>
<span class="udiff-line-modified-added">+                     a[++i + 1] = a2;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = a1;</span>
                  }
              }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Sort left and right parts recursively.</span>
<span class="udiff-line-removed">-              * All elements from center part are equal</span>
<span class="udiff-line-removed">-              * and, therefore, already sorted.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             sort(a, left, less - 1, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 1, right, false);</span>
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array using the given</span>
<span class="udiff-line-removed">-      * workspace array slice if possible for merging</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using insertion sort.</span>
       *
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-removed">-     static void sort(short[] a, int left, int right,</span>
<span class="udiff-line-removed">-                      short[] work, int workBase, int workLen) {</span>
<span class="udiff-line-removed">-         // Use counting sort on large arrays</span>
<span class="udiff-line-removed">-         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {</span>
<span class="udiff-line-removed">-             int[] count = new int[NUM_SHORT_VALUES];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             for (int i = left - 1; ++i &lt;= right;</span>
<span class="udiff-line-removed">-                 count[a[i] - Short.MIN_VALUE]++</span>
<span class="udiff-line-removed">-             );</span>
<span class="udiff-line-removed">-             for (int i = NUM_SHORT_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="udiff-line-removed">-                 while (count[--i] == 0);</span>
<span class="udiff-line-removed">-                 short value = (short) (i + Short.MIN_VALUE);</span>
<span class="udiff-line-removed">-                 int s = count[i];</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void insertionSort(int[] a, int low, int high) {</span>
<span class="udiff-line-modified-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-modified-added">+             int ai = a[i = k];</span>
  
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     a[--k] = value;</span>
<span class="udiff-line-modified-removed">-                 } while (--s &gt; 0);</span>
<span class="udiff-line-modified-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-modified-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
              }
<span class="udiff-line-removed">-         } else { // Use Dual-Pivot Quicksort on small arrays</span>
<span class="udiff-line-removed">-             doSort(a, left, right, work, workBase, workLen);</span>
          }
      }
  
<span class="udiff-line-removed">-     /** The number of distinct short values. */</span>
<span class="udiff-line-removed">-     private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span>
<span class="udiff-line-removed">- </span>
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array.</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using heap sort.</span>
       *
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-removed">-     private static void doSort(short[] a, int left, int right,</span>
<span class="udiff-line-removed">-                                short[] work, int workBase, int workLen) {</span>
<span class="udiff-line-removed">-         // Use Quicksort on small arrays</span>
<span class="udiff-line-removed">-         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="udiff-line-removed">-             sort(a, left, right, true);</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void heapSort(int[] a, int low, int high) {</span>
<span class="udiff-line-modified-added">+         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="udiff-line-modified-added">+             pushDown(a, --k, a[k], low, high);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Index run[i] is the start of i-th run</span>
<span class="udiff-line-modified-removed">-          * (ascending or descending sequence).</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="udiff-line-removed">-         int count = 0; run[0] = left;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Check if the array is nearly sorted</span>
<span class="udiff-line-removed">-         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="udiff-line-removed">-             // Equal items in the beginning of the sequence</span>
<span class="udiff-line-removed">-             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="udiff-line-removed">-                 k++;</span>
<span class="udiff-line-removed">-             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="udiff-line-removed">-             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-removed">-             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-removed">-                 // Transform into an ascending sequence</span>
<span class="udiff-line-removed">-                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="udiff-line-removed">-                     short t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Merge a transformed descending sequence followed by an</span>
<span class="udiff-line-removed">-             // ascending sequence</span>
<span class="udiff-line-removed">-             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="udiff-line-removed">-                 count--;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * The array is not highly structured,</span>
<span class="udiff-line-removed">-              * use Quicksort instead of merge sort.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             if (++count == MAX_RUN_COUNT) {</span>
<span class="udiff-line-removed">-                 sort(a, left, right, true);</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         while (--high &gt; low) {</span>
<span class="udiff-line-modified-added">+             int max = a[low];</span>
<span class="udiff-line-modified-added">+             pushDown(a, low, a[high], low, high);</span>
<span class="udiff-line-modified-added">+             a[high] = max;</span>
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // These invariants should hold true:</span>
<span class="udiff-line-modified-removed">-         //    run[0] = 0</span>
<span class="udiff-line-modified-removed">-         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Pushes specified element down during heap sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-added">+      * @param a the given array</span>
<span class="udiff-line-added">+      * @param p the start index</span>
<span class="udiff-line-added">+      * @param value the given element</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void pushDown(int[] a, int p, int value, int low, int high) {</span>
<span class="udiff-line-added">+         for (int k ;; a[p] = a[p = k]) {</span>
<span class="udiff-line-added">+             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
  
<span class="udiff-line-modified-removed">-         if (count == 0) {</span>
<span class="udiff-line-modified-removed">-             // A single equal run</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="udiff-line-removed">-             // Either a single ascending or a transformed descending run.</span>
<span class="udiff-line-removed">-             // Always check that a final run is a proper terminator, otherwise</span>
<span class="udiff-line-removed">-             // we have an unterminated trailing run, to handle downstream.</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         right++;</span>
<span class="udiff-line-removed">-         if (run[count] &lt; right) {</span>
<span class="udiff-line-removed">-             // Corner case: the final run is not a terminator. This may happen</span>
<span class="udiff-line-removed">-             // if a final run is an equals run, or there is a single-element run</span>
<span class="udiff-line-removed">-             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="udiff-line-removed">-             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="udiff-line-removed">-             run[++count] = right;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Determine alternation base for merge</span>
<span class="udiff-line-removed">-         byte odd = 0;</span>
<span class="udiff-line-removed">-         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use or create temporary array b for merging</span>
<span class="udiff-line-removed">-         short[] b;                 // temp array; alternates with a</span>
<span class="udiff-line-removed">-         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="udiff-line-removed">-         int blen = right - left; // space needed for b</span>
<span class="udiff-line-removed">-         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="udiff-line-removed">-             work = new short[blen];</span>
<span class="udiff-line-removed">-             workBase = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (odd == 0) {</span>
<span class="udiff-line-removed">-             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="udiff-line-removed">-             b = a;</span>
<span class="udiff-line-removed">-             bo = 0;</span>
<span class="udiff-line-removed">-             a = work;</span>
<span class="udiff-line-removed">-             ao = workBase - left;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             b = work;</span>
<span class="udiff-line-removed">-             ao = 0;</span>
<span class="udiff-line-removed">-             bo = workBase - left;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Merging</span>
<span class="udiff-line-removed">-         for (int last; count &gt; 1; count = last) {</span>
<span class="udiff-line-removed">-             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="udiff-line-removed">-                 int hi = run[k], mi = run[k - 1];</span>
<span class="udiff-line-removed">-                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="udiff-line-removed">-                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[p++ + ao];</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[q++ + ao];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 run[++last] = hi;</span>
<span class="udiff-line-modified-added">+             if (k &gt; high) {</span>
<span class="udiff-line-modified-added">+                 break;</span>
              }
<span class="udiff-line-modified-removed">-             if ((count &amp; 1) != 0) {</span>
<span class="udiff-line-modified-removed">-                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="udiff-line-modified-removed">-                     b[i + bo] = a[i + ao]</span>
<span class="udiff-line-modified-removed">-                 );</span>
<span class="udiff-line-modified-removed">-                 run[++last] = right;</span>
<span class="udiff-line-modified-added">+             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="udiff-line-modified-added">+                 --k;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             if (a[k] &lt;= value) {</span>
<span class="udiff-line-modified-added">+                 break;</span>
              }
<span class="udiff-line-removed">-             short[] t = a; a = b; b = t;</span>
<span class="udiff-line-removed">-             int o = ao; ao = bo; bo = o;</span>
          }
<span class="udiff-line-added">+         a[p] = value;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="udiff-line-modified-added">+      * Tries to sort the specified range of the array.</span>
       *
<span class="udiff-line-added">+      * @param sorter parallel context</span>
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void sort(short[] a, int left, int right, boolean leftmost) {</span>
<span class="udiff-line-removed">-         int length = right - left + 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use insertion sort on tiny arrays</span>
<span class="udiff-line-removed">-         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="udiff-line-removed">-             if (leftmost) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Traditional (without sentinel) insertion sort,</span>
<span class="udiff-line-removed">-                  * optimized for server VM, is used in case of</span>
<span class="udiff-line-removed">-                  * the leftmost part.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-removed">-                     short ai = a[i + 1];</span>
<span class="udiff-line-removed">-                     while (ai &lt; a[j]) {</span>
<span class="udiff-line-removed">-                         a[j + 1] = a[j];</span>
<span class="udiff-line-removed">-                         if (j-- == left) {</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[j + 1] = ai;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Skip the longest ascending sequence.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 do {</span>
<span class="udiff-line-removed">-                     if (left &gt;= right) {</span>
<span class="udiff-line-removed">-                         return;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element to be sorted</span>
<span class="udiff-line-modified-added">+      * @param size the array size</span>
<span class="udiff-line-modified-added">+      * @return true if finally sorted, false otherwise</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {</span>
  
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Every element from adjoining part plays the role</span>
<span class="udiff-line-modified-removed">-                  * of sentinel, therefore this allows us to avoid the</span>
<span class="udiff-line-modified-removed">-                  * left range check on each iteration. Moreover, we use</span>
<span class="udiff-line-modified-removed">-                  * the more optimized algorithm, so called pair insertion</span>
<span class="udiff-line-modified-removed">-                  * sort, which is faster (in the context of Quicksort)</span>
<span class="udiff-line-modified-removed">-                  * than traditional implementation of insertion sort.</span>
<span class="udiff-line-modified-removed">-                  */</span>
<span class="udiff-line-removed">-                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="udiff-line-removed">-                     short a1 = a[k], a2 = a[left];</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * The run array is constructed only if initial runs are</span>
<span class="udiff-line-modified-added">+          * long enough to continue, run[i] then holds start index</span>
<span class="udiff-line-modified-added">+          * of the i-th sequence of elements in non-descending order.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         int[] run = null;</span>
<span class="udiff-line-modified-added">+         int high = low + size;</span>
<span class="udiff-line-modified-added">+         int count = 1, last = low;</span>
  
<span class="udiff-line-modified-removed">-                     if (a1 &lt; a2) {</span>
<span class="udiff-line-modified-removed">-                         a2 = a1; a1 = a[left];</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     while (a1 &lt; a[--k]) {</span>
<span class="udiff-line-removed">-                         a[k + 2] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[++k + 1] = a1;</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Identify all possible runs.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         for (int k = low + 1; k &lt; high; ) {</span>
  
<span class="udiff-line-modified-removed">-                     while (a2 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 1] = a[k];</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     a[k + 1] = a2;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 short last = a[right];</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Find the end index of the current run.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (a[k - 1] &lt; a[k]) {</span>
  
<span class="udiff-line-modified-removed">-                 while (last &lt; a[--right]) {</span>
<span class="udiff-line-modified-removed">-                     a[right + 1] = a[right];</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 a[right + 1] = last;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+                 // Identify ascending sequence</span>
<span class="udiff-line-modified-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
  
<span class="udiff-line-modified-removed">-         // Inexpensive approximation of length / 7</span>
<span class="udiff-line-removed">-         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="udiff-line-modified-added">+             } else if (a[k - 1] &gt; a[k]) {</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Sort five evenly spaced elements around (and including) the</span>
<span class="udiff-line-removed">-          * center element in the range. These elements will be used for</span>
<span class="udiff-line-removed">-          * pivot selection as described below. The choice for spacing</span>
<span class="udiff-line-removed">-          * these elements was empirically determined to work well on</span>
<span class="udiff-line-removed">-          * a wide variety of inputs.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="udiff-line-removed">-         int e2 = e3 - seventh;</span>
<span class="udiff-line-removed">-         int e1 = e2 - seventh;</span>
<span class="udiff-line-removed">-         int e4 = e3 + seventh;</span>
<span class="udiff-line-removed">-         int e5 = e4 + seventh;</span>
<span class="udiff-line-modified-added">+                 // Identify descending sequence</span>
<span class="udiff-line-modified-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
  
<span class="udiff-line-modified-removed">-         // Sort these elements using insertion sort</span>
<span class="udiff-line-modified-removed">-         if (a[e2] &lt; a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+                 // Reverse into ascending order</span>
<span class="udiff-line-modified-added">+                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="udiff-line-added">+                     int ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else { // Identify constant sequence</span>
<span class="udiff-line-added">+                 for (int ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
  
<span class="udiff-line-modified-removed">-         if (a[e3] &lt; a[e2]) { short t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (a[e4] &lt; a[e3]) { short t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (a[e5] &lt; a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-removed">-                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+                 if (k &lt; high) {</span>
<span class="udiff-line-modified-added">+                     continue;</span>
                  }
              }
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Pointers</span>
<span class="udiff-line-removed">-         int less  = left;  // The index of the first element of center part</span>
<span class="udiff-line-removed">-         int great = right; // The index before the first element of right part</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="udiff-line-removed">-              * These values are inexpensive approximations of the first and</span>
<span class="udiff-line-removed">-              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             short pivot1 = a[e2];</span>
<span class="udiff-line-removed">-             short pivot2 = a[e4];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * The first and the last elements to be sorted are moved to the</span>
<span class="udiff-line-removed">-              * locations formerly occupied by the pivots. When partitioning</span>
<span class="udiff-line-removed">-              * is complete, the pivots are swapped back into their final</span>
<span class="udiff-line-removed">-              * positions, and excluded from subsequent sorting.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             a[e2] = a[left];</span>
<span class="udiff-line-removed">-             a[e4] = a[right];</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Skip elements, which are less or greater than pivot values.</span>
<span class="udiff-line-modified-added">+              * Check special cases.</span>
               */
<span class="udiff-line-modified-removed">-             while (a[++less] &lt; pivot1);</span>
<span class="udiff-line-modified-removed">-             while (a[--great] &gt; pivot2);</span>
<span class="udiff-line-modified-added">+             if (run == null) {</span>
<span class="udiff-line-modified-added">+                 if (k == high) {</span>
  
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Partitioning:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part           center part                   right part</span>
<span class="udiff-line-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="udiff-line-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-removed">-              *               ^                          ^       ^</span>
<span class="udiff-line-removed">-              *               |                          |       |</span>
<span class="udiff-line-removed">-              *              less                        k     great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *              all in (left, less)   &lt; pivot1</span>
<span class="udiff-line-removed">-              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="udiff-line-removed">-              *              all in (great, right) &gt; pivot2</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             outer:</span>
<span class="udiff-line-removed">-             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-removed">-                 short ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
                      /*
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="udiff-line-modified-removed">-                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-added">+                      * The array is monotonous sequence,</span>
<span class="udiff-line-modified-added">+                      * and therefore already sorted.</span>
                       */
<span class="udiff-line-modified-removed">-                     a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-modified-removed">-                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-modified-removed">-                     while (a[great] &gt; pivot2) {</span>
<span class="udiff-line-modified-removed">-                         if (great-- == k) {</span>
<span class="udiff-line-removed">-                             break outer;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-modified-added">+                     return true;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="udiff-line-modified-added">+ </span>
                      /*
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="udiff-line-modified-removed">-                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-added">+                      * The first run is too small</span>
<span class="udiff-line-modified-added">+                      * to proceed with scanning.</span>
                       */
<span class="udiff-line-modified-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     return false;</span>
                  }
<span class="udiff-line-removed">-             }</span>
  
<span class="udiff-line-modified-removed">-             // Swap pivots into their final positions</span>
<span class="udiff-line-modified-removed">-             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="udiff-line-removed">-             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="udiff-line-modified-added">+                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="udiff-line-modified-added">+                 run[0] = low;</span>
  
<span class="udiff-line-modified-removed">-             // Sort left and right parts recursively, excluding known pivots</span>
<span class="udiff-line-removed">-             sort(a, left, less - 2, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 2, right, false);</span>
<span class="udiff-line-modified-added">+             } else if (a[last - 1] &gt; a[last]) {</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-removed">-              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="udiff-line-removed">-              * swap internal pivot values to ends.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Skip elements, which are equal to pivot values.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 while (a[less] == pivot1) {</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
  
<span class="udiff-line-modified-removed">-                 while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * The first runs are not long</span>
<span class="udiff-line-added">+                      * enough to continue scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
                  }
  
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Partitioning:</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  *   left part         center part                  right part</span>
<span class="udiff-line-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-removed">-                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="udiff-line-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-removed">-                  *              ^                        ^       ^</span>
<span class="udiff-line-removed">-                  *              |                        |       |</span>
<span class="udiff-line-removed">-                  *             less                      k     great</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Invariants:</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  *              all in (*,  less) == pivot1</span>
<span class="udiff-line-removed">-                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="udiff-line-removed">-                  *              all in (great, *) == pivot2</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 outer:</span>
<span class="udiff-line-removed">-                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-removed">-                     short ak = a[k];</span>
<span class="udiff-line-removed">-                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = ak;</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                         while (a[great] == pivot2) {</span>
<span class="udiff-line-removed">-                             if (great-- == k) {</span>
<span class="udiff-line-removed">-                                 break outer;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[less];</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * Even though a[great] equals to pivot1, the</span>
<span class="udiff-line-removed">-                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="udiff-line-removed">-                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="udiff-line-removed">-                              * of different signs. Therefore in float and</span>
<span class="udiff-line-removed">-                              * double sorting methods we have to use more</span>
<span class="udiff-line-removed">-                              * accurate assignment a[less] = a[great].</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             a[less] = pivot1;</span>
<span class="udiff-line-removed">-                             ++less;</span>
<span class="udiff-line-removed">-                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[great];</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         a[great] = ak;</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+                 if (++count == MAX_RUN_CAPACITY) {</span>
  
<span class="udiff-line-modified-removed">-             // Sort center part recursively</span>
<span class="udiff-line-modified-removed">-             sort(a, less, great, false);</span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * Array is not highly structured.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
  
<span class="udiff-line-modified-removed">-         } else { // Partitioning with one pivot</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Use the third of the five sorted elements as pivot.</span>
<span class="udiff-line-removed">-              * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             short pivot = a[e3];</span>
<span class="udiff-line-modified-added">+                 if (count == run.length) {</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Partitioning degenerates to the traditional 3-way</span>
<span class="udiff-line-modified-removed">-              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part    center part              right part</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              *              ^              ^        ^</span>
<span class="udiff-line-removed">-              *              |              |        |</span>
<span class="udiff-line-removed">-              *             less            k      great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   all in (left, less)   &lt; pivot</span>
<span class="udiff-line-removed">-              *   all in [less, k)     == pivot</span>
<span class="udiff-line-removed">-              *   all in (great, right) &gt; pivot</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             for (int k = less; k &lt;= great; ++k) {</span>
<span class="udiff-line-removed">-                 if (a[k] == pivot) {</span>
<span class="udiff-line-removed">-                     continue;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 short ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot) {</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // a[great] == pivot</span>
<span class="udiff-line-removed">-                         /*</span>
<span class="udiff-line-removed">-                          * Even though a[great] equals to pivot, the</span>
<span class="udiff-line-removed">-                          * assignment a[k] = pivot may be incorrect,</span>
<span class="udiff-line-removed">-                          * if a[great] and pivot are floating-point</span>
<span class="udiff-line-removed">-                          * zeros of different signs. Therefore in float</span>
<span class="udiff-line-removed">-                          * and double sorting methods we have to use</span>
<span class="udiff-line-removed">-                          * more accurate assignment a[k] = a[great].</span>
<span class="udiff-line-removed">-                          */</span>
<span class="udiff-line-removed">-                         a[k] = pivot;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * Increase capacity of index array.</span>
<span class="udiff-line-modified-added">+                      */</span>
<span class="udiff-line-modified-added">+                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
                  }
              }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Sort left and right parts recursively.</span>
<span class="udiff-line-removed">-              * All elements from center part are equal</span>
<span class="udiff-line-removed">-              * and, therefore, already sorted.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             sort(a, left, less - 1, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 1, right, false);</span>
<span class="udiff-line-modified-added">+             run[count] = (last = k);</span>
          }
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array using the given</span>
<span class="udiff-line-modified-removed">-      * workspace array slice if possible for merging</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static void sort(char[] a, int left, int right,</span>
<span class="udiff-line-removed">-                      char[] work, int workBase, int workLen) {</span>
<span class="udiff-line-removed">-         // Use counting sort on large arrays</span>
<span class="udiff-line-removed">-         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {</span>
<span class="udiff-line-removed">-             int[] count = new int[NUM_CHAR_VALUES];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             for (int i = left - 1; ++i &lt;= right;</span>
<span class="udiff-line-removed">-                 count[a[i]]++</span>
<span class="udiff-line-removed">-             );</span>
<span class="udiff-line-removed">-             for (int i = NUM_CHAR_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="udiff-line-removed">-                 while (count[--i] == 0);</span>
<span class="udiff-line-removed">-                 char value = (char) i;</span>
<span class="udiff-line-removed">-                 int s = count[i];</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Merge runs of highly structured array.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         if (count &gt; 1) {</span>
<span class="udiff-line-modified-added">+             int[] b; int offset = low;</span>
  
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     a[--k] = value;</span>
<span class="udiff-line-modified-removed">-                 } while (--s &gt; 0);</span>
<span class="udiff-line-modified-added">+             if (sorter == null || (b = (int[]) sorter.b) == null) {</span>
<span class="udiff-line-modified-added">+                 b = new int[size];</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-added">+                 offset = sorter.offset;</span>
              }
<span class="udiff-line-modified-removed">-         } else { // Use Dual-Pivot Quicksort on small arrays</span>
<span class="udiff-line-removed">-             doSort(a, left, right, work, workBase, workLen);</span>
<span class="udiff-line-modified-added">+             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
          }
<span class="udiff-line-added">+         return true;</span>
      }
  
<span class="udiff-line-removed">-     /** The number of distinct char values. */</span>
<span class="udiff-line-removed">-     private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span>
<span class="udiff-line-removed">- </span>
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array.</span>
<span class="udiff-line-modified-added">+      * Merges the specified runs.</span>
       *
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void doSort(char[] a, int left, int right,</span>
<span class="udiff-line-modified-removed">-                                char[] work, int workBase, int workLen) {</span>
<span class="udiff-line-modified-removed">-         // Use Quicksort on small arrays</span>
<span class="udiff-line-modified-removed">-         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="udiff-line-modified-removed">-             sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+      * @param a the source array</span>
<span class="udiff-line-modified-added">+      * @param b the temporary buffer used in merging</span>
<span class="udiff-line-modified-added">+      * @param offset the start index in the source, inclusive</span>
<span class="udiff-line-modified-added">+      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="udiff-line-modified-added">+      * @param parallel indicates whether merging is performed in parallel</span>
<span class="udiff-line-modified-added">+      * @param run the start indexes of the runs, inclusive</span>
<span class="udiff-line-modified-added">+      * @param lo the start index of the first run, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi the start index of the last run, inclusive</span>
<span class="udiff-line-modified-added">+      * @return the destination where runs are merged</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static int[] mergeRuns(int[] a, int[] b, int offset,</span>
<span class="udiff-line-modified-added">+             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         if (hi - lo == 1) {</span>
<span class="udiff-line-added">+             if (aim &gt;= 0) {</span>
<span class="udiff-line-added">+                 return a;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="udiff-line-added">+                 b[--j] = a[--i]</span>
<span class="udiff-line-added">+             );</span>
<span class="udiff-line-added">+             return b;</span>
          }
  
          /*
<span class="udiff-line-modified-removed">-          * Index run[i] is the start of i-th run</span>
<span class="udiff-line-removed">-          * (ascending or descending sequence).</span>
<span class="udiff-line-modified-added">+          * Split into approximately equal parts.</span>
           */
<span class="udiff-line-modified-removed">-         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="udiff-line-modified-removed">-         int count = 0; run[0] = left;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Check if the array is nearly sorted</span>
<span class="udiff-line-removed">-         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="udiff-line-removed">-             // Equal items in the beginning of the sequence</span>
<span class="udiff-line-removed">-             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="udiff-line-removed">-                 k++;</span>
<span class="udiff-line-removed">-             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="udiff-line-removed">-             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-removed">-             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-removed">-                 // Transform into an ascending sequence</span>
<span class="udiff-line-removed">-                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="udiff-line-removed">-                     char t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+         while (run[++mi + 1] &lt;= rmi);</span>
  
<span class="udiff-line-modified-removed">-             // Merge a transformed descending sequence followed by an</span>
<span class="udiff-line-modified-removed">-             // ascending sequence</span>
<span class="udiff-line-modified-removed">-             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="udiff-line-modified-removed">-                 count--;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Merge the left and right parts.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         int[] a1, a2;</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The array is not highly structured,</span>
<span class="udiff-line-modified-removed">-              * use Quicksort instead of merge sort.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             if (++count == MAX_RUN_COUNT) {</span>
<span class="udiff-line-modified-removed">-                 sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="udiff-line-modified-added">+             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="udiff-line-modified-added">+             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="udiff-line-modified-added">+             a2 = (int[]) merger.getDestination();</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="udiff-line-modified-added">+             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>
          }
  
<span class="udiff-line-modified-removed">-         // These invariants should hold true:</span>
<span class="udiff-line-removed">-         //    run[0] = 0</span>
<span class="udiff-line-removed">-         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
<span class="udiff-line-modified-added">+         int[] dst = a1 == a ? b : a;</span>
  
<span class="udiff-line-modified-removed">-         if (count == 0) {</span>
<span class="udiff-line-modified-removed">-             // A single equal run</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="udiff-line-modified-removed">-             // Either a single ascending or a transformed descending run.</span>
<span class="udiff-line-modified-removed">-             // Always check that a final run is a proper terminator, otherwise</span>
<span class="udiff-line-modified-removed">-             // we have an unterminated trailing run, to handle downstream.</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         right++;</span>
<span class="udiff-line-removed">-         if (run[count] &lt; right) {</span>
<span class="udiff-line-removed">-             // Corner case: the final run is not a terminator. This may happen</span>
<span class="udiff-line-removed">-             // if a final run is an equals run, or there is a single-element run</span>
<span class="udiff-line-removed">-             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="udiff-line-removed">-             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="udiff-line-removed">-             run[++count] = right;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Determine alternation base for merge</span>
<span class="udiff-line-removed">-         byte odd = 0;</span>
<span class="udiff-line-removed">-         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use or create temporary array b for merging</span>
<span class="udiff-line-removed">-         char[] b;                 // temp array; alternates with a</span>
<span class="udiff-line-removed">-         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="udiff-line-removed">-         int blen = right - left; // space needed for b</span>
<span class="udiff-line-removed">-         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="udiff-line-removed">-             work = new char[blen];</span>
<span class="udiff-line-removed">-             workBase = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (odd == 0) {</span>
<span class="udiff-line-removed">-             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="udiff-line-removed">-             b = a;</span>
<span class="udiff-line-removed">-             bo = 0;</span>
<span class="udiff-line-removed">-             a = work;</span>
<span class="udiff-line-removed">-             ao = workBase - left;</span>
<span class="udiff-line-modified-added">+         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-modified-added">+         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-modified-added">+         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-modified-added">+         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-modified-added">+         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (parallel) {</span>
<span class="udiff-line-modified-added">+             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>
          } else {
<span class="udiff-line-modified-removed">-             b = work;</span>
<span class="udiff-line-removed">-             ao = 0;</span>
<span class="udiff-line-removed">-             bo = workBase - left;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Merging</span>
<span class="udiff-line-removed">-         for (int last; count &gt; 1; count = last) {</span>
<span class="udiff-line-removed">-             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="udiff-line-removed">-                 int hi = run[k], mi = run[k - 1];</span>
<span class="udiff-line-removed">-                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="udiff-line-removed">-                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[p++ + ao];</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[q++ + ao];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 run[++last] = hi;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if ((count &amp; 1) != 0) {</span>
<span class="udiff-line-removed">-                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="udiff-line-removed">-                     b[i + bo] = a[i + ao]</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-                 run[++last] = right;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             char[] t = a; a = b; b = t;</span>
<span class="udiff-line-removed">-             int o = ao; ao = bo; bo = o;</span>
<span class="udiff-line-modified-added">+             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>
          }
<span class="udiff-line-added">+         return dst;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="udiff-line-modified-added">+      * Merges the sorted parts.</span>
       *
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void sort(char[] a, int left, int right, boolean leftmost) {</span>
<span class="udiff-line-modified-removed">-         int length = right - left + 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         // Use insertion sort on tiny arrays</span>
<span class="udiff-line-modified-removed">-         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="udiff-line-modified-removed">-             if (leftmost) {</span>
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Traditional (without sentinel) insertion sort,</span>
<span class="udiff-line-modified-removed">-                  * optimized for server VM, is used in case of</span>
<span class="udiff-line-modified-removed">-                  * the leftmost part.</span>
<span class="udiff-line-modified-removed">-                  */</span>
<span class="udiff-line-modified-removed">-                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-modified-removed">-                     char ai = a[i + 1];</span>
<span class="udiff-line-modified-removed">-                     while (ai &lt; a[j]) {</span>
<span class="udiff-line-modified-removed">-                         a[j + 1] = a[j];</span>
<span class="udiff-line-modified-removed">-                         if (j-- == left) {</span>
<span class="udiff-line-modified-removed">-                             break;</span>
<span class="udiff-line-modified-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[j + 1] = ai;</span>
<span class="udiff-line-modified-added">+      * @param merger parallel context</span>
<span class="udiff-line-modified-added">+      * @param dst the destination where parts are merged</span>
<span class="udiff-line-modified-added">+      * @param k the start index of the destination, inclusive</span>
<span class="udiff-line-modified-added">+      * @param a1 the first part</span>
<span class="udiff-line-modified-added">+      * @param lo1 the start index of the first part, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi1 the end index of the first part, exclusive</span>
<span class="udiff-line-modified-added">+      * @param a2 the second part</span>
<span class="udiff-line-modified-added">+      * @param lo2 the start index of the second part, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi2 the end index of the second part, exclusive</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void mergeParts(Merger merger, int[] dst, int k,</span>
<span class="udiff-line-modified-added">+             int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             while (true) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * The first part must be larger.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="udiff-line-modified-added">+                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="udiff-line-modified-added">+                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>
                  }
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Skip the longest ascending sequence.</span>
<span class="udiff-line-modified-added">+                  * Small parts will be merged sequentially.</span>
                   */
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     if (left &gt;= right) {</span>
<span class="udiff-line-modified-removed">-                         return;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="udiff-line-modified-added">+                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="udiff-line-modified-added">+                     break;</span>
<span class="udiff-line-modified-added">+                 }</span>
  
                  /*
<span class="udiff-line-modified-removed">-                  * Every element from adjoining part plays the role</span>
<span class="udiff-line-removed">-                  * of sentinel, therefore this allows us to avoid the</span>
<span class="udiff-line-removed">-                  * left range check on each iteration. Moreover, we use</span>
<span class="udiff-line-removed">-                  * the more optimized algorithm, so called pair insertion</span>
<span class="udiff-line-removed">-                  * sort, which is faster (in the context of Quicksort)</span>
<span class="udiff-line-removed">-                  * than traditional implementation of insertion sort.</span>
<span class="udiff-line-modified-added">+                  * Find the median of the larger part.</span>
                   */
<span class="udiff-line-modified-removed">-                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="udiff-line-modified-removed">-                     char a1 = a[k], a2 = a[left];</span>
<span class="udiff-line-modified-added">+                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+                 int key = a1[mi1];</span>
<span class="udiff-line-added">+                 int mi2 = hi2;</span>
  
<span class="udiff-line-modified-removed">-                     if (a1 &lt; a2) {</span>
<span class="udiff-line-modified-removed">-                         a2 = a1; a1 = a[left];</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     while (a1 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 2] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[++k + 1] = a1;</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Partition the smaller part.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="udiff-line-modified-added">+                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>
  
<span class="udiff-line-modified-removed">-                     while (a2 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 1] = a[k];</span>
<span class="udiff-line-modified-added">+                     if (key &gt; a2[t]) {</span>
<span class="udiff-line-modified-added">+                         loo = t + 1;</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         mi2 = t;</span>
                      }
<span class="udiff-line-removed">-                     a[k + 1] = a2;</span>
                  }
<span class="udiff-line-removed">-                 char last = a[right];</span>
  
<span class="udiff-line-modified-removed">-                 while (last &lt; a[--right]) {</span>
<span class="udiff-line-modified-removed">-                     a[right + 1] = a[right];</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 a[right + 1] = last;</span>
<span class="udiff-line-modified-added">+                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Merge the right sub-parts in parallel.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Process the sub-left parts.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 hi1 = mi1;</span>
<span class="udiff-line-added">+                 hi2 = mi2;</span>
              }
<span class="udiff-line-removed">-             return;</span>
          }
  
<span class="udiff-line-removed">-         // Inexpensive approximation of length / 7</span>
<span class="udiff-line-removed">-         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="udiff-line-removed">- </span>
          /*
<span class="udiff-line-modified-removed">-          * Sort five evenly spaced elements around (and including) the</span>
<span class="udiff-line-removed">-          * center element in the range. These elements will be used for</span>
<span class="udiff-line-removed">-          * pivot selection as described below. The choice for spacing</span>
<span class="udiff-line-removed">-          * these elements was empirically determined to work well on</span>
<span class="udiff-line-removed">-          * a wide variety of inputs.</span>
<span class="udiff-line-modified-added">+          * Merge small parts sequentially.</span>
           */
<span class="udiff-line-modified-removed">-         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="udiff-line-modified-removed">-         int e2 = e3 - seventh;</span>
<span class="udiff-line-removed">-         int e1 = e2 - seventh;</span>
<span class="udiff-line-removed">-         int e4 = e3 + seventh;</span>
<span class="udiff-line-removed">-         int e5 = e4 + seventh;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Sort these elements using insertion sort</span>
<span class="udiff-line-removed">-         if (a[e2] &lt; a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (a[e3] &lt; a[e2]) { char t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="udiff-line-modified-added">+             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>
          }
<span class="udiff-line-modified-removed">-         if (a[e4] &lt; a[e3]) { char t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+         if (dst != a1 || k &lt; lo1) {</span>
<span class="udiff-line-modified-added">+             while (lo1 &lt; hi1) {</span>
<span class="udiff-line-modified-added">+                 dst[k++] = a1[lo1++];</span>
              }
          }
<span class="udiff-line-modified-removed">-         if (a[e5] &lt; a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         if (dst != a2 || k &lt; lo2) {</span>
<span class="udiff-line-modified-added">+             while (lo2 &lt; hi2) {</span>
<span class="udiff-line-modified-added">+                 dst[k++] = a2[lo2++];</span>
              }
          }
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // [long]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using parallel merge</span>
<span class="udiff-line-added">+      * sort and/or Dual-Pivot Quicksort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * To balance the faster splitting and parallelism of merge sort</span>
<span class="udiff-line-added">+      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="udiff-line-added">+      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="udiff-line-added">+      * the four-way parallel merge is started, still ensuring enough</span>
<span class="udiff-line-added">+      * parallelism to process the partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param parallelism the parallelism level</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(long[] a, int parallelism, int low, int high) {</span>
<span class="udiff-line-added">+         int size = high - low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="udiff-line-added">+             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="udiff-line-added">+             long[] b = depth == 0 ? null : new long[size];</span>
<span class="udiff-line-added">+             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             sort(null, a, 0, low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // Pointers</span>
<span class="udiff-line-modified-removed">-         int less  = left;  // The index of the first element of center part</span>
<span class="udiff-line-modified-removed">-         int great = right; // The index before the first element of right part</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="udiff-line-modified-added">+      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param sorter parallel context</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="udiff-line-added">+      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(Sorter sorter, long[] a, int bits, int low, int high) {</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             int end = high - 1, size = high - low;</span>
  
<span class="udiff-line-removed">-         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
              /*
<span class="udiff-line-modified-removed">-              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="udiff-line-removed">-              * These values are inexpensive approximations of the first and</span>
<span class="udiff-line-removed">-              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="udiff-line-modified-added">+              * Run mixed insertion sort on small non-leftmost parts.</span>
               */
<span class="udiff-line-modified-removed">-             char pivot1 = a[e2];</span>
<span class="udiff-line-modified-removed">-             char pivot2 = a[e4];</span>
<span class="udiff-line-modified-added">+             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
              /*
<span class="udiff-line-modified-removed">-              * The first and the last elements to be sorted are moved to the</span>
<span class="udiff-line-removed">-              * locations formerly occupied by the pivots. When partitioning</span>
<span class="udiff-line-removed">-              * is complete, the pivots are swapped back into their final</span>
<span class="udiff-line-removed">-              * positions, and excluded from subsequent sorting.</span>
<span class="udiff-line-modified-added">+              * Invoke insertion sort on small leftmost part.</span>
               */
<span class="udiff-line-modified-removed">-             a[e2] = a[left];</span>
<span class="udiff-line-modified-removed">-             a[e4] = a[right];</span>
<span class="udiff-line-modified-added">+             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="udiff-line-modified-added">+                 insertionSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Skip elements, which are less or greater than pivot values.</span>
<span class="udiff-line-modified-added">+              * Check if the whole array or large non-leftmost</span>
<span class="udiff-line-added">+              * parts are nearly sorted and then merge runs.</span>
               */
<span class="udiff-line-modified-removed">-             while (a[++less] &lt; pivot1);</span>
<span class="udiff-line-modified-removed">-             while (a[--great] &gt; pivot2);</span>
<span class="udiff-line-modified-added">+             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="udiff-line-modified-added">+                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Partitioning:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part           center part                   right part</span>
<span class="udiff-line-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="udiff-line-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-removed">-              *               ^                          ^       ^</span>
<span class="udiff-line-removed">-              *               |                          |       |</span>
<span class="udiff-line-removed">-              *              less                        k     great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *              all in (left, less)   &lt; pivot1</span>
<span class="udiff-line-removed">-              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="udiff-line-removed">-              *              all in (great, right) &gt; pivot2</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+              * Switch to heap sort if execution</span>
<span class="udiff-line-modified-added">+              * time is becoming quadratic.</span>
               */
<span class="udiff-line-modified-removed">-             outer:</span>
<span class="udiff-line-modified-removed">-             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-modified-removed">-                 char ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot2) {</span>
<span class="udiff-line-removed">-                         if (great-- == k) {</span>
<span class="udiff-line-removed">-                             break outer;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="udiff-line-modified-added">+                 heapSort(a, low, high);</span>
<span class="udiff-line-modified-added">+                 return;</span>
              }
  
<span class="udiff-line-modified-removed">-             // Swap pivots into their final positions</span>
<span class="udiff-line-modified-removed">-             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="udiff-line-modified-removed">-             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Sort left and right parts recursively, excluding known pivots</span>
<span class="udiff-line-removed">-             sort(a, left, less - 2, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 2, right, false);</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Use an inexpensive approximation of the golden ratio</span>
<span class="udiff-line-modified-added">+              * to select five sample elements and determine pivots.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             int step = (size &gt;&gt; 3) * 3 + 3;</span>
  
              /*
<span class="udiff-line-modified-removed">-              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="udiff-line-modified-removed">-              * swap internal pivot values to ends.</span>
<span class="udiff-line-modified-added">+              * Five elements around (and including) the central element</span>
<span class="udiff-line-modified-added">+              * will be used for pivot selection as described below. The</span>
<span class="udiff-line-added">+              * unequal choice of spacing these elements was empirically</span>
<span class="udiff-line-added">+              * determined to work well on a wide variety of inputs.</span>
               */
<span class="udiff-line-modified-removed">-             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Skip elements, which are equal to pivot values.</span>
<span class="udiff-line-modified-added">+             int e1 = low + step;</span>
<span class="udiff-line-modified-added">+             int e5 = end - step;</span>
<span class="udiff-line-modified-added">+             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             long a3 = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Sort these elements in place by the combination</span>
<span class="udiff-line-added">+              * of 4-element sorting network and insertion sort.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              *    5 ------o-----------o------------</span>
<span class="udiff-line-added">+              *            |           |</span>
<span class="udiff-line-added">+              *    4 ------|-----o-----o-----o------</span>
<span class="udiff-line-added">+              *            |     |           |</span>
<span class="udiff-line-added">+              *    2 ------o-----|-----o-----o------</span>
<span class="udiff-line-added">+              *                  |     |</span>
<span class="udiff-line-added">+              *    1 ------------o-----o------------</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="udiff-line-added">+             if (a[e2] &lt; a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a3 &lt; a[e2]) {</span>
<span class="udiff-line-added">+                 if (a3 &lt; a[e1]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (a3 &gt; a[e4]) {</span>
<span class="udiff-line-added">+                 if (a3 &gt; a[e5]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Pointers</span>
<span class="udiff-line-added">+             int lower = low; // The index of the last element of the left part</span>
<span class="udiff-line-added">+             int upper = end; // The index of the first element of the right part</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Partitioning with 2 pivots in case of different elements.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the first and fifth of the five sorted elements as</span>
<span class="udiff-line-added">+                  * the pivots. These values are inexpensive approximation</span>
<span class="udiff-line-added">+                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 long pivot1 = a[e1];</span>
<span class="udiff-line-added">+                 long pivot2 = a[e5];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first and the last elements to be sorted are moved</span>
<span class="udiff-line-added">+                  * to the locations formerly occupied by the pivots. When</span>
<span class="udiff-line-added">+                  * partitioning is completed, the pivots are swapped back</span>
<span class="udiff-line-added">+                  * into their final positions, and excluded from the next</span>
<span class="udiff-line-added">+                  * subsequent sorting.</span>
                   */
<span class="udiff-line-modified-removed">-                 while (a[less] == pivot1) {</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-modified-added">+                 a[e1] = a[lower];</span>
<span class="udiff-line-modified-added">+                 a[e5] = a[upper];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Skip elements, which are less or greater than the pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 while (a[++lower] &lt; pivot1);</span>
<span class="udiff-line-added">+                 while (a[--upper] &gt; pivot2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Backward 3-interval partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part          right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *             ^       ^                            ^</span>
<span class="udiff-line-added">+                  *             |       |                            |</span>
<span class="udiff-line-added">+                  *           lower     k                          upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *              all in (low, lower] &lt; pivot1</span>
<span class="udiff-line-added">+                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="udiff-line-added">+                  *              all in [upper, end) &gt; pivot2</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     long ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                         while (lower &lt; k) {</span>
<span class="udiff-line-added">+                             if (a[++lower] &gt;= pivot1) {</span>
<span class="udiff-line-added">+                                 if (a[lower] &gt; pivot2) {</span>
<span class="udiff-line-added">+                                     a[k] = a[--upper];</span>
<span class="udiff-line-added">+                                     a[upper] = a[lower];</span>
<span class="udiff-line-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     a[k] = a[lower];</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 a[lower] = ak;</span>
<span class="udiff-line-added">+                                 break;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="udiff-line-added">+                         a[k] = a[--upper];</span>
<span class="udiff-line-added">+                         a[upper] = ak;</span>
<span class="udiff-line-added">+                     }</span>
                  }
  
<span class="udiff-line-modified-removed">-                 while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Swap the pivots into their final positions.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="udiff-line-added">+                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="udiff-line-added">+                  * excluding known pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, upper + 1, high);</span>
                  }
  
<span class="udiff-line-added">+             } else { // Use single pivot in case of many equal elements</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the third of the five sorted elements as the pivot.</span>
<span class="udiff-line-added">+                  * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 long pivot = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first element to be sorted is moved to the</span>
<span class="udiff-line-added">+                  * location formerly occupied by the pivot. After</span>
<span class="udiff-line-added">+                  * completion of partitioning the pivot is swapped</span>
<span class="udiff-line-added">+                  * back into its final position, and excluded from</span>
<span class="udiff-line-added">+                  * the next subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e3] = a[lower];</span>
<span class="udiff-line-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Partitioning:</span>
<span class="udiff-line-modified-added">+                  * Traditional 3-way (Dutch National Flag) partitioning</span>
                   *
<span class="udiff-line-modified-removed">-                  *   left part         center part                  right part</span>
<span class="udiff-line-modified-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="udiff-line-modified-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-                  *              ^                        ^       ^</span>
<span class="udiff-line-modified-removed">-                  *              |                        |       |</span>
<span class="udiff-line-modified-removed">-                  *             less                      k     great</span>
<span class="udiff-line-modified-added">+                  *   left part                 central part    right part</span>
<span class="udiff-line-modified-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-modified-added">+                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="udiff-line-modified-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-modified-added">+                  *              ^           ^                ^</span>
<span class="udiff-line-modified-added">+                  *              |           |                |</span>
<span class="udiff-line-modified-added">+                  *            lower         k              upper</span>
                   *
                   * Invariants:
                   *
<span class="udiff-line-modified-removed">-                  *              all in (*,  less) == pivot1</span>
<span class="udiff-line-modified-removed">-                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="udiff-line-modified-removed">-                  *              all in (great, *) == pivot2</span>
<span class="udiff-line-modified-added">+                  *   all in (low, lower] &lt; pivot</span>
<span class="udiff-line-modified-added">+                  *   all in (k, upper)  == pivot</span>
<span class="udiff-line-modified-added">+                  *   all in [upper, end] &gt; pivot</span>
                   *
<span class="udiff-line-modified-removed">-                  * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+                  * Pointer k is the last index of ?-part</span>
                   */
<span class="udiff-line-modified-removed">-                 outer:</span>
<span class="udiff-line-modified-removed">-                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-modified-removed">-                     char ak = a[k];</span>
<span class="udiff-line-modified-removed">-                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                         a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                         ++less;</span>
<span class="udiff-line-modified-removed">-                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-modified-removed">-                         while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                             if (great-- == k) {</span>
<span class="udiff-line-modified-removed">-                                 break outer;</span>
<span class="udiff-line-modified-added">+                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-modified-added">+                     long ak = a[k];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     if (ak != pivot) {</span>
<span class="udiff-line-modified-added">+                         a[k] = pivot;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="udiff-line-modified-added">+                             while (a[++lower] &lt; pivot);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                             if (a[lower] &gt; pivot) {</span>
<span class="udiff-line-modified-added">+                                 a[--upper] = a[lower];</span>
                              }
<span class="udiff-line-added">+                             a[lower] = ak;</span>
<span class="udiff-line-added">+                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="udiff-line-added">+                             a[--upper] = ak;</span>
                          }
<span class="udiff-line-removed">-                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[less];</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * Even though a[great] equals to pivot1, the</span>
<span class="udiff-line-removed">-                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="udiff-line-removed">-                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="udiff-line-removed">-                              * of different signs. Therefore in float and</span>
<span class="udiff-line-removed">-                              * double sorting methods we have to use more</span>
<span class="udiff-line-removed">-                              * accurate assignment a[less] = a[great].</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             a[less] = pivot1;</span>
<span class="udiff-line-removed">-                             ++less;</span>
<span class="udiff-line-removed">-                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[great];</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         a[great] = ak;</span>
<span class="udiff-line-removed">-                         --great;</span>
                      }
                  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivot into its final position.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort the right part (possibly in parallel), excluding</span>
<span class="udiff-line-added">+                  * known pivot. All elements from the central part are</span>
<span class="udiff-line-added">+                  * equal and therefore already sorted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="udiff-line-added">+                 }</span>
              }
<span class="udiff-line-added">+             high = lower; // Iterate along the left part</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-             // Sort center part recursively</span>
<span class="udiff-line-modified-removed">-             sort(a, less, great, false);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="udiff-line-added">+      * pin insertion sort and pair insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="udiff-line-added">+      * from the left part plays the role of sentinel, because it</span>
<span class="udiff-line-added">+      * is less than any elements from the given part. Therefore,</span>
<span class="udiff-line-added">+      * expensive check of the left range can be skipped on each</span>
<span class="udiff-line-added">+      * iteration unless it is the leftmost call.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param end the index of the last element for simple insertion sort</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void mixedInsertionSort(long[] a, int low, int end, int high) {</span>
<span class="udiff-line-added">+         if (end == high) {</span>
  
<span class="udiff-line-removed">-         } else { // Partitioning with one pivot</span>
              /*
<span class="udiff-line-modified-removed">-              * Use the third of the five sorted elements as pivot.</span>
<span class="udiff-line-removed">-              * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-modified-added">+              * Invoke simple insertion sort on tiny array.</span>
               */
<span class="udiff-line-modified-removed">-             char pivot = a[e3];</span>
<span class="udiff-line-modified-added">+             for (int i; ++low &lt; end; ) {</span>
<span class="udiff-line-added">+                 long ai = a[i = low];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Partitioning degenerates to the traditional 3-way</span>
<span class="udiff-line-removed">-              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part    center part              right part</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              *              ^              ^        ^</span>
<span class="udiff-line-removed">-              *              |              |        |</span>
<span class="udiff-line-removed">-              *             less            k      great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-modified-added">+              * Start with pin insertion sort on small part.</span>
               *
<span class="udiff-line-modified-removed">-              *   all in (left, less)   &lt; pivot</span>
<span class="udiff-line-modified-removed">-              *   all in [less, k)     == pivot</span>
<span class="udiff-line-modified-removed">-              *   all in (great, right) &gt; pivot</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+              * Pin insertion sort is extended simple insertion sort.</span>
<span class="udiff-line-modified-added">+              * The main idea of this sort is to put elements larger</span>
<span class="udiff-line-modified-added">+              * than an element called pin to the end of array (the</span>
<span class="udiff-line-modified-added">+              * proper area for such elements). It avoids expensive</span>
<span class="udiff-line-modified-added">+              * movements of these elements through the whole array.</span>
               */
<span class="udiff-line-modified-removed">-             for (int k = less; k &lt;= great; ++k) {</span>
<span class="udiff-line-modified-removed">-                 if (a[k] == pivot) {</span>
<span class="udiff-line-modified-removed">-                     continue;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 char ak = a[k];</span>
<span class="udiff-line-modified-removed">-                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="udiff-line-modified-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                     a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-modified-removed">-                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="udiff-line-modified-removed">-                     while (a[great] &gt; pivot) {</span>
<span class="udiff-line-modified-removed">-                         --great;</span>
<span class="udiff-line-modified-added">+             long pin = a[end];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="udiff-line-modified-added">+                 long ai = a[i = low];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * Insert small element into sorted part.</span>
<span class="udiff-line-modified-added">+                      */</span>
<span class="udiff-line-modified-added">+                     a[i] = a[--i];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-modified-removed">-                         ++less;</span>
<span class="udiff-line-modified-removed">-                     } else { // a[great] == pivot</span>
<span class="udiff-line-modified-removed">-                         /*</span>
<span class="udiff-line-modified-removed">-                          * Even though a[great] equals to pivot, the</span>
<span class="udiff-line-modified-removed">-                          * assignment a[k] = pivot may be incorrect,</span>
<span class="udiff-line-modified-removed">-                          * if a[great] and pivot are floating-point</span>
<span class="udiff-line-modified-removed">-                          * zeros of different signs. Therefore in float</span>
<span class="udiff-line-modified-removed">-                          * and double sorting methods we have to use</span>
<span class="udiff-line-modified-removed">-                          * more accurate assignment a[k] = a[great].</span>
<span class="udiff-line-modified-removed">-                          */</span>
<span class="udiff-line-modified-removed">-                         a[k] = pivot;</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = ai;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * Find element smaller than pin.</span>
<span class="udiff-line-modified-added">+                      */</span>
<span class="udiff-line-modified-added">+                     while (a[--p] &gt; pin);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     /*</span>
<span class="udiff-line-modified-added">+                      * Swap it with large element.</span>
<span class="udiff-line-modified-added">+                      */</span>
<span class="udiff-line-modified-added">+                     if (p &gt; i) {</span>
<span class="udiff-line-modified-added">+                         ai = a[p];</span>
<span class="udiff-line-added">+                         a[p] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Insert small element into sorted part.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = ai;</span>
                  }
              }
  
              /*
<span class="udiff-line-modified-removed">-              * Sort left and right parts recursively.</span>
<span class="udiff-line-removed">-              * All elements from center part are equal</span>
<span class="udiff-line-removed">-              * and, therefore, already sorted.</span>
<span class="udiff-line-modified-added">+              * Continue with pair insertion sort on remain part.</span>
               */
<span class="udiff-line-modified-removed">-             sort(a, left, less - 1, leftmost);</span>
<span class="udiff-line-modified-removed">-             sort(a, great + 1, right, false);</span>
<span class="udiff-line-modified-added">+             for (int i; low &lt; high; ++low) {</span>
<span class="udiff-line-modified-added">+                 long a1 = a[i = low], a2 = a[++low];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Insert two elements per iteration: at first, insert the</span>
<span class="udiff-line-added">+                  * larger element and then insert the smaller element, but</span>
<span class="udiff-line-added">+                  * from the position where the larger element was inserted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (a1 &gt; a2) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 2] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[++i + 1] = a1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = a2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 } else if (a1 &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 2] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[++i + 1] = a2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = a1;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
<span class="udiff-line-removed">-     /** The number of distinct byte values. */</span>
<span class="udiff-line-removed">-     private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span>
<span class="udiff-line-removed">- </span>
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array.</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using insertion sort.</span>
       *
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
       */
<span class="udiff-line-modified-removed">-     static void sort(byte[] a, int left, int right) {</span>
<span class="udiff-line-modified-removed">-         // Use counting sort on large arrays</span>
<span class="udiff-line-modified-removed">-         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_BYTE) {</span>
<span class="udiff-line-removed">-             int[] count = new int[NUM_BYTE_VALUES];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             for (int i = left - 1; ++i &lt;= right;</span>
<span class="udiff-line-removed">-                 count[a[i] - Byte.MIN_VALUE]++</span>
<span class="udiff-line-removed">-             );</span>
<span class="udiff-line-removed">-             for (int i = NUM_BYTE_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="udiff-line-removed">-                 while (count[--i] == 0);</span>
<span class="udiff-line-removed">-                 byte value = (byte) (i + Byte.MIN_VALUE);</span>
<span class="udiff-line-removed">-                 int s = count[i];</span>
<span class="udiff-line-modified-added">+     private static void insertionSort(long[] a, int low, int high) {</span>
<span class="udiff-line-modified-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-modified-added">+             long ai = a[i = k];</span>
  
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     a[--k] = value;</span>
<span class="udiff-line-modified-removed">-                 } while (--s &gt; 0);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         } else { // Use insertion sort on small arrays</span>
<span class="udiff-line-removed">-             for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-removed">-                 byte ai = a[i + 1];</span>
<span class="udiff-line-removed">-                 while (ai &lt; a[j]) {</span>
<span class="udiff-line-removed">-                     a[j + 1] = a[j];</span>
<span class="udiff-line-removed">-                     if (j-- == left) {</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-modified-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-modified-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = a[i];</span>
                  }
<span class="udiff-line-modified-removed">-                 a[j + 1] = ai;</span>
<span class="udiff-line-modified-added">+                 a[i + 1] = ai;</span>
              }
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array using the given</span>
<span class="udiff-line-removed">-      * workspace array slice if possible for merging</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using heap sort.</span>
       *
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     static void sort(float[] a, int left, int right,</span>
<span class="udiff-line-modified-removed">-                      float[] work, int workBase, int workLen) {</span>
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Phase 1: Move NaNs to the end of the array.</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-removed">-         while (left &lt;= right &amp;&amp; Float.isNaN(a[right])) {</span>
<span class="udiff-line-removed">-             --right;</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void heapSort(long[] a, int low, int high) {</span>
<span class="udiff-line-modified-added">+         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="udiff-line-modified-added">+             pushDown(a, --k, a[k], low, high);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         while (--high &gt; low) {</span>
<span class="udiff-line-modified-added">+             long max = a[low];</span>
<span class="udiff-line-modified-added">+             pushDown(a, low, a[high], low, high);</span>
<span class="udiff-line-modified-added">+             a[high] = max;</span>
          }
<span class="udiff-line-modified-removed">-         for (int k = right; --k &gt;= left; ) {</span>
<span class="udiff-line-modified-removed">-             float ak = a[k];</span>
<span class="udiff-line-modified-removed">-             if (ak != ak) { // a[k] is NaN</span>
<span class="udiff-line-modified-removed">-                 a[k] = a[right];</span>
<span class="udiff-line-modified-removed">-                 a[right] = ak;</span>
<span class="udiff-line-modified-removed">-                 --right;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Pushes specified element down during heap sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param a the given array</span>
<span class="udiff-line-added">+      * @param p the start index</span>
<span class="udiff-line-added">+      * @param value the given element</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void pushDown(long[] a, int p, long value, int low, int high) {</span>
<span class="udiff-line-added">+         for (int k ;; a[p] = a[p = k]) {</span>
<span class="udiff-line-added">+             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (k &gt; high) {</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="udiff-line-added">+                 --k;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (a[k] &lt;= value) {</span>
<span class="udiff-line-added">+                 break;</span>
              }
          }
<span class="udiff-line-added">+         a[p] = value;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Phase 2: Sort everything except NaNs (which are already in place).</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-modified-removed">-         doSort(a, left, right, work, workBase, workLen);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Tries to sort the specified range of the array.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param sorter parallel context</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element to be sorted</span>
<span class="udiff-line-added">+      * @param size the array size</span>
<span class="udiff-line-added">+      * @return true if finally sorted, false otherwise</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {</span>
  
          /*
<span class="udiff-line-modified-removed">-          * Phase 3: Place negative zeros before positive zeros.</span>
<span class="udiff-line-modified-added">+          * The run array is constructed only if initial runs are</span>
<span class="udiff-line-added">+          * long enough to continue, run[i] then holds start index</span>
<span class="udiff-line-added">+          * of the i-th sequence of elements in non-descending order.</span>
           */
<span class="udiff-line-modified-removed">-         int hi = right;</span>
<span class="udiff-line-modified-added">+         int[] run = null;</span>
<span class="udiff-line-added">+         int high = low + size;</span>
<span class="udiff-line-added">+         int count = 1, last = low;</span>
  
          /*
<span class="udiff-line-modified-removed">-          * Find the first zero, or first positive, or last negative element.</span>
<span class="udiff-line-modified-added">+          * Identify all possible runs.</span>
           */
<span class="udiff-line-modified-removed">-         while (left &lt; hi) {</span>
<span class="udiff-line-removed">-             int middle = (left + hi) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-removed">-             float middleValue = a[middle];</span>
<span class="udiff-line-modified-added">+         for (int k = low + 1; k &lt; high; ) {</span>
  
<span class="udiff-line-modified-removed">-             if (middleValue &lt; 0.0f) {</span>
<span class="udiff-line-modified-removed">-                 left = middle + 1;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 hi = middle;</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Find the end index of the current run.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (a[k - 1] &lt; a[k]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Identify ascending sequence</span>
<span class="udiff-line-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Identify descending sequence</span>
<span class="udiff-line-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Reverse into ascending order</span>
<span class="udiff-line-added">+                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="udiff-line-added">+                     long ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else { // Identify constant sequence</span>
<span class="udiff-line-added">+                 for (long ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (k &lt; high) {</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 }</span>
              }
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Skip the last negative value (if any) or all leading negative zeros.</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-modified-removed">-         while (left &lt;= right &amp;&amp; Float.floatToRawIntBits(a[left]) &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             ++left;</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Check special cases.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (run == null) {</span>
<span class="udiff-line-modified-added">+                 if (k == high) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The array is monotonous sequence,</span>
<span class="udiff-line-added">+                      * and therefore already sorted.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The first run is too small</span>
<span class="udiff-line-added">+                      * to proceed with scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="udiff-line-added">+                 run[0] = low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The first runs are not long</span>
<span class="udiff-line-added">+                      * enough to continue scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Array is not highly structured.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (count == run.length) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Increase capacity of index array.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             run[count] = (last = k);</span>
          }
  
          /*
<span class="udiff-line-modified-removed">-          * Move negative zeros to the beginning of the sub-range.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Partitioning:</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * +----------------------------------------------------+</span>
<span class="udiff-line-removed">-          * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span>
<span class="udiff-line-removed">-          * +----------------------------------------------------+</span>
<span class="udiff-line-removed">-          *              ^          ^         ^</span>
<span class="udiff-line-removed">-          *              |          |         |</span>
<span class="udiff-line-removed">-          *             left        p         k</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Invariants:</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          *   all in (*,  left)  &lt;  0.0</span>
<span class="udiff-line-removed">-          *   all in [left,  p) == -0.0</span>
<span class="udiff-line-removed">-          *   all in [p,     k) ==  0.0</span>
<span class="udiff-line-removed">-          *   all in [k, right] &gt;=  0.0</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+          * Merge runs of highly structured array.</span>
           */
<span class="udiff-line-modified-removed">-         for (int k = left, p = left - 1; ++k &lt;= right; ) {</span>
<span class="udiff-line-modified-removed">-             float ak = a[k];</span>
<span class="udiff-line-modified-removed">-             if (ak != 0.0f) {</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (Float.floatToRawIntBits(ak) &lt; 0) { // ak is -0.0f</span>
<span class="udiff-line-modified-removed">-                 a[k] = 0.0f;</span>
<span class="udiff-line-removed">-                 a[++p] = -0.0f;</span>
<span class="udiff-line-modified-added">+         if (count &gt; 1) {</span>
<span class="udiff-line-modified-added">+             long[] b; int offset = low;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (sorter == null || (b = (long[]) sorter.b) == null) {</span>
<span class="udiff-line-modified-added">+                 b = new long[size];</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-modified-added">+                 offset = sorter.offset;</span>
              }
<span class="udiff-line-added">+             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
          }
<span class="udiff-line-added">+         return true;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array.</span>
<span class="udiff-line-modified-added">+      * Merges the specified runs.</span>
       *
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void doSort(float[] a, int left, int right,</span>
<span class="udiff-line-modified-removed">-                                float[] work, int workBase, int workLen) {</span>
<span class="udiff-line-modified-removed">-         // Use Quicksort on small arrays</span>
<span class="udiff-line-modified-removed">-         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="udiff-line-modified-removed">-             sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+      * @param a the source array</span>
<span class="udiff-line-modified-added">+      * @param b the temporary buffer used in merging</span>
<span class="udiff-line-modified-added">+      * @param offset the start index in the source, inclusive</span>
<span class="udiff-line-modified-added">+      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="udiff-line-modified-added">+      * @param parallel indicates whether merging is performed in parallel</span>
<span class="udiff-line-modified-added">+      * @param run the start indexes of the runs, inclusive</span>
<span class="udiff-line-modified-added">+      * @param lo the start index of the first run, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi the start index of the last run, inclusive</span>
<span class="udiff-line-modified-added">+      * @return the destination where runs are merged</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static long[] mergeRuns(long[] a, long[] b, int offset,</span>
<span class="udiff-line-modified-added">+             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         if (hi - lo == 1) {</span>
<span class="udiff-line-added">+             if (aim &gt;= 0) {</span>
<span class="udiff-line-added">+                 return a;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="udiff-line-added">+                 b[--j] = a[--i]</span>
<span class="udiff-line-added">+             );</span>
<span class="udiff-line-added">+             return b;</span>
          }
  
          /*
<span class="udiff-line-modified-removed">-          * Index run[i] is the start of i-th run</span>
<span class="udiff-line-removed">-          * (ascending or descending sequence).</span>
<span class="udiff-line-modified-added">+          * Split into approximately equal parts.</span>
           */
<span class="udiff-line-modified-removed">-         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="udiff-line-modified-removed">-         int count = 0; run[0] = left;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Check if the array is nearly sorted</span>
<span class="udiff-line-removed">-         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="udiff-line-removed">-             // Equal items in the beginning of the sequence</span>
<span class="udiff-line-removed">-             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="udiff-line-removed">-                 k++;</span>
<span class="udiff-line-removed">-             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="udiff-line-removed">-             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-removed">-             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-removed">-                 // Transform into an ascending sequence</span>
<span class="udiff-line-removed">-                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="udiff-line-removed">-                     float t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+         while (run[++mi + 1] &lt;= rmi);</span>
  
<span class="udiff-line-modified-removed">-             // Merge a transformed descending sequence followed by an</span>
<span class="udiff-line-modified-removed">-             // ascending sequence</span>
<span class="udiff-line-modified-removed">-             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="udiff-line-modified-removed">-                 count--;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Merge the left and right parts.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         long[] a1, a2;</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The array is not highly structured,</span>
<span class="udiff-line-modified-removed">-              * use Quicksort instead of merge sort.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             if (++count == MAX_RUN_COUNT) {</span>
<span class="udiff-line-modified-removed">-                 sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="udiff-line-modified-added">+             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="udiff-line-modified-added">+             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="udiff-line-modified-added">+             a2 = (long[]) merger.getDestination();</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="udiff-line-modified-added">+             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>
          }
  
<span class="udiff-line-modified-removed">-         // These invariants should hold true:</span>
<span class="udiff-line-removed">-         //    run[0] = 0</span>
<span class="udiff-line-removed">-         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
<span class="udiff-line-modified-added">+         long[] dst = a1 == a ? b : a;</span>
  
<span class="udiff-line-modified-removed">-         if (count == 0) {</span>
<span class="udiff-line-modified-removed">-             // A single equal run</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="udiff-line-modified-removed">-             // Either a single ascending or a transformed descending run.</span>
<span class="udiff-line-modified-removed">-             // Always check that a final run is a proper terminator, otherwise</span>
<span class="udiff-line-modified-removed">-             // we have an unterminated trailing run, to handle downstream.</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         right++;</span>
<span class="udiff-line-removed">-         if (run[count] &lt; right) {</span>
<span class="udiff-line-removed">-             // Corner case: the final run is not a terminator. This may happen</span>
<span class="udiff-line-removed">-             // if a final run is an equals run, or there is a single-element run</span>
<span class="udiff-line-removed">-             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="udiff-line-removed">-             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="udiff-line-removed">-             run[++count] = right;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Determine alternation base for merge</span>
<span class="udiff-line-removed">-         byte odd = 0;</span>
<span class="udiff-line-removed">-         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use or create temporary array b for merging</span>
<span class="udiff-line-removed">-         float[] b;                 // temp array; alternates with a</span>
<span class="udiff-line-removed">-         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="udiff-line-removed">-         int blen = right - left; // space needed for b</span>
<span class="udiff-line-removed">-         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="udiff-line-removed">-             work = new float[blen];</span>
<span class="udiff-line-removed">-             workBase = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (odd == 0) {</span>
<span class="udiff-line-removed">-             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="udiff-line-removed">-             b = a;</span>
<span class="udiff-line-removed">-             bo = 0;</span>
<span class="udiff-line-removed">-             a = work;</span>
<span class="udiff-line-removed">-             ao = workBase - left;</span>
<span class="udiff-line-modified-added">+         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-modified-added">+         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-modified-added">+         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-modified-added">+         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-modified-added">+         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (parallel) {</span>
<span class="udiff-line-modified-added">+             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>
          } else {
<span class="udiff-line-modified-removed">-             b = work;</span>
<span class="udiff-line-removed">-             ao = 0;</span>
<span class="udiff-line-removed">-             bo = workBase - left;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Merging</span>
<span class="udiff-line-removed">-         for (int last; count &gt; 1; count = last) {</span>
<span class="udiff-line-removed">-             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="udiff-line-removed">-                 int hi = run[k], mi = run[k - 1];</span>
<span class="udiff-line-removed">-                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="udiff-line-removed">-                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[p++ + ao];</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[q++ + ao];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 run[++last] = hi;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if ((count &amp; 1) != 0) {</span>
<span class="udiff-line-removed">-                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="udiff-line-removed">-                     b[i + bo] = a[i + ao]</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-                 run[++last] = right;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             float[] t = a; a = b; b = t;</span>
<span class="udiff-line-removed">-             int o = ao; ao = bo; bo = o;</span>
<span class="udiff-line-modified-added">+             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>
          }
<span class="udiff-line-added">+         return dst;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="udiff-line-modified-added">+      * Merges the sorted parts.</span>
       *
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void sort(float[] a, int left, int right, boolean leftmost) {</span>
<span class="udiff-line-modified-removed">-         int length = right - left + 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         // Use insertion sort on tiny arrays</span>
<span class="udiff-line-modified-removed">-         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="udiff-line-modified-removed">-             if (leftmost) {</span>
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Traditional (without sentinel) insertion sort,</span>
<span class="udiff-line-modified-removed">-                  * optimized for server VM, is used in case of</span>
<span class="udiff-line-modified-removed">-                  * the leftmost part.</span>
<span class="udiff-line-modified-removed">-                  */</span>
<span class="udiff-line-modified-removed">-                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-modified-removed">-                     float ai = a[i + 1];</span>
<span class="udiff-line-modified-removed">-                     while (ai &lt; a[j]) {</span>
<span class="udiff-line-modified-removed">-                         a[j + 1] = a[j];</span>
<span class="udiff-line-modified-removed">-                         if (j-- == left) {</span>
<span class="udiff-line-modified-removed">-                             break;</span>
<span class="udiff-line-modified-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[j + 1] = ai;</span>
<span class="udiff-line-modified-added">+      * @param merger parallel context</span>
<span class="udiff-line-modified-added">+      * @param dst the destination where parts are merged</span>
<span class="udiff-line-modified-added">+      * @param k the start index of the destination, inclusive</span>
<span class="udiff-line-modified-added">+      * @param a1 the first part</span>
<span class="udiff-line-modified-added">+      * @param lo1 the start index of the first part, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi1 the end index of the first part, exclusive</span>
<span class="udiff-line-modified-added">+      * @param a2 the second part</span>
<span class="udiff-line-modified-added">+      * @param lo2 the start index of the second part, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi2 the end index of the second part, exclusive</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void mergeParts(Merger merger, long[] dst, int k,</span>
<span class="udiff-line-modified-added">+             long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             while (true) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * The first part must be larger.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="udiff-line-modified-added">+                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="udiff-line-modified-added">+                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>
                  }
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Skip the longest ascending sequence.</span>
<span class="udiff-line-modified-added">+                  * Small parts will be merged sequentially.</span>
                   */
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     if (left &gt;= right) {</span>
<span class="udiff-line-modified-removed">-                         return;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="udiff-line-modified-added">+                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="udiff-line-modified-added">+                     break;</span>
<span class="udiff-line-modified-added">+                 }</span>
  
                  /*
<span class="udiff-line-modified-removed">-                  * Every element from adjoining part plays the role</span>
<span class="udiff-line-removed">-                  * of sentinel, therefore this allows us to avoid the</span>
<span class="udiff-line-removed">-                  * left range check on each iteration. Moreover, we use</span>
<span class="udiff-line-removed">-                  * the more optimized algorithm, so called pair insertion</span>
<span class="udiff-line-removed">-                  * sort, which is faster (in the context of Quicksort)</span>
<span class="udiff-line-removed">-                  * than traditional implementation of insertion sort.</span>
<span class="udiff-line-modified-added">+                  * Find the median of the larger part.</span>
                   */
<span class="udiff-line-modified-removed">-                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="udiff-line-modified-removed">-                     float a1 = a[k], a2 = a[left];</span>
<span class="udiff-line-modified-added">+                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+                 long key = a1[mi1];</span>
<span class="udiff-line-added">+                 int mi2 = hi2;</span>
  
<span class="udiff-line-modified-removed">-                     if (a1 &lt; a2) {</span>
<span class="udiff-line-modified-removed">-                         a2 = a1; a1 = a[left];</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     while (a1 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 2] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[++k + 1] = a1;</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Partition the smaller part.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="udiff-line-modified-added">+                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>
  
<span class="udiff-line-modified-removed">-                     while (a2 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 1] = a[k];</span>
<span class="udiff-line-modified-added">+                     if (key &gt; a2[t]) {</span>
<span class="udiff-line-modified-added">+                         loo = t + 1;</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         mi2 = t;</span>
                      }
<span class="udiff-line-removed">-                     a[k + 1] = a2;</span>
                  }
<span class="udiff-line-removed">-                 float last = a[right];</span>
  
<span class="udiff-line-modified-removed">-                 while (last &lt; a[--right]) {</span>
<span class="udiff-line-modified-removed">-                     a[right + 1] = a[right];</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 a[right + 1] = last;</span>
<span class="udiff-line-modified-added">+                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Merge the right sub-parts in parallel.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Process the sub-left parts.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 hi1 = mi1;</span>
<span class="udiff-line-added">+                 hi2 = mi2;</span>
              }
<span class="udiff-line-removed">-             return;</span>
          }
  
<span class="udiff-line-removed">-         // Inexpensive approximation of length / 7</span>
<span class="udiff-line-removed">-         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="udiff-line-removed">- </span>
          /*
<span class="udiff-line-modified-removed">-          * Sort five evenly spaced elements around (and including) the</span>
<span class="udiff-line-removed">-          * center element in the range. These elements will be used for</span>
<span class="udiff-line-removed">-          * pivot selection as described below. The choice for spacing</span>
<span class="udiff-line-removed">-          * these elements was empirically determined to work well on</span>
<span class="udiff-line-removed">-          * a wide variety of inputs.</span>
<span class="udiff-line-modified-added">+          * Merge small parts sequentially.</span>
           */
<span class="udiff-line-modified-removed">-         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="udiff-line-modified-removed">-         int e2 = e3 - seventh;</span>
<span class="udiff-line-removed">-         int e1 = e2 - seventh;</span>
<span class="udiff-line-removed">-         int e4 = e3 + seventh;</span>
<span class="udiff-line-removed">-         int e5 = e4 + seventh;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Sort these elements using insertion sort</span>
<span class="udiff-line-removed">-         if (a[e2] &lt; a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (a[e3] &lt; a[e2]) { float t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="udiff-line-modified-added">+             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>
          }
<span class="udiff-line-modified-removed">-         if (a[e4] &lt; a[e3]) { float t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+         if (dst != a1 || k &lt; lo1) {</span>
<span class="udiff-line-modified-added">+             while (lo1 &lt; hi1) {</span>
<span class="udiff-line-modified-added">+                 dst[k++] = a1[lo1++];</span>
              }
          }
<span class="udiff-line-modified-removed">-         if (a[e5] &lt; a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         if (dst != a2 || k &lt; lo2) {</span>
<span class="udiff-line-modified-added">+             while (lo2 &lt; hi2) {</span>
<span class="udiff-line-modified-added">+                 dst[k++] = a2[lo2++];</span>
              }
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // Pointers</span>
<span class="udiff-line-removed">-         int less  = left;  // The index of the first element of center part</span>
<span class="udiff-line-removed">-         int great = right; // The index before the first element of right part</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="udiff-line-removed">-              * These values are inexpensive approximations of the first and</span>
<span class="udiff-line-removed">-              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             float pivot1 = a[e2];</span>
<span class="udiff-line-removed">-             float pivot2 = a[e4];</span>
<span class="udiff-line-modified-added">+ // [byte]</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The first and the last elements to be sorted are moved to the</span>
<span class="udiff-line-modified-removed">-              * locations formerly occupied by the pivots. When partitioning</span>
<span class="udiff-line-modified-removed">-              * is complete, the pivots are swapped back into their final</span>
<span class="udiff-line-modified-removed">-              * positions, and excluded from subsequent sorting.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             a[e2] = a[left];</span>
<span class="udiff-line-modified-removed">-             a[e4] = a[right];</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using</span>
<span class="udiff-line-modified-added">+      * counting sort or insertion sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-added">+     static void sort(byte[] a, int low, int high) {</span>
<span class="udiff-line-added">+         if (high - low &gt; MIN_BYTE_COUNTING_SORT_SIZE) {</span>
<span class="udiff-line-added">+             countingSort(a, low, high);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             insertionSort(a, low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Skip elements, which are less or greater than pivot values.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             while (a[++less] &lt; pivot1);</span>
<span class="udiff-line-modified-removed">-             while (a[--great] &gt; pivot2);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using insertion sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void insertionSort(byte[] a, int low, int high) {</span>
<span class="udiff-line-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-added">+             byte ai = a[i = k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * The number of distinct byte values.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Max index of byte counter.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using counting sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void countingSort(byte[] a, int low, int high) {</span>
<span class="udiff-line-added">+         int[] count = new int[NUM_BYTE_VALUES];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Compute a histogram with the number of each values.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         for (int i = high; i &gt; low; ++count[a[--i] &amp; 0xFF]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Place values on their final positions.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         if (high - low &gt; NUM_BYTE_VALUES) {</span>
<span class="udiff-line-added">+             for (int i = MAX_BYTE_INDEX; --i &gt; Byte.MAX_VALUE; ) {</span>
<span class="udiff-line-added">+                 int value = i &amp; 0xFF;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 for (low = high - count[value]; high &gt; low;</span>
<span class="udiff-line-added">+                     a[--high] = (byte) value</span>
<span class="udiff-line-added">+                 );</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             for (int i = MAX_BYTE_INDEX; high &gt; low; ) {</span>
<span class="udiff-line-added">+                 while (count[--i &amp; 0xFF] == 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 int value = i &amp; 0xFF;</span>
<span class="udiff-line-added">+                 int c = count[value];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 do {</span>
<span class="udiff-line-added">+                     a[--high] = (byte) value;</span>
<span class="udiff-line-added">+                 } while (--c &gt; 0);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // [char]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using</span>
<span class="udiff-line-added">+      * counting sort or Dual-Pivot Quicksort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(char[] a, int low, int high) {</span>
<span class="udiff-line-added">+         if (high - low &gt; MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {</span>
<span class="udiff-line-added">+             countingSort(a, low, high);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             sort(a, 0, low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="udiff-line-added">+      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="udiff-line-added">+      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(char[] a, int bits, int low, int high) {</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             int end = high - 1, size = high - low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Invoke insertion sort on small leftmost part.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="udiff-line-added">+                 insertionSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Switch to counting sort if execution</span>
<span class="udiff-line-added">+              * time is becoming quadratic.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="udiff-line-added">+                 countingSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Use an inexpensive approximation of the golden ratio</span>
<span class="udiff-line-added">+              * to select five sample elements and determine pivots.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Five elements around (and including) the central element</span>
<span class="udiff-line-added">+              * will be used for pivot selection as described below. The</span>
<span class="udiff-line-added">+              * unequal choice of spacing these elements was empirically</span>
<span class="udiff-line-added">+              * determined to work well on a wide variety of inputs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int e1 = low + step;</span>
<span class="udiff-line-added">+             int e5 = end - step;</span>
<span class="udiff-line-added">+             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             char a3 = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Sort these elements in place by the combination</span>
<span class="udiff-line-added">+              * of 4-element sorting network and insertion sort.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              *    5 ------o-----------o------------</span>
<span class="udiff-line-added">+              *            |           |</span>
<span class="udiff-line-added">+              *    4 ------|-----o-----o-----o------</span>
<span class="udiff-line-added">+              *            |     |           |</span>
<span class="udiff-line-added">+              *    2 ------o-----|-----o-----o------</span>
<span class="udiff-line-added">+              *                  |     |</span>
<span class="udiff-line-added">+              *    1 ------------o-----o------------</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="udiff-line-added">+             if (a[e2] &lt; a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a3 &lt; a[e2]) {</span>
<span class="udiff-line-added">+                 if (a3 &lt; a[e1]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (a3 &gt; a[e4]) {</span>
<span class="udiff-line-added">+                 if (a3 &gt; a[e5]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Pointers</span>
<span class="udiff-line-added">+             int lower = low; // The index of the last element of the left part</span>
<span class="udiff-line-added">+             int upper = end; // The index of the first element of the right part</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Partitioning with 2 pivots in case of different elements.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the first and fifth of the five sorted elements as</span>
<span class="udiff-line-added">+                  * the pivots. These values are inexpensive approximation</span>
<span class="udiff-line-added">+                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 char pivot1 = a[e1];</span>
<span class="udiff-line-added">+                 char pivot2 = a[e5];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first and the last elements to be sorted are moved</span>
<span class="udiff-line-added">+                  * to the locations formerly occupied by the pivots. When</span>
<span class="udiff-line-added">+                  * partitioning is completed, the pivots are swapped back</span>
<span class="udiff-line-added">+                  * into their final positions, and excluded from the next</span>
<span class="udiff-line-added">+                  * subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e1] = a[lower];</span>
<span class="udiff-line-added">+                 a[e5] = a[upper];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Skip elements, which are less or greater than the pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 while (a[++lower] &lt; pivot1);</span>
<span class="udiff-line-added">+                 while (a[--upper] &gt; pivot2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Backward 3-interval partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part          right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *             ^       ^                            ^</span>
<span class="udiff-line-added">+                  *             |       |                            |</span>
<span class="udiff-line-added">+                  *           lower     k                          upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *              all in (low, lower] &lt; pivot1</span>
<span class="udiff-line-added">+                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="udiff-line-added">+                  *              all in [upper, end) &gt; pivot2</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     char ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                         while (lower &lt; k) {</span>
<span class="udiff-line-added">+                             if (a[++lower] &gt;= pivot1) {</span>
<span class="udiff-line-added">+                                 if (a[lower] &gt; pivot2) {</span>
<span class="udiff-line-added">+                                     a[k] = a[--upper];</span>
<span class="udiff-line-added">+                                     a[upper] = a[lower];</span>
<span class="udiff-line-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     a[k] = a[lower];</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 a[lower] = ak;</span>
<span class="udiff-line-added">+                                 break;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="udiff-line-added">+                         a[k] = a[--upper];</span>
<span class="udiff-line-added">+                         a[upper] = ak;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivots into their final positions.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="udiff-line-added">+                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort non-left parts recursively,</span>
<span class="udiff-line-added">+                  * excluding known pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 sort(a, bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                 sort(a, bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else { // Use single pivot in case of many equal elements</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the third of the five sorted elements as the pivot.</span>
<span class="udiff-line-added">+                  * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 char pivot = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first element to be sorted is moved to the</span>
<span class="udiff-line-added">+                  * location formerly occupied by the pivot. After</span>
<span class="udiff-line-added">+                  * completion of partitioning the pivot is swapped</span>
<span class="udiff-line-added">+                  * back into its final position, and excluded from</span>
<span class="udiff-line-added">+                  * the next subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e3] = a[lower];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part    right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *              ^           ^                ^</span>
<span class="udiff-line-added">+                  *              |           |                |</span>
<span class="udiff-line-added">+                  *            lower         k              upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   all in (low, lower] &lt; pivot</span>
<span class="udiff-line-added">+                  *   all in (k, upper)  == pivot</span>
<span class="udiff-line-added">+                  *   all in [upper, end] &gt; pivot</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     char ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak != pivot) {</span>
<span class="udiff-line-added">+                         a[k] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                             while (a[++lower] &lt; pivot);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                             if (a[lower] &gt; pivot) {</span>
<span class="udiff-line-added">+                                 a[--upper] = a[lower];</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             a[lower] = ak;</span>
<span class="udiff-line-added">+                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="udiff-line-added">+                             a[--upper] = ak;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivot into its final position.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort the right part, excluding known pivot.</span>
<span class="udiff-line-added">+                  * All elements from the central part are</span>
<span class="udiff-line-added">+                  * equal and therefore already sorted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 sort(a, bits | 1, upper, high);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             high = lower; // Iterate along the left part</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void insertionSort(char[] a, int low, int high) {</span>
<span class="udiff-line-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-added">+             char ai = a[i = k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * The number of distinct char values.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using counting sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void countingSort(char[] a, int low, int high) {</span>
<span class="udiff-line-added">+         int[] count = new int[NUM_CHAR_VALUES];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Compute a histogram with the number of each values.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         for (int i = high; i &gt; low; ++count[a[--i]]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Place values on their final positions.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         if (high - low &gt; NUM_CHAR_VALUES) {</span>
<span class="udiff-line-added">+             for (int i = NUM_CHAR_VALUES; i &gt; 0; ) {</span>
<span class="udiff-line-added">+                 for (low = high - count[--i]; high &gt; low;</span>
<span class="udiff-line-added">+                     a[--high] = (char) i</span>
<span class="udiff-line-added">+                 );</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             for (int i = NUM_CHAR_VALUES; high &gt; low; ) {</span>
<span class="udiff-line-added">+                 while (count[--i] == 0);</span>
<span class="udiff-line-added">+                 int c = count[i];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 do {</span>
<span class="udiff-line-added">+                     a[--high] = (char) i;</span>
<span class="udiff-line-added">+                 } while (--c &gt; 0);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // [short]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using</span>
<span class="udiff-line-added">+      * counting sort or Dual-Pivot Quicksort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(short[] a, int low, int high) {</span>
<span class="udiff-line-added">+         if (high - low &gt; MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {</span>
<span class="udiff-line-added">+             countingSort(a, low, high);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             sort(a, 0, low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="udiff-line-added">+      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="udiff-line-added">+      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(short[] a, int bits, int low, int high) {</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             int end = high - 1, size = high - low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Invoke insertion sort on small leftmost part.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="udiff-line-added">+                 insertionSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Switch to counting sort if execution</span>
<span class="udiff-line-added">+              * time is becoming quadratic.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="udiff-line-added">+                 countingSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Use an inexpensive approximation of the golden ratio</span>
<span class="udiff-line-added">+              * to select five sample elements and determine pivots.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Five elements around (and including) the central element</span>
<span class="udiff-line-added">+              * will be used for pivot selection as described below. The</span>
<span class="udiff-line-added">+              * unequal choice of spacing these elements was empirically</span>
<span class="udiff-line-added">+              * determined to work well on a wide variety of inputs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int e1 = low + step;</span>
<span class="udiff-line-added">+             int e5 = end - step;</span>
<span class="udiff-line-added">+             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             short a3 = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Sort these elements in place by the combination</span>
<span class="udiff-line-added">+              * of 4-element sorting network and insertion sort.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              *    5 ------o-----------o------------</span>
<span class="udiff-line-added">+              *            |           |</span>
<span class="udiff-line-added">+              *    4 ------|-----o-----o-----o------</span>
<span class="udiff-line-added">+              *            |     |           |</span>
<span class="udiff-line-added">+              *    2 ------o-----|-----o-----o------</span>
<span class="udiff-line-added">+              *                  |     |</span>
<span class="udiff-line-added">+              *    1 ------------o-----o------------</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="udiff-line-added">+             if (a[e2] &lt; a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a3 &lt; a[e2]) {</span>
<span class="udiff-line-added">+                 if (a3 &lt; a[e1]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (a3 &gt; a[e4]) {</span>
<span class="udiff-line-added">+                 if (a3 &gt; a[e5]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Pointers</span>
<span class="udiff-line-added">+             int lower = low; // The index of the last element of the left part</span>
<span class="udiff-line-added">+             int upper = end; // The index of the first element of the right part</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Partitioning with 2 pivots in case of different elements.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the first and fifth of the five sorted elements as</span>
<span class="udiff-line-added">+                  * the pivots. These values are inexpensive approximation</span>
<span class="udiff-line-added">+                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 short pivot1 = a[e1];</span>
<span class="udiff-line-added">+                 short pivot2 = a[e5];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first and the last elements to be sorted are moved</span>
<span class="udiff-line-added">+                  * to the locations formerly occupied by the pivots. When</span>
<span class="udiff-line-added">+                  * partitioning is completed, the pivots are swapped back</span>
<span class="udiff-line-added">+                  * into their final positions, and excluded from the next</span>
<span class="udiff-line-added">+                  * subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e1] = a[lower];</span>
<span class="udiff-line-added">+                 a[e5] = a[upper];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Skip elements, which are less or greater than the pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 while (a[++lower] &lt; pivot1);</span>
<span class="udiff-line-added">+                 while (a[--upper] &gt; pivot2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Backward 3-interval partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part          right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *             ^       ^                            ^</span>
<span class="udiff-line-added">+                  *             |       |                            |</span>
<span class="udiff-line-added">+                  *           lower     k                          upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *              all in (low, lower] &lt; pivot1</span>
<span class="udiff-line-added">+                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="udiff-line-added">+                  *              all in [upper, end) &gt; pivot2</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     short ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                         while (lower &lt; k) {</span>
<span class="udiff-line-added">+                             if (a[++lower] &gt;= pivot1) {</span>
<span class="udiff-line-added">+                                 if (a[lower] &gt; pivot2) {</span>
<span class="udiff-line-added">+                                     a[k] = a[--upper];</span>
<span class="udiff-line-added">+                                     a[upper] = a[lower];</span>
<span class="udiff-line-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     a[k] = a[lower];</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 a[lower] = ak;</span>
<span class="udiff-line-added">+                                 break;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="udiff-line-added">+                         a[k] = a[--upper];</span>
<span class="udiff-line-added">+                         a[upper] = ak;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivots into their final positions.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="udiff-line-added">+                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort non-left parts recursively,</span>
<span class="udiff-line-added">+                  * excluding known pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 sort(a, bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                 sort(a, bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else { // Use single pivot in case of many equal elements</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the third of the five sorted elements as the pivot.</span>
<span class="udiff-line-added">+                  * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 short pivot = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first element to be sorted is moved to the</span>
<span class="udiff-line-added">+                  * location formerly occupied by the pivot. After</span>
<span class="udiff-line-added">+                  * completion of partitioning the pivot is swapped</span>
<span class="udiff-line-added">+                  * back into its final position, and excluded from</span>
<span class="udiff-line-added">+                  * the next subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e3] = a[lower];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part    right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *              ^           ^                ^</span>
<span class="udiff-line-added">+                  *              |           |                |</span>
<span class="udiff-line-added">+                  *            lower         k              upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   all in (low, lower] &lt; pivot</span>
<span class="udiff-line-added">+                  *   all in (k, upper)  == pivot</span>
<span class="udiff-line-added">+                  *   all in [upper, end] &gt; pivot</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     short ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak != pivot) {</span>
<span class="udiff-line-added">+                         a[k] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                             while (a[++lower] &lt; pivot);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                             if (a[lower] &gt; pivot) {</span>
<span class="udiff-line-added">+                                 a[--upper] = a[lower];</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             a[lower] = ak;</span>
<span class="udiff-line-added">+                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="udiff-line-added">+                             a[--upper] = ak;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivot into its final position.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort the right part, excluding known pivot.</span>
<span class="udiff-line-added">+                  * All elements from the central part are</span>
<span class="udiff-line-added">+                  * equal and therefore already sorted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 sort(a, bits | 1, upper, high);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             high = lower; // Iterate along the left part</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void insertionSort(short[] a, int low, int high) {</span>
<span class="udiff-line-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-added">+             short ai = a[i = k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * The number of distinct short values.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Max index of short counter.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using counting sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void countingSort(short[] a, int low, int high) {</span>
<span class="udiff-line-added">+         int[] count = new int[NUM_SHORT_VALUES];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Compute a histogram with the number of each values.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         for (int i = high; i &gt; low; ++count[a[--i] &amp; 0xFFFF]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Place values on their final positions.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         if (high - low &gt; NUM_SHORT_VALUES) {</span>
<span class="udiff-line-added">+             for (int i = MAX_SHORT_INDEX; --i &gt; Short.MAX_VALUE; ) {</span>
<span class="udiff-line-added">+                 int value = i &amp; 0xFFFF;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 for (low = high - count[value]; high &gt; low;</span>
<span class="udiff-line-added">+                     a[--high] = (short) value</span>
<span class="udiff-line-added">+                 );</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             for (int i = MAX_SHORT_INDEX; high &gt; low; ) {</span>
<span class="udiff-line-added">+                 while (count[--i &amp; 0xFFFF] == 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 int value = i &amp; 0xFFFF;</span>
<span class="udiff-line-added">+                 int c = count[value];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 do {</span>
<span class="udiff-line-added">+                     a[--high] = (short) value;</span>
<span class="udiff-line-added">+                 } while (--c &gt; 0);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // [float]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using parallel merge</span>
<span class="udiff-line-added">+      * sort and/or Dual-Pivot Quicksort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * To balance the faster splitting and parallelism of merge sort</span>
<span class="udiff-line-added">+      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="udiff-line-added">+      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="udiff-line-added">+      * the four-way parallel merge is started, still ensuring enough</span>
<span class="udiff-line-added">+      * parallelism to process the partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param parallelism the parallelism level</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(float[] a, int parallelism, int low, int high) {</span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Phase 1. Count the number of negative zero -0.0f,</span>
<span class="udiff-line-added">+          * turn them into positive zero, and move all NaNs</span>
<span class="udiff-line-added">+          * to the end of the array.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         int numNegativeZero = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (int k = high; k &gt; low; ) {</span>
<span class="udiff-line-added">+             float ak = a[--k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ak == 0.0f &amp;&amp; Float.floatToRawIntBits(ak) &lt; 0) { // ak is -0.0f</span>
<span class="udiff-line-added">+                 numNegativeZero += 1;</span>
<span class="udiff-line-added">+                 a[k] = 0.0f;</span>
<span class="udiff-line-added">+             } else if (ak != ak) { // ak is NaN</span>
<span class="udiff-line-added">+                 a[k] = a[--high];</span>
<span class="udiff-line-added">+                 a[high] = ak;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Phase 2. Sort everything except NaNs,</span>
<span class="udiff-line-added">+          * which are already in place.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         int size = high - low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="udiff-line-added">+             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="udiff-line-added">+             float[] b = depth == 0 ? null : new float[size];</span>
<span class="udiff-line-added">+             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             sort(null, a, 0, low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Phase 3. Turn positive zero 0.0f</span>
<span class="udiff-line-added">+          * back into negative zero -0.0f.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         if (++numNegativeZero == 1) {</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Find the position one less than</span>
<span class="udiff-line-added">+          * the index of the first zero.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         while (low &lt;= high) {</span>
<span class="udiff-line-added">+             int middle = (low + high) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a[middle] &lt; 0) {</span>
<span class="udiff-line-added">+                 low = middle + 1;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 high = middle - 1;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Replace the required number of 0.0f by -0.0f.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         while (--numNegativeZero &gt; 0) {</span>
<span class="udiff-line-added">+             a[++high] = -0.0f;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="udiff-line-added">+      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param sorter parallel context</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="udiff-line-added">+      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(Sorter sorter, float[] a, int bits, int low, int high) {</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             int end = high - 1, size = high - low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="udiff-line-added">+                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Invoke insertion sort on small leftmost part.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="udiff-line-added">+                 insertionSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Check if the whole array or large non-leftmost</span>
<span class="udiff-line-added">+              * parts are nearly sorted and then merge runs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="udiff-line-added">+                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Switch to heap sort if execution</span>
<span class="udiff-line-added">+              * time is becoming quadratic.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="udiff-line-added">+                 heapSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Use an inexpensive approximation of the golden ratio</span>
<span class="udiff-line-added">+              * to select five sample elements and determine pivots.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Five elements around (and including) the central element</span>
<span class="udiff-line-added">+              * will be used for pivot selection as described below. The</span>
<span class="udiff-line-added">+              * unequal choice of spacing these elements was empirically</span>
<span class="udiff-line-added">+              * determined to work well on a wide variety of inputs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int e1 = low + step;</span>
<span class="udiff-line-added">+             int e5 = end - step;</span>
<span class="udiff-line-added">+             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             float a3 = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Sort these elements in place by the combination</span>
<span class="udiff-line-added">+              * of 4-element sorting network and insertion sort.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              *    5 ------o-----------o------------</span>
<span class="udiff-line-added">+              *            |           |</span>
<span class="udiff-line-added">+              *    4 ------|-----o-----o-----o------</span>
<span class="udiff-line-added">+              *            |     |           |</span>
<span class="udiff-line-added">+              *    2 ------o-----|-----o-----o------</span>
<span class="udiff-line-added">+              *                  |     |</span>
<span class="udiff-line-added">+              *    1 ------------o-----o------------</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="udiff-line-added">+             if (a[e2] &lt; a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a3 &lt; a[e2]) {</span>
<span class="udiff-line-added">+                 if (a3 &lt; a[e1]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (a3 &gt; a[e4]) {</span>
<span class="udiff-line-added">+                 if (a3 &gt; a[e5]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Pointers</span>
<span class="udiff-line-added">+             int lower = low; // The index of the last element of the left part</span>
<span class="udiff-line-added">+             int upper = end; // The index of the first element of the right part</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Partitioning with 2 pivots in case of different elements.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the first and fifth of the five sorted elements as</span>
<span class="udiff-line-added">+                  * the pivots. These values are inexpensive approximation</span>
<span class="udiff-line-added">+                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 float pivot1 = a[e1];</span>
<span class="udiff-line-added">+                 float pivot2 = a[e5];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first and the last elements to be sorted are moved</span>
<span class="udiff-line-added">+                  * to the locations formerly occupied by the pivots. When</span>
<span class="udiff-line-added">+                  * partitioning is completed, the pivots are swapped back</span>
<span class="udiff-line-added">+                  * into their final positions, and excluded from the next</span>
<span class="udiff-line-added">+                  * subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e1] = a[lower];</span>
<span class="udiff-line-added">+                 a[e5] = a[upper];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Skip elements, which are less or greater than the pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 while (a[++lower] &lt; pivot1);</span>
<span class="udiff-line-added">+                 while (a[--upper] &gt; pivot2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Backward 3-interval partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part          right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *             ^       ^                            ^</span>
<span class="udiff-line-added">+                  *             |       |                            |</span>
<span class="udiff-line-added">+                  *           lower     k                          upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *              all in (low, lower] &lt; pivot1</span>
<span class="udiff-line-added">+                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="udiff-line-added">+                  *              all in [upper, end) &gt; pivot2</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     float ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                         while (lower &lt; k) {</span>
<span class="udiff-line-added">+                             if (a[++lower] &gt;= pivot1) {</span>
<span class="udiff-line-added">+                                 if (a[lower] &gt; pivot2) {</span>
<span class="udiff-line-added">+                                     a[k] = a[--upper];</span>
<span class="udiff-line-added">+                                     a[upper] = a[lower];</span>
<span class="udiff-line-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     a[k] = a[lower];</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 a[lower] = ak;</span>
<span class="udiff-line-added">+                                 break;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="udiff-line-added">+                         a[k] = a[--upper];</span>
<span class="udiff-line-added">+                         a[upper] = ak;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivots into their final positions.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="udiff-line-added">+                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="udiff-line-added">+                  * excluding known pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else { // Use single pivot in case of many equal elements</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the third of the five sorted elements as the pivot.</span>
<span class="udiff-line-added">+                  * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 float pivot = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first element to be sorted is moved to the</span>
<span class="udiff-line-added">+                  * location formerly occupied by the pivot. After</span>
<span class="udiff-line-added">+                  * completion of partitioning the pivot is swapped</span>
<span class="udiff-line-added">+                  * back into its final position, and excluded from</span>
<span class="udiff-line-added">+                  * the next subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e3] = a[lower];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part    right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *              ^           ^                ^</span>
<span class="udiff-line-added">+                  *              |           |                |</span>
<span class="udiff-line-added">+                  *            lower         k              upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   all in (low, lower] &lt; pivot</span>
<span class="udiff-line-added">+                  *   all in (k, upper)  == pivot</span>
<span class="udiff-line-added">+                  *   all in [upper, end] &gt; pivot</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     float ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak != pivot) {</span>
<span class="udiff-line-added">+                         a[k] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                             while (a[++lower] &lt; pivot);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                             if (a[lower] &gt; pivot) {</span>
<span class="udiff-line-added">+                                 a[--upper] = a[lower];</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             a[lower] = ak;</span>
<span class="udiff-line-added">+                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="udiff-line-added">+                             a[--upper] = ak;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivot into its final position.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort the right part (possibly in parallel), excluding</span>
<span class="udiff-line-added">+                  * known pivot. All elements from the central part are</span>
<span class="udiff-line-added">+                  * equal and therefore already sorted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             high = lower; // Iterate along the left part</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="udiff-line-added">+      * pin insertion sort and pair insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="udiff-line-added">+      * from the left part plays the role of sentinel, because it</span>
<span class="udiff-line-added">+      * is less than any elements from the given part. Therefore,</span>
<span class="udiff-line-added">+      * expensive check of the left range can be skipped on each</span>
<span class="udiff-line-added">+      * iteration unless it is the leftmost call.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param end the index of the last element for simple insertion sort</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void mixedInsertionSort(float[] a, int low, int end, int high) {</span>
<span class="udiff-line-added">+         if (end == high) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Invoke simple insertion sort on tiny array.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             for (int i; ++low &lt; end; ) {</span>
<span class="udiff-line-added">+                 float ai = a[i = low];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Start with pin insertion sort on small part.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * Pin insertion sort is extended simple insertion sort.</span>
<span class="udiff-line-added">+              * The main idea of this sort is to put elements larger</span>
<span class="udiff-line-added">+              * than an element called pin to the end of array (the</span>
<span class="udiff-line-added">+              * proper area for such elements). It avoids expensive</span>
<span class="udiff-line-added">+              * movements of these elements through the whole array.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             float pin = a[end];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="udiff-line-added">+                 float ai = a[i = low];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Insert small element into sorted part.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     a[i] = a[--i];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = ai;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Find element smaller than pin.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     while (a[--p] &gt; pin);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Swap it with large element.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     if (p &gt; i) {</span>
<span class="udiff-line-added">+                         ai = a[p];</span>
<span class="udiff-line-added">+                         a[p] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Insert small element into sorted part.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = ai;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Continue with pair insertion sort on remain part.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             for (int i; low &lt; high; ++low) {</span>
<span class="udiff-line-added">+                 float a1 = a[i = low], a2 = a[++low];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Insert two elements per iteration: at first, insert the</span>
<span class="udiff-line-added">+                  * larger element and then insert the smaller element, but</span>
<span class="udiff-line-added">+                  * from the position where the larger element was inserted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (a1 &gt; a2) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 2] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[++i + 1] = a1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = a2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 } else if (a1 &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 2] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[++i + 1] = a2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = a1;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void insertionSort(float[] a, int low, int high) {</span>
<span class="udiff-line-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-added">+             float ai = a[i = k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using heap sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void heapSort(float[] a, int low, int high) {</span>
<span class="udiff-line-added">+         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="udiff-line-added">+             pushDown(a, --k, a[k], low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         while (--high &gt; low) {</span>
<span class="udiff-line-added">+             float max = a[low];</span>
<span class="udiff-line-added">+             pushDown(a, low, a[high], low, high);</span>
<span class="udiff-line-added">+             a[high] = max;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Pushes specified element down during heap sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the given array</span>
<span class="udiff-line-added">+      * @param p the start index</span>
<span class="udiff-line-added">+      * @param value the given element</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void pushDown(float[] a, int p, float value, int low, int high) {</span>
<span class="udiff-line-added">+         for (int k ;; a[p] = a[p = k]) {</span>
<span class="udiff-line-added">+             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (k &gt; high) {</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="udiff-line-added">+                 --k;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (a[k] &lt;= value) {</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         a[p] = value;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Tries to sort the specified range of the array.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param sorter parallel context</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element to be sorted</span>
<span class="udiff-line-added">+      * @param size the array size</span>
<span class="udiff-line-added">+      * @return true if finally sorted, false otherwise</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * The run array is constructed only if initial runs are</span>
<span class="udiff-line-added">+          * long enough to continue, run[i] then holds start index</span>
<span class="udiff-line-added">+          * of the i-th sequence of elements in non-descending order.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         int[] run = null;</span>
<span class="udiff-line-added">+         int high = low + size;</span>
<span class="udiff-line-added">+         int count = 1, last = low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Identify all possible runs.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         for (int k = low + 1; k &lt; high; ) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Find the end index of the current run.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[k - 1] &lt; a[k]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Identify ascending sequence</span>
<span class="udiff-line-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Identify descending sequence</span>
<span class="udiff-line-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Reverse into ascending order</span>
<span class="udiff-line-added">+                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="udiff-line-added">+                     float ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else { // Identify constant sequence</span>
<span class="udiff-line-added">+                 for (float ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (k &lt; high) {</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Check special cases.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (run == null) {</span>
<span class="udiff-line-added">+                 if (k == high) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The array is monotonous sequence,</span>
<span class="udiff-line-added">+                      * and therefore already sorted.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The first run is too small</span>
<span class="udiff-line-added">+                      * to proceed with scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="udiff-line-added">+                 run[0] = low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The first runs are not long</span>
<span class="udiff-line-added">+                      * enough to continue scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Array is not highly structured.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (count == run.length) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Increase capacity of index array.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             run[count] = (last = k);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Merge runs of highly structured array.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         if (count &gt; 1) {</span>
<span class="udiff-line-added">+             float[] b; int offset = low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (sorter == null || (b = (float[]) sorter.b) == null) {</span>
<span class="udiff-line-added">+                 b = new float[size];</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 offset = sorter.offset;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Merges the specified runs.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the source array</span>
<span class="udiff-line-added">+      * @param b the temporary buffer used in merging</span>
<span class="udiff-line-added">+      * @param offset the start index in the source, inclusive</span>
<span class="udiff-line-added">+      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="udiff-line-added">+      * @param parallel indicates whether merging is performed in parallel</span>
<span class="udiff-line-added">+      * @param run the start indexes of the runs, inclusive</span>
<span class="udiff-line-added">+      * @param lo the start index of the first run, inclusive</span>
<span class="udiff-line-added">+      * @param hi the start index of the last run, inclusive</span>
<span class="udiff-line-added">+      * @return the destination where runs are merged</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static float[] mergeRuns(float[] a, float[] b, int offset,</span>
<span class="udiff-line-added">+             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (hi - lo == 1) {</span>
<span class="udiff-line-added">+             if (aim &gt;= 0) {</span>
<span class="udiff-line-added">+                 return a;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="udiff-line-added">+                 b[--j] = a[--i]</span>
<span class="udiff-line-added">+             );</span>
<span class="udiff-line-added">+             return b;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Split into approximately equal parts.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+         while (run[++mi + 1] &lt;= rmi);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Merge the left and right parts.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         float[] a1, a2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="udiff-line-added">+             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="udiff-line-added">+             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="udiff-line-added">+             a2 = (float[]) merger.getDestination();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="udiff-line-added">+             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         float[] dst = a1 == a ? b : a;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-added">+         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-added">+         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-added">+         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-added">+         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (parallel) {</span>
<span class="udiff-line-added">+             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return dst;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Merges the sorted parts.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param merger parallel context</span>
<span class="udiff-line-added">+      * @param dst the destination where parts are merged</span>
<span class="udiff-line-added">+      * @param k the start index of the destination, inclusive</span>
<span class="udiff-line-added">+      * @param a1 the first part</span>
<span class="udiff-line-added">+      * @param lo1 the start index of the first part, inclusive</span>
<span class="udiff-line-added">+      * @param hi1 the end index of the first part, exclusive</span>
<span class="udiff-line-added">+      * @param a2 the second part</span>
<span class="udiff-line-added">+      * @param lo2 the start index of the second part, inclusive</span>
<span class="udiff-line-added">+      * @param hi2 the end index of the second part, exclusive</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void mergeParts(Merger merger, float[] dst, int k,</span>
<span class="udiff-line-added">+             float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             while (true) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first part must be larger.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="udiff-line-added">+                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="udiff-line-added">+                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Small parts will be merged sequentially.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Find the median of the larger part.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+                 float key = a1[mi1];</span>
<span class="udiff-line-added">+                 int mi2 = hi2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Partition the smaller part.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="udiff-line-added">+                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (key &gt; a2[t]) {</span>
<span class="udiff-line-added">+                         loo = t + 1;</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         mi2 = t;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Merge the right sub-parts in parallel.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Process the sub-left parts.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 hi1 = mi1;</span>
<span class="udiff-line-added">+                 hi2 = mi2;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Merge small parts sequentially.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="udiff-line-added">+             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (dst != a1 || k &lt; lo1) {</span>
<span class="udiff-line-added">+             while (lo1 &lt; hi1) {</span>
<span class="udiff-line-added">+                 dst[k++] = a1[lo1++];</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (dst != a2 || k &lt; lo2) {</span>
<span class="udiff-line-added">+             while (lo2 &lt; hi2) {</span>
<span class="udiff-line-added">+                 dst[k++] = a2[lo2++];</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // [double]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using parallel merge</span>
<span class="udiff-line-added">+      * sort and/or Dual-Pivot Quicksort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * To balance the faster splitting and parallelism of merge sort</span>
<span class="udiff-line-added">+      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="udiff-line-added">+      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="udiff-line-added">+      * the four-way parallel merge is started, still ensuring enough</span>
<span class="udiff-line-added">+      * parallelism to process the partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param parallelism the parallelism level</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(double[] a, int parallelism, int low, int high) {</span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Phase 1. Count the number of negative zero -0.0d,</span>
<span class="udiff-line-added">+          * turn them into positive zero, and move all NaNs</span>
<span class="udiff-line-added">+          * to the end of the array.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         int numNegativeZero = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (int k = high; k &gt; low; ) {</span>
<span class="udiff-line-added">+             double ak = a[--k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ak == 0.0d &amp;&amp; Double.doubleToRawLongBits(ak) &lt; 0) { // ak is -0.0d</span>
<span class="udiff-line-added">+                 numNegativeZero += 1;</span>
<span class="udiff-line-added">+                 a[k] = 0.0d;</span>
<span class="udiff-line-added">+             } else if (ak != ak) { // ak is NaN</span>
<span class="udiff-line-added">+                 a[k] = a[--high];</span>
<span class="udiff-line-added">+                 a[high] = ak;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Phase 2. Sort everything except NaNs,</span>
<span class="udiff-line-added">+          * which are already in place.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         int size = high - low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="udiff-line-added">+             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="udiff-line-added">+             double[] b = depth == 0 ? null : new double[size];</span>
<span class="udiff-line-added">+             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             sort(null, a, 0, low, high);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Phase 3. Turn positive zero 0.0d</span>
<span class="udiff-line-added">+          * back into negative zero -0.0d.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         if (++numNegativeZero == 1) {</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Find the position one less than</span>
<span class="udiff-line-added">+          * the index of the first zero.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         while (low &lt;= high) {</span>
<span class="udiff-line-added">+             int middle = (low + high) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a[middle] &lt; 0) {</span>
<span class="udiff-line-added">+                 low = middle + 1;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 high = middle - 1;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Replace the required number of 0.0d by -0.0d.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         while (--numNegativeZero &gt; 0) {</span>
<span class="udiff-line-added">+             a[++high] = -0.0d;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="udiff-line-added">+      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param sorter parallel context</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="udiff-line-added">+      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void sort(Sorter sorter, double[] a, int bits, int low, int high) {</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             int end = high - 1, size = high - low;</span>
  
              /*
<span class="udiff-line-modified-removed">-              * Partitioning:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              *   left part           center part                   right part</span>
<span class="udiff-line-modified-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="udiff-line-modified-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              *               ^                          ^       ^</span>
<span class="udiff-line-modified-removed">-              *               |                          |       |</span>
<span class="udiff-line-modified-removed">-              *              less                        k     great</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              * Invariants:</span>
<span class="udiff-line-modified-added">+              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="udiff-line-modified-added">+                 return;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Invoke insertion sort on small leftmost part.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="udiff-line-added">+                 insertionSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Check if the whole array or large non-leftmost</span>
<span class="udiff-line-added">+              * parts are nearly sorted and then merge runs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="udiff-line-added">+                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Switch to heap sort if execution</span>
<span class="udiff-line-added">+              * time is becoming quadratic.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="udiff-line-added">+                 heapSort(a, low, high);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Use an inexpensive approximation of the golden ratio</span>
<span class="udiff-line-added">+              * to select five sample elements and determine pivots.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Five elements around (and including) the central element</span>
<span class="udiff-line-added">+              * will be used for pivot selection as described below. The</span>
<span class="udiff-line-added">+              * unequal choice of spacing these elements was empirically</span>
<span class="udiff-line-added">+              * determined to work well on a wide variety of inputs.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int e1 = low + step;</span>
<span class="udiff-line-added">+             int e5 = end - step;</span>
<span class="udiff-line-added">+             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-added">+             double a3 = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Sort these elements in place by the combination</span>
<span class="udiff-line-added">+              * of 4-element sorting network and insertion sort.</span>
               *
<span class="udiff-line-modified-removed">-              *              all in (left, less)   &lt; pivot1</span>
<span class="udiff-line-modified-removed">-              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="udiff-line-modified-removed">-              *              all in (great, right) &gt; pivot2</span>
<span class="udiff-line-modified-added">+              *    5 ------o-----------o------------</span>
<span class="udiff-line-modified-added">+              *            |           |</span>
<span class="udiff-line-modified-added">+              *    4 ------|-----o-----o-----o------</span>
<span class="udiff-line-added">+              *            |     |           |</span>
<span class="udiff-line-added">+              *    2 ------o-----|-----o-----o------</span>
<span class="udiff-line-added">+              *                  |     |</span>
<span class="udiff-line-added">+              *    1 ------------o-----o------------</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e5] &lt; a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="udiff-line-added">+             if (a[e2] &lt; a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-added">+             if (a[e4] &lt; a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (a3 &lt; a[e2]) {</span>
<span class="udiff-line-added">+                 if (a3 &lt; a[e1]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (a3 &gt; a[e4]) {</span>
<span class="udiff-line-added">+                 if (a3 &gt; a[e5]) {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Pointers</span>
<span class="udiff-line-added">+             int lower = low; // The index of the last element of the left part</span>
<span class="udiff-line-added">+             int upper = end; // The index of the first element of the right part</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Partitioning with 2 pivots in case of different elements.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the first and fifth of the five sorted elements as</span>
<span class="udiff-line-added">+                  * the pivots. These values are inexpensive approximation</span>
<span class="udiff-line-added">+                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 double pivot1 = a[e1];</span>
<span class="udiff-line-added">+                 double pivot2 = a[e5];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first and the last elements to be sorted are moved</span>
<span class="udiff-line-added">+                  * to the locations formerly occupied by the pivots. When</span>
<span class="udiff-line-added">+                  * partitioning is completed, the pivots are swapped back</span>
<span class="udiff-line-added">+                  * into their final positions, and excluded from the next</span>
<span class="udiff-line-added">+                  * subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e1] = a[lower];</span>
<span class="udiff-line-added">+                 a[e5] = a[upper];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Skip elements, which are less or greater than the pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 while (a[++lower] &lt; pivot1);</span>
<span class="udiff-line-added">+                 while (a[--upper] &gt; pivot2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Backward 3-interval partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part          right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *             ^       ^                            ^</span>
<span class="udiff-line-added">+                  *             |       |                            |</span>
<span class="udiff-line-added">+                  *           lower     k                          upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *              all in (low, lower] &lt; pivot1</span>
<span class="udiff-line-added">+                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="udiff-line-added">+                  *              all in [upper, end) &gt; pivot2</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     double ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                         while (lower &lt; k) {</span>
<span class="udiff-line-added">+                             if (a[++lower] &gt;= pivot1) {</span>
<span class="udiff-line-added">+                                 if (a[lower] &gt; pivot2) {</span>
<span class="udiff-line-added">+                                     a[k] = a[--upper];</span>
<span class="udiff-line-added">+                                     a[upper] = a[lower];</span>
<span class="udiff-line-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     a[k] = a[lower];</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 a[lower] = ak;</span>
<span class="udiff-line-added">+                                 break;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="udiff-line-added">+                         a[k] = a[--upper];</span>
<span class="udiff-line-added">+                         a[upper] = ak;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivots into their final positions.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="udiff-line-added">+                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="udiff-line-added">+                  * excluding known pivots.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, upper + 1, high);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else { // Use single pivot in case of many equal elements</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Use the third of the five sorted elements as the pivot.</span>
<span class="udiff-line-added">+                  * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 double pivot = a[e3];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * The first element to be sorted is moved to the</span>
<span class="udiff-line-added">+                  * location formerly occupied by the pivot. After</span>
<span class="udiff-line-added">+                  * completion of partitioning the pivot is swapped</span>
<span class="udiff-line-added">+                  * back into its final position, and excluded from</span>
<span class="udiff-line-added">+                  * the next subsequent sorting.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[e3] = a[lower];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   left part                 central part    right part</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="udiff-line-added">+                  * +------------------------------------------------------+</span>
<span class="udiff-line-added">+                  *              ^           ^                ^</span>
<span class="udiff-line-added">+                  *              |           |                |</span>
<span class="udiff-line-added">+                  *            lower         k              upper</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Invariants:</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  *   all in (low, lower] &lt; pivot</span>
<span class="udiff-line-added">+                  *   all in (k, upper)  == pivot</span>
<span class="udiff-line-added">+                  *   all in [upper, end] &gt; pivot</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Pointer k is the last index of ?-part</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="udiff-line-added">+                     double ak = a[k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (ak != pivot) {</span>
<span class="udiff-line-added">+                         a[k] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="udiff-line-added">+                             while (a[++lower] &lt; pivot);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                             if (a[lower] &gt; pivot) {</span>
<span class="udiff-line-added">+                                 a[--upper] = a[lower];</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             a[lower] = ak;</span>
<span class="udiff-line-added">+                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="udiff-line-added">+                             a[--upper] = ak;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Swap the pivot into its final position.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Sort the right part (possibly in parallel), excluding</span>
<span class="udiff-line-added">+                  * known pivot. All elements from the central part are</span>
<span class="udiff-line-added">+                  * equal and therefore already sorted.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="udiff-line-added">+                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             high = lower; // Iterate along the left part</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="udiff-line-added">+      * pin insertion sort and pair insertion sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="udiff-line-added">+      * from the left part plays the role of sentinel, because it</span>
<span class="udiff-line-added">+      * is less than any elements from the given part. Therefore,</span>
<span class="udiff-line-added">+      * expensive check of the left range can be skipped on each</span>
<span class="udiff-line-added">+      * iteration unless it is the leftmost call.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param end the index of the last element for simple insertion sort</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void mixedInsertionSort(double[] a, int low, int end, int high) {</span>
<span class="udiff-line-added">+         if (end == high) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Invoke simple insertion sort on tiny array.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             for (int i; ++low &lt; end; ) {</span>
<span class="udiff-line-added">+                 double ai = a[i = low];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Start with pin insertion sort on small part.</span>
               *
<span class="udiff-line-modified-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+              * Pin insertion sort is extended simple insertion sort.</span>
<span class="udiff-line-added">+              * The main idea of this sort is to put elements larger</span>
<span class="udiff-line-added">+              * than an element called pin to the end of array (the</span>
<span class="udiff-line-added">+              * proper area for such elements). It avoids expensive</span>
<span class="udiff-line-added">+              * movements of these elements through the whole array.</span>
               */
<span class="udiff-line-modified-removed">-             outer:</span>
<span class="udiff-line-modified-removed">-             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-modified-removed">-                 float ak = a[k];</span>
<span class="udiff-line-modified-removed">-                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-modified-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-modified-added">+             double pin = a[end];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="udiff-line-modified-added">+                 double ai = a[i = low];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Insert small element into sorted part.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     a[i] = a[--i];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = ai;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Find element smaller than pin.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     while (a[--p] &gt; pin);</span>
<span class="udiff-line-added">+ </span>
                      /*
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-added">+                      * Swap it with large element.</span>
                       */
<span class="udiff-line-modified-removed">-                     a[less] = ak;</span>
<span class="udiff-line-modified-removed">-                     ++less;</span>
<span class="udiff-line-modified-removed">-                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot2) {</span>
<span class="udiff-line-removed">-                         if (great-- == k) {</span>
<span class="udiff-line-removed">-                             break outer;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-modified-added">+                     if (p &gt; i) {</span>
<span class="udiff-line-modified-added">+                         ai = a[p];</span>
<span class="udiff-line-modified-added">+                         a[p] = a[i];</span>
                      }
<span class="udiff-line-added">+ </span>
                      /*
<span class="udiff-line-modified-removed">-                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="udiff-line-modified-added">+                      * Insert small element into sorted part.</span>
                       */
<span class="udiff-line-modified-removed">-                     a[great] = ak;</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     while (ai &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = ai;</span>
                  }
              }
  
<span class="udiff-line-removed">-             // Swap pivots into their final positions</span>
<span class="udiff-line-removed">-             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="udiff-line-removed">-             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Sort left and right parts recursively, excluding known pivots</span>
<span class="udiff-line-removed">-             sort(a, left, less - 2, leftmost);</span>
<span class="udiff-line-removed">-             sort(a, great + 2, right, false);</span>
<span class="udiff-line-removed">- </span>
              /*
<span class="udiff-line-modified-removed">-              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="udiff-line-removed">-              * swap internal pivot values to ends.</span>
<span class="udiff-line-modified-added">+              * Continue with pair insertion sort on remain part.</span>
               */
<span class="udiff-line-modified-removed">-             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Skip elements, which are equal to pivot values.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 while (a[less] == pivot1) {</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 while (a[great] == pivot2) {</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+             for (int i; low &lt; high; ++low) {</span>
<span class="udiff-line-modified-added">+                 double a1 = a[i = low], a2 = a[++low];</span>
  
                  /*
<span class="udiff-line-modified-removed">-                  * Partitioning:</span>
<span class="udiff-line-modified-removed">-                  *</span>
<span class="udiff-line-modified-removed">-                  *   left part         center part                  right part</span>
<span class="udiff-line-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-removed">-                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="udiff-line-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-removed">-                  *              ^                        ^       ^</span>
<span class="udiff-line-removed">-                  *              |                        |       |</span>
<span class="udiff-line-removed">-                  *             less                      k     great</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Invariants:</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  *              all in (*,  less) == pivot1</span>
<span class="udiff-line-removed">-                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="udiff-line-removed">-                  *              all in (great, *) == pivot2</span>
<span class="udiff-line-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+                  * Insert two elements per iteration: at first, insert the</span>
<span class="udiff-line-modified-added">+                  * larger element and then insert the smaller element, but</span>
<span class="udiff-line-modified-added">+                  * from the position where the larger element was inserted.</span>
                   */
<span class="udiff-line-modified-removed">-                 outer:</span>
<span class="udiff-line-modified-removed">-                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-modified-removed">-                     float ak = a[k];</span>
<span class="udiff-line-modified-removed">-                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = ak;</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                         while (a[great] == pivot2) {</span>
<span class="udiff-line-removed">-                             if (great-- == k) {</span>
<span class="udiff-line-removed">-                                 break outer;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[less];</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * Even though a[great] equals to pivot1, the</span>
<span class="udiff-line-removed">-                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="udiff-line-removed">-                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="udiff-line-removed">-                              * of different signs. Therefore in float and</span>
<span class="udiff-line-removed">-                              * double sorting methods we have to use more</span>
<span class="udiff-line-removed">-                              * accurate assignment a[less] = a[great].</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             a[less] = a[great];</span>
<span class="udiff-line-removed">-                             ++less;</span>
<span class="udiff-line-removed">-                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[great];</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         a[great] = ak;</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-modified-added">+                 if (a1 &gt; a2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 2] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+                     a[++i + 1] = a1;</span>
  
<span class="udiff-line-modified-removed">-             // Sort center part recursively</span>
<span class="udiff-line-modified-removed">-             sort(a, less, great, false);</span>
<span class="udiff-line-modified-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     a[i + 1] = a2;</span>
  
<span class="udiff-line-modified-removed">-         } else { // Partitioning with one pivot</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Use the third of the five sorted elements as pivot.</span>
<span class="udiff-line-removed">-              * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             float pivot = a[e3];</span>
<span class="udiff-line-modified-added">+                 } else if (a1 &lt; a[i - 1]) {</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Partitioning degenerates to the traditional 3-way</span>
<span class="udiff-line-removed">-              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part    center part              right part</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              *              ^              ^        ^</span>
<span class="udiff-line-removed">-              *              |              |        |</span>
<span class="udiff-line-removed">-              *             less            k      great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   all in (left, less)   &lt; pivot</span>
<span class="udiff-line-removed">-              *   all in [less, k)     == pivot</span>
<span class="udiff-line-removed">-              *   all in (great, right) &gt; pivot</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             for (int k = less; k &lt;= great; ++k) {</span>
<span class="udiff-line-removed">-                 if (a[k] == pivot) {</span>
<span class="udiff-line-removed">-                     continue;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 float ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot) {</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-modified-added">+                     while (a2 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 2] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="udiff-line-modified-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-modified-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-modified-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // a[great] == pivot</span>
<span class="udiff-line-removed">-                         /*</span>
<span class="udiff-line-removed">-                          * Even though a[great] equals to pivot, the</span>
<span class="udiff-line-removed">-                          * assignment a[k] = pivot may be incorrect,</span>
<span class="udiff-line-removed">-                          * if a[great] and pivot are floating-point</span>
<span class="udiff-line-removed">-                          * zeros of different signs. Therefore in float</span>
<span class="udiff-line-removed">-                          * and double sorting methods we have to use</span>
<span class="udiff-line-removed">-                          * more accurate assignment a[k] = a[great].</span>
<span class="udiff-line-removed">-                          */</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-modified-added">+                     a[++i + 1] = a2;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     while (a1 &lt; a[--i]) {</span>
<span class="udiff-line-modified-added">+                         a[i + 1] = a[i];</span>
                      }
<span class="udiff-line-modified-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+                     a[i + 1] = a1;</span>
                  }
              }
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Sort left and right parts recursively.</span>
<span class="udiff-line-modified-removed">-              * All elements from center part are equal</span>
<span class="udiff-line-modified-removed">-              * and, therefore, already sorted.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             sort(a, left, less - 1, leftmost);</span>
<span class="udiff-line-modified-removed">-             sort(a, great + 1, right, false);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using insertion sort.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-added">+     private static void insertionSort(double[] a, int low, int high) {</span>
<span class="udiff-line-added">+         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="udiff-line-added">+             double ai = a[i = k];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (ai &lt; a[i - 1]) {</span>
<span class="udiff-line-added">+                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="udiff-line-added">+                     a[i + 1] = a[i];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 a[i + 1] = ai;</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array using the given</span>
<span class="udiff-line-removed">-      * workspace array slice if possible for merging</span>
<span class="udiff-line-modified-added">+      * Sorts the specified range of the array using heap sort.</span>
       *
       * @param a the array to be sorted
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-removed">-     static void sort(double[] a, int left, int right,</span>
<span class="udiff-line-removed">-                      double[] work, int workBase, int workLen) {</span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * Phase 1: Move NaNs to the end of the array.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         while (left &lt;= right &amp;&amp; Double.isNaN(a[right])) {</span>
<span class="udiff-line-removed">-             --right;</span>
<span class="udiff-line-modified-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void heapSort(double[] a, int low, int high) {</span>
<span class="udiff-line-modified-added">+         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="udiff-line-modified-added">+             pushDown(a, --k, a[k], low, high);</span>
          }
<span class="udiff-line-modified-removed">-         for (int k = right; --k &gt;= left; ) {</span>
<span class="udiff-line-modified-removed">-             double ak = a[k];</span>
<span class="udiff-line-modified-removed">-             if (ak != ak) { // a[k] is NaN</span>
<span class="udiff-line-modified-removed">-                 a[k] = a[right];</span>
<span class="udiff-line-modified-removed">-                 a[right] = ak;</span>
<span class="udiff-line-modified-removed">-                 --right;</span>
<span class="udiff-line-modified-added">+         while (--high &gt; low) {</span>
<span class="udiff-line-modified-added">+             double max = a[low];</span>
<span class="udiff-line-modified-added">+             pushDown(a, low, a[high], low, high);</span>
<span class="udiff-line-modified-added">+             a[high] = max;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Pushes specified element down during heap sort.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param a the given array</span>
<span class="udiff-line-added">+      * @param p the start index</span>
<span class="udiff-line-added">+      * @param value the given element</span>
<span class="udiff-line-added">+      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-added">+      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void pushDown(double[] a, int p, double value, int low, int high) {</span>
<span class="udiff-line-added">+         for (int k ;; a[p] = a[p = k]) {</span>
<span class="udiff-line-added">+             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (k &gt; high) {</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="udiff-line-added">+                 --k;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (a[k] &lt;= value) {</span>
<span class="udiff-line-added">+                 break;</span>
              }
          }
<span class="udiff-line-added">+         a[p] = value;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Phase 2: Sort everything except NaNs (which are already in place).</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-modified-removed">-         doSort(a, left, right, work, workBase, workLen);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Tries to sort the specified range of the array.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param sorter parallel context</span>
<span class="udiff-line-added">+      * @param a the array to be sorted</span>
<span class="udiff-line-added">+      * @param low the index of the first element to be sorted</span>
<span class="udiff-line-added">+      * @param size the array size</span>
<span class="udiff-line-added">+      * @return true if finally sorted, false otherwise</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {</span>
  
          /*
<span class="udiff-line-modified-removed">-          * Phase 3: Place negative zeros before positive zeros.</span>
<span class="udiff-line-modified-added">+          * The run array is constructed only if initial runs are</span>
<span class="udiff-line-added">+          * long enough to continue, run[i] then holds start index</span>
<span class="udiff-line-added">+          * of the i-th sequence of elements in non-descending order.</span>
           */
<span class="udiff-line-modified-removed">-         int hi = right;</span>
<span class="udiff-line-modified-added">+         int[] run = null;</span>
<span class="udiff-line-added">+         int high = low + size;</span>
<span class="udiff-line-added">+         int count = 1, last = low;</span>
  
          /*
<span class="udiff-line-modified-removed">-          * Find the first zero, or first positive, or last negative element.</span>
<span class="udiff-line-modified-added">+          * Identify all possible runs.</span>
           */
<span class="udiff-line-modified-removed">-         while (left &lt; hi) {</span>
<span class="udiff-line-removed">-             int middle = (left + hi) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-removed">-             double middleValue = a[middle];</span>
<span class="udiff-line-modified-added">+         for (int k = low + 1; k &lt; high; ) {</span>
  
<span class="udiff-line-modified-removed">-             if (middleValue &lt; 0.0d) {</span>
<span class="udiff-line-modified-removed">-                 left = middle + 1;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 hi = middle;</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Find the end index of the current run.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (a[k - 1] &lt; a[k]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Identify ascending sequence</span>
<span class="udiff-line-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Identify descending sequence</span>
<span class="udiff-line-added">+                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Reverse into ascending order</span>
<span class="udiff-line-added">+                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="udiff-line-added">+                     double ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else { // Identify constant sequence</span>
<span class="udiff-line-added">+                 for (double ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (k &lt; high) {</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 }</span>
              }
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Skip the last negative value (if any) or all leading negative zeros.</span>
<span class="udiff-line-modified-removed">-          */</span>
<span class="udiff-line-modified-removed">-         while (left &lt;= right &amp;&amp; Double.doubleToRawLongBits(a[left]) &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             ++left;</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Check special cases.</span>
<span class="udiff-line-modified-added">+              */</span>
<span class="udiff-line-modified-added">+             if (run == null) {</span>
<span class="udiff-line-modified-added">+                 if (k == high) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The array is monotonous sequence,</span>
<span class="udiff-line-added">+                      * and therefore already sorted.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The first run is too small</span>
<span class="udiff-line-added">+                      * to proceed with scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="udiff-line-added">+                 run[0] = low;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * The first runs are not long</span>
<span class="udiff-line-added">+                      * enough to continue scanning.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Array is not highly structured.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (count == run.length) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * Increase capacity of index array.</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             run[count] = (last = k);</span>
          }
  
          /*
<span class="udiff-line-modified-removed">-          * Move negative zeros to the beginning of the sub-range.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Partitioning:</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * +----------------------------------------------------+</span>
<span class="udiff-line-removed">-          * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span>
<span class="udiff-line-removed">-          * +----------------------------------------------------+</span>
<span class="udiff-line-removed">-          *              ^          ^         ^</span>
<span class="udiff-line-removed">-          *              |          |         |</span>
<span class="udiff-line-removed">-          *             left        p         k</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Invariants:</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          *   all in (*,  left)  &lt;  0.0</span>
<span class="udiff-line-removed">-          *   all in [left,  p) == -0.0</span>
<span class="udiff-line-removed">-          *   all in [p,     k) ==  0.0</span>
<span class="udiff-line-removed">-          *   all in [k, right] &gt;=  0.0</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-added">+          * Merge runs of highly structured array.</span>
           */
<span class="udiff-line-modified-removed">-         for (int k = left, p = left - 1; ++k &lt;= right; ) {</span>
<span class="udiff-line-modified-removed">-             double ak = a[k];</span>
<span class="udiff-line-modified-removed">-             if (ak != 0.0d) {</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (Double.doubleToRawLongBits(ak) &lt; 0) { // ak is -0.0d</span>
<span class="udiff-line-modified-removed">-                 a[k] = 0.0d;</span>
<span class="udiff-line-removed">-                 a[++p] = -0.0d;</span>
<span class="udiff-line-modified-added">+         if (count &gt; 1) {</span>
<span class="udiff-line-modified-added">+             double[] b; int offset = low;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (sorter == null || (b = (double[]) sorter.b) == null) {</span>
<span class="udiff-line-modified-added">+                 b = new double[size];</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-modified-added">+                 offset = sorter.offset;</span>
              }
<span class="udiff-line-added">+             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
          }
<span class="udiff-line-added">+         return true;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array.</span>
<span class="udiff-line-modified-added">+      * Merges the specified runs.</span>
       *
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param work a workspace array (slice)</span>
<span class="udiff-line-modified-removed">-      * @param workBase origin of usable space in work array</span>
<span class="udiff-line-modified-removed">-      * @param workLen usable size of work array</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void doSort(double[] a, int left, int right,</span>
<span class="udiff-line-modified-removed">-                                double[] work, int workBase, int workLen) {</span>
<span class="udiff-line-modified-removed">-         // Use Quicksort on small arrays</span>
<span class="udiff-line-modified-removed">-         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="udiff-line-modified-removed">-             sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+      * @param a the source array</span>
<span class="udiff-line-modified-added">+      * @param b the temporary buffer used in merging</span>
<span class="udiff-line-modified-added">+      * @param offset the start index in the source, inclusive</span>
<span class="udiff-line-modified-added">+      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="udiff-line-modified-added">+      * @param parallel indicates whether merging is performed in parallel</span>
<span class="udiff-line-modified-added">+      * @param run the start indexes of the runs, inclusive</span>
<span class="udiff-line-modified-added">+      * @param lo the start index of the first run, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi the start index of the last run, inclusive</span>
<span class="udiff-line-modified-added">+      * @return the destination where runs are merged</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static double[] mergeRuns(double[] a, double[] b, int offset,</span>
<span class="udiff-line-modified-added">+             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         if (hi - lo == 1) {</span>
<span class="udiff-line-added">+             if (aim &gt;= 0) {</span>
<span class="udiff-line-added">+                 return a;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="udiff-line-added">+                 b[--j] = a[--i]</span>
<span class="udiff-line-added">+             );</span>
<span class="udiff-line-added">+             return b;</span>
          }
  
          /*
<span class="udiff-line-modified-removed">-          * Index run[i] is the start of i-th run</span>
<span class="udiff-line-removed">-          * (ascending or descending sequence).</span>
<span class="udiff-line-modified-added">+          * Split into approximately equal parts.</span>
           */
<span class="udiff-line-modified-removed">-         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="udiff-line-modified-removed">-         int count = 0; run[0] = left;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Check if the array is nearly sorted</span>
<span class="udiff-line-removed">-         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="udiff-line-removed">-             // Equal items in the beginning of the sequence</span>
<span class="udiff-line-removed">-             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="udiff-line-removed">-                 k++;</span>
<span class="udiff-line-removed">-             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="udiff-line-removed">-             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="udiff-line-removed">-             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="udiff-line-removed">-                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="udiff-line-removed">-                 // Transform into an ascending sequence</span>
<span class="udiff-line-removed">-                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="udiff-line-removed">-                     double t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+         while (run[++mi + 1] &lt;= rmi);</span>
  
<span class="udiff-line-modified-removed">-             // Merge a transformed descending sequence followed by an</span>
<span class="udiff-line-modified-removed">-             // ascending sequence</span>
<span class="udiff-line-modified-removed">-             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="udiff-line-modified-removed">-                 count--;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Merge the left and right parts.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         double[] a1, a2;</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * The array is not highly structured,</span>
<span class="udiff-line-modified-removed">-              * use Quicksort instead of merge sort.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             if (++count == MAX_RUN_COUNT) {</span>
<span class="udiff-line-modified-removed">-                 sort(a, left, right, true);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="udiff-line-modified-added">+             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="udiff-line-modified-added">+             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="udiff-line-modified-added">+             a2 = (double[]) merger.getDestination();</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="udiff-line-modified-added">+             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>
          }
  
<span class="udiff-line-modified-removed">-         // These invariants should hold true:</span>
<span class="udiff-line-removed">-         //    run[0] = 0</span>
<span class="udiff-line-removed">-         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
<span class="udiff-line-modified-added">+         double[] dst = a1 == a ? b : a;</span>
  
<span class="udiff-line-modified-removed">-         if (count == 0) {</span>
<span class="udiff-line-modified-removed">-             // A single equal run</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="udiff-line-modified-removed">-             // Either a single ascending or a transformed descending run.</span>
<span class="udiff-line-modified-removed">-             // Always check that a final run is a proper terminator, otherwise</span>
<span class="udiff-line-modified-removed">-             // we have an unterminated trailing run, to handle downstream.</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         right++;</span>
<span class="udiff-line-removed">-         if (run[count] &lt; right) {</span>
<span class="udiff-line-removed">-             // Corner case: the final run is not a terminator. This may happen</span>
<span class="udiff-line-removed">-             // if a final run is an equals run, or there is a single-element run</span>
<span class="udiff-line-removed">-             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="udiff-line-removed">-             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="udiff-line-removed">-             run[++count] = right;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Determine alternation base for merge</span>
<span class="udiff-line-removed">-         byte odd = 0;</span>
<span class="udiff-line-removed">-         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Use or create temporary array b for merging</span>
<span class="udiff-line-removed">-         double[] b;                 // temp array; alternates with a</span>
<span class="udiff-line-removed">-         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="udiff-line-removed">-         int blen = right - left; // space needed for b</span>
<span class="udiff-line-removed">-         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="udiff-line-removed">-             work = new double[blen];</span>
<span class="udiff-line-removed">-             workBase = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (odd == 0) {</span>
<span class="udiff-line-removed">-             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="udiff-line-removed">-             b = a;</span>
<span class="udiff-line-removed">-             bo = 0;</span>
<span class="udiff-line-removed">-             a = work;</span>
<span class="udiff-line-removed">-             ao = workBase - left;</span>
<span class="udiff-line-modified-added">+         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-modified-added">+         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="udiff-line-modified-added">+         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-modified-added">+         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="udiff-line-modified-added">+         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (parallel) {</span>
<span class="udiff-line-modified-added">+             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>
          } else {
<span class="udiff-line-modified-removed">-             b = work;</span>
<span class="udiff-line-removed">-             ao = 0;</span>
<span class="udiff-line-removed">-             bo = workBase - left;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Merging</span>
<span class="udiff-line-removed">-         for (int last; count &gt; 1; count = last) {</span>
<span class="udiff-line-removed">-             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="udiff-line-removed">-                 int hi = run[k], mi = run[k - 1];</span>
<span class="udiff-line-removed">-                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="udiff-line-removed">-                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[p++ + ao];</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         b[i + bo] = a[q++ + ao];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 run[++last] = hi;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if ((count &amp; 1) != 0) {</span>
<span class="udiff-line-removed">-                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="udiff-line-removed">-                     b[i + bo] = a[i + ao]</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-                 run[++last] = right;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             double[] t = a; a = b; b = t;</span>
<span class="udiff-line-removed">-             int o = ao; ao = bo; bo = o;</span>
<span class="udiff-line-modified-added">+             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>
          }
<span class="udiff-line-added">+         return dst;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="udiff-line-modified-added">+      * Merges the sorted parts.</span>
       *
<span class="udiff-line-modified-removed">-      * @param a the array to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="udiff-line-modified-removed">-      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     private static void sort(double[] a, int left, int right, boolean leftmost) {</span>
<span class="udiff-line-modified-removed">-         int length = right - left + 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         // Use insertion sort on tiny arrays</span>
<span class="udiff-line-modified-removed">-         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="udiff-line-modified-removed">-             if (leftmost) {</span>
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Traditional (without sentinel) insertion sort,</span>
<span class="udiff-line-modified-removed">-                  * optimized for server VM, is used in case of</span>
<span class="udiff-line-modified-removed">-                  * the leftmost part.</span>
<span class="udiff-line-modified-removed">-                  */</span>
<span class="udiff-line-modified-removed">-                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="udiff-line-modified-removed">-                     double ai = a[i + 1];</span>
<span class="udiff-line-modified-removed">-                     while (ai &lt; a[j]) {</span>
<span class="udiff-line-modified-removed">-                         a[j + 1] = a[j];</span>
<span class="udiff-line-modified-removed">-                         if (j-- == left) {</span>
<span class="udiff-line-modified-removed">-                             break;</span>
<span class="udiff-line-modified-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[j + 1] = ai;</span>
<span class="udiff-line-modified-added">+      * @param merger parallel context</span>
<span class="udiff-line-modified-added">+      * @param dst the destination where parts are merged</span>
<span class="udiff-line-modified-added">+      * @param k the start index of the destination, inclusive</span>
<span class="udiff-line-modified-added">+      * @param a1 the first part</span>
<span class="udiff-line-modified-added">+      * @param lo1 the start index of the first part, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi1 the end index of the first part, exclusive</span>
<span class="udiff-line-modified-added">+      * @param a2 the second part</span>
<span class="udiff-line-modified-added">+      * @param lo2 the start index of the second part, inclusive</span>
<span class="udiff-line-modified-added">+      * @param hi2 the end index of the second part, exclusive</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static void mergeParts(Merger merger, double[] dst, int k,</span>
<span class="udiff-line-modified-added">+             double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             while (true) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * The first part must be larger.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="udiff-line-modified-added">+                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="udiff-line-modified-added">+                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>
                  }
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-added">+ </span>
                  /*
<span class="udiff-line-modified-removed">-                  * Skip the longest ascending sequence.</span>
<span class="udiff-line-modified-added">+                  * Small parts will be merged sequentially.</span>
                   */
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     if (left &gt;= right) {</span>
<span class="udiff-line-modified-removed">-                         return;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="udiff-line-modified-added">+                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="udiff-line-modified-added">+                     break;</span>
<span class="udiff-line-modified-added">+                 }</span>
  
                  /*
<span class="udiff-line-modified-removed">-                  * Every element from adjoining part plays the role</span>
<span class="udiff-line-removed">-                  * of sentinel, therefore this allows us to avoid the</span>
<span class="udiff-line-removed">-                  * left range check on each iteration. Moreover, we use</span>
<span class="udiff-line-removed">-                  * the more optimized algorithm, so called pair insertion</span>
<span class="udiff-line-removed">-                  * sort, which is faster (in the context of Quicksort)</span>
<span class="udiff-line-removed">-                  * than traditional implementation of insertion sort.</span>
<span class="udiff-line-modified-added">+                  * Find the median of the larger part.</span>
                   */
<span class="udiff-line-modified-removed">-                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="udiff-line-modified-removed">-                     double a1 = a[k], a2 = a[left];</span>
<span class="udiff-line-modified-added">+                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+                 double key = a1[mi1];</span>
<span class="udiff-line-added">+                 int mi2 = hi2;</span>
  
<span class="udiff-line-modified-removed">-                     if (a1 &lt; a2) {</span>
<span class="udiff-line-modified-removed">-                         a2 = a1; a1 = a[left];</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     while (a1 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 2] = a[k];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[++k + 1] = a1;</span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Partition the smaller part.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="udiff-line-modified-added">+                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>
  
<span class="udiff-line-modified-removed">-                     while (a2 &lt; a[--k]) {</span>
<span class="udiff-line-modified-removed">-                         a[k + 1] = a[k];</span>
<span class="udiff-line-modified-added">+                     if (key &gt; a2[t]) {</span>
<span class="udiff-line-modified-added">+                         loo = t + 1;</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         mi2 = t;</span>
                      }
<span class="udiff-line-removed">-                     a[k + 1] = a2;</span>
                  }
<span class="udiff-line-removed">-                 double last = a[right];</span>
  
<span class="udiff-line-modified-removed">-                 while (last &lt; a[--right]) {</span>
<span class="udiff-line-modified-removed">-                     a[right + 1] = a[right];</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 a[right + 1] = last;</span>
<span class="udiff-line-modified-added">+                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 /*</span>
<span class="udiff-line-modified-added">+                  * Merge the right sub-parts in parallel.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Process the sub-left parts.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 hi1 = mi1;</span>
<span class="udiff-line-added">+                 hi2 = mi2;</span>
              }
<span class="udiff-line-removed">-             return;</span>
          }
  
<span class="udiff-line-removed">-         // Inexpensive approximation of length / 7</span>
<span class="udiff-line-removed">-         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="udiff-line-removed">- </span>
          /*
<span class="udiff-line-modified-removed">-          * Sort five evenly spaced elements around (and including) the</span>
<span class="udiff-line-removed">-          * center element in the range. These elements will be used for</span>
<span class="udiff-line-removed">-          * pivot selection as described below. The choice for spacing</span>
<span class="udiff-line-removed">-          * these elements was empirically determined to work well on</span>
<span class="udiff-line-removed">-          * a wide variety of inputs.</span>
<span class="udiff-line-modified-added">+          * Merge small parts sequentially.</span>
           */
<span class="udiff-line-modified-removed">-         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="udiff-line-modified-removed">-         int e2 = e3 - seventh;</span>
<span class="udiff-line-removed">-         int e1 = e2 - seventh;</span>
<span class="udiff-line-removed">-         int e4 = e3 + seventh;</span>
<span class="udiff-line-removed">-         int e5 = e4 + seventh;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Sort these elements using insertion sort</span>
<span class="udiff-line-removed">-         if (a[e2] &lt; a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (a[e3] &lt; a[e2]) { double t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="udiff-line-modified-added">+             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>
          }
<span class="udiff-line-modified-removed">-         if (a[e4] &lt; a[e3]) { double t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-modified-added">+         if (dst != a1 || k &lt; lo1) {</span>
<span class="udiff-line-modified-added">+             while (lo1 &lt; hi1) {</span>
<span class="udiff-line-modified-added">+                 dst[k++] = a1[lo1++];</span>
              }
          }
<span class="udiff-line-modified-removed">-         if (a[e5] &lt; a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="udiff-line-modified-removed">-             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="udiff-line-modified-removed">-                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="udiff-line-removed">-                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         if (dst != a2 || k &lt; lo2) {</span>
<span class="udiff-line-modified-added">+             while (lo2 &lt; hi2) {</span>
<span class="udiff-line-modified-added">+                 dst[k++] = a2[lo2++];</span>
              }
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // Pointers</span>
<span class="udiff-line-removed">-         int less  = left;  // The index of the first element of center part</span>
<span class="udiff-line-removed">-         int great = right; // The index before the first element of right part</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="udiff-line-removed">-              * These values are inexpensive approximations of the first and</span>
<span class="udiff-line-removed">-              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             double pivot1 = a[e2];</span>
<span class="udiff-line-removed">-             double pivot2 = a[e4];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             /*</span>
<span class="udiff-line-removed">-              * The first and the last elements to be sorted are moved to the</span>
<span class="udiff-line-removed">-              * locations formerly occupied by the pivots. When partitioning</span>
<span class="udiff-line-removed">-              * is complete, the pivots are swapped back into their final</span>
<span class="udiff-line-removed">-              * positions, and excluded from subsequent sorting.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             a[e2] = a[left];</span>
<span class="udiff-line-removed">-             a[e4] = a[right];</span>
<span class="udiff-line-modified-added">+ // [class]</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Skip elements, which are less or greater than pivot values.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             while (a[++less] &lt; pivot1);</span>
<span class="udiff-line-modified-removed">-             while (a[--great] &gt; pivot2);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * This class implements parallel sorting.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="udiff-line-modified-added">+         private static final long serialVersionUID = 20180818L;</span>
<span class="udiff-line-added">+         private final Object a, b;</span>
<span class="udiff-line-added">+         private final int low, size, offset, depth;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private Sorter(CountedCompleter&lt;?&gt; parent,</span>
<span class="udiff-line-added">+                 Object a, Object b, int low, int size, int offset, int depth) {</span>
<span class="udiff-line-added">+             super(parent);</span>
<span class="udiff-line-added">+             this.a = a;</span>
<span class="udiff-line-added">+             this.b = b;</span>
<span class="udiff-line-added">+             this.low = low;</span>
<span class="udiff-line-added">+             this.size = size;</span>
<span class="udiff-line-added">+             this.offset = offset;</span>
<span class="udiff-line-added">+             this.depth = depth;</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Partitioning:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              *   left part           center part                   right part</span>
<span class="udiff-line-modified-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="udiff-line-modified-removed">-              * +--------------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-              *               ^                          ^       ^</span>
<span class="udiff-line-modified-removed">-              *               |                          |       |</span>
<span class="udiff-line-modified-removed">-              *              less                        k     great</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              * Invariants:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              *              all in (left, less)   &lt; pivot1</span>
<span class="udiff-line-modified-removed">-              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="udiff-line-modified-removed">-              *              all in (great, right) &gt; pivot2</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-modified-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-removed">-             outer:</span>
<span class="udiff-line-removed">-             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-removed">-                 double ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot2) {</span>
<span class="udiff-line-removed">-                         if (great-- == k) {</span>
<span class="udiff-line-removed">-                             break outer;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="udiff-line-removed">-                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-modified-added">+         public final void compute() {</span>
<span class="udiff-line-modified-added">+             if (depth &lt; 0) {</span>
<span class="udiff-line-modified-added">+                 setPendingCount(2);</span>
<span class="udiff-line-modified-added">+                 int half = size &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+                 new Sorter(this, b, a, low, half, offset, depth + 1).fork();</span>
<span class="udiff-line-modified-added">+                 new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-modified-added">+                 if (a instanceof int[]) {</span>
<span class="udiff-line-modified-added">+                     sort(this, (int[]) a, depth, low, low + size);</span>
<span class="udiff-line-modified-added">+                 } else if (a instanceof long[]) {</span>
<span class="udiff-line-modified-added">+                     sort(this, (long[]) a, depth, low, low + size);</span>
<span class="udiff-line-modified-added">+                 } else if (a instanceof float[]) {</span>
<span class="udiff-line-modified-added">+                     sort(this, (float[]) a, depth, low, low + size);</span>
<span class="udiff-line-modified-added">+                 } else if (a instanceof double[]) {</span>
<span class="udiff-line-modified-added">+                     sort(this, (double[]) a, depth, low, low + size);</span>
<span class="udiff-line-modified-added">+                 } else {</span>
<span class="udiff-line-modified-added">+                     throw new IllegalArgumentException(</span>
<span class="udiff-line-modified-added">+                         &quot;Unknown type of array: &quot; + a.getClass().getName());</span>
                  }
              }
<span class="udiff-line-added">+             tryComplete();</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             // Swap pivots into their final positions</span>
<span class="udiff-line-modified-removed">-             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="udiff-line-modified-removed">-             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Sort left and right parts recursively, excluding known pivots</span>
<span class="udiff-line-modified-removed">-             sort(a, left, less - 2, leftmost);</span>
<span class="udiff-line-modified-removed">-             sort(a, great + 2, right, false);</span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-modified-added">+         public final void onCompletion(CountedCompleter&lt;?&gt; caller) {</span>
<span class="udiff-line-modified-added">+             if (depth &lt; 0) {</span>
<span class="udiff-line-modified-added">+                 int mi = low + (size &gt;&gt; 1);</span>
<span class="udiff-line-modified-added">+                 boolean src = (depth &amp; 1) == 0;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 new Merger(null,</span>
<span class="udiff-line-added">+                     a,</span>
<span class="udiff-line-added">+                     src ? low : low - offset,</span>
<span class="udiff-line-added">+                     b,</span>
<span class="udiff-line-added">+                     src ? low - offset : low,</span>
<span class="udiff-line-added">+                     src ? mi - offset : mi,</span>
<span class="udiff-line-added">+                     b,</span>
<span class="udiff-line-added">+                     src ? mi - offset : mi,</span>
<span class="udiff-line-added">+                     src ? low + size - offset : low + size</span>
<span class="udiff-line-added">+                 ).invoke();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="udiff-line-modified-removed">-              * swap internal pivot values to ends.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * Skip elements, which are equal to pivot values.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 while (a[less] == pivot1) {</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         private void forkSorter(int depth, int low, int high) {</span>
<span class="udiff-line-modified-added">+             addToPendingCount(1);</span>
<span class="udiff-line-modified-added">+             Object a = this.a; // Use local variable for performance</span>
<span class="udiff-line-modified-added">+             new Sorter(this, a, b, low, high - low, offset, depth).fork();</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     }</span>
  
<span class="udiff-line-modified-removed">-                 while (a[great] == pivot2) {</span>
<span class="udiff-line-modified-removed">-                     --great;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * This class implements parallel merging.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-added">+     private static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="udiff-line-added">+         private static final long serialVersionUID = 20180818L;</span>
<span class="udiff-line-added">+         private final Object dst, a1, a2;</span>
<span class="udiff-line-added">+         private final int k, lo1, hi1, lo2, hi2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private Merger(CountedCompleter&lt;?&gt; parent, Object dst, int k,</span>
<span class="udiff-line-added">+                 Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {</span>
<span class="udiff-line-added">+             super(parent);</span>
<span class="udiff-line-added">+             this.dst = dst;</span>
<span class="udiff-line-added">+             this.k = k;</span>
<span class="udiff-line-added">+             this.a1 = a1;</span>
<span class="udiff-line-added">+             this.lo1 = lo1;</span>
<span class="udiff-line-added">+             this.hi1 = hi1;</span>
<span class="udiff-line-added">+             this.a2 = a2;</span>
<span class="udiff-line-added">+             this.lo2 = lo2;</span>
<span class="udiff-line-added">+             this.hi2 = hi2;</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-                 /*</span>
<span class="udiff-line-modified-removed">-                  * Partitioning:</span>
<span class="udiff-line-modified-removed">-                  *</span>
<span class="udiff-line-modified-removed">-                  *   left part         center part                  right part</span>
<span class="udiff-line-modified-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="udiff-line-modified-removed">-                  * +----------------------------------------------------------+</span>
<span class="udiff-line-modified-removed">-                  *              ^                        ^       ^</span>
<span class="udiff-line-modified-removed">-                  *              |                        |       |</span>
<span class="udiff-line-modified-removed">-                  *             less                      k     great</span>
<span class="udiff-line-modified-removed">-                  *</span>
<span class="udiff-line-modified-removed">-                  * Invariants:</span>
<span class="udiff-line-modified-removed">-                  *</span>
<span class="udiff-line-modified-removed">-                  *              all in (*,  less) == pivot1</span>
<span class="udiff-line-modified-removed">-                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="udiff-line-modified-removed">-                  *              all in (great, *) == pivot2</span>
<span class="udiff-line-modified-removed">-                  *</span>
<span class="udiff-line-removed">-                  * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 outer:</span>
<span class="udiff-line-removed">-                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="udiff-line-removed">-                     double ak = a[k];</span>
<span class="udiff-line-removed">-                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = ak;</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="udiff-line-removed">-                         while (a[great] == pivot2) {</span>
<span class="udiff-line-removed">-                             if (great-- == k) {</span>
<span class="udiff-line-removed">-                                 break outer;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[less];</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * Even though a[great] equals to pivot1, the</span>
<span class="udiff-line-removed">-                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="udiff-line-removed">-                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="udiff-line-removed">-                              * of different signs. Therefore in float and</span>
<span class="udiff-line-removed">-                              * double sorting methods we have to use more</span>
<span class="udiff-line-removed">-                              * accurate assignment a[less] = a[great].</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             a[less] = a[great];</span>
<span class="udiff-line-removed">-                             ++less;</span>
<span class="udiff-line-removed">-                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="udiff-line-removed">-                             a[k] = a[great];</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         a[great] = ak;</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-modified-added">+         public final void compute() {</span>
<span class="udiff-line-modified-added">+             if (dst instanceof int[]) {</span>
<span class="udiff-line-modified-added">+                 mergeParts(this, (int[]) dst, k,</span>
<span class="udiff-line-modified-added">+                     (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);</span>
<span class="udiff-line-modified-added">+             } else if (dst instanceof long[]) {</span>
<span class="udiff-line-modified-added">+                 mergeParts(this, (long[]) dst, k,</span>
<span class="udiff-line-modified-added">+                     (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);</span>
<span class="udiff-line-modified-added">+             } else if (dst instanceof float[]) {</span>
<span class="udiff-line-modified-added">+                 mergeParts(this, (float[]) dst, k,</span>
<span class="udiff-line-modified-added">+                     (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);</span>
<span class="udiff-line-modified-added">+             } else if (dst instanceof double[]) {</span>
<span class="udiff-line-modified-added">+                 mergeParts(this, (double[]) dst, k,</span>
<span class="udiff-line-modified-added">+                     (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-modified-added">+                 throw new IllegalArgumentException(</span>
<span class="udiff-line-modified-added">+                     &quot;Unknown type of array: &quot; + dst.getClass().getName());</span>
              }
<span class="udiff-line-added">+             propagateCompletion();</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             // Sort center part recursively</span>
<span class="udiff-line-modified-removed">-             sort(a, less, great, false);</span>
<span class="udiff-line-modified-added">+         private void forkMerger(Object dst, int k,</span>
<span class="udiff-line-modified-added">+                 Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {</span>
<span class="udiff-line-added">+             addToPendingCount(1);</span>
<span class="udiff-line-added">+             new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         } else { // Partitioning with one pivot</span>
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Use the third of the five sorted elements as pivot.</span>
<span class="udiff-line-modified-removed">-              * This value is inexpensive approximation of the median.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             double pivot = a[e3];</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * This class implements parallel merging of runs.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private static final class RunMerger extends RecursiveTask&lt;Object&gt; {</span>
<span class="udiff-line-modified-added">+         private static final long serialVersionUID = 20180818L;</span>
<span class="udiff-line-modified-added">+         private final Object a, b;</span>
<span class="udiff-line-added">+         private final int[] run;</span>
<span class="udiff-line-added">+         private final int offset, aim, lo, hi;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private RunMerger(Object a, Object b, int offset,</span>
<span class="udiff-line-added">+                 int aim, int[] run, int lo, int hi) {</span>
<span class="udiff-line-added">+             this.a = a;</span>
<span class="udiff-line-added">+             this.b = b;</span>
<span class="udiff-line-added">+             this.offset = offset;</span>
<span class="udiff-line-added">+             this.aim = aim;</span>
<span class="udiff-line-added">+             this.run = run;</span>
<span class="udiff-line-added">+             this.lo = lo;</span>
<span class="udiff-line-added">+             this.hi = hi;</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Partitioning degenerates to the traditional 3-way</span>
<span class="udiff-line-modified-removed">-              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="udiff-line-modified-removed">-              *</span>
<span class="udiff-line-removed">-              *   left part    center part              right part</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="udiff-line-removed">-              * +-------------------------------------------------+</span>
<span class="udiff-line-removed">-              *              ^              ^        ^</span>
<span class="udiff-line-removed">-              *              |              |        |</span>
<span class="udiff-line-removed">-              *             less            k      great</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Invariants:</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              *   all in (left, less)   &lt; pivot</span>
<span class="udiff-line-removed">-              *   all in [less, k)     == pivot</span>
<span class="udiff-line-removed">-              *   all in (great, right) &gt; pivot</span>
<span class="udiff-line-removed">-              *</span>
<span class="udiff-line-removed">-              * Pointer k is the first index of ?-part.</span>
<span class="udiff-line-removed">-              */</span>
<span class="udiff-line-removed">-             for (int k = less; k &lt;= great; ++k) {</span>
<span class="udiff-line-removed">-                 if (a[k] == pivot) {</span>
<span class="udiff-line-removed">-                     continue;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 double ak = a[k];</span>
<span class="udiff-line-removed">-                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="udiff-line-removed">-                     a[k] = a[less];</span>
<span class="udiff-line-removed">-                     a[less] = ak;</span>
<span class="udiff-line-removed">-                     ++less;</span>
<span class="udiff-line-removed">-                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="udiff-line-removed">-                     while (a[great] &gt; pivot) {</span>
<span class="udiff-line-removed">-                         --great;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="udiff-line-removed">-                         a[k] = a[less];</span>
<span class="udiff-line-removed">-                         a[less] = a[great];</span>
<span class="udiff-line-removed">-                         ++less;</span>
<span class="udiff-line-removed">-                     } else { // a[great] == pivot</span>
<span class="udiff-line-removed">-                         /*</span>
<span class="udiff-line-removed">-                          * Even though a[great] equals to pivot, the</span>
<span class="udiff-line-removed">-                          * assignment a[k] = pivot may be incorrect,</span>
<span class="udiff-line-removed">-                          * if a[great] and pivot are floating-point</span>
<span class="udiff-line-removed">-                          * zeros of different signs. Therefore in float</span>
<span class="udiff-line-removed">-                          * and double sorting methods we have to use</span>
<span class="udiff-line-removed">-                          * more accurate assignment a[k] = a[great].</span>
<span class="udiff-line-removed">-                          */</span>
<span class="udiff-line-removed">-                         a[k] = a[great];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     a[great] = ak;</span>
<span class="udiff-line-removed">-                     --great;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-modified-added">+         protected final Object compute() {</span>
<span class="udiff-line-modified-added">+             if (a instanceof int[]) {</span>
<span class="udiff-line-modified-added">+                 return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);</span>
              }
<span class="udiff-line-added">+             if (a instanceof long[]) {</span>
<span class="udiff-line-added">+                 return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (a instanceof float[]) {</span>
<span class="udiff-line-added">+                 return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (a instanceof double[]) {</span>
<span class="udiff-line-added">+                 return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             throw new IllegalArgumentException(</span>
<span class="udiff-line-added">+                 &quot;Unknown type of array: &quot; + a.getClass().getName());</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             /*</span>
<span class="udiff-line-modified-removed">-              * Sort left and right parts recursively.</span>
<span class="udiff-line-modified-removed">-              * All elements from center part are equal</span>
<span class="udiff-line-modified-removed">-              * and, therefore, already sorted.</span>
<span class="udiff-line-modified-removed">-              */</span>
<span class="udiff-line-modified-removed">-             sort(a, left, less - 1, leftmost);</span>
<span class="udiff-line-modified-removed">-             sort(a, great + 1, right, false);</span>
<span class="udiff-line-modified-added">+         private RunMerger forkMe() {</span>
<span class="udiff-line-modified-added">+             fork();</span>
<span class="udiff-line-modified-added">+             return this;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         private Object getDestination() {</span>
<span class="udiff-line-modified-added">+             join();</span>
<span class="udiff-line-added">+             return getRawResult();</span>
          }
      }
  }
</pre>
<center><a href="DoubleSummaryStatistics.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DuplicateFormatFlagsException.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
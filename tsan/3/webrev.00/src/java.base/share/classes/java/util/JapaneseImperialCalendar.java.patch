diff a/src/java.base/share/classes/java/util/JapaneseImperialCalendar.java b/src/java.base/share/classes/java/util/JapaneseImperialCalendar.java
--- a/src/java.base/share/classes/java/util/JapaneseImperialCalendar.java
+++ b/src/java.base/share/classes/java/util/JapaneseImperialCalendar.java
@@ -48,11 +48,11 @@
  *     0       N/A         N/A
  *     1       Meiji       1868-01-01T00:00:00 local time
  *     2       Taisho      1912-07-30T00:00:00 local time
  *     3       Showa       1926-12-25T00:00:00 local time
  *     4       Heisei      1989-01-08T00:00:00 local time
- *     5       NewEra      2019-05-01T00:00:00 local time
+ *     5       Reiwa       2019-05-01T00:00:00 local time
  * ------------------------------------------------------
  * }</pre>
  *
  * <p>{@code ERA} value 0 specifies the years before Meiji and
  * the Gregorian year values are used. Unlike
@@ -127,13 +127,13 @@
      * The ERA constant designating the Heisei era.
      */
     public static final int HEISEI = 4;
 
     /**
-     * The ERA constant designating the NewEra era.
+     * The ERA constant designating the Reiwa era.
      */
-    private static final int NEWERA = 5;
+    private static final int REIWA = 5;
 
     private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
 
     // Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
     // into ints, they must be longs in order to prevent arithmetic overflow
@@ -249,10 +249,11 @@
         2*ONE_HOUR      // DST_OFFSET (double summer time)
     };
 
     // Proclaim serialization compatibility with JDK 1.6
     @SuppressWarnings("FieldNameHidesFieldInSuperclass")
+    @java.io.Serial
     private static final long serialVersionUID = -3364572813905467929L;
 
     static {
         Era[] es = jcal.getEras();
         int length = es.length + 1;
@@ -415,11 +416,11 @@
      * that are not expected to be invariant. The calendar system
      * determines what fields are expected to be invariant.</p>
      *
      * @param field the calendar field.
      * @param amount the amount of date or time to be added to the field.
-     * @exception IllegalArgumentException if {@code field} is
+     * @throws    IllegalArgumentException if {@code field} is
      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,
      * or if any calendar fields have out-of-range values in
      * non-lenient mode.
      */
     @Override
@@ -566,11 +567,11 @@
      * is any calendar field having an out-of-range value in non-lenient mode, then an
      * {@code IllegalArgumentException} is thrown.
      *
      * @param field the calendar field.
      * @param amount the signed amount to add to {@code field}.
-     * @exception IllegalArgumentException if {@code field} is
+     * @throws    IllegalArgumentException if {@code field} is
      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,
      * or if any calendar fields have out-of-range values in
      * non-lenient mode.
      * @see #roll(int,boolean)
      * @see #add(int,int)
@@ -1759,16 +1760,16 @@
                     if (d.isLeapYear()) {
                         --prevJan1;
                     }
                 } else if (transitionYear) {
                     if (jdate.getYear() == 1) {
-                        // As of NewEra (since Meiji) there's no case
+                        // As of Reiwa (since Meiji) there's no case
                         // that there are multiple transitions in a
                         // year.  Historically there was such
                         // case. There might be such case again in the
                         // future.
-                        if (era > NEWERA) {
+                        if (era > REIWA) {
                             CalendarDate pd = eras[era - 1].getSinceDate();
                             if (normalizedYear == pd.getYear()) {
                                 d.setMonth(pd.getMonth()).setDayOfMonth(pd.getDayOfMonth());
                             }
                         } else {
@@ -1864,11 +1865,11 @@
 
     /**
      * Converts calendar field values to the time value (millisecond
      * offset from the <a href="Calendar.html#Epoch">Epoch</a>).
      *
-     * @exception IllegalArgumentException if any calendar fields are invalid.
+     * @throws    IllegalArgumentException if any calendar fields are invalid.
      */
     protected void computeTime() {
         // In non-lenient mode, perform brief checking of calendar
         // fields which have been set externally. Through this
         // checking, the field values are stored in originalFields[]
@@ -2389,10 +2390,11 @@
     }
 
     /**
      * Updates internal state.
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream stream)
             throws IOException, ClassNotFoundException {
         stream.defaultReadObject();
         if (jdate == null) {
             jdate = jcal.newCalendarDate(getZone());

diff a/src/java.base/share/classes/java/util/jar/Attributes.java b/src/java.base/share/classes/java/util/jar/Attributes.java
--- a/src/java.base/share/classes/java/util/jar/Attributes.java
+++ b/src/java.base/share/classes/java/util/jar/Attributes.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,13 +32,15 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 
-import sun.util.logging.PlatformLogger;
+import jdk.internal.misc.VM;
+import jdk.internal.vm.annotation.Stable;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
+import sun.nio.cs.UTF_8;
+import sun.util.logging.PlatformLogger;
 
 /**
  * The Attributes class maps Manifest attribute names to associated string
  * values. Valid attribute names are case-insensitive, are restricted to
  * the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70
@@ -144,11 +146,11 @@
      * the attribute name, the old value is replaced.
      *
      * @param name the attribute name
      * @param value the attribute value
      * @return the previous value of the attribute, or null if none
-     * @exception ClassCastException if the name is not a Attributes.Name
+     * @throws    ClassCastException if the name is not a Attributes.Name
      *            or the value is not a String
      */
     public Object put(Object name, Object value) {
         return map.put((Attributes.Name)name, (String)value);
     }
@@ -165,11 +167,11 @@
      * </pre>
      *
      * @param name the attribute name as a string
      * @param value the attribute value
      * @return the previous value of the attribute, or null if none
-     * @exception IllegalArgumentException if the attribute name is invalid
+     * @throws    IllegalArgumentException if the attribute name is invalid
      */
     public String putValue(String name, String value) {
         return (String)put(Name.of(name), value);
     }
 
@@ -209,11 +211,11 @@
     /**
      * Copies all of the attribute name-value mappings from the specified
      * Attributes to this Map. Duplicate mappings will be replaced.
      *
      * @param attr the Attributes to be stored in this map
-     * @exception ClassCastException if attr is not an Attributes
+     * @throws    ClassCastException if attr is not an Attributes
      */
     public void putAll(Map<?,?> attr) {
         // ## javac bug?
         if (!Attributes.class.isInstance(attr))
             throw new ClassCastException();
@@ -333,11 +335,11 @@
 
         if (version != null) {
             buffer.append(vername);
             buffer.append(": ");
             buffer.append(version);
-            out.write(buffer.toString().getBytes(UTF_8));
+            out.write(buffer.toString().getBytes(UTF_8.INSTANCE));
             Manifest.println(out);
         }
 
         // write out all attributes except for the version
         // we wrote out earlier
@@ -395,11 +397,11 @@
                 System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);
                 if (is.peek() == ' ') {
                     lastline = buf;
                     continue;
                 }
-                value = new String(buf, 0, buf.length, UTF_8);
+                value = new String(buf, 0, buf.length, UTF_8.INSTANCE);
                 lastline = null;
             } else {
                 while (lbuf[i++] != ':') {
                     if (i >= len) {
                         throw new IOException("invalid header field ("
@@ -408,17 +410,17 @@
                 }
                 if (lbuf[i++] != ' ') {
                     throw new IOException("invalid header field ("
                                 + Manifest.getErrorPosition(filename, lineNumber) + ")");
                 }
-                name = new String(lbuf, 0, i - 2, UTF_8);
+                name = new String(lbuf, 0, i - 2, UTF_8.INSTANCE);
                 if (is.peek() == ' ') {
                     lastline = new byte[len - i];
                     System.arraycopy(lbuf, i, lastline, 0, len - i);
                     continue;
                 }
-                value = new String(lbuf, i, len - i, UTF_8);
+                value = new String(lbuf, i, len - i, UTF_8.INSTANCE);
             }
             try {
                 if ((putValue(name, value) != null) && (!lineContinued)) {
                     PlatformLogger.getLogger("java.util.jar").warning(
                                      "Duplicate name in Manifest: " + name
@@ -452,11 +454,11 @@
         private final int hashCode;
 
         /**
          * Avoid allocation for common Names
          */
-        private static final Map<String, Name> KNOWN_NAMES;
+        private static @Stable Map<String, Name> KNOWN_NAMES;
 
         static final Name of(String name) {
             Name n = KNOWN_NAMES.get(name);
             if (n != null) {
                 return n;
@@ -466,13 +468,13 @@
 
         /**
          * Constructs a new attribute name using the given string name.
          *
          * @param name the attribute string name
-         * @exception IllegalArgumentException if the attribute name was
+         * @throws    IllegalArgumentException if the attribute name was
          *            invalid
-         * @exception NullPointerException if the attribute name was null
+         * @throws    NullPointerException if the attribute name was null
          */
         public Name(String name) {
             this.hashCode = hash(name);
             this.name = name.intern();
         }
@@ -539,179 +541,217 @@
          * manifest attribute. This attribute indicates the version number
          * of the manifest standard to which a JAR file's manifest conforms.
          * @see <a href="{@docRoot}/../specs/jar/jar.html#jar-manifest">
          *      Manifest and Signature Specification</a>
          */
-        public static final Name MANIFEST_VERSION = new Name("Manifest-Version");
+        public static final Name MANIFEST_VERSION;
 
         /**
          * {@code Name} object for {@code Signature-Version}
          * manifest attribute used when signing JAR files.
          * @see <a href="{@docRoot}/../specs/jar/jar.html#jar-manifest">
          *      Manifest and Signature Specification</a>
          */
-        public static final Name SIGNATURE_VERSION = new Name("Signature-Version");
+        public static final Name SIGNATURE_VERSION;
 
         /**
          * {@code Name} object for {@code Content-Type}
          * manifest attribute.
          */
-        public static final Name CONTENT_TYPE = new Name("Content-Type");
+        public static final Name CONTENT_TYPE;
 
         /**
          * {@code Name} object for {@code Class-Path}
          * manifest attribute.
          * @see <a href="{@docRoot}/../specs/jar/jar.html#class-path-attribute">
          *      JAR file specification</a>
          */
-        public static final Name CLASS_PATH = new Name("Class-Path");
+        public static final Name CLASS_PATH;
 
         /**
          * {@code Name} object for {@code Main-Class} manifest
          * attribute used for launching applications packaged in JAR files.
          * The {@code Main-Class} attribute is used in conjunction
          * with the {@code -jar} command-line option of the
          * {@code java} application launcher.
          */
-        public static final Name MAIN_CLASS = new Name("Main-Class");
+        public static final Name MAIN_CLASS;
 
         /**
          * {@code Name} object for {@code Sealed} manifest attribute
          * used for sealing.
          * @see <a href="{@docRoot}/../specs/jar/jar.html#package-sealing">
          *      Package Sealing</a>
          */
-        public static final Name SEALED = new Name("Sealed");
+        public static final Name SEALED;
 
         /**
          * {@code Name} object for {@code Extension-List} manifest attribute
          * used for the extension mechanism that is no longer supported.
          */
-        public static final Name EXTENSION_LIST = new Name("Extension-List");
+        public static final Name EXTENSION_LIST;
 
         /**
          * {@code Name} object for {@code Extension-Name} manifest attribute.
          * used for the extension mechanism that is no longer supported.
          */
-        public static final Name EXTENSION_NAME = new Name("Extension-Name");
+        public static final Name EXTENSION_NAME;
 
         /**
          * {@code Name} object for {@code Extension-Installation} manifest attribute.
          *
          * @deprecated Extension mechanism is no longer supported.
          */
         @Deprecated
-        public static final Name EXTENSION_INSTALLATION = new Name("Extension-Installation");
+        public static final Name EXTENSION_INSTALLATION;
 
         /**
          * {@code Name} object for {@code Implementation-Title}
          * manifest attribute used for package versioning.
          */
-        public static final Name IMPLEMENTATION_TITLE = new Name("Implementation-Title");
+        public static final Name IMPLEMENTATION_TITLE;
 
         /**
          * {@code Name} object for {@code Implementation-Version}
          * manifest attribute used for package versioning.
          */
-        public static final Name IMPLEMENTATION_VERSION = new Name("Implementation-Version");
+        public static final Name IMPLEMENTATION_VERSION;
 
         /**
          * {@code Name} object for {@code Implementation-Vendor}
          * manifest attribute used for package versioning.
          */
-        public static final Name IMPLEMENTATION_VENDOR = new Name("Implementation-Vendor");
+        public static final Name IMPLEMENTATION_VENDOR;
 
         /**
          * {@code Name} object for {@code Implementation-Vendor-Id}
          * manifest attribute.
          *
          * @deprecated Extension mechanism is no longer supported.
          */
         @Deprecated
-        public static final Name IMPLEMENTATION_VENDOR_ID = new Name("Implementation-Vendor-Id");
+        public static final Name IMPLEMENTATION_VENDOR_ID;
 
         /**
          * {@code Name} object for {@code Implementation-URL}
          * manifest attribute.
          *
          * @deprecated Extension mechanism is no longer supported.
          */
         @Deprecated
-        public static final Name IMPLEMENTATION_URL = new Name("Implementation-URL");
+        public static final Name IMPLEMENTATION_URL;
 
         /**
          * {@code Name} object for {@code Specification-Title}
          * manifest attribute used for package versioning.
          */
-        public static final Name SPECIFICATION_TITLE = new Name("Specification-Title");
+        public static final Name SPECIFICATION_TITLE;
 
         /**
          * {@code Name} object for {@code Specification-Version}
          * manifest attribute used for package versioning.
          */
-        public static final Name SPECIFICATION_VERSION = new Name("Specification-Version");
+        public static final Name SPECIFICATION_VERSION;
 
         /**
          * {@code Name} object for {@code Specification-Vendor}
          * manifest attribute used for package versioning.
          */
-        public static final Name SPECIFICATION_VENDOR = new Name("Specification-Vendor");
+        public static final Name SPECIFICATION_VENDOR;
 
         /**
          * {@code Name} object for {@code Multi-Release}
          * manifest attribute that indicates this is a multi-release JAR file.
          *
          * @since   9
          */
-        public static final Name MULTI_RELEASE = new Name("Multi-Release");
+        public static final Name MULTI_RELEASE;
 
         private static void addName(Map<String, Name> names, Name name) {
             names.put(name.name, name);
         }
 
         static {
-            var names = new HashMap<String, Name>(64);
-            addName(names, MANIFEST_VERSION);
-            addName(names, SIGNATURE_VERSION);
-            addName(names, CONTENT_TYPE);
-            addName(names, CLASS_PATH);
-            addName(names, MAIN_CLASS);
-            addName(names, SEALED);
-            addName(names, EXTENSION_LIST);
-            addName(names, EXTENSION_NAME);
-            addName(names, IMPLEMENTATION_TITLE);
-            addName(names, IMPLEMENTATION_VERSION);
-            addName(names, IMPLEMENTATION_VENDOR);
-            addName(names, SPECIFICATION_TITLE);
-            addName(names, SPECIFICATION_VERSION);
-            addName(names, SPECIFICATION_VENDOR);
-            addName(names, MULTI_RELEASE);
-
-            // Common attributes used in MANIFEST.MF et.al; adding these has a
-            // small footprint cost, but is likely to be quickly paid for by
-            // reducing allocation when reading and parsing typical manifests
-            addName(names, new Name("Add-Exports"));
-            addName(names, new Name("Add-Opens"));
-            addName(names, new Name("Ant-Version"));
-            addName(names, new Name("Archiver-Version"));
-            addName(names, new Name("Build-Jdk"));
-            addName(names, new Name("Built-By"));
-            addName(names, new Name("Bnd-LastModified"));
-            addName(names, new Name("Bundle-Description"));
-            addName(names, new Name("Bundle-DocURL"));
-            addName(names, new Name("Bundle-License"));
-            addName(names, new Name("Bundle-ManifestVersion"));
-            addName(names, new Name("Bundle-Name"));
-            addName(names, new Name("Bundle-Vendor"));
-            addName(names, new Name("Bundle-Version"));
-            addName(names, new Name("Bundle-SymbolicName"));
-            addName(names, new Name("Created-By"));
-            addName(names, new Name("Export-Package"));
-            addName(names, new Name("Import-Package"));
-            addName(names, new Name("Name"));
-            addName(names, new Name("SHA1-Digest"));
-            addName(names, new Name("X-Compile-Source-JDK"));
-            addName(names, new Name("X-Compile-Target-JDK"));
-            KNOWN_NAMES = names;
+
+            VM.initializeFromArchive(Attributes.Name.class);
+
+            if (KNOWN_NAMES == null) {
+                MANIFEST_VERSION = new Name("Manifest-Version");
+                SIGNATURE_VERSION = new Name("Signature-Version");
+                CONTENT_TYPE = new Name("Content-Type");
+                CLASS_PATH = new Name("Class-Path");
+                MAIN_CLASS = new Name("Main-Class");
+                SEALED = new Name("Sealed");
+                EXTENSION_LIST = new Name("Extension-List");
+                EXTENSION_NAME = new Name("Extension-Name");
+                EXTENSION_INSTALLATION = new Name("Extension-Installation");
+                IMPLEMENTATION_TITLE = new Name("Implementation-Title");
+                IMPLEMENTATION_VERSION = new Name("Implementation-Version");
+                IMPLEMENTATION_VENDOR = new Name("Implementation-Vendor");
+                IMPLEMENTATION_VENDOR_ID = new Name("Implementation-Vendor-Id");
+                IMPLEMENTATION_URL = new Name("Implementation-URL");
+                SPECIFICATION_TITLE = new Name("Specification-Title");
+                SPECIFICATION_VERSION = new Name("Specification-Version");
+                SPECIFICATION_VENDOR = new Name("Specification-Vendor");
+                MULTI_RELEASE = new Name("Multi-Release");
+
+                var names = new HashMap<String, Name>(64);
+                addName(names, MANIFEST_VERSION);
+                addName(names, SIGNATURE_VERSION);
+                addName(names, CONTENT_TYPE);
+                addName(names, CLASS_PATH);
+                addName(names, MAIN_CLASS);
+                addName(names, SEALED);
+                addName(names, EXTENSION_LIST);
+                addName(names, EXTENSION_NAME);
+                addName(names, EXTENSION_INSTALLATION);
+                addName(names, IMPLEMENTATION_TITLE);
+                addName(names, IMPLEMENTATION_VERSION);
+                addName(names, IMPLEMENTATION_VENDOR);
+                addName(names, IMPLEMENTATION_VENDOR_ID);
+                addName(names, IMPLEMENTATION_URL);
+                addName(names, SPECIFICATION_TITLE);
+                addName(names, SPECIFICATION_VERSION);
+                addName(names, SPECIFICATION_VENDOR);
+                addName(names, MULTI_RELEASE);
+
+                // Common attributes used in MANIFEST.MF et.al; adding these has a
+                // small footprint cost, but is likely to be quickly paid for by
+                // reducing allocation when reading and parsing typical manifests
+
+                // JDK internal attributes
+                addName(names, new Name("Add-Exports"));
+                addName(names, new Name("Add-Opens"));
+                // LauncherHelper attributes
+                addName(names, new Name("Launcher-Agent-Class"));
+                addName(names, new Name("JavaFX-Application-Class"));
+                // jarsigner attributes
+                addName(names, new Name("Name"));
+                addName(names, new Name("Created-By"));
+                addName(names, new Name("SHA1-Digest"));
+                addName(names, new Name("SHA-256-Digest"));
+                KNOWN_NAMES = Map.copyOf(names);
+            } else {
+                // Even if KNOWN_NAMES was read from archive, we still need
+                // to initialize the public constants
+                MANIFEST_VERSION = KNOWN_NAMES.get("Manifest-Version");
+                SIGNATURE_VERSION = KNOWN_NAMES.get("Signature-Version");
+                CONTENT_TYPE = KNOWN_NAMES.get("Content-Type");
+                CLASS_PATH = KNOWN_NAMES.get("Class-Path");
+                MAIN_CLASS = KNOWN_NAMES.get("Main-Class");
+                SEALED = KNOWN_NAMES.get("Sealed");
+                EXTENSION_LIST = KNOWN_NAMES.get("Extension-List");
+                EXTENSION_NAME = KNOWN_NAMES.get("Extension-Name");
+                EXTENSION_INSTALLATION = KNOWN_NAMES.get("Extension-Installation");
+                IMPLEMENTATION_TITLE = KNOWN_NAMES.get("Implementation-Title");
+                IMPLEMENTATION_VERSION = KNOWN_NAMES.get("Implementation-Version");
+                IMPLEMENTATION_VENDOR = KNOWN_NAMES.get("Implementation-Vendor");
+                IMPLEMENTATION_VENDOR_ID = KNOWN_NAMES.get("Implementation-Vendor-Id");
+                IMPLEMENTATION_URL = KNOWN_NAMES.get("Implementation-URL");
+                SPECIFICATION_TITLE = KNOWN_NAMES.get("Specification-Title");
+                SPECIFICATION_VERSION = KNOWN_NAMES.get("Specification-Version");
+                SPECIFICATION_VENDOR = KNOWN_NAMES.get("Specification-Vendor");
+                MULTI_RELEASE = KNOWN_NAMES.get("Multi-Release");
+            }
         }
     }
 }

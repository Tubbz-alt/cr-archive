diff a/src/java.base/share/classes/java/util/regex/Pattern.java b/src/java.base/share/classes/java/util/regex/Pattern.java
--- a/src/java.base/share/classes/java/util/regex/Pattern.java
+++ b/src/java.base/share/classes/java/util/regex/Pattern.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,11 @@
 import java.util.Spliterators;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import jdk.internal.util.ArraysSupport;
 
 /**
  * A compiled representation of a regular expression.
  *
  * <p> A regular expression, specified as a string, must first be compiled into
@@ -75,11 +76,11 @@
  * <p> Instances of this class are immutable and are safe for use by multiple
  * concurrent threads.  Instances of the {@link Matcher} class are not safe for
  * such use.
  *
  *
- * <h3><a id="sum">Summary of regular-expression constructs</a></h3>
+ * <h2><a id="sum">Summary of regular-expression constructs</a></h2>
  *
  * <table class="borderless">
  * <caption style="display:none">Regular expression constructs, and what they match</caption>
  * <thead style="text-align:left">
  * <tr>
@@ -354,15 +355,15 @@
  * <tr><th style="vertical-align:top; font-weight:normal" id="flags"><code>(?idmsuxU-idmsuxU)&nbsp;</code></th>
  *     <td headers="matches special flags">Nothing, but turns match flags <a href="#CASE_INSENSITIVE">i</a>
  * <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a>
  * <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> <a href="#UNICODE_CHARACTER_CLASS">U</a>
  * on - off</td></tr>
- * <tr><th style="vertical-align:top; font-weight:normal" id="non_capture_group_flags"><code>(?idmsux-idmsux:</code><i>X</i>{@code )}&nbsp;&nbsp;</th>
+ * <tr><th style="vertical-align:top; font-weight:normal" id="non_capture_group_flags">{@code (?idmsuxU-idmsuxU:}<i>X</i>{@code )}&nbsp;&nbsp;</th>
  *     <td headers="matches special non_capture_group_flags"><i>X</i>, as a <a href="#cg">non-capturing group</a> with the
  *         given flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a>
  * <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a >
- * <a href="#COMMENTS">x</a> on - off</td></tr>
+ * <a href="#COMMENTS">x</a> <a href="#UNICODE_CHARACTER_CLASS">U</a> on - off</td></tr>
  * <tr><th style="vertical-align:top; font-weight:normal" id="pos_lookahead">{@code (?=}<i>X</i>{@code )}</th>
  *     <td headers="matches special pos_lookahead"><i>X</i>, via zero-width positive lookahead</td></tr>
  * <tr><th style="vertical-align:top; font-weight:normal" id="neg_lookahead">{@code (?!}<i>X</i>{@code )}</th>
  *     <td headers="matches special neg_lookahead"><i>X</i>, via zero-width negative lookahead</td></tr>
  * <tr><th style="vertical-align:top; font-weight:normal" id="pos_lookbehind">{@code (?<=}<i>X</i>{@code )}</th>
@@ -376,11 +377,11 @@
  * </table>
  *
  * <hr>
  *
  *
- * <h3><a id="bs">Backslashes, escapes, and quoting</a></h3>
+ * <h2><a id="bs">Backslashes, escapes, and quoting</a></h2>
  *
  * <p> The backslash character ({@code '\'}) serves to introduce escaped
  * constructs, as defined in the table above, as well as to quote characters
  * that otherwise would be interpreted as unescaped constructs.  Thus the
  * expression {@code \\} matches a single backslash and <code>\{</code> matches a
@@ -404,11 +405,11 @@
  * word boundary.  The string literal {@code "\(hello\)"} is illegal
  * and leads to a compile-time error; in order to match the string
  * {@code (hello)} the string literal {@code "\\(hello\\)"}
  * must be used.
  *
- * <h3><a id="cc">Character Classes</a></h3>
+ * <h2><a id="cc">Character Classes</a></h2>
  *
  *    <p> Character classes may appear within other character classes, and
  *    may be composed by the union operator (implicit) and the intersection
  *    operator ({@code &&}).
  *    The union operator denotes a class that contains every character that is
@@ -447,11 +448,11 @@
  *    a character class than outside a character class. For instance, the
  *    regular expression {@code .} loses its special meaning inside a
  *    character class, while the expression {@code -} becomes a range
  *    forming metacharacter.
  *
- * <h3><a id="lt">Line terminators</a></h3>
+ * <h2><a id="lt">Line terminators</a></h2>
  *
  * <p> A <i>line terminator</i> is a one- or two-character sequence that marks
  * the end of a line of the input character sequence.  The following are
  * recognized as line terminators:
  *
@@ -482,13 +483,13 @@
  * of the entire input sequence. If {@link #MULTILINE} mode is activated then
  * {@code ^} matches at the beginning of input and after any line terminator
  * except at the end of input. When in {@link #MULTILINE} mode {@code $}
  * matches just before a line terminator or the end of the input sequence.
  *
- * <h3><a id="cg">Groups and capturing</a></h3>
+ * <h2><a id="cg">Groups and capturing</a></h2>
  *
- * <h4><a id="gnumber">Group number</a></h4>
+ * <h3><a id="gnumber">Group number</a></h3>
  * <p> Capturing groups are numbered by counting their opening parentheses from
  * left to right.  In the expression {@code ((A)(B(C)))}, for example, there
  * are four such groups: </p>
  *
  * <ol style="margin-left:2em;">
@@ -503,11 +504,11 @@
  * <p> Capturing groups are so named because, during a match, each subsequence
  * of the input sequence that matches such a group is saved.  The captured
  * subsequence may be used later in the expression, via a back reference, and
  * may also be retrieved from the matcher once the match operation is complete.
  *
- * <h4><a id="groupname">Group name</a></h4>
+ * <h3><a id="groupname">Group name</a></h3>
  * <p>A capturing group can also be assigned a "name", a {@code named-capturing group},
  * and then be back-referenced later by the "name". Group names are composed of
  * the following characters. The first character must be a {@code letter}.
  *
  * <ul>
@@ -532,16 +533,16 @@
  *
  * <p> Groups beginning with {@code (?} are either pure, <i>non-capturing</i> groups
  * that do not capture text and do not count towards the group total, or
  * <i>named-capturing</i> group.
  *
- * <h3> Unicode support </h3>
+ * <h2> Unicode support </h2>
  *
  * <p> This class is in conformance with Level 1 of <a
  * href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical
  * Standard #18: Unicode Regular Expression</i></a>, plus RL2.1
- * Canonical Equivalents.
+ * Canonical Equivalents and RL2.2 Extended Grapheme Clusters.
  * <p>
  * <b>Unicode escape sequences</b> such as <code>&#92;u2014</code> in Java source code
  * are processed as described in section 3.3 of
  * <cite>The Java&trade; Language Specification</cite>.
  * Such escape sequences are also implemented directly by the regular-expression
@@ -686,11 +687,11 @@
  * Categories that behave like the java.lang.Character
  * boolean is<i>methodname</i> methods (except for the deprecated ones) are
  * available through the same <code>\p{</code><i>prop</i><code>}</code> syntax where
  * the specified property has the name <code>java<i>methodname</i></code></a>.
  *
- * <h3> Comparison to Perl 5 </h3>
+ * <h2> Comparison to Perl 5 </h2>
  *
  * <p>The {@code Pattern} engine performs traditional NFA-based matching
  * with ordered alternation as occurs in Perl 5.
  *
  * <p> Perl constructs not supported by this class: </p>
@@ -932,10 +933,11 @@
      * and the flags, which are all that is needed to recompile the pattern
      * when it is deserialized.
      */
 
     /** use serialVersionUID from Merlin b59 for interoperability */
+    @java.io.Serial
     private static final long serialVersionUID = 5073258162644648461L;
 
     /**
      * The original regular-expression pattern string.
      *
@@ -1373,10 +1375,11 @@
 
     /**
      * Recompile the Pattern instance from a stream.  The original pattern
      * string is read in and the object tree is recompiled from it.
      */
+    @java.io.Serial
     private void readObject(java.io.ObjectInputStream s)
         throws java.io.IOException, ClassNotFoundException {
 
         // Read in all fields
         s.defaultReadObject();
@@ -1422,11 +1425,15 @@
         capturingGroupCount = 1;
         localCount = 0;
         localTCNCount = 0;
 
         if (!pattern.isEmpty()) {
-            compile();
+            try {
+                compile();
+            } catch (StackOverflowError soe) {
+                throw error("Stack overflow during pattern compilation");
+            }
         } else {
             root = new Start(lastAccept);
             matchRoot = lastAccept;
         }
     }
@@ -1498,23 +1505,16 @@
             if (".$|()[]{}^?*+\\".indexOf(ch0) != -1) {
                 dst.append((char)ch0);
                 off++;
                 continue;
             }
-            int j = off + Character.charCount(ch0);
+            int j = Grapheme.nextBoundary(src, off, limit);
             int ch1;
-            while (j < limit) {
-                ch1 = src.codePointAt(j);
-                if (Grapheme.isBoundary(ch0, ch1))
-                    break;
-                ch0 = ch1;
-                j += Character.charCount(ch1);
-            }
             String seq = src.substring(off, j);
             String nfd = Normalizer.normalize(seq, Normalizer.Form.NFD);
             off = j;
-            if (nfd.length() > 1) {
+            if (nfd.codePointCount(0, nfd.length()) > 1) {
                 ch0 = nfd.codePointAt(0);
                 ch1 = nfd.codePointAt(Character.charCount(ch0));
                 if (Character.getType(ch1) == Character.NON_SPACING_MARK) {
                     Set<String> altns = new LinkedHashSet<>();
                     altns.add(seq);
@@ -1676,11 +1676,17 @@
         }
         if (i >= pLen - 1)    // No \Q sequence found
             return;
         int j = i;
         i += 2;
-        int[] newtemp = new int[j + 3*(pLen-i) + 2];
+        int newTempLen;
+        try {
+            newTempLen = Math.addExact(j + 2, Math.multiplyExact(3, pLen - i));
+        } catch (ArithmeticException ae) {
+            throw new OutOfMemoryError();
+        }
+        int[] newtemp = new int[newTempLen];
         System.arraycopy(temp, 0, newtemp, 0, j);
 
         boolean inQuote = true;
         boolean beginQuote = true;
         while (i < pLen) {
@@ -1961,20 +1967,28 @@
      */
     private int parsePastLine() {
         int ch = temp[cursor++];
         while (ch != 0 && !isLineSeparator(ch))
             ch = temp[cursor++];
+        if (ch == 0 && cursor > patternLength) {
+            cursor = patternLength;
+            ch = temp[cursor++];
+        }
         return ch;
     }
 
     /**
      * xmode peek past comment to end of line.
      */
     private int peekPastLine() {
         int ch = temp[++cursor];
         while (ch != 0 && !isLineSeparator(ch))
             ch = temp[++cursor];
+        if (ch == 0 && cursor > patternLength) {
+            cursor = patternLength;
+            ch = temp[cursor];
+        }
         return ch;
     }
 
     /**
      * Determines if character is a line separator in the current mode
@@ -2048,11 +2062,11 @@
      */
     private Node expr(Node end) {
         Node prev = null;
         Node firstTail = null;
         Branch branch = null;
-        Node branchConn = null;
+        BranchConn branchConn = null;
 
         for (;;) {
             Node node = sequence(end);
             Node nodeTail = root;      //double return
             if (prev == null) {
@@ -2098,11 +2112,11 @@
      * Parsing of sequences between alternations.
      */
     private Node sequence(Node end) {
         Node head = null;
         Node tail = null;
-        Node node = null;
+        Node node;
     LOOP:
         for (;;) {
             int ch = peek();
             switch (ch) {
             case '(':
@@ -2196,11 +2210,28 @@
             default:
                 node = atom();
                 break;
             }
 
-            node = closure(node);
+            if (node instanceof LineEnding) {
+                LineEnding le = (LineEnding)node;
+                node = closureOfLineEnding(le);
+
+                if (node != le) {
+                    // LineEnding was replaced with an anonymous group
+                    if (head == null)
+                        head = node;
+                    else
+                        tail.next = node;
+                    // Double return: Tail was returned in root
+                    tail = root;
+                    continue;
+                }
+            } else {
+                node = closure(node);
+            }
+
             /* save the top dot-greedy nodes (.*, .+) as well
             if (node instanceof GreedyCharProperty &&
                 ((GreedyCharProperty)node).cp instanceof Dot) {
                 topClosureNodes.add(node);
             }
@@ -2307,17 +2338,19 @@
         } else {
             return newSlice(buffer, first, hasSupplementary);
         }
     }
 
-    private void append(int ch, int len) {
-        if (len >= buffer.length) {
-            int[] tmp = new int[len+len];
-            System.arraycopy(buffer, 0, tmp, 0, len);
-            buffer = tmp;
+    private void append(int ch, int index) {
+        int len = buffer.length;
+        if (index - len >= 0) {
+            len = ArraysSupport.newLength(len,
+                    1 + index - len, /* minimum growth */
+                    len              /* preferred growth */);
+            buffer = Arrays.copyOf(buffer, len);
         }
-        buffer[len] = ch;
+        buffer[index] = ch;
     }
 
     /**
      * Parses a backref greedily, taking as many numbers as it
      * can. The first digit is always treated as a backref, but
@@ -2613,11 +2646,10 @@
      */
     private CharPredicate clazz(boolean consume) {
         CharPredicate prev = null;
         CharPredicate curr = null;
         BitClass bits = new BitClass();
-        BmpCharPredicate bitsP = ch -> ch < 256 && bits.bits[ch];
 
         boolean isNeg = false;
         boolean hasBits = false;
         int ch = next();
 
@@ -2654,13 +2686,13 @@
                             ch = peek();
                         }
                         if (hasBits) {
                             // bits used, union has high precedence
                             if (prev == null) {
-                                prev = curr = bitsP;
+                                prev = curr = bits;
                             } else {
-                                prev = prev.union(bitsP);
+                                prev = prev.union(bits);
                             }
                             hasBits = false;
                         }
                         if (right != null)
                             curr = right;
@@ -2685,13 +2717,13 @@
                 case ']':
                     if (prev != null || hasBits) {
                         if (consume)
                             next();
                         if (prev == null)
-                            prev = bitsP;
+                            prev = bits;
                         else if (hasBits)
-                            prev = prev.union(bitsP);
+                            prev = prev.union(bits);
                         if (isNeg)
                             return prev.negate();
                         return prev;
                     }
                     break;
@@ -2885,25 +2917,25 @@
             if (name.startsWith("In")) {
                 // \p{InBlockName}
                 p = CharPredicates.forUnicodeBlock(name.substring(2));
             } else if (name.startsWith("Is")) {
                 // \p{IsGeneralCategory} and \p{IsScriptName}
-                name = name.substring(2);
-                p = CharPredicates.forUnicodeProperty(name);
+                String shortName = name.substring(2);
+                p = CharPredicates.forUnicodeProperty(shortName);
                 if (p == null)
-                    p = CharPredicates.forProperty(name);
+                    p = CharPredicates.forProperty(shortName);
                 if (p == null)
-                    p = CharPredicates.forUnicodeScript(name);
+                    p = CharPredicates.forUnicodeScript(shortName);
             } else {
                 if (has(UNICODE_CHARACTER_CLASS)) {
                     p = CharPredicates.forPOSIXName(name);
                 }
                 if (p == null)
                     p = CharPredicates.forProperty(name);
             }
             if (p == null)
-                throw error("Unknown character property name {In/Is" + name + "}");
+                throw error("Unknown character property name {" + name + "}");
         }
         if (isComplement) {
             // it might be too expensive to detect if a complement of
             // CharProperty can match "certain" supplementary. So just
             // go with StartS.
@@ -2943,12 +2975,12 @@
      * the group. Sometimes a double return system is used where the tail is
      * returned in root.
      */
     private Node group0() {
         boolean capturingGroup = false;
-        Node head = null;
-        Node tail = null;
+        Node head;
+        Node tail;
         int save = flags0;
         int saveTCNCount = topClosureNodes.size();
         root = null;
         int ch = next();
         if (ch == '?') {
@@ -2993,11 +3025,11 @@
                 }
                 int start = cursor;
                 head = createGroup(true);
                 tail = root;
                 head.next = expr(tail);
-                tail.next = lookbehindEnd;
+                tail.next = LookBehindEndNode.INSTANCE;
                 TreeInfo info = new TreeInfo();
                 head.study(info);
                 if (info.maxValid == false) {
                     throw error("Look-behind group does not have "
                                 + "an obvious maximum length");
@@ -3062,22 +3094,35 @@
         // have group closure, clear all inner closure nodes from the
         // top list (no backtracking stopper optimization for inner
         if (saveTCNCount < topClosureNodes.size())
             topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
 
+        return groupWithClosure(node, head, tail, capturingGroup);
+    }
+
+    /**
+     * Transforms a Group with quantifiers into some special constructs
+     * (such as Branch or Loop/GroupCurly), if necessary.
+     *
+     * This method is applied either to actual groups or to the Unicode
+     * linebreak (aka \\R) represented as an anonymous group.
+     */
+    private Node groupWithClosure(Node node, Node head, Node tail,
+                                  boolean capturingGroup)
+    {
         if (node instanceof Ques) {
             Ques ques = (Ques) node;
             if (ques.type == Qtype.POSSESSIVE) {
                 root = node;
                 return node;
             }
-            tail.next = new BranchConn();
-            tail = tail.next;
+            BranchConn branchConn = new BranchConn();
+            tail = tail.next = branchConn;
             if (ques.type == Qtype.GREEDY) {
-                head = new Branch(head, null, tail);
+                head = new Branch(head, null, branchConn);
             } else { // Reluctant quantifier
-                head = new Branch(null, head, tail);
+                head = new Branch(null, head, branchConn);
             }
             root = tail;
             return head;
         } else if (node instanceof Curly) {
             Curly curly = (Curly) node;
@@ -3226,86 +3271,109 @@
 
     static enum Qtype {
         GREEDY, LAZY, POSSESSIVE, INDEPENDENT
     }
 
-    private Node curly(Node prev, int cmin) {
+    private Qtype qtype() {
         int ch = next();
         if (ch == '?') {
             next();
-            return new Curly(prev, cmin, MAX_REPS, Qtype.LAZY);
+            return Qtype.LAZY;
         } else if (ch == '+') {
             next();
-            return new Curly(prev, cmin, MAX_REPS, Qtype.POSSESSIVE);
+            return Qtype.POSSESSIVE;
         }
-        if (prev instanceof BmpCharProperty) {
-            return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);
-        } else if (prev instanceof CharProperty) {
-            return new CharPropertyGreedy((CharProperty)prev, cmin);
+        return Qtype.GREEDY;
+    }
+
+    private Node curly(Node prev, int cmin) {
+        Qtype qtype = qtype();
+        if (qtype == Qtype.GREEDY) {
+            if (prev instanceof BmpCharProperty) {
+                return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);
+            } else if (prev instanceof CharProperty) {
+                return new CharPropertyGreedy((CharProperty)prev, cmin);
+            }
         }
-        return new Curly(prev, cmin, MAX_REPS, Qtype.GREEDY);
+        return new Curly(prev, cmin, MAX_REPS, qtype);
+    }
+
+    /**
+     * Processing repetition of a Unicode linebreak \\R.
+     */
+    private Node closureOfLineEnding(LineEnding le) {
+        int ch = peek();
+        if (ch != '?' && ch != '*' && ch != '+' && ch != '{') {
+            return le;
+        }
+
+        // Replace the LineEnding with an anonymous group
+        // (?:\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029])
+        Node grHead = createGroup(true);
+        Node grTail = root;
+        BranchConn branchConn = new BranchConn();
+        branchConn.next = grTail;
+        Node slice = new Slice(new int[] {0x0D, 0x0A});
+        slice.next = branchConn;
+        Node chClass = newCharProperty(x -> x == 0x0A || x == 0x0B ||
+                x == 0x0C || x == 0x0D || x == 0x85 || x == 0x2028 ||
+                x == 0x2029);
+        chClass.next = branchConn;
+        grHead.next = new Branch(slice, chClass, branchConn);
+        return groupWithClosure(closure(grHead), grHead, grTail, false);
     }
 
     /**
      * Processes repetition. If the next character peeked is a quantifier
      * then new nodes must be appended to handle the repetition.
      * Prev could be a single or a group, so it could be a chain of nodes.
      */
     private Node closure(Node prev) {
-        Node atom;
         int ch = peek();
         switch (ch) {
         case '?':
-            ch = next();
-            if (ch == '?') {
-                next();
-                return new Ques(prev, Qtype.LAZY);
-            } else if (ch == '+') {
-                next();
-                return new Ques(prev, Qtype.POSSESSIVE);
-            }
-            return new Ques(prev, Qtype.GREEDY);
+            return new Ques(prev, qtype());
         case '*':
             return curly(prev, 0);
         case '+':
             return curly(prev, 1);
         case '{':
-            ch = temp[cursor+1];
+            ch = skip();
             if (ASCII.isDigit(ch)) {
-                skip();
-                int cmin = 0;
-                do {
-                    cmin = cmin * 10 + (ch - '0');
-                } while (ASCII.isDigit(ch = read()));
-                int cmax = cmin;
-                if (ch == ',') {
-                    ch = read();
-                    cmax = MAX_REPS;
-                    if (ch != '}') {
-                        cmax = 0;
-                        while (ASCII.isDigit(ch)) {
-                            cmax = cmax * 10 + (ch - '0');
-                            ch = read();
+                int cmin = 0, cmax;
+                try {
+                    do {
+                        cmin = Math.addExact(Math.multiplyExact(cmin, 10),
+                                             ch - '0');
+                    } while (ASCII.isDigit(ch = read()));
+                    if (ch == ',') {
+                        ch = read();
+                        if (ch == '}') {
+                            unread();
+                            return curly(prev, cmin);
+                        } else {
+                            cmax = 0;
+                            while (ASCII.isDigit(ch)) {
+                                cmax = Math.addExact(Math.multiplyExact(cmax, 10),
+                                                     ch - '0');
+                                ch = read();
+                            }
                         }
+                    } else {
+                        cmax = cmin;
                     }
+                } catch (ArithmeticException ae) {
+                    throw error("Illegal repetition range");
                 }
                 if (ch != '}')
                     throw error("Unclosed counted closure");
-                if (((cmin) | (cmax) | (cmax - cmin)) < 0)
+                if (cmax < cmin)
                     throw error("Illegal repetition range");
-                Curly curly;
-                ch = peek();
-                if (ch == '?') {
-                    next();
-                    curly = new Curly(prev, cmin, cmax, Qtype.LAZY);
-                } else if (ch == '+') {
-                    next();
-                    curly = new Curly(prev, cmin, cmax, Qtype.POSSESSIVE);
-                } else {
-                    curly = new Curly(prev, cmin, cmax, Qtype.GREEDY);
-                }
-                return curly;
+                unread();
+                return (cmin == 0 && cmax == 1)
+                        ? new Ques(prev, qtype())
+                        : new Curly(prev, cmin, cmax, qtype());
             } else {
                 throw error("Illegal repetition");
             }
         default:
             return prev;
@@ -3405,13 +3473,14 @@
     }
 
     private int N() {
         if (read() == '{') {
             int i = cursor;
-            while (cursor < patternLength && read() != '}') {}
-            if (cursor > patternLength)
-                throw error("Unclosed character name escape sequence");
+            while (read() != '}') {
+                if (cursor >= patternLength)
+                    throw error("Unclosed character name escape sequence");
+            }
             String name = new String(temp, i, cursor - i - 1);
             try {
                 return Character.codePointOf(name);
             } catch (IllegalArgumentException x) {
                 throw error("Unknown character name [" + name + "]");
@@ -3476,18 +3545,14 @@
     /**
      *  Creates a bit vector for matching Latin-1 values. A normal BitClass
      *  never matches values above Latin-1, and a complemented BitClass always
      *  matches values above Latin-1.
      */
-    static final class BitClass extends BmpCharProperty {
+    static final class BitClass implements BmpCharPredicate {
         final boolean[] bits;
         BitClass() {
-            this(new boolean[256]);
-        }
-        private BitClass(boolean[] bits) {
-            super( ch -> ch < 256 && bits[ch]);
-            this.bits = bits;
+            bits = new boolean[256];
         }
         BitClass add(int c, int flags) {
             assert c >= 0 && c <= 255;
             if ((flags & CASE_INSENSITIVE) != 0) {
                 if (ASCII.isAscii(c)) {
@@ -3499,12 +3564,16 @@
                 }
             }
             bits[c] = true;
             return this;
         }
+        public boolean is(int ch) {
+            return ch < 256 && bits[ch];
+        }
     }
 
+
     /**
      *  Utility method for creating a string slice matcher.
      */
     private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
         int[] tmp = new int[count];
@@ -3913,24 +3982,26 @@
     /**
      * Abstract node class to match one character satisfying some
      * boolean property.
      */
     static class CharProperty extends Node {
-        CharPredicate predicate;
+        final CharPredicate predicate;
 
         CharProperty (CharPredicate predicate) {
             this.predicate = predicate;
         }
         boolean match(Matcher matcher, int i, CharSequence seq) {
             if (i < matcher.to) {
                 int ch = Character.codePointAt(seq, i);
-                return predicate.is(ch) &&
-                       next.match(matcher, i + Character.charCount(ch), seq);
-            } else {
-                matcher.hitEnd = true;
-                return false;
+                i += Character.charCount(ch);
+                if (i <= matcher.to) {
+                    return predicate.is(ch) &&
+                           next.match(matcher, i, seq);
+                }
             }
+            matcher.hitEnd = true;
+            return false;
         }
         boolean study(TreeInfo info) {
             info.minLength++;
             info.maxLength++;
             return next.study(info);
@@ -3965,10 +4036,12 @@
         boolean match(Matcher matcher, int i, CharSequence seq) {
             if (i < matcher.to) {
                 int ch0 = Character.codePointAt(seq, i);
                 int n = Character.charCount(ch0);
                 int j = i + n;
+                // Fast check if it's necessary to call Normalizer;
+                // testing Grapheme.isBoundary is enough for this case
                 while (j < matcher.to) {
                     int ch1 = Character.codePointAt(seq, j);
                     if (Grapheme.isBoundary(ch0, ch1))
                         break;
                     ch0 = ch1;
@@ -4010,19 +4083,11 @@
      * Node class that matches an unicode extended grapheme cluster
      */
     static class XGrapheme extends Node {
         boolean match(Matcher matcher, int i, CharSequence seq) {
             if (i < matcher.to) {
-                int ch0 = Character.codePointAt(seq, i);
-                    i += Character.charCount(ch0);
-                while (i < matcher.to) {
-                    int ch1 = Character.codePointAt(seq, i);
-                    if (Grapheme.isBoundary(ch0, ch1))
-                        break;
-                    ch0 = ch1;
-                    i += Character.charCount(ch1);
-                }
+                i = Grapheme.nextBoundary(seq, i, matcher.to);
                 return next.match(matcher, i, seq);
             }
             matcher.hitEnd = true;
             return false;
         }
@@ -4048,12 +4113,13 @@
             if (i == startIndex) {
                 return next.match(matcher, i, seq);
             }
             if (i < endIndex) {
                 if (Character.isSurrogatePair(seq.charAt(i-1), seq.charAt(i)) ||
-                    !Grapheme.isBoundary(Character.codePointBefore(seq, i),
-                                         Character.codePointAt(seq, i))) {
+                    Grapheme.nextBoundary(seq,
+                        i - Character.charCount(Character.codePointBefore(seq, i)),
+                        i + Character.charCount(Character.codePointAt(seq, i))) > i) {
                     return false;
                 }
             } else {
                 matcher.hitEnd = true;
                 matcher.requireEnd = true;
@@ -4262,22 +4328,22 @@
             }
         }
     }
 
     /**
-     * Handles the greedy style repetition with the minimum either be
-     * 0 or 1 and the maximum be MAX_REPS, for * and + quantifier.
+     * Handles the greedy style repetition with the specified minimum
+     * and the maximum equal to MAX_REPS, for *, + and {N,} quantifiers.
      */
     static class CharPropertyGreedy extends Node {
         final CharPredicate predicate;
         final int cmin;
 
         CharPropertyGreedy(CharProperty cp, int cmin) {
             this.predicate = cp.predicate;
             this.cmin = cmin;
         }
-        boolean match(Matcher matcher, int i,  CharSequence seq) {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
             int n = 0;
             int to = matcher.to;
             // greedy, all the way down
             while (i < to) {
                 int ch = Character.codePointAt(seq, i);
@@ -4316,11 +4382,11 @@
 
         BmpCharPropertyGreedy(BmpCharProperty bcp, int cmin) {
             super(bcp, cmin);
         }
 
-        boolean match(Matcher matcher, int i,  CharSequence seq) {
+        boolean match(Matcher matcher, int i, CharSequence seq) {
             int n = 0;
             int to = matcher.to;
             while (i < to && predicate.is(seq.charAt(i))) {
                 i++; n++;
             }
@@ -4693,11 +4759,11 @@
      * "next" but not the "study", so we can collect the TreeInfo
      * of each atom node without including the TreeInfo of the
      * "next".
      */
     static final class BranchConn extends Node {
-        BranchConn() {};
+        BranchConn() {}
         boolean match(Matcher matcher, int i, CharSequence seq) {
             return next.match(matcher, i, seq);
         }
         boolean study(TreeInfo info) {
             return info.deterministic;
@@ -4710,22 +4776,23 @@
      * and where it does not occur.
      */
     static final class Branch extends Node {
         Node[] atoms = new Node[2];
         int size = 2;
-        Node conn;
-        Branch(Node first, Node second, Node branchConn) {
+        BranchConn conn;
+        Branch(Node first, Node second, BranchConn branchConn) {
             conn = branchConn;
             atoms[0] = first;
             atoms[1] = second;
         }
 
         void add(Node node) {
             if (size >= atoms.length) {
-                Node[] tmp = new Node[atoms.length*2];
-                System.arraycopy(atoms, 0, tmp, 0, atoms.length);
-                atoms = tmp;
+                int len = ArraysSupport.newLength(size,
+                        1,    /* minimum growth */
+                        size  /* preferred growth */);
+                atoms = Arrays.copyOf(atoms, len);
             }
             atoms[size++] = node;
         }
 
         boolean match(Matcher matcher, int i, CharSequence seq) {
@@ -4790,38 +4857,10 @@
             matcher.locals[localIndex] = i;
             boolean ret = next.match(matcher, i, seq);
             matcher.locals[localIndex] = save;
             return ret;
         }
-        boolean matchRef(Matcher matcher, int i, CharSequence seq) {
-            int save = matcher.locals[localIndex];
-            matcher.locals[localIndex] = ~i; // HACK
-            boolean ret = next.match(matcher, i, seq);
-            matcher.locals[localIndex] = save;
-            return ret;
-        }
-    }
-
-    /**
-     * Recursive reference to a group in the regular expression. It calls
-     * matchRef because if the reference fails to match we would not unset
-     * the group.
-     */
-    static final class GroupRef extends Node {
-        GroupHead head;
-        GroupRef(GroupHead head) {
-            this.head = head;
-        }
-        boolean match(Matcher matcher, int i, CharSequence seq) {
-            return head.matchRef(matcher, i, seq)
-                && next.match(matcher, matcher.last, seq);
-        }
-        boolean study(TreeInfo info) {
-            info.maxValid = false;
-            info.deterministic = false;
-            return next.study(info);
-        }
     }
 
     /**
      * The GroupTail handles the setting of group beginning and ending
      * locations when groups are successfully matched. It must also be able to
@@ -4939,11 +4978,11 @@
             }
             return next.match(matcher, i, seq);
         }
         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
             int save = matcher.locals[countIndex];
-            boolean ret = false;
+            boolean ret;
             if (posIndex != -1 && matcher.localsPos[posIndex] == null) {
                 matcher.localsPos[posIndex] = new IntHashSet();
             }
             if (0 < cmin) {
                 matcher.locals[countIndex] = 1;
@@ -5153,56 +5192,21 @@
             info.deterministic = false;
             return next.study(info);
         }
     }
 
-    static final class Conditional extends Node {
-        Node cond, yes, not;
-        Conditional(Node cond, Node yes, Node not) {
-            this.cond = cond;
-            this.yes = yes;
-            this.not = not;
-        }
-        boolean match(Matcher matcher, int i, CharSequence seq) {
-            if (cond.match(matcher, i, seq)) {
-                return yes.match(matcher, i, seq);
-            } else {
-                return not.match(matcher, i, seq);
-            }
-        }
-        boolean study(TreeInfo info) {
-            int minL = info.minLength;
-            int maxL = info.maxLength;
-            boolean maxV = info.maxValid;
-            info.reset();
-            yes.study(info);
-
-            int minL2 = info.minLength;
-            int maxL2 = info.maxLength;
-            boolean maxV2 = info.maxValid;
-            info.reset();
-            not.study(info);
-
-            info.minLength = minL + Math.min(minL2, info.minLength);
-            info.maxLength = maxL + Math.max(maxL2, info.maxLength);
-            info.maxValid = (maxV & maxV2 & info.maxValid);
-            info.deterministic = false;
-            return next.study(info);
-        }
-    }
-
     /**
      * Zero width positive lookahead.
      */
     static final class Pos extends Node {
         Node cond;
         Pos(Node cond) {
             this.cond = cond;
         }
         boolean match(Matcher matcher, int i, CharSequence seq) {
             int savedTo = matcher.to;
-            boolean conditionMatched = false;
+            boolean conditionMatched;
 
             // Relax transparent region boundaries for lookahead
             if (matcher.transparentBounds)
                 matcher.to = matcher.getTextLength();
             try {
@@ -5223,11 +5227,11 @@
         Neg(Node cond) {
             this.cond = cond;
         }
         boolean match(Matcher matcher, int i, CharSequence seq) {
             int savedTo = matcher.to;
-            boolean conditionMatched = false;
+            boolean conditionMatched;
 
             // Relax transparent region boundaries for lookahead
             if (matcher.transparentBounds)
                 matcher.to = matcher.getTextLength();
             try {
@@ -5249,15 +5253,19 @@
 
     /**
      * For use with lookbehinds; matches the position where the lookbehind
      * was encountered.
      */
-    static Node lookbehindEnd = new Node() {
+    static class LookBehindEndNode extends Node {
+        private LookBehindEndNode() {} // Singleton
+
+        static LookBehindEndNode INSTANCE = new LookBehindEndNode();
+
         boolean match(Matcher matcher, int i, CharSequence seq) {
             return i == matcher.lookbehindTo;
         }
-    };
+    }
 
     /**
      * Zero width positive lookbehind.
      */
     static class Behind extends Node {
@@ -5521,11 +5529,11 @@
             // a shift larger than the pattern length cannot
             // be used anyway.
             if (patternLength < 4) {
                 return node;
             }
-            int i, j, k;
+            int i, j;
             int[] lastOcc = new int[128];
             int[] optoSft = new int[patternLength];
             // Precalculate part of the bad character shift
             // It is a table for where in the pattern each
             // lower 7-bit value occurs
@@ -5676,11 +5684,11 @@
     }
 
     static interface BmpCharPredicate extends CharPredicate {
 
         default CharPredicate and(CharPredicate p) {
-            if(p instanceof BmpCharPredicate)
+            if (p instanceof BmpCharPredicate)
                 return (BmpCharPredicate)(ch -> is(ch) && p.is(ch));
             return ch -> is(ch) && p.is(ch);
         }
         default CharPredicate union(CharPredicate p) {
             if (p instanceof BmpCharPredicate)

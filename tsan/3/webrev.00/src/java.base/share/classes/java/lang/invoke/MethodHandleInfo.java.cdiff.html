<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodHandleInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleProxies.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,19 ***</span>
  
  /**
   * A symbolic reference obtained by cracking a direct method handle
   * into its consitutent symbolic parts.
   * To crack a direct method handle, call {@link Lookup#revealDirect Lookup.revealDirect}.
<span class="line-modified">!  * &lt;h1&gt;&lt;a id=&quot;directmh&quot;&gt;&lt;/a&gt;Direct Method Handles&lt;/h1&gt;</span>
   * A &lt;em&gt;direct method handle&lt;/em&gt; represents a method, constructor, or field without
   * any intervening argument bindings or other transformations.
   * The method, constructor, or field referred to by a direct method handle is called
   * its &lt;em&gt;underlying member&lt;/em&gt;.
   * Direct method handles may be obtained in any of these ways:
   * &lt;ul&gt;
   * &lt;li&gt;By executing an {@code ldc} instruction on a {@code CONSTANT_MethodHandle} constant.
<span class="line-modified">!  *     (See the Java Virtual Machine Specification, sections 4.4.8 and 5.4.3.)</span>
   * &lt;li&gt;By calling one of the &lt;a href=&quot;MethodHandles.Lookup.html#lookups&quot;&gt;Lookup Factory Methods&lt;/a&gt;,
   *     such as {@link Lookup#findVirtual Lookup.findVirtual},
   *     to resolve a symbolic reference into a method handle.
   *     A symbolic reference consists of a class, name string, and type.
   * &lt;li&gt;By calling the factory method {@link Lookup#unreflect Lookup.unreflect}
<span class="line-new-header">--- 33,20 ---</span>
  
  /**
   * A symbolic reference obtained by cracking a direct method handle
   * into its consitutent symbolic parts.
   * To crack a direct method handle, call {@link Lookup#revealDirect Lookup.revealDirect}.
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;directmh&quot;&gt;&lt;/a&gt;Direct Method Handles&lt;/h2&gt;</span>
   * A &lt;em&gt;direct method handle&lt;/em&gt; represents a method, constructor, or field without
   * any intervening argument bindings or other transformations.
   * The method, constructor, or field referred to by a direct method handle is called
   * its &lt;em&gt;underlying member&lt;/em&gt;.
   * Direct method handles may be obtained in any of these ways:
   * &lt;ul&gt;
   * &lt;li&gt;By executing an {@code ldc} instruction on a {@code CONSTANT_MethodHandle} constant.
<span class="line-modified">!  *     (See the Java Virtual Machine Specification, sections {@jvms</span>
<span class="line-added">+  *     4.4.8} and {@jvms 5.4.3}.)</span>
   * &lt;li&gt;By calling one of the &lt;a href=&quot;MethodHandles.Lookup.html#lookups&quot;&gt;Lookup Factory Methods&lt;/a&gt;,
   *     such as {@link Lookup#findVirtual Lookup.findVirtual},
   *     to resolve a symbolic reference into a method handle.
   *     A symbolic reference consists of a class, name string, and type.
   * &lt;li&gt;By calling the factory method {@link Lookup#unreflect Lookup.unreflect}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,11 ***</span>
   * &lt;li&gt;By calling the factory method {@link Lookup#unreflectGetter Lookup.unreflectGetter}
   *     or {@link Lookup#unreflectSetter Lookup.unreflectSetter}
   *     to convert a {@link Field} into a method handle.
   * &lt;/ul&gt;
   *
<span class="line-modified">!  * &lt;h1&gt;Restrictions on Cracking&lt;/h1&gt;</span>
   * Given a suitable {@code Lookup} object, it is possible to crack any direct method handle
   * to recover a symbolic reference for the underlying method, constructor, or field.
   * Cracking must be done via a {@code Lookup} object equivalent to that which created
   * the target method handle, or which has enough access permissions to recreate
   * an equivalent method handle.
<span class="line-new-header">--- 57,11 ---</span>
   * &lt;li&gt;By calling the factory method {@link Lookup#unreflectGetter Lookup.unreflectGetter}
   *     or {@link Lookup#unreflectSetter Lookup.unreflectSetter}
   *     to convert a {@link Field} into a method handle.
   * &lt;/ul&gt;
   *
<span class="line-modified">!  * &lt;h2&gt;Restrictions on Cracking&lt;/h2&gt;</span>
   * Given a suitable {@code Lookup} object, it is possible to crack any direct method handle
   * to recover a symbolic reference for the underlying method, constructor, or field.
   * Cracking must be done via a {@code Lookup} object equivalent to that which created
   * the target method handle, or which has enough access permissions to recreate
   * an equivalent method handle.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,11 ***</span>
   * The requirement of lookup object matching provides a &quot;fast fail&quot; behavior
   * for programs which may otherwise trust erroneous revelation of a method
   * handle with symbolic information (or caller binding) from an unexpected scope.
   * Use {@link java.lang.invoke.MethodHandles#reflectAs} to override this limitation.
   *
<span class="line-modified">!  * &lt;h1&gt;&lt;a id=&quot;refkinds&quot;&gt;&lt;/a&gt;Reference kinds&lt;/h1&gt;</span>
   * The &lt;a href=&quot;MethodHandles.Lookup.html#lookups&quot;&gt;Lookup Factory Methods&lt;/a&gt;
   * correspond to all major use cases for methods, constructors, and fields.
   * These use cases may be distinguished using small integers as follows:
   * &lt;table class=&quot;striped&quot;&gt;
   * &lt;caption style=&quot;display:none&quot;&gt;reference kinds&lt;/caption&gt;
<span class="line-new-header">--- 76,11 ---</span>
   * The requirement of lookup object matching provides a &quot;fast fail&quot; behavior
   * for programs which may otherwise trust erroneous revelation of a method
   * handle with symbolic information (or caller binding) from an unexpected scope.
   * Use {@link java.lang.invoke.MethodHandles#reflectAs} to override this limitation.
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;refkinds&quot;&gt;&lt;/a&gt;Reference kinds&lt;/h2&gt;</span>
   * The &lt;a href=&quot;MethodHandles.Lookup.html#lookups&quot;&gt;Lookup Factory Methods&lt;/a&gt;
   * correspond to all major use cases for methods, constructors, and fields.
   * These use cases may be distinguished using small integers as follows:
   * &lt;table class=&quot;striped&quot;&gt;
   * &lt;caption style=&quot;display:none&quot;&gt;reference kinds&lt;/caption&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,12 ***</span>
   * &lt;/tr&gt;
   * &lt;/tbody&gt;
   * &lt;/table&gt;
   * @since 1.8
   */
<span class="line-modified">! public</span>
<span class="line-removed">- interface MethodHandleInfo {</span>
      /**
       * A direct method handle reference kind,
       * as defined in the &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;table above&lt;/a&gt;.
       */
      public static final int
<span class="line-new-header">--- 126,11 ---</span>
   * &lt;/tr&gt;
   * &lt;/tbody&gt;
   * &lt;/table&gt;
   * @since 1.8
   */
<span class="line-modified">! public interface MethodHandleInfo {</span>
      /**
       * A direct method handle reference kind,
       * as defined in the &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;table above&lt;/a&gt;.
       */
      public static final int
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,13 ***</span>
       * The underlying member must be accessible to the given lookup object.
       * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
       * @param expected a class object representing the desired result type {@code T}
       * @param lookup the lookup object that created this MethodHandleInfo, or one with equivalent access privileges
       * @return a reference to the method, constructor, or field object
<span class="line-modified">!      * @exception ClassCastException if the member is not of the expected type</span>
<span class="line-modified">!      * @exception NullPointerException if either argument is {@code null}</span>
<span class="line-modified">!      * @exception IllegalArgumentException if the underlying member is not accessible to the given lookup object</span>
       */
      public &lt;T extends Member&gt; T reflectAs(Class&lt;T&gt; expected, Lookup lookup);
  
      /**
       * Returns the access modifiers of the underlying member.
<span class="line-new-header">--- 197,13 ---</span>
       * The underlying member must be accessible to the given lookup object.
       * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
       * @param expected a class object representing the desired result type {@code T}
       * @param lookup the lookup object that created this MethodHandleInfo, or one with equivalent access privileges
       * @return a reference to the method, constructor, or field object
<span class="line-modified">!      * @throws    ClassCastException if the member is not of the expected type</span>
<span class="line-modified">!      * @throws    NullPointerException if either argument is {@code null}</span>
<span class="line-modified">!      * @throws    IllegalArgumentException if the underlying member is not accessible to the given lookup object</span>
       */
      public &lt;T extends Member&gt; T reflectAs(Class&lt;T&gt; expected, Lookup lookup);
  
      /**
       * Returns the access modifiers of the underlying member.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,11 ***</span>
       * Returns the descriptive name of the given reference kind,
       * as defined in the &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;table above&lt;/a&gt;.
       * The conventional prefix &quot;REF_&quot; is omitted.
       * @param referenceKind an integer code for a kind of reference used to access a class member
       * @return a mixed-case string such as {@code &quot;getField&quot;}
<span class="line-modified">!      * @exception IllegalArgumentException if the argument is not a valid</span>
       *            &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;reference kind number&lt;/a&gt;
       */
      public static String referenceKindToString(int referenceKind) {
          if (!MethodHandleNatives.refKindIsValid(referenceKind))
              throw newIllegalArgumentException(&quot;invalid reference kind&quot;, referenceKind);
<span class="line-new-header">--- 241,11 ---</span>
       * Returns the descriptive name of the given reference kind,
       * as defined in the &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;table above&lt;/a&gt;.
       * The conventional prefix &quot;REF_&quot; is omitted.
       * @param referenceKind an integer code for a kind of reference used to access a class member
       * @return a mixed-case string such as {@code &quot;getField&quot;}
<span class="line-modified">!      * @throws    IllegalArgumentException if the argument is not a valid</span>
       *            &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;reference kind number&lt;/a&gt;
       */
      public static String referenceKindToString(int referenceKind) {
          if (!MethodHandleNatives.refKindIsValid(referenceKind))
              throw newIllegalArgumentException(&quot;invalid reference kind&quot;, referenceKind);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 276,13 ***</span>
       * @param kind the {@linkplain #getReferenceKind reference kind} part of the symbolic reference
       * @param defc the {@linkplain #getDeclaringClass declaring class} part of the symbolic reference
       * @param name the {@linkplain #getName member name} part of the symbolic reference
       * @param type the {@linkplain #getMethodType method type} part of the symbolic reference
       * @return a string of the form {@code &quot;RK C.N:MT&quot;}
<span class="line-modified">!      * @exception IllegalArgumentException if the first argument is not a valid</span>
       *            &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;reference kind number&lt;/a&gt;
<span class="line-modified">!      * @exception NullPointerException if any reference argument is {@code null}</span>
       */
      public static String toString(int kind, Class&lt;?&gt; defc, String name, MethodType type) {
          Objects.requireNonNull(name); Objects.requireNonNull(type);
          return String.format(&quot;%s %s.%s:%s&quot;, referenceKindToString(kind), defc.getName(), name, type);
      }
<span class="line-new-header">--- 276,13 ---</span>
       * @param kind the {@linkplain #getReferenceKind reference kind} part of the symbolic reference
       * @param defc the {@linkplain #getDeclaringClass declaring class} part of the symbolic reference
       * @param name the {@linkplain #getName member name} part of the symbolic reference
       * @param type the {@linkplain #getMethodType method type} part of the symbolic reference
       * @return a string of the form {@code &quot;RK C.N:MT&quot;}
<span class="line-modified">!      * @throws    IllegalArgumentException if the first argument is not a valid</span>
       *            &lt;a href=&quot;MethodHandleInfo.html#refkinds&quot;&gt;reference kind number&lt;/a&gt;
<span class="line-modified">!      * @throws    NullPointerException if any reference argument is {@code null}</span>
       */
      public static String toString(int kind, Class&lt;?&gt; defc, String name, MethodType type) {
          Objects.requireNonNull(name); Objects.requireNonNull(type);
          return String.format(&quot;%s %s.%s:%s&quot;, referenceKindToString(kind), defc.getName(), name, type);
      }
</pre>
<center><a href="MethodHandleImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleProxies.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/text/NumberFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.io.ObjectOutputStream;
  45 import java.math.BigInteger;
  46 import java.math.RoundingMode;
  47 import java.text.spi.NumberFormatProvider;
  48 import java.util.Currency;
  49 import java.util.HashMap;
  50 import java.util.Locale;
  51 import java.util.Map;
  52 import java.util.Objects;
  53 import java.util.concurrent.atomic.AtomicInteger;
  54 import java.util.concurrent.atomic.AtomicLong;
  55 import sun.util.locale.provider.LocaleProviderAdapter;
  56 import sun.util.locale.provider.LocaleServiceProviderPool;
  57 
  58 /**
<a name="2" id="anc2"></a><span class="line-modified">  59  * &lt;code&gt;NumberFormat&lt;/code&gt; is the abstract base class for all number</span>
  60  * formats. This class provides the interface for formatting and parsing
<a name="3" id="anc3"></a><span class="line-modified">  61  * numbers. &lt;code&gt;NumberFormat&lt;/code&gt; also provides methods for determining</span>
  62  * which locales have number formats, and what their names are.
  63  *
  64  * &lt;p&gt;
<a name="4" id="anc4"></a><span class="line-modified">  65  * &lt;code&gt;NumberFormat&lt;/code&gt; helps you to format and parse numbers for any locale.</span>
  66  * Your code can be completely independent of the locale conventions for
  67  * decimal points, thousands-separators, or even the particular decimal
  68  * digits used, or whether the number format is even decimal.
  69  *
  70  * &lt;p&gt;
  71  * To format a number for the current Locale, use one of the factory
  72  * class methods:
  73  * &lt;blockquote&gt;
  74  * &lt;pre&gt;{@code
  75  * myString = NumberFormat.getInstance().format(myNumber);
  76  * }&lt;/pre&gt;
  77  * &lt;/blockquote&gt;
  78  * If you are formatting multiple numbers, it is
  79  * more efficient to get the format and use it multiple times so that
  80  * the system doesn&#39;t have to fetch the information about the local
  81  * language and country conventions multiple times.
  82  * &lt;blockquote&gt;
  83  * &lt;pre&gt;{@code
  84  * NumberFormat nf = NumberFormat.getInstance();
  85  * for (int i = 0; i &lt; myNumber.length; ++i) {
  86  *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
  87  * }
  88  * }&lt;/pre&gt;
  89  * &lt;/blockquote&gt;
  90  * To format a number for a different Locale, specify it in the
<a name="5" id="anc5"></a><span class="line-modified">  91  * call to &lt;code&gt;getInstance&lt;/code&gt;.</span>
  92  * &lt;blockquote&gt;
  93  * &lt;pre&gt;{@code
  94  * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
  95  * }&lt;/pre&gt;
  96  * &lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;If the locale contains &quot;nu&quot; (numbers) and/or &quot;rg&quot; (region override)
  99  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
 100  * the decimal digits, and/or the country used for formatting are overridden.
 101  * If both &quot;nu&quot; and &quot;rg&quot; are specified, the decimal digits from the &quot;nu&quot;
 102  * extension supersedes the implicit one from the &quot;rg&quot; extension.
 103  *
 104  * &lt;p&gt;You can also use a {@code NumberFormat} to parse numbers:
 105  * &lt;blockquote&gt;
 106  * &lt;pre&gt;{@code
 107  * myNumber = nf.parse(myString);
 108  * }&lt;/pre&gt;
 109  * &lt;/blockquote&gt;
<a name="6" id="anc6"></a><span class="line-modified"> 110  * Use &lt;code&gt;getInstance&lt;/code&gt; or &lt;code&gt;getNumberInstance&lt;/code&gt; to get the</span>
<span class="line-modified"> 111  * normal number format. Use &lt;code&gt;getIntegerInstance&lt;/code&gt; to get an</span>
<span class="line-modified"> 112  * integer number format. Use &lt;code&gt;getCurrencyInstance&lt;/code&gt; to get the</span>
 113  * currency number format. Use {@code getCompactNumberInstance} to get the
 114  * compact number format to format a number in shorter form. For example,
 115  * {@code 2000} can be formatted as {@code &quot;2K&quot;} in
<a name="7" id="anc7"></a><span class="line-modified"> 116  * {@link java.util.Locale#US US locale}. Use &lt;code&gt;getPercentInstance&lt;/code&gt;</span>
 117  * to get a format for displaying percentages. With this format, a fraction
 118  * like 0.53 is displayed as 53%.
 119  *
 120  * &lt;p&gt;
 121  * You can also control the display of numbers with such methods as
<a name="8" id="anc8"></a><span class="line-modified"> 122  * &lt;code&gt;setMinimumFractionDigits&lt;/code&gt;.</span>
 123  * If you want even more control over the format or parsing,
 124  * or want to give your users more control,
<a name="9" id="anc9"></a><span class="line-modified"> 125  * you can try casting the &lt;code&gt;NumberFormat&lt;/code&gt; you get from the factory methods</span>
 126  * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on
 127  * the factory method used. This will work for the vast majority of locales;
<a name="10" id="anc10"></a><span class="line-modified"> 128  * just remember to put it in a &lt;code&gt;try&lt;/code&gt; block in case you encounter</span>
 129  * an unusual one.
 130  *
 131  * &lt;p&gt;
 132  * NumberFormat and DecimalFormat are designed such that some controls
 133  * work for formatting and others work for parsing.  The following is
 134  * the detailed description for each these control methods,
 135  * &lt;p&gt;
 136  * setParseIntegerOnly : only affects parsing, e.g.
 137  * if true,  &quot;3456.78&quot; &amp;rarr; 3456 (and leaves the parse position just after index 6)
 138  * if false, &quot;3456.78&quot; &amp;rarr; 3456.78 (and leaves the parse position just after index 8)
 139  * This is independent of formatting.  If you want to not show a decimal point
 140  * where there might be no digits after the decimal point, use
 141  * setDecimalSeparatorAlwaysShown.
 142  * &lt;p&gt;
 143  * setDecimalSeparatorAlwaysShown : only affects formatting, and only where
 144  * there might be no digits after the decimal point, such as with a pattern
 145  * like &quot;#,##0.##&quot;, e.g.,
 146  * if true,  3456.00 &amp;rarr; &quot;3,456.&quot;
 147  * if false, 3456.00 &amp;rarr; &quot;3456&quot;
 148  * This is independent of parsing.  If you want parsing to stop at the decimal
 149  * point, use setParseIntegerOnly.
 150  *
 151  * &lt;p&gt;
<a name="11" id="anc11"></a><span class="line-modified"> 152  * You can also use forms of the &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt;</span>
<span class="line-modified"> 153  * methods with &lt;code&gt;ParsePosition&lt;/code&gt; and &lt;code&gt;FieldPosition&lt;/code&gt; to</span>
 154  * allow you to:
 155  * &lt;ul&gt;
 156  * &lt;li&gt; progressively parse through pieces of a string
 157  * &lt;li&gt; align the decimal point and other areas
 158  * &lt;/ul&gt;
 159  * For example, you can align numbers in two ways:
 160  * &lt;ol&gt;
 161  * &lt;li&gt; If you are using a monospaced font with spacing for alignment,
<a name="12" id="anc12"></a><span class="line-modified"> 162  *      you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with</span>
<span class="line-modified"> 163  *      &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output,</span>
<span class="line-modified"> 164  *      &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the</span>
 165  *      last character of the integer and the decimal. Add
 166  *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
 167  *
 168  * &lt;li&gt; If you are using proportional fonts,
 169  *      instead of padding with spaces, measure the width
<a name="13" id="anc13"></a><span class="line-modified"> 170  *      of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;.</span>
 171  *      Then move the pen by
 172  *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
 173  *      It also works where there is no decimal, but possibly additional
 174  *      characters at the end, e.g., with parentheses in negative
 175  *      numbers: &quot;(12)&quot; for -12.
 176  * &lt;/ol&gt;
 177  *
<a name="14" id="anc14"></a><span class="line-modified"> 178  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
 179  *
 180  * &lt;p&gt;
 181  * Number formats are generally not synchronized.
 182  * It is recommended to create separate format instances for each thread.
 183  * If multiple threads access a format concurrently, it must be synchronized
 184  * externally.
 185  *
 186  * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},
 187  * {@link #format(long, StringBuffer, FieldPosition)} and
 188  * {@link #parse(String, ParsePosition)} methods may throw
 189  * {@code NullPointerException}, if any of their parameter is {@code null}.
 190  * The subclass may provide its own implementation and specification about
 191  * {@code NullPointerException}.
 192  *
 193  * &lt;p&gt;
 194  * The default implementation provides rounding modes defined
 195  * in {@link java.math.RoundingMode} for formatting numbers. It
 196  * uses the {@linkplain java.math.RoundingMode#HALF_EVEN
 197  * round half-even algorithm}. To change the rounding mode use
 198  * {@link #setRoundingMode(java.math.RoundingMode) setRoundingMode}.
 199  * The {@code NumberFormat} returned by the static factory methods is
 200  * configured to round floating point numbers using half-even
 201  * rounding (see {@link java.math.RoundingMode#HALF_EVEN
 202  * RoundingMode.HALF_EVEN}) for formatting.
 203  *
 204  * @see          DecimalFormat
 205  * @see          ChoiceFormat
 206  * @see          CompactNumberFormat
 207  * @author       Mark Davis
 208  * @author       Helena Shih
 209  * @since 1.1
 210  */
 211 public abstract class NumberFormat extends Format  {
 212 
 213     /**
 214      * Field constant used to construct a FieldPosition object. Signifies that
 215      * the position of the integer part of a formatted number should be returned.
 216      * @see java.text.FieldPosition
 217      */
 218     public static final int INTEGER_FIELD = 0;
 219 
 220     /**
 221      * Field constant used to construct a FieldPosition object. Signifies that
 222      * the position of the fraction part of a formatted number should be returned.
 223      * @see java.text.FieldPosition
 224      */
 225     public static final int FRACTION_FIELD = 1;
 226 
 227     /**
 228      * Sole constructor.  (For invocation by subclass constructors, typically
 229      * implicit.)
 230      */
 231     protected NumberFormat() {
 232     }
 233 
 234     /**
 235      * Formats a number and appends the resulting text to the given string
 236      * buffer.
 237      * The number can be of any subclass of {@link java.lang.Number}.
 238      * &lt;p&gt;
 239      * This implementation extracts the number&#39;s value using
 240      * {@link java.lang.Number#longValue()} for all integral type values that
<a name="15" id="anc15"></a><span class="line-modified"> 241      * can be converted to &lt;code&gt;long&lt;/code&gt; without loss of information,</span>
<span class="line-modified"> 242      * including &lt;code&gt;BigInteger&lt;/code&gt; values with a</span>
 243      * {@link java.math.BigInteger#bitLength() bit length} of less than 64,
 244      * and {@link java.lang.Number#doubleValue()} for all other types. It
 245      * then calls
 246      * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
 247      * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
 248      * This may result in loss of magnitude information and precision for
<a name="16" id="anc16"></a><span class="line-modified"> 249      * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; values.</span>
 250      * @param number     the number to format
<a name="17" id="anc17"></a><span class="line-modified"> 251      * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted</span>
 252      *                   text is to be appended
 253      * @param pos        keeps track on the position of the field within the
 254      *                   returned string. For example, for formatting a number
 255      *                   {@code 1234567.89} in {@code Locale.US} locale,
 256      *                   if the given {@code fieldPosition} is
 257      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 258      *                   and end index of {@code fieldPosition} will be set
 259      *                   to 0 and 9, respectively for the output string
 260      *                   {@code 1,234,567.89}.
<a name="18" id="anc18"></a><span class="line-modified"> 261      * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;</span>
<span class="line-modified"> 262      * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is</span>
<span class="line-modified"> 263      *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</span>
<span class="line-modified"> 264      * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified"> 265      *                   &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified"> 266      * @exception        ArithmeticException if rounding is needed with rounding</span>
 267      *                   mode being set to RoundingMode.UNNECESSARY
 268      * @see              java.text.FieldPosition
 269      */
 270     @Override
 271     public StringBuffer format(Object number,
 272                                StringBuffer toAppendTo,
 273                                FieldPosition pos) {
 274         if (number instanceof Long || number instanceof Integer ||
 275             number instanceof Short || number instanceof Byte ||
 276             number instanceof AtomicInteger || number instanceof AtomicLong ||
 277             (number instanceof BigInteger &amp;&amp;
 278              ((BigInteger)number).bitLength() &lt; 64)) {
 279             return format(((Number)number).longValue(), toAppendTo, pos);
 280         } else if (number instanceof Number) {
 281             return format(((Number)number).doubleValue(), toAppendTo, pos);
 282         } else {
 283             throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
 284         }
 285     }
 286 
 287     /**
<a name="19" id="anc19"></a><span class="line-modified"> 288      * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.</span>
 289      * &lt;p&gt;
 290      * The method attempts to parse text starting at the index given by
<a name="20" id="anc20"></a><span class="line-modified"> 291      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified"> 292      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
 293      * to the index after the last character used (parsing does not necessarily
 294      * use all characters up to the end of the string), and the parsed
<a name="21" id="anc21"></a><span class="line-modified"> 295      * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
 296      * indicate the starting point for the next call to this method.
<a name="22" id="anc22"></a><span class="line-modified"> 297      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified"> 298      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
 299      * the character where the error occurred, and null is returned.
 300      * &lt;p&gt;
 301      * See the {@link #parse(String, ParsePosition)} method for more information
 302      * on number parsing.
 303      *
<a name="23" id="anc23"></a><span class="line-modified"> 304      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified"> 305      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
 306      *            index information as described above.
<a name="24" id="anc24"></a><span class="line-modified"> 307      * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string. In case of</span>
 308      *         error, returns null.
 309      * @throws NullPointerException if {@code source} or {@code pos} is null.
 310      */
 311     @Override
 312     public final Object parseObject(String source, ParsePosition pos) {
 313         return parse(source, pos);
 314     }
 315 
 316    /**
 317      * Specialization of format.
 318      *
 319      * @param number the double number to format
 320      * @return the formatted String
<a name="25" id="anc25"></a><span class="line-modified"> 321      * @exception        ArithmeticException if rounding is needed with rounding</span>
 322      *                   mode being set to RoundingMode.UNNECESSARY
 323      * @see java.text.Format#format
 324      */
 325     public final String format(double number) {
 326         // Use fast-path for double result if that works
 327         String result = fastFormat(number);
 328         if (result != null)
 329             return result;
 330 
 331         return format(number, new StringBuffer(),
 332                       DontCareFieldPosition.INSTANCE).toString();
 333     }
 334 
 335     /*
 336      * fastFormat() is supposed to be implemented in concrete subclasses only.
 337      * Default implem always returns null.
 338      */
 339     String fastFormat(double number) { return null; }
 340 
 341    /**
 342      * Specialization of format.
 343      *
 344      * @param number the long number to format
 345      * @return the formatted String
<a name="26" id="anc26"></a><span class="line-modified"> 346      * @exception        ArithmeticException if rounding is needed with rounding</span>
 347      *                   mode being set to RoundingMode.UNNECESSARY
 348      * @see java.text.Format#format
 349      */
 350     public final String format(long number) {
 351         return format(number, new StringBuffer(),
 352                       DontCareFieldPosition.INSTANCE).toString();
 353     }
 354 
 355    /**
 356      * Specialization of format.
 357      *
 358      * @param number     the double number to format
 359      * @param toAppendTo the StringBuffer to which the formatted text is to be
 360      *                   appended
 361      * @param pos        keeps track on the position of the field within the
 362      *                   returned string. For example, for formatting a number
 363      *                   {@code 1234567.89} in {@code Locale.US} locale,
 364      *                   if the given {@code fieldPosition} is
 365      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 366      *                   and end index of {@code fieldPosition} will be set
 367      *                   to 0 and 9, respectively for the output string
 368      *                   {@code 1,234,567.89}.
 369      * @return the formatted StringBuffer
<a name="27" id="anc27"></a><span class="line-modified"> 370      * @exception        ArithmeticException if rounding is needed with rounding</span>
 371      *                   mode being set to RoundingMode.UNNECESSARY
 372      * @see java.text.Format#format
 373      */
 374     public abstract StringBuffer format(double number,
 375                                         StringBuffer toAppendTo,
 376                                         FieldPosition pos);
 377 
 378    /**
 379      * Specialization of format.
 380      *
 381      * @param number     the long number to format
 382      * @param toAppendTo the StringBuffer to which the formatted text is to be
 383      *                   appended
 384      * @param pos        keeps track on the position of the field within the
 385      *                   returned string. For example, for formatting a number
 386      *                   {@code 123456789} in {@code Locale.US} locale,
 387      *                   if the given {@code fieldPosition} is
 388      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 389      *                   and end index of {@code fieldPosition} will be set
 390      *                   to 0 and 11, respectively for the output string
 391      *                   {@code 123,456,789}.
 392      * @return the formatted StringBuffer
<a name="28" id="anc28"></a><span class="line-modified"> 393      * @exception        ArithmeticException if rounding is needed with rounding</span>
 394      *                   mode being set to RoundingMode.UNNECESSARY
 395      * @see java.text.Format#format
 396      */
 397     public abstract StringBuffer format(long number,
 398                                         StringBuffer toAppendTo,
 399                                         FieldPosition pos);
 400 
 401    /**
 402      * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
 403      * Long.MAX_VALUE] and with no decimals), otherwise a Double.
 404      * If IntegerOnly is set, will stop at a decimal
 405      * point (or equivalent; e.g., for rational numbers &quot;1 2/3&quot;, will stop
 406      * after the 1).
 407      * Does not throw an exception; if no object can be parsed, index is
 408      * unchanged!
 409      *
 410      * @param source the String to parse
 411      * @param parsePosition the parse position
 412      * @return the parsed value
 413      * @see java.text.NumberFormat#isParseIntegerOnly
 414      * @see java.text.Format#parseObject
 415      */
 416     public abstract Number parse(String source, ParsePosition parsePosition);
 417 
 418     /**
 419      * Parses text from the beginning of the given string to produce a number.
 420      * The method may not use the entire text of the given string.
 421      * &lt;p&gt;
 422      * See the {@link #parse(String, ParsePosition)} method for more information
 423      * on number parsing.
 424      *
<a name="29" id="anc29"></a><span class="line-modified"> 425      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified"> 426      * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string.</span>
<span class="line-modified"> 427      * @exception ParseException if the beginning of the specified string</span>
 428      *            cannot be parsed.
 429      */
 430     public Number parse(String source) throws ParseException {
 431         ParsePosition parsePosition = new ParsePosition(0);
 432         Number result = parse(source, parsePosition);
 433         if (parsePosition.index == 0) {
 434             throw new ParseException(&quot;Unparseable number: \&quot;&quot; + source + &quot;\&quot;&quot;,
 435                                      parsePosition.errorIndex);
 436         }
 437         return result;
 438     }
 439 
 440     /**
 441      * Returns true if this format will parse numbers as integers only.
 442      * For example in the English locale, with ParseIntegerOnly true, the
 443      * string &quot;1234.&quot; would be parsed as the integer value 1234 and parsing
 444      * would stop at the &quot;.&quot; character.  Of course, the exact format accepted
 445      * by the parse operation is locale dependent and determined by sub-classes
 446      * of NumberFormat.
 447      *
 448      * @return {@code true} if numbers should be parsed as integers only;
 449      *         {@code false} otherwise
 450      */
 451     public boolean isParseIntegerOnly() {
 452         return parseIntegerOnly;
 453     }
 454 
 455     /**
 456      * Sets whether or not numbers should be parsed as integers only.
 457      *
 458      * @param value {@code true} if numbers should be parsed as integers only;
 459      *              {@code false} otherwise
 460      * @see #isParseIntegerOnly
 461      */
 462     public void setParseIntegerOnly(boolean value) {
 463         parseIntegerOnly = value;
 464     }
 465 
 466     //============== Locale Stuff =====================
 467 
 468     /**
 469      * Returns a general-purpose number format for the current default
 470      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 471      * This is the same as calling
 472      * {@link #getNumberInstance() getNumberInstance()}.
 473      *
 474      * @return the {@code NumberFormat} instance for general-purpose number
 475      * formatting
 476      */
 477     public static final NumberFormat getInstance() {
 478         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, NUMBERSTYLE);
 479     }
 480 
 481     /**
 482      * Returns a general-purpose number format for the specified locale.
 483      * This is the same as calling
 484      * {@link #getNumberInstance(java.util.Locale) getNumberInstance(inLocale)}.
 485      *
 486      * @param inLocale the desired locale
 487      * @return the {@code NumberFormat} instance for general-purpose number
 488      * formatting
 489      */
 490     public static NumberFormat getInstance(Locale inLocale) {
 491         return getInstance(inLocale, null, NUMBERSTYLE);
 492     }
 493 
 494     /**
 495      * Returns a general-purpose number format for the current default
 496      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 497      * &lt;p&gt;This is equivalent to calling
 498      * {@link #getNumberInstance(Locale)
 499      *     getNumberInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 500      *
 501      * @return the {@code NumberFormat} instance for general-purpose number
 502      * formatting
 503      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 504      * @see java.util.Locale.Category#FORMAT
 505      */
 506     public static final NumberFormat getNumberInstance() {
 507         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, NUMBERSTYLE);
 508     }
 509 
 510     /**
 511      * Returns a general-purpose number format for the specified locale.
 512      *
 513      * @param inLocale the desired locale
 514      * @return the {@code NumberFormat} instance for general-purpose number
 515      * formatting
 516      */
 517     public static NumberFormat getNumberInstance(Locale inLocale) {
 518         return getInstance(inLocale, null, NUMBERSTYLE);
 519     }
 520 
 521     /**
 522      * Returns an integer number format for the current default
 523      * {@link java.util.Locale.Category#FORMAT FORMAT} locale. The
 524      * returned number format is configured to round floating point numbers
 525      * to the nearest integer using half-even rounding (see {@link
 526      * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,
 527      * and to parse only the integer part of an input string (see {@link
 528      * #isParseIntegerOnly isParseIntegerOnly}).
 529      * &lt;p&gt;This is equivalent to calling
 530      * {@link #getIntegerInstance(Locale)
 531      *     getIntegerInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 532      *
 533      * @see #getRoundingMode()
 534      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 535      * @see java.util.Locale.Category#FORMAT
 536      * @return a number format for integer values
 537      * @since 1.4
 538      */
 539     public static final NumberFormat getIntegerInstance() {
 540         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, INTEGERSTYLE);
 541     }
 542 
 543     /**
 544      * Returns an integer number format for the specified locale. The
 545      * returned number format is configured to round floating point numbers
 546      * to the nearest integer using half-even rounding (see {@link
 547      * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,
 548      * and to parse only the integer part of an input string (see {@link
 549      * #isParseIntegerOnly isParseIntegerOnly}).
 550      *
 551      * @param inLocale the desired locale
 552      * @see #getRoundingMode()
 553      * @return a number format for integer values
 554      * @since 1.4
 555      */
 556     public static NumberFormat getIntegerInstance(Locale inLocale) {
 557         return getInstance(inLocale, null, INTEGERSTYLE);
 558     }
 559 
 560     /**
 561      * Returns a currency format for the current default
 562      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 563      * &lt;p&gt;This is equivalent to calling
 564      * {@link #getCurrencyInstance(Locale)
 565      *     getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 566      *
 567      * @return the {@code NumberFormat} instance for currency formatting
 568      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 569      * @see java.util.Locale.Category#FORMAT
 570      */
 571     public static final NumberFormat getCurrencyInstance() {
 572         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, CURRENCYSTYLE);
 573     }
 574 
 575     /**
 576      * Returns a currency format for the specified locale.
 577      *
<a name="30" id="anc30"></a>








 578      * @param inLocale the desired locale
 579      * @return the {@code NumberFormat} instance for currency formatting
 580      */
 581     public static NumberFormat getCurrencyInstance(Locale inLocale) {
 582         return getInstance(inLocale, null, CURRENCYSTYLE);
 583     }
 584 
 585     /**
 586      * Returns a percentage format for the current default
 587      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 588      * &lt;p&gt;This is equivalent to calling
 589      * {@link #getPercentInstance(Locale)
 590      *     getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 591      *
 592      * @return the {@code NumberFormat} instance for percentage formatting
 593      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 594      * @see java.util.Locale.Category#FORMAT
 595      */
 596     public static final NumberFormat getPercentInstance() {
 597         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, PERCENTSTYLE);
 598     }
 599 
 600     /**
 601      * Returns a percentage format for the specified locale.
 602      *
 603      * @param inLocale the desired locale
 604      * @return the {@code NumberFormat} instance for percentage formatting
 605      */
 606     public static NumberFormat getPercentInstance(Locale inLocale) {
 607         return getInstance(inLocale, null, PERCENTSTYLE);
 608     }
 609 
 610     /**
 611      * Returns a scientific format for the current default locale.
 612      */
 613     /*public*/ final static NumberFormat getScientificInstance() {
 614         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, SCIENTIFICSTYLE);
 615     }
 616 
 617     /**
 618      * Returns a scientific format for the specified locale.
 619      *
 620      * @param inLocale the desired locale
 621      */
 622     /*public*/ static NumberFormat getScientificInstance(Locale inLocale) {
 623         return getInstance(inLocale, null, SCIENTIFICSTYLE);
 624     }
 625 
 626     /**
 627      * Returns a compact number format for the default
 628      * {@link java.util.Locale.Category#FORMAT FORMAT} locale with
 629      * {@link NumberFormat.Style#SHORT &quot;SHORT&quot;} format style.
 630      *
 631      * @return A {@code NumberFormat} instance for compact number
 632      *         formatting
 633      *
 634      * @see CompactNumberFormat
 635      * @see NumberFormat.Style
 636      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 637      * @see java.util.Locale.Category#FORMAT
 638      * @since 12
 639      */
 640     public static NumberFormat getCompactNumberInstance() {
 641         return getInstance(Locale.getDefault(
 642                 Locale.Category.FORMAT), NumberFormat.Style.SHORT, COMPACTSTYLE);
 643     }
 644 
 645     /**
 646      * Returns a compact number format for the specified {@link java.util.Locale locale}
 647      * and {@link NumberFormat.Style formatStyle}.
 648      *
 649      * @param locale the desired locale
 650      * @param formatStyle the style for formatting a number
 651      * @return A {@code NumberFormat} instance for compact number
 652      *         formatting
 653      * @throws NullPointerException if {@code locale} or {@code formatStyle}
 654      *                              is {@code null}
 655      *
 656      * @see CompactNumberFormat
 657      * @see NumberFormat.Style
 658      * @see java.util.Locale
 659      * @since 12
 660      */
 661     public static NumberFormat getCompactNumberInstance(Locale locale,
 662             NumberFormat.Style formatStyle) {
 663 
 664         Objects.requireNonNull(locale);
 665         Objects.requireNonNull(formatStyle);
 666         return getInstance(locale, formatStyle, COMPACTSTYLE);
 667     }
 668 
 669     /**
 670      * Returns an array of all locales for which the
<a name="31" id="anc31"></a><span class="line-modified"> 671      * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return</span>
 672      * localized instances.
 673      * The returned array represents the union of locales supported by the Java
 674      * runtime and by installed
 675      * {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
<a name="32" id="anc32"></a><span class="line-modified"> 676      * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to</span>
 677      * {@link java.util.Locale#US Locale.US}.
 678      *
 679      * @return An array of locales for which localized
<a name="33" id="anc33"></a><span class="line-modified"> 680      *         &lt;code&gt;NumberFormat&lt;/code&gt; instances are available.</span>
 681      */
 682     public static Locale[] getAvailableLocales() {
 683         LocaleServiceProviderPool pool =
 684             LocaleServiceProviderPool.getPool(NumberFormatProvider.class);
 685         return pool.getAvailableLocales();
 686     }
 687 
 688     /**
 689      * Overrides hashCode.
 690      */
 691     @Override
 692     public int hashCode() {
 693         return maximumIntegerDigits * 37 + maxFractionDigits;
 694         // just enough fields for a reasonable distribution
 695     }
 696 
 697     /**
 698      * Overrides equals.
 699      */
 700     @Override
 701     public boolean equals(Object obj) {
 702         if (obj == null) {
 703             return false;
 704         }
 705         if (this == obj) {
 706             return true;
 707         }
 708         if (getClass() != obj.getClass()) {
 709             return false;
 710         }
 711         NumberFormat other = (NumberFormat) obj;
 712         return (maximumIntegerDigits == other.maximumIntegerDigits
 713             &amp;&amp; minimumIntegerDigits == other.minimumIntegerDigits
 714             &amp;&amp; maximumFractionDigits == other.maximumFractionDigits
 715             &amp;&amp; minimumFractionDigits == other.minimumFractionDigits
 716             &amp;&amp; groupingUsed == other.groupingUsed
 717             &amp;&amp; parseIntegerOnly == other.parseIntegerOnly);
 718     }
 719 
 720     /**
 721      * Overrides Cloneable.
 722      */
 723     @Override
 724     public Object clone() {
 725         NumberFormat other = (NumberFormat) super.clone();
 726         return other;
 727     }
 728 
 729     /**
 730      * Returns true if grouping is used in this format. For example, in the
 731      * English locale, with grouping on, the number 1234567 might be formatted
 732      * as &quot;1,234,567&quot;. The grouping separator as well as the size of each group
 733      * is locale dependent and is determined by sub-classes of NumberFormat.
 734      *
 735      * @return {@code true} if grouping is used;
 736      *         {@code false} otherwise
 737      * @see #setGroupingUsed
 738      */
 739     public boolean isGroupingUsed() {
 740         return groupingUsed;
 741     }
 742 
 743     /**
 744      * Set whether or not grouping will be used in this format.
 745      *
 746      * @param newValue {@code true} if grouping is used;
 747      *                 {@code false} otherwise
 748      * @see #isGroupingUsed
 749      */
 750     public void setGroupingUsed(boolean newValue) {
 751         groupingUsed = newValue;
 752     }
 753 
 754     /**
 755      * Returns the maximum number of digits allowed in the integer portion of a
 756      * number.
 757      *
 758      * @return the maximum number of digits
 759      * @see #setMaximumIntegerDigits
 760      */
 761     public int getMaximumIntegerDigits() {
 762         return maximumIntegerDigits;
 763     }
 764 
 765     /**
 766      * Sets the maximum number of digits allowed in the integer portion of a
 767      * number. maximumIntegerDigits must be &amp;ge; minimumIntegerDigits.  If the
 768      * new value for maximumIntegerDigits is less than the current value
 769      * of minimumIntegerDigits, then minimumIntegerDigits will also be set to
 770      * the new value.
 771      *
 772      * @param newValue the maximum number of integer digits to be shown; if
 773      * less than zero, then zero is used. The concrete subclass may enforce an
 774      * upper limit to this value appropriate to the numeric type being formatted.
 775      * @see #getMaximumIntegerDigits
 776      */
 777     public void setMaximumIntegerDigits(int newValue) {
 778         maximumIntegerDigits = Math.max(0,newValue);
 779         if (minimumIntegerDigits &gt; maximumIntegerDigits) {
 780             minimumIntegerDigits = maximumIntegerDigits;
 781         }
 782     }
 783 
 784     /**
 785      * Returns the minimum number of digits allowed in the integer portion of a
 786      * number.
 787      *
 788      * @return the minimum number of digits
 789      * @see #setMinimumIntegerDigits
 790      */
 791     public int getMinimumIntegerDigits() {
 792         return minimumIntegerDigits;
 793     }
 794 
 795     /**
 796      * Sets the minimum number of digits allowed in the integer portion of a
 797      * number. minimumIntegerDigits must be &amp;le; maximumIntegerDigits.  If the
 798      * new value for minimumIntegerDigits exceeds the current value
 799      * of maximumIntegerDigits, then maximumIntegerDigits will also be set to
 800      * the new value
 801      *
 802      * @param newValue the minimum number of integer digits to be shown; if
 803      * less than zero, then zero is used. The concrete subclass may enforce an
 804      * upper limit to this value appropriate to the numeric type being formatted.
 805      * @see #getMinimumIntegerDigits
 806      */
 807     public void setMinimumIntegerDigits(int newValue) {
 808         minimumIntegerDigits = Math.max(0,newValue);
 809         if (minimumIntegerDigits &gt; maximumIntegerDigits) {
 810             maximumIntegerDigits = minimumIntegerDigits;
 811         }
 812     }
 813 
 814     /**
 815      * Returns the maximum number of digits allowed in the fraction portion of a
 816      * number.
 817      *
 818      * @return the maximum number of digits.
 819      * @see #setMaximumFractionDigits
 820      */
 821     public int getMaximumFractionDigits() {
 822         return maximumFractionDigits;
 823     }
 824 
 825     /**
 826      * Sets the maximum number of digits allowed in the fraction portion of a
 827      * number. maximumFractionDigits must be &amp;ge; minimumFractionDigits.  If the
 828      * new value for maximumFractionDigits is less than the current value
 829      * of minimumFractionDigits, then minimumFractionDigits will also be set to
 830      * the new value.
 831      *
 832      * @param newValue the maximum number of fraction digits to be shown; if
 833      * less than zero, then zero is used. The concrete subclass may enforce an
 834      * upper limit to this value appropriate to the numeric type being formatted.
 835      * @see #getMaximumFractionDigits
 836      */
 837     public void setMaximumFractionDigits(int newValue) {
 838         maximumFractionDigits = Math.max(0,newValue);
 839         if (maximumFractionDigits &lt; minimumFractionDigits) {
 840             minimumFractionDigits = maximumFractionDigits;
 841         }
 842     }
 843 
 844     /**
 845      * Returns the minimum number of digits allowed in the fraction portion of a
 846      * number.
 847      *
 848      * @return the minimum number of digits
 849      * @see #setMinimumFractionDigits
 850      */
 851     public int getMinimumFractionDigits() {
 852         return minimumFractionDigits;
 853     }
 854 
 855     /**
 856      * Sets the minimum number of digits allowed in the fraction portion of a
 857      * number. minimumFractionDigits must be &amp;le; maximumFractionDigits.  If the
 858      * new value for minimumFractionDigits exceeds the current value
 859      * of maximumFractionDigits, then maximumIntegerDigits will also be set to
 860      * the new value
 861      *
 862      * @param newValue the minimum number of fraction digits to be shown; if
 863      * less than zero, then zero is used. The concrete subclass may enforce an
 864      * upper limit to this value appropriate to the numeric type being formatted.
 865      * @see #getMinimumFractionDigits
 866      */
 867     public void setMinimumFractionDigits(int newValue) {
 868         minimumFractionDigits = Math.max(0,newValue);
 869         if (maximumFractionDigits &lt; minimumFractionDigits) {
 870             maximumFractionDigits = minimumFractionDigits;
 871         }
 872     }
 873 
 874     /**
 875      * Gets the currency used by this number format when formatting
 876      * currency values. The initial value is derived in a locale dependent
 877      * way. The returned value may be null if no valid
 878      * currency could be determined and no currency has been set using
 879      * {@link #setCurrency(java.util.Currency) setCurrency}.
 880      * &lt;p&gt;
 881      * The default implementation throws
<a name="34" id="anc34"></a><span class="line-modified"> 882      * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</span>
 883      *
<a name="35" id="anc35"></a><span class="line-modified"> 884      * @return the currency used by this number format, or &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 885      * @exception UnsupportedOperationException if the number format class</span>
 886      * doesn&#39;t implement currency formatting
 887      * @since 1.4
 888      */
 889     public Currency getCurrency() {
 890         throw new UnsupportedOperationException();
 891     }
 892 
 893     /**
 894      * Sets the currency used by this number format when formatting
 895      * currency values. This does not update the minimum or maximum
 896      * number of fraction digits used by the number format.
 897      * &lt;p&gt;
 898      * The default implementation throws
<a name="36" id="anc36"></a><span class="line-modified"> 899      * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</span>
 900      *
 901      * @param currency the new currency to be used by this number format
<a name="37" id="anc37"></a><span class="line-modified"> 902      * @exception UnsupportedOperationException if the number format class</span>
 903      * doesn&#39;t implement currency formatting
<a name="38" id="anc38"></a><span class="line-modified"> 904      * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</span>
 905      * @since 1.4
 906      */
 907     public void setCurrency(Currency currency) {
 908         throw new UnsupportedOperationException();
 909     }
 910 
 911     /**
 912      * Gets the {@link java.math.RoundingMode} used in this NumberFormat.
 913      * The default implementation of this method in NumberFormat
 914      * always throws {@link java.lang.UnsupportedOperationException}.
 915      * Subclasses which handle different rounding modes should override
 916      * this method.
 917      *
<a name="39" id="anc39"></a><span class="line-modified"> 918      * @exception UnsupportedOperationException The default implementation</span>
 919      *     always throws this exception
<a name="40" id="anc40"></a><span class="line-modified"> 920      * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this NumberFormat.</span>
 921      * @see #setRoundingMode(RoundingMode)
 922      * @since 1.6
 923      */
 924     public RoundingMode getRoundingMode() {
 925         throw new UnsupportedOperationException();
 926     }
 927 
 928     /**
 929      * Sets the {@link java.math.RoundingMode} used in this NumberFormat.
 930      * The default implementation of this method in NumberFormat always
 931      * throws {@link java.lang.UnsupportedOperationException}.
 932      * Subclasses which handle different rounding modes should override
 933      * this method.
 934      *
<a name="41" id="anc41"></a><span class="line-modified"> 935      * @exception UnsupportedOperationException The default implementation</span>
 936      *     always throws this exception
<a name="42" id="anc42"></a><span class="line-modified"> 937      * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null</span>
<span class="line-modified"> 938      * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</span>
 939      * @see #getRoundingMode()
 940      * @since 1.6
 941      */
 942     public void setRoundingMode(RoundingMode roundingMode) {
 943         throw new UnsupportedOperationException();
 944     }
 945 
 946     // =======================privates===============================
 947 
 948     private static NumberFormat getInstance(Locale desiredLocale,
 949                                             Style formatStyle, int choice) {
 950         LocaleProviderAdapter adapter;
 951         adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class,
 952                 desiredLocale);
 953         NumberFormat numberFormat = getInstance(adapter, desiredLocale,
 954                 formatStyle, choice);
 955         if (numberFormat == null) {
 956             numberFormat = getInstance(LocaleProviderAdapter.forJRE(),
 957                     desiredLocale, formatStyle, choice);
 958         }
 959         return numberFormat;
 960     }
 961 
 962     private static NumberFormat getInstance(LocaleProviderAdapter adapter,
 963                                             Locale locale, Style formatStyle,
 964                                             int choice) {
 965         NumberFormatProvider provider = adapter.getNumberFormatProvider();
 966         NumberFormat numberFormat = null;
 967         switch (choice) {
 968         case NUMBERSTYLE:
 969             numberFormat = provider.getNumberInstance(locale);
 970             break;
 971         case PERCENTSTYLE:
 972             numberFormat = provider.getPercentInstance(locale);
 973             break;
 974         case CURRENCYSTYLE:
 975             numberFormat = provider.getCurrencyInstance(locale);
 976             break;
 977         case INTEGERSTYLE:
 978             numberFormat = provider.getIntegerInstance(locale);
 979             break;
 980         case COMPACTSTYLE:
 981             numberFormat = provider.getCompactNumberInstance(locale, formatStyle);
 982             break;
 983         }
 984         return numberFormat;
 985     }
 986 
 987     /**
 988      * First, read in the default serializable data.
 989      *
<a name="43" id="anc43"></a><span class="line-modified"> 990      * Then, if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that</span>
 991      * the stream was written by JDK 1.1,
<a name="44" id="anc44"></a><span class="line-modified"> 992      * set the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
<span class="line-modified"> 993      * to be equal to the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt;,</span>
<span class="line-modified"> 994      * since the &lt;code&gt;int&lt;/code&gt; fields were not present in JDK 1.1.</span>
 995      * Finally, set serialVersionOnStream back to the maximum allowed value so that
 996      * default serialization will work properly if this object is streamed out again.
 997      *
<a name="45" id="anc45"></a><span class="line-modified"> 998      * &lt;p&gt;If &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is greater than</span>
<span class="line-modified"> 999      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;minimumFractionDigits&lt;/code&gt;</span>
<span class="line-modified">1000      * is greater than &lt;code&gt;maximumFractionDigits&lt;/code&gt;, then the stream data</span>
<span class="line-modified">1001      * is invalid and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
1002      * In addition, if any of these values is negative, then this method throws
<a name="46" id="anc46"></a><span class="line-modified">1003      * an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
1004      *
1005      * @since 1.2
1006      */
<a name="47" id="anc47"></a>
1007     private void readObject(ObjectInputStream stream)
1008          throws IOException, ClassNotFoundException
1009     {
1010         stream.defaultReadObject();
1011         if (serialVersionOnStream &lt; 1) {
1012             // Didn&#39;t have additional int fields, reassign to use them.
1013             maximumIntegerDigits = maxIntegerDigits;
1014             minimumIntegerDigits = minIntegerDigits;
1015             maximumFractionDigits = maxFractionDigits;
1016             minimumFractionDigits = minFractionDigits;
1017         }
1018         if (minimumIntegerDigits &gt; maximumIntegerDigits ||
1019             minimumFractionDigits &gt; maximumFractionDigits ||
1020             minimumIntegerDigits &lt; 0 || minimumFractionDigits &lt; 0) {
1021             throw new InvalidObjectException(&quot;Digit count range invalid&quot;);
1022         }
1023         serialVersionOnStream = currentSerialVersion;
1024     }
1025 
1026     /**
1027      * Write out the default serializable data, after first setting
<a name="48" id="anc48"></a><span class="line-modified">1028      * the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; to be</span>
<span class="line-modified">1029      * equal to the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
<span class="line-modified">1030      * (or to &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;, whichever is smaller), for compatibility</span>
1031      * with the JDK 1.1 version of the stream format.
1032      *
1033      * @since 1.2
1034      */
<a name="49" id="anc49"></a>
1035     private void writeObject(ObjectOutputStream stream)
1036          throws IOException
1037     {
1038         maxIntegerDigits = (maximumIntegerDigits &gt; Byte.MAX_VALUE) ?
1039                            Byte.MAX_VALUE : (byte)maximumIntegerDigits;
1040         minIntegerDigits = (minimumIntegerDigits &gt; Byte.MAX_VALUE) ?
1041                            Byte.MAX_VALUE : (byte)minimumIntegerDigits;
1042         maxFractionDigits = (maximumFractionDigits &gt; Byte.MAX_VALUE) ?
1043                             Byte.MAX_VALUE : (byte)maximumFractionDigits;
1044         minFractionDigits = (minimumFractionDigits &gt; Byte.MAX_VALUE) ?
1045                             Byte.MAX_VALUE : (byte)minimumFractionDigits;
1046         stream.defaultWriteObject();
1047     }
1048 
1049     // Constants used by factory methods to specify a style of format.
1050     private static final int NUMBERSTYLE = 0;
1051     private static final int CURRENCYSTYLE = 1;
1052     private static final int PERCENTSTYLE = 2;
1053     private static final int SCIENTIFICSTYLE = 3;
1054     private static final int INTEGERSTYLE = 4;
1055     private static final int COMPACTSTYLE = 5;
1056 
1057     /**
1058      * True if the grouping (i.e. thousands) separator is used when
1059      * formatting and parsing numbers.
1060      *
1061      * @serial
1062      * @see #isGroupingUsed
1063      */
1064     private boolean groupingUsed = true;
1065 
1066     /**
1067      * The maximum number of digits allowed in the integer portion of a
<a name="50" id="anc50"></a><span class="line-modified">1068      * number.  &lt;code&gt;maxIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1069      * &lt;code&gt;minIntegerDigits&lt;/code&gt;.</span>
1070      * &lt;p&gt;
1071      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1072      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<a name="51" id="anc51"></a><span class="line-modified">1073      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumIntegerDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1074      * When writing to a stream, &lt;code&gt;maxIntegerDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1075      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1076      * whichever is smaller.  When reading from a stream, this field is used
<a name="52" id="anc52"></a><span class="line-modified">1077      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1078      *
1079      * @serial
1080      * @see #getMaximumIntegerDigits
1081      */
1082     private byte    maxIntegerDigits = 40;
1083 
1084     /**
1085      * The minimum number of digits allowed in the integer portion of a
<a name="53" id="anc53"></a><span class="line-modified">1086      * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1087      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
1088      * &lt;p&gt;
1089      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1090      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<a name="54" id="anc54"></a><span class="line-modified">1091      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1092      * When writing to a stream, &lt;code&gt;minIntegerDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1093      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1094      * whichever is smaller.  When reading from a stream, this field is used
<a name="55" id="anc55"></a><span class="line-modified">1095      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1096      *
1097      * @serial
1098      * @see #getMinimumIntegerDigits
1099      */
1100     private byte    minIntegerDigits = 1;
1101 
1102     /**
1103      * The maximum number of digits allowed in the fractional portion of a
<a name="56" id="anc56"></a><span class="line-modified">1104      * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1105      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
1106      * &lt;p&gt;
1107      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1108      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<a name="57" id="anc57"></a><span class="line-modified">1109      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumFractionDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1110      * When writing to a stream, &lt;code&gt;maxFractionDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1111      * &lt;code&gt;maximumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1112      * whichever is smaller.  When reading from a stream, this field is used
<a name="58" id="anc58"></a><span class="line-modified">1113      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1114      *
1115      * @serial
1116      * @see #getMaximumFractionDigits
1117      */
1118     private byte    maxFractionDigits = 3;    // invariant, &gt;= minFractionDigits
1119 
1120     /**
1121      * The minimum number of digits allowed in the fractional portion of a
<a name="59" id="anc59"></a><span class="line-modified">1122      * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1123      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
1124      * &lt;p&gt;
1125      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1126      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<a name="60" id="anc60"></a><span class="line-modified">1127      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumFractionDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1128      * When writing to a stream, &lt;code&gt;minFractionDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1129      * &lt;code&gt;minimumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1130      * whichever is smaller.  When reading from a stream, this field is used
<a name="61" id="anc61"></a><span class="line-modified">1131      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1132      *
1133      * @serial
1134      * @see #getMinimumFractionDigits
1135      */
1136     private byte    minFractionDigits = 0;
1137 
1138     /**
1139      * True if this format will parse numbers as integers only.
1140      *
1141      * @serial
1142      * @see #isParseIntegerOnly
1143      */
1144     private boolean parseIntegerOnly = false;
1145 
1146     // new fields for 1.2.  byte is too small for integer digits.
1147 
1148     /**
1149      * The maximum number of digits allowed in the integer portion of a
<a name="62" id="anc62"></a><span class="line-modified">1150      * number.  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1151      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</span>
1152      *
1153      * @serial
1154      * @since 1.2
1155      * @see #getMaximumIntegerDigits
1156      */
1157     private int    maximumIntegerDigits = 40;
1158 
1159     /**
1160      * The minimum number of digits allowed in the integer portion of a
<a name="63" id="anc63"></a><span class="line-modified">1161      * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1162      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
1163      *
1164      * @serial
1165      * @since 1.2
1166      * @see #getMinimumIntegerDigits
1167      */
1168     private int    minimumIntegerDigits = 1;
1169 
1170     /**
1171      * The maximum number of digits allowed in the fractional portion of a
<a name="64" id="anc64"></a><span class="line-modified">1172      * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1173      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
1174      *
1175      * @serial
1176      * @since 1.2
1177      * @see #getMaximumFractionDigits
1178      */
1179     private int    maximumFractionDigits = 3;    // invariant, &gt;= minFractionDigits
1180 
1181     /**
1182      * The minimum number of digits allowed in the fractional portion of a
<a name="65" id="anc65"></a><span class="line-modified">1183      * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1184      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
1185      *
1186      * @serial
1187      * @since 1.2
1188      * @see #getMinimumFractionDigits
1189      */
1190     private int    minimumFractionDigits = 0;
1191 
1192     static final int currentSerialVersion = 1;
1193 
1194     /**
<a name="66" id="anc66"></a><span class="line-modified">1195      * Describes the version of &lt;code&gt;NumberFormat&lt;/code&gt; present on the stream.</span>
1196      * Possible values are:
1197      * &lt;ul&gt;
1198      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
<a name="67" id="anc67"></a><span class="line-modified">1199      *     In this version, the &lt;code&gt;int&lt;/code&gt; fields such as</span>
<span class="line-modified">1200      *     &lt;code&gt;maximumIntegerDigits&lt;/code&gt; were not present, and the &lt;code&gt;byte&lt;/code&gt;</span>
<span class="line-modified">1201      *     fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are used instead.</span>
1202      *
1203      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
<a name="68" id="anc68"></a><span class="line-modified">1204      *     &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are ignored,</span>
<span class="line-modified">1205      *     and the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
1206      *     are used instead.
1207      * &lt;/ul&gt;
<a name="69" id="anc69"></a><span class="line-modified">1208      * When streaming out a &lt;code&gt;NumberFormat&lt;/code&gt;, the most recent format</span>
<span class="line-modified">1209      * (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)</span>
1210      * is always written.
1211      *
1212      * @serial
1213      * @since 1.2
1214      */
1215     private int serialVersionOnStream = currentSerialVersion;
1216 
1217     // Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization
1218     // ID for backward compatibility.
<a name="70" id="anc70"></a>
1219     static final long serialVersionUID = -2308460125733713944L;
1220 
1221 
1222     //
1223     // class for AttributedCharacterIterator attributes
1224     //
1225     /**
1226      * Defines constants that are used as attribute keys in the
<a name="71" id="anc71"></a><span class="line-modified">1227      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">1228      * from &lt;code&gt;NumberFormat.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">1229      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
1230      *
1231      * @since 1.4
1232      */
1233     public static class Field extends Format.Field {
1234 
1235         // Proclaim serial compatibility with 1.4 FCS
<a name="72" id="anc72"></a>
1236         private static final long serialVersionUID = 7494728892700160890L;
1237 
1238         // table of all instances in this class, used by readResolve
1239         private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(11);
1240 
1241         /**
1242          * Creates a Field instance with the specified
1243          * name.
1244          *
1245          * @param name Name of the attribute
1246          */
1247         protected Field(String name) {
1248             super(name);
1249             if (this.getClass() == NumberFormat.Field.class) {
1250                 instanceMap.put(name, this);
1251             }
1252         }
1253 
1254         /**
1255          * Resolves instances being deserialized to the predefined constants.
1256          *
1257          * @throws InvalidObjectException if the constant could not be resolved.
1258          * @return resolved NumberFormat.Field constant
1259          */
1260         @Override
<a name="73" id="anc73"></a>
1261         protected Object readResolve() throws InvalidObjectException {
1262             if (this.getClass() != NumberFormat.Field.class) {
1263                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1264             }
1265 
1266             Object instance = instanceMap.get(getName());
1267             if (instance != null) {
1268                 return instance;
1269             } else {
1270                 throw new InvalidObjectException(&quot;unknown attribute name&quot;);
1271             }
1272         }
1273 
1274         /**
1275          * Constant identifying the integer field.
1276          */
1277         public static final Field INTEGER = new Field(&quot;integer&quot;);
1278 
1279         /**
1280          * Constant identifying the fraction field.
1281          */
1282         public static final Field FRACTION = new Field(&quot;fraction&quot;);
1283 
1284         /**
1285          * Constant identifying the exponent field.
1286          */
1287         public static final Field EXPONENT = new Field(&quot;exponent&quot;);
1288 
1289         /**
1290          * Constant identifying the decimal separator field.
1291          */
1292         public static final Field DECIMAL_SEPARATOR =
1293                             new Field(&quot;decimal separator&quot;);
1294 
1295         /**
1296          * Constant identifying the sign field.
1297          */
1298         public static final Field SIGN = new Field(&quot;sign&quot;);
1299 
1300         /**
1301          * Constant identifying the grouping separator field.
1302          */
1303         public static final Field GROUPING_SEPARATOR =
1304                             new Field(&quot;grouping separator&quot;);
1305 
1306         /**
1307          * Constant identifying the exponent symbol field.
1308          */
1309         public static final Field EXPONENT_SYMBOL = new
1310                             Field(&quot;exponent symbol&quot;);
1311 
1312         /**
1313          * Constant identifying the percent field.
1314          */
1315         public static final Field PERCENT = new Field(&quot;percent&quot;);
1316 
1317         /**
1318          * Constant identifying the permille field.
1319          */
1320         public static final Field PERMILLE = new Field(&quot;per mille&quot;);
1321 
1322         /**
1323          * Constant identifying the currency field.
1324          */
1325         public static final Field CURRENCY = new Field(&quot;currency&quot;);
1326 
1327         /**
1328          * Constant identifying the exponent sign field.
1329          */
1330         public static final Field EXPONENT_SIGN = new Field(&quot;exponent sign&quot;);
1331 
1332         /**
1333          * Constant identifying the prefix field.
1334          *
1335          * @since 12
1336          */
1337         public static final Field PREFIX = new Field(&quot;prefix&quot;);
1338 
1339         /**
1340          * Constant identifying the suffix field.
1341          *
1342          * @since 12
1343          */
1344         public static final Field SUFFIX = new Field(&quot;suffix&quot;);
1345     }
1346 
1347     /**
1348      * A number format style.
1349      * &lt;p&gt;
1350      * {@code Style} is an enum which represents the style for formatting
1351      * a number within a given {@code NumberFormat} instance.
1352      *
1353      * @see CompactNumberFormat
1354      * @see NumberFormat#getCompactNumberInstance(Locale, Style)
1355      * @since 12
1356      */
1357     public enum Style {
1358 
1359         /**
1360          * The {@code SHORT} number format style.
1361          */
1362         SHORT,
1363 
1364         /**
1365          * The {@code LONG} number format style.
1366          */
1367         LONG
1368 
1369     }
1370 }
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>
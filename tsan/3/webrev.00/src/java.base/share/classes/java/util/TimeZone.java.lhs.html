<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/TimeZone.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.util;
 40 
 41 import java.io.Serializable;
 42 import java.time.ZoneId;
 43 
 44 import jdk.internal.util.StaticProperty;
 45 import sun.security.action.GetPropertyAction;
 46 import sun.util.calendar.ZoneInfo;
 47 import sun.util.calendar.ZoneInfoFile;
 48 import sun.util.locale.provider.TimeZoneNameUtility;
 49 
 50 /**
<a name="2" id="anc2"></a><span class="line-modified"> 51  * &lt;code&gt;TimeZone&lt;/code&gt; represents a time zone offset, and also figures out daylight</span>
 52  * savings.
 53  *
 54  * &lt;p&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 55  * Typically, you get a &lt;code&gt;TimeZone&lt;/code&gt; using &lt;code&gt;getDefault&lt;/code&gt;</span>
<span class="line-modified"> 56  * which creates a &lt;code&gt;TimeZone&lt;/code&gt; based on the time zone where the program</span>
<span class="line-modified"> 57  * is running. For example, for a program running in Japan, &lt;code&gt;getDefault&lt;/code&gt;</span>
<span class="line-modified"> 58  * creates a &lt;code&gt;TimeZone&lt;/code&gt; object based on Japanese Standard Time.</span>
 59  *
 60  * &lt;p&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 61  * You can also get a &lt;code&gt;TimeZone&lt;/code&gt; using &lt;code&gt;getTimeZone&lt;/code&gt;</span>
 62  * along with a time zone ID. For instance, the time zone ID for the
 63  * U.S. Pacific Time zone is &quot;America/Los_Angeles&quot;. So, you can get a
<a name="5" id="anc5"></a><span class="line-modified"> 64  * U.S. Pacific Time &lt;code&gt;TimeZone&lt;/code&gt; object with:</span>
 65  * &lt;blockquote&gt;&lt;pre&gt;
 66  * TimeZone tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);
 67  * &lt;/pre&gt;&lt;/blockquote&gt;
<a name="6" id="anc6"></a><span class="line-modified"> 68  * You can use the &lt;code&gt;getAvailableIDs&lt;/code&gt; method to iterate through</span>
 69  * all the supported time zone IDs. You can then choose a
<a name="7" id="anc7"></a><span class="line-modified"> 70  * supported ID to get a &lt;code&gt;TimeZone&lt;/code&gt;.</span>
 71  * If the time zone you want is not represented by one of the
 72  * supported IDs, then a custom time zone ID can be specified to
 73  * produce a TimeZone. The syntax of a custom time zone ID is:
 74  *
 75  * &lt;blockquote&gt;&lt;pre&gt;
 76  * &lt;a id=&quot;CustomID&quot;&gt;&lt;i&gt;CustomID:&lt;/i&gt;&lt;/a&gt;
<a name="8" id="anc8"></a><span class="line-modified"> 77  *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;</span>
<span class="line-modified"> 78  *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;</span>
<span class="line-modified"> 79  *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt;</span>
 80  * &lt;i&gt;Sign:&lt;/i&gt; one of
<a name="9" id="anc9"></a><span class="line-modified"> 81  *         &lt;code&gt;+ -&lt;/code&gt;</span>
 82  * &lt;i&gt;Hours:&lt;/i&gt;
 83  *         &lt;i&gt;Digit&lt;/i&gt;
 84  *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 85  * &lt;i&gt;Minutes:&lt;/i&gt;
 86  *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 87  * &lt;i&gt;Digit:&lt;/i&gt; one of
<a name="10" id="anc10"></a><span class="line-modified"> 88  *         &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;</span>
 89  * &lt;/pre&gt;&lt;/blockquote&gt;
 90  *
 91  * &lt;i&gt;Hours&lt;/i&gt; must be between 0 to 23 and &lt;i&gt;Minutes&lt;/i&gt; must be
 92  * between 00 to 59.  For example, &quot;GMT+10&quot; and &quot;GMT+0010&quot; mean ten
 93  * hours and ten minutes ahead of GMT, respectively.
 94  * &lt;p&gt;
 95  * The format is locale independent and digits must be taken from the
 96  * Basic Latin block of the Unicode standard. No daylight saving time
 97  * transition schedule can be specified with a custom time zone ID. If
<a name="11" id="anc11"></a><span class="line-modified"> 98  * the specified string doesn&#39;t match the syntax, &lt;code&gt;&quot;GMT&quot;&lt;/code&gt;</span>
 99  * is used.
100  * &lt;p&gt;
<a name="12" id="anc12"></a><span class="line-modified">101  * When creating a &lt;code&gt;TimeZone&lt;/code&gt;, the specified custom time</span>
102  * zone ID is normalized in the following syntax:
103  * &lt;blockquote&gt;&lt;pre&gt;
104  * &lt;a id=&quot;NormalizedCustomID&quot;&gt;&lt;i&gt;NormalizedCustomID:&lt;/i&gt;&lt;/a&gt;
<a name="13" id="anc13"></a><span class="line-modified">105  *         &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;</span>
106  * &lt;i&gt;Sign:&lt;/i&gt; one of
<a name="14" id="anc14"></a><span class="line-modified">107  *         &lt;code&gt;+ -&lt;/code&gt;</span>
108  * &lt;i&gt;TwoDigitHours:&lt;/i&gt;
109  *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
110  * &lt;i&gt;Minutes:&lt;/i&gt;
111  *         &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
112  * &lt;i&gt;Digit:&lt;/i&gt; one of
<a name="15" id="anc15"></a><span class="line-modified">113  *         &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;</span>
114  * &lt;/pre&gt;&lt;/blockquote&gt;
115  * For example, TimeZone.getTimeZone(&quot;GMT-8&quot;).getID() returns &quot;GMT-08:00&quot;.
116  *
<a name="16" id="anc16"></a><span class="line-modified">117  * &lt;h3&gt;Three-letter time zone IDs&lt;/h3&gt;</span>
118  *
119  * For compatibility with JDK 1.1.x, some other three-letter time zone IDs
120  * (such as &quot;PST&quot;, &quot;CTT&quot;, &quot;AST&quot;) are also supported. However, &lt;strong&gt;their
121  * use is deprecated&lt;/strong&gt; because the same abbreviation is often used
122  * for multiple time zones (for example, &quot;CST&quot; could be U.S. &quot;Central Standard
123  * Time&quot; and &quot;China Standard Time&quot;), and the Java platform can then only
124  * recognize one of them.
125  *
126  *
127  * @see          Calendar
128  * @see          GregorianCalendar
129  * @see          SimpleTimeZone
130  * @author       Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
131  * @since        1.1
132  */
133 public abstract class TimeZone implements Serializable, Cloneable {
134     /**
135      * Sole constructor.  (For invocation by subclass constructors, typically
136      * implicit.)
137      */
138     public TimeZone() {
139     }
140 
141     /**
<a name="17" id="anc17"></a><span class="line-modified">142      * A style specifier for &lt;code&gt;getDisplayName()&lt;/code&gt; indicating</span>
143      * a short name, such as &quot;PST.&quot;
144      * @see #LONG
145      * @since 1.2
146      */
147     public static final int SHORT = 0;
148 
149     /**
<a name="18" id="anc18"></a><span class="line-modified">150      * A style specifier for &lt;code&gt;getDisplayName()&lt;/code&gt; indicating</span>
151      * a long name, such as &quot;Pacific Standard Time.&quot;
152      * @see #SHORT
153      * @since 1.2
154      */
155     public static final int LONG  = 1;
156 
157     // Constants used internally; unit is milliseconds
158     private static final int ONE_MINUTE = 60*1000;
159     private static final int ONE_HOUR   = 60*ONE_MINUTE;
160     private static final int ONE_DAY    = 24*ONE_HOUR;
161 
162     // Proclaim serialization compatibility with JDK 1.1
<a name="19" id="anc19"></a>
163     static final long serialVersionUID = 3581463369166924961L;
164 
165     /**
166      * Gets the time zone offset, for current date, modified in case of
167      * daylight savings. This is the offset to add to UTC to get local time.
168      * &lt;p&gt;
169      * This method returns a historically correct offset if an
<a name="20" id="anc20"></a><span class="line-modified">170      * underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass</span>
171      * supports historical Daylight Saving Time schedule and GMT
172      * offset changes.
173      *
174      * @param era the era of the given date.
175      * @param year the year in the given date.
176      * @param month the month in the given date.
177      * Month is 0-based. e.g., 0 for January.
178      * @param day the day-in-month of the given date.
179      * @param dayOfWeek the day-of-week of the given date.
180      * @param milliseconds the milliseconds in day in &lt;em&gt;standard&lt;/em&gt;
181      * local time.
182      *
183      * @return the offset in milliseconds to add to GMT to get local time.
184      *
185      * @see Calendar#ZONE_OFFSET
186      * @see Calendar#DST_OFFSET
187      */
188     public abstract int getOffset(int era, int year, int month, int day,
189                                   int dayOfWeek, int milliseconds);
190 
191     /**
192      * Returns the offset of this time zone from UTC at the specified
193      * date. If Daylight Saving Time is in effect at the specified
194      * date, the offset value is adjusted with the amount of daylight
195      * saving.
196      * &lt;p&gt;
197      * This method returns a historically correct offset value if an
198      * underlying TimeZone implementation subclass supports historical
199      * Daylight Saving Time schedule and GMT offset changes.
200      *
201      * @param date the date represented in milliseconds since January 1, 1970 00:00:00 GMT
202      * @return the amount of time in milliseconds to add to UTC to get local time.
203      *
204      * @see Calendar#ZONE_OFFSET
205      * @see Calendar#DST_OFFSET
206      * @since 1.4
207      */
208     public int getOffset(long date) {
209         if (inDaylightTime(new Date(date))) {
210             return getRawOffset() + getDSTSavings();
211         }
212         return getRawOffset();
213     }
214 
215     /**
216      * Gets the raw GMT offset and the amount of daylight saving of this
217      * time zone at the given time.
218      * @param date the milliseconds (since January 1, 1970,
219      * 00:00:00.000 GMT) at which the time zone offset and daylight
220      * saving amount are found
221      * @param offsets an array of int where the raw GMT offset
222      * (offset[0]) and daylight saving amount (offset[1]) are stored,
223      * or null if those values are not needed. The method assumes that
224      * the length of the given array is two or larger.
225      * @return the total amount of the raw GMT offset and daylight
226      * saving at the specified date.
227      *
228      * @see Calendar#ZONE_OFFSET
229      * @see Calendar#DST_OFFSET
230      */
231     int getOffsets(long date, int[] offsets) {
232         int rawoffset = getRawOffset();
233         int dstoffset = 0;
234         if (inDaylightTime(new Date(date))) {
235             dstoffset = getDSTSavings();
236         }
237         if (offsets != null) {
238             offsets[0] = rawoffset;
239             offsets[1] = dstoffset;
240         }
241         return rawoffset + dstoffset;
242     }
243 
244     /**
245      * Sets the base time zone offset to GMT.
246      * This is the offset to add to UTC to get local time.
247      * &lt;p&gt;
<a name="21" id="anc21"></a><span class="line-modified">248      * If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass</span>
249      * supports historical GMT offset changes, the specified GMT
250      * offset is set as the latest GMT offset and the difference from
251      * the known latest GMT offset value is used to adjust all
252      * historical GMT offset values.
253      *
254      * @param offsetMillis the given base time zone offset to GMT.
255      */
256     public abstract void setRawOffset(int offsetMillis);
257 
258     /**
259      * Returns the amount of time in milliseconds to add to UTC to get
260      * standard time in this time zone. Because this value is not
261      * affected by daylight saving time, it is called &lt;I&gt;raw
262      * offset&lt;/I&gt;.
263      * &lt;p&gt;
<a name="22" id="anc22"></a><span class="line-modified">264      * If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass</span>
265      * supports historical GMT offset changes, the method returns the
266      * raw offset value of the current date. In Honolulu, for example,
267      * its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and
268      * this method always returns -36000000 milliseconds (i.e., -10
269      * hours).
270      *
271      * @return the amount of raw offset time in milliseconds to add to UTC.
272      * @see Calendar#ZONE_OFFSET
273      */
274     public abstract int getRawOffset();
275 
276     /**
277      * Gets the ID of this time zone.
278      * @return the ID of this time zone.
279      */
280     public String getID()
281     {
282         return ID;
283     }
284 
285     /**
286      * Sets the time zone ID. This does not change any other data in
287      * the time zone object.
288      * @param ID the new time zone ID.
289      */
290     public void setID(String ID)
291     {
292         if (ID == null) {
293             throw new NullPointerException();
294         }
295         this.ID = ID;
296         this.zoneId = null;   // invalidate cache
297     }
298 
299     /**
300      * Returns a long standard time name of this {@code TimeZone} suitable for
301      * presentation to the user in the default locale.
302      *
303      * &lt;p&gt;This method is equivalent to:
304      * &lt;blockquote&gt;&lt;pre&gt;
305      * getDisplayName(false, {@link #LONG},
306      *                Locale.getDefault({@link Locale.Category#DISPLAY}))
307      * &lt;/pre&gt;&lt;/blockquote&gt;
308      *
309      * @return the human-readable name of this time zone in the default locale.
310      * @since 1.2
311      * @see #getDisplayName(boolean, int, Locale)
312      * @see Locale#getDefault(Locale.Category)
313      * @see Locale.Category
314      */
315     public final String getDisplayName() {
316         return getDisplayName(false, LONG,
317                               Locale.getDefault(Locale.Category.DISPLAY));
318     }
319 
320     /**
321      * Returns a long standard time name of this {@code TimeZone} suitable for
322      * presentation to the user in the specified {@code locale}.
323      *
324      * &lt;p&gt;This method is equivalent to:
325      * &lt;blockquote&gt;&lt;pre&gt;
326      * getDisplayName(false, {@link #LONG}, locale)
327      * &lt;/pre&gt;&lt;/blockquote&gt;
328      *
329      * @param locale the locale in which to supply the display name.
330      * @return the human-readable name of this time zone in the given locale.
<a name="23" id="anc23"></a><span class="line-modified">331      * @exception NullPointerException if {@code locale} is {@code null}.</span>
332      * @since 1.2
333      * @see #getDisplayName(boolean, int, Locale)
334      */
335     public final String getDisplayName(Locale locale) {
336         return getDisplayName(false, LONG, locale);
337     }
338 
339     /**
340      * Returns a name in the specified {@code style} of this {@code TimeZone}
341      * suitable for presentation to the user in the default locale. If the
342      * specified {@code daylight} is {@code true}, a Daylight Saving Time name
343      * is returned (even if this {@code TimeZone} doesn&#39;t observe Daylight Saving
344      * Time). Otherwise, a Standard Time name is returned.
345      *
346      * &lt;p&gt;This method is equivalent to:
347      * &lt;blockquote&gt;&lt;pre&gt;
348      * getDisplayName(daylight, style,
349      *                Locale.getDefault({@link Locale.Category#DISPLAY}))
350      * &lt;/pre&gt;&lt;/blockquote&gt;
351      *
352      * @param daylight {@code true} specifying a Daylight Saving Time name, or
353      *                 {@code false} specifying a Standard Time name
354      * @param style either {@link #LONG} or {@link #SHORT}
355      * @return the human-readable name of this time zone in the default locale.
<a name="24" id="anc24"></a><span class="line-modified">356      * @exception IllegalArgumentException if {@code style} is invalid.</span>
357      * @since 1.2
358      * @see #getDisplayName(boolean, int, Locale)
359      * @see Locale#getDefault(Locale.Category)
360      * @see Locale.Category
361      * @see java.text.DateFormatSymbols#getZoneStrings()
362      */
363     public final String getDisplayName(boolean daylight, int style) {
364         return getDisplayName(daylight, style,
365                               Locale.getDefault(Locale.Category.DISPLAY));
366     }
367 
368     /**
369      * Returns a name in the specified {@code style} of this {@code TimeZone}
370      * suitable for presentation to the user in the specified {@code
371      * locale}. If the specified {@code daylight} is {@code true}, a Daylight
372      * Saving Time name is returned (even if this {@code TimeZone} doesn&#39;t
373      * observe Daylight Saving Time). Otherwise, a Standard Time name is
374      * returned.
375      *
376      * &lt;p&gt;When looking up a time zone name, the {@linkplain
377      * ResourceBundle.Control#getCandidateLocales(String,Locale) default
<a name="25" id="anc25"></a><span class="line-modified">378      * &lt;code&gt;Locale&lt;/code&gt; search path of &lt;code&gt;ResourceBundle&lt;/code&gt;} derived</span>
379      * from the specified {@code locale} is used. (No {@linkplain
380      * ResourceBundle.Control#getFallbackLocale(String,Locale) fallback
<a name="26" id="anc26"></a><span class="line-modified">381      * &lt;code&gt;Locale&lt;/code&gt;} search is performed.) If a time zone name in any</span>
382      * {@code Locale} of the search path, including {@link Locale#ROOT}, is
383      * found, the name is returned. Otherwise, a string in the
384      * &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.
385      *
386      * @param daylight {@code true} specifying a Daylight Saving Time name, or
387      *                 {@code false} specifying a Standard Time name
388      * @param style either {@link #LONG} or {@link #SHORT}
389      * @param locale   the locale in which to supply the display name.
390      * @return the human-readable name of this time zone in the given locale.
<a name="27" id="anc27"></a><span class="line-modified">391      * @exception IllegalArgumentException if {@code style} is invalid.</span>
<span class="line-modified">392      * @exception NullPointerException if {@code locale} is {@code null}.</span>
393      * @since 1.2
394      * @see java.text.DateFormatSymbols#getZoneStrings()
395      */
396     public String getDisplayName(boolean daylight, int style, Locale locale) {
397         if (style != SHORT &amp;&amp; style != LONG) {
398             throw new IllegalArgumentException(&quot;Illegal style: &quot; + style);
399         }
400         String id = getID();
401         String name = TimeZoneNameUtility.retrieveDisplayName(id, daylight, style, locale);
402         if (name != null) {
403             return name;
404         }
405 
406         if (id.startsWith(&quot;GMT&quot;) &amp;&amp; id.length() &gt; 3) {
407             char sign = id.charAt(3);
408             if (sign == &#39;+&#39; || sign == &#39;-&#39;) {
409                 return id;
410             }
411         }
412         int offset = getRawOffset();
413         if (daylight) {
414             offset += getDSTSavings();
415         }
416         return ZoneInfoFile.toCustomID(offset);
417     }
418 
419     private static String[] getDisplayNames(String id, Locale locale) {
420         return TimeZoneNameUtility.retrieveDisplayNames(id, locale);
421     }
422 
423     /**
424      * Returns the amount of time to be added to local standard time
425      * to get local wall clock time.
426      *
427      * &lt;p&gt;The default implementation returns 3600000 milliseconds
428      * (i.e., one hour) if a call to {@link #useDaylightTime()}
429      * returns {@code true}. Otherwise, 0 (zero) is returned.
430      *
431      * &lt;p&gt;If an underlying {@code TimeZone} implementation subclass
432      * supports historical and future Daylight Saving Time schedule
433      * changes, this method returns the amount of saving time of the
434      * last known Daylight Saving Time rule that can be a future
435      * prediction.
436      *
437      * &lt;p&gt;If the amount of saving time at any given time stamp is
438      * required, construct a {@link Calendar} with this {@code
439      * TimeZone} and the time stamp, and call {@link Calendar#get(int)
440      * Calendar.get}{@code (}{@link Calendar#DST_OFFSET}{@code )}.
441      *
442      * @return the amount of saving time in milliseconds
443      * @since 1.4
444      * @see #inDaylightTime(Date)
445      * @see #getOffset(long)
446      * @see #getOffset(int,int,int,int,int,int)
447      * @see Calendar#ZONE_OFFSET
448      */
449     public int getDSTSavings() {
450         if (useDaylightTime()) {
451             return 3600000;
452         }
453         return 0;
454     }
455 
456     /**
457      * Queries if this {@code TimeZone} uses Daylight Saving Time.
458      *
459      * &lt;p&gt;If an underlying {@code TimeZone} implementation subclass
460      * supports historical and future Daylight Saving Time schedule
461      * changes, this method refers to the last known Daylight Saving Time
462      * rule that can be a future prediction and may not be the same as
463      * the current rule. Consider calling {@link #observesDaylightTime()}
464      * if the current rule should also be taken into account.
465      *
466      * @return {@code true} if this {@code TimeZone} uses Daylight Saving Time,
467      *         {@code false}, otherwise.
468      * @see #inDaylightTime(Date)
469      * @see Calendar#DST_OFFSET
470      */
471     public abstract boolean useDaylightTime();
472 
473     /**
474      * Returns {@code true} if this {@code TimeZone} is currently in
475      * Daylight Saving Time, or if a transition from Standard Time to
476      * Daylight Saving Time occurs at any future time.
477      *
478      * &lt;p&gt;The default implementation returns {@code true} if
479      * {@code useDaylightTime()} or {@code inDaylightTime(new Date())}
480      * returns {@code true}.
481      *
482      * @return {@code true} if this {@code TimeZone} is currently in
483      * Daylight Saving Time, or if a transition from Standard Time to
484      * Daylight Saving Time occurs at any future time; {@code false}
485      * otherwise.
486      * @since 1.7
487      * @see #useDaylightTime()
488      * @see #inDaylightTime(Date)
489      * @see Calendar#DST_OFFSET
490      */
491     public boolean observesDaylightTime() {
492         return useDaylightTime() || inDaylightTime(new Date());
493     }
494 
495     /**
496      * Queries if the given {@code date} is in Daylight Saving Time in
497      * this time zone.
498      *
499      * @param date the given Date.
500      * @return {@code true} if the given date is in Daylight Saving Time,
501      *         {@code false}, otherwise.
502      */
503     public abstract boolean inDaylightTime(Date date);
504 
505     /**
<a name="28" id="anc28"></a><span class="line-modified">506      * Gets the &lt;code&gt;TimeZone&lt;/code&gt; for the given ID.</span>
507      *
<a name="29" id="anc29"></a><span class="line-modified">508      * @param ID the ID for a &lt;code&gt;TimeZone&lt;/code&gt;, either an abbreviation</span>
509      * such as &quot;PST&quot;, a full name such as &quot;America/Los_Angeles&quot;, or a custom
510      * ID such as &quot;GMT-8:00&quot;. Note that the support of abbreviations is
511      * for JDK 1.1.x compatibility only and full names should be used.
512      *
<a name="30" id="anc30"></a><span class="line-modified">513      * @return the specified &lt;code&gt;TimeZone&lt;/code&gt;, or the GMT zone if the given ID</span>
514      * cannot be understood.
515      */
516     public static synchronized TimeZone getTimeZone(String ID) {
517         return getTimeZone(ID, true);
518     }
519 
520     /**
521      * Gets the {@code TimeZone} for the given {@code zoneId}.
522      *
523      * @param zoneId a {@link ZoneId} from which the time zone ID is obtained
524      * @return the specified {@code TimeZone}, or the GMT zone if the given ID
525      *         cannot be understood.
526      * @throws NullPointerException if {@code zoneId} is {@code null}
527      * @since 1.8
528      */
529     public static TimeZone getTimeZone(ZoneId zoneId) {
530         String tzid = zoneId.getId(); // throws an NPE if null
531         char c = tzid.charAt(0);
532         if (c == &#39;+&#39; || c == &#39;-&#39;) {
533             tzid = &quot;GMT&quot; + tzid;
534         } else if (c == &#39;Z&#39; &amp;&amp; tzid.length() == 1) {
535             tzid = &quot;UTC&quot;;
536         }
537         return getTimeZone(tzid, true);
538     }
539 
540     /**
541      * Converts this {@code TimeZone} object to a {@code ZoneId}.
542      *
543      * @return a {@code ZoneId} representing the same time zone as this
544      *         {@code TimeZone}
545      * @since 1.8
546      */
547     public ZoneId toZoneId() {
548         ZoneId zId = zoneId;
549         if (zId == null) {
550             zoneId = zId = toZoneId0();
551         }
552         return zId;
553     }
554 
555     private ZoneId toZoneId0() {
556         String id = getID();
557         TimeZone defaultZone = defaultTimeZone;
558         // are we not defaultTimeZone but our id is equal to default&#39;s?
559         if (defaultZone != this &amp;&amp;
560             defaultZone != null &amp;&amp; id.equals(defaultZone.getID())) {
561             // delegate to default TZ which is effectively immutable
562             return defaultZone.toZoneId();
563         }
564         // derive it ourselves
565         if (ZoneInfoFile.useOldMapping() &amp;&amp; id.length() == 3) {
566             if (&quot;EST&quot;.equals(id))
567                 return ZoneId.of(&quot;America/New_York&quot;);
568             if (&quot;MST&quot;.equals(id))
569                 return ZoneId.of(&quot;America/Denver&quot;);
570             if (&quot;HST&quot;.equals(id))
571                 return ZoneId.of(&quot;America/Honolulu&quot;);
572         }
573         return ZoneId.of(id, ZoneId.SHORT_IDS);
574     }
575 
576     private static TimeZone getTimeZone(String ID, boolean fallback) {
577         TimeZone tz = ZoneInfo.getTimeZone(ID);
578         if (tz == null) {
579             tz = parseCustomTimeZone(ID);
580             if (tz == null &amp;&amp; fallback) {
581                 tz = new ZoneInfo(GMT_ID, 0);
582             }
583         }
584         return tz;
585     }
586 
587     /**
588      * Gets the available IDs according to the given time zone offset in milliseconds.
589      *
590      * @param rawOffset the given time zone GMT offset in milliseconds.
591      * @return an array of IDs, where the time zone for that ID has
592      * the specified GMT offset. For example, &quot;America/Phoenix&quot; and &quot;America/Denver&quot;
593      * both have GMT-07:00, but differ in daylight saving behavior.
594      * @see #getRawOffset()
595      */
596     public static synchronized String[] getAvailableIDs(int rawOffset) {
597         return ZoneInfo.getAvailableIDs(rawOffset);
598     }
599 
600     /**
601      * Gets all the available IDs supported.
602      * @return an array of IDs.
603      */
604     public static synchronized String[] getAvailableIDs() {
605         return ZoneInfo.getAvailableIDs();
606     }
607 
608     /**
609      * Gets the platform defined TimeZone ID.
610      **/
611     private static native String getSystemTimeZoneID(String javaHome);
612 
613     /**
614      * Gets the custom time zone ID based on the GMT offset of the
615      * platform. (e.g., &quot;GMT+08:00&quot;)
616      */
617     private static native String getSystemGMTOffsetID();
618 
619     /**
620      * Gets the default {@code TimeZone} of the Java virtual machine. If the
621      * cached default {@code TimeZone} is available, its clone is returned.
622      * Otherwise, the method takes the following steps to determine the default
623      * time zone.
624      *
625      * &lt;ul&gt;
626      * &lt;li&gt;Use the {@code user.timezone} property value as the default
627      * time zone ID if it&#39;s available.&lt;/li&gt;
628      * &lt;li&gt;Detect the platform time zone ID. The source of the
629      * platform time zone and ID mapping may vary with implementation.&lt;/li&gt;
630      * &lt;li&gt;Use {@code GMT} as the last resort if the given or detected
631      * time zone ID is unknown.&lt;/li&gt;
632      * &lt;/ul&gt;
633      *
634      * &lt;p&gt;The default {@code TimeZone} created from the ID is cached,
635      * and its clone is returned. The {@code user.timezone} property
636      * value is set to the ID upon return.
637      *
638      * @return the default {@code TimeZone}
639      * @see #setDefault(TimeZone)
640      */
641     public static TimeZone getDefault() {
642         return (TimeZone) getDefaultRef().clone();
643     }
644 
645     /**
646      * Returns the reference to the default TimeZone object. This
647      * method doesn&#39;t create a clone.
648      */
649     static TimeZone getDefaultRef() {
650         TimeZone defaultZone = defaultTimeZone;
651         if (defaultZone == null) {
652             // Need to initialize the default time zone.
653             defaultZone = setDefaultZone();
654             assert defaultZone != null;
655         }
656         // Don&#39;t clone here.
657         return defaultZone;
658     }
659 
660     private static synchronized TimeZone setDefaultZone() {
661         TimeZone tz;
662         // get the time zone ID from the system properties
663         Properties props = GetPropertyAction.privilegedGetProperties();
664         String zoneID = props.getProperty(&quot;user.timezone&quot;);
665 
666         // if the time zone ID is not set (yet), perform the
667         // platform to Java time zone ID mapping.
668         if (zoneID == null || zoneID.isEmpty()) {
669             String javaHome = StaticProperty.javaHome();
670             try {
671                 zoneID = getSystemTimeZoneID(javaHome);
672                 if (zoneID == null) {
673                     zoneID = GMT_ID;
674                 }
675             } catch (NullPointerException e) {
676                 zoneID = GMT_ID;
677             }
678         }
679 
680         // Get the time zone for zoneID. But not fall back to
681         // &quot;GMT&quot; here.
682         tz = getTimeZone(zoneID, false);
683 
684         if (tz == null) {
685             // If the given zone ID is unknown in Java, try to
686             // get the GMT-offset-based time zone ID,
687             // a.k.a. custom time zone ID (e.g., &quot;GMT-08:00&quot;).
688             String gmtOffsetID = getSystemGMTOffsetID();
689             if (gmtOffsetID != null) {
690                 zoneID = gmtOffsetID;
691             }
692             tz = getTimeZone(zoneID, true);
693         }
694         assert tz != null;
695 
696         final String id = zoneID;
697         props.setProperty(&quot;user.timezone&quot;, id);
698 
699         defaultTimeZone = tz;
700         return tz;
701     }
702 
703     /**
704      * Sets the {@code TimeZone} that is returned by the {@code getDefault}
705      * method. {@code zone} is cached. If {@code zone} is null, the cached
706      * default {@code TimeZone} is cleared. This method doesn&#39;t change the value
707      * of the {@code user.timezone} property.
708      *
709      * @param zone the new default {@code TimeZone}, or null
710      * @throws SecurityException if the security manager&#39;s {@code checkPermission}
711      *                           denies {@code PropertyPermission(&quot;user.timezone&quot;,
712      *                           &quot;write&quot;)}
713      * @see #getDefault
714      * @see PropertyPermission
715      */
716     public static void setDefault(TimeZone zone)
717     {
718         SecurityManager sm = System.getSecurityManager();
719         if (sm != null) {
720             sm.checkPermission(new PropertyPermission
721                                (&quot;user.timezone&quot;, &quot;write&quot;));
722         }
723         // by saving a defensive clone and returning a clone in getDefault() too,
724         // the defaultTimeZone instance is isolated from user code which makes it
725         // effectively immutable. This is important to avoid races when the
726         // following is evaluated in ZoneId.systemDefault():
727         // TimeZone.getDefault().toZoneId().
728         defaultTimeZone = (zone == null) ? null : (TimeZone) zone.clone();
729     }
730 
731     /**
732      * Returns true if this zone has the same rule and offset as another zone.
733      * That is, if this zone differs only in ID, if at all.  Returns false
734      * if the other zone is null.
<a name="31" id="anc31"></a><span class="line-modified">735      * @param other the &lt;code&gt;TimeZone&lt;/code&gt; object to be compared with</span>
736      * @return true if the other zone is not null and is the same as this one,
737      * with the possible exception of the ID
738      * @since 1.2
739      */
740     public boolean hasSameRules(TimeZone other) {
741         return other != null &amp;&amp; getRawOffset() == other.getRawOffset() &amp;&amp;
742             useDaylightTime() == other.useDaylightTime();
743     }
744 
745     /**
<a name="32" id="anc32"></a><span class="line-modified">746      * Creates a copy of this &lt;code&gt;TimeZone&lt;/code&gt;.</span>
747      *
<a name="33" id="anc33"></a><span class="line-modified">748      * @return a clone of this &lt;code&gt;TimeZone&lt;/code&gt;</span>
749      */
750     public Object clone()
751     {
752         try {
753             return super.clone();
754         } catch (CloneNotSupportedException e) {
755             throw new InternalError(e);
756         }
757     }
758 
759     /**
760      * The null constant as a TimeZone.
761      */
762     static final TimeZone NO_TIMEZONE = null;
763 
764     // =======================privates===============================
765 
766     /**
<a name="34" id="anc34"></a><span class="line-modified">767      * The string identifier of this &lt;code&gt;TimeZone&lt;/code&gt;.  This is a</span>
<span class="line-modified">768      * programmatic identifier used internally to look up &lt;code&gt;TimeZone&lt;/code&gt;</span>
769      * objects from the system table and also to map them to their localized
<a name="35" id="anc35"></a><span class="line-modified">770      * display names.  &lt;code&gt;ID&lt;/code&gt; values are unique in the system</span>
771      * table but may not be for dynamically created zones.
772      * @serial
773      */
774     private String           ID;
775 
776     /**
777      * Cached {@link ZoneId} for this TimeZone
778      */
779     private transient ZoneId zoneId;
780 
781     private static volatile TimeZone defaultTimeZone;
782 
783     static final String         GMT_ID        = &quot;GMT&quot;;
784     private static final int    GMT_ID_LENGTH = 3;
785 
786     /**
787      * Parses a custom time zone identifier and returns a corresponding zone.
788      * This method doesn&#39;t support the RFC 822 time zone format. (e.g., +hhmm)
789      *
790      * @param id a string of the &lt;a href=&quot;#CustomID&quot;&gt;custom ID form&lt;/a&gt;.
791      * @return a newly created TimeZone with the given offset and
792      * no daylight saving time, or null if the id cannot be parsed.
793      */
794     private static final TimeZone parseCustomTimeZone(String id) {
795         int length;
796 
797         // Error if the length of id isn&#39;t long enough or id doesn&#39;t
798         // start with &quot;GMT&quot;.
799         if ((length = id.length()) &lt; (GMT_ID_LENGTH + 2) ||
800             id.indexOf(GMT_ID) != 0) {
801             return null;
802         }
803 
804         ZoneInfo zi;
805 
806         // First, we try to find it in the cache with the given
807         // id. Even the id is not normalized, the returned ZoneInfo
808         // should have its normalized id.
809         zi = ZoneInfoFile.getZoneInfo(id);
810         if (zi != null) {
811             return zi;
812         }
813 
814         int index = GMT_ID_LENGTH;
815         boolean negative = false;
816         char c = id.charAt(index++);
817         if (c == &#39;-&#39;) {
818             negative = true;
819         } else if (c != &#39;+&#39;) {
820             return null;
821         }
822 
823         int hours = 0;
824         int num = 0;
825         int countDelim = 0;
826         int len = 0;
827         while (index &lt; length) {
828             c = id.charAt(index++);
829             if (c == &#39;:&#39;) {
830                 if (countDelim &gt; 0) {
831                     return null;
832                 }
833                 if (len &gt; 2) {
834                     return null;
835                 }
836                 hours = num;
837                 countDelim++;
838                 num = 0;
839                 len = 0;
840                 continue;
841             }
842             if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
843                 return null;
844             }
845             num = num * 10 + (c - &#39;0&#39;);
846             len++;
847         }
848         if (index != length) {
849             return null;
850         }
851         if (countDelim == 0) {
852             if (len &lt;= 2) {
853                 hours = num;
854                 num = 0;
855             } else {
856                 hours = num / 100;
857                 num %= 100;
858             }
859         } else {
860             if (len != 2) {
861                 return null;
862             }
863         }
864         if (hours &gt; 23 || num &gt; 59) {
865             return null;
866         }
867         int gmtOffset =  (hours * 60 + num) * 60 * 1000;
868 
869         if (gmtOffset == 0) {
870             zi = ZoneInfoFile.getZoneInfo(GMT_ID);
871             if (negative) {
872                 zi.setID(&quot;GMT-00:00&quot;);
873             } else {
874                 zi.setID(&quot;GMT+00:00&quot;);
875             }
876         } else {
877             zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
878         }
879         return zi;
880     }
881 }
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
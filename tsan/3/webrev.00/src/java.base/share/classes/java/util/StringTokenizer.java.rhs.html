<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/StringTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import java.lang.*;
 29 
 30 /**
 31  * The string tokenizer class allows an application to break a
 32  * string into tokens. The tokenization method is much simpler than
 33  * the one used by the {@code StreamTokenizer} class. The
 34  * {@code StringTokenizer} methods do not distinguish among
 35  * identifiers, numbers, and quoted strings, nor do they recognize
 36  * and skip comments.
 37  * &lt;p&gt;
 38  * The set of delimiters (the characters that separate tokens) may
 39  * be specified either at creation time or on a per-token basis.
 40  * &lt;p&gt;
 41  * An instance of {@code StringTokenizer} behaves in one of two
 42  * ways, depending on whether it was created with the
 43  * {@code returnDelims} flag having the value {@code true}
 44  * or {@code false}:
 45  * &lt;ul&gt;
 46  * &lt;li&gt;If the flag is {@code false}, delimiter characters serve to
 47  *     separate tokens. A token is a maximal sequence of consecutive
 48  *     characters that are not delimiters.
 49  * &lt;li&gt;If the flag is {@code true}, delimiter characters are themselves
 50  *     considered to be tokens. A token is thus either one delimiter
 51  *     character, or a maximal sequence of consecutive characters that are
 52  *     not delimiters.
 53  * &lt;/ul&gt;&lt;p&gt;
 54  * A {@code StringTokenizer} object internally maintains a current
 55  * position within the string to be tokenized. Some operations advance this
 56  * current position past the characters processed.&lt;p&gt;
 57  * A token is returned by taking a substring of the string that was used to
 58  * create the {@code StringTokenizer} object.
 59  * &lt;p&gt;
 60  * The following is one example of the use of the tokenizer. The code:
 61  * &lt;blockquote&gt;&lt;pre&gt;
 62  *     StringTokenizer st = new StringTokenizer(&quot;this is a test&quot;);
 63  *     while (st.hasMoreTokens()) {
 64  *         System.out.println(st.nextToken());
 65  *     }
 66  * &lt;/pre&gt;&lt;/blockquote&gt;
 67  * &lt;p&gt;
 68  * prints the following output:
 69  * &lt;blockquote&gt;&lt;pre&gt;
 70  *     this
 71  *     is
 72  *     a
 73  *     test
 74  * &lt;/pre&gt;&lt;/blockquote&gt;
 75  *
 76  * &lt;p&gt;
 77  * {@code StringTokenizer} is a legacy class that is retained for
 78  * compatibility reasons although its use is discouraged in new code. It is
 79  * recommended that anyone seeking this functionality use the {@code split}
 80  * method of {@code String} or the java.util.regex package instead.
 81  * &lt;p&gt;
 82  * The following example illustrates how the {@code String.split}
 83  * method can be used to break up a string into its basic tokens:
 84  * &lt;blockquote&gt;&lt;pre&gt;
 85  *     String[] result = &quot;this is a test&quot;.split(&quot;\\s&quot;);
 86  *     for (int x=0; x&amp;lt;result.length; x++)
 87  *         System.out.println(result[x]);
 88  * &lt;/pre&gt;&lt;/blockquote&gt;
 89  * &lt;p&gt;
 90  * prints the following output:
 91  * &lt;blockquote&gt;&lt;pre&gt;
 92  *     this
 93  *     is
 94  *     a
 95  *     test
 96  * &lt;/pre&gt;&lt;/blockquote&gt;
 97  *
 98  * @author  unascribed
 99  * @see     java.io.StreamTokenizer
100  * @since   1.0
101  */
<a name="2" id="anc2"></a><span class="line-modified">102 public class StringTokenizer implements Enumeration&lt;Object&gt; {</span>

103     private int currentPosition;
104     private int newPosition;
105     private int maxPosition;
106     private String str;
107     private String delimiters;
108     private boolean retDelims;
109     private boolean delimsChanged;
110 
111     /**
112      * maxDelimCodePoint stores the value of the delimiter character with the
113      * highest value. It is used to optimize the detection of delimiter
114      * characters.
115      *
116      * It is unlikely to provide any optimization benefit in the
117      * hasSurrogates case because most string characters will be
118      * smaller than the limit, but we keep it so that the two code
119      * paths remain similar.
120      */
121     private int maxDelimCodePoint;
122 
123     /**
124      * If delimiters include any surrogates (including surrogate
125      * pairs), hasSurrogates is true and the tokenizer uses the
126      * different code path. This is because String.indexOf(int)
127      * doesn&#39;t handle unpaired surrogates as a single character.
128      */
129     private boolean hasSurrogates = false;
130 
131     /**
132      * When hasSurrogates is true, delimiters are converted to code
133      * points and isDelimiter(int) is used to determine if the given
134      * codepoint is a delimiter.
135      */
136     private int[] delimiterCodePoints;
137 
138     /**
139      * Set maxDelimCodePoint to the highest char in the delimiter set.
140      */
141     private void setMaxDelimCodePoint() {
142         if (delimiters == null) {
143             maxDelimCodePoint = 0;
144             return;
145         }
146 
147         int m = 0;
148         int c;
149         int count = 0;
150         for (int i = 0; i &lt; delimiters.length(); i += Character.charCount(c)) {
151             c = delimiters.charAt(i);
152             if (c &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; c &lt;= Character.MAX_LOW_SURROGATE) {
153                 c = delimiters.codePointAt(i);
154                 hasSurrogates = true;
155             }
156             if (m &lt; c)
157                 m = c;
158             count++;
159         }
160         maxDelimCodePoint = m;
161 
162         if (hasSurrogates) {
163             delimiterCodePoints = new int[count];
164             for (int i = 0, j = 0; i &lt; count; i++, j += Character.charCount(c)) {
165                 c = delimiters.codePointAt(j);
166                 delimiterCodePoints[i] = c;
167             }
168         }
169     }
170 
171     /**
172      * Constructs a string tokenizer for the specified string. All
173      * characters in the {@code delim} argument are the delimiters
174      * for separating tokens.
175      * &lt;p&gt;
176      * If the {@code returnDelims} flag is {@code true}, then
177      * the delimiter characters are also returned as tokens. Each
178      * delimiter is returned as a string of length one. If the flag is
179      * {@code false}, the delimiter characters are skipped and only
180      * serve as separators between tokens.
181      * &lt;p&gt;
182      * Note that if {@code delim} is {@code null}, this constructor does
183      * not throw an exception. However, trying to invoke other methods on the
184      * resulting {@code StringTokenizer} may result in a
185      * {@code NullPointerException}.
186      *
187      * @param   str            a string to be parsed.
188      * @param   delim          the delimiters.
189      * @param   returnDelims   flag indicating whether to return the delimiters
190      *                         as tokens.
<a name="3" id="anc3"></a><span class="line-modified">191      * @throws    NullPointerException if str is {@code null}</span>
192      */
193     public StringTokenizer(String str, String delim, boolean returnDelims) {
194         currentPosition = 0;
195         newPosition = -1;
196         delimsChanged = false;
197         this.str = str;
198         maxPosition = str.length();
199         delimiters = delim;
200         retDelims = returnDelims;
201         setMaxDelimCodePoint();
202     }
203 
204     /**
205      * Constructs a string tokenizer for the specified string. The
206      * characters in the {@code delim} argument are the delimiters
207      * for separating tokens. Delimiter characters themselves will not
208      * be treated as tokens.
209      * &lt;p&gt;
210      * Note that if {@code delim} is {@code null}, this constructor does
211      * not throw an exception. However, trying to invoke other methods on the
212      * resulting {@code StringTokenizer} may result in a
213      * {@code NullPointerException}.
214      *
215      * @param   str     a string to be parsed.
216      * @param   delim   the delimiters.
<a name="4" id="anc4"></a><span class="line-modified">217      * @throws    NullPointerException if str is {@code null}</span>
218      */
219     public StringTokenizer(String str, String delim) {
220         this(str, delim, false);
221     }
222 
223     /**
224      * Constructs a string tokenizer for the specified string. The
225      * tokenizer uses the default delimiter set, which is
226      * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character,
227      * the tab character, the newline character, the carriage-return character,
228      * and the form-feed character. Delimiter characters themselves will
229      * not be treated as tokens.
230      *
231      * @param   str   a string to be parsed.
<a name="5" id="anc5"></a><span class="line-modified">232      * @throws    NullPointerException if str is {@code null}</span>
233      */
234     public StringTokenizer(String str) {
235         this(str, &quot; \t\n\r\f&quot;, false);
236     }
237 
238     /**
239      * Skips delimiters starting from the specified position. If retDelims
240      * is false, returns the index of the first non-delimiter character at or
241      * after startPos. If retDelims is true, startPos is returned.
242      */
243     private int skipDelimiters(int startPos) {
244         if (delimiters == null)
245             throw new NullPointerException();
246 
247         int position = startPos;
248         while (!retDelims &amp;&amp; position &lt; maxPosition) {
249             if (!hasSurrogates) {
250                 char c = str.charAt(position);
251                 if ((c &gt; maxDelimCodePoint) || (delimiters.indexOf(c) &lt; 0))
252                     break;
253                 position++;
254             } else {
255                 int c = str.codePointAt(position);
256                 if ((c &gt; maxDelimCodePoint) || !isDelimiter(c)) {
257                     break;
258                 }
259                 position += Character.charCount(c);
260             }
261         }
262         return position;
263     }
264 
265     /**
266      * Skips ahead from startPos and returns the index of the next delimiter
267      * character encountered, or maxPosition if no such delimiter is found.
268      */
269     private int scanToken(int startPos) {
270         int position = startPos;
271         while (position &lt; maxPosition) {
272             if (!hasSurrogates) {
273                 char c = str.charAt(position);
274                 if ((c &lt;= maxDelimCodePoint) &amp;&amp; (delimiters.indexOf(c) &gt;= 0))
275                     break;
276                 position++;
277             } else {
278                 int c = str.codePointAt(position);
279                 if ((c &lt;= maxDelimCodePoint) &amp;&amp; isDelimiter(c))
280                     break;
281                 position += Character.charCount(c);
282             }
283         }
284         if (retDelims &amp;&amp; (startPos == position)) {
285             if (!hasSurrogates) {
286                 char c = str.charAt(position);
287                 if ((c &lt;= maxDelimCodePoint) &amp;&amp; (delimiters.indexOf(c) &gt;= 0))
288                     position++;
289             } else {
290                 int c = str.codePointAt(position);
291                 if ((c &lt;= maxDelimCodePoint) &amp;&amp; isDelimiter(c))
292                     position += Character.charCount(c);
293             }
294         }
295         return position;
296     }
297 
298     private boolean isDelimiter(int codePoint) {
299         for (int delimiterCodePoint : delimiterCodePoints) {
300             if (delimiterCodePoint == codePoint) {
301                 return true;
302             }
303         }
304         return false;
305     }
306 
307     /**
308      * Tests if there are more tokens available from this tokenizer&#39;s string.
309      * If this method returns {@code true}, then a subsequent call to
310      * {@code nextToken} with no argument will successfully return a token.
311      *
312      * @return  {@code true} if and only if there is at least one token
313      *          in the string after the current position; {@code false}
314      *          otherwise.
315      */
316     public boolean hasMoreTokens() {
317         /*
318          * Temporarily store this position and use it in the following
319          * nextToken() method only if the delimiters haven&#39;t been changed in
320          * that nextToken() invocation.
321          */
322         newPosition = skipDelimiters(currentPosition);
323         return (newPosition &lt; maxPosition);
324     }
325 
326     /**
327      * Returns the next token from this string tokenizer.
328      *
329      * @return     the next token from this string tokenizer.
<a name="6" id="anc6"></a><span class="line-modified">330      * @throws     NoSuchElementException  if there are no more tokens in this</span>
331      *               tokenizer&#39;s string.
332      */
333     public String nextToken() {
334         /*
335          * If next position already computed in hasMoreElements() and
336          * delimiters have changed between the computation and this invocation,
337          * then use the computed value.
338          */
339 
340         currentPosition = (newPosition &gt;= 0 &amp;&amp; !delimsChanged) ?
341             newPosition : skipDelimiters(currentPosition);
342 
343         /* Reset these anyway */
344         delimsChanged = false;
345         newPosition = -1;
346 
347         if (currentPosition &gt;= maxPosition)
348             throw new NoSuchElementException();
349         int start = currentPosition;
350         currentPosition = scanToken(currentPosition);
351         return str.substring(start, currentPosition);
352     }
353 
354     /**
355      * Returns the next token in this string tokenizer&#39;s string. First,
356      * the set of characters considered to be delimiters by this
357      * {@code StringTokenizer} object is changed to be the characters in
358      * the string {@code delim}. Then the next token in the string
359      * after the current position is returned. The current position is
360      * advanced beyond the recognized token.  The new delimiter set
361      * remains the default after this call.
362      *
363      * @param      delim   the new delimiters.
364      * @return     the next token, after switching to the new delimiter set.
<a name="7" id="anc7"></a><span class="line-modified">365      * @throws     NoSuchElementException  if there are no more tokens in this</span>
366      *               tokenizer&#39;s string.
<a name="8" id="anc8"></a><span class="line-modified">367      * @throws    NullPointerException if delim is {@code null}</span>
368      */
369     public String nextToken(String delim) {
370         delimiters = delim;
371 
372         /* delimiter string specified, so set the appropriate flag. */
373         delimsChanged = true;
374 
375         setMaxDelimCodePoint();
376         return nextToken();
377     }
378 
379     /**
380      * Returns the same value as the {@code hasMoreTokens}
381      * method. It exists so that this class can implement the
382      * {@code Enumeration} interface.
383      *
384      * @return  {@code true} if there are more tokens;
385      *          {@code false} otherwise.
386      * @see     java.util.Enumeration
387      * @see     java.util.StringTokenizer#hasMoreTokens()
388      */
389     public boolean hasMoreElements() {
390         return hasMoreTokens();
391     }
392 
393     /**
394      * Returns the same value as the {@code nextToken} method,
395      * except that its declared return value is {@code Object} rather than
396      * {@code String}. It exists so that this class can implement the
397      * {@code Enumeration} interface.
398      *
399      * @return     the next token in the string.
<a name="9" id="anc9"></a><span class="line-modified">400      * @throws     NoSuchElementException  if there are no more tokens in this</span>
401      *               tokenizer&#39;s string.
402      * @see        java.util.Enumeration
403      * @see        java.util.StringTokenizer#nextToken()
404      */
405     public Object nextElement() {
406         return nextToken();
407     }
408 
409     /**
410      * Calculates the number of times that this tokenizer&#39;s
411      * {@code nextToken} method can be called before it generates an
412      * exception. The current position is not advanced.
413      *
414      * @return  the number of tokens remaining in the string using the current
415      *          delimiter set.
416      * @see     java.util.StringTokenizer#nextToken()
417      */
418     public int countTokens() {
419         int count = 0;
420         int currpos = currentPosition;
421         while (currpos &lt; maxPosition) {
422             currpos = skipDelimiters(currpos);
423             if (currpos &gt;= maxPosition)
424                 break;
425             currpos = scanToken(currpos);
426             count++;
427         }
428         return count;
429     }
430 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
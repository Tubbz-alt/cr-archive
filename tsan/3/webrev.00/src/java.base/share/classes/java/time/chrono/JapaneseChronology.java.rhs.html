<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/chrono/JapaneseChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 28  *
 29  * All rights reserved.
 30  *
 31  * Redistribution and use in source and binary forms, with or without
 32  * modification, are permitted provided that the following conditions are met:
 33  *
 34  *  * Redistributions of source code must retain the above copyright notice,
 35  *    this list of conditions and the following disclaimer.
 36  *
 37  *  * Redistributions in binary form must reproduce the above copyright notice,
 38  *    this list of conditions and the following disclaimer in the documentation
 39  *    and/or other materials provided with the distribution.
 40  *
 41  *  * Neither the name of JSR-310 nor the names of its contributors
 42  *    may be used to endorse or promote products derived from this software
 43  *    without specific prior written permission.
 44  *
 45  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 46  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 47  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 48  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 49  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 50  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 51  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 52  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 53  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 54  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 55  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 56  */
 57 package java.time.chrono;
 58 
 59 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
 60 import static java.time.temporal.ChronoField.DAY_OF_YEAR;
 61 import static java.time.temporal.ChronoField.ERA;
 62 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
 63 import static java.time.temporal.ChronoField.YEAR;
 64 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
 65 import static java.time.temporal.ChronoUnit.DAYS;
 66 import static java.time.temporal.ChronoUnit.MONTHS;
 67 
 68 import java.io.InvalidObjectException;
 69 import java.io.ObjectInputStream;
 70 import java.io.Serializable;
 71 import java.time.Clock;
 72 import java.time.DateTimeException;
 73 import java.time.Instant;
 74 import java.time.LocalDate;
 75 import java.time.Year;
 76 import java.time.ZoneId;
 77 import java.time.format.ResolverStyle;
 78 import java.time.temporal.ChronoField;
 79 import java.time.temporal.TemporalAccessor;
 80 import java.time.temporal.TemporalAdjusters;
 81 import java.time.temporal.TemporalField;
 82 import java.time.temporal.UnsupportedTemporalTypeException;
 83 import java.time.temporal.ValueRange;
 84 import java.util.Calendar;
 85 import java.util.List;
 86 import java.util.Locale;
 87 import java.util.Map;
 88 
 89 import sun.util.calendar.CalendarSystem;
 90 import sun.util.calendar.LocalGregorianCalendar;
 91 
 92 /**
 93  * The Japanese Imperial calendar system.
 94  * &lt;p&gt;
 95  * This chronology defines the rules of the Japanese Imperial calendar system.
 96  * This calendar system is primarily used in Japan.
 97  * The Japanese Imperial calendar system is the same as the ISO calendar system
 98  * apart from the era-based year numbering.
 99  * &lt;p&gt;
100  * Japan introduced the Gregorian calendar starting with Meiji 6.
101  * Only Meiji and later eras are supported;
102  * dates before Meiji 6, January 1 are not supported.
103  * &lt;p&gt;
104  * The supported {@code ChronoField} instances are:
105  * &lt;ul&gt;
106  * &lt;li&gt;{@code DAY_OF_WEEK}
107  * &lt;li&gt;{@code DAY_OF_MONTH}
108  * &lt;li&gt;{@code DAY_OF_YEAR}
109  * &lt;li&gt;{@code EPOCH_DAY}
110  * &lt;li&gt;{@code MONTH_OF_YEAR}
111  * &lt;li&gt;{@code PROLEPTIC_MONTH}
112  * &lt;li&gt;{@code YEAR_OF_ERA}
113  * &lt;li&gt;{@code YEAR}
114  * &lt;li&gt;{@code ERA}
115  * &lt;/ul&gt;
116  *
117  * @implSpec
118  * This class is immutable and thread-safe.
119  *
120  * @since 1.8
121  */
122 public final class JapaneseChronology extends AbstractChronology implements Serializable {
123 
124     static final LocalGregorianCalendar JCAL =
125         (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);
126 
127     // Locale for creating a JapaneseImpericalCalendar.
128     static final Locale LOCALE = Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;);
129 
130     /**
131      * Singleton instance for Japanese chronology.
132      */
133     public static final JapaneseChronology INSTANCE = new JapaneseChronology();
134 
135     /**
136      * Serialization version.
137      */
<a name="2" id="anc2"></a><span class="line-added">138     @java.io.Serial</span>
139     private static final long serialVersionUID = 459996390165777884L;
140 
141     //-----------------------------------------------------------------------
142     /**
143      * Restricted constructor.
144      */
145     private JapaneseChronology() {
146     }
147 
148     //-----------------------------------------------------------------------
149     /**
150      * Gets the ID of the chronology - &#39;Japanese&#39;.
151      * &lt;p&gt;
152      * The ID uniquely identifies the {@code Chronology}.
153      * It can be used to lookup the {@code Chronology} using {@link Chronology#of(String)}.
154      *
155      * @return the chronology ID - &#39;Japanese&#39;
156      * @see #getCalendarType()
157      */
158     @Override
159     public String getId() {
160         return &quot;Japanese&quot;;
161     }
162 
163     /**
164      * Gets the calendar type of the underlying calendar system - &#39;japanese&#39;.
165      * &lt;p&gt;
166      * The calendar type is an identifier defined by the
167      * &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification.
168      * It can be used to lookup the {@code Chronology} using {@link Chronology#of(String)}.
169      * It can also be used as part of a locale, accessible via
170      * {@link Locale#getUnicodeLocaleType(String)} with the key &#39;ca&#39;.
171      *
172      * @return the calendar system type - &#39;japanese&#39;
173      * @see #getId()
174      */
175     @Override
176     public String getCalendarType() {
177         return &quot;japanese&quot;;
178     }
179 
180     //-----------------------------------------------------------------------
181     /**
182      * Obtains a local date in Japanese calendar system from the
183      * era, year-of-era, month-of-year and day-of-month fields.
184      * &lt;p&gt;
185      * The Japanese month and day-of-month are the same as those in the
186      * ISO calendar system. They are not reset when the era changes.
187      * For example:
188      * &lt;pre&gt;
189      *  6th Jan Showa 64 = ISO 1989-01-06
190      *  7th Jan Showa 64 = ISO 1989-01-07
191      *  8th Jan Heisei 1 = ISO 1989-01-08
192      *  9th Jan Heisei 1 = ISO 1989-01-09
193      * &lt;/pre&gt;
194      *
195      * @param era  the Japanese era, not null
196      * @param yearOfEra  the year-of-era
197      * @param month  the month-of-year
198      * @param dayOfMonth  the day-of-month
199      * @return the Japanese local date, not null
200      * @throws DateTimeException if unable to create the date
201      * @throws ClassCastException if the {@code era} is not a {@code JapaneseEra}
202      */
203     @Override
204     public JapaneseDate date(Era era, int yearOfEra, int month, int dayOfMonth) {
205         if (era instanceof JapaneseEra == false) {
206             throw new ClassCastException(&quot;Era must be JapaneseEra&quot;);
207         }
208         return JapaneseDate.of((JapaneseEra) era, yearOfEra, month, dayOfMonth);
209     }
210 
211     /**
212      * Obtains a local date in Japanese calendar system from the
213      * proleptic-year, month-of-year and day-of-month fields.
214      * &lt;p&gt;
215      * The Japanese proleptic year, month and day-of-month are the same as those
216      * in the ISO calendar system. They are not reset when the era changes.
217      *
218      * @param prolepticYear  the proleptic-year
219      * @param month  the month-of-year
220      * @param dayOfMonth  the day-of-month
221      * @return the Japanese local date, not null
222      * @throws DateTimeException if unable to create the date
223      */
224     @Override
225     public JapaneseDate date(int prolepticYear, int month, int dayOfMonth) {
226         return new JapaneseDate(LocalDate.of(prolepticYear, month, dayOfMonth));
227     }
228 
229     /**
230      * Obtains a local date in Japanese calendar system from the
231      * era, year-of-era and day-of-year fields.
232      * &lt;p&gt;
233      * The day-of-year in this factory is expressed relative to the start of the year-of-era.
234      * This definition changes the normal meaning of day-of-year only in those years
235      * where the year-of-era is reset to one due to a change in the era.
236      * For example:
237      * &lt;pre&gt;
238      *  6th Jan Showa 64 = day-of-year 6
239      *  7th Jan Showa 64 = day-of-year 7
240      *  8th Jan Heisei 1 = day-of-year 1
241      *  9th Jan Heisei 1 = day-of-year 2
242      * &lt;/pre&gt;
243      *
244      * @param era  the Japanese era, not null
245      * @param yearOfEra  the year-of-era
246      * @param dayOfYear  the day-of-year
247      * @return the Japanese local date, not null
248      * @throws DateTimeException if unable to create the date
249      * @throws ClassCastException if the {@code era} is not a {@code JapaneseEra}
250      */
251     @Override
252     public JapaneseDate dateYearDay(Era era, int yearOfEra, int dayOfYear) {
253         return JapaneseDate.ofYearDay((JapaneseEra) era, yearOfEra, dayOfYear);
254     }
255 
256     /**
257      * Obtains a local date in Japanese calendar system from the
258      * proleptic-year and day-of-year fields.
259      * &lt;p&gt;
260      * The day-of-year in this factory is expressed relative to the start of the proleptic year.
261      * The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system.
262      * They are not reset when the era changes.
263      *
264      * @param prolepticYear  the proleptic-year
265      * @param dayOfYear  the day-of-year
266      * @return the Japanese local date, not null
267      * @throws DateTimeException if unable to create the date
268      */
269     @Override
270     public JapaneseDate dateYearDay(int prolepticYear, int dayOfYear) {
271         return new JapaneseDate(LocalDate.ofYearDay(prolepticYear, dayOfYear));
272     }
273 
274     /**
275      * Obtains a local date in the Japanese calendar system from the epoch-day.
276      *
277      * @param epochDay  the epoch day
278      * @return the Japanese local date, not null
279      * @throws DateTimeException if unable to create the date
280      */
281     @Override  // override with covariant return type
282     public JapaneseDate dateEpochDay(long epochDay) {
283         return new JapaneseDate(LocalDate.ofEpochDay(epochDay));
284     }
285 
286     @Override
287     public JapaneseDate dateNow() {
288         return dateNow(Clock.systemDefaultZone());
289     }
290 
291     @Override
292     public JapaneseDate dateNow(ZoneId zone) {
293         return dateNow(Clock.system(zone));
294     }
295 
296     @Override
297     public JapaneseDate dateNow(Clock clock) {
298         return date(LocalDate.now(clock));
299     }
300 
301     @Override
302     public JapaneseDate date(TemporalAccessor temporal) {
303         if (temporal instanceof JapaneseDate) {
304             return (JapaneseDate) temporal;
305         }
306         return new JapaneseDate(LocalDate.from(temporal));
307     }
308 
309     @Override
310     @SuppressWarnings(&quot;unchecked&quot;)
311     public ChronoLocalDateTime&lt;JapaneseDate&gt; localDateTime(TemporalAccessor temporal) {
312         return (ChronoLocalDateTime&lt;JapaneseDate&gt;)super.localDateTime(temporal);
313     }
314 
315     @Override
316     @SuppressWarnings(&quot;unchecked&quot;)
317     public ChronoZonedDateTime&lt;JapaneseDate&gt; zonedDateTime(TemporalAccessor temporal) {
318         return (ChronoZonedDateTime&lt;JapaneseDate&gt;)super.zonedDateTime(temporal);
319     }
320 
321     @Override
322     @SuppressWarnings(&quot;unchecked&quot;)
323     public ChronoZonedDateTime&lt;JapaneseDate&gt; zonedDateTime(Instant instant, ZoneId zone) {
324         return (ChronoZonedDateTime&lt;JapaneseDate&gt;)super.zonedDateTime(instant, zone);
325     }
326 
327     //-----------------------------------------------------------------------
328     /**
329      * Checks if the specified year is a leap year.
330      * &lt;p&gt;
331      * Japanese calendar leap years occur exactly in line with ISO leap years.
332      * This method does not validate the year passed in, and only has a
333      * well-defined result for years in the supported range.
334      *
335      * @param prolepticYear  the proleptic-year to check, not validated for range
336      * @return true if the year is a leap year
337      */
338     @Override
339     public boolean isLeapYear(long prolepticYear) {
340         return IsoChronology.INSTANCE.isLeapYear(prolepticYear);
341     }
342 
343     @Override
344     public int prolepticYear(Era era, int yearOfEra) {
345         if (era instanceof JapaneseEra == false) {
346             throw new ClassCastException(&quot;Era must be JapaneseEra&quot;);
347         }
348 
349         JapaneseEra jera = (JapaneseEra) era;
350         int gregorianYear = jera.getPrivateEra().getSinceDate().getYear() + yearOfEra - 1;
351         if (yearOfEra == 1) {
352             return gregorianYear;
353         }
354         if (gregorianYear &gt;= Year.MIN_VALUE &amp;&amp; gregorianYear &lt;= Year.MAX_VALUE) {
355             LocalGregorianCalendar.Date jdate = JCAL.newCalendarDate(null);
356             jdate.setEra(jera.getPrivateEra()).setDate(yearOfEra, 1, 1);
357             if (JapaneseChronology.JCAL.validate(jdate)) {
358                 return gregorianYear;
359             }
360         }
361         throw new DateTimeException(&quot;Invalid yearOfEra value&quot;);
362     }
363 
364     /**
365      * Returns the calendar system era object from the given numeric value.
366      *
<a name="3" id="anc3"></a><span class="line-modified">367      * The numeric values supported by this method are the same as the</span>
<span class="line-modified">368      * numeric values supported by {@link JapaneseEra#of(int)}.</span>

369      *
370      * @param eraValue  the era value
371      * @return the Japanese {@code Era} for the given numeric era value
372      * @throws DateTimeException if {@code eraValue} is invalid
373      */
374     @Override
375     public JapaneseEra eraOf(int eraValue) {
376         return JapaneseEra.of(eraValue);
377     }
378 
379     @Override
380     public List&lt;Era&gt; eras() {
381         return List.of(JapaneseEra.values());
382     }
383 
384     JapaneseEra getCurrentEra() {
385         // Assume that the last JapaneseEra is the current one.
386         JapaneseEra[] eras = JapaneseEra.values();
387         return eras[eras.length - 1];
388     }
389 
390     //-----------------------------------------------------------------------
391     @Override
392     public ValueRange range(ChronoField field) {
393         switch (field) {
394             case ALIGNED_DAY_OF_WEEK_IN_MONTH:
395             case ALIGNED_DAY_OF_WEEK_IN_YEAR:
396             case ALIGNED_WEEK_OF_MONTH:
397             case ALIGNED_WEEK_OF_YEAR:
398                 throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
399             case YEAR_OF_ERA: {
400                 Calendar jcal = Calendar.getInstance(LOCALE);
401                 int startYear = getCurrentEra().getPrivateEra().getSinceDate().getYear();
402                 return ValueRange.of(1, jcal.getGreatestMinimum(Calendar.YEAR),
403                         jcal.getLeastMaximum(Calendar.YEAR) + 1, // +1 due to the different definitions
404                         Year.MAX_VALUE - startYear);
405             }
406             case DAY_OF_YEAR: {
407                 Calendar jcal = Calendar.getInstance(LOCALE);
408                 int fieldIndex = Calendar.DAY_OF_YEAR;
409                 return ValueRange.of(jcal.getMinimum(fieldIndex), jcal.getGreatestMinimum(fieldIndex),
410                         jcal.getLeastMaximum(fieldIndex), jcal.getMaximum(fieldIndex));
411             }
412             case YEAR:
413                 return ValueRange.of(JapaneseDate.MEIJI_6_ISODATE.getYear(), Year.MAX_VALUE);
414             case ERA:
415                 return ValueRange.of(JapaneseEra.MEIJI.getValue(), getCurrentEra().getValue());
416             default:
417                 return field.range();
418         }
419     }
420 
421     //-----------------------------------------------------------------------
422     @Override  // override for return type
423     public JapaneseDate resolveDate(Map &lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
424         return (JapaneseDate) super.resolveDate(fieldValues, resolverStyle);
425     }
426 
427     @Override  // override for special Japanese behavior
428     ChronoLocalDate resolveYearOfEra(Map&lt;TemporalField, Long&gt; fieldValues, ResolverStyle resolverStyle) {
429         // validate era and year-of-era
430         Long eraLong = fieldValues.get(ERA);
431         JapaneseEra era = null;
432         if (eraLong != null) {
433             era = eraOf(range(ERA).checkValidIntValue(eraLong, ERA));  // always validated
434         }
435         Long yoeLong = fieldValues.get(YEAR_OF_ERA);
436         int yoe = 0;
437         if (yoeLong != null) {
438             yoe = range(YEAR_OF_ERA).checkValidIntValue(yoeLong, YEAR_OF_ERA);  // always validated
439         }
440         // if only year-of-era and no year then invent era unless strict
441         if (era == null &amp;&amp; yoeLong != null &amp;&amp; fieldValues.containsKey(YEAR) == false &amp;&amp; resolverStyle != ResolverStyle.STRICT) {
442             era = JapaneseEra.values()[JapaneseEra.values().length - 1];
443         }
444         // if both present, then try to create date
445         if (yoeLong != null &amp;&amp; era != null) {
446             if (fieldValues.containsKey(MONTH_OF_YEAR)) {
447                 if (fieldValues.containsKey(DAY_OF_MONTH)) {
448                     return resolveYMD(era, yoe, fieldValues, resolverStyle);
449                 }
450             }
451             if (fieldValues.containsKey(DAY_OF_YEAR)) {
452                 return resolveYD(era, yoe, fieldValues, resolverStyle);
453             }
454         }
455         return null;
456     }
457 
458     private int prolepticYearLenient(JapaneseEra era, int yearOfEra) {
459         return era.getPrivateEra().getSinceDate().getYear() + yearOfEra - 1;
460     }
461 
462     private ChronoLocalDate resolveYMD(JapaneseEra era, int yoe, Map&lt;TemporalField,Long&gt; fieldValues, ResolverStyle resolverStyle) {
463         fieldValues.remove(ERA);
464         fieldValues.remove(YEAR_OF_ERA);
465         if (resolverStyle == ResolverStyle.LENIENT) {
466             int y = prolepticYearLenient(era, yoe);
467             long months = Math.subtractExact(fieldValues.remove(MONTH_OF_YEAR), 1);
468             long days = Math.subtractExact(fieldValues.remove(DAY_OF_MONTH), 1);
469             return date(y, 1, 1).plus(months, MONTHS).plus(days, DAYS);
470         }
471         int moy = range(MONTH_OF_YEAR).checkValidIntValue(fieldValues.remove(MONTH_OF_YEAR), MONTH_OF_YEAR);
472         int dom = range(DAY_OF_MONTH).checkValidIntValue(fieldValues.remove(DAY_OF_MONTH), DAY_OF_MONTH);
473         if (resolverStyle == ResolverStyle.SMART) {  // previous valid
474             if (yoe &lt; 1) {
475                 throw new DateTimeException(&quot;Invalid YearOfEra: &quot; + yoe);
476             }
477             int y = prolepticYearLenient(era, yoe);
478             JapaneseDate result;
479             try {
480                 result = date(y, moy, dom);
481             } catch (DateTimeException ex) {
482                 result = date(y, moy, 1).with(TemporalAdjusters.lastDayOfMonth());
483             }
484             // handle the era being changed
485             // only allow if the new date is in the same Jan-Dec as the era change
486             // determine by ensuring either original yoe or result yoe is 1
487             if (result.getEra() != era &amp;&amp; result.get(YEAR_OF_ERA) &gt; 1 &amp;&amp; yoe &gt; 1) {
488                 throw new DateTimeException(&quot;Invalid YearOfEra for Era: &quot; + era + &quot; &quot; + yoe);
489             }
490             return result;
491         }
492         return date(era, yoe, moy, dom);
493     }
494 
495     private ChronoLocalDate resolveYD(JapaneseEra era, int yoe, Map &lt;TemporalField,Long&gt; fieldValues, ResolverStyle resolverStyle) {
496         fieldValues.remove(ERA);
497         fieldValues.remove(YEAR_OF_ERA);
498         if (resolverStyle == ResolverStyle.LENIENT) {
499             int y = prolepticYearLenient(era, yoe);
500             long days = Math.subtractExact(fieldValues.remove(DAY_OF_YEAR), 1);
501             return dateYearDay(y, 1).plus(days, DAYS);
502         }
503         int doy = range(DAY_OF_YEAR).checkValidIntValue(fieldValues.remove(DAY_OF_YEAR), DAY_OF_YEAR);
504         return dateYearDay(era, yoe, doy);  // smart is same as strict
505     }
506 
507     //-----------------------------------------------------------------------
508     /**
509      * Writes the Chronology using a
510      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
511      * @serialData
512      * &lt;pre&gt;
513      *  out.writeByte(1);     // identifies a Chronology
514      *  out.writeUTF(getId());
515      * &lt;/pre&gt;
516      *
517      * @return the instance of {@code Ser}, not null
518      */
519     @Override
<a name="4" id="anc4"></a><span class="line-added">520     @java.io.Serial</span>
521     Object writeReplace() {
522         return super.writeReplace();
523     }
524 
525     /**
526      * Defend against malicious streams.
527      *
528      * @param s the stream to read
529      * @throws InvalidObjectException always
530      */
<a name="5" id="anc5"></a><span class="line-added">531     @java.io.Serial</span>
532     private void readObject(ObjectInputStream s) throws InvalidObjectException {
533         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
534     }
535 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/UnresolvedPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="UnrecoverableKeyException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="UnresolvedPermissionCollection.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/UnresolvedPermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 90  *
 91  * &lt;p&gt; Note that the {@code getName} method for an
 92  * {@code UnresolvedPermission} returns the
 93  * {@code type} (class name) for the underlying permission
 94  * that has not been resolved.
 95  *
 96  * @see java.security.Permission
 97  * @see java.security.Permissions
 98  * @see java.security.PermissionCollection
 99  * @see java.security.Policy
100  *
101  *
102  * @author Roland Schemers
103  * @since 1.2
104  */
105 
106 public final class UnresolvedPermission extends Permission
107 implements java.io.Serializable
108 {
109 

110     private static final long serialVersionUID = -4821973115467008846L;
111 
112     private static final sun.security.util.Debug debug =
113         sun.security.util.Debug.getInstance
114         (&quot;policy,access&quot;, &quot;UnresolvedPermission&quot;);
115 
116     /**
117      * The class name of the Permission class that will be
118      * created when this unresolved permission is resolved.
119      *
120      * @serial
121      */
122     private String type;
123 
124     /**
125      * The permission name.
126      *
127      * @serial
128      */
129     private String name;
</pre>
<hr />
<pre>
504     public PermissionCollection newPermissionCollection() {
505         return new UnresolvedPermissionCollection();
506     }
507 
508     /**
509      * Writes this object out to a stream (i.e., serializes it).
510      *
511      * @serialData An initial {@code String} denoting the
512      * {@code type} is followed by a {@code String} denoting the
513      * {@code name} is followed by a {@code String} denoting the
514      * {@code actions} is followed by an {@code int} indicating the
515      * number of certificates to follow
516      * (a value of &quot;zero&quot; denotes that there are no certificates associated
517      * with this object).
518      * Each certificate is written out starting with a {@code String}
519      * denoting the certificate type, followed by an
520      * {@code int} specifying the length of the certificate encoding,
521      * followed by the certificate encoding itself which is written out as an
522      * array of bytes.
523      */

524     private void writeObject(java.io.ObjectOutputStream oos)
525         throws IOException
526     {
527         oos.defaultWriteObject();
528 
529         if (certs==null || certs.length==0) {
530             oos.writeInt(0);
531         } else {
532             // write out the total number of certs
533             oos.writeInt(certs.length);
534             // write out each cert, including its type
535             for (int i=0; i &lt; certs.length; i++) {
536                 java.security.cert.Certificate cert = certs[i];
537                 try {
538                     oos.writeUTF(cert.getType());
539                     byte[] encoded = cert.getEncoded();
540                     oos.writeInt(encoded.length);
541                     oos.write(encoded);
542                 } catch (CertificateEncodingException cee) {
543                     throw new IOException(cee.getMessage());
544                 }
545             }
546         }
547     }
548 
549     /**
550      * Restores this object from a stream (i.e., deserializes it).
551      */

552     private void readObject(java.io.ObjectInputStream ois)
553         throws IOException, ClassNotFoundException
554     {
555         CertificateFactory cf;
556         Hashtable&lt;String, CertificateFactory&gt; cfs = null;
557         List&lt;Certificate&gt; certList = null;
558 
559         ois.defaultReadObject();
560 
561         if (type == null)
562                 throw new NullPointerException(&quot;type can&#39;t be null&quot;);
563 
564         // process any new-style certs in the stream (if present)
565         int size = ois.readInt();
566         if (size &gt; 0) {
567             // we know of 3 different cert types: X.509, PGP, SDSI, which
568             // could all be present in the stream at the same time
569             cfs = new Hashtable&lt;&gt;(3);
570             certList = new ArrayList&lt;&gt;(size &gt; 20 ? 20 : size);
571         } else if (size &lt; 0) {
</pre>
<hr />
<pre>
574 
575         for (int i=0; i&lt;size; i++) {
576             // read the certificate type, and instantiate a certificate
577             // factory of that type (reuse existing factory if possible)
578             String certType = ois.readUTF();
579             if (cfs.containsKey(certType)) {
580                 // reuse certificate factory
581                 cf = cfs.get(certType);
582             } else {
583                 // create new certificate factory
584                 try {
585                     cf = CertificateFactory.getInstance(certType);
586                 } catch (CertificateException ce) {
587                     throw new ClassNotFoundException
588                         (&quot;Certificate factory for &quot;+certType+&quot; not found&quot;);
589                 }
590                 // store the certificate factory so we can reuse it later
591                 cfs.put(certType, cf);
592             }
593             // parse the certificate
<span class="line-modified">594             byte[] encoded = IOUtils.readNBytes(ois, ois.readInt());</span>
595             ByteArrayInputStream bais = new ByteArrayInputStream(encoded);
596             try {
597                 certList.add(cf.generateCertificate(bais));
598             } catch (CertificateException ce) {
599                 throw new IOException(ce.getMessage());
600             }
601             bais.close();
602         }
603         if (certList != null) {
604             this.certs = certList.toArray(
605                     new java.security.cert.Certificate[size]);
606         }
607     }
608 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 90  *
 91  * &lt;p&gt; Note that the {@code getName} method for an
 92  * {@code UnresolvedPermission} returns the
 93  * {@code type} (class name) for the underlying permission
 94  * that has not been resolved.
 95  *
 96  * @see java.security.Permission
 97  * @see java.security.Permissions
 98  * @see java.security.PermissionCollection
 99  * @see java.security.Policy
100  *
101  *
102  * @author Roland Schemers
103  * @since 1.2
104  */
105 
106 public final class UnresolvedPermission extends Permission
107 implements java.io.Serializable
108 {
109 
<span class="line-added">110     @java.io.Serial</span>
111     private static final long serialVersionUID = -4821973115467008846L;
112 
113     private static final sun.security.util.Debug debug =
114         sun.security.util.Debug.getInstance
115         (&quot;policy,access&quot;, &quot;UnresolvedPermission&quot;);
116 
117     /**
118      * The class name of the Permission class that will be
119      * created when this unresolved permission is resolved.
120      *
121      * @serial
122      */
123     private String type;
124 
125     /**
126      * The permission name.
127      *
128      * @serial
129      */
130     private String name;
</pre>
<hr />
<pre>
505     public PermissionCollection newPermissionCollection() {
506         return new UnresolvedPermissionCollection();
507     }
508 
509     /**
510      * Writes this object out to a stream (i.e., serializes it).
511      *
512      * @serialData An initial {@code String} denoting the
513      * {@code type} is followed by a {@code String} denoting the
514      * {@code name} is followed by a {@code String} denoting the
515      * {@code actions} is followed by an {@code int} indicating the
516      * number of certificates to follow
517      * (a value of &quot;zero&quot; denotes that there are no certificates associated
518      * with this object).
519      * Each certificate is written out starting with a {@code String}
520      * denoting the certificate type, followed by an
521      * {@code int} specifying the length of the certificate encoding,
522      * followed by the certificate encoding itself which is written out as an
523      * array of bytes.
524      */
<span class="line-added">525     @java.io.Serial</span>
526     private void writeObject(java.io.ObjectOutputStream oos)
527         throws IOException
528     {
529         oos.defaultWriteObject();
530 
531         if (certs==null || certs.length==0) {
532             oos.writeInt(0);
533         } else {
534             // write out the total number of certs
535             oos.writeInt(certs.length);
536             // write out each cert, including its type
537             for (int i=0; i &lt; certs.length; i++) {
538                 java.security.cert.Certificate cert = certs[i];
539                 try {
540                     oos.writeUTF(cert.getType());
541                     byte[] encoded = cert.getEncoded();
542                     oos.writeInt(encoded.length);
543                     oos.write(encoded);
544                 } catch (CertificateEncodingException cee) {
545                     throw new IOException(cee.getMessage());
546                 }
547             }
548         }
549     }
550 
551     /**
552      * Restores this object from a stream (i.e., deserializes it).
553      */
<span class="line-added">554     @java.io.Serial</span>
555     private void readObject(java.io.ObjectInputStream ois)
556         throws IOException, ClassNotFoundException
557     {
558         CertificateFactory cf;
559         Hashtable&lt;String, CertificateFactory&gt; cfs = null;
560         List&lt;Certificate&gt; certList = null;
561 
562         ois.defaultReadObject();
563 
564         if (type == null)
565                 throw new NullPointerException(&quot;type can&#39;t be null&quot;);
566 
567         // process any new-style certs in the stream (if present)
568         int size = ois.readInt();
569         if (size &gt; 0) {
570             // we know of 3 different cert types: X.509, PGP, SDSI, which
571             // could all be present in the stream at the same time
572             cfs = new Hashtable&lt;&gt;(3);
573             certList = new ArrayList&lt;&gt;(size &gt; 20 ? 20 : size);
574         } else if (size &lt; 0) {
</pre>
<hr />
<pre>
577 
578         for (int i=0; i&lt;size; i++) {
579             // read the certificate type, and instantiate a certificate
580             // factory of that type (reuse existing factory if possible)
581             String certType = ois.readUTF();
582             if (cfs.containsKey(certType)) {
583                 // reuse certificate factory
584                 cf = cfs.get(certType);
585             } else {
586                 // create new certificate factory
587                 try {
588                     cf = CertificateFactory.getInstance(certType);
589                 } catch (CertificateException ce) {
590                     throw new ClassNotFoundException
591                         (&quot;Certificate factory for &quot;+certType+&quot; not found&quot;);
592                 }
593                 // store the certificate factory so we can reuse it later
594                 cfs.put(certType, cf);
595             }
596             // parse the certificate
<span class="line-modified">597             byte[] encoded = IOUtils.readExactlyNBytes(ois, ois.readInt());</span>
598             ByteArrayInputStream bais = new ByteArrayInputStream(encoded);
599             try {
600                 certList.add(cf.generateCertificate(bais));
601             } catch (CertificateException ce) {
602                 throw new IOException(ce.getMessage());
603             }
604             bais.close();
605         }
606         if (certList != null) {
607             this.certs = certList.toArray(
608                     new java.security.cert.Certificate[size]);
609         }
610     }
611 }
</pre>
</td>
</tr>
</table>
<center><a href="UnrecoverableKeyException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="UnresolvedPermissionCollection.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
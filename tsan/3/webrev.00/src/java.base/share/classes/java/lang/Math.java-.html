<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/Math.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.math.BigDecimal;
  29 import java.util.Random;
  30 import jdk.internal.math.FloatConsts;
  31 import jdk.internal.math.DoubleConsts;
  32 import jdk.internal.HotSpotIntrinsicCandidate;
  33 
  34 /**
  35  * The class {@code Math} contains methods for performing basic
  36  * numeric operations such as the elementary exponential, logarithm,
  37  * square root, and trigonometric functions.
  38  *
  39  * &lt;p&gt;Unlike some of the numeric methods of class
  40  * {@code StrictMath}, all implementations of the equivalent
  41  * functions of class {@code Math} are not defined to return the
  42  * bit-for-bit same results.  This relaxation permits
  43  * better-performing implementations where strict reproducibility is
  44  * not required.
  45  *
  46  * &lt;p&gt;By default many of the {@code Math} methods simply call
  47  * the equivalent method in {@code StrictMath} for their
  48  * implementation.  Code generators are encouraged to use
  49  * platform-specific native libraries or microprocessor instructions,
  50  * where available, to provide higher-performance implementations of
  51  * {@code Math} methods.  Such higher-performance
  52  * implementations still must conform to the specification for
  53  * {@code Math}.
  54  *
  55  * &lt;p&gt;The quality of implementation specifications concern two
  56  * properties, accuracy of the returned result and monotonicity of the
  57  * method.  Accuracy of the floating-point {@code Math} methods is
  58  * measured in terms of &lt;i&gt;ulps&lt;/i&gt;, units in the last place.  For a
  59  * given floating-point format, an {@linkplain #ulp(double) ulp} of a
  60  * specific real number value is the distance between the two
  61  * floating-point values bracketing that numerical value.  When
  62  * discussing the accuracy of a method as a whole rather than at a
  63  * specific argument, the number of ulps cited is for the worst-case
  64  * error at any argument.  If a method always has an error less than
  65  * 0.5 ulps, the method always returns the floating-point number
  66  * nearest the exact result; such a method is &lt;i&gt;correctly
  67  * rounded&lt;/i&gt;.  A correctly rounded method is generally the best a
  68  * floating-point approximation can be; however, it is impractical for
  69  * many floating-point methods to be correctly rounded.  Instead, for
  70  * the {@code Math} class, a larger error bound of 1 or 2 ulps is
  71  * allowed for certain methods.  Informally, with a 1 ulp error bound,
  72  * when the exact result is a representable number, the exact result
  73  * should be returned as the computed result; otherwise, either of the
  74  * two floating-point values which bracket the exact result may be
  75  * returned.  For exact results large in magnitude, one of the
  76  * endpoints of the bracket may be infinite.  Besides accuracy at
  77  * individual arguments, maintaining proper relations between the
  78  * method at different arguments is also important.  Therefore, most
  79  * methods with more than 0.5 ulp errors are required to be
  80  * &lt;i&gt;semi-monotonic&lt;/i&gt;: whenever the mathematical function is
  81  * non-decreasing, so is the floating-point approximation, likewise,
  82  * whenever the mathematical function is non-increasing, so is the
  83  * floating-point approximation.  Not all approximations that have 1
  84  * ulp accuracy will automatically meet the monotonicity requirements.
  85  *
  86  * &lt;p&gt;
  87  * The platform uses signed two&#39;s complement integer arithmetic with
  88  * int and long primitive types.  The developer should choose
  89  * the primitive type to ensure that arithmetic operations consistently
  90  * produce correct results, which in some cases means the operations
  91  * will not overflow the range of values of the computation.
  92  * The best practice is to choose the primitive type and algorithm to avoid
  93  * overflow. In cases where the size is {@code int} or {@code long} and
  94  * overflow errors need to be detected, the methods {@code addExact},
  95  * {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}
  96  * throw an {@code ArithmeticException} when the results overflow.
  97  * For other arithmetic operations such as divide, absolute value,
  98  * increment by one, decrement by one, and negation, overflow occurs only with
  99  * a specific minimum or maximum value and should be checked against
 100  * the minimum or maximum as appropriate.
 101  *
 102  * @author  unascribed
 103  * @author  Joseph D. Darcy
 104  * @since   1.0
 105  */
 106 
 107 public final class Math {
 108 
 109     /**
 110      * Don&#39;t let anyone instantiate this class.
 111      */
 112     private Math() {}
 113 
 114     /**
 115      * The {@code double} value that is closer than any other to
 116      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
 117      */
 118     public static final double E = 2.7182818284590452354;
 119 
 120     /**
 121      * The {@code double} value that is closer than any other to
 122      * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its
 123      * diameter.
 124      */
 125     public static final double PI = 3.14159265358979323846;
 126 
 127     /**
 128      * Constant by which to multiply an angular value in degrees to obtain an
 129      * angular value in radians.
 130      */
 131     private static final double DEGREES_TO_RADIANS = 0.017453292519943295;
 132 
 133     /**
 134      * Constant by which to multiply an angular value in radians to obtain an
 135      * angular value in degrees.
 136      */
 137     private static final double RADIANS_TO_DEGREES = 57.29577951308232;
 138 
 139     /**
 140      * Returns the trigonometric sine of an angle.  Special cases:
 141      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 142      * result is NaN.
 143      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 144      * same sign as the argument.&lt;/ul&gt;
 145      *
 146      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 147      * Results must be semi-monotonic.
 148      *
 149      * @param   a   an angle, in radians.
 150      * @return  the sine of the argument.
 151      */
 152     @HotSpotIntrinsicCandidate
 153     public static double sin(double a) {
 154         return StrictMath.sin(a); // default impl. delegates to StrictMath
 155     }
 156 
 157     /**
 158      * Returns the trigonometric cosine of an angle. Special cases:
 159      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 160      * result is NaN.&lt;/ul&gt;
 161      *
 162      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 163      * Results must be semi-monotonic.
 164      *
 165      * @param   a   an angle, in radians.
 166      * @return  the cosine of the argument.
 167      */
 168     @HotSpotIntrinsicCandidate
 169     public static double cos(double a) {
 170         return StrictMath.cos(a); // default impl. delegates to StrictMath
 171     }
 172 
 173     /**
 174      * Returns the trigonometric tangent of an angle.  Special cases:
 175      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the result
 176      * is NaN.
 177      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 178      * same sign as the argument.&lt;/ul&gt;
 179      *
 180      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 181      * Results must be semi-monotonic.
 182      *
 183      * @param   a   an angle, in radians.
 184      * @return  the tangent of the argument.
 185      */
 186     @HotSpotIntrinsicCandidate
 187     public static double tan(double a) {
 188         return StrictMath.tan(a); // default impl. delegates to StrictMath
 189     }
 190 
 191     /**
 192      * Returns the arc sine of a value; the returned angle is in the
 193      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 194      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 195      * than 1, then the result is NaN.
 196      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 197      * same sign as the argument.&lt;/ul&gt;
 198      *
 199      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 200      * Results must be semi-monotonic.
 201      *
 202      * @param   a   the value whose arc sine is to be returned.
 203      * @return  the arc sine of the argument.
 204      */
 205     public static double asin(double a) {
 206         return StrictMath.asin(a); // default impl. delegates to StrictMath
 207     }
 208 
 209     /**
 210      * Returns the arc cosine of a value; the returned angle is in the
 211      * range 0.0 through &lt;i&gt;pi&lt;/i&gt;.  Special case:
 212      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 213      * than 1, then the result is NaN.&lt;/ul&gt;
 214      *
 215      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 216      * Results must be semi-monotonic.
 217      *
 218      * @param   a   the value whose arc cosine is to be returned.
 219      * @return  the arc cosine of the argument.
 220      */
 221     public static double acos(double a) {
 222         return StrictMath.acos(a); // default impl. delegates to StrictMath
 223     }
 224 
 225     /**
 226      * Returns the arc tangent of a value; the returned angle is in the
 227      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 228      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, then the result is NaN.
 229      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 230      * same sign as the argument.&lt;/ul&gt;
 231      *
 232      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 233      * Results must be semi-monotonic.
 234      *
 235      * @param   a   the value whose arc tangent is to be returned.
 236      * @return  the arc tangent of the argument.
 237      */
 238     public static double atan(double a) {
 239         return StrictMath.atan(a); // default impl. delegates to StrictMath
 240     }
 241 
 242     /**
 243      * Converts an angle measured in degrees to an approximately
 244      * equivalent angle measured in radians.  The conversion from
 245      * degrees to radians is generally inexact.
 246      *
 247      * @param   angdeg   an angle, in degrees
 248      * @return  the measurement of the angle {@code angdeg}
 249      *          in radians.
 250      * @since   1.2
 251      */
 252     public static double toRadians(double angdeg) {
 253         return angdeg * DEGREES_TO_RADIANS;
 254     }
 255 
 256     /**
 257      * Converts an angle measured in radians to an approximately
 258      * equivalent angle measured in degrees.  The conversion from
 259      * radians to degrees is generally inexact; users should
 260      * &lt;i&gt;not&lt;/i&gt; expect {@code cos(toRadians(90.0))} to exactly
 261      * equal {@code 0.0}.
 262      *
 263      * @param   angrad   an angle, in radians
 264      * @return  the measurement of the angle {@code angrad}
 265      *          in degrees.
 266      * @since   1.2
 267      */
 268     public static double toDegrees(double angrad) {
 269         return angrad * RADIANS_TO_DEGREES;
 270     }
 271 
 272     /**
 273      * Returns Euler&#39;s number &lt;i&gt;e&lt;/i&gt; raised to the power of a
 274      * {@code double} value.  Special cases:
 275      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is NaN.
 276      * &lt;li&gt;If the argument is positive infinity, then the result is
 277      * positive infinity.
 278      * &lt;li&gt;If the argument is negative infinity, then the result is
 279      * positive zero.&lt;/ul&gt;
 280      *
 281      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 282      * Results must be semi-monotonic.
 283      *
 284      * @param   a   the exponent to raise &lt;i&gt;e&lt;/i&gt; to.
 285      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code a}&lt;/sup&gt;,
 286      *          where &lt;i&gt;e&lt;/i&gt; is the base of the natural logarithms.
 287      */
 288     @HotSpotIntrinsicCandidate
 289     public static double exp(double a) {
 290         return StrictMath.exp(a); // default impl. delegates to StrictMath
 291     }
 292 
 293     /**
 294      * Returns the natural logarithm (base &lt;i&gt;e&lt;/i&gt;) of a {@code double}
 295      * value.  Special cases:
 296      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 297      * is NaN.
 298      * &lt;li&gt;If the argument is positive infinity, then the result is
 299      * positive infinity.
 300      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 301      * result is negative infinity.&lt;/ul&gt;
 302      *
 303      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 304      * Results must be semi-monotonic.
 305      *
 306      * @param   a   a value
 307      * @return  the value ln&amp;nbsp;{@code a}, the natural logarithm of
 308      *          {@code a}.
 309      */
 310     @HotSpotIntrinsicCandidate
 311     public static double log(double a) {
 312         return StrictMath.log(a); // default impl. delegates to StrictMath
 313     }
 314 
 315     /**
 316      * Returns the base 10 logarithm of a {@code double} value.
 317      * Special cases:
 318      *
 319      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 320      * is NaN.
 321      * &lt;li&gt;If the argument is positive infinity, then the result is
 322      * positive infinity.
 323      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 324      * result is negative infinity.
 325      * &lt;li&gt; If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for
 326      * integer &lt;i&gt;n&lt;/i&gt;, then the result is &lt;i&gt;n&lt;/i&gt;.
 327      * &lt;/ul&gt;
 328      *
 329      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 330      * Results must be semi-monotonic.
 331      *
 332      * @param   a   a value
 333      * @return  the base 10 logarithm of  {@code a}.
 334      * @since 1.5
 335      */
 336     @HotSpotIntrinsicCandidate
 337     public static double log10(double a) {
 338         return StrictMath.log10(a); // default impl. delegates to StrictMath
 339     }
 340 
 341     /**
 342      * Returns the correctly rounded positive square root of a
 343      * {@code double} value.
 344      * Special cases:
 345      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 346      * is NaN.
 347      * &lt;li&gt;If the argument is positive infinity, then the result is positive
 348      * infinity.
 349      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 350      * result is the same as the argument.&lt;/ul&gt;
 351      * Otherwise, the result is the {@code double} value closest to
 352      * the true mathematical square root of the argument value.
 353      *
 354      * @param   a   a value.
 355      * @return  the positive square root of {@code a}.
 356      *          If the argument is NaN or less than zero, the result is NaN.
 357      */
 358     @HotSpotIntrinsicCandidate
 359     public static double sqrt(double a) {
 360         return StrictMath.sqrt(a); // default impl. delegates to StrictMath
 361                                    // Note that hardware sqrt instructions
 362                                    // frequently can be directly used by JITs
 363                                    // and should be much faster than doing
 364                                    // Math.sqrt in software.
 365     }
 366 
 367 
 368     /**
 369      * Returns the cube root of a {@code double} value.  For
 370      * positive finite {@code x}, {@code cbrt(-x) ==
 371      * -cbrt(x)}; that is, the cube root of a negative value is
 372      * the negative of the cube root of that value&#39;s magnitude.
 373      *
 374      * Special cases:
 375      *
 376      * &lt;ul&gt;
 377      *
 378      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 379      *
 380      * &lt;li&gt;If the argument is infinite, then the result is an infinity
 381      * with the same sign as the argument.
 382      *
 383      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 384      * same sign as the argument.
 385      *
 386      * &lt;/ul&gt;
 387      *
 388      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 389      *
 390      * @param   a   a value.
 391      * @return  the cube root of {@code a}.
 392      * @since 1.5
 393      */
 394     public static double cbrt(double a) {
 395         return StrictMath.cbrt(a);
 396     }
 397 
 398     /**
 399      * Computes the remainder operation on two arguments as prescribed
 400      * by the IEEE 754 standard.
 401      * The remainder value is mathematically equal to
 402      * &lt;code&gt;f1&amp;nbsp;-&amp;nbsp;f2&lt;/code&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;,
 403      * where &lt;i&gt;n&lt;/i&gt; is the mathematical integer closest to the exact
 404      * mathematical value of the quotient {@code f1/f2}, and if two
 405      * mathematical integers are equally close to {@code f1/f2},
 406      * then &lt;i&gt;n&lt;/i&gt; is the integer that is even. If the remainder is
 407      * zero, its sign is the same as the sign of the first argument.
 408      * Special cases:
 409      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, or the first argument is infinite,
 410      * or the second argument is positive zero or negative zero, then the
 411      * result is NaN.
 412      * &lt;li&gt;If the first argument is finite and the second argument is
 413      * infinite, then the result is the same as the first argument.&lt;/ul&gt;
 414      *
 415      * @param   f1   the dividend.
 416      * @param   f2   the divisor.
 417      * @return  the remainder when {@code f1} is divided by
 418      *          {@code f2}.
 419      */
 420     public static double IEEEremainder(double f1, double f2) {
 421         return StrictMath.IEEEremainder(f1, f2); // delegate to StrictMath
 422     }
 423 
 424     /**
 425      * Returns the smallest (closest to negative infinity)
 426      * {@code double} value that is greater than or equal to the
 427      * argument and is equal to a mathematical integer. Special cases:
 428      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 429      * mathematical integer, then the result is the same as the
 430      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 431      * positive zero or negative zero, then the result is the same as
 432      * the argument.  &lt;li&gt;If the argument value is less than zero but
 433      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 434      * that the value of {@code Math.ceil(x)} is exactly the
 435      * value of {@code -Math.floor(-x)}.
 436      *
 437      *
 438      * @param   a   a value.
 439      * @return  the smallest (closest to negative infinity)
 440      *          floating-point value that is greater than or equal to
 441      *          the argument and is equal to a mathematical integer.
 442      */
 443     public static double ceil(double a) {
 444         return StrictMath.ceil(a); // default impl. delegates to StrictMath
 445     }
 446 
 447     /**
 448      * Returns the largest (closest to positive infinity)
 449      * {@code double} value that is less than or equal to the
 450      * argument and is equal to a mathematical integer. Special cases:
 451      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 452      * mathematical integer, then the result is the same as the
 453      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 454      * positive zero or negative zero, then the result is the same as
 455      * the argument.&lt;/ul&gt;
 456      *
 457      * @param   a   a value.
 458      * @return  the largest (closest to positive infinity)
 459      *          floating-point value that less than or equal to the argument
 460      *          and is equal to a mathematical integer.
 461      */
 462     public static double floor(double a) {
 463         return StrictMath.floor(a); // default impl. delegates to StrictMath
 464     }
 465 
 466     /**
 467      * Returns the {@code double} value that is closest in value
 468      * to the argument and is equal to a mathematical integer. If two
 469      * {@code double} values that are mathematical integers are
 470      * equally close, the result is the integer value that is
 471      * even. Special cases:
 472      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 473      * integer, then the result is the same as the argument.
 474      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 475      * zero, then the result is the same as the argument.&lt;/ul&gt;
 476      *
 477      * @param   a   a {@code double} value.
 478      * @return  the closest floating-point value to {@code a} that is
 479      *          equal to a mathematical integer.
 480      */
 481     public static double rint(double a) {
 482         return StrictMath.rint(a); // default impl. delegates to StrictMath
 483     }
 484 
 485     /**
 486      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 487      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 488      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 489      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 490      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 491      * cases:
 492      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 493      * &lt;li&gt;If the first argument is positive zero and the second argument
 494      * is positive, or the first argument is positive and finite and the
 495      * second argument is positive infinity, then the result is positive
 496      * zero.
 497      * &lt;li&gt;If the first argument is negative zero and the second argument
 498      * is positive, or the first argument is negative and finite and the
 499      * second argument is positive infinity, then the result is negative zero.
 500      * &lt;li&gt;If the first argument is positive zero and the second argument
 501      * is negative, or the first argument is positive and finite and the
 502      * second argument is negative infinity, then the result is the
 503      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;.
 504      * &lt;li&gt;If the first argument is negative zero and the second argument
 505      * is negative, or the first argument is negative and finite and the
 506      * second argument is negative infinity, then the result is the
 507      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;.
 508      * &lt;li&gt;If the first argument is positive and the second argument is
 509      * positive zero or negative zero, or the first argument is positive
 510      * infinity and the second argument is finite, then the result is the
 511      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/2.
 512      * &lt;li&gt;If the first argument is negative and the second argument is
 513      * positive zero or negative zero, or the first argument is negative
 514      * infinity and the second argument is finite, then the result is the
 515      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;/2.
 516      * &lt;li&gt;If both arguments are positive infinity, then the result is the
 517      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/4.
 518      * &lt;li&gt;If the first argument is positive infinity and the second argument
 519      * is negative infinity, then the result is the {@code double}
 520      * value closest to 3*&lt;i&gt;pi&lt;/i&gt;/4.
 521      * &lt;li&gt;If the first argument is negative infinity and the second argument
 522      * is positive infinity, then the result is the {@code double} value
 523      * closest to -&lt;i&gt;pi&lt;/i&gt;/4.
 524      * &lt;li&gt;If both arguments are negative infinity, then the result is the
 525      * {@code double} value closest to -3*&lt;i&gt;pi&lt;/i&gt;/4.&lt;/ul&gt;
 526      *
 527      * &lt;p&gt;The computed result must be within 2 ulps of the exact result.
 528      * Results must be semi-monotonic.
 529      *
 530      * @param   y   the ordinate coordinate
 531      * @param   x   the abscissa coordinate
 532      * @return  the &lt;i&gt;theta&lt;/i&gt; component of the point
 533      *          (&lt;i&gt;r&lt;/i&gt;,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;)
 534      *          in polar coordinates that corresponds to the point
 535      *          (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in Cartesian coordinates.
 536      */
 537     @HotSpotIntrinsicCandidate
 538     public static double atan2(double y, double x) {
 539         return StrictMath.atan2(y, x); // default impl. delegates to StrictMath
 540     }
 541 
 542     /**
 543      * Returns the value of the first argument raised to the power of the
 544      * second argument. Special cases:
 545      *
 546      * &lt;ul&gt;&lt;li&gt;If the second argument is positive or negative zero, then the
 547      * result is 1.0.
 548      * &lt;li&gt;If the second argument is 1.0, then the result is the same as the
 549      * first argument.
 550      * &lt;li&gt;If the second argument is NaN, then the result is NaN.
 551      * &lt;li&gt;If the first argument is NaN and the second argument is nonzero,
 552      * then the result is NaN.
 553      *
 554      * &lt;li&gt;If
 555      * &lt;ul&gt;
 556      * &lt;li&gt;the absolute value of the first argument is greater than 1
 557      * and the second argument is positive infinity, or
 558      * &lt;li&gt;the absolute value of the first argument is less than 1 and
 559      * the second argument is negative infinity,
 560      * &lt;/ul&gt;
 561      * then the result is positive infinity.
 562      *
 563      * &lt;li&gt;If
 564      * &lt;ul&gt;
 565      * &lt;li&gt;the absolute value of the first argument is greater than 1 and
 566      * the second argument is negative infinity, or
 567      * &lt;li&gt;the absolute value of the
 568      * first argument is less than 1 and the second argument is positive
 569      * infinity,
 570      * &lt;/ul&gt;
 571      * then the result is positive zero.
 572      *
 573      * &lt;li&gt;If the absolute value of the first argument equals 1 and the
 574      * second argument is infinite, then the result is NaN.
 575      *
 576      * &lt;li&gt;If
 577      * &lt;ul&gt;
 578      * &lt;li&gt;the first argument is positive zero and the second argument
 579      * is greater than zero, or
 580      * &lt;li&gt;the first argument is positive infinity and the second
 581      * argument is less than zero,
 582      * &lt;/ul&gt;
 583      * then the result is positive zero.
 584      *
 585      * &lt;li&gt;If
 586      * &lt;ul&gt;
 587      * &lt;li&gt;the first argument is positive zero and the second argument
 588      * is less than zero, or
 589      * &lt;li&gt;the first argument is positive infinity and the second
 590      * argument is greater than zero,
 591      * &lt;/ul&gt;
 592      * then the result is positive infinity.
 593      *
 594      * &lt;li&gt;If
 595      * &lt;ul&gt;
 596      * &lt;li&gt;the first argument is negative zero and the second argument
 597      * is greater than zero but not a finite odd integer, or
 598      * &lt;li&gt;the first argument is negative infinity and the second
 599      * argument is less than zero but not a finite odd integer,
 600      * &lt;/ul&gt;
 601      * then the result is positive zero.
 602      *
 603      * &lt;li&gt;If
 604      * &lt;ul&gt;
 605      * &lt;li&gt;the first argument is negative zero and the second argument
 606      * is a positive finite odd integer, or
 607      * &lt;li&gt;the first argument is negative infinity and the second
 608      * argument is a negative finite odd integer,
 609      * &lt;/ul&gt;
 610      * then the result is negative zero.
 611      *
 612      * &lt;li&gt;If
 613      * &lt;ul&gt;
 614      * &lt;li&gt;the first argument is negative zero and the second argument
 615      * is less than zero but not a finite odd integer, or
 616      * &lt;li&gt;the first argument is negative infinity and the second
 617      * argument is greater than zero but not a finite odd integer,
 618      * &lt;/ul&gt;
 619      * then the result is positive infinity.
 620      *
 621      * &lt;li&gt;If
 622      * &lt;ul&gt;
 623      * &lt;li&gt;the first argument is negative zero and the second argument
 624      * is a negative finite odd integer, or
 625      * &lt;li&gt;the first argument is negative infinity and the second
 626      * argument is a positive finite odd integer,
 627      * &lt;/ul&gt;
 628      * then the result is negative infinity.
 629      *
 630      * &lt;li&gt;If the first argument is finite and less than zero
 631      * &lt;ul&gt;
 632      * &lt;li&gt; if the second argument is a finite even integer, the
 633      * result is equal to the result of raising the absolute value of
 634      * the first argument to the power of the second argument
 635      *
 636      * &lt;li&gt;if the second argument is a finite odd integer, the result
 637      * is equal to the negative of the result of raising the absolute
 638      * value of the first argument to the power of the second
 639      * argument
 640      *
 641      * &lt;li&gt;if the second argument is finite and not an integer, then
 642      * the result is NaN.
 643      * &lt;/ul&gt;
 644      *
 645      * &lt;li&gt;If both arguments are integers, then the result is exactly equal
 646      * to the mathematical result of raising the first argument to the power
 647      * of the second argument if that result can in fact be represented
 648      * exactly as a {@code double} value.&lt;/ul&gt;
 649      *
 650      * &lt;p&gt;(In the foregoing descriptions, a floating-point value is
 651      * considered to be an integer if and only if it is finite and a
 652      * fixed point of the method {@link #ceil ceil} or,
 653      * equivalently, a fixed point of the method {@link #floor
 654      * floor}. A value is a fixed point of a one-argument
 655      * method if and only if the result of applying the method to the
 656      * value is equal to the value.)
 657      *
 658      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 659      * Results must be semi-monotonic.
 660      *
 661      * @param   a   the base.
 662      * @param   b   the exponent.
 663      * @return  the value {@code a}&lt;sup&gt;{@code b}&lt;/sup&gt;.
 664      */
 665     @HotSpotIntrinsicCandidate
 666     public static double pow(double a, double b) {
 667         return StrictMath.pow(a, b); // default impl. delegates to StrictMath
 668     }
 669 
 670     /**
 671      * Returns the closest {@code int} to the argument, with ties
 672      * rounding to positive infinity.
 673      *
 674      * &lt;p&gt;
 675      * Special cases:
 676      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 677      * &lt;li&gt;If the argument is negative infinity or any value less than or
 678      * equal to the value of {@code Integer.MIN_VALUE}, the result is
 679      * equal to the value of {@code Integer.MIN_VALUE}.
 680      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 681      * equal to the value of {@code Integer.MAX_VALUE}, the result is
 682      * equal to the value of {@code Integer.MAX_VALUE}.&lt;/ul&gt;
 683      *
 684      * @param   a   a floating-point value to be rounded to an integer.
 685      * @return  the value of the argument rounded to the nearest
 686      *          {@code int} value.
 687      * @see     java.lang.Integer#MAX_VALUE
 688      * @see     java.lang.Integer#MIN_VALUE
 689      */
 690     public static int round(float a) {
 691         int intBits = Float.floatToRawIntBits(a);
 692         int biasedExp = (intBits &amp; FloatConsts.EXP_BIT_MASK)
 693                 &gt;&gt; (FloatConsts.SIGNIFICAND_WIDTH - 1);
 694         int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2
 695                 + FloatConsts.EXP_BIAS) - biasedExp;
 696         if ((shift &amp; -32) == 0) { // shift &gt;= 0 &amp;&amp; shift &lt; 32
 697             // a is a finite number such that pow(2,-32) &lt;= ulp(a) &lt; 1
 698             int r = ((intBits &amp; FloatConsts.SIGNIF_BIT_MASK)
 699                     | (FloatConsts.SIGNIF_BIT_MASK + 1));
 700             if (intBits &lt; 0) {
 701                 r = -r;
 702             }
 703             // In the comments below each Java expression evaluates to the value
 704             // the corresponding mathematical expression:
 705             // (r) evaluates to a / ulp(a)
 706             // (r &gt;&gt; shift) evaluates to floor(a * 2)
 707             // ((r &gt;&gt; shift) + 1) evaluates to floor((a + 1/2) * 2)
 708             // (((r &gt;&gt; shift) + 1) &gt;&gt; 1) evaluates to floor(a + 1/2)
 709             return ((r &gt;&gt; shift) + 1) &gt;&gt; 1;
 710         } else {
 711             // a is either
 712             // - a finite number with abs(a) &lt; exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) &lt; 1/2
 713             // - a finite number with ulp(a) &gt;= 1 and hence a is a mathematical integer
 714             // - an infinity or NaN
 715             return (int) a;
 716         }
 717     }
 718 
 719     /**
 720      * Returns the closest {@code long} to the argument, with ties
 721      * rounding to positive infinity.
 722      *
 723      * &lt;p&gt;Special cases:
 724      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 725      * &lt;li&gt;If the argument is negative infinity or any value less than or
 726      * equal to the value of {@code Long.MIN_VALUE}, the result is
 727      * equal to the value of {@code Long.MIN_VALUE}.
 728      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 729      * equal to the value of {@code Long.MAX_VALUE}, the result is
 730      * equal to the value of {@code Long.MAX_VALUE}.&lt;/ul&gt;
 731      *
 732      * @param   a   a floating-point value to be rounded to a
 733      *          {@code long}.
 734      * @return  the value of the argument rounded to the nearest
 735      *          {@code long} value.
 736      * @see     java.lang.Long#MAX_VALUE
 737      * @see     java.lang.Long#MIN_VALUE
 738      */
 739     public static long round(double a) {
 740         long longBits = Double.doubleToRawLongBits(a);
 741         long biasedExp = (longBits &amp; DoubleConsts.EXP_BIT_MASK)
 742                 &gt;&gt; (DoubleConsts.SIGNIFICAND_WIDTH - 1);
 743         long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2
 744                 + DoubleConsts.EXP_BIAS) - biasedExp;
 745         if ((shift &amp; -64) == 0) { // shift &gt;= 0 &amp;&amp; shift &lt; 64
 746             // a is a finite number such that pow(2,-64) &lt;= ulp(a) &lt; 1
 747             long r = ((longBits &amp; DoubleConsts.SIGNIF_BIT_MASK)
 748                     | (DoubleConsts.SIGNIF_BIT_MASK + 1));
 749             if (longBits &lt; 0) {
 750                 r = -r;
 751             }
 752             // In the comments below each Java expression evaluates to the value
 753             // the corresponding mathematical expression:
 754             // (r) evaluates to a / ulp(a)
 755             // (r &gt;&gt; shift) evaluates to floor(a * 2)
 756             // ((r &gt;&gt; shift) + 1) evaluates to floor((a + 1/2) * 2)
 757             // (((r &gt;&gt; shift) + 1) &gt;&gt; 1) evaluates to floor(a + 1/2)
 758             return ((r &gt;&gt; shift) + 1) &gt;&gt; 1;
 759         } else {
 760             // a is either
 761             // - a finite number with abs(a) &lt; exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) &lt; 1/2
 762             // - a finite number with ulp(a) &gt;= 1 and hence a is a mathematical integer
 763             // - an infinity or NaN
 764             return (long) a;
 765         }
 766     }
 767 
 768     private static final class RandomNumberGeneratorHolder {
 769         static final Random randomNumberGenerator = new Random();
 770     }
 771 
 772     /**
 773      * Returns a {@code double} value with a positive sign, greater
 774      * than or equal to {@code 0.0} and less than {@code 1.0}.
 775      * Returned values are chosen pseudorandomly with (approximately)
 776      * uniform distribution from that range.
 777      *
 778      * &lt;p&gt;When this method is first called, it creates a single new
 779      * pseudorandom-number generator, exactly as if by the expression
 780      *
 781      * &lt;blockquote&gt;{@code new java.util.Random()}&lt;/blockquote&gt;
 782      *
 783      * This new pseudorandom-number generator is used thereafter for
 784      * all calls to this method and is used nowhere else.
 785      *
 786      * &lt;p&gt;This method is properly synchronized to allow correct use by
 787      * more than one thread. However, if many threads need to generate
 788      * pseudorandom numbers at a great rate, it may reduce contention
 789      * for each thread to have its own pseudorandom-number generator.
 790      *
 791      * @apiNote
 792      * As the largest {@code double} value less than {@code 1.0}
 793      * is {@code Math.nextDown(1.0)}, a value {@code x} in the closed range
 794      * {@code [x1,x2]} where {@code x1&lt;=x2} may be defined by the statements
 795      *
 796      * &lt;blockquote&gt;&lt;pre&gt;{@code
 797      * double f = Math.random()/Math.nextDown(1.0);
 798      * double x = x1*(1.0 - f) + x2*f;
 799      * }&lt;/pre&gt;&lt;/blockquote&gt;
 800      *
 801      * @return  a pseudorandom {@code double} greater than or equal
 802      * to {@code 0.0} and less than {@code 1.0}.
 803      * @see #nextDown(double)
 804      * @see Random#nextDouble()
 805      */
 806     public static double random() {
 807         return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
 808     }
 809 
 810     /**
 811      * Returns the sum of its arguments,
 812      * throwing an exception if the result overflows an {@code int}.
 813      *
 814      * @param x the first value
 815      * @param y the second value
 816      * @return the result
 817      * @throws ArithmeticException if the result overflows an int
 818      * @since 1.8
 819      */
 820     @HotSpotIntrinsicCandidate
 821     public static int addExact(int x, int y) {
 822         int r = x + y;
 823         // HD 2-12 Overflow iff both arguments have the opposite sign of the result
 824         if (((x ^ r) &amp; (y ^ r)) &lt; 0) {
 825             throw new ArithmeticException(&quot;integer overflow&quot;);
 826         }
 827         return r;
 828     }
 829 
 830     /**
 831      * Returns the sum of its arguments,
 832      * throwing an exception if the result overflows a {@code long}.
 833      *
 834      * @param x the first value
 835      * @param y the second value
 836      * @return the result
 837      * @throws ArithmeticException if the result overflows a long
 838      * @since 1.8
 839      */
 840     @HotSpotIntrinsicCandidate
 841     public static long addExact(long x, long y) {
 842         long r = x + y;
 843         // HD 2-12 Overflow iff both arguments have the opposite sign of the result
 844         if (((x ^ r) &amp; (y ^ r)) &lt; 0) {
 845             throw new ArithmeticException(&quot;long overflow&quot;);
 846         }
 847         return r;
 848     }
 849 
 850     /**
 851      * Returns the difference of the arguments,
 852      * throwing an exception if the result overflows an {@code int}.
 853      *
 854      * @param x the first value
 855      * @param y the second value to subtract from the first
 856      * @return the result
 857      * @throws ArithmeticException if the result overflows an int
 858      * @since 1.8
 859      */
 860     @HotSpotIntrinsicCandidate
 861     public static int subtractExact(int x, int y) {
 862         int r = x - y;
 863         // HD 2-12 Overflow iff the arguments have different signs and
 864         // the sign of the result is different from the sign of x
 865         if (((x ^ y) &amp; (x ^ r)) &lt; 0) {
 866             throw new ArithmeticException(&quot;integer overflow&quot;);
 867         }
 868         return r;
 869     }
 870 
 871     /**
 872      * Returns the difference of the arguments,
 873      * throwing an exception if the result overflows a {@code long}.
 874      *
 875      * @param x the first value
 876      * @param y the second value to subtract from the first
 877      * @return the result
 878      * @throws ArithmeticException if the result overflows a long
 879      * @since 1.8
 880      */
 881     @HotSpotIntrinsicCandidate
 882     public static long subtractExact(long x, long y) {
 883         long r = x - y;
 884         // HD 2-12 Overflow iff the arguments have different signs and
 885         // the sign of the result is different from the sign of x
 886         if (((x ^ y) &amp; (x ^ r)) &lt; 0) {
 887             throw new ArithmeticException(&quot;long overflow&quot;);
 888         }
 889         return r;
 890     }
 891 
 892     /**
 893      * Returns the product of the arguments,
 894      * throwing an exception if the result overflows an {@code int}.
 895      *
 896      * @param x the first value
 897      * @param y the second value
 898      * @return the result
 899      * @throws ArithmeticException if the result overflows an int
 900      * @since 1.8
 901      */
 902     @HotSpotIntrinsicCandidate
 903     public static int multiplyExact(int x, int y) {
 904         long r = (long)x * (long)y;
 905         if ((int)r != r) {
 906             throw new ArithmeticException(&quot;integer overflow&quot;);
 907         }
 908         return (int)r;
 909     }
 910 
 911     /**
 912      * Returns the product of the arguments, throwing an exception if the result
 913      * overflows a {@code long}.
 914      *
 915      * @param x the first value
 916      * @param y the second value
 917      * @return the result
 918      * @throws ArithmeticException if the result overflows a long
 919      * @since 9
 920      */
 921     public static long multiplyExact(long x, int y) {
 922         return multiplyExact(x, (long)y);
 923     }
 924 
 925     /**
 926      * Returns the product of the arguments,
 927      * throwing an exception if the result overflows a {@code long}.
 928      *
 929      * @param x the first value
 930      * @param y the second value
 931      * @return the result
 932      * @throws ArithmeticException if the result overflows a long
 933      * @since 1.8
 934      */
 935     @HotSpotIntrinsicCandidate
 936     public static long multiplyExact(long x, long y) {
 937         long r = x * y;
 938         long ax = Math.abs(x);
 939         long ay = Math.abs(y);
 940         if (((ax | ay) &gt;&gt;&gt; 31 != 0)) {
 941             // Some bits greater than 2^31 that might cause overflow
 942             // Check the result using the divide operator
 943             // and check for the special case of Long.MIN_VALUE * -1
 944            if (((y != 0) &amp;&amp; (r / y != x)) ||
 945                (x == Long.MIN_VALUE &amp;&amp; y == -1)) {
 946                 throw new ArithmeticException(&quot;long overflow&quot;);
 947             }
 948         }
 949         return r;
 950     }
 951 
 952     /**
 953      * Returns the argument incremented by one, throwing an exception if the
 954      * result overflows an {@code int}.
 955      *
 956      * @param a the value to increment
 957      * @return the result
 958      * @throws ArithmeticException if the result overflows an int
 959      * @since 1.8
 960      */
 961     @HotSpotIntrinsicCandidate
 962     public static int incrementExact(int a) {
 963         if (a == Integer.MAX_VALUE) {
 964             throw new ArithmeticException(&quot;integer overflow&quot;);
 965         }
 966 
 967         return a + 1;
 968     }
 969 
 970     /**
 971      * Returns the argument incremented by one, throwing an exception if the
 972      * result overflows a {@code long}.
 973      *
 974      * @param a the value to increment
 975      * @return the result
 976      * @throws ArithmeticException if the result overflows a long
 977      * @since 1.8
 978      */
 979     @HotSpotIntrinsicCandidate
 980     public static long incrementExact(long a) {
 981         if (a == Long.MAX_VALUE) {
 982             throw new ArithmeticException(&quot;long overflow&quot;);
 983         }
 984 
 985         return a + 1L;
 986     }
 987 
 988     /**
 989      * Returns the argument decremented by one, throwing an exception if the
 990      * result overflows an {@code int}.
 991      *
 992      * @param a the value to decrement
 993      * @return the result
 994      * @throws ArithmeticException if the result overflows an int
 995      * @since 1.8
 996      */
 997     @HotSpotIntrinsicCandidate
 998     public static int decrementExact(int a) {
 999         if (a == Integer.MIN_VALUE) {
1000             throw new ArithmeticException(&quot;integer overflow&quot;);
1001         }
1002 
1003         return a - 1;
1004     }
1005 
1006     /**
1007      * Returns the argument decremented by one, throwing an exception if the
1008      * result overflows a {@code long}.
1009      *
1010      * @param a the value to decrement
1011      * @return the result
1012      * @throws ArithmeticException if the result overflows a long
1013      * @since 1.8
1014      */
1015     @HotSpotIntrinsicCandidate
1016     public static long decrementExact(long a) {
1017         if (a == Long.MIN_VALUE) {
1018             throw new ArithmeticException(&quot;long overflow&quot;);
1019         }
1020 
1021         return a - 1L;
1022     }
1023 
1024     /**
1025      * Returns the negation of the argument, throwing an exception if the
1026      * result overflows an {@code int}.
1027      *
1028      * @param a the value to negate
1029      * @return the result
1030      * @throws ArithmeticException if the result overflows an int
1031      * @since 1.8
1032      */
1033     @HotSpotIntrinsicCandidate
1034     public static int negateExact(int a) {
1035         if (a == Integer.MIN_VALUE) {
1036             throw new ArithmeticException(&quot;integer overflow&quot;);
1037         }
1038 
1039         return -a;
1040     }
1041 
1042     /**
1043      * Returns the negation of the argument, throwing an exception if the
1044      * result overflows a {@code long}.
1045      *
1046      * @param a the value to negate
1047      * @return the result
1048      * @throws ArithmeticException if the result overflows a long
1049      * @since 1.8
1050      */
1051     @HotSpotIntrinsicCandidate
1052     public static long negateExact(long a) {
1053         if (a == Long.MIN_VALUE) {
1054             throw new ArithmeticException(&quot;long overflow&quot;);
1055         }
1056 
1057         return -a;
1058     }
1059 
1060     /**
1061      * Returns the value of the {@code long} argument;
1062      * throwing an exception if the value overflows an {@code int}.
1063      *
1064      * @param value the long value
1065      * @return the argument as an int
1066      * @throws ArithmeticException if the {@code argument} overflows an int
1067      * @since 1.8
1068      */
1069     public static int toIntExact(long value) {
1070         if ((int)value != value) {
1071             throw new ArithmeticException(&quot;integer overflow&quot;);
1072         }
1073         return (int)value;
1074     }
1075 
1076     /**
1077      * Returns the exact mathematical product of the arguments.
1078      *
1079      * @param x the first value
1080      * @param y the second value
1081      * @return the result
1082      * @since 9
1083      */
1084     public static long multiplyFull(int x, int y) {
1085         return (long)x * (long)y;
1086     }
1087 
1088     /**
1089      * Returns as a {@code long} the most significant 64 bits of the 128-bit
1090      * product of two 64-bit factors.
1091      *
1092      * @param x the first value
1093      * @param y the second value
1094      * @return the result
1095      * @since 9
1096      */
1097     @HotSpotIntrinsicCandidate
1098     public static long multiplyHigh(long x, long y) {
1099         if (x &lt; 0 || y &lt; 0) {
1100             // Use technique from section 8-2 of Henry S. Warren, Jr.,
1101             // Hacker&#39;s Delight (2nd ed.) (Addison Wesley, 2013), 173-174.
1102             long x1 = x &gt;&gt; 32;
1103             long x2 = x &amp; 0xFFFFFFFFL;
1104             long y1 = y &gt;&gt; 32;
1105             long y2 = y &amp; 0xFFFFFFFFL;
1106             long z2 = x2 * y2;
1107             long t = x1 * y2 + (z2 &gt;&gt;&gt; 32);
1108             long z1 = t &amp; 0xFFFFFFFFL;
1109             long z0 = t &gt;&gt; 32;
1110             z1 += x2 * y1;
1111             return x1 * y1 + z0 + (z1 &gt;&gt; 32);
1112         } else {
1113             // Use Karatsuba technique with two base 2^32 digits.
1114             long x1 = x &gt;&gt;&gt; 32;
1115             long y1 = y &gt;&gt;&gt; 32;
1116             long x2 = x &amp; 0xFFFFFFFFL;
1117             long y2 = y &amp; 0xFFFFFFFFL;
1118             long A = x1 * y1;
1119             long B = x2 * y2;
1120             long C = (x1 + x2) * (y1 + y2);
1121             long K = C - A - B;
1122             return (((B &gt;&gt;&gt; 32) + K) &gt;&gt;&gt; 32) + A;
1123         }
1124     }
1125 
1126     /**
1127      * Returns the largest (closest to positive infinity)
1128      * {@code int} value that is less than or equal to the algebraic quotient.
1129      * There is one special case, if the dividend is the
1130      * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},
1131      * then integer overflow occurs and
1132      * the result is equal to {@code Integer.MIN_VALUE}.
1133      * &lt;p&gt;
1134      * Normal integer division operates under the round to zero rounding mode
1135      * (truncation).  This operation instead acts under the round toward
1136      * negative infinity (floor) rounding mode.
1137      * The floor rounding mode gives different results from truncation
1138      * when the exact result is negative.
1139      * &lt;ul&gt;
1140      *   &lt;li&gt;If the signs of the arguments are the same, the results of
1141      *       {@code floorDiv} and the {@code /} operator are the same.  &lt;br&gt;
1142      *       For example, {@code floorDiv(4, 3) == 1} and {@code (4 / 3) == 1}.&lt;/li&gt;
1143      *   &lt;li&gt;If the signs of the arguments are different,  the quotient is negative and
1144      *       {@code floorDiv} returns the integer less than or equal to the quotient
1145      *       and the {@code /} operator returns the integer closest to zero.&lt;br&gt;
1146      *       For example, {@code floorDiv(-4, 3) == -2},
1147      *       whereas {@code (-4 / 3) == -1}.
1148      *   &lt;/li&gt;
1149      * &lt;/ul&gt;
1150      *
1151      * @param x the dividend
1152      * @param y the divisor
1153      * @return the largest (closest to positive infinity)
1154      * {@code int} value that is less than or equal to the algebraic quotient.
1155      * @throws ArithmeticException if the divisor {@code y} is zero
1156      * @see #floorMod(int, int)
1157      * @see #floor(double)
1158      * @since 1.8
1159      */
1160     public static int floorDiv(int x, int y) {
1161         int r = x / y;
1162         // if the signs are different and modulo not zero, round down
1163         if ((x ^ y) &lt; 0 &amp;&amp; (r * y != x)) {
1164             r--;
1165         }
1166         return r;
1167     }
1168 
1169     /**
1170      * Returns the largest (closest to positive infinity)
1171      * {@code long} value that is less than or equal to the algebraic quotient.
1172      * There is one special case, if the dividend is the
1173      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
1174      * then integer overflow occurs and
1175      * the result is equal to {@code Long.MIN_VALUE}.
1176      * &lt;p&gt;
1177      * Normal integer division operates under the round to zero rounding mode
1178      * (truncation).  This operation instead acts under the round toward
1179      * negative infinity (floor) rounding mode.
1180      * The floor rounding mode gives different results from truncation
1181      * when the exact result is negative.
1182      * &lt;p&gt;
1183      * For examples, see {@link #floorDiv(int, int)}.
1184      *
1185      * @param x the dividend
1186      * @param y the divisor
1187      * @return the largest (closest to positive infinity)
1188      * {@code int} value that is less than or equal to the algebraic quotient.
1189      * @throws ArithmeticException if the divisor {@code y} is zero
1190      * @see #floorMod(long, int)
1191      * @see #floor(double)
1192      * @since 9
1193      */
1194     public static long floorDiv(long x, int y) {
1195         return floorDiv(x, (long)y);
1196     }
1197 
1198     /**
1199      * Returns the largest (closest to positive infinity)
1200      * {@code long} value that is less than or equal to the algebraic quotient.
1201      * There is one special case, if the dividend is the
1202      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
1203      * then integer overflow occurs and
1204      * the result is equal to {@code Long.MIN_VALUE}.
1205      * &lt;p&gt;
1206      * Normal integer division operates under the round to zero rounding mode
1207      * (truncation).  This operation instead acts under the round toward
1208      * negative infinity (floor) rounding mode.
1209      * The floor rounding mode gives different results from truncation
1210      * when the exact result is negative.
1211      * &lt;p&gt;
1212      * For examples, see {@link #floorDiv(int, int)}.
1213      *
1214      * @param x the dividend
1215      * @param y the divisor
1216      * @return the largest (closest to positive infinity)
1217      * {@code long} value that is less than or equal to the algebraic quotient.
1218      * @throws ArithmeticException if the divisor {@code y} is zero
1219      * @see #floorMod(long, long)
1220      * @see #floor(double)
1221      * @since 1.8
1222      */
1223     public static long floorDiv(long x, long y) {
1224         long r = x / y;
1225         // if the signs are different and modulo not zero, round down
1226         if ((x ^ y) &lt; 0 &amp;&amp; (r * y != x)) {
1227             r--;
1228         }
1229         return r;
1230     }
1231 
1232     /**
1233      * Returns the floor modulus of the {@code int} arguments.
1234      * &lt;p&gt;
1235      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1236      * has the same sign as the divisor {@code y}, and
1237      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1238      *
1239      * &lt;p&gt;
1240      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1241      * &lt;ul&gt;
1242      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1243      * &lt;/ul&gt;
1244      * &lt;p&gt;
1245      * The difference in values between {@code floorMod} and
1246      * the {@code %} operator is due to the difference between
1247      * {@code floorDiv} that returns the integer less than or equal to the quotient
1248      * and the {@code /} operator that returns the integer closest to zero.
1249      * &lt;p&gt;
1250      * Examples:
1251      * &lt;ul&gt;
1252      *   &lt;li&gt;If the signs of the arguments are the same, the results
1253      *       of {@code floorMod} and the {@code %} operator are the same.  &lt;br&gt;
1254      *       &lt;ul&gt;
1255      *       &lt;li&gt;{@code floorMod(4, 3) == 1}; &amp;nbsp; and {@code (4 % 3) == 1}&lt;/li&gt;
1256      *       &lt;/ul&gt;
1257      *   &lt;li&gt;If the signs of the arguments are different, the results differ from the {@code %} operator.&lt;br&gt;
1258      *      &lt;ul&gt;
1259      *      &lt;li&gt;{@code floorMod(+4, -3) == -2}; &amp;nbsp; and {@code (+4 % -3) == +1} &lt;/li&gt;
1260      *      &lt;li&gt;{@code floorMod(-4, +3) == +2}; &amp;nbsp; and {@code (-4 % +3) == -1} &lt;/li&gt;
1261      *      &lt;li&gt;{@code floorMod(-4, -3) == -1}; &amp;nbsp; and {@code (-4 % -3) == -1 } &lt;/li&gt;
1262      *      &lt;/ul&gt;
1263      *   &lt;/li&gt;
1264      * &lt;/ul&gt;
1265      * &lt;p&gt;
1266      * If the signs of arguments are unknown and a positive modulus
1267      * is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
1268      *
1269      * @param x the dividend
1270      * @param y the divisor
1271      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1272      * @throws ArithmeticException if the divisor {@code y} is zero
1273      * @see #floorDiv(int, int)
1274      * @since 1.8
1275      */
1276     public static int floorMod(int x, int y) {
1277         return x - floorDiv(x, y) * y;
1278     }
1279 
1280     /**
1281      * Returns the floor modulus of the {@code long} and {@code int} arguments.
1282      * &lt;p&gt;
1283      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1284      * has the same sign as the divisor {@code y}, and
1285      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1286      *
1287      * &lt;p&gt;
1288      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1289      * &lt;ul&gt;
1290      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1291      * &lt;/ul&gt;
1292      * &lt;p&gt;
1293      * For examples, see {@link #floorMod(int, int)}.
1294      *
1295      * @param x the dividend
1296      * @param y the divisor
1297      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1298      * @throws ArithmeticException if the divisor {@code y} is zero
1299      * @see #floorDiv(long, int)
1300      * @since 9
1301      */
1302     public static int floorMod(long x, int y) {
1303         // Result cannot overflow the range of int.
1304         return (int)(x - floorDiv(x, y) * y);
1305     }
1306 
1307     /**
1308      * Returns the floor modulus of the {@code long} arguments.
1309      * &lt;p&gt;
1310      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1311      * has the same sign as the divisor {@code y}, and
1312      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1313      *
1314      * &lt;p&gt;
1315      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1316      * &lt;ul&gt;
1317      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1318      * &lt;/ul&gt;
1319      * &lt;p&gt;
1320      * For examples, see {@link #floorMod(int, int)}.
1321      *
1322      * @param x the dividend
1323      * @param y the divisor
1324      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1325      * @throws ArithmeticException if the divisor {@code y} is zero
1326      * @see #floorDiv(long, long)
1327      * @since 1.8
1328      */
1329     public static long floorMod(long x, long y) {
1330         return x - floorDiv(x, y) * y;
1331     }
1332 
1333     /**
1334      * Returns the absolute value of an {@code int} value.
1335      * If the argument is not negative, the argument is returned.
1336      * If the argument is negative, the negation of the argument is returned.
1337      *
1338      * &lt;p&gt;Note that if the argument is equal to the value of
1339      * {@link Integer#MIN_VALUE}, the most negative representable
1340      * {@code int} value, the result is that same value, which is
1341      * negative.
1342      *
1343      * @param   a   the argument whose absolute value is to be determined
1344      * @return  the absolute value of the argument.
1345      */
1346     public static int abs(int a) {
1347         return (a &lt; 0) ? -a : a;
1348     }
1349 
1350     /**
1351      * Returns the absolute value of a {@code long} value.
1352      * If the argument is not negative, the argument is returned.
1353      * If the argument is negative, the negation of the argument is returned.
1354      *
1355      * &lt;p&gt;Note that if the argument is equal to the value of
1356      * {@link Long#MIN_VALUE}, the most negative representable
1357      * {@code long} value, the result is that same value, which
1358      * is negative.
1359      *
1360      * @param   a   the argument whose absolute value is to be determined
1361      * @return  the absolute value of the argument.
1362      */
1363     public static long abs(long a) {
1364         return (a &lt; 0) ? -a : a;
1365     }
1366 
1367     /**
1368      * Returns the absolute value of a {@code float} value.
1369      * If the argument is not negative, the argument is returned.
1370      * If the argument is negative, the negation of the argument is returned.
1371      * Special cases:
1372      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1373      * result is positive zero.
1374      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1375      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1376      *
1377      * @apiNote As implied by the above, one valid implementation of
1378      * this method is given by the expression below which computes a
1379      * {@code float} with the same exponent and significand as the
1380      * argument but with a guaranteed zero sign bit indicating a
1381      * positive value:&lt;br&gt;
1382      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1383      *
1384      * @param   a   the argument whose absolute value is to be determined
1385      * @return  the absolute value of the argument.
1386      */
1387     public static float abs(float a) {
1388         return (a &lt;= 0.0F) ? 0.0F - a : a;
1389     }
1390 
1391     /**
1392      * Returns the absolute value of a {@code double} value.
1393      * If the argument is not negative, the argument is returned.
1394      * If the argument is negative, the negation of the argument is returned.
1395      * Special cases:
1396      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1397      * is positive zero.
1398      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1399      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1400      *
1401      * @apiNote As implied by the above, one valid implementation of
1402      * this method is given by the expression below which computes a
1403      * {@code double} with the same exponent and significand as the
1404      * argument but with a guaranteed zero sign bit indicating a
1405      * positive value:&lt;br&gt;
1406      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
1407      *
1408      * @param   a   the argument whose absolute value is to be determined
1409      * @return  the absolute value of the argument.
1410      */
1411     @HotSpotIntrinsicCandidate
1412     public static double abs(double a) {
1413         return (a &lt;= 0.0D) ? 0.0D - a : a;
1414     }
1415 
1416     /**
1417      * Returns the greater of two {@code int} values. That is, the
1418      * result is the argument closer to the value of
1419      * {@link Integer#MAX_VALUE}. If the arguments have the same value,
1420      * the result is that same value.
1421      *
1422      * @param   a   an argument.
1423      * @param   b   another argument.
1424      * @return  the larger of {@code a} and {@code b}.
1425      */
1426     @HotSpotIntrinsicCandidate
1427     public static int max(int a, int b) {
1428         return (a &gt;= b) ? a : b;
1429     }
1430 
1431     /**
1432      * Returns the greater of two {@code long} values. That is, the
1433      * result is the argument closer to the value of
1434      * {@link Long#MAX_VALUE}. If the arguments have the same value,
1435      * the result is that same value.
1436      *
1437      * @param   a   an argument.
1438      * @param   b   another argument.
1439      * @return  the larger of {@code a} and {@code b}.
1440      */
1441     public static long max(long a, long b) {
1442         return (a &gt;= b) ? a : b;
1443     }
1444 
1445     // Use raw bit-wise conversions on guaranteed non-NaN arguments.
1446     private static final long negativeZeroFloatBits  = Float.floatToRawIntBits(-0.0f);
1447     private static final long negativeZeroDoubleBits = Double.doubleToRawLongBits(-0.0d);
1448 
1449     /**
1450      * Returns the greater of two {@code float} values.  That is,
1451      * the result is the argument closer to positive infinity. If the
1452      * arguments have the same value, the result is that same
1453      * value. If either value is NaN, then the result is NaN.  Unlike
1454      * the numerical comparison operators, this method considers
1455      * negative zero to be strictly smaller than positive zero. If one
1456      * argument is positive zero and the other negative zero, the
1457      * result is positive zero.
1458      *
1459      * @param   a   an argument.
1460      * @param   b   another argument.
1461      * @return  the larger of {@code a} and {@code b}.
1462      */
1463     @HotSpotIntrinsicCandidate
1464     public static float max(float a, float b) {
1465         if (a != a)
1466             return a;   // a is NaN
1467         if ((a == 0.0f) &amp;&amp;
1468             (b == 0.0f) &amp;&amp;
1469             (Float.floatToRawIntBits(a) == negativeZeroFloatBits)) {
1470             // Raw conversion ok since NaN can&#39;t map to -0.0.
1471             return b;
1472         }
1473         return (a &gt;= b) ? a : b;
1474     }
1475 
1476     /**
1477      * Returns the greater of two {@code double} values.  That
1478      * is, the result is the argument closer to positive infinity. If
1479      * the arguments have the same value, the result is that same
1480      * value. If either value is NaN, then the result is NaN.  Unlike
1481      * the numerical comparison operators, this method considers
1482      * negative zero to be strictly smaller than positive zero. If one
1483      * argument is positive zero and the other negative zero, the
1484      * result is positive zero.
1485      *
1486      * @param   a   an argument.
1487      * @param   b   another argument.
1488      * @return  the larger of {@code a} and {@code b}.
1489      */
1490     @HotSpotIntrinsicCandidate
1491     public static double max(double a, double b) {
1492         if (a != a)
1493             return a;   // a is NaN
1494         if ((a == 0.0d) &amp;&amp;
1495             (b == 0.0d) &amp;&amp;
1496             (Double.doubleToRawLongBits(a) == negativeZeroDoubleBits)) {
1497             // Raw conversion ok since NaN can&#39;t map to -0.0.
1498             return b;
1499         }
1500         return (a &gt;= b) ? a : b;
1501     }
1502 
1503     /**
1504      * Returns the smaller of two {@code int} values. That is,
1505      * the result the argument closer to the value of
1506      * {@link Integer#MIN_VALUE}.  If the arguments have the same
1507      * value, the result is that same value.
1508      *
1509      * @param   a   an argument.
1510      * @param   b   another argument.
1511      * @return  the smaller of {@code a} and {@code b}.
1512      */
1513     @HotSpotIntrinsicCandidate
1514     public static int min(int a, int b) {
1515         return (a &lt;= b) ? a : b;
1516     }
1517 
1518     /**
1519      * Returns the smaller of two {@code long} values. That is,
1520      * the result is the argument closer to the value of
1521      * {@link Long#MIN_VALUE}. If the arguments have the same
1522      * value, the result is that same value.
1523      *
1524      * @param   a   an argument.
1525      * @param   b   another argument.
1526      * @return  the smaller of {@code a} and {@code b}.
1527      */
1528     public static long min(long a, long b) {
1529         return (a &lt;= b) ? a : b;
1530     }
1531 
1532     /**
1533      * Returns the smaller of two {@code float} values.  That is,
1534      * the result is the value closer to negative infinity. If the
1535      * arguments have the same value, the result is that same
1536      * value. If either value is NaN, then the result is NaN.  Unlike
1537      * the numerical comparison operators, this method considers
1538      * negative zero to be strictly smaller than positive zero.  If
1539      * one argument is positive zero and the other is negative zero,
1540      * the result is negative zero.
1541      *
1542      * @param   a   an argument.
1543      * @param   b   another argument.
1544      * @return  the smaller of {@code a} and {@code b}.
1545      */
1546     @HotSpotIntrinsicCandidate
1547     public static float min(float a, float b) {
1548         if (a != a)
1549             return a;   // a is NaN
1550         if ((a == 0.0f) &amp;&amp;
1551             (b == 0.0f) &amp;&amp;
1552             (Float.floatToRawIntBits(b) == negativeZeroFloatBits)) {
1553             // Raw conversion ok since NaN can&#39;t map to -0.0.
1554             return b;
1555         }
1556         return (a &lt;= b) ? a : b;
1557     }
1558 
1559     /**
1560      * Returns the smaller of two {@code double} values.  That
1561      * is, the result is the value closer to negative infinity. If the
1562      * arguments have the same value, the result is that same
1563      * value. If either value is NaN, then the result is NaN.  Unlike
1564      * the numerical comparison operators, this method considers
1565      * negative zero to be strictly smaller than positive zero. If one
1566      * argument is positive zero and the other is negative zero, the
1567      * result is negative zero.
1568      *
1569      * @param   a   an argument.
1570      * @param   b   another argument.
1571      * @return  the smaller of {@code a} and {@code b}.
1572      */
1573     @HotSpotIntrinsicCandidate
1574     public static double min(double a, double b) {
1575         if (a != a)
1576             return a;   // a is NaN
1577         if ((a == 0.0d) &amp;&amp;
1578             (b == 0.0d) &amp;&amp;
1579             (Double.doubleToRawLongBits(b) == negativeZeroDoubleBits)) {
1580             // Raw conversion ok since NaN can&#39;t map to -0.0.
1581             return b;
1582         }
1583         return (a &lt;= b) ? a : b;
1584     }
1585 
1586     /**
1587      * Returns the fused multiply add of the three arguments; that is,
1588      * returns the exact product of the first two arguments summed
1589      * with the third argument and then rounded once to the nearest
1590      * {@code double}.
1591      *
1592      * The rounding is done using the {@linkplain
1593      * java.math.RoundingMode#HALF_EVEN round to nearest even
1594      * rounding mode}.
1595      *
1596      * In contrast, if {@code a * b + c} is evaluated as a regular
1597      * floating-point expression, two rounding errors are involved,
1598      * the first for the multiply operation, the second for the
1599      * addition operation.
1600      *
1601      * &lt;p&gt;Special cases:
1602      * &lt;ul&gt;
1603      * &lt;li&gt; If any argument is NaN, the result is NaN.
1604      *
1605      * &lt;li&gt; If one of the first two arguments is infinite and the
1606      * other is zero, the result is NaN.
1607      *
1608      * &lt;li&gt; If the exact product of the first two arguments is infinite
1609      * (in other words, at least one of the arguments is infinite and
1610      * the other is neither zero nor NaN) and the third argument is an
1611      * infinity of the opposite sign, the result is NaN.
1612      *
1613      * &lt;/ul&gt;
1614      *
1615      * &lt;p&gt;Note that {@code fma(a, 1.0, c)} returns the same
1616      * result as ({@code a + c}).  However,
1617      * {@code fma(a, b, +0.0)} does &lt;em&gt;not&lt;/em&gt; always return the
1618      * same result as ({@code a * b}) since
1619      * {@code fma(-0.0, +0.0, +0.0)} is {@code +0.0} while
1620      * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fma(a, b, -0.0)} is
1621      * equivalent to ({@code a * b}) however.
1622      *
1623      * @apiNote This method corresponds to the fusedMultiplyAdd
1624      * operation defined in IEEE 754-2008.
1625      *
1626      * @param a a value
1627      * @param b a value
1628      * @param c a value
1629      *
1630      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1631      * computed, as if with unlimited range and precision, and rounded
1632      * once to the nearest {@code double} value
1633      *
1634      * @since 9
1635      */
1636     @HotSpotIntrinsicCandidate
1637     public static double fma(double a, double b, double c) {
1638         /*
1639          * Infinity and NaN arithmetic is not quite the same with two
1640          * roundings as opposed to just one so the simple expression
1641          * &quot;a * b + c&quot; cannot always be used to compute the correct
1642          * result.  With two roundings, the product can overflow and
1643          * if the addend is infinite, a spurious NaN can be produced
1644          * if the infinity from the overflow and the infinite addend
1645          * have opposite signs.
1646          */
1647 
1648         // First, screen for and handle non-finite input values whose
1649         // arithmetic is not supported by BigDecimal.
1650         if (Double.isNaN(a) || Double.isNaN(b) || Double.isNaN(c)) {
1651             return Double.NaN;
1652         } else { // All inputs non-NaN
1653             boolean infiniteA = Double.isInfinite(a);
1654             boolean infiniteB = Double.isInfinite(b);
1655             boolean infiniteC = Double.isInfinite(c);
1656             double result;
1657 
1658             if (infiniteA || infiniteB || infiniteC) {
1659                 if (infiniteA &amp;&amp; b == 0.0 ||
1660                     infiniteB &amp;&amp; a == 0.0 ) {
1661                     return Double.NaN;
1662                 }
1663                 // Store product in a double field to cause an
1664                 // overflow even if non-strictfp evaluation is being
1665                 // used.
1666                 double product = a * b;
1667                 if (Double.isInfinite(product) &amp;&amp; !infiniteA &amp;&amp; !infiniteB) {
1668                     // Intermediate overflow; might cause a
1669                     // spurious NaN if added to infinite c.
1670                     assert Double.isInfinite(c);
1671                     return c;
1672                 } else {
1673                     result = product + c;
1674                     assert !Double.isFinite(result);
1675                     return result;
1676                 }
1677             } else { // All inputs finite
1678                 BigDecimal product = (new BigDecimal(a)).multiply(new BigDecimal(b));
1679                 if (c == 0.0) { // Positive or negative zero
1680                     // If the product is an exact zero, use a
1681                     // floating-point expression to compute the sign
1682                     // of the zero final result. The product is an
1683                     // exact zero if and only if at least one of a and
1684                     // b is zero.
1685                     if (a == 0.0 || b == 0.0) {
1686                         return a * b + c;
1687                     } else {
1688                         // The sign of a zero addend doesn&#39;t matter if
1689                         // the product is nonzero. The sign of a zero
1690                         // addend is not factored in the result if the
1691                         // exact product is nonzero but underflows to
1692                         // zero; see IEEE-754 2008 section 6.3 &quot;The
1693                         // sign bit&quot;.
1694                         return product.doubleValue();
1695                     }
1696                 } else {
1697                     return product.add(new BigDecimal(c)).doubleValue();
1698                 }
1699             }
1700         }
1701     }
1702 
1703     /**
1704      * Returns the fused multiply add of the three arguments; that is,
1705      * returns the exact product of the first two arguments summed
1706      * with the third argument and then rounded once to the nearest
1707      * {@code float}.
1708      *
1709      * The rounding is done using the {@linkplain
1710      * java.math.RoundingMode#HALF_EVEN round to nearest even
1711      * rounding mode}.
1712      *
1713      * In contrast, if {@code a * b + c} is evaluated as a regular
1714      * floating-point expression, two rounding errors are involved,
1715      * the first for the multiply operation, the second for the
1716      * addition operation.
1717      *
1718      * &lt;p&gt;Special cases:
1719      * &lt;ul&gt;
1720      * &lt;li&gt; If any argument is NaN, the result is NaN.
1721      *
1722      * &lt;li&gt; If one of the first two arguments is infinite and the
1723      * other is zero, the result is NaN.
1724      *
1725      * &lt;li&gt; If the exact product of the first two arguments is infinite
1726      * (in other words, at least one of the arguments is infinite and
1727      * the other is neither zero nor NaN) and the third argument is an
1728      * infinity of the opposite sign, the result is NaN.
1729      *
1730      * &lt;/ul&gt;
1731      *
1732      * &lt;p&gt;Note that {@code fma(a, 1.0f, c)} returns the same
1733      * result as ({@code a + c}).  However,
1734      * {@code fma(a, b, +0.0f)} does &lt;em&gt;not&lt;/em&gt; always return the
1735      * same result as ({@code a * b}) since
1736      * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
1737      * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
1738      * equivalent to ({@code a * b}) however.
1739      *
1740      * @apiNote This method corresponds to the fusedMultiplyAdd
1741      * operation defined in IEEE 754-2008.
1742      *
1743      * @param a a value
1744      * @param b a value
1745      * @param c a value
1746      *
1747      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1748      * computed, as if with unlimited range and precision, and rounded
1749      * once to the nearest {@code float} value
1750      *
1751      * @since 9
1752      */
1753     @HotSpotIntrinsicCandidate
1754     public static float fma(float a, float b, float c) {
1755         /*
1756          *  Since the double format has more than twice the precision
1757          *  of the float format, the multiply of a * b is exact in
1758          *  double. The add of c to the product then incurs one
1759          *  rounding error. Since the double format moreover has more
1760          *  than (2p + 2) precision bits compared to the p bits of the
1761          *  float format, the two roundings of (a * b + c), first to
1762          *  the double format and then secondarily to the float format,
1763          *  are equivalent to rounding the intermediate result directly
1764          *  to the float format.
1765          *
1766          * In terms of strictfp vs default-fp concerns related to
1767          * overflow and underflow, since
1768          *
1769          * (Float.MAX_VALUE * Float.MAX_VALUE) &lt;&lt; Double.MAX_VALUE
1770          * (Float.MIN_VALUE * Float.MIN_VALUE) &gt;&gt; Double.MIN_VALUE
1771          *
1772          * neither the multiply nor add will overflow or underflow in
1773          * double. Therefore, it is not necessary for this method to
1774          * be declared strictfp to have reproducible
1775          * behavior. However, it is necessary to explicitly store down
1776          * to a float variable to avoid returning a value in the float
1777          * extended value set.
1778          */
1779         float result = (float)(((double) a * (double) b ) + (double) c);
1780         return result;
1781     }
1782 
1783     /**
1784      * Returns the size of an ulp of the argument.  An ulp, unit in
1785      * the last place, of a {@code double} value is the positive
1786      * distance between this floating-point value and the {@code
1787      * double} value next larger in magnitude.  Note that for non-NaN
1788      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1789      *
1790      * &lt;p&gt;Special Cases:
1791      * &lt;ul&gt;
1792      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1793      * &lt;li&gt; If the argument is positive or negative infinity, then the
1794      * result is positive infinity.
1795      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1796      * {@code Double.MIN_VALUE}.
1797      * &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
1798      * the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
1799      * &lt;/ul&gt;
1800      *
1801      * @param d the floating-point value whose ulp is to be returned
1802      * @return the size of an ulp of the argument
1803      * @author Joseph D. Darcy
1804      * @since 1.5
1805      */
1806     public static double ulp(double d) {
1807         int exp = getExponent(d);
1808 
1809         switch(exp) {
1810         case Double.MAX_EXPONENT + 1:       // NaN or infinity
1811             return Math.abs(d);
1812 
1813         case Double.MIN_EXPONENT - 1:       // zero or subnormal
1814             return Double.MIN_VALUE;
1815 
1816         default:
1817             assert exp &lt;= Double.MAX_EXPONENT &amp;&amp; exp &gt;= Double.MIN_EXPONENT;
1818 
1819             // ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
1820             exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH-1);
1821             if (exp &gt;= Double.MIN_EXPONENT) {
1822                 return powerOfTwoD(exp);
1823             }
1824             else {
1825                 // return a subnormal result; left shift integer
1826                 // representation of Double.MIN_VALUE appropriate
1827                 // number of positions
1828                 return Double.longBitsToDouble(1L &lt;&lt;
1829                 (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH-1)) ));
1830             }
1831         }
1832     }
1833 
1834     /**
1835      * Returns the size of an ulp of the argument.  An ulp, unit in
1836      * the last place, of a {@code float} value is the positive
1837      * distance between this floating-point value and the {@code
1838      * float} value next larger in magnitude.  Note that for non-NaN
1839      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1840      *
1841      * &lt;p&gt;Special Cases:
1842      * &lt;ul&gt;
1843      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1844      * &lt;li&gt; If the argument is positive or negative infinity, then the
1845      * result is positive infinity.
1846      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1847      * {@code Float.MIN_VALUE}.
1848      * &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
1849      * the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
1850      * &lt;/ul&gt;
1851      *
1852      * @param f the floating-point value whose ulp is to be returned
1853      * @return the size of an ulp of the argument
1854      * @author Joseph D. Darcy
1855      * @since 1.5
1856      */
1857     public static float ulp(float f) {
1858         int exp = getExponent(f);
1859 
1860         switch(exp) {
1861         case Float.MAX_EXPONENT+1:        // NaN or infinity
1862             return Math.abs(f);
1863 
1864         case Float.MIN_EXPONENT-1:        // zero or subnormal
1865             return Float.MIN_VALUE;
1866 
1867         default:
1868             assert exp &lt;= Float.MAX_EXPONENT &amp;&amp; exp &gt;= Float.MIN_EXPONENT;
1869 
1870             // ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
1871             exp = exp - (FloatConsts.SIGNIFICAND_WIDTH-1);
1872             if (exp &gt;= Float.MIN_EXPONENT) {
1873                 return powerOfTwoF(exp);
1874             } else {
1875                 // return a subnormal result; left shift integer
1876                 // representation of FloatConsts.MIN_VALUE appropriate
1877                 // number of positions
1878                 return Float.intBitsToFloat(1 &lt;&lt;
1879                 (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH-1)) ));
1880             }
1881         }
1882     }
1883 
1884     /**
1885      * Returns the signum function of the argument; zero if the argument
1886      * is zero, 1.0 if the argument is greater than zero, -1.0 if the
1887      * argument is less than zero.
1888      *
1889      * &lt;p&gt;Special Cases:
1890      * &lt;ul&gt;
1891      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1892      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1893      *      result is the same as the argument.
1894      * &lt;/ul&gt;
1895      *
1896      * @param d the floating-point value whose signum is to be returned
1897      * @return the signum function of the argument
1898      * @author Joseph D. Darcy
1899      * @since 1.5
1900      */
1901     public static double signum(double d) {
1902         return (d == 0.0 || Double.isNaN(d))?d:copySign(1.0, d);
1903     }
1904 
1905     /**
1906      * Returns the signum function of the argument; zero if the argument
1907      * is zero, 1.0f if the argument is greater than zero, -1.0f if the
1908      * argument is less than zero.
1909      *
1910      * &lt;p&gt;Special Cases:
1911      * &lt;ul&gt;
1912      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1913      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1914      *      result is the same as the argument.
1915      * &lt;/ul&gt;
1916      *
1917      * @param f the floating-point value whose signum is to be returned
1918      * @return the signum function of the argument
1919      * @author Joseph D. Darcy
1920      * @since 1.5
1921      */
1922     public static float signum(float f) {
1923         return (f == 0.0f || Float.isNaN(f))?f:copySign(1.0f, f);
1924     }
1925 
1926     /**
1927      * Returns the hyperbolic sine of a {@code double} value.
1928      * The hyperbolic sine of &lt;i&gt;x&lt;/i&gt; is defined to be
1929      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1930      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1931      *
1932      * &lt;p&gt;Special cases:
1933      * &lt;ul&gt;
1934      *
1935      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1936      *
1937      * &lt;li&gt;If the argument is infinite, then the result is an infinity
1938      * with the same sign as the argument.
1939      *
1940      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1941      * same sign as the argument.
1942      *
1943      * &lt;/ul&gt;
1944      *
1945      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
1946      *
1947      * @param   x The number whose hyperbolic sine is to be returned.
1948      * @return  The hyperbolic sine of {@code x}.
1949      * @since 1.5
1950      */
1951     public static double sinh(double x) {
1952         return StrictMath.sinh(x);
1953     }
1954 
1955     /**
1956      * Returns the hyperbolic cosine of a {@code double} value.
1957      * The hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; is defined to be
1958      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1959      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1960      *
1961      * &lt;p&gt;Special cases:
1962      * &lt;ul&gt;
1963      *
1964      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1965      *
1966      * &lt;li&gt;If the argument is infinite, then the result is positive
1967      * infinity.
1968      *
1969      * &lt;li&gt;If the argument is zero, then the result is {@code 1.0}.
1970      *
1971      * &lt;/ul&gt;
1972      *
1973      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
1974      *
1975      * @param   x The number whose hyperbolic cosine is to be returned.
1976      * @return  The hyperbolic cosine of {@code x}.
1977      * @since 1.5
1978      */
1979     public static double cosh(double x) {
1980         return StrictMath.cosh(x);
1981     }
1982 
1983     /**
1984      * Returns the hyperbolic tangent of a {@code double} value.
1985      * The hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; is defined to be
1986      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/(&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;),
1987      * in other words, {@linkplain Math#sinh
1988      * sinh(&lt;i&gt;x&lt;/i&gt;)}/{@linkplain Math#cosh cosh(&lt;i&gt;x&lt;/i&gt;)}.  Note
1989      * that the absolute value of the exact tanh is always less than
1990      * 1.
1991      *
1992      * &lt;p&gt;Special cases:
1993      * &lt;ul&gt;
1994      *
1995      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1996      *
1997      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1998      * same sign as the argument.
1999      *
2000      * &lt;li&gt;If the argument is positive infinity, then the result is
2001      * {@code +1.0}.
2002      *
2003      * &lt;li&gt;If the argument is negative infinity, then the result is
2004      * {@code -1.0}.
2005      *
2006      * &lt;/ul&gt;
2007      *
2008      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
2009      * The result of {@code tanh} for any finite input must have
2010      * an absolute value less than or equal to 1.  Note that once the
2011      * exact result of tanh is within 1/2 of an ulp of the limit value
2012      * of &amp;plusmn;1, correctly signed &amp;plusmn;{@code 1.0} should
2013      * be returned.
2014      *
2015      * @param   x The number whose hyperbolic tangent is to be returned.
2016      * @return  The hyperbolic tangent of {@code x}.
2017      * @since 1.5
2018      */
2019     public static double tanh(double x) {
2020         return StrictMath.tanh(x);
2021     }
2022 
2023     /**
2024      * Returns sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
2025      * without intermediate overflow or underflow.
2026      *
2027      * &lt;p&gt;Special cases:
2028      * &lt;ul&gt;
2029      *
2030      * &lt;li&gt; If either argument is infinite, then the result
2031      * is positive infinity.
2032      *
2033      * &lt;li&gt; If either argument is NaN and neither argument is infinite,
2034      * then the result is NaN.
2035      *
2036      * &lt;/ul&gt;
2037      *
2038      * &lt;p&gt;The computed result must be within 1 ulp of the exact
2039      * result.  If one parameter is held constant, the results must be
2040      * semi-monotonic in the other parameter.
2041      *
2042      * @param x a value
2043      * @param y a value
2044      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
2045      * without intermediate overflow or underflow
2046      * @since 1.5
2047      */
2048     public static double hypot(double x, double y) {
2049         return StrictMath.hypot(x, y);
2050     }
2051 
2052     /**
2053      * Returns &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-1.  Note that for values of
2054      * &lt;i&gt;x&lt;/i&gt; near 0, the exact sum of
2055      * {@code expm1(x)}&amp;nbsp;+&amp;nbsp;1 is much closer to the true
2056      * result of &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt; than {@code exp(x)}.
2057      *
2058      * &lt;p&gt;Special cases:
2059      * &lt;ul&gt;
2060      * &lt;li&gt;If the argument is NaN, the result is NaN.
2061      *
2062      * &lt;li&gt;If the argument is positive infinity, then the result is
2063      * positive infinity.
2064      *
2065      * &lt;li&gt;If the argument is negative infinity, then the result is
2066      * -1.0.
2067      *
2068      * &lt;li&gt;If the argument is zero, then the result is a zero with the
2069      * same sign as the argument.
2070      *
2071      * &lt;/ul&gt;
2072      *
2073      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
2074      * Results must be semi-monotonic.  The result of
2075      * {@code expm1} for any finite input must be greater than or
2076      * equal to {@code -1.0}.  Note that once the exact result of
2077      * &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1 is within 1/2
2078      * ulp of the limit value -1, {@code -1.0} should be
2079      * returned.
2080      *
2081      * @param   x   the exponent to raise &lt;i&gt;e&lt;/i&gt; to in the computation of
2082      *              &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-1.
2083      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1.
2084      * @since 1.5
2085      */
2086     public static double expm1(double x) {
2087         return StrictMath.expm1(x);
2088     }
2089 
2090     /**
2091      * Returns the natural logarithm of the sum of the argument and 1.
2092      * Note that for small values {@code x}, the result of
2093      * {@code log1p(x)} is much closer to the true result of ln(1
2094      * + {@code x}) than the floating-point evaluation of
2095      * {@code log(1.0+x)}.
2096      *
2097      * &lt;p&gt;Special cases:
2098      *
2099      * &lt;ul&gt;
2100      *
2101      * &lt;li&gt;If the argument is NaN or less than -1, then the result is
2102      * NaN.
2103      *
2104      * &lt;li&gt;If the argument is positive infinity, then the result is
2105      * positive infinity.
2106      *
2107      * &lt;li&gt;If the argument is negative one, then the result is
2108      * negative infinity.
2109      *
2110      * &lt;li&gt;If the argument is zero, then the result is a zero with the
2111      * same sign as the argument.
2112      *
2113      * &lt;/ul&gt;
2114      *
2115      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
2116      * Results must be semi-monotonic.
2117      *
2118      * @param   x   a value
2119      * @return the value ln({@code x}&amp;nbsp;+&amp;nbsp;1), the natural
2120      * log of {@code x}&amp;nbsp;+&amp;nbsp;1
2121      * @since 1.5
2122      */
2123     public static double log1p(double x) {
2124         return StrictMath.log1p(x);
2125     }
2126 
2127     /**
2128      * Returns the first floating-point argument with the sign of the
2129      * second floating-point argument.  Note that unlike the {@link
2130      * StrictMath#copySign(double, double) StrictMath.copySign}
2131      * method, this method does not require NaN {@code sign}
2132      * arguments to be treated as positive values; implementations are
2133      * permitted to treat some NaN arguments as positive and other NaN
2134      * arguments as negative to allow greater performance.
2135      *
2136      * @param magnitude  the parameter providing the magnitude of the result
2137      * @param sign   the parameter providing the sign of the result
2138      * @return a value with the magnitude of {@code magnitude}
2139      * and the sign of {@code sign}.
2140      * @since 1.6
2141      */
2142     public static double copySign(double magnitude, double sign) {
2143         return Double.longBitsToDouble((Double.doubleToRawLongBits(sign) &amp;
2144                                         (DoubleConsts.SIGN_BIT_MASK)) |
2145                                        (Double.doubleToRawLongBits(magnitude) &amp;
2146                                         (DoubleConsts.EXP_BIT_MASK |
2147                                          DoubleConsts.SIGNIF_BIT_MASK)));
2148     }
2149 
2150     /**
2151      * Returns the first floating-point argument with the sign of the
2152      * second floating-point argument.  Note that unlike the {@link
2153      * StrictMath#copySign(float, float) StrictMath.copySign}
2154      * method, this method does not require NaN {@code sign}
2155      * arguments to be treated as positive values; implementations are
2156      * permitted to treat some NaN arguments as positive and other NaN
2157      * arguments as negative to allow greater performance.
2158      *
2159      * @param magnitude  the parameter providing the magnitude of the result
2160      * @param sign   the parameter providing the sign of the result
2161      * @return a value with the magnitude of {@code magnitude}
2162      * and the sign of {@code sign}.
2163      * @since 1.6
2164      */
2165     public static float copySign(float magnitude, float sign) {
2166         return Float.intBitsToFloat((Float.floatToRawIntBits(sign) &amp;
2167                                      (FloatConsts.SIGN_BIT_MASK)) |
2168                                     (Float.floatToRawIntBits(magnitude) &amp;
2169                                      (FloatConsts.EXP_BIT_MASK |
2170                                       FloatConsts.SIGNIF_BIT_MASK)));
2171     }
2172 
2173     /**
2174      * Returns the unbiased exponent used in the representation of a
2175      * {@code float}.  Special cases:
2176      *
2177      * &lt;ul&gt;
2178      * &lt;li&gt;If the argument is NaN or infinite, then the result is
2179      * {@link Float#MAX_EXPONENT} + 1.
2180      * &lt;li&gt;If the argument is zero or subnormal, then the result is
2181      * {@link Float#MIN_EXPONENT} -1.
2182      * &lt;/ul&gt;
2183      * @param f a {@code float} value
2184      * @return the unbiased exponent of the argument
2185      * @since 1.6
2186      */
2187     public static int getExponent(float f) {
2188         /*
2189          * Bitwise convert f to integer, mask out exponent bits, shift
2190          * to the right and then subtract out float&#39;s bias adjust to
2191          * get true exponent value
2192          */
2193         return ((Float.floatToRawIntBits(f) &amp; FloatConsts.EXP_BIT_MASK) &gt;&gt;
2194                 (FloatConsts.SIGNIFICAND_WIDTH - 1)) - FloatConsts.EXP_BIAS;
2195     }
2196 
2197     /**
2198      * Returns the unbiased exponent used in the representation of a
2199      * {@code double}.  Special cases:
2200      *
2201      * &lt;ul&gt;
2202      * &lt;li&gt;If the argument is NaN or infinite, then the result is
2203      * {@link Double#MAX_EXPONENT} + 1.
2204      * &lt;li&gt;If the argument is zero or subnormal, then the result is
2205      * {@link Double#MIN_EXPONENT} -1.
2206      * &lt;/ul&gt;
2207      * @param d a {@code double} value
2208      * @return the unbiased exponent of the argument
2209      * @since 1.6
2210      */
2211     public static int getExponent(double d) {
2212         /*
2213          * Bitwise convert d to long, mask out exponent bits, shift
2214          * to the right and then subtract out double&#39;s bias adjust to
2215          * get true exponent value.
2216          */
2217         return (int)(((Double.doubleToRawLongBits(d) &amp; DoubleConsts.EXP_BIT_MASK) &gt;&gt;
2218                       (DoubleConsts.SIGNIFICAND_WIDTH - 1)) - DoubleConsts.EXP_BIAS);
2219     }
2220 
2221     /**
2222      * Returns the floating-point number adjacent to the first
2223      * argument in the direction of the second argument.  If both
2224      * arguments compare as equal the second argument is returned.
2225      *
2226      * &lt;p&gt;
2227      * Special cases:
2228      * &lt;ul&gt;
2229      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
2230      *
2231      * &lt;li&gt; If both arguments are signed zeros, {@code direction}
2232      * is returned unchanged (as implied by the requirement of
2233      * returning the second argument if the arguments compare as
2234      * equal).
2235      *
2236      * &lt;li&gt; If {@code start} is
2237      * &amp;plusmn;{@link Double#MIN_VALUE} and {@code direction}
2238      * has a value such that the result should have a smaller
2239      * magnitude, then a zero with the same sign as {@code start}
2240      * is returned.
2241      *
2242      * &lt;li&gt; If {@code start} is infinite and
2243      * {@code direction} has a value such that the result should
2244      * have a smaller magnitude, {@link Double#MAX_VALUE} with the
2245      * same sign as {@code start} is returned.
2246      *
2247      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
2248      * {@link Double#MAX_VALUE} and {@code direction} has a
2249      * value such that the result should have a larger magnitude, an
2250      * infinity with same sign as {@code start} is returned.
2251      * &lt;/ul&gt;
2252      *
2253      * @param start  starting floating-point value
2254      * @param direction value indicating which of
2255      * {@code start}&#39;s neighbors or {@code start} should
2256      * be returned
2257      * @return The floating-point number adjacent to {@code start} in the
2258      * direction of {@code direction}.
2259      * @since 1.6
2260      */
2261     public static double nextAfter(double start, double direction) {
2262         /*
2263          * The cases:
2264          *
2265          * nextAfter(+infinity, 0)  == MAX_VALUE
2266          * nextAfter(+infinity, +infinity)  == +infinity
2267          * nextAfter(-infinity, 0)  == -MAX_VALUE
2268          * nextAfter(-infinity, -infinity)  == -infinity
2269          *
2270          * are naturally handled without any additional testing
2271          */
2272 
2273         /*
2274          * IEEE 754 floating-point numbers are lexicographically
2275          * ordered if treated as signed-magnitude integers.
2276          * Since Java&#39;s integers are two&#39;s complement,
2277          * incrementing the two&#39;s complement representation of a
2278          * logically negative floating-point value *decrements*
2279          * the signed-magnitude representation. Therefore, when
2280          * the integer representation of a floating-point value
2281          * is negative, the adjustment to the representation is in
2282          * the opposite direction from what would initially be expected.
2283          */
2284 
2285         // Branch to descending case first as it is more costly than ascending
2286         // case due to start != 0.0d conditional.
2287         if (start &gt; direction) { // descending
2288             if (start != 0.0d) {
2289                 final long transducer = Double.doubleToRawLongBits(start);
2290                 return Double.longBitsToDouble(transducer + ((transducer &gt; 0L) ? -1L : 1L));
2291             } else { // start == 0.0d &amp;&amp; direction &lt; 0.0d
2292                 return -Double.MIN_VALUE;
2293             }
2294         } else if (start &lt; direction) { // ascending
2295             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0)
2296             // then bitwise convert start to integer.
2297             final long transducer = Double.doubleToRawLongBits(start + 0.0d);
2298             return Double.longBitsToDouble(transducer + ((transducer &gt;= 0L) ? 1L : -1L));
2299         } else if (start == direction) {
2300             return direction;
2301         } else { // isNaN(start) || isNaN(direction)
2302             return start + direction;
2303         }
2304     }
2305 
2306     /**
2307      * Returns the floating-point number adjacent to the first
2308      * argument in the direction of the second argument.  If both
2309      * arguments compare as equal a value equivalent to the second argument
2310      * is returned.
2311      *
2312      * &lt;p&gt;
2313      * Special cases:
2314      * &lt;ul&gt;
2315      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
2316      *
2317      * &lt;li&gt; If both arguments are signed zeros, a value equivalent
2318      * to {@code direction} is returned.
2319      *
2320      * &lt;li&gt; If {@code start} is
2321      * &amp;plusmn;{@link Float#MIN_VALUE} and {@code direction}
2322      * has a value such that the result should have a smaller
2323      * magnitude, then a zero with the same sign as {@code start}
2324      * is returned.
2325      *
2326      * &lt;li&gt; If {@code start} is infinite and
2327      * {@code direction} has a value such that the result should
2328      * have a smaller magnitude, {@link Float#MAX_VALUE} with the
2329      * same sign as {@code start} is returned.
2330      *
2331      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
2332      * {@link Float#MAX_VALUE} and {@code direction} has a
2333      * value such that the result should have a larger magnitude, an
2334      * infinity with same sign as {@code start} is returned.
2335      * &lt;/ul&gt;
2336      *
2337      * @param start  starting floating-point value
2338      * @param direction value indicating which of
2339      * {@code start}&#39;s neighbors or {@code start} should
2340      * be returned
2341      * @return The floating-point number adjacent to {@code start} in the
2342      * direction of {@code direction}.
2343      * @since 1.6
2344      */
2345     public static float nextAfter(float start, double direction) {
2346         /*
2347          * The cases:
2348          *
2349          * nextAfter(+infinity, 0)  == MAX_VALUE
2350          * nextAfter(+infinity, +infinity)  == +infinity
2351          * nextAfter(-infinity, 0)  == -MAX_VALUE
2352          * nextAfter(-infinity, -infinity)  == -infinity
2353          *
2354          * are naturally handled without any additional testing
2355          */
2356 
2357         /*
2358          * IEEE 754 floating-point numbers are lexicographically
2359          * ordered if treated as signed-magnitude integers.
2360          * Since Java&#39;s integers are two&#39;s complement,
2361          * incrementing the two&#39;s complement representation of a
2362          * logically negative floating-point value *decrements*
2363          * the signed-magnitude representation. Therefore, when
2364          * the integer representation of a floating-point value
2365          * is negative, the adjustment to the representation is in
2366          * the opposite direction from what would initially be expected.
2367          */
2368 
2369         // Branch to descending case first as it is more costly than ascending
2370         // case due to start != 0.0f conditional.
2371         if (start &gt; direction) { // descending
2372             if (start != 0.0f) {
2373                 final int transducer = Float.floatToRawIntBits(start);
2374                 return Float.intBitsToFloat(transducer + ((transducer &gt; 0) ? -1 : 1));
2375             } else { // start == 0.0f &amp;&amp; direction &lt; 0.0f
2376                 return -Float.MIN_VALUE;
2377             }
2378         } else if (start &lt; direction) { // ascending
2379             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0)
2380             // then bitwise convert start to integer.
2381             final int transducer = Float.floatToRawIntBits(start + 0.0f);
2382             return Float.intBitsToFloat(transducer + ((transducer &gt;= 0) ? 1 : -1));
2383         } else if (start == direction) {
2384             return (float)direction;
2385         } else { // isNaN(start) || isNaN(direction)
2386             return start + (float)direction;
2387         }
2388     }
2389 
2390     /**
2391      * Returns the floating-point value adjacent to {@code d} in
2392      * the direction of positive infinity.  This method is
2393      * semantically equivalent to {@code nextAfter(d,
2394      * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}
2395      * implementation may run faster than its equivalent
2396      * {@code nextAfter} call.
2397      *
2398      * &lt;p&gt;Special Cases:
2399      * &lt;ul&gt;
2400      * &lt;li&gt; If the argument is NaN, the result is NaN.
2401      *
2402      * &lt;li&gt; If the argument is positive infinity, the result is
2403      * positive infinity.
2404      *
2405      * &lt;li&gt; If the argument is zero, the result is
2406      * {@link Double#MIN_VALUE}
2407      *
2408      * &lt;/ul&gt;
2409      *
2410      * @param d starting floating-point value
2411      * @return The adjacent floating-point value closer to positive
2412      * infinity.
2413      * @since 1.6
2414      */
2415     public static double nextUp(double d) {
2416         // Use a single conditional and handle the likely cases first.
2417         if (d &lt; Double.POSITIVE_INFINITY) {
2418             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0).
2419             final long transducer = Double.doubleToRawLongBits(d + 0.0D);
2420             return Double.longBitsToDouble(transducer + ((transducer &gt;= 0L) ? 1L : -1L));
2421         } else { // d is NaN or +Infinity
2422             return d;
2423         }
2424     }
2425 
2426     /**
2427      * Returns the floating-point value adjacent to {@code f} in
2428      * the direction of positive infinity.  This method is
2429      * semantically equivalent to {@code nextAfter(f,
2430      * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}
2431      * implementation may run faster than its equivalent
2432      * {@code nextAfter} call.
2433      *
2434      * &lt;p&gt;Special Cases:
2435      * &lt;ul&gt;
2436      * &lt;li&gt; If the argument is NaN, the result is NaN.
2437      *
2438      * &lt;li&gt; If the argument is positive infinity, the result is
2439      * positive infinity.
2440      *
2441      * &lt;li&gt; If the argument is zero, the result is
2442      * {@link Float#MIN_VALUE}
2443      *
2444      * &lt;/ul&gt;
2445      *
2446      * @param f starting floating-point value
2447      * @return The adjacent floating-point value closer to positive
2448      * infinity.
2449      * @since 1.6
2450      */
2451     public static float nextUp(float f) {
2452         // Use a single conditional and handle the likely cases first.
2453         if (f &lt; Float.POSITIVE_INFINITY) {
2454             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0).
2455             final int transducer = Float.floatToRawIntBits(f + 0.0F);
2456             return Float.intBitsToFloat(transducer + ((transducer &gt;= 0) ? 1 : -1));
2457         } else { // f is NaN or +Infinity
2458             return f;
2459         }
2460     }
2461 
2462     /**
2463      * Returns the floating-point value adjacent to {@code d} in
2464      * the direction of negative infinity.  This method is
2465      * semantically equivalent to {@code nextAfter(d,
2466      * Double.NEGATIVE_INFINITY)}; however, a
2467      * {@code nextDown} implementation may run faster than its
2468      * equivalent {@code nextAfter} call.
2469      *
2470      * &lt;p&gt;Special Cases:
2471      * &lt;ul&gt;
2472      * &lt;li&gt; If the argument is NaN, the result is NaN.
2473      *
2474      * &lt;li&gt; If the argument is negative infinity, the result is
2475      * negative infinity.
2476      *
2477      * &lt;li&gt; If the argument is zero, the result is
2478      * {@code -Double.MIN_VALUE}
2479      *
2480      * &lt;/ul&gt;
2481      *
2482      * @param d  starting floating-point value
2483      * @return The adjacent floating-point value closer to negative
2484      * infinity.
2485      * @since 1.8
2486      */
2487     public static double nextDown(double d) {
2488         if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY)
2489             return d;
2490         else {
2491             if (d == 0.0)
2492                 return -Double.MIN_VALUE;
2493             else
2494                 return Double.longBitsToDouble(Double.doubleToRawLongBits(d) +
2495                                                ((d &gt; 0.0d)?-1L:+1L));
2496         }
2497     }
2498 
2499     /**
2500      * Returns the floating-point value adjacent to {@code f} in
2501      * the direction of negative infinity.  This method is
2502      * semantically equivalent to {@code nextAfter(f,
2503      * Float.NEGATIVE_INFINITY)}; however, a
2504      * {@code nextDown} implementation may run faster than its
2505      * equivalent {@code nextAfter} call.
2506      *
2507      * &lt;p&gt;Special Cases:
2508      * &lt;ul&gt;
2509      * &lt;li&gt; If the argument is NaN, the result is NaN.
2510      *
2511      * &lt;li&gt; If the argument is negative infinity, the result is
2512      * negative infinity.
2513      *
2514      * &lt;li&gt; If the argument is zero, the result is
2515      * {@code -Float.MIN_VALUE}
2516      *
2517      * &lt;/ul&gt;
2518      *
2519      * @param f  starting floating-point value
2520      * @return The adjacent floating-point value closer to negative
2521      * infinity.
2522      * @since 1.8
2523      */
2524     public static float nextDown(float f) {
2525         if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY)
2526             return f;
2527         else {
2528             if (f == 0.0f)
2529                 return -Float.MIN_VALUE;
2530             else
2531                 return Float.intBitsToFloat(Float.floatToRawIntBits(f) +
2532                                             ((f &gt; 0.0f)?-1:+1));
2533         }
2534     }
2535 
2536     /**
2537      * Returns {@code d} &amp;times;
2538      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2539      * by a single correctly rounded floating-point multiply to a
2540      * member of the double value set.  See the Java
2541      * Language Specification for a discussion of floating-point
2542      * value sets.  If the exponent of the result is between {@link
2543      * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the
2544      * answer is calculated exactly.  If the exponent of the result
2545      * would be larger than {@code Double.MAX_EXPONENT}, an
2546      * infinity is returned.  Note that if the result is subnormal,
2547      * precision may be lost; that is, when {@code scalb(x, n)}
2548      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2549      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2550      * sign as {@code d}.
2551      *
2552      * &lt;p&gt;Special cases:
2553      * &lt;ul&gt;
2554      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2555      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2556      * same sign is returned.
2557      * &lt;li&gt; If the first argument is zero, then a zero of the same
2558      * sign is returned.
2559      * &lt;/ul&gt;
2560      *
2561      * @param d number to be scaled by a power of two.
2562      * @param scaleFactor power of 2 used to scale {@code d}
2563      * @return {@code d} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2564      * @since 1.6
2565      */
2566     public static double scalb(double d, int scaleFactor) {
2567         /*
2568          * This method does not need to be declared strictfp to
2569          * compute the same correct result on all platforms.  When
2570          * scaling up, it does not matter what order the
2571          * multiply-store operations are done; the result will be
2572          * finite or overflow regardless of the operation ordering.
2573          * However, to get the correct result when scaling down, a
2574          * particular ordering must be used.
2575          *
2576          * When scaling down, the multiply-store operations are
2577          * sequenced so that it is not possible for two consecutive
2578          * multiply-stores to return subnormal results.  If one
2579          * multiply-store result is subnormal, the next multiply will
2580          * round it away to zero.  This is done by first multiplying
2581          * by 2 ^ (scaleFactor % n) and then multiplying several
2582          * times by 2^n as needed where n is the exponent of number
2583          * that is a covenient power of two.  In this way, at most one
2584          * real rounding error occurs.  If the double value set is
2585          * being used exclusively, the rounding will occur on a
2586          * multiply.  If the double-extended-exponent value set is
2587          * being used, the products will (perhaps) be exact but the
2588          * stores to d are guaranteed to round to the double value
2589          * set.
2590          *
2591          * It is _not_ a valid implementation to first multiply d by
2592          * 2^MIN_EXPONENT and then by 2 ^ (scaleFactor %
2593          * MIN_EXPONENT) since even in a strictfp program double
2594          * rounding on underflow could occur; e.g. if the scaleFactor
2595          * argument was (MIN_EXPONENT - n) and the exponent of d was a
2596          * little less than -(MIN_EXPONENT - n), meaning the final
2597          * result would be subnormal.
2598          *
2599          * Since exact reproducibility of this method can be achieved
2600          * without any undue performance burden, there is no
2601          * compelling reason to allow double rounding on underflow in
2602          * scalb.
2603          */
2604 
2605         // magnitude of a power of two so large that scaling a finite
2606         // nonzero value by it would be guaranteed to over or
2607         // underflow; due to rounding, scaling down takes an
2608         // additional power of two which is reflected here
2609         final int MAX_SCALE = Double.MAX_EXPONENT + -Double.MIN_EXPONENT +
2610                               DoubleConsts.SIGNIFICAND_WIDTH + 1;
2611         int exp_adjust = 0;
2612         int scale_increment = 0;
2613         double exp_delta = Double.NaN;
2614 
2615         // Make sure scaling factor is in a reasonable range
2616 
2617         if(scaleFactor &lt; 0) {
2618             scaleFactor = Math.max(scaleFactor, -MAX_SCALE);
2619             scale_increment = -512;
2620             exp_delta = twoToTheDoubleScaleDown;
2621         }
2622         else {
2623             scaleFactor = Math.min(scaleFactor, MAX_SCALE);
2624             scale_increment = 512;
2625             exp_delta = twoToTheDoubleScaleUp;
2626         }
2627 
2628         // Calculate (scaleFactor % +/-512), 512 = 2^9, using
2629         // technique from &quot;Hacker&#39;s Delight&quot; section 10-2.
2630         int t = (scaleFactor &gt;&gt; 9-1) &gt;&gt;&gt; 32 - 9;
2631         exp_adjust = ((scaleFactor + t) &amp; (512 -1)) - t;
2632 
2633         d *= powerOfTwoD(exp_adjust);
2634         scaleFactor -= exp_adjust;
2635 
2636         while(scaleFactor != 0) {
2637             d *= exp_delta;
2638             scaleFactor -= scale_increment;
2639         }
2640         return d;
2641     }
2642 
2643     /**
2644      * Returns {@code f} &amp;times;
2645      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2646      * by a single correctly rounded floating-point multiply to a
2647      * member of the float value set.  See the Java
2648      * Language Specification for a discussion of floating-point
2649      * value sets.  If the exponent of the result is between {@link
2650      * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the
2651      * answer is calculated exactly.  If the exponent of the result
2652      * would be larger than {@code Float.MAX_EXPONENT}, an
2653      * infinity is returned.  Note that if the result is subnormal,
2654      * precision may be lost; that is, when {@code scalb(x, n)}
2655      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2656      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2657      * sign as {@code f}.
2658      *
2659      * &lt;p&gt;Special cases:
2660      * &lt;ul&gt;
2661      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2662      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2663      * same sign is returned.
2664      * &lt;li&gt; If the first argument is zero, then a zero of the same
2665      * sign is returned.
2666      * &lt;/ul&gt;
2667      *
2668      * @param f number to be scaled by a power of two.
2669      * @param scaleFactor power of 2 used to scale {@code f}
2670      * @return {@code f} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2671      * @since 1.6
2672      */
2673     public static float scalb(float f, int scaleFactor) {
2674         // magnitude of a power of two so large that scaling a finite
2675         // nonzero value by it would be guaranteed to over or
2676         // underflow; due to rounding, scaling down takes an
2677         // additional power of two which is reflected here
2678         final int MAX_SCALE = Float.MAX_EXPONENT + -Float.MIN_EXPONENT +
2679                               FloatConsts.SIGNIFICAND_WIDTH + 1;
2680 
2681         // Make sure scaling factor is in a reasonable range
2682         scaleFactor = Math.max(Math.min(scaleFactor, MAX_SCALE), -MAX_SCALE);
2683 
2684         /*
2685          * Since + MAX_SCALE for float fits well within the double
2686          * exponent range and + float -&gt; double conversion is exact
2687          * the multiplication below will be exact. Therefore, the
2688          * rounding that occurs when the double product is cast to
2689          * float will be the correctly rounded float result.  Since
2690          * all operations other than the final multiply will be exact,
2691          * it is not necessary to declare this method strictfp.
2692          */
2693         return (float)((double)f*powerOfTwoD(scaleFactor));
2694     }
2695 
2696     // Constants used in scalb
2697     static double twoToTheDoubleScaleUp = powerOfTwoD(512);
2698     static double twoToTheDoubleScaleDown = powerOfTwoD(-512);
2699 
2700     /**
2701      * Returns a floating-point power of two in the normal range.
2702      */
2703     static double powerOfTwoD(int n) {
2704         assert(n &gt;= Double.MIN_EXPONENT &amp;&amp; n &lt;= Double.MAX_EXPONENT);
2705         return Double.longBitsToDouble((((long)n + (long)DoubleConsts.EXP_BIAS) &lt;&lt;
2706                                         (DoubleConsts.SIGNIFICAND_WIDTH-1))
2707                                        &amp; DoubleConsts.EXP_BIT_MASK);
2708     }
2709 
2710     /**
2711      * Returns a floating-point power of two in the normal range.
2712      */
2713     static float powerOfTwoF(int n) {
2714         assert(n &gt;= Float.MIN_EXPONENT &amp;&amp; n &lt;= Float.MAX_EXPONENT);
2715         return Float.intBitsToFloat(((n + FloatConsts.EXP_BIAS) &lt;&lt;
2716                                      (FloatConsts.SIGNIFICAND_WIDTH-1))
2717                                     &amp; FloatConsts.EXP_BIT_MASK);
2718     }
2719 }
    </pre>
  </body>
</html>
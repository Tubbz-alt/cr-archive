<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 
<a name="1" id="anc1"></a><span class="line-removed">  38 import java.lang.invoke.MethodHandles;</span>
<span class="line-removed">  39 import java.lang.invoke.VarHandle;</span>
  40 import java.util.ArrayList;
  41 import java.util.Collection;
  42 import java.util.Date;
  43 import java.util.concurrent.TimeUnit;
<a name="2" id="anc2"></a><span class="line-modified">  44 import java.util.concurrent.locks.AbstractQueuedSynchronizer.Node;</span>

  45 
  46 /**
  47  * A version of {@link AbstractQueuedSynchronizer} in
  48  * which synchronization state is maintained as a {@code long}.
  49  * This class has exactly the same structure, properties, and methods
  50  * as {@code AbstractQueuedSynchronizer} with the exception
  51  * that all state-related parameters and results are defined
  52  * as {@code long} rather than {@code int}. This class
  53  * may be useful when creating synchronizers such as
  54  * multilevel locks and barriers that require
  55  * 64 bits of state.
  56  *
  57  * &lt;p&gt;See {@link AbstractQueuedSynchronizer} for usage
  58  * notes and examples.
  59  *
  60  * @since 1.6
  61  * @author Doug Lea
  62  */
  63 public abstract class AbstractQueuedLongSynchronizer
  64     extends AbstractOwnableSynchronizer
  65     implements java.io.Serializable {
  66 
  67     private static final long serialVersionUID = 7373984972572414692L;
  68 
  69     /*
  70      * To keep sources in sync, the remainder of this source file is
  71      * exactly cloned from AbstractQueuedSynchronizer, replacing class
  72      * name and changing ints related with sync state to longs. Please
  73      * keep it that way.
  74      */
  75 
<a name="3" id="anc3"></a><span class="line-modified">  76     /**</span>
<span class="line-modified">  77      * Creates a new {@code AbstractQueuedLongSynchronizer} instance</span>
<span class="line-modified">  78      * with initial synchronization state of zero.</span>
<span class="line-modified">  79      */</span>
<span class="line-modified">  80     protected AbstractQueuedLongSynchronizer() { }</span>

























































  81 
  82     /**
<a name="4" id="anc4"></a><span class="line-modified">  83      * Head of the wait queue, lazily initialized.  Except for</span>
<span class="line-removed">  84      * initialization, it is modified only via method setHead.  Note:</span>
<span class="line-removed">  85      * If head exists, its waitStatus is guaranteed not to be</span>
<span class="line-removed">  86      * CANCELLED.</span>
  87      */
  88     private transient volatile Node head;
  89 
  90     /**
<a name="5" id="anc5"></a><span class="line-modified">  91      * Tail of the wait queue, lazily initialized.  Modified only via</span>
<span class="line-removed">  92      * method enq to add new wait node.</span>
  93      */
  94     private transient volatile Node tail;
  95 
  96     /**
  97      * The synchronization state.
  98      */
  99     private volatile long state;
 100 
 101     /**
 102      * Returns the current value of synchronization state.
 103      * This operation has memory semantics of a {@code volatile} read.
 104      * @return current state value
 105      */
 106     protected final long getState() {
 107         return state;
 108     }
 109 
 110     /**
 111      * Sets the value of synchronization state.
 112      * This operation has memory semantics of a {@code volatile} write.
 113      * @param newState the new state value
 114      */
 115     protected final void setState(long newState) {
<a name="6" id="anc6"></a><span class="line-modified"> 116         // See JDK-8180620: Clarify VarHandle mixed-access subtleties</span>
<span class="line-removed"> 117         STATE.setVolatile(this, newState);</span>
 118     }
 119 
 120     /**
 121      * Atomically sets synchronization state to the given updated
 122      * value if the current state value equals the expected value.
 123      * This operation has memory semantics of a {@code volatile} read
 124      * and write.
 125      *
 126      * @param expect the expected value
 127      * @param update the new value
 128      * @return {@code true} if successful. False return indicates that the actual
 129      *         value was not equal to the expected value.
 130      */
 131     protected final boolean compareAndSetState(long expect, long update) {
<a name="7" id="anc7"></a><span class="line-modified"> 132         return STATE.compareAndSet(this, expect, update);</span>
 133     }
 134 
 135     // Queuing utilities
 136 
<a name="8" id="anc8"></a><span class="line-modified"> 137     /**</span>
<span class="line-modified"> 138      * The number of nanoseconds for which it is faster to spin</span>
<span class="line-removed"> 139      * rather than to use timed park. A rough estimate suffices</span>
<span class="line-removed"> 140      * to improve responsiveness with very short timeouts.</span>
<span class="line-removed"> 141      */</span>
<span class="line-removed"> 142     static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1000L;</span>
<span class="line-removed"> 143 </span>
<span class="line-removed"> 144     /**</span>
<span class="line-removed"> 145      * Inserts node into queue, initializing if necessary. See picture above.</span>
<span class="line-removed"> 146      * @param node the node to insert</span>
<span class="line-removed"> 147      * @return node&#39;s predecessor</span>
<span class="line-removed"> 148      */</span>
<span class="line-removed"> 149     private Node enq(Node node) {</span>
<span class="line-removed"> 150         for (;;) {</span>
<span class="line-removed"> 151             Node oldTail = tail;</span>
<span class="line-removed"> 152             if (oldTail != null) {</span>
<span class="line-removed"> 153                 node.setPrevRelaxed(oldTail);</span>
<span class="line-removed"> 154                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="line-removed"> 155                     oldTail.next = node;</span>
<span class="line-removed"> 156                     return oldTail;</span>
<span class="line-removed"> 157                 }</span>
<span class="line-removed"> 158             } else {</span>
<span class="line-removed"> 159                 initializeSyncQueue();</span>
<span class="line-removed"> 160             }</span>
<span class="line-removed"> 161         }</span>
<span class="line-removed"> 162     }</span>
<span class="line-removed"> 163 </span>
<span class="line-removed"> 164     /**</span>
<span class="line-removed"> 165      * Creates and enqueues node for current thread and given mode.</span>
<span class="line-removed"> 166      *</span>
<span class="line-removed"> 167      * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span>
<span class="line-removed"> 168      * @return the new node</span>
<span class="line-removed"> 169      */</span>
<span class="line-removed"> 170     private Node addWaiter(Node mode) {</span>
<span class="line-removed"> 171         Node node = new Node(mode);</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173         for (;;) {</span>
<span class="line-removed"> 174             Node oldTail = tail;</span>
<span class="line-removed"> 175             if (oldTail != null) {</span>
<span class="line-removed"> 176                 node.setPrevRelaxed(oldTail);</span>
<span class="line-removed"> 177                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="line-removed"> 178                     oldTail.next = node;</span>
<span class="line-removed"> 179                     return node;</span>
<span class="line-removed"> 180                 }</span>
<span class="line-removed"> 181             } else {</span>
<span class="line-removed"> 182                 initializeSyncQueue();</span>
<span class="line-removed"> 183             }</span>
<span class="line-removed"> 184         }</span>
<span class="line-removed"> 185     }</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187     /**</span>
<span class="line-removed"> 188      * Sets head of queue to be node, thus dequeuing. Called only by</span>
<span class="line-removed"> 189      * acquire methods.  Also nulls out unused fields for sake of GC</span>
<span class="line-removed"> 190      * and to suppress unnecessary signals and traversals.</span>
<span class="line-removed"> 191      *</span>
<span class="line-removed"> 192      * @param node the node</span>
<span class="line-removed"> 193      */</span>
<span class="line-removed"> 194     private void setHead(Node node) {</span>
<span class="line-removed"> 195         head = node;</span>
<span class="line-removed"> 196         node.thread = null;</span>
<span class="line-removed"> 197         node.prev = null;</span>
 198     }
 199 
<a name="9" id="anc9"></a><span class="line-modified"> 200     /**</span>
<span class="line-modified"> 201      * Wakes up node&#39;s successor, if one exists.</span>
<span class="line-modified"> 202      *</span>
<span class="line-modified"> 203      * @param node the node</span>
<span class="line-modified"> 204      */</span>
<span class="line-removed"> 205     private void unparkSuccessor(Node node) {</span>
<span class="line-removed"> 206         /*</span>
<span class="line-removed"> 207          * If status is negative (i.e., possibly needing signal) try</span>
<span class="line-removed"> 208          * to clear in anticipation of signalling.  It is OK if this</span>
<span class="line-removed"> 209          * fails or if status is changed by waiting thread.</span>
<span class="line-removed"> 210          */</span>
<span class="line-removed"> 211         int ws = node.waitStatus;</span>
<span class="line-removed"> 212         if (ws &lt; 0)</span>
<span class="line-removed"> 213             node.compareAndSetWaitStatus(ws, 0);</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215         /*</span>
<span class="line-removed"> 216          * Thread to unpark is held in successor, which is normally</span>
<span class="line-removed"> 217          * just the next node.  But if cancelled or apparently null,</span>
<span class="line-removed"> 218          * traverse backwards from tail to find the actual</span>
<span class="line-removed"> 219          * non-cancelled successor.</span>
<span class="line-removed"> 220          */</span>
<span class="line-removed"> 221         Node s = node.next;</span>
<span class="line-removed"> 222         if (s == null || s.waitStatus &gt; 0) {</span>
<span class="line-removed"> 223             s = null;</span>
<span class="line-removed"> 224             for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span>
<span class="line-removed"> 225                 if (p.waitStatus &lt;= 0)</span>
<span class="line-removed"> 226                     s = p;</span>
<span class="line-removed"> 227         }</span>
<span class="line-removed"> 228         if (s != null)</span>
<span class="line-removed"> 229             LockSupport.unpark(s.thread);</span>
 230     }
 231 
 232     /**
<a name="10" id="anc10"></a><span class="line-modified"> 233      * Release action for shared mode -- signals successor and ensures</span>
<span class="line-modified"> 234      * propagation. (Note: For exclusive mode, release just amounts</span>
<span class="line-removed"> 235      * to calling unparkSuccessor of head if it needs signal.)</span>
 236      */
<a name="11" id="anc11"></a><span class="line-modified"> 237     private void doReleaseShared() {</span>
<span class="line-modified"> 238         /*</span>
<span class="line-modified"> 239          * Ensure that a release propagates, even if there are other</span>
<span class="line-modified"> 240          * in-progress acquires/releases.  This proceeds in the usual</span>
<span class="line-modified"> 241          * way of trying to unparkSuccessor of head if it needs</span>
<span class="line-modified"> 242          * signal. But if it does not, status is set to PROPAGATE to</span>
<span class="line-modified"> 243          * ensure that upon release, propagation continues.</span>
<span class="line-modified"> 244          * Additionally, we must loop in case a new node is added</span>
<span class="line-modified"> 245          * while we are doing this. Also, unlike other uses of</span>
<span class="line-modified"> 246          * unparkSuccessor, we need to know if CAS to reset status</span>
<span class="line-modified"> 247          * fails, if so rechecking.</span>
<span class="line-modified"> 248          */</span>
<span class="line-removed"> 249         for (;;) {</span>
<span class="line-removed"> 250             Node h = head;</span>
<span class="line-removed"> 251             if (h != null &amp;&amp; h != tail) {</span>
<span class="line-removed"> 252                 int ws = h.waitStatus;</span>
<span class="line-removed"> 253                 if (ws == Node.SIGNAL) {</span>
<span class="line-removed"> 254                     if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))</span>
<span class="line-removed"> 255                         continue;            // loop to recheck cases</span>
<span class="line-removed"> 256                     unparkSuccessor(h);</span>
 257                 }
<a name="12" id="anc12"></a><span class="line-removed"> 258                 else if (ws == 0 &amp;&amp;</span>
<span class="line-removed"> 259                          !h.compareAndSetWaitStatus(0, Node.PROPAGATE))</span>
<span class="line-removed"> 260                     continue;                // loop on failed CAS</span>
 261             }
<a name="13" id="anc13"></a><span class="line-removed"> 262             if (h == head)                   // loop if head changed</span>
<span class="line-removed"> 263                 break;</span>
 264         }
 265     }
 266 
<a name="14" id="anc14"></a><span class="line-modified"> 267     /**</span>
<span class="line-modified"> 268      * Sets head of queue, and checks if successor may be waiting</span>
<span class="line-modified"> 269      * in shared mode, if so propagating if either propagate &gt; 0 or</span>
<span class="line-modified"> 270      * PROPAGATE status was set.</span>
<span class="line-modified"> 271      *</span>
<span class="line-modified"> 272      * @param node the node</span>
<span class="line-removed"> 273      * @param propagate the return value from a tryAcquireShared</span>
<span class="line-removed"> 274      */</span>
<span class="line-removed"> 275     private void setHeadAndPropagate(Node node, long propagate) {</span>
<span class="line-removed"> 276         Node h = head; // Record old head for check below</span>
<span class="line-removed"> 277         setHead(node);</span>
<span class="line-removed"> 278         /*</span>
<span class="line-removed"> 279          * Try to signal next queued node if:</span>
<span class="line-removed"> 280          *   Propagation was indicated by caller,</span>
<span class="line-removed"> 281          *     or was recorded (as h.waitStatus either before</span>
<span class="line-removed"> 282          *     or after setHead) by a previous operation</span>
<span class="line-removed"> 283          *     (note: this uses sign-check of waitStatus because</span>
<span class="line-removed"> 284          *      PROPAGATE status may transition to SIGNAL.)</span>
<span class="line-removed"> 285          * and</span>
<span class="line-removed"> 286          *   The next node is waiting in shared mode,</span>
<span class="line-removed"> 287          *     or we don&#39;t know, because it appears null</span>
<span class="line-removed"> 288          *</span>
<span class="line-removed"> 289          * The conservatism in both of these checks may cause</span>
<span class="line-removed"> 290          * unnecessary wake-ups, but only when there are multiple</span>
<span class="line-removed"> 291          * racing acquires/releases, so most need signals now or soon</span>
<span class="line-removed"> 292          * anyway.</span>
<span class="line-removed"> 293          */</span>
<span class="line-removed"> 294         if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span>
<span class="line-removed"> 295             (h = head) == null || h.waitStatus &lt; 0) {</span>
<span class="line-removed"> 296             Node s = node.next;</span>
<span class="line-removed"> 297             if (s == null || s.isShared())</span>
<span class="line-removed"> 298                 doReleaseShared();</span>
<span class="line-removed"> 299         }</span>
 300     }
 301 
<a name="15" id="anc15"></a><span class="line-removed"> 302     // Utilities for various versions of acquire</span>
<span class="line-removed"> 303 </span>
 304     /**
<a name="16" id="anc16"></a><span class="line-modified"> 305      * Cancels an ongoing attempt to acquire.</span>
<span class="line-modified"> 306      *</span>
<span class="line-modified"> 307      * @param node the node</span>

 308      */
<a name="17" id="anc17"></a><span class="line-modified"> 309     private void cancelAcquire(Node node) {</span>
<span class="line-modified"> 310         // Ignore if node doesn&#39;t exist</span>
<span class="line-modified"> 311         if (node == null)</span>
<span class="line-modified"> 312             return;</span>
<span class="line-modified"> 313 </span>
<span class="line-removed"> 314         node.thread = null;</span>
<span class="line-removed"> 315 </span>
<span class="line-removed"> 316         // Skip cancelled predecessors</span>
<span class="line-removed"> 317         Node pred = node.prev;</span>
<span class="line-removed"> 318         while (pred.waitStatus &gt; 0)</span>
<span class="line-removed"> 319             node.prev = pred = pred.prev;</span>
<span class="line-removed"> 320 </span>
<span class="line-removed"> 321         // predNext is the apparent node to unsplice. CASes below will</span>
<span class="line-removed"> 322         // fail if not, in which case, we lost race vs another cancel</span>
<span class="line-removed"> 323         // or signal, so no further action is necessary, although with</span>
<span class="line-removed"> 324         // a possibility that a cancelled node may transiently remain</span>
<span class="line-removed"> 325         // reachable.</span>
<span class="line-removed"> 326         Node predNext = pred.next;</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328         // Can use unconditional write instead of CAS here.</span>
<span class="line-removed"> 329         // After this atomic step, other Nodes can skip past us.</span>
<span class="line-removed"> 330         // Before, we are free of interference from other threads.</span>
<span class="line-removed"> 331         node.waitStatus = Node.CANCELLED;</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333         // If we are the tail, remove ourselves.</span>
<span class="line-removed"> 334         if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span>
<span class="line-removed"> 335             pred.compareAndSetNext(predNext, null);</span>
<span class="line-removed"> 336         } else {</span>
<span class="line-removed"> 337             // If successor needs signal, try to set pred&#39;s next-link</span>
<span class="line-removed"> 338             // so it will get one. Otherwise wake it up to propagate.</span>
<span class="line-removed"> 339             int ws;</span>
<span class="line-removed"> 340             if (pred != head &amp;&amp;</span>
<span class="line-removed"> 341                 ((ws = pred.waitStatus) == Node.SIGNAL ||</span>
<span class="line-removed"> 342                  (ws &lt;= 0 &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span>
<span class="line-removed"> 343                 pred.thread != null) {</span>
<span class="line-removed"> 344                 Node next = node.next;</span>
<span class="line-removed"> 345                 if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span>
<span class="line-removed"> 346                     pred.compareAndSetNext(predNext, next);</span>
<span class="line-removed"> 347             } else {</span>
<span class="line-removed"> 348                 unparkSuccessor(node);</span>
<span class="line-removed"> 349             }</span>
<span class="line-removed"> 350 </span>
<span class="line-removed"> 351             node.next = node; // help GC</span>
 352         }
 353     }
 354 
<a name="18" id="anc18"></a><span class="line-modified"> 355     /**</span>
<span class="line-modified"> 356      * Checks and updates status for a node that failed to acquire.</span>
<span class="line-modified"> 357      * Returns true if thread should block. This is the main signal</span>
<span class="line-modified"> 358      * control in all acquire loops.  Requires that pred == node.prev.</span>
<span class="line-modified"> 359      *</span>
<span class="line-modified"> 360      * @param pred node&#39;s predecessor holding status</span>
<span class="line-modified"> 361      * @param node the node</span>
<span class="line-removed"> 362      * @return {@code true} if thread should block</span>
<span class="line-removed"> 363      */</span>
<span class="line-removed"> 364     private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</span>
<span class="line-removed"> 365         int ws = pred.waitStatus;</span>
<span class="line-removed"> 366         if (ws == Node.SIGNAL)</span>
<span class="line-removed"> 367             /*</span>
<span class="line-removed"> 368              * This node has already set status asking a release</span>
<span class="line-removed"> 369              * to signal it, so it can safely park.</span>
<span class="line-removed"> 370              */</span>
<span class="line-removed"> 371             return true;</span>
<span class="line-removed"> 372         if (ws &gt; 0) {</span>
<span class="line-removed"> 373             /*</span>
<span class="line-removed"> 374              * Predecessor was cancelled. Skip over predecessors and</span>
<span class="line-removed"> 375              * indicate retry.</span>
<span class="line-removed"> 376              */</span>
<span class="line-removed"> 377             do {</span>
<span class="line-removed"> 378                 node.prev = pred = pred.prev;</span>
<span class="line-removed"> 379             } while (pred.waitStatus &gt; 0);</span>
<span class="line-removed"> 380             pred.next = node;</span>
<span class="line-removed"> 381         } else {</span>
<span class="line-removed"> 382             /*</span>
<span class="line-removed"> 383              * waitStatus must be 0 or PROPAGATE.  Indicate that we</span>
<span class="line-removed"> 384              * need a signal, but don&#39;t park yet.  Caller will need to</span>
<span class="line-removed"> 385              * retry to make sure it cannot acquire before parking.</span>
<span class="line-removed"> 386              */</span>
<span class="line-removed"> 387             pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span>
 388         }
<a name="19" id="anc19"></a><span class="line-removed"> 389         return false;</span>
<span class="line-removed"> 390     }</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392     /**</span>
<span class="line-removed"> 393      * Convenience method to interrupt current thread.</span>
<span class="line-removed"> 394      */</span>
<span class="line-removed"> 395     static void selfInterrupt() {</span>
<span class="line-removed"> 396         Thread.currentThread().interrupt();</span>
 397     }
 398 
 399     /**
<a name="20" id="anc20"></a><span class="line-modified"> 400      * Convenience method to park and then check if interrupted.</span>
<span class="line-removed"> 401      *</span>
<span class="line-removed"> 402      * @return {@code true} if interrupted</span>
<span class="line-removed"> 403      */</span>
<span class="line-removed"> 404     private final boolean parkAndCheckInterrupt() {</span>
<span class="line-removed"> 405         LockSupport.park(this);</span>
<span class="line-removed"> 406         return Thread.interrupted();</span>
<span class="line-removed"> 407     }</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409     /*</span>
<span class="line-removed"> 410      * Various flavors of acquire, varying in exclusive/shared and</span>
<span class="line-removed"> 411      * control modes.  Each is mostly the same, but annoyingly</span>
<span class="line-removed"> 412      * different.  Only a little bit of factoring is possible due to</span>
<span class="line-removed"> 413      * interactions of exception mechanics (including ensuring that we</span>
<span class="line-removed"> 414      * cancel if tryAcquire throws exception) and other control, at</span>
<span class="line-removed"> 415      * least not without hurting performance too much.</span>
<span class="line-removed"> 416      */</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418     /**</span>
<span class="line-removed"> 419      * Acquires in exclusive uninterruptible mode for thread already in</span>
<span class="line-removed"> 420      * queue. Used by condition wait methods as well as acquire.</span>
 421      *
<a name="21" id="anc21"></a><span class="line-modified"> 422      * @param node the node</span>
 423      * @param arg the acquire argument
<a name="22" id="anc22"></a><span class="line-modified"> 424      * @return {@code true} if interrupted while waiting</span>




 425      */
<a name="23" id="anc23"></a><span class="line-modified"> 426     final boolean acquireQueued(final Node node, long arg) {</span>
<span class="line-modified"> 427         boolean interrupted = false;</span>
<span class="line-modified"> 428         try {</span>
<span class="line-modified"> 429             for (;;) {</span>
<span class="line-modified"> 430                 final Node p = node.predecessor();</span>
<span class="line-modified"> 431                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-removed"> 432                     setHead(node);</span>
<span class="line-removed"> 433                     p.next = null; // help GC</span>
<span class="line-removed"> 434                     return interrupted;</span>
<span class="line-removed"> 435                 }</span>
<span class="line-removed"> 436                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="line-removed"> 437                     interrupted |= parkAndCheckInterrupt();</span>
<span class="line-removed"> 438             }</span>
<span class="line-removed"> 439         } catch (Throwable t) {</span>
<span class="line-removed"> 440             cancelAcquire(node);</span>
<span class="line-removed"> 441             if (interrupted)</span>
<span class="line-removed"> 442                 selfInterrupt();</span>
<span class="line-removed"> 443             throw t;</span>
<span class="line-removed"> 444         }</span>
<span class="line-removed"> 445     }</span>
 446 
<a name="24" id="anc24"></a><span class="line-modified"> 447     /**</span>
<span class="line-modified"> 448      * Acquires in exclusive interruptible mode.</span>
<span class="line-modified"> 449      * @param arg the acquire argument</span>
<span class="line-modified"> 450      */</span>
<span class="line-modified"> 451     private void doAcquireInterruptibly(long arg)</span>
<span class="line-modified"> 452         throws InterruptedException {</span>
<span class="line-modified"> 453         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="line-modified"> 454         try {</span>
<span class="line-modified"> 455             for (;;) {</span>
<span class="line-modified"> 456                 final Node p = node.predecessor();</span>
<span class="line-modified"> 457                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-modified"> 458                     setHead(node);</span>
<span class="line-modified"> 459                     p.next = null; // help GC</span>
<span class="line-modified"> 460                     return;</span>







 461                 }
<a name="25" id="anc25"></a><span class="line-removed"> 462                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 463                     parkAndCheckInterrupt())</span>
<span class="line-removed"> 464                     throw new InterruptedException();</span>
 465             }
<a name="26" id="anc26"></a><span class="line-modified"> 466         } catch (Throwable t) {</span>
<span class="line-modified"> 467             cancelAcquire(node);</span>
<span class="line-modified"> 468             throw t;</span>
<span class="line-modified"> 469         }</span>
<span class="line-modified"> 470     }</span>
<span class="line-modified"> 471 </span>
<span class="line-modified"> 472     /**</span>
<span class="line-modified"> 473      * Acquires in exclusive timed mode.</span>
<span class="line-modified"> 474      *</span>
<span class="line-modified"> 475      * @param arg the acquire argument</span>
<span class="line-removed"> 476      * @param nanosTimeout max wait time</span>
<span class="line-removed"> 477      * @return {@code true} if acquired</span>
<span class="line-removed"> 478      */</span>
<span class="line-removed"> 479     private boolean doAcquireNanos(long arg, long nanosTimeout)</span>
<span class="line-removed"> 480             throws InterruptedException {</span>
<span class="line-removed"> 481         if (nanosTimeout &lt;= 0L)</span>
<span class="line-removed"> 482             return false;</span>
<span class="line-removed"> 483         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-removed"> 484         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="line-removed"> 485         try {</span>
<span class="line-removed"> 486             for (;;) {</span>
<span class="line-removed"> 487                 final Node p = node.predecessor();</span>
<span class="line-removed"> 488                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-removed"> 489                     setHead(node);</span>
<span class="line-removed"> 490                     p.next = null; // help GC</span>
<span class="line-removed"> 491                     return true;</span>
 492                 }
<a name="27" id="anc27"></a><span class="line-modified"> 493                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="line-modified"> 494                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified"> 495                     cancelAcquire(node);</span>
<span class="line-modified"> 496                     return false;</span>








 497                 }
<a name="28" id="anc28"></a><span class="line-removed"> 498                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 499                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed"> 500                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed"> 501                 if (Thread.interrupted())</span>
<span class="line-removed"> 502                     throw new InterruptedException();</span>
 503             }
<a name="29" id="anc29"></a><span class="line-modified"> 504         } catch (Throwable t) {</span>
<span class="line-modified"> 505             cancelAcquire(node);</span>
<span class="line-modified"> 506             throw t;</span>






























 507         }
<a name="30" id="anc30"></a>
 508     }
 509 
 510     /**
<a name="31" id="anc31"></a><span class="line-modified"> 511      * Acquires in shared uninterruptible mode.</span>
<span class="line-modified"> 512      * @param arg the acquire argument</span>
 513      */
<a name="32" id="anc32"></a><span class="line-modified"> 514     private void doAcquireShared(long arg) {</span>
<span class="line-modified"> 515         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-modified"> 516         boolean interrupted = false;</span>
<span class="line-modified"> 517         try {</span>
<span class="line-modified"> 518             for (;;) {</span>
<span class="line-modified"> 519                 final Node p = node.predecessor();</span>
<span class="line-modified"> 520                 if (p == head) {</span>
<span class="line-modified"> 521                     long r = tryAcquireShared(arg);</span>
<span class="line-modified"> 522                     if (r &gt;= 0) {</span>
<span class="line-modified"> 523                         setHeadAndPropagate(node, r);</span>
<span class="line-modified"> 524                         p.next = null; // help GC</span>
<span class="line-modified"> 525                         return;</span>

 526                     }
<a name="33" id="anc33"></a>
 527                 }
<a name="34" id="anc34"></a><span class="line-modified"> 528                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="line-modified"> 529                     interrupted |= parkAndCheckInterrupt();</span>
<span class="line-modified"> 530             }</span>
<span class="line-modified"> 531         } catch (Throwable t) {</span>
<span class="line-modified"> 532             cancelAcquire(node);</span>
<span class="line-removed"> 533             throw t;</span>
<span class="line-removed"> 534         } finally {</span>
<span class="line-removed"> 535             if (interrupted)</span>
<span class="line-removed"> 536                 selfInterrupt();</span>
<span class="line-removed"> 537         }</span>
<span class="line-removed"> 538     }</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540     /**</span>
<span class="line-removed"> 541      * Acquires in shared interruptible mode.</span>
<span class="line-removed"> 542      * @param arg the acquire argument</span>
<span class="line-removed"> 543      */</span>
<span class="line-removed"> 544     private void doAcquireSharedInterruptibly(long arg)</span>
<span class="line-removed"> 545         throws InterruptedException {</span>
<span class="line-removed"> 546         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-removed"> 547         try {</span>
<span class="line-removed"> 548             for (;;) {</span>
<span class="line-removed"> 549                 final Node p = node.predecessor();</span>
<span class="line-removed"> 550                 if (p == head) {</span>
<span class="line-removed"> 551                     long r = tryAcquireShared(arg);</span>
<span class="line-removed"> 552                     if (r &gt;= 0) {</span>
<span class="line-removed"> 553                         setHeadAndPropagate(node, r);</span>
<span class="line-removed"> 554                         p.next = null; // help GC</span>
<span class="line-removed"> 555                         return;</span>
 556                     }
<a name="35" id="anc35"></a>
 557                 }
<a name="36" id="anc36"></a><span class="line-modified"> 558                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-modified"> 559                     parkAndCheckInterrupt())</span>
<span class="line-removed"> 560                     throw new InterruptedException();</span>
 561             }
<a name="37" id="anc37"></a><span class="line-removed"> 562         } catch (Throwable t) {</span>
<span class="line-removed"> 563             cancelAcquire(node);</span>
<span class="line-removed"> 564             throw t;</span>
 565         }
 566     }
 567 
 568     /**
<a name="38" id="anc38"></a><span class="line-modified"> 569      * Acquires in shared timed mode.</span>
 570      *
<a name="39" id="anc39"></a><span class="line-modified"> 571      * @param arg the acquire argument</span>
<span class="line-modified"> 572      * @param nanosTimeout max wait time</span>
<span class="line-modified"> 573      * @return {@code true} if acquired</span>
 574      */
<a name="40" id="anc40"></a><span class="line-modified"> 575     private boolean doAcquireSharedNanos(long arg, long nanosTimeout)</span>
<span class="line-modified"> 576             throws InterruptedException {</span>
<span class="line-modified"> 577         if (nanosTimeout &lt;= 0L)</span>
<span class="line-modified"> 578             return false;</span>
<span class="line-modified"> 579         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified"> 580         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-modified"> 581         try {</span>
<span class="line-modified"> 582             for (;;) {</span>
<span class="line-modified"> 583                 final Node p = node.predecessor();</span>
<span class="line-modified"> 584                 if (p == head) {</span>
<span class="line-modified"> 585                     long r = tryAcquireShared(arg);</span>
<span class="line-modified"> 586                     if (r &gt;= 0) {</span>
<span class="line-modified"> 587                         setHeadAndPropagate(node, r);</span>
<span class="line-removed"> 588                         p.next = null; // help GC</span>
<span class="line-removed"> 589                         return true;</span>
<span class="line-removed"> 590                     }</span>
<span class="line-removed"> 591                 }</span>
<span class="line-removed"> 592                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="line-removed"> 593                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-removed"> 594                     cancelAcquire(node);</span>
<span class="line-removed"> 595                     return false;</span>
<span class="line-removed"> 596                 }</span>
<span class="line-removed"> 597                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 598                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed"> 599                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed"> 600                 if (Thread.interrupted())</span>
<span class="line-removed"> 601                     throw new InterruptedException();</span>
<span class="line-removed"> 602             }</span>
<span class="line-removed"> 603         } catch (Throwable t) {</span>
<span class="line-removed"> 604             cancelAcquire(node);</span>
<span class="line-removed"> 605             throw t;</span>
 606         }
<a name="41" id="anc41"></a>
 607     }
 608 
 609     // Main exported methods
 610 
 611     /**
 612      * Attempts to acquire in exclusive mode. This method should query
 613      * if the state of the object permits it to be acquired in the
 614      * exclusive mode, and if so to acquire it.
 615      *
 616      * &lt;p&gt;This method is always invoked by the thread performing
 617      * acquire.  If this method reports failure, the acquire method
 618      * may queue the thread, if it is not already queued, until it is
 619      * signalled by a release from some other thread. This can be used
 620      * to implement method {@link Lock#tryLock()}.
 621      *
 622      * &lt;p&gt;The default
 623      * implementation throws {@link UnsupportedOperationException}.
 624      *
 625      * @param arg the acquire argument. This value is always the one
 626      *        passed to an acquire method, or is the value saved on entry
 627      *        to a condition wait.  The value is otherwise uninterpreted
 628      *        and can represent anything you like.
 629      * @return {@code true} if successful. Upon success, this object has
 630      *         been acquired.
 631      * @throws IllegalMonitorStateException if acquiring would place this
 632      *         synchronizer in an illegal state. This exception must be
 633      *         thrown in a consistent fashion for synchronization to work
 634      *         correctly.
 635      * @throws UnsupportedOperationException if exclusive mode is not supported
 636      */
 637     protected boolean tryAcquire(long arg) {
 638         throw new UnsupportedOperationException();
 639     }
 640 
 641     /**
 642      * Attempts to set the state to reflect a release in exclusive
 643      * mode.
 644      *
 645      * &lt;p&gt;This method is always invoked by the thread performing release.
 646      *
 647      * &lt;p&gt;The default implementation throws
 648      * {@link UnsupportedOperationException}.
 649      *
 650      * @param arg the release argument. This value is always the one
 651      *        passed to a release method, or the current state value upon
 652      *        entry to a condition wait.  The value is otherwise
 653      *        uninterpreted and can represent anything you like.
 654      * @return {@code true} if this object is now in a fully released
 655      *         state, so that any waiting threads may attempt to acquire;
 656      *         and {@code false} otherwise.
 657      * @throws IllegalMonitorStateException if releasing would place this
 658      *         synchronizer in an illegal state. This exception must be
 659      *         thrown in a consistent fashion for synchronization to work
 660      *         correctly.
 661      * @throws UnsupportedOperationException if exclusive mode is not supported
 662      */
 663     protected boolean tryRelease(long arg) {
 664         throw new UnsupportedOperationException();
 665     }
 666 
 667     /**
 668      * Attempts to acquire in shared mode. This method should query if
 669      * the state of the object permits it to be acquired in the shared
 670      * mode, and if so to acquire it.
 671      *
 672      * &lt;p&gt;This method is always invoked by the thread performing
 673      * acquire.  If this method reports failure, the acquire method
 674      * may queue the thread, if it is not already queued, until it is
 675      * signalled by a release from some other thread.
 676      *
 677      * &lt;p&gt;The default implementation throws {@link
 678      * UnsupportedOperationException}.
 679      *
 680      * @param arg the acquire argument. This value is always the one
 681      *        passed to an acquire method, or is the value saved on entry
 682      *        to a condition wait.  The value is otherwise uninterpreted
 683      *        and can represent anything you like.
 684      * @return a negative value on failure; zero if acquisition in shared
 685      *         mode succeeded but no subsequent shared-mode acquire can
 686      *         succeed; and a positive value if acquisition in shared
 687      *         mode succeeded and subsequent shared-mode acquires might
 688      *         also succeed, in which case a subsequent waiting thread
 689      *         must check availability. (Support for three different
 690      *         return values enables this method to be used in contexts
 691      *         where acquires only sometimes act exclusively.)  Upon
 692      *         success, this object has been acquired.
 693      * @throws IllegalMonitorStateException if acquiring would place this
 694      *         synchronizer in an illegal state. This exception must be
 695      *         thrown in a consistent fashion for synchronization to work
 696      *         correctly.
 697      * @throws UnsupportedOperationException if shared mode is not supported
 698      */
 699     protected long tryAcquireShared(long arg) {
 700         throw new UnsupportedOperationException();
 701     }
 702 
 703     /**
 704      * Attempts to set the state to reflect a release in shared mode.
 705      *
 706      * &lt;p&gt;This method is always invoked by the thread performing release.
 707      *
 708      * &lt;p&gt;The default implementation throws
 709      * {@link UnsupportedOperationException}.
 710      *
 711      * @param arg the release argument. This value is always the one
 712      *        passed to a release method, or the current state value upon
 713      *        entry to a condition wait.  The value is otherwise
 714      *        uninterpreted and can represent anything you like.
 715      * @return {@code true} if this release of shared mode may permit a
 716      *         waiting acquire (shared or exclusive) to succeed; and
 717      *         {@code false} otherwise
 718      * @throws IllegalMonitorStateException if releasing would place this
 719      *         synchronizer in an illegal state. This exception must be
 720      *         thrown in a consistent fashion for synchronization to work
 721      *         correctly.
 722      * @throws UnsupportedOperationException if shared mode is not supported
 723      */
 724     protected boolean tryReleaseShared(long arg) {
 725         throw new UnsupportedOperationException();
 726     }
 727 
 728     /**
 729      * Returns {@code true} if synchronization is held exclusively with
 730      * respect to the current (calling) thread.  This method is invoked
 731      * upon each call to a {@link ConditionObject} method.
 732      *
 733      * &lt;p&gt;The default implementation throws {@link
 734      * UnsupportedOperationException}. This method is invoked
 735      * internally only within {@link ConditionObject} methods, so need
 736      * not be defined if conditions are not used.
 737      *
 738      * @return {@code true} if synchronization is held exclusively;
 739      *         {@code false} otherwise
 740      * @throws UnsupportedOperationException if conditions are not supported
 741      */
 742     protected boolean isHeldExclusively() {
 743         throw new UnsupportedOperationException();
 744     }
 745 
 746     /**
 747      * Acquires in exclusive mode, ignoring interrupts.  Implemented
 748      * by invoking at least once {@link #tryAcquire},
 749      * returning on success.  Otherwise the thread is queued, possibly
 750      * repeatedly blocking and unblocking, invoking {@link
 751      * #tryAcquire} until success.  This method can be used
 752      * to implement method {@link Lock#lock}.
 753      *
 754      * @param arg the acquire argument.  This value is conveyed to
 755      *        {@link #tryAcquire} but is otherwise uninterpreted and
 756      *        can represent anything you like.
 757      */
 758     public final void acquire(long arg) {
<a name="42" id="anc42"></a><span class="line-modified"> 759         if (!tryAcquire(arg) &amp;&amp;</span>
<span class="line-modified"> 760             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span>
<span class="line-removed"> 761             selfInterrupt();</span>
 762     }
 763 
 764     /**
 765      * Acquires in exclusive mode, aborting if interrupted.
 766      * Implemented by first checking interrupt status, then invoking
 767      * at least once {@link #tryAcquire}, returning on
 768      * success.  Otherwise the thread is queued, possibly repeatedly
 769      * blocking and unblocking, invoking {@link #tryAcquire}
 770      * until success or the thread is interrupted.  This method can be
 771      * used to implement method {@link Lock#lockInterruptibly}.
 772      *
 773      * @param arg the acquire argument.  This value is conveyed to
 774      *        {@link #tryAcquire} but is otherwise uninterpreted and
 775      *        can represent anything you like.
 776      * @throws InterruptedException if the current thread is interrupted
 777      */
 778     public final void acquireInterruptibly(long arg)
<a name="43" id="anc43"></a><span class="line-modified"> 779             throws InterruptedException {</span>
<span class="line-modified"> 780         if (Thread.interrupted())</span>

 781             throw new InterruptedException();
<a name="44" id="anc44"></a><span class="line-removed"> 782         if (!tryAcquire(arg))</span>
<span class="line-removed"> 783             doAcquireInterruptibly(arg);</span>
 784     }
 785 
 786     /**
 787      * Attempts to acquire in exclusive mode, aborting if interrupted,
 788      * and failing if the given timeout elapses.  Implemented by first
 789      * checking interrupt status, then invoking at least once {@link
 790      * #tryAcquire}, returning on success.  Otherwise, the thread is
 791      * queued, possibly repeatedly blocking and unblocking, invoking
 792      * {@link #tryAcquire} until success or the thread is interrupted
 793      * or the timeout elapses.  This method can be used to implement
 794      * method {@link Lock#tryLock(long, TimeUnit)}.
 795      *
 796      * @param arg the acquire argument.  This value is conveyed to
 797      *        {@link #tryAcquire} but is otherwise uninterpreted and
 798      *        can represent anything you like.
 799      * @param nanosTimeout the maximum number of nanoseconds to wait
 800      * @return {@code true} if acquired; {@code false} if timed out
 801      * @throws InterruptedException if the current thread is interrupted
 802      */
 803     public final boolean tryAcquireNanos(long arg, long nanosTimeout)
<a name="45" id="anc45"></a><span class="line-modified"> 804             throws InterruptedException {</span>
<span class="line-modified"> 805         if (Thread.interrupted())</span>
<span class="line-modified"> 806             throw new InterruptedException();</span>
<span class="line-modified"> 807         return tryAcquire(arg) ||</span>
<span class="line-modified"> 808             doAcquireNanos(arg, nanosTimeout);</span>









 809     }
 810 
 811     /**
 812      * Releases in exclusive mode.  Implemented by unblocking one or
 813      * more threads if {@link #tryRelease} returns true.
 814      * This method can be used to implement method {@link Lock#unlock}.
 815      *
 816      * @param arg the release argument.  This value is conveyed to
 817      *        {@link #tryRelease} but is otherwise uninterpreted and
 818      *        can represent anything you like.
 819      * @return the value returned from {@link #tryRelease}
 820      */
 821     public final boolean release(long arg) {
 822         if (tryRelease(arg)) {
<a name="46" id="anc46"></a><span class="line-modified"> 823             Node h = head;</span>
<span class="line-removed"> 824             if (h != null &amp;&amp; h.waitStatus != 0)</span>
<span class="line-removed"> 825                 unparkSuccessor(h);</span>
 826             return true;
 827         }
 828         return false;
 829     }
 830 
 831     /**
 832      * Acquires in shared mode, ignoring interrupts.  Implemented by
 833      * first invoking at least once {@link #tryAcquireShared},
 834      * returning on success.  Otherwise the thread is queued, possibly
 835      * repeatedly blocking and unblocking, invoking {@link
 836      * #tryAcquireShared} until success.
 837      *
 838      * @param arg the acquire argument.  This value is conveyed to
 839      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 840      *        and can represent anything you like.
 841      */
 842     public final void acquireShared(long arg) {
 843         if (tryAcquireShared(arg) &lt; 0)
<a name="47" id="anc47"></a><span class="line-modified"> 844             doAcquireShared(arg);</span>
 845     }
 846 
 847     /**
 848      * Acquires in shared mode, aborting if interrupted.  Implemented
 849      * by first checking interrupt status, then invoking at least once
 850      * {@link #tryAcquireShared}, returning on success.  Otherwise the
 851      * thread is queued, possibly repeatedly blocking and unblocking,
 852      * invoking {@link #tryAcquireShared} until success or the thread
 853      * is interrupted.
 854      * @param arg the acquire argument.
 855      * This value is conveyed to {@link #tryAcquireShared} but is
 856      * otherwise uninterpreted and can represent anything
 857      * you like.
 858      * @throws InterruptedException if the current thread is interrupted
 859      */
 860     public final void acquireSharedInterruptibly(long arg)
<a name="48" id="anc48"></a><span class="line-modified"> 861             throws InterruptedException {</span>
<span class="line-modified"> 862         if (Thread.interrupted())</span>


 863             throw new InterruptedException();
<a name="49" id="anc49"></a><span class="line-removed"> 864         if (tryAcquireShared(arg) &lt; 0)</span>
<span class="line-removed"> 865             doAcquireSharedInterruptibly(arg);</span>
 866     }
 867 
 868     /**
 869      * Attempts to acquire in shared mode, aborting if interrupted, and
 870      * failing if the given timeout elapses.  Implemented by first
 871      * checking interrupt status, then invoking at least once {@link
 872      * #tryAcquireShared}, returning on success.  Otherwise, the
 873      * thread is queued, possibly repeatedly blocking and unblocking,
 874      * invoking {@link #tryAcquireShared} until success or the thread
 875      * is interrupted or the timeout elapses.
 876      *
 877      * @param arg the acquire argument.  This value is conveyed to
 878      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 879      *        and can represent anything you like.
 880      * @param nanosTimeout the maximum number of nanoseconds to wait
 881      * @return {@code true} if acquired; {@code false} if timed out
 882      * @throws InterruptedException if the current thread is interrupted
 883      */
 884     public final boolean tryAcquireSharedNanos(long arg, long nanosTimeout)
 885             throws InterruptedException {
<a name="50" id="anc50"></a><span class="line-modified"> 886         if (Thread.interrupted())</span>
<span class="line-modified"> 887             throw new InterruptedException();</span>
<span class="line-modified"> 888         return tryAcquireShared(arg) &gt;= 0 ||</span>
<span class="line-modified"> 889             doAcquireSharedNanos(arg, nanosTimeout);</span>









 890     }
 891 
 892     /**
 893      * Releases in shared mode.  Implemented by unblocking one or more
 894      * threads if {@link #tryReleaseShared} returns true.
 895      *
 896      * @param arg the release argument.  This value is conveyed to
 897      *        {@link #tryReleaseShared} but is otherwise uninterpreted
 898      *        and can represent anything you like.
 899      * @return the value returned from {@link #tryReleaseShared}
 900      */
 901     public final boolean releaseShared(long arg) {
 902         if (tryReleaseShared(arg)) {
<a name="51" id="anc51"></a><span class="line-modified"> 903             doReleaseShared();</span>
 904             return true;
 905         }
 906         return false;
 907     }
 908 
 909     // Queue inspection methods
 910 
 911     /**
 912      * Queries whether any threads are waiting to acquire. Note that
 913      * because cancellations due to interrupts and timeouts may occur
 914      * at any time, a {@code true} return does not guarantee that any
 915      * other thread will ever acquire.
 916      *
 917      * @return {@code true} if there may be other threads waiting to acquire
 918      */
 919     public final boolean hasQueuedThreads() {
 920         for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<a name="52" id="anc52"></a><span class="line-modified"> 921             if (p.waitStatus &lt;= 0)</span>
 922                 return true;
 923         return false;
 924     }
 925 
 926     /**
 927      * Queries whether any threads have ever contended to acquire this
 928      * synchronizer; that is, if an acquire method has ever blocked.
 929      *
 930      * &lt;p&gt;In this implementation, this operation returns in
 931      * constant time.
 932      *
 933      * @return {@code true} if there has ever been contention
 934      */
 935     public final boolean hasContended() {
 936         return head != null;
 937     }
 938 
 939     /**
 940      * Returns the first (longest-waiting) thread in the queue, or
 941      * {@code null} if no threads are currently queued.
 942      *
 943      * &lt;p&gt;In this implementation, this operation normally returns in
 944      * constant time, but may iterate upon contention if other threads are
 945      * concurrently modifying the queue.
 946      *
 947      * @return the first (longest-waiting) thread in the queue, or
 948      *         {@code null} if no threads are currently queued
 949      */
 950     public final Thread getFirstQueuedThread() {
<a name="53" id="anc53"></a><span class="line-modified"> 951         // handle only fast path, else relay</span>
<span class="line-modified"> 952         return (head == tail) ? null : fullGetFirstQueuedThread();</span>
<span class="line-modified"> 953     }</span>
<span class="line-modified"> 954 </span>
<span class="line-modified"> 955     /**</span>
<span class="line-modified"> 956      * Version of getFirstQueuedThread called when fastpath fails.</span>
<span class="line-modified"> 957      */</span>
<span class="line-modified"> 958     private Thread fullGetFirstQueuedThread() {</span>
<span class="line-removed"> 959         /*</span>
<span class="line-removed"> 960          * The first node is normally head.next. Try to get its</span>
<span class="line-removed"> 961          * thread field, ensuring consistent reads: If thread</span>
<span class="line-removed"> 962          * field is nulled out or s.prev is no longer head, then</span>
<span class="line-removed"> 963          * some other thread(s) concurrently performed setHead in</span>
<span class="line-removed"> 964          * between some of our reads. We try this twice before</span>
<span class="line-removed"> 965          * resorting to traversal.</span>
<span class="line-removed"> 966          */</span>
<span class="line-removed"> 967         Node h, s;</span>
<span class="line-removed"> 968         Thread st;</span>
<span class="line-removed"> 969         if (((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-removed"> 970              s.prev == head &amp;&amp; (st = s.thread) != null) ||</span>
<span class="line-removed"> 971             ((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-removed"> 972              s.prev == head &amp;&amp; (st = s.thread) != null))</span>
<span class="line-removed"> 973             return st;</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975         /*</span>
<span class="line-removed"> 976          * Head&#39;s next field might not have been set yet, or may have</span>
<span class="line-removed"> 977          * been unset after setHead. So we must check to see if tail</span>
<span class="line-removed"> 978          * is actually first node. If not, we continue on, safely</span>
<span class="line-removed"> 979          * traversing from tail back to head to find first,</span>
<span class="line-removed"> 980          * guaranteeing termination.</span>
<span class="line-removed"> 981          */</span>
<span class="line-removed"> 982 </span>
<span class="line-removed"> 983         Thread firstThread = null;</span>
<span class="line-removed"> 984         for (Node p = tail; p != null &amp;&amp; p != head; p = p.prev) {</span>
<span class="line-removed"> 985             Thread t = p.thread;</span>
<span class="line-removed"> 986             if (t != null)</span>
<span class="line-removed"> 987                 firstThread = t;</span>
 988         }
<a name="54" id="anc54"></a><span class="line-modified"> 989         return firstThread;</span>
 990     }
 991 
 992     /**
 993      * Returns true if the given thread is currently queued.
 994      *
 995      * &lt;p&gt;This implementation traverses the queue to determine
 996      * presence of the given thread.
 997      *
 998      * @param thread the thread
 999      * @return {@code true} if the given thread is on the queue
1000      * @throws NullPointerException if the thread is null
1001      */
1002     public final boolean isQueued(Thread thread) {
1003         if (thread == null)
1004             throw new NullPointerException();
1005         for (Node p = tail; p != null; p = p.prev)
<a name="55" id="anc55"></a><span class="line-modified">1006             if (p.thread == thread)</span>
1007                 return true;
1008         return false;
1009     }
1010 
1011     /**
1012      * Returns {@code true} if the apparent first queued thread, if one
1013      * exists, is waiting in exclusive mode.  If this method returns
1014      * {@code true}, and the current thread is attempting to acquire in
1015      * shared mode (that is, this method is invoked from {@link
1016      * #tryAcquireShared}) then it is guaranteed that the current thread
1017      * is not the first queued thread.  Used only as a heuristic in
1018      * ReentrantReadWriteLock.
1019      */
1020     final boolean apparentlyFirstQueuedIsExclusive() {
1021         Node h, s;
<a name="56" id="anc56"></a><span class="line-modified">1022         return (h = head) != null &amp;&amp;</span>
<span class="line-modified">1023             (s = h.next)  != null &amp;&amp;</span>
<span class="line-removed">1024             !s.isShared()         &amp;&amp;</span>
<span class="line-removed">1025             s.thread != null;</span>
1026     }
1027 
1028     /**
1029      * Queries whether any threads have been waiting to acquire longer
1030      * than the current thread.
1031      *
1032      * &lt;p&gt;An invocation of this method is equivalent to (but may be
1033      * more efficient than):
1034      * &lt;pre&gt; {@code
1035      * getFirstQueuedThread() != Thread.currentThread()
1036      *   &amp;&amp; hasQueuedThreads()}&lt;/pre&gt;
1037      *
1038      * &lt;p&gt;Note that because cancellations due to interrupts and
1039      * timeouts may occur at any time, a {@code true} return does not
1040      * guarantee that some other thread will acquire before the current
1041      * thread.  Likewise, it is possible for another thread to win a
1042      * race to enqueue after this method has returned {@code false},
1043      * due to the queue being empty.
1044      *
1045      * &lt;p&gt;This method is designed to be used by a fair synchronizer to
1046      * avoid &lt;a href=&quot;AbstractQueuedSynchronizer.html#barging&quot;&gt;barging&lt;/a&gt;.
1047      * Such a synchronizer&#39;s {@link #tryAcquire} method should return
1048      * {@code false}, and its {@link #tryAcquireShared} method should
1049      * return a negative value, if this method returns {@code true}
1050      * (unless this is a reentrant acquire).  For example, the {@code
1051      * tryAcquire} method for a fair, reentrant, exclusive mode
1052      * synchronizer might look like this:
1053      *
1054      * &lt;pre&gt; {@code
<a name="57" id="anc57"></a><span class="line-modified">1055      * protected boolean tryAcquire(int arg) {</span>
1056      *   if (isHeldExclusively()) {
1057      *     // A reentrant acquire; increment hold count
1058      *     return true;
1059      *   } else if (hasQueuedPredecessors()) {
1060      *     return false;
1061      *   } else {
1062      *     // try to acquire normally
1063      *   }
1064      * }}&lt;/pre&gt;
1065      *
1066      * @return {@code true} if there is a queued thread preceding the
1067      *         current thread, and {@code false} if the current thread
1068      *         is at the head of the queue or the queue is empty
1069      * @since 1.7
1070      */
1071     public final boolean hasQueuedPredecessors() {
<a name="58" id="anc58"></a><span class="line-modified">1072         Node h, s;</span>
<span class="line-modified">1073         if ((h = head) != null) {</span>
<span class="line-modified">1074             if ((s = h.next) == null || s.waitStatus &gt; 0) {</span>
<span class="line-modified">1075                 s = null; // traverse in case of concurrent cancellation</span>
<span class="line-modified">1076                 for (Node p = tail; p != h &amp;&amp; p != null; p = p.prev) {</span>
<span class="line-modified">1077                     if (p.waitStatus &lt;= 0)</span>
<span class="line-removed">1078                         s = p;</span>
<span class="line-removed">1079                 }</span>
<span class="line-removed">1080             }</span>
<span class="line-removed">1081             if (s != null &amp;&amp; s.thread != Thread.currentThread())</span>
<span class="line-removed">1082                 return true;</span>
<span class="line-removed">1083         }</span>
<span class="line-removed">1084         return false;</span>
1085     }
1086 
1087     // Instrumentation and monitoring methods
1088 
1089     /**
1090      * Returns an estimate of the number of threads waiting to
1091      * acquire.  The value is only an estimate because the number of
1092      * threads may change dynamically while this method traverses
1093      * internal data structures.  This method is designed for use in
1094      * monitoring system state, not for synchronization control.
1095      *
1096      * @return the estimated number of threads waiting to acquire
1097      */
1098     public final int getQueueLength() {
1099         int n = 0;
1100         for (Node p = tail; p != null; p = p.prev) {
<a name="59" id="anc59"></a><span class="line-modified">1101             if (p.thread != null)</span>
1102                 ++n;
1103         }
1104         return n;
1105     }
1106 
1107     /**
1108      * Returns a collection containing threads that may be waiting to
1109      * acquire.  Because the actual set of threads may change
1110      * dynamically while constructing this result, the returned
1111      * collection is only a best-effort estimate.  The elements of the
1112      * returned collection are in no particular order.  This method is
1113      * designed to facilitate construction of subclasses that provide
1114      * more extensive monitoring facilities.
1115      *
1116      * @return the collection of threads
1117      */
1118     public final Collection&lt;Thread&gt; getQueuedThreads() {
1119         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1120         for (Node p = tail; p != null; p = p.prev) {
<a name="60" id="anc60"></a><span class="line-modified">1121             Thread t = p.thread;</span>
1122             if (t != null)
1123                 list.add(t);
1124         }
1125         return list;
1126     }
1127 
1128     /**
1129      * Returns a collection containing threads that may be waiting to
1130      * acquire in exclusive mode. This has the same properties
1131      * as {@link #getQueuedThreads} except that it only returns
1132      * those threads waiting due to an exclusive acquire.
1133      *
1134      * @return the collection of threads
1135      */
1136     public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
1137         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1138         for (Node p = tail; p != null; p = p.prev) {
<a name="61" id="anc61"></a><span class="line-modified">1139             if (!p.isShared()) {</span>
<span class="line-modified">1140                 Thread t = p.thread;</span>
1141                 if (t != null)
1142                     list.add(t);
1143             }
1144         }
1145         return list;
1146     }
1147 
1148     /**
1149      * Returns a collection containing threads that may be waiting to
1150      * acquire in shared mode. This has the same properties
1151      * as {@link #getQueuedThreads} except that it only returns
1152      * those threads waiting due to a shared acquire.
1153      *
1154      * @return the collection of threads
1155      */
1156     public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
1157         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1158         for (Node p = tail; p != null; p = p.prev) {
<a name="62" id="anc62"></a><span class="line-modified">1159             if (p.isShared()) {</span>
<span class="line-modified">1160                 Thread t = p.thread;</span>
1161                 if (t != null)
1162                     list.add(t);
1163             }
1164         }
1165         return list;
1166     }
1167 
1168     /**
1169      * Returns a string identifying this synchronizer, as well as its state.
1170      * The state, in brackets, includes the String {@code &quot;State =&quot;}
1171      * followed by the current value of {@link #getState}, and either
1172      * {@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
1173      * queue is empty.
1174      *
1175      * @return a string identifying this synchronizer, as well as its state
1176      */
1177     public String toString() {
1178         return super.toString()
1179             + &quot;[State = &quot; + getState() + &quot;, &quot;
1180             + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
1181     }
1182 
<a name="63" id="anc63"></a><span class="line-removed">1183 </span>
<span class="line-removed">1184     // Internal support methods for Conditions</span>
<span class="line-removed">1185 </span>
<span class="line-removed">1186     /**</span>
<span class="line-removed">1187      * Returns true if a node, always one that was initially placed on</span>
<span class="line-removed">1188      * a condition queue, is now waiting to reacquire on sync queue.</span>
<span class="line-removed">1189      * @param node the node</span>
<span class="line-removed">1190      * @return true if is reacquiring</span>
<span class="line-removed">1191      */</span>
<span class="line-removed">1192     final boolean isOnSyncQueue(Node node) {</span>
<span class="line-removed">1193         if (node.waitStatus == Node.CONDITION || node.prev == null)</span>
<span class="line-removed">1194             return false;</span>
<span class="line-removed">1195         if (node.next != null) // If has successor, it must be on queue</span>
<span class="line-removed">1196             return true;</span>
<span class="line-removed">1197         /*</span>
<span class="line-removed">1198          * node.prev can be non-null, but not yet on queue because</span>
<span class="line-removed">1199          * the CAS to place it on queue can fail. So we have to</span>
<span class="line-removed">1200          * traverse from tail to make sure it actually made it.  It</span>
<span class="line-removed">1201          * will always be near the tail in calls to this method, and</span>
<span class="line-removed">1202          * unless the CAS failed (which is unlikely), it will be</span>
<span class="line-removed">1203          * there, so we hardly ever traverse much.</span>
<span class="line-removed">1204          */</span>
<span class="line-removed">1205         return findNodeFromTail(node);</span>
<span class="line-removed">1206     }</span>
<span class="line-removed">1207 </span>
<span class="line-removed">1208     /**</span>
<span class="line-removed">1209      * Returns true if node is on sync queue by searching backwards from tail.</span>
<span class="line-removed">1210      * Called only when needed by isOnSyncQueue.</span>
<span class="line-removed">1211      * @return true if present</span>
<span class="line-removed">1212      */</span>
<span class="line-removed">1213     private boolean findNodeFromTail(Node node) {</span>
<span class="line-removed">1214         // We check for node first, since it&#39;s likely to be at or near tail.</span>
<span class="line-removed">1215         // tail is known to be non-null, so we could re-order to &quot;save&quot;</span>
<span class="line-removed">1216         // one null check, but we leave it this way to help the VM.</span>
<span class="line-removed">1217         for (Node p = tail;;) {</span>
<span class="line-removed">1218             if (p == node)</span>
<span class="line-removed">1219                 return true;</span>
<span class="line-removed">1220             if (p == null)</span>
<span class="line-removed">1221                 return false;</span>
<span class="line-removed">1222             p = p.prev;</span>
<span class="line-removed">1223         }</span>
<span class="line-removed">1224     }</span>
<span class="line-removed">1225 </span>
<span class="line-removed">1226     /**</span>
<span class="line-removed">1227      * Transfers a node from a condition queue onto sync queue.</span>
<span class="line-removed">1228      * Returns true if successful.</span>
<span class="line-removed">1229      * @param node the node</span>
<span class="line-removed">1230      * @return true if successfully transferred (else the node was</span>
<span class="line-removed">1231      * cancelled before signal)</span>
<span class="line-removed">1232      */</span>
<span class="line-removed">1233     final boolean transferForSignal(Node node) {</span>
<span class="line-removed">1234         /*</span>
<span class="line-removed">1235          * If cannot change waitStatus, the node has been cancelled.</span>
<span class="line-removed">1236          */</span>
<span class="line-removed">1237         if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))</span>
<span class="line-removed">1238             return false;</span>
<span class="line-removed">1239 </span>
<span class="line-removed">1240         /*</span>
<span class="line-removed">1241          * Splice onto queue and try to set waitStatus of predecessor to</span>
<span class="line-removed">1242          * indicate that thread is (probably) waiting. If cancelled or</span>
<span class="line-removed">1243          * attempt to set waitStatus fails, wake up to resync (in which</span>
<span class="line-removed">1244          * case the waitStatus can be transiently and harmlessly wrong).</span>
<span class="line-removed">1245          */</span>
<span class="line-removed">1246         Node p = enq(node);</span>
<span class="line-removed">1247         int ws = p.waitStatus;</span>
<span class="line-removed">1248         if (ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span>
<span class="line-removed">1249             LockSupport.unpark(node.thread);</span>
<span class="line-removed">1250         return true;</span>
<span class="line-removed">1251     }</span>
<span class="line-removed">1252 </span>
<span class="line-removed">1253     /**</span>
<span class="line-removed">1254      * Transfers node, if necessary, to sync queue after a cancelled wait.</span>
<span class="line-removed">1255      * Returns true if thread was cancelled before being signalled.</span>
<span class="line-removed">1256      *</span>
<span class="line-removed">1257      * @param node the node</span>
<span class="line-removed">1258      * @return true if cancelled before the node was signalled</span>
<span class="line-removed">1259      */</span>
<span class="line-removed">1260     final boolean transferAfterCancelledWait(Node node) {</span>
<span class="line-removed">1261         if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {</span>
<span class="line-removed">1262             enq(node);</span>
<span class="line-removed">1263             return true;</span>
<span class="line-removed">1264         }</span>
<span class="line-removed">1265         /*</span>
<span class="line-removed">1266          * If we lost out to a signal(), then we can&#39;t proceed</span>
<span class="line-removed">1267          * until it finishes its enq().  Cancelling during an</span>
<span class="line-removed">1268          * incomplete transfer is both rare and transient, so just</span>
<span class="line-removed">1269          * spin.</span>
<span class="line-removed">1270          */</span>
<span class="line-removed">1271         while (!isOnSyncQueue(node))</span>
<span class="line-removed">1272             Thread.yield();</span>
<span class="line-removed">1273         return false;</span>
<span class="line-removed">1274     }</span>
<span class="line-removed">1275 </span>
<span class="line-removed">1276     /**</span>
<span class="line-removed">1277      * Invokes release with current state value; returns saved state.</span>
<span class="line-removed">1278      * Cancels node and throws exception on failure.</span>
<span class="line-removed">1279      * @param node the condition node for this wait</span>
<span class="line-removed">1280      * @return previous sync state</span>
<span class="line-removed">1281      */</span>
<span class="line-removed">1282     final long fullyRelease(Node node) {</span>
<span class="line-removed">1283         try {</span>
<span class="line-removed">1284             long savedState = getState();</span>
<span class="line-removed">1285             if (release(savedState))</span>
<span class="line-removed">1286                 return savedState;</span>
<span class="line-removed">1287             throw new IllegalMonitorStateException();</span>
<span class="line-removed">1288         } catch (Throwable t) {</span>
<span class="line-removed">1289             node.waitStatus = Node.CANCELLED;</span>
<span class="line-removed">1290             throw t;</span>
<span class="line-removed">1291         }</span>
<span class="line-removed">1292     }</span>
<span class="line-removed">1293 </span>
1294     // Instrumentation methods for conditions
1295 
1296     /**
1297      * Queries whether the given ConditionObject
1298      * uses this synchronizer as its lock.
1299      *
1300      * @param condition the condition
1301      * @return {@code true} if owned
1302      * @throws NullPointerException if the condition is null
1303      */
1304     public final boolean owns(ConditionObject condition) {
1305         return condition.isOwnedBy(this);
1306     }
1307 
1308     /**
1309      * Queries whether any threads are waiting on the given condition
1310      * associated with this synchronizer. Note that because timeouts
1311      * and interrupts may occur at any time, a {@code true} return
1312      * does not guarantee that a future {@code signal} will awaken
1313      * any threads.  This method is designed primarily for use in
1314      * monitoring of the system state.
1315      *
1316      * @param condition the condition
1317      * @return {@code true} if there are any waiting threads
1318      * @throws IllegalMonitorStateException if exclusive synchronization
1319      *         is not held
1320      * @throws IllegalArgumentException if the given condition is
1321      *         not associated with this synchronizer
1322      * @throws NullPointerException if the condition is null
1323      */
1324     public final boolean hasWaiters(ConditionObject condition) {
1325         if (!owns(condition))
1326             throw new IllegalArgumentException(&quot;Not owner&quot;);
1327         return condition.hasWaiters();
1328     }
1329 
1330     /**
1331      * Returns an estimate of the number of threads waiting on the
1332      * given condition associated with this synchronizer. Note that
1333      * because timeouts and interrupts may occur at any time, the
1334      * estimate serves only as an upper bound on the actual number of
1335      * waiters.  This method is designed for use in monitoring system
1336      * state, not for synchronization control.
1337      *
1338      * @param condition the condition
1339      * @return the estimated number of waiting threads
1340      * @throws IllegalMonitorStateException if exclusive synchronization
1341      *         is not held
1342      * @throws IllegalArgumentException if the given condition is
1343      *         not associated with this synchronizer
1344      * @throws NullPointerException if the condition is null
1345      */
1346     public final int getWaitQueueLength(ConditionObject condition) {
1347         if (!owns(condition))
1348             throw new IllegalArgumentException(&quot;Not owner&quot;);
1349         return condition.getWaitQueueLength();
1350     }
1351 
1352     /**
1353      * Returns a collection containing those threads that may be
1354      * waiting on the given condition associated with this
1355      * synchronizer.  Because the actual set of threads may change
1356      * dynamically while constructing this result, the returned
1357      * collection is only a best-effort estimate. The elements of the
1358      * returned collection are in no particular order.
1359      *
1360      * @param condition the condition
1361      * @return the collection of threads
1362      * @throws IllegalMonitorStateException if exclusive synchronization
1363      *         is not held
1364      * @throws IllegalArgumentException if the given condition is
1365      *         not associated with this synchronizer
1366      * @throws NullPointerException if the condition is null
1367      */
1368     public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition) {
1369         if (!owns(condition))
1370             throw new IllegalArgumentException(&quot;Not owner&quot;);
1371         return condition.getWaitingThreads();
1372     }
1373 
1374     /**
1375      * Condition implementation for a {@link AbstractQueuedLongSynchronizer}
1376      * serving as the basis of a {@link Lock} implementation.
1377      *
1378      * &lt;p&gt;Method documentation for this class describes mechanics,
1379      * not behavioral specifications from the point of view of Lock
1380      * and Condition users. Exported versions of this class will in
1381      * general need to be accompanied by documentation describing
1382      * condition semantics that rely on those of the associated
1383      * {@code AbstractQueuedLongSynchronizer}.
1384      *
1385      * &lt;p&gt;This class is Serializable, but all fields are transient,
1386      * so deserialized conditions have no waiters.
<a name="64" id="anc64"></a><span class="line-removed">1387      *</span>
<span class="line-removed">1388      * @since 1.6</span>
1389      */
1390     public class ConditionObject implements Condition, java.io.Serializable {
1391         private static final long serialVersionUID = 1173984872572414699L;
1392         /** First node of condition queue. */
<a name="65" id="anc65"></a><span class="line-modified">1393         private transient Node firstWaiter;</span>
1394         /** Last node of condition queue. */
<a name="66" id="anc66"></a><span class="line-modified">1395         private transient Node lastWaiter;</span>
1396 
1397         /**
1398          * Creates a new {@code ConditionObject} instance.
1399          */
1400         public ConditionObject() { }
1401 
<a name="67" id="anc67"></a><span class="line-modified">1402         // Internal methods</span>
<span class="line-removed">1403 </span>
<span class="line-removed">1404         /**</span>
<span class="line-removed">1405          * Adds a new waiter to wait queue.</span>
<span class="line-removed">1406          * @return its new wait node</span>
<span class="line-removed">1407          */</span>
<span class="line-removed">1408         private Node addConditionWaiter() {</span>
<span class="line-removed">1409             if (!isHeldExclusively())</span>
<span class="line-removed">1410                 throw new IllegalMonitorStateException();</span>
<span class="line-removed">1411             Node t = lastWaiter;</span>
<span class="line-removed">1412             // If lastWaiter is cancelled, clean out.</span>
<span class="line-removed">1413             if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span>
<span class="line-removed">1414                 unlinkCancelledWaiters();</span>
<span class="line-removed">1415                 t = lastWaiter;</span>
<span class="line-removed">1416             }</span>
<span class="line-removed">1417 </span>
<span class="line-removed">1418             Node node = new Node(Node.CONDITION);</span>
<span class="line-removed">1419 </span>
<span class="line-removed">1420             if (t == null)</span>
<span class="line-removed">1421                 firstWaiter = node;</span>
<span class="line-removed">1422             else</span>
<span class="line-removed">1423                 t.nextWaiter = node;</span>
<span class="line-removed">1424             lastWaiter = node;</span>
<span class="line-removed">1425             return node;</span>
<span class="line-removed">1426         }</span>
1427 
1428         /**
<a name="68" id="anc68"></a><span class="line-modified">1429          * Removes and transfers nodes until hit non-cancelled one or</span>
<span class="line-removed">1430          * null. Split out from signal in part to encourage compilers</span>
<span class="line-removed">1431          * to inline the case of no waiters.</span>
<span class="line-removed">1432          * @param first (non-null) the first node on condition queue</span>
1433          */
<a name="69" id="anc69"></a><span class="line-modified">1434         private void doSignal(Node first) {</span>
<span class="line-modified">1435             do {</span>
<span class="line-modified">1436                 if ( (firstWaiter = first.nextWaiter) == null)</span>

1437                     lastWaiter = null;
<a name="70" id="anc70"></a><span class="line-modified">1438                 first.nextWaiter = null;</span>
<span class="line-modified">1439             } while (!transferForSignal(first) &amp;&amp;</span>
<span class="line-modified">1440                      (first = firstWaiter) != null);</span>
<span class="line-modified">1441         }</span>
<span class="line-removed">1442 </span>
<span class="line-removed">1443         /**</span>
<span class="line-removed">1444          * Removes and transfers all nodes.</span>
<span class="line-removed">1445          * @param first (non-null) the first node on condition queue</span>
<span class="line-removed">1446          */</span>
<span class="line-removed">1447         private void doSignalAll(Node first) {</span>
<span class="line-removed">1448             lastWaiter = firstWaiter = null;</span>
<span class="line-removed">1449             do {</span>
<span class="line-removed">1450                 Node next = first.nextWaiter;</span>
<span class="line-removed">1451                 first.nextWaiter = null;</span>
<span class="line-removed">1452                 transferForSignal(first);</span>
<span class="line-removed">1453                 first = next;</span>
<span class="line-removed">1454             } while (first != null);</span>
<span class="line-removed">1455         }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457         /**</span>
<span class="line-removed">1458          * Unlinks cancelled waiter nodes from condition queue.</span>
<span class="line-removed">1459          * Called only while holding lock. This is called when</span>
<span class="line-removed">1460          * cancellation occurred during condition wait, and upon</span>
<span class="line-removed">1461          * insertion of a new waiter when lastWaiter is seen to have</span>
<span class="line-removed">1462          * been cancelled. This method is needed to avoid garbage</span>
<span class="line-removed">1463          * retention in the absence of signals. So even though it may</span>
<span class="line-removed">1464          * require a full traversal, it comes into play only when</span>
<span class="line-removed">1465          * timeouts or cancellations occur in the absence of</span>
<span class="line-removed">1466          * signals. It traverses all nodes rather than stopping at a</span>
<span class="line-removed">1467          * particular target to unlink all pointers to garbage nodes</span>
<span class="line-removed">1468          * without requiring many re-traversals during cancellation</span>
<span class="line-removed">1469          * storms.</span>
<span class="line-removed">1470          */</span>
<span class="line-removed">1471         private void unlinkCancelledWaiters() {</span>
<span class="line-removed">1472             Node t = firstWaiter;</span>
<span class="line-removed">1473             Node trail = null;</span>
<span class="line-removed">1474             while (t != null) {</span>
<span class="line-removed">1475                 Node next = t.nextWaiter;</span>
<span class="line-removed">1476                 if (t.waitStatus != Node.CONDITION) {</span>
<span class="line-removed">1477                     t.nextWaiter = null;</span>
<span class="line-removed">1478                     if (trail == null)</span>
<span class="line-removed">1479                         firstWaiter = next;</span>
<span class="line-removed">1480                     else</span>
<span class="line-removed">1481                         trail.nextWaiter = next;</span>
<span class="line-removed">1482                     if (next == null)</span>
<span class="line-removed">1483                         lastWaiter = trail;</span>
1484                 }
<a name="71" id="anc71"></a><span class="line-modified">1485                 else</span>
<span class="line-removed">1486                     trail = t;</span>
<span class="line-removed">1487                 t = next;</span>
1488             }
1489         }
1490 
<a name="72" id="anc72"></a><span class="line-removed">1491         // public methods</span>
<span class="line-removed">1492 </span>
1493         /**
1494          * Moves the longest-waiting thread, if one exists, from the
1495          * wait queue for this condition to the wait queue for the
1496          * owning lock.
1497          *
1498          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1499          *         returns {@code false}
1500          */
1501         public final void signal() {
<a name="73" id="anc73"></a>
1502             if (!isHeldExclusively())
1503                 throw new IllegalMonitorStateException();
<a name="74" id="anc74"></a><span class="line-removed">1504             Node first = firstWaiter;</span>
1505             if (first != null)
<a name="75" id="anc75"></a><span class="line-modified">1506                 doSignal(first);</span>
1507         }
1508 
1509         /**
1510          * Moves all threads from the wait queue for this condition to
1511          * the wait queue for the owning lock.
1512          *
1513          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1514          *         returns {@code false}
1515          */
1516         public final void signalAll() {
<a name="76" id="anc76"></a>
1517             if (!isHeldExclusively())
1518                 throw new IllegalMonitorStateException();
<a name="77" id="anc77"></a><span class="line-removed">1519             Node first = firstWaiter;</span>
1520             if (first != null)
<a name="78" id="anc78"></a><span class="line-modified">1521                 doSignalAll(first);</span>





























































1522         }
1523 
1524         /**
1525          * Implements uninterruptible condition wait.
1526          * &lt;ol&gt;
1527          * &lt;li&gt;Save lock state returned by {@link #getState}.
1528          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1529          *     throwing IllegalMonitorStateException if it fails.
1530          * &lt;li&gt;Block until signalled.
1531          * &lt;li&gt;Reacquire by invoking specialized version of
1532          *     {@link #acquire} with saved state as argument.
1533          * &lt;/ol&gt;
1534          */
1535         public final void awaitUninterruptibly() {
<a name="79" id="anc79"></a><span class="line-modified">1536             Node node = addConditionWaiter();</span>
<span class="line-modified">1537             long savedState = fullyRelease(node);</span>

1538             boolean interrupted = false;
<a name="80" id="anc80"></a><span class="line-modified">1539             while (!isOnSyncQueue(node)) {</span>
<span class="line-removed">1540                 LockSupport.park(this);</span>
1541                 if (Thread.interrupted())
1542                     interrupted = true;
<a name="81" id="anc81"></a>







1543             }
<a name="82" id="anc82"></a><span class="line-modified">1544             if (acquireQueued(node, savedState) || interrupted)</span>
<span class="line-modified">1545                 selfInterrupt();</span>
<span class="line-modified">1546         }</span>
<span class="line-modified">1547 </span>
<span class="line-modified">1548         /*</span>
<span class="line-removed">1549          * For interruptible waits, we need to track whether to throw</span>
<span class="line-removed">1550          * InterruptedException, if interrupted while blocked on</span>
<span class="line-removed">1551          * condition, versus reinterrupt current thread, if</span>
<span class="line-removed">1552          * interrupted while blocked waiting to re-acquire.</span>
<span class="line-removed">1553          */</span>
<span class="line-removed">1554 </span>
<span class="line-removed">1555         /** Mode meaning to reinterrupt on exit from wait */</span>
<span class="line-removed">1556         private static final int REINTERRUPT =  1;</span>
<span class="line-removed">1557         /** Mode meaning to throw InterruptedException on exit from wait */</span>
<span class="line-removed">1558         private static final int THROW_IE    = -1;</span>
<span class="line-removed">1559 </span>
<span class="line-removed">1560         /**</span>
<span class="line-removed">1561          * Checks for interrupt, returning THROW_IE if interrupted</span>
<span class="line-removed">1562          * before signalled, REINTERRUPT if after signalled, or</span>
<span class="line-removed">1563          * 0 if not interrupted.</span>
<span class="line-removed">1564          */</span>
<span class="line-removed">1565         private int checkInterruptWhileWaiting(Node node) {</span>
<span class="line-removed">1566             return Thread.interrupted() ?</span>
<span class="line-removed">1567                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span>
<span class="line-removed">1568                 0;</span>
<span class="line-removed">1569         }</span>
<span class="line-removed">1570 </span>
<span class="line-removed">1571         /**</span>
<span class="line-removed">1572          * Throws InterruptedException, reinterrupts current thread, or</span>
<span class="line-removed">1573          * does nothing, depending on mode.</span>
<span class="line-removed">1574          */</span>
<span class="line-removed">1575         private void reportInterruptAfterWait(int interruptMode)</span>
<span class="line-removed">1576             throws InterruptedException {</span>
<span class="line-removed">1577             if (interruptMode == THROW_IE)</span>
<span class="line-removed">1578                 throw new InterruptedException();</span>
<span class="line-removed">1579             else if (interruptMode == REINTERRUPT)</span>
<span class="line-removed">1580                 selfInterrupt();</span>
1581         }
1582 
1583         /**
1584          * Implements interruptible condition wait.
1585          * &lt;ol&gt;
1586          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1587          * &lt;li&gt;Save lock state returned by {@link #getState}.
1588          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1589          *     throwing IllegalMonitorStateException if it fails.
1590          * &lt;li&gt;Block until signalled or interrupted.
1591          * &lt;li&gt;Reacquire by invoking specialized version of
1592          *     {@link #acquire} with saved state as argument.
1593          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1594          * &lt;/ol&gt;
1595          */
1596         public final void await() throws InterruptedException {
1597             if (Thread.interrupted())
1598                 throw new InterruptedException();
<a name="83" id="anc83"></a><span class="line-modified">1599             Node node = addConditionWaiter();</span>
<span class="line-modified">1600             long savedState = fullyRelease(node);</span>
<span class="line-modified">1601             int interruptMode = 0;</span>
<span class="line-modified">1602             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1603                 LockSupport.park(this);</span>
<span class="line-modified">1604                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-modified">1605                     break;</span>



















1606             }
<a name="84" id="anc84"></a><span class="line-removed">1607             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-removed">1608                 interruptMode = REINTERRUPT;</span>
<span class="line-removed">1609             if (node.nextWaiter != null) // clean up if cancelled</span>
<span class="line-removed">1610                 unlinkCancelledWaiters();</span>
<span class="line-removed">1611             if (interruptMode != 0)</span>
<span class="line-removed">1612                 reportInterruptAfterWait(interruptMode);</span>
1613         }
1614 
1615         /**
1616          * Implements timed condition wait.
1617          * &lt;ol&gt;
1618          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1619          * &lt;li&gt;Save lock state returned by {@link #getState}.
1620          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1621          *     throwing IllegalMonitorStateException if it fails.
1622          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1623          * &lt;li&gt;Reacquire by invoking specialized version of
1624          *     {@link #acquire} with saved state as argument.
1625          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1626          * &lt;/ol&gt;
1627          */
1628         public final long awaitNanos(long nanosTimeout)
1629                 throws InterruptedException {
1630             if (Thread.interrupted())
1631                 throw new InterruptedException();
<a name="85" id="anc85"></a><span class="line-modified">1632             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="line-modified">1633             // awaitNanos(0) as a way to &quot;yield the lock&quot;.</span>
<span class="line-modified">1634             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">1635             long initialNanos = nanosTimeout;</span>
<span class="line-modified">1636             Node node = addConditionWaiter();</span>
<span class="line-modified">1637             long savedState = fullyRelease(node);</span>
<span class="line-modified">1638             int interruptMode = 0;</span>
<span class="line-modified">1639             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1640                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified">1641                     transferAfterCancelledWait(node);</span>
<span class="line-modified">1642                     break;</span>
<span class="line-modified">1643                 }</span>
<span class="line-removed">1644                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">1645                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">1646                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">1647                     break;</span>
<span class="line-removed">1648                 nanosTimeout = deadline - System.nanoTime();</span>
1649             }
<a name="86" id="anc86"></a><span class="line-modified">1650             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">1651                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">1652             if (node.nextWaiter != null)</span>
<span class="line-modified">1653                 unlinkCancelledWaiters();</span>
<span class="line-modified">1654             if (interruptMode != 0)</span>
<span class="line-modified">1655                 reportInterruptAfterWait(interruptMode);</span>


1656             long remaining = deadline - System.nanoTime(); // avoid overflow
<a name="87" id="anc87"></a><span class="line-modified">1657             return (remaining &lt;= initialNanos) ? remaining : Long.MIN_VALUE;</span>
1658         }
1659 
1660         /**
1661          * Implements absolute timed condition wait.
1662          * &lt;ol&gt;
1663          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1664          * &lt;li&gt;Save lock state returned by {@link #getState}.
1665          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1666          *     throwing IllegalMonitorStateException if it fails.
1667          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1668          * &lt;li&gt;Reacquire by invoking specialized version of
1669          *     {@link #acquire} with saved state as argument.
1670          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1671          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1672          * &lt;/ol&gt;
1673          */
1674         public final boolean awaitUntil(Date deadline)
1675                 throws InterruptedException {
1676             long abstime = deadline.getTime();
1677             if (Thread.interrupted())
1678                 throw new InterruptedException();
<a name="88" id="anc88"></a><span class="line-modified">1679             Node node = addConditionWaiter();</span>
<span class="line-modified">1680             long savedState = fullyRelease(node);</span>
<span class="line-modified">1681             boolean timedout = false;</span>
<span class="line-modified">1682             int interruptMode = 0;</span>
<span class="line-modified">1683             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1684                 if (System.currentTimeMillis() &gt;= abstime) {</span>
<span class="line-modified">1685                     timedout = transferAfterCancelledWait(node);</span>
<span class="line-modified">1686                     break;</span>
<span class="line-modified">1687                 }</span>
<span class="line-modified">1688                 LockSupport.parkUntil(this, abstime);</span>
<span class="line-removed">1689                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">1690                     break;</span>
1691             }
<a name="89" id="anc89"></a><span class="line-modified">1692             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">1693                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">1694             if (node.nextWaiter != null)</span>
<span class="line-modified">1695                 unlinkCancelledWaiters();</span>
<span class="line-modified">1696             if (interruptMode != 0)</span>
<span class="line-modified">1697                 reportInterruptAfterWait(interruptMode);</span>
<span class="line-modified">1698             return !timedout;</span>


1699         }
1700 
1701         /**
1702          * Implements timed condition wait.
1703          * &lt;ol&gt;
1704          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1705          * &lt;li&gt;Save lock state returned by {@link #getState}.
1706          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1707          *     throwing IllegalMonitorStateException if it fails.
1708          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1709          * &lt;li&gt;Reacquire by invoking specialized version of
1710          *     {@link #acquire} with saved state as argument.
1711          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1712          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1713          * &lt;/ol&gt;
1714          */
1715         public final boolean await(long time, TimeUnit unit)
1716                 throws InterruptedException {
1717             long nanosTimeout = unit.toNanos(time);
1718             if (Thread.interrupted())
1719                 throw new InterruptedException();
<a name="90" id="anc90"></a><span class="line-modified">1720             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="line-modified">1721             // await(0, unit) as a way to &quot;yield the lock&quot;.</span>
<span class="line-modified">1722             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">1723             Node node = addConditionWaiter();</span>
<span class="line-modified">1724             long savedState = fullyRelease(node);</span>
<span class="line-modified">1725             boolean timedout = false;</span>
<span class="line-modified">1726             int interruptMode = 0;</span>
<span class="line-modified">1727             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1728                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified">1729                     timedout = transferAfterCancelledWait(node);</span>
<span class="line-modified">1730                     break;</span>
<span class="line-modified">1731                 }</span>
<span class="line-removed">1732                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">1733                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">1734                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">1735                     break;</span>
<span class="line-removed">1736                 nanosTimeout = deadline - System.nanoTime();</span>
1737             }
<a name="91" id="anc91"></a><span class="line-modified">1738             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">1739                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">1740             if (node.nextWaiter != null)</span>
<span class="line-modified">1741                 unlinkCancelledWaiters();</span>
<span class="line-modified">1742             if (interruptMode != 0)</span>
<span class="line-modified">1743                 reportInterruptAfterWait(interruptMode);</span>
<span class="line-modified">1744             return !timedout;</span>


1745         }
1746 
1747         //  support for instrumentation
1748 
1749         /**
1750          * Returns true if this condition was created by the given
1751          * synchronization object.
1752          *
1753          * @return {@code true} if owned
1754          */
1755         final boolean isOwnedBy(AbstractQueuedLongSynchronizer sync) {
1756             return sync == AbstractQueuedLongSynchronizer.this;
1757         }
1758 
1759         /**
1760          * Queries whether any threads are waiting on this condition.
1761          * Implements {@link AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject)}.
1762          *
1763          * @return {@code true} if there are any waiting threads
1764          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1765          *         returns {@code false}
1766          */
1767         protected final boolean hasWaiters() {
1768             if (!isHeldExclusively())
1769                 throw new IllegalMonitorStateException();
<a name="92" id="anc92"></a><span class="line-modified">1770             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1771                 if (w.waitStatus == Node.CONDITION)</span>
1772                     return true;
1773             }
1774             return false;
1775         }
1776 
1777         /**
1778          * Returns an estimate of the number of threads waiting on
1779          * this condition.
1780          * Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject)}.
1781          *
1782          * @return the estimated number of waiting threads
1783          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1784          *         returns {@code false}
1785          */
1786         protected final int getWaitQueueLength() {
1787             if (!isHeldExclusively())
1788                 throw new IllegalMonitorStateException();
1789             int n = 0;
<a name="93" id="anc93"></a><span class="line-modified">1790             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1791                 if (w.waitStatus == Node.CONDITION)</span>
1792                     ++n;
1793             }
1794             return n;
1795         }
1796 
1797         /**
1798          * Returns a collection containing those threads that may be
1799          * waiting on this Condition.
1800          * Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject)}.
1801          *
1802          * @return the collection of threads
1803          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1804          *         returns {@code false}
1805          */
1806         protected final Collection&lt;Thread&gt; getWaitingThreads() {
1807             if (!isHeldExclusively())
1808                 throw new IllegalMonitorStateException();
1809             ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<a name="94" id="anc94"></a><span class="line-modified">1810             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1811                 if (w.waitStatus == Node.CONDITION) {</span>
<span class="line-modified">1812                     Thread t = w.thread;</span>
1813                     if (t != null)
1814                         list.add(t);
1815                 }
1816             }
1817             return list;
1818         }
1819     }
1820 
<a name="95" id="anc95"></a><span class="line-modified">1821     // VarHandle mechanics</span>
<span class="line-modified">1822     private static final VarHandle STATE;</span>
<span class="line-modified">1823     private static final VarHandle HEAD;</span>
<span class="line-modified">1824     private static final VarHandle TAIL;</span>




1825 
1826     static {
<a name="96" id="anc96"></a><span class="line-removed">1827         try {</span>
<span class="line-removed">1828             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-removed">1829             STATE = l.findVarHandle(AbstractQueuedLongSynchronizer.class, &quot;state&quot;, long.class);</span>
<span class="line-removed">1830             HEAD = l.findVarHandle(AbstractQueuedLongSynchronizer.class, &quot;head&quot;, Node.class);</span>
<span class="line-removed">1831             TAIL = l.findVarHandle(AbstractQueuedLongSynchronizer.class, &quot;tail&quot;, Node.class);</span>
<span class="line-removed">1832         } catch (ReflectiveOperationException e) {</span>
<span class="line-removed">1833             throw new ExceptionInInitializerError(e);</span>
<span class="line-removed">1834         }</span>
<span class="line-removed">1835 </span>
<span class="line-removed">1836         // Reduce the risk of rare disastrous classloading in first call to</span>
<span class="line-removed">1837         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span>
1838         Class&lt;?&gt; ensureLoaded = LockSupport.class;
1839     }
<a name="97" id="anc97"></a><span class="line-removed">1840 </span>
<span class="line-removed">1841     /**</span>
<span class="line-removed">1842      * Initializes head and tail fields on first contention.</span>
<span class="line-removed">1843      */</span>
<span class="line-removed">1844     private final void initializeSyncQueue() {</span>
<span class="line-removed">1845         Node h;</span>
<span class="line-removed">1846         if (HEAD.compareAndSet(this, null, (h = new Node())))</span>
<span class="line-removed">1847             tail = h;</span>
<span class="line-removed">1848     }</span>
<span class="line-removed">1849 </span>
<span class="line-removed">1850     /**</span>
<span class="line-removed">1851      * CASes tail field.</span>
<span class="line-removed">1852      */</span>
<span class="line-removed">1853     private final boolean compareAndSetTail(Node expect, Node update) {</span>
<span class="line-removed">1854         return TAIL.compareAndSet(this, expect, update);</span>
<span class="line-removed">1855     }</span>
1856 }
<a name="98" id="anc98"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="98" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../atomic/LongAccumulator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractQueuedSynchronizer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 
<span class="line-removed">  38 import java.lang.invoke.MethodHandles;</span>
<span class="line-removed">  39 import java.lang.invoke.VarHandle;</span>
  40 import java.util.ArrayList;
  41 import java.util.Collection;
  42 import java.util.Date;
  43 import java.util.concurrent.TimeUnit;
<span class="line-modified">  44 import java.util.concurrent.locks.AbstractQueuedSynchronizer.Node;</span>

  45 
  46 /**
  47  * A version of {@link AbstractQueuedSynchronizer} in
  48  * which synchronization state is maintained as a {@code long}.
  49  * This class has exactly the same structure, properties, and methods
  50  * as {@code AbstractQueuedSynchronizer} with the exception
  51  * that all state-related parameters and results are defined
  52  * as {@code long} rather than {@code int}. This class
  53  * may be useful when creating synchronizers such as
  54  * multilevel locks and barriers that require
  55  * 64 bits of state.
  56  *
  57  * &lt;p&gt;See {@link AbstractQueuedSynchronizer} for usage
  58  * notes and examples.
  59  *
  60  * @since 1.6
  61  * @author Doug Lea
  62  */
  63 public abstract class AbstractQueuedLongSynchronizer
  64     extends AbstractOwnableSynchronizer
  65     implements java.io.Serializable {
  66 
  67     private static final long serialVersionUID = 7373984972572414692L;
  68 
  69     /*
  70      * To keep sources in sync, the remainder of this source file is
  71      * exactly cloned from AbstractQueuedSynchronizer, replacing class
  72      * name and changing ints related with sync state to longs. Please
  73      * keep it that way.
  74      */
  75 
<span class="line-modified">  76     /**</span>
<span class="line-modified">  77      * Creates a new {@code AbstractQueuedLongSynchronizer} instance</span>
<span class="line-modified">  78      * with initial synchronization state of zero.</span>
<span class="line-modified">  79      */</span>
<span class="line-modified">  80     protected AbstractQueuedLongSynchronizer() { }</span>

























































  81 
  82     /**
<span class="line-modified">  83      * Head of the wait queue, lazily initialized.  Except for</span>
<span class="line-removed">  84      * initialization, it is modified only via method setHead.  Note:</span>
<span class="line-removed">  85      * If head exists, its waitStatus is guaranteed not to be</span>
<span class="line-removed">  86      * CANCELLED.</span>
  87      */
  88     private transient volatile Node head;
  89 
  90     /**
<span class="line-modified">  91      * Tail of the wait queue, lazily initialized.  Modified only via</span>
<span class="line-removed">  92      * method enq to add new wait node.</span>
  93      */
  94     private transient volatile Node tail;
  95 
  96     /**
  97      * The synchronization state.
  98      */
  99     private volatile long state;
 100 
 101     /**
 102      * Returns the current value of synchronization state.
 103      * This operation has memory semantics of a {@code volatile} read.
 104      * @return current state value
 105      */
 106     protected final long getState() {
 107         return state;
 108     }
 109 
 110     /**
 111      * Sets the value of synchronization state.
 112      * This operation has memory semantics of a {@code volatile} write.
 113      * @param newState the new state value
 114      */
 115     protected final void setState(long newState) {
<span class="line-modified"> 116         // See JDK-8180620: Clarify VarHandle mixed-access subtleties</span>
<span class="line-removed"> 117         STATE.setVolatile(this, newState);</span>
 118     }
 119 
 120     /**
 121      * Atomically sets synchronization state to the given updated
 122      * value if the current state value equals the expected value.
 123      * This operation has memory semantics of a {@code volatile} read
 124      * and write.
 125      *
 126      * @param expect the expected value
 127      * @param update the new value
 128      * @return {@code true} if successful. False return indicates that the actual
 129      *         value was not equal to the expected value.
 130      */
 131     protected final boolean compareAndSetState(long expect, long update) {
<span class="line-modified"> 132         return STATE.compareAndSet(this, expect, update);</span>
 133     }
 134 
 135     // Queuing utilities
 136 
<span class="line-modified"> 137     /**</span>
<span class="line-modified"> 138      * The number of nanoseconds for which it is faster to spin</span>
<span class="line-removed"> 139      * rather than to use timed park. A rough estimate suffices</span>
<span class="line-removed"> 140      * to improve responsiveness with very short timeouts.</span>
<span class="line-removed"> 141      */</span>
<span class="line-removed"> 142     static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1000L;</span>
<span class="line-removed"> 143 </span>
<span class="line-removed"> 144     /**</span>
<span class="line-removed"> 145      * Inserts node into queue, initializing if necessary. See picture above.</span>
<span class="line-removed"> 146      * @param node the node to insert</span>
<span class="line-removed"> 147      * @return node&#39;s predecessor</span>
<span class="line-removed"> 148      */</span>
<span class="line-removed"> 149     private Node enq(Node node) {</span>
<span class="line-removed"> 150         for (;;) {</span>
<span class="line-removed"> 151             Node oldTail = tail;</span>
<span class="line-removed"> 152             if (oldTail != null) {</span>
<span class="line-removed"> 153                 node.setPrevRelaxed(oldTail);</span>
<span class="line-removed"> 154                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="line-removed"> 155                     oldTail.next = node;</span>
<span class="line-removed"> 156                     return oldTail;</span>
<span class="line-removed"> 157                 }</span>
<span class="line-removed"> 158             } else {</span>
<span class="line-removed"> 159                 initializeSyncQueue();</span>
<span class="line-removed"> 160             }</span>
<span class="line-removed"> 161         }</span>
<span class="line-removed"> 162     }</span>
<span class="line-removed"> 163 </span>
<span class="line-removed"> 164     /**</span>
<span class="line-removed"> 165      * Creates and enqueues node for current thread and given mode.</span>
<span class="line-removed"> 166      *</span>
<span class="line-removed"> 167      * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span>
<span class="line-removed"> 168      * @return the new node</span>
<span class="line-removed"> 169      */</span>
<span class="line-removed"> 170     private Node addWaiter(Node mode) {</span>
<span class="line-removed"> 171         Node node = new Node(mode);</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173         for (;;) {</span>
<span class="line-removed"> 174             Node oldTail = tail;</span>
<span class="line-removed"> 175             if (oldTail != null) {</span>
<span class="line-removed"> 176                 node.setPrevRelaxed(oldTail);</span>
<span class="line-removed"> 177                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="line-removed"> 178                     oldTail.next = node;</span>
<span class="line-removed"> 179                     return node;</span>
<span class="line-removed"> 180                 }</span>
<span class="line-removed"> 181             } else {</span>
<span class="line-removed"> 182                 initializeSyncQueue();</span>
<span class="line-removed"> 183             }</span>
<span class="line-removed"> 184         }</span>
<span class="line-removed"> 185     }</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187     /**</span>
<span class="line-removed"> 188      * Sets head of queue to be node, thus dequeuing. Called only by</span>
<span class="line-removed"> 189      * acquire methods.  Also nulls out unused fields for sake of GC</span>
<span class="line-removed"> 190      * and to suppress unnecessary signals and traversals.</span>
<span class="line-removed"> 191      *</span>
<span class="line-removed"> 192      * @param node the node</span>
<span class="line-removed"> 193      */</span>
<span class="line-removed"> 194     private void setHead(Node node) {</span>
<span class="line-removed"> 195         head = node;</span>
<span class="line-removed"> 196         node.thread = null;</span>
<span class="line-removed"> 197         node.prev = null;</span>
 198     }
 199 
<span class="line-modified"> 200     /**</span>
<span class="line-modified"> 201      * Wakes up node&#39;s successor, if one exists.</span>
<span class="line-modified"> 202      *</span>
<span class="line-modified"> 203      * @param node the node</span>
<span class="line-modified"> 204      */</span>
<span class="line-removed"> 205     private void unparkSuccessor(Node node) {</span>
<span class="line-removed"> 206         /*</span>
<span class="line-removed"> 207          * If status is negative (i.e., possibly needing signal) try</span>
<span class="line-removed"> 208          * to clear in anticipation of signalling.  It is OK if this</span>
<span class="line-removed"> 209          * fails or if status is changed by waiting thread.</span>
<span class="line-removed"> 210          */</span>
<span class="line-removed"> 211         int ws = node.waitStatus;</span>
<span class="line-removed"> 212         if (ws &lt; 0)</span>
<span class="line-removed"> 213             node.compareAndSetWaitStatus(ws, 0);</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215         /*</span>
<span class="line-removed"> 216          * Thread to unpark is held in successor, which is normally</span>
<span class="line-removed"> 217          * just the next node.  But if cancelled or apparently null,</span>
<span class="line-removed"> 218          * traverse backwards from tail to find the actual</span>
<span class="line-removed"> 219          * non-cancelled successor.</span>
<span class="line-removed"> 220          */</span>
<span class="line-removed"> 221         Node s = node.next;</span>
<span class="line-removed"> 222         if (s == null || s.waitStatus &gt; 0) {</span>
<span class="line-removed"> 223             s = null;</span>
<span class="line-removed"> 224             for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span>
<span class="line-removed"> 225                 if (p.waitStatus &lt;= 0)</span>
<span class="line-removed"> 226                     s = p;</span>
<span class="line-removed"> 227         }</span>
<span class="line-removed"> 228         if (s != null)</span>
<span class="line-removed"> 229             LockSupport.unpark(s.thread);</span>
 230     }
 231 
 232     /**
<span class="line-modified"> 233      * Release action for shared mode -- signals successor and ensures</span>
<span class="line-modified"> 234      * propagation. (Note: For exclusive mode, release just amounts</span>
<span class="line-removed"> 235      * to calling unparkSuccessor of head if it needs signal.)</span>
 236      */
<span class="line-modified"> 237     private void doReleaseShared() {</span>
<span class="line-modified"> 238         /*</span>
<span class="line-modified"> 239          * Ensure that a release propagates, even if there are other</span>
<span class="line-modified"> 240          * in-progress acquires/releases.  This proceeds in the usual</span>
<span class="line-modified"> 241          * way of trying to unparkSuccessor of head if it needs</span>
<span class="line-modified"> 242          * signal. But if it does not, status is set to PROPAGATE to</span>
<span class="line-modified"> 243          * ensure that upon release, propagation continues.</span>
<span class="line-modified"> 244          * Additionally, we must loop in case a new node is added</span>
<span class="line-modified"> 245          * while we are doing this. Also, unlike other uses of</span>
<span class="line-modified"> 246          * unparkSuccessor, we need to know if CAS to reset status</span>
<span class="line-modified"> 247          * fails, if so rechecking.</span>
<span class="line-modified"> 248          */</span>
<span class="line-removed"> 249         for (;;) {</span>
<span class="line-removed"> 250             Node h = head;</span>
<span class="line-removed"> 251             if (h != null &amp;&amp; h != tail) {</span>
<span class="line-removed"> 252                 int ws = h.waitStatus;</span>
<span class="line-removed"> 253                 if (ws == Node.SIGNAL) {</span>
<span class="line-removed"> 254                     if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))</span>
<span class="line-removed"> 255                         continue;            // loop to recheck cases</span>
<span class="line-removed"> 256                     unparkSuccessor(h);</span>
 257                 }
<span class="line-removed"> 258                 else if (ws == 0 &amp;&amp;</span>
<span class="line-removed"> 259                          !h.compareAndSetWaitStatus(0, Node.PROPAGATE))</span>
<span class="line-removed"> 260                     continue;                // loop on failed CAS</span>
 261             }
<span class="line-removed"> 262             if (h == head)                   // loop if head changed</span>
<span class="line-removed"> 263                 break;</span>
 264         }
 265     }
 266 
<span class="line-modified"> 267     /**</span>
<span class="line-modified"> 268      * Sets head of queue, and checks if successor may be waiting</span>
<span class="line-modified"> 269      * in shared mode, if so propagating if either propagate &gt; 0 or</span>
<span class="line-modified"> 270      * PROPAGATE status was set.</span>
<span class="line-modified"> 271      *</span>
<span class="line-modified"> 272      * @param node the node</span>
<span class="line-removed"> 273      * @param propagate the return value from a tryAcquireShared</span>
<span class="line-removed"> 274      */</span>
<span class="line-removed"> 275     private void setHeadAndPropagate(Node node, long propagate) {</span>
<span class="line-removed"> 276         Node h = head; // Record old head for check below</span>
<span class="line-removed"> 277         setHead(node);</span>
<span class="line-removed"> 278         /*</span>
<span class="line-removed"> 279          * Try to signal next queued node if:</span>
<span class="line-removed"> 280          *   Propagation was indicated by caller,</span>
<span class="line-removed"> 281          *     or was recorded (as h.waitStatus either before</span>
<span class="line-removed"> 282          *     or after setHead) by a previous operation</span>
<span class="line-removed"> 283          *     (note: this uses sign-check of waitStatus because</span>
<span class="line-removed"> 284          *      PROPAGATE status may transition to SIGNAL.)</span>
<span class="line-removed"> 285          * and</span>
<span class="line-removed"> 286          *   The next node is waiting in shared mode,</span>
<span class="line-removed"> 287          *     or we don&#39;t know, because it appears null</span>
<span class="line-removed"> 288          *</span>
<span class="line-removed"> 289          * The conservatism in both of these checks may cause</span>
<span class="line-removed"> 290          * unnecessary wake-ups, but only when there are multiple</span>
<span class="line-removed"> 291          * racing acquires/releases, so most need signals now or soon</span>
<span class="line-removed"> 292          * anyway.</span>
<span class="line-removed"> 293          */</span>
<span class="line-removed"> 294         if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span>
<span class="line-removed"> 295             (h = head) == null || h.waitStatus &lt; 0) {</span>
<span class="line-removed"> 296             Node s = node.next;</span>
<span class="line-removed"> 297             if (s == null || s.isShared())</span>
<span class="line-removed"> 298                 doReleaseShared();</span>
<span class="line-removed"> 299         }</span>
 300     }
 301 
<span class="line-removed"> 302     // Utilities for various versions of acquire</span>
<span class="line-removed"> 303 </span>
 304     /**
<span class="line-modified"> 305      * Cancels an ongoing attempt to acquire.</span>
<span class="line-modified"> 306      *</span>
<span class="line-modified"> 307      * @param node the node</span>

 308      */
<span class="line-modified"> 309     private void cancelAcquire(Node node) {</span>
<span class="line-modified"> 310         // Ignore if node doesn&#39;t exist</span>
<span class="line-modified"> 311         if (node == null)</span>
<span class="line-modified"> 312             return;</span>
<span class="line-modified"> 313 </span>
<span class="line-removed"> 314         node.thread = null;</span>
<span class="line-removed"> 315 </span>
<span class="line-removed"> 316         // Skip cancelled predecessors</span>
<span class="line-removed"> 317         Node pred = node.prev;</span>
<span class="line-removed"> 318         while (pred.waitStatus &gt; 0)</span>
<span class="line-removed"> 319             node.prev = pred = pred.prev;</span>
<span class="line-removed"> 320 </span>
<span class="line-removed"> 321         // predNext is the apparent node to unsplice. CASes below will</span>
<span class="line-removed"> 322         // fail if not, in which case, we lost race vs another cancel</span>
<span class="line-removed"> 323         // or signal, so no further action is necessary, although with</span>
<span class="line-removed"> 324         // a possibility that a cancelled node may transiently remain</span>
<span class="line-removed"> 325         // reachable.</span>
<span class="line-removed"> 326         Node predNext = pred.next;</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328         // Can use unconditional write instead of CAS here.</span>
<span class="line-removed"> 329         // After this atomic step, other Nodes can skip past us.</span>
<span class="line-removed"> 330         // Before, we are free of interference from other threads.</span>
<span class="line-removed"> 331         node.waitStatus = Node.CANCELLED;</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333         // If we are the tail, remove ourselves.</span>
<span class="line-removed"> 334         if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span>
<span class="line-removed"> 335             pred.compareAndSetNext(predNext, null);</span>
<span class="line-removed"> 336         } else {</span>
<span class="line-removed"> 337             // If successor needs signal, try to set pred&#39;s next-link</span>
<span class="line-removed"> 338             // so it will get one. Otherwise wake it up to propagate.</span>
<span class="line-removed"> 339             int ws;</span>
<span class="line-removed"> 340             if (pred != head &amp;&amp;</span>
<span class="line-removed"> 341                 ((ws = pred.waitStatus) == Node.SIGNAL ||</span>
<span class="line-removed"> 342                  (ws &lt;= 0 &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span>
<span class="line-removed"> 343                 pred.thread != null) {</span>
<span class="line-removed"> 344                 Node next = node.next;</span>
<span class="line-removed"> 345                 if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span>
<span class="line-removed"> 346                     pred.compareAndSetNext(predNext, next);</span>
<span class="line-removed"> 347             } else {</span>
<span class="line-removed"> 348                 unparkSuccessor(node);</span>
<span class="line-removed"> 349             }</span>
<span class="line-removed"> 350 </span>
<span class="line-removed"> 351             node.next = node; // help GC</span>
 352         }
 353     }
 354 
<span class="line-modified"> 355     /**</span>
<span class="line-modified"> 356      * Checks and updates status for a node that failed to acquire.</span>
<span class="line-modified"> 357      * Returns true if thread should block. This is the main signal</span>
<span class="line-modified"> 358      * control in all acquire loops.  Requires that pred == node.prev.</span>
<span class="line-modified"> 359      *</span>
<span class="line-modified"> 360      * @param pred node&#39;s predecessor holding status</span>
<span class="line-modified"> 361      * @param node the node</span>
<span class="line-removed"> 362      * @return {@code true} if thread should block</span>
<span class="line-removed"> 363      */</span>
<span class="line-removed"> 364     private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</span>
<span class="line-removed"> 365         int ws = pred.waitStatus;</span>
<span class="line-removed"> 366         if (ws == Node.SIGNAL)</span>
<span class="line-removed"> 367             /*</span>
<span class="line-removed"> 368              * This node has already set status asking a release</span>
<span class="line-removed"> 369              * to signal it, so it can safely park.</span>
<span class="line-removed"> 370              */</span>
<span class="line-removed"> 371             return true;</span>
<span class="line-removed"> 372         if (ws &gt; 0) {</span>
<span class="line-removed"> 373             /*</span>
<span class="line-removed"> 374              * Predecessor was cancelled. Skip over predecessors and</span>
<span class="line-removed"> 375              * indicate retry.</span>
<span class="line-removed"> 376              */</span>
<span class="line-removed"> 377             do {</span>
<span class="line-removed"> 378                 node.prev = pred = pred.prev;</span>
<span class="line-removed"> 379             } while (pred.waitStatus &gt; 0);</span>
<span class="line-removed"> 380             pred.next = node;</span>
<span class="line-removed"> 381         } else {</span>
<span class="line-removed"> 382             /*</span>
<span class="line-removed"> 383              * waitStatus must be 0 or PROPAGATE.  Indicate that we</span>
<span class="line-removed"> 384              * need a signal, but don&#39;t park yet.  Caller will need to</span>
<span class="line-removed"> 385              * retry to make sure it cannot acquire before parking.</span>
<span class="line-removed"> 386              */</span>
<span class="line-removed"> 387             pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span>
 388         }
<span class="line-removed"> 389         return false;</span>
<span class="line-removed"> 390     }</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392     /**</span>
<span class="line-removed"> 393      * Convenience method to interrupt current thread.</span>
<span class="line-removed"> 394      */</span>
<span class="line-removed"> 395     static void selfInterrupt() {</span>
<span class="line-removed"> 396         Thread.currentThread().interrupt();</span>
 397     }
 398 
 399     /**
<span class="line-modified"> 400      * Convenience method to park and then check if interrupted.</span>
<span class="line-removed"> 401      *</span>
<span class="line-removed"> 402      * @return {@code true} if interrupted</span>
<span class="line-removed"> 403      */</span>
<span class="line-removed"> 404     private final boolean parkAndCheckInterrupt() {</span>
<span class="line-removed"> 405         LockSupport.park(this);</span>
<span class="line-removed"> 406         return Thread.interrupted();</span>
<span class="line-removed"> 407     }</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409     /*</span>
<span class="line-removed"> 410      * Various flavors of acquire, varying in exclusive/shared and</span>
<span class="line-removed"> 411      * control modes.  Each is mostly the same, but annoyingly</span>
<span class="line-removed"> 412      * different.  Only a little bit of factoring is possible due to</span>
<span class="line-removed"> 413      * interactions of exception mechanics (including ensuring that we</span>
<span class="line-removed"> 414      * cancel if tryAcquire throws exception) and other control, at</span>
<span class="line-removed"> 415      * least not without hurting performance too much.</span>
<span class="line-removed"> 416      */</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418     /**</span>
<span class="line-removed"> 419      * Acquires in exclusive uninterruptible mode for thread already in</span>
<span class="line-removed"> 420      * queue. Used by condition wait methods as well as acquire.</span>
 421      *
<span class="line-modified"> 422      * @param node the node</span>
 423      * @param arg the acquire argument
<span class="line-modified"> 424      * @return {@code true} if interrupted while waiting</span>




 425      */
<span class="line-modified"> 426     final boolean acquireQueued(final Node node, long arg) {</span>
<span class="line-modified"> 427         boolean interrupted = false;</span>
<span class="line-modified"> 428         try {</span>
<span class="line-modified"> 429             for (;;) {</span>
<span class="line-modified"> 430                 final Node p = node.predecessor();</span>
<span class="line-modified"> 431                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-removed"> 432                     setHead(node);</span>
<span class="line-removed"> 433                     p.next = null; // help GC</span>
<span class="line-removed"> 434                     return interrupted;</span>
<span class="line-removed"> 435                 }</span>
<span class="line-removed"> 436                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="line-removed"> 437                     interrupted |= parkAndCheckInterrupt();</span>
<span class="line-removed"> 438             }</span>
<span class="line-removed"> 439         } catch (Throwable t) {</span>
<span class="line-removed"> 440             cancelAcquire(node);</span>
<span class="line-removed"> 441             if (interrupted)</span>
<span class="line-removed"> 442                 selfInterrupt();</span>
<span class="line-removed"> 443             throw t;</span>
<span class="line-removed"> 444         }</span>
<span class="line-removed"> 445     }</span>
 446 
<span class="line-modified"> 447     /**</span>
<span class="line-modified"> 448      * Acquires in exclusive interruptible mode.</span>
<span class="line-modified"> 449      * @param arg the acquire argument</span>
<span class="line-modified"> 450      */</span>
<span class="line-modified"> 451     private void doAcquireInterruptibly(long arg)</span>
<span class="line-modified"> 452         throws InterruptedException {</span>
<span class="line-modified"> 453         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="line-modified"> 454         try {</span>
<span class="line-modified"> 455             for (;;) {</span>
<span class="line-modified"> 456                 final Node p = node.predecessor();</span>
<span class="line-modified"> 457                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-modified"> 458                     setHead(node);</span>
<span class="line-modified"> 459                     p.next = null; // help GC</span>
<span class="line-modified"> 460                     return;</span>







 461                 }
<span class="line-removed"> 462                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 463                     parkAndCheckInterrupt())</span>
<span class="line-removed"> 464                     throw new InterruptedException();</span>
 465             }
<span class="line-modified"> 466         } catch (Throwable t) {</span>
<span class="line-modified"> 467             cancelAcquire(node);</span>
<span class="line-modified"> 468             throw t;</span>
<span class="line-modified"> 469         }</span>
<span class="line-modified"> 470     }</span>
<span class="line-modified"> 471 </span>
<span class="line-modified"> 472     /**</span>
<span class="line-modified"> 473      * Acquires in exclusive timed mode.</span>
<span class="line-modified"> 474      *</span>
<span class="line-modified"> 475      * @param arg the acquire argument</span>
<span class="line-removed"> 476      * @param nanosTimeout max wait time</span>
<span class="line-removed"> 477      * @return {@code true} if acquired</span>
<span class="line-removed"> 478      */</span>
<span class="line-removed"> 479     private boolean doAcquireNanos(long arg, long nanosTimeout)</span>
<span class="line-removed"> 480             throws InterruptedException {</span>
<span class="line-removed"> 481         if (nanosTimeout &lt;= 0L)</span>
<span class="line-removed"> 482             return false;</span>
<span class="line-removed"> 483         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-removed"> 484         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="line-removed"> 485         try {</span>
<span class="line-removed"> 486             for (;;) {</span>
<span class="line-removed"> 487                 final Node p = node.predecessor();</span>
<span class="line-removed"> 488                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-removed"> 489                     setHead(node);</span>
<span class="line-removed"> 490                     p.next = null; // help GC</span>
<span class="line-removed"> 491                     return true;</span>
 492                 }
<span class="line-modified"> 493                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="line-modified"> 494                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified"> 495                     cancelAcquire(node);</span>
<span class="line-modified"> 496                     return false;</span>








 497                 }
<span class="line-removed"> 498                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 499                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed"> 500                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed"> 501                 if (Thread.interrupted())</span>
<span class="line-removed"> 502                     throw new InterruptedException();</span>
 503             }
<span class="line-modified"> 504         } catch (Throwable t) {</span>
<span class="line-modified"> 505             cancelAcquire(node);</span>
<span class="line-modified"> 506             throw t;</span>






























 507         }

 508     }
 509 
 510     /**
<span class="line-modified"> 511      * Acquires in shared uninterruptible mode.</span>
<span class="line-modified"> 512      * @param arg the acquire argument</span>
 513      */
<span class="line-modified"> 514     private void doAcquireShared(long arg) {</span>
<span class="line-modified"> 515         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-modified"> 516         boolean interrupted = false;</span>
<span class="line-modified"> 517         try {</span>
<span class="line-modified"> 518             for (;;) {</span>
<span class="line-modified"> 519                 final Node p = node.predecessor();</span>
<span class="line-modified"> 520                 if (p == head) {</span>
<span class="line-modified"> 521                     long r = tryAcquireShared(arg);</span>
<span class="line-modified"> 522                     if (r &gt;= 0) {</span>
<span class="line-modified"> 523                         setHeadAndPropagate(node, r);</span>
<span class="line-modified"> 524                         p.next = null; // help GC</span>
<span class="line-modified"> 525                         return;</span>

 526                     }

 527                 }
<span class="line-modified"> 528                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="line-modified"> 529                     interrupted |= parkAndCheckInterrupt();</span>
<span class="line-modified"> 530             }</span>
<span class="line-modified"> 531         } catch (Throwable t) {</span>
<span class="line-modified"> 532             cancelAcquire(node);</span>
<span class="line-removed"> 533             throw t;</span>
<span class="line-removed"> 534         } finally {</span>
<span class="line-removed"> 535             if (interrupted)</span>
<span class="line-removed"> 536                 selfInterrupt();</span>
<span class="line-removed"> 537         }</span>
<span class="line-removed"> 538     }</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540     /**</span>
<span class="line-removed"> 541      * Acquires in shared interruptible mode.</span>
<span class="line-removed"> 542      * @param arg the acquire argument</span>
<span class="line-removed"> 543      */</span>
<span class="line-removed"> 544     private void doAcquireSharedInterruptibly(long arg)</span>
<span class="line-removed"> 545         throws InterruptedException {</span>
<span class="line-removed"> 546         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-removed"> 547         try {</span>
<span class="line-removed"> 548             for (;;) {</span>
<span class="line-removed"> 549                 final Node p = node.predecessor();</span>
<span class="line-removed"> 550                 if (p == head) {</span>
<span class="line-removed"> 551                     long r = tryAcquireShared(arg);</span>
<span class="line-removed"> 552                     if (r &gt;= 0) {</span>
<span class="line-removed"> 553                         setHeadAndPropagate(node, r);</span>
<span class="line-removed"> 554                         p.next = null; // help GC</span>
<span class="line-removed"> 555                         return;</span>
 556                     }

 557                 }
<span class="line-modified"> 558                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-modified"> 559                     parkAndCheckInterrupt())</span>
<span class="line-removed"> 560                     throw new InterruptedException();</span>
 561             }
<span class="line-removed"> 562         } catch (Throwable t) {</span>
<span class="line-removed"> 563             cancelAcquire(node);</span>
<span class="line-removed"> 564             throw t;</span>
 565         }
 566     }
 567 
 568     /**
<span class="line-modified"> 569      * Acquires in shared timed mode.</span>
 570      *
<span class="line-modified"> 571      * @param arg the acquire argument</span>
<span class="line-modified"> 572      * @param nanosTimeout max wait time</span>
<span class="line-modified"> 573      * @return {@code true} if acquired</span>
 574      */
<span class="line-modified"> 575     private boolean doAcquireSharedNanos(long arg, long nanosTimeout)</span>
<span class="line-modified"> 576             throws InterruptedException {</span>
<span class="line-modified"> 577         if (nanosTimeout &lt;= 0L)</span>
<span class="line-modified"> 578             return false;</span>
<span class="line-modified"> 579         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified"> 580         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-modified"> 581         try {</span>
<span class="line-modified"> 582             for (;;) {</span>
<span class="line-modified"> 583                 final Node p = node.predecessor();</span>
<span class="line-modified"> 584                 if (p == head) {</span>
<span class="line-modified"> 585                     long r = tryAcquireShared(arg);</span>
<span class="line-modified"> 586                     if (r &gt;= 0) {</span>
<span class="line-modified"> 587                         setHeadAndPropagate(node, r);</span>
<span class="line-removed"> 588                         p.next = null; // help GC</span>
<span class="line-removed"> 589                         return true;</span>
<span class="line-removed"> 590                     }</span>
<span class="line-removed"> 591                 }</span>
<span class="line-removed"> 592                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="line-removed"> 593                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-removed"> 594                     cancelAcquire(node);</span>
<span class="line-removed"> 595                     return false;</span>
<span class="line-removed"> 596                 }</span>
<span class="line-removed"> 597                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 598                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed"> 599                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed"> 600                 if (Thread.interrupted())</span>
<span class="line-removed"> 601                     throw new InterruptedException();</span>
<span class="line-removed"> 602             }</span>
<span class="line-removed"> 603         } catch (Throwable t) {</span>
<span class="line-removed"> 604             cancelAcquire(node);</span>
<span class="line-removed"> 605             throw t;</span>
 606         }

 607     }
 608 
 609     // Main exported methods
 610 
 611     /**
 612      * Attempts to acquire in exclusive mode. This method should query
 613      * if the state of the object permits it to be acquired in the
 614      * exclusive mode, and if so to acquire it.
 615      *
 616      * &lt;p&gt;This method is always invoked by the thread performing
 617      * acquire.  If this method reports failure, the acquire method
 618      * may queue the thread, if it is not already queued, until it is
 619      * signalled by a release from some other thread. This can be used
 620      * to implement method {@link Lock#tryLock()}.
 621      *
 622      * &lt;p&gt;The default
 623      * implementation throws {@link UnsupportedOperationException}.
 624      *
 625      * @param arg the acquire argument. This value is always the one
 626      *        passed to an acquire method, or is the value saved on entry
</pre>
<hr />
<pre>
 739      *         {@code false} otherwise
 740      * @throws UnsupportedOperationException if conditions are not supported
 741      */
 742     protected boolean isHeldExclusively() {
 743         throw new UnsupportedOperationException();
 744     }
 745 
 746     /**
 747      * Acquires in exclusive mode, ignoring interrupts.  Implemented
 748      * by invoking at least once {@link #tryAcquire},
 749      * returning on success.  Otherwise the thread is queued, possibly
 750      * repeatedly blocking and unblocking, invoking {@link
 751      * #tryAcquire} until success.  This method can be used
 752      * to implement method {@link Lock#lock}.
 753      *
 754      * @param arg the acquire argument.  This value is conveyed to
 755      *        {@link #tryAcquire} but is otherwise uninterpreted and
 756      *        can represent anything you like.
 757      */
 758     public final void acquire(long arg) {
<span class="line-modified"> 759         if (!tryAcquire(arg) &amp;&amp;</span>
<span class="line-modified"> 760             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span>
<span class="line-removed"> 761             selfInterrupt();</span>
 762     }
 763 
 764     /**
 765      * Acquires in exclusive mode, aborting if interrupted.
 766      * Implemented by first checking interrupt status, then invoking
 767      * at least once {@link #tryAcquire}, returning on
 768      * success.  Otherwise the thread is queued, possibly repeatedly
 769      * blocking and unblocking, invoking {@link #tryAcquire}
 770      * until success or the thread is interrupted.  This method can be
 771      * used to implement method {@link Lock#lockInterruptibly}.
 772      *
 773      * @param arg the acquire argument.  This value is conveyed to
 774      *        {@link #tryAcquire} but is otherwise uninterpreted and
 775      *        can represent anything you like.
 776      * @throws InterruptedException if the current thread is interrupted
 777      */
 778     public final void acquireInterruptibly(long arg)
<span class="line-modified"> 779             throws InterruptedException {</span>
<span class="line-modified"> 780         if (Thread.interrupted())</span>

 781             throw new InterruptedException();
<span class="line-removed"> 782         if (!tryAcquire(arg))</span>
<span class="line-removed"> 783             doAcquireInterruptibly(arg);</span>
 784     }
 785 
 786     /**
 787      * Attempts to acquire in exclusive mode, aborting if interrupted,
 788      * and failing if the given timeout elapses.  Implemented by first
 789      * checking interrupt status, then invoking at least once {@link
 790      * #tryAcquire}, returning on success.  Otherwise, the thread is
 791      * queued, possibly repeatedly blocking and unblocking, invoking
 792      * {@link #tryAcquire} until success or the thread is interrupted
 793      * or the timeout elapses.  This method can be used to implement
 794      * method {@link Lock#tryLock(long, TimeUnit)}.
 795      *
 796      * @param arg the acquire argument.  This value is conveyed to
 797      *        {@link #tryAcquire} but is otherwise uninterpreted and
 798      *        can represent anything you like.
 799      * @param nanosTimeout the maximum number of nanoseconds to wait
 800      * @return {@code true} if acquired; {@code false} if timed out
 801      * @throws InterruptedException if the current thread is interrupted
 802      */
 803     public final boolean tryAcquireNanos(long arg, long nanosTimeout)
<span class="line-modified"> 804             throws InterruptedException {</span>
<span class="line-modified"> 805         if (Thread.interrupted())</span>
<span class="line-modified"> 806             throw new InterruptedException();</span>
<span class="line-modified"> 807         return tryAcquire(arg) ||</span>
<span class="line-modified"> 808             doAcquireNanos(arg, nanosTimeout);</span>









 809     }
 810 
 811     /**
 812      * Releases in exclusive mode.  Implemented by unblocking one or
 813      * more threads if {@link #tryRelease} returns true.
 814      * This method can be used to implement method {@link Lock#unlock}.
 815      *
 816      * @param arg the release argument.  This value is conveyed to
 817      *        {@link #tryRelease} but is otherwise uninterpreted and
 818      *        can represent anything you like.
 819      * @return the value returned from {@link #tryRelease}
 820      */
 821     public final boolean release(long arg) {
 822         if (tryRelease(arg)) {
<span class="line-modified"> 823             Node h = head;</span>
<span class="line-removed"> 824             if (h != null &amp;&amp; h.waitStatus != 0)</span>
<span class="line-removed"> 825                 unparkSuccessor(h);</span>
 826             return true;
 827         }
 828         return false;
 829     }
 830 
 831     /**
 832      * Acquires in shared mode, ignoring interrupts.  Implemented by
 833      * first invoking at least once {@link #tryAcquireShared},
 834      * returning on success.  Otherwise the thread is queued, possibly
 835      * repeatedly blocking and unblocking, invoking {@link
 836      * #tryAcquireShared} until success.
 837      *
 838      * @param arg the acquire argument.  This value is conveyed to
 839      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 840      *        and can represent anything you like.
 841      */
 842     public final void acquireShared(long arg) {
 843         if (tryAcquireShared(arg) &lt; 0)
<span class="line-modified"> 844             doAcquireShared(arg);</span>
 845     }
 846 
 847     /**
 848      * Acquires in shared mode, aborting if interrupted.  Implemented
 849      * by first checking interrupt status, then invoking at least once
 850      * {@link #tryAcquireShared}, returning on success.  Otherwise the
 851      * thread is queued, possibly repeatedly blocking and unblocking,
 852      * invoking {@link #tryAcquireShared} until success or the thread
 853      * is interrupted.
 854      * @param arg the acquire argument.
 855      * This value is conveyed to {@link #tryAcquireShared} but is
 856      * otherwise uninterpreted and can represent anything
 857      * you like.
 858      * @throws InterruptedException if the current thread is interrupted
 859      */
 860     public final void acquireSharedInterruptibly(long arg)
<span class="line-modified"> 861             throws InterruptedException {</span>
<span class="line-modified"> 862         if (Thread.interrupted())</span>


 863             throw new InterruptedException();
<span class="line-removed"> 864         if (tryAcquireShared(arg) &lt; 0)</span>
<span class="line-removed"> 865             doAcquireSharedInterruptibly(arg);</span>
 866     }
 867 
 868     /**
 869      * Attempts to acquire in shared mode, aborting if interrupted, and
 870      * failing if the given timeout elapses.  Implemented by first
 871      * checking interrupt status, then invoking at least once {@link
 872      * #tryAcquireShared}, returning on success.  Otherwise, the
 873      * thread is queued, possibly repeatedly blocking and unblocking,
 874      * invoking {@link #tryAcquireShared} until success or the thread
 875      * is interrupted or the timeout elapses.
 876      *
 877      * @param arg the acquire argument.  This value is conveyed to
 878      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 879      *        and can represent anything you like.
 880      * @param nanosTimeout the maximum number of nanoseconds to wait
 881      * @return {@code true} if acquired; {@code false} if timed out
 882      * @throws InterruptedException if the current thread is interrupted
 883      */
 884     public final boolean tryAcquireSharedNanos(long arg, long nanosTimeout)
 885             throws InterruptedException {
<span class="line-modified"> 886         if (Thread.interrupted())</span>
<span class="line-modified"> 887             throw new InterruptedException();</span>
<span class="line-modified"> 888         return tryAcquireShared(arg) &gt;= 0 ||</span>
<span class="line-modified"> 889             doAcquireSharedNanos(arg, nanosTimeout);</span>









 890     }
 891 
 892     /**
 893      * Releases in shared mode.  Implemented by unblocking one or more
 894      * threads if {@link #tryReleaseShared} returns true.
 895      *
 896      * @param arg the release argument.  This value is conveyed to
 897      *        {@link #tryReleaseShared} but is otherwise uninterpreted
 898      *        and can represent anything you like.
 899      * @return the value returned from {@link #tryReleaseShared}
 900      */
 901     public final boolean releaseShared(long arg) {
 902         if (tryReleaseShared(arg)) {
<span class="line-modified"> 903             doReleaseShared();</span>
 904             return true;
 905         }
 906         return false;
 907     }
 908 
 909     // Queue inspection methods
 910 
 911     /**
 912      * Queries whether any threads are waiting to acquire. Note that
 913      * because cancellations due to interrupts and timeouts may occur
 914      * at any time, a {@code true} return does not guarantee that any
 915      * other thread will ever acquire.
 916      *
 917      * @return {@code true} if there may be other threads waiting to acquire
 918      */
 919     public final boolean hasQueuedThreads() {
 920         for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<span class="line-modified"> 921             if (p.waitStatus &lt;= 0)</span>
 922                 return true;
 923         return false;
 924     }
 925 
 926     /**
 927      * Queries whether any threads have ever contended to acquire this
 928      * synchronizer; that is, if an acquire method has ever blocked.
 929      *
 930      * &lt;p&gt;In this implementation, this operation returns in
 931      * constant time.
 932      *
 933      * @return {@code true} if there has ever been contention
 934      */
 935     public final boolean hasContended() {
 936         return head != null;
 937     }
 938 
 939     /**
 940      * Returns the first (longest-waiting) thread in the queue, or
 941      * {@code null} if no threads are currently queued.
 942      *
 943      * &lt;p&gt;In this implementation, this operation normally returns in
 944      * constant time, but may iterate upon contention if other threads are
 945      * concurrently modifying the queue.
 946      *
 947      * @return the first (longest-waiting) thread in the queue, or
 948      *         {@code null} if no threads are currently queued
 949      */
 950     public final Thread getFirstQueuedThread() {
<span class="line-modified"> 951         // handle only fast path, else relay</span>
<span class="line-modified"> 952         return (head == tail) ? null : fullGetFirstQueuedThread();</span>
<span class="line-modified"> 953     }</span>
<span class="line-modified"> 954 </span>
<span class="line-modified"> 955     /**</span>
<span class="line-modified"> 956      * Version of getFirstQueuedThread called when fastpath fails.</span>
<span class="line-modified"> 957      */</span>
<span class="line-modified"> 958     private Thread fullGetFirstQueuedThread() {</span>
<span class="line-removed"> 959         /*</span>
<span class="line-removed"> 960          * The first node is normally head.next. Try to get its</span>
<span class="line-removed"> 961          * thread field, ensuring consistent reads: If thread</span>
<span class="line-removed"> 962          * field is nulled out or s.prev is no longer head, then</span>
<span class="line-removed"> 963          * some other thread(s) concurrently performed setHead in</span>
<span class="line-removed"> 964          * between some of our reads. We try this twice before</span>
<span class="line-removed"> 965          * resorting to traversal.</span>
<span class="line-removed"> 966          */</span>
<span class="line-removed"> 967         Node h, s;</span>
<span class="line-removed"> 968         Thread st;</span>
<span class="line-removed"> 969         if (((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-removed"> 970              s.prev == head &amp;&amp; (st = s.thread) != null) ||</span>
<span class="line-removed"> 971             ((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-removed"> 972              s.prev == head &amp;&amp; (st = s.thread) != null))</span>
<span class="line-removed"> 973             return st;</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975         /*</span>
<span class="line-removed"> 976          * Head&#39;s next field might not have been set yet, or may have</span>
<span class="line-removed"> 977          * been unset after setHead. So we must check to see if tail</span>
<span class="line-removed"> 978          * is actually first node. If not, we continue on, safely</span>
<span class="line-removed"> 979          * traversing from tail back to head to find first,</span>
<span class="line-removed"> 980          * guaranteeing termination.</span>
<span class="line-removed"> 981          */</span>
<span class="line-removed"> 982 </span>
<span class="line-removed"> 983         Thread firstThread = null;</span>
<span class="line-removed"> 984         for (Node p = tail; p != null &amp;&amp; p != head; p = p.prev) {</span>
<span class="line-removed"> 985             Thread t = p.thread;</span>
<span class="line-removed"> 986             if (t != null)</span>
<span class="line-removed"> 987                 firstThread = t;</span>
 988         }
<span class="line-modified"> 989         return firstThread;</span>
 990     }
 991 
 992     /**
 993      * Returns true if the given thread is currently queued.
 994      *
 995      * &lt;p&gt;This implementation traverses the queue to determine
 996      * presence of the given thread.
 997      *
 998      * @param thread the thread
 999      * @return {@code true} if the given thread is on the queue
1000      * @throws NullPointerException if the thread is null
1001      */
1002     public final boolean isQueued(Thread thread) {
1003         if (thread == null)
1004             throw new NullPointerException();
1005         for (Node p = tail; p != null; p = p.prev)
<span class="line-modified">1006             if (p.thread == thread)</span>
1007                 return true;
1008         return false;
1009     }
1010 
1011     /**
1012      * Returns {@code true} if the apparent first queued thread, if one
1013      * exists, is waiting in exclusive mode.  If this method returns
1014      * {@code true}, and the current thread is attempting to acquire in
1015      * shared mode (that is, this method is invoked from {@link
1016      * #tryAcquireShared}) then it is guaranteed that the current thread
1017      * is not the first queued thread.  Used only as a heuristic in
1018      * ReentrantReadWriteLock.
1019      */
1020     final boolean apparentlyFirstQueuedIsExclusive() {
1021         Node h, s;
<span class="line-modified">1022         return (h = head) != null &amp;&amp;</span>
<span class="line-modified">1023             (s = h.next)  != null &amp;&amp;</span>
<span class="line-removed">1024             !s.isShared()         &amp;&amp;</span>
<span class="line-removed">1025             s.thread != null;</span>
1026     }
1027 
1028     /**
1029      * Queries whether any threads have been waiting to acquire longer
1030      * than the current thread.
1031      *
1032      * &lt;p&gt;An invocation of this method is equivalent to (but may be
1033      * more efficient than):
1034      * &lt;pre&gt; {@code
1035      * getFirstQueuedThread() != Thread.currentThread()
1036      *   &amp;&amp; hasQueuedThreads()}&lt;/pre&gt;
1037      *
1038      * &lt;p&gt;Note that because cancellations due to interrupts and
1039      * timeouts may occur at any time, a {@code true} return does not
1040      * guarantee that some other thread will acquire before the current
1041      * thread.  Likewise, it is possible for another thread to win a
1042      * race to enqueue after this method has returned {@code false},
1043      * due to the queue being empty.
1044      *
1045      * &lt;p&gt;This method is designed to be used by a fair synchronizer to
1046      * avoid &lt;a href=&quot;AbstractQueuedSynchronizer.html#barging&quot;&gt;barging&lt;/a&gt;.
1047      * Such a synchronizer&#39;s {@link #tryAcquire} method should return
1048      * {@code false}, and its {@link #tryAcquireShared} method should
1049      * return a negative value, if this method returns {@code true}
1050      * (unless this is a reentrant acquire).  For example, the {@code
1051      * tryAcquire} method for a fair, reentrant, exclusive mode
1052      * synchronizer might look like this:
1053      *
1054      * &lt;pre&gt; {@code
<span class="line-modified">1055      * protected boolean tryAcquire(int arg) {</span>
1056      *   if (isHeldExclusively()) {
1057      *     // A reentrant acquire; increment hold count
1058      *     return true;
1059      *   } else if (hasQueuedPredecessors()) {
1060      *     return false;
1061      *   } else {
1062      *     // try to acquire normally
1063      *   }
1064      * }}&lt;/pre&gt;
1065      *
1066      * @return {@code true} if there is a queued thread preceding the
1067      *         current thread, and {@code false} if the current thread
1068      *         is at the head of the queue or the queue is empty
1069      * @since 1.7
1070      */
1071     public final boolean hasQueuedPredecessors() {
<span class="line-modified">1072         Node h, s;</span>
<span class="line-modified">1073         if ((h = head) != null) {</span>
<span class="line-modified">1074             if ((s = h.next) == null || s.waitStatus &gt; 0) {</span>
<span class="line-modified">1075                 s = null; // traverse in case of concurrent cancellation</span>
<span class="line-modified">1076                 for (Node p = tail; p != h &amp;&amp; p != null; p = p.prev) {</span>
<span class="line-modified">1077                     if (p.waitStatus &lt;= 0)</span>
<span class="line-removed">1078                         s = p;</span>
<span class="line-removed">1079                 }</span>
<span class="line-removed">1080             }</span>
<span class="line-removed">1081             if (s != null &amp;&amp; s.thread != Thread.currentThread())</span>
<span class="line-removed">1082                 return true;</span>
<span class="line-removed">1083         }</span>
<span class="line-removed">1084         return false;</span>
1085     }
1086 
1087     // Instrumentation and monitoring methods
1088 
1089     /**
1090      * Returns an estimate of the number of threads waiting to
1091      * acquire.  The value is only an estimate because the number of
1092      * threads may change dynamically while this method traverses
1093      * internal data structures.  This method is designed for use in
1094      * monitoring system state, not for synchronization control.
1095      *
1096      * @return the estimated number of threads waiting to acquire
1097      */
1098     public final int getQueueLength() {
1099         int n = 0;
1100         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1101             if (p.thread != null)</span>
1102                 ++n;
1103         }
1104         return n;
1105     }
1106 
1107     /**
1108      * Returns a collection containing threads that may be waiting to
1109      * acquire.  Because the actual set of threads may change
1110      * dynamically while constructing this result, the returned
1111      * collection is only a best-effort estimate.  The elements of the
1112      * returned collection are in no particular order.  This method is
1113      * designed to facilitate construction of subclasses that provide
1114      * more extensive monitoring facilities.
1115      *
1116      * @return the collection of threads
1117      */
1118     public final Collection&lt;Thread&gt; getQueuedThreads() {
1119         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1120         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1121             Thread t = p.thread;</span>
1122             if (t != null)
1123                 list.add(t);
1124         }
1125         return list;
1126     }
1127 
1128     /**
1129      * Returns a collection containing threads that may be waiting to
1130      * acquire in exclusive mode. This has the same properties
1131      * as {@link #getQueuedThreads} except that it only returns
1132      * those threads waiting due to an exclusive acquire.
1133      *
1134      * @return the collection of threads
1135      */
1136     public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
1137         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1138         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1139             if (!p.isShared()) {</span>
<span class="line-modified">1140                 Thread t = p.thread;</span>
1141                 if (t != null)
1142                     list.add(t);
1143             }
1144         }
1145         return list;
1146     }
1147 
1148     /**
1149      * Returns a collection containing threads that may be waiting to
1150      * acquire in shared mode. This has the same properties
1151      * as {@link #getQueuedThreads} except that it only returns
1152      * those threads waiting due to a shared acquire.
1153      *
1154      * @return the collection of threads
1155      */
1156     public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
1157         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1158         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1159             if (p.isShared()) {</span>
<span class="line-modified">1160                 Thread t = p.thread;</span>
1161                 if (t != null)
1162                     list.add(t);
1163             }
1164         }
1165         return list;
1166     }
1167 
1168     /**
1169      * Returns a string identifying this synchronizer, as well as its state.
1170      * The state, in brackets, includes the String {@code &quot;State =&quot;}
1171      * followed by the current value of {@link #getState}, and either
1172      * {@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
1173      * queue is empty.
1174      *
1175      * @return a string identifying this synchronizer, as well as its state
1176      */
1177     public String toString() {
1178         return super.toString()
1179             + &quot;[State = &quot; + getState() + &quot;, &quot;
1180             + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
1181     }
1182 
<span class="line-removed">1183 </span>
<span class="line-removed">1184     // Internal support methods for Conditions</span>
<span class="line-removed">1185 </span>
<span class="line-removed">1186     /**</span>
<span class="line-removed">1187      * Returns true if a node, always one that was initially placed on</span>
<span class="line-removed">1188      * a condition queue, is now waiting to reacquire on sync queue.</span>
<span class="line-removed">1189      * @param node the node</span>
<span class="line-removed">1190      * @return true if is reacquiring</span>
<span class="line-removed">1191      */</span>
<span class="line-removed">1192     final boolean isOnSyncQueue(Node node) {</span>
<span class="line-removed">1193         if (node.waitStatus == Node.CONDITION || node.prev == null)</span>
<span class="line-removed">1194             return false;</span>
<span class="line-removed">1195         if (node.next != null) // If has successor, it must be on queue</span>
<span class="line-removed">1196             return true;</span>
<span class="line-removed">1197         /*</span>
<span class="line-removed">1198          * node.prev can be non-null, but not yet on queue because</span>
<span class="line-removed">1199          * the CAS to place it on queue can fail. So we have to</span>
<span class="line-removed">1200          * traverse from tail to make sure it actually made it.  It</span>
<span class="line-removed">1201          * will always be near the tail in calls to this method, and</span>
<span class="line-removed">1202          * unless the CAS failed (which is unlikely), it will be</span>
<span class="line-removed">1203          * there, so we hardly ever traverse much.</span>
<span class="line-removed">1204          */</span>
<span class="line-removed">1205         return findNodeFromTail(node);</span>
<span class="line-removed">1206     }</span>
<span class="line-removed">1207 </span>
<span class="line-removed">1208     /**</span>
<span class="line-removed">1209      * Returns true if node is on sync queue by searching backwards from tail.</span>
<span class="line-removed">1210      * Called only when needed by isOnSyncQueue.</span>
<span class="line-removed">1211      * @return true if present</span>
<span class="line-removed">1212      */</span>
<span class="line-removed">1213     private boolean findNodeFromTail(Node node) {</span>
<span class="line-removed">1214         // We check for node first, since it&#39;s likely to be at or near tail.</span>
<span class="line-removed">1215         // tail is known to be non-null, so we could re-order to &quot;save&quot;</span>
<span class="line-removed">1216         // one null check, but we leave it this way to help the VM.</span>
<span class="line-removed">1217         for (Node p = tail;;) {</span>
<span class="line-removed">1218             if (p == node)</span>
<span class="line-removed">1219                 return true;</span>
<span class="line-removed">1220             if (p == null)</span>
<span class="line-removed">1221                 return false;</span>
<span class="line-removed">1222             p = p.prev;</span>
<span class="line-removed">1223         }</span>
<span class="line-removed">1224     }</span>
<span class="line-removed">1225 </span>
<span class="line-removed">1226     /**</span>
<span class="line-removed">1227      * Transfers a node from a condition queue onto sync queue.</span>
<span class="line-removed">1228      * Returns true if successful.</span>
<span class="line-removed">1229      * @param node the node</span>
<span class="line-removed">1230      * @return true if successfully transferred (else the node was</span>
<span class="line-removed">1231      * cancelled before signal)</span>
<span class="line-removed">1232      */</span>
<span class="line-removed">1233     final boolean transferForSignal(Node node) {</span>
<span class="line-removed">1234         /*</span>
<span class="line-removed">1235          * If cannot change waitStatus, the node has been cancelled.</span>
<span class="line-removed">1236          */</span>
<span class="line-removed">1237         if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))</span>
<span class="line-removed">1238             return false;</span>
<span class="line-removed">1239 </span>
<span class="line-removed">1240         /*</span>
<span class="line-removed">1241          * Splice onto queue and try to set waitStatus of predecessor to</span>
<span class="line-removed">1242          * indicate that thread is (probably) waiting. If cancelled or</span>
<span class="line-removed">1243          * attempt to set waitStatus fails, wake up to resync (in which</span>
<span class="line-removed">1244          * case the waitStatus can be transiently and harmlessly wrong).</span>
<span class="line-removed">1245          */</span>
<span class="line-removed">1246         Node p = enq(node);</span>
<span class="line-removed">1247         int ws = p.waitStatus;</span>
<span class="line-removed">1248         if (ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span>
<span class="line-removed">1249             LockSupport.unpark(node.thread);</span>
<span class="line-removed">1250         return true;</span>
<span class="line-removed">1251     }</span>
<span class="line-removed">1252 </span>
<span class="line-removed">1253     /**</span>
<span class="line-removed">1254      * Transfers node, if necessary, to sync queue after a cancelled wait.</span>
<span class="line-removed">1255      * Returns true if thread was cancelled before being signalled.</span>
<span class="line-removed">1256      *</span>
<span class="line-removed">1257      * @param node the node</span>
<span class="line-removed">1258      * @return true if cancelled before the node was signalled</span>
<span class="line-removed">1259      */</span>
<span class="line-removed">1260     final boolean transferAfterCancelledWait(Node node) {</span>
<span class="line-removed">1261         if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {</span>
<span class="line-removed">1262             enq(node);</span>
<span class="line-removed">1263             return true;</span>
<span class="line-removed">1264         }</span>
<span class="line-removed">1265         /*</span>
<span class="line-removed">1266          * If we lost out to a signal(), then we can&#39;t proceed</span>
<span class="line-removed">1267          * until it finishes its enq().  Cancelling during an</span>
<span class="line-removed">1268          * incomplete transfer is both rare and transient, so just</span>
<span class="line-removed">1269          * spin.</span>
<span class="line-removed">1270          */</span>
<span class="line-removed">1271         while (!isOnSyncQueue(node))</span>
<span class="line-removed">1272             Thread.yield();</span>
<span class="line-removed">1273         return false;</span>
<span class="line-removed">1274     }</span>
<span class="line-removed">1275 </span>
<span class="line-removed">1276     /**</span>
<span class="line-removed">1277      * Invokes release with current state value; returns saved state.</span>
<span class="line-removed">1278      * Cancels node and throws exception on failure.</span>
<span class="line-removed">1279      * @param node the condition node for this wait</span>
<span class="line-removed">1280      * @return previous sync state</span>
<span class="line-removed">1281      */</span>
<span class="line-removed">1282     final long fullyRelease(Node node) {</span>
<span class="line-removed">1283         try {</span>
<span class="line-removed">1284             long savedState = getState();</span>
<span class="line-removed">1285             if (release(savedState))</span>
<span class="line-removed">1286                 return savedState;</span>
<span class="line-removed">1287             throw new IllegalMonitorStateException();</span>
<span class="line-removed">1288         } catch (Throwable t) {</span>
<span class="line-removed">1289             node.waitStatus = Node.CANCELLED;</span>
<span class="line-removed">1290             throw t;</span>
<span class="line-removed">1291         }</span>
<span class="line-removed">1292     }</span>
<span class="line-removed">1293 </span>
1294     // Instrumentation methods for conditions
1295 
1296     /**
1297      * Queries whether the given ConditionObject
1298      * uses this synchronizer as its lock.
1299      *
1300      * @param condition the condition
1301      * @return {@code true} if owned
1302      * @throws NullPointerException if the condition is null
1303      */
1304     public final boolean owns(ConditionObject condition) {
1305         return condition.isOwnedBy(this);
1306     }
1307 
1308     /**
1309      * Queries whether any threads are waiting on the given condition
1310      * associated with this synchronizer. Note that because timeouts
1311      * and interrupts may occur at any time, a {@code true} return
1312      * does not guarantee that a future {@code signal} will awaken
1313      * any threads.  This method is designed primarily for use in
</pre>
<hr />
<pre>
1367      */
1368     public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition) {
1369         if (!owns(condition))
1370             throw new IllegalArgumentException(&quot;Not owner&quot;);
1371         return condition.getWaitingThreads();
1372     }
1373 
1374     /**
1375      * Condition implementation for a {@link AbstractQueuedLongSynchronizer}
1376      * serving as the basis of a {@link Lock} implementation.
1377      *
1378      * &lt;p&gt;Method documentation for this class describes mechanics,
1379      * not behavioral specifications from the point of view of Lock
1380      * and Condition users. Exported versions of this class will in
1381      * general need to be accompanied by documentation describing
1382      * condition semantics that rely on those of the associated
1383      * {@code AbstractQueuedLongSynchronizer}.
1384      *
1385      * &lt;p&gt;This class is Serializable, but all fields are transient,
1386      * so deserialized conditions have no waiters.
<span class="line-removed">1387      *</span>
<span class="line-removed">1388      * @since 1.6</span>
1389      */
1390     public class ConditionObject implements Condition, java.io.Serializable {
1391         private static final long serialVersionUID = 1173984872572414699L;
1392         /** First node of condition queue. */
<span class="line-modified">1393         private transient Node firstWaiter;</span>
1394         /** Last node of condition queue. */
<span class="line-modified">1395         private transient Node lastWaiter;</span>
1396 
1397         /**
1398          * Creates a new {@code ConditionObject} instance.
1399          */
1400         public ConditionObject() { }
1401 
<span class="line-modified">1402         // Internal methods</span>
<span class="line-removed">1403 </span>
<span class="line-removed">1404         /**</span>
<span class="line-removed">1405          * Adds a new waiter to wait queue.</span>
<span class="line-removed">1406          * @return its new wait node</span>
<span class="line-removed">1407          */</span>
<span class="line-removed">1408         private Node addConditionWaiter() {</span>
<span class="line-removed">1409             if (!isHeldExclusively())</span>
<span class="line-removed">1410                 throw new IllegalMonitorStateException();</span>
<span class="line-removed">1411             Node t = lastWaiter;</span>
<span class="line-removed">1412             // If lastWaiter is cancelled, clean out.</span>
<span class="line-removed">1413             if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span>
<span class="line-removed">1414                 unlinkCancelledWaiters();</span>
<span class="line-removed">1415                 t = lastWaiter;</span>
<span class="line-removed">1416             }</span>
<span class="line-removed">1417 </span>
<span class="line-removed">1418             Node node = new Node(Node.CONDITION);</span>
<span class="line-removed">1419 </span>
<span class="line-removed">1420             if (t == null)</span>
<span class="line-removed">1421                 firstWaiter = node;</span>
<span class="line-removed">1422             else</span>
<span class="line-removed">1423                 t.nextWaiter = node;</span>
<span class="line-removed">1424             lastWaiter = node;</span>
<span class="line-removed">1425             return node;</span>
<span class="line-removed">1426         }</span>
1427 
1428         /**
<span class="line-modified">1429          * Removes and transfers nodes until hit non-cancelled one or</span>
<span class="line-removed">1430          * null. Split out from signal in part to encourage compilers</span>
<span class="line-removed">1431          * to inline the case of no waiters.</span>
<span class="line-removed">1432          * @param first (non-null) the first node on condition queue</span>
1433          */
<span class="line-modified">1434         private void doSignal(Node first) {</span>
<span class="line-modified">1435             do {</span>
<span class="line-modified">1436                 if ( (firstWaiter = first.nextWaiter) == null)</span>

1437                     lastWaiter = null;
<span class="line-modified">1438                 first.nextWaiter = null;</span>
<span class="line-modified">1439             } while (!transferForSignal(first) &amp;&amp;</span>
<span class="line-modified">1440                      (first = firstWaiter) != null);</span>
<span class="line-modified">1441         }</span>
<span class="line-removed">1442 </span>
<span class="line-removed">1443         /**</span>
<span class="line-removed">1444          * Removes and transfers all nodes.</span>
<span class="line-removed">1445          * @param first (non-null) the first node on condition queue</span>
<span class="line-removed">1446          */</span>
<span class="line-removed">1447         private void doSignalAll(Node first) {</span>
<span class="line-removed">1448             lastWaiter = firstWaiter = null;</span>
<span class="line-removed">1449             do {</span>
<span class="line-removed">1450                 Node next = first.nextWaiter;</span>
<span class="line-removed">1451                 first.nextWaiter = null;</span>
<span class="line-removed">1452                 transferForSignal(first);</span>
<span class="line-removed">1453                 first = next;</span>
<span class="line-removed">1454             } while (first != null);</span>
<span class="line-removed">1455         }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457         /**</span>
<span class="line-removed">1458          * Unlinks cancelled waiter nodes from condition queue.</span>
<span class="line-removed">1459          * Called only while holding lock. This is called when</span>
<span class="line-removed">1460          * cancellation occurred during condition wait, and upon</span>
<span class="line-removed">1461          * insertion of a new waiter when lastWaiter is seen to have</span>
<span class="line-removed">1462          * been cancelled. This method is needed to avoid garbage</span>
<span class="line-removed">1463          * retention in the absence of signals. So even though it may</span>
<span class="line-removed">1464          * require a full traversal, it comes into play only when</span>
<span class="line-removed">1465          * timeouts or cancellations occur in the absence of</span>
<span class="line-removed">1466          * signals. It traverses all nodes rather than stopping at a</span>
<span class="line-removed">1467          * particular target to unlink all pointers to garbage nodes</span>
<span class="line-removed">1468          * without requiring many re-traversals during cancellation</span>
<span class="line-removed">1469          * storms.</span>
<span class="line-removed">1470          */</span>
<span class="line-removed">1471         private void unlinkCancelledWaiters() {</span>
<span class="line-removed">1472             Node t = firstWaiter;</span>
<span class="line-removed">1473             Node trail = null;</span>
<span class="line-removed">1474             while (t != null) {</span>
<span class="line-removed">1475                 Node next = t.nextWaiter;</span>
<span class="line-removed">1476                 if (t.waitStatus != Node.CONDITION) {</span>
<span class="line-removed">1477                     t.nextWaiter = null;</span>
<span class="line-removed">1478                     if (trail == null)</span>
<span class="line-removed">1479                         firstWaiter = next;</span>
<span class="line-removed">1480                     else</span>
<span class="line-removed">1481                         trail.nextWaiter = next;</span>
<span class="line-removed">1482                     if (next == null)</span>
<span class="line-removed">1483                         lastWaiter = trail;</span>
1484                 }
<span class="line-modified">1485                 else</span>
<span class="line-removed">1486                     trail = t;</span>
<span class="line-removed">1487                 t = next;</span>
1488             }
1489         }
1490 
<span class="line-removed">1491         // public methods</span>
<span class="line-removed">1492 </span>
1493         /**
1494          * Moves the longest-waiting thread, if one exists, from the
1495          * wait queue for this condition to the wait queue for the
1496          * owning lock.
1497          *
1498          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1499          *         returns {@code false}
1500          */
1501         public final void signal() {

1502             if (!isHeldExclusively())
1503                 throw new IllegalMonitorStateException();
<span class="line-removed">1504             Node first = firstWaiter;</span>
1505             if (first != null)
<span class="line-modified">1506                 doSignal(first);</span>
1507         }
1508 
1509         /**
1510          * Moves all threads from the wait queue for this condition to
1511          * the wait queue for the owning lock.
1512          *
1513          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1514          *         returns {@code false}
1515          */
1516         public final void signalAll() {

1517             if (!isHeldExclusively())
1518                 throw new IllegalMonitorStateException();
<span class="line-removed">1519             Node first = firstWaiter;</span>
1520             if (first != null)
<span class="line-modified">1521                 doSignalAll(first);</span>





























































1522         }
1523 
1524         /**
1525          * Implements uninterruptible condition wait.
1526          * &lt;ol&gt;
1527          * &lt;li&gt;Save lock state returned by {@link #getState}.
1528          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1529          *     throwing IllegalMonitorStateException if it fails.
1530          * &lt;li&gt;Block until signalled.
1531          * &lt;li&gt;Reacquire by invoking specialized version of
1532          *     {@link #acquire} with saved state as argument.
1533          * &lt;/ol&gt;
1534          */
1535         public final void awaitUninterruptibly() {
<span class="line-modified">1536             Node node = addConditionWaiter();</span>
<span class="line-modified">1537             long savedState = fullyRelease(node);</span>

1538             boolean interrupted = false;
<span class="line-modified">1539             while (!isOnSyncQueue(node)) {</span>
<span class="line-removed">1540                 LockSupport.park(this);</span>
1541                 if (Thread.interrupted())
1542                     interrupted = true;








1543             }
<span class="line-modified">1544             if (acquireQueued(node, savedState) || interrupted)</span>
<span class="line-modified">1545                 selfInterrupt();</span>
<span class="line-modified">1546         }</span>
<span class="line-modified">1547 </span>
<span class="line-modified">1548         /*</span>
<span class="line-removed">1549          * For interruptible waits, we need to track whether to throw</span>
<span class="line-removed">1550          * InterruptedException, if interrupted while blocked on</span>
<span class="line-removed">1551          * condition, versus reinterrupt current thread, if</span>
<span class="line-removed">1552          * interrupted while blocked waiting to re-acquire.</span>
<span class="line-removed">1553          */</span>
<span class="line-removed">1554 </span>
<span class="line-removed">1555         /** Mode meaning to reinterrupt on exit from wait */</span>
<span class="line-removed">1556         private static final int REINTERRUPT =  1;</span>
<span class="line-removed">1557         /** Mode meaning to throw InterruptedException on exit from wait */</span>
<span class="line-removed">1558         private static final int THROW_IE    = -1;</span>
<span class="line-removed">1559 </span>
<span class="line-removed">1560         /**</span>
<span class="line-removed">1561          * Checks for interrupt, returning THROW_IE if interrupted</span>
<span class="line-removed">1562          * before signalled, REINTERRUPT if after signalled, or</span>
<span class="line-removed">1563          * 0 if not interrupted.</span>
<span class="line-removed">1564          */</span>
<span class="line-removed">1565         private int checkInterruptWhileWaiting(Node node) {</span>
<span class="line-removed">1566             return Thread.interrupted() ?</span>
<span class="line-removed">1567                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span>
<span class="line-removed">1568                 0;</span>
<span class="line-removed">1569         }</span>
<span class="line-removed">1570 </span>
<span class="line-removed">1571         /**</span>
<span class="line-removed">1572          * Throws InterruptedException, reinterrupts current thread, or</span>
<span class="line-removed">1573          * does nothing, depending on mode.</span>
<span class="line-removed">1574          */</span>
<span class="line-removed">1575         private void reportInterruptAfterWait(int interruptMode)</span>
<span class="line-removed">1576             throws InterruptedException {</span>
<span class="line-removed">1577             if (interruptMode == THROW_IE)</span>
<span class="line-removed">1578                 throw new InterruptedException();</span>
<span class="line-removed">1579             else if (interruptMode == REINTERRUPT)</span>
<span class="line-removed">1580                 selfInterrupt();</span>
1581         }
1582 
1583         /**
1584          * Implements interruptible condition wait.
1585          * &lt;ol&gt;
1586          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1587          * &lt;li&gt;Save lock state returned by {@link #getState}.
1588          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1589          *     throwing IllegalMonitorStateException if it fails.
1590          * &lt;li&gt;Block until signalled or interrupted.
1591          * &lt;li&gt;Reacquire by invoking specialized version of
1592          *     {@link #acquire} with saved state as argument.
1593          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1594          * &lt;/ol&gt;
1595          */
1596         public final void await() throws InterruptedException {
1597             if (Thread.interrupted())
1598                 throw new InterruptedException();
<span class="line-modified">1599             Node node = addConditionWaiter();</span>
<span class="line-modified">1600             long savedState = fullyRelease(node);</span>
<span class="line-modified">1601             int interruptMode = 0;</span>
<span class="line-modified">1602             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1603                 LockSupport.park(this);</span>
<span class="line-modified">1604                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-modified">1605                     break;</span>



















1606             }
<span class="line-removed">1607             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-removed">1608                 interruptMode = REINTERRUPT;</span>
<span class="line-removed">1609             if (node.nextWaiter != null) // clean up if cancelled</span>
<span class="line-removed">1610                 unlinkCancelledWaiters();</span>
<span class="line-removed">1611             if (interruptMode != 0)</span>
<span class="line-removed">1612                 reportInterruptAfterWait(interruptMode);</span>
1613         }
1614 
1615         /**
1616          * Implements timed condition wait.
1617          * &lt;ol&gt;
1618          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1619          * &lt;li&gt;Save lock state returned by {@link #getState}.
1620          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1621          *     throwing IllegalMonitorStateException if it fails.
1622          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1623          * &lt;li&gt;Reacquire by invoking specialized version of
1624          *     {@link #acquire} with saved state as argument.
1625          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1626          * &lt;/ol&gt;
1627          */
1628         public final long awaitNanos(long nanosTimeout)
1629                 throws InterruptedException {
1630             if (Thread.interrupted())
1631                 throw new InterruptedException();
<span class="line-modified">1632             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="line-modified">1633             // awaitNanos(0) as a way to &quot;yield the lock&quot;.</span>
<span class="line-modified">1634             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">1635             long initialNanos = nanosTimeout;</span>
<span class="line-modified">1636             Node node = addConditionWaiter();</span>
<span class="line-modified">1637             long savedState = fullyRelease(node);</span>
<span class="line-modified">1638             int interruptMode = 0;</span>
<span class="line-modified">1639             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1640                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified">1641                     transferAfterCancelledWait(node);</span>
<span class="line-modified">1642                     break;</span>
<span class="line-modified">1643                 }</span>
<span class="line-removed">1644                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">1645                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">1646                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">1647                     break;</span>
<span class="line-removed">1648                 nanosTimeout = deadline - System.nanoTime();</span>
1649             }
<span class="line-modified">1650             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">1651                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">1652             if (node.nextWaiter != null)</span>
<span class="line-modified">1653                 unlinkCancelledWaiters();</span>
<span class="line-modified">1654             if (interruptMode != 0)</span>
<span class="line-modified">1655                 reportInterruptAfterWait(interruptMode);</span>


1656             long remaining = deadline - System.nanoTime(); // avoid overflow
<span class="line-modified">1657             return (remaining &lt;= initialNanos) ? remaining : Long.MIN_VALUE;</span>
1658         }
1659 
1660         /**
1661          * Implements absolute timed condition wait.
1662          * &lt;ol&gt;
1663          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1664          * &lt;li&gt;Save lock state returned by {@link #getState}.
1665          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1666          *     throwing IllegalMonitorStateException if it fails.
1667          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1668          * &lt;li&gt;Reacquire by invoking specialized version of
1669          *     {@link #acquire} with saved state as argument.
1670          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1671          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1672          * &lt;/ol&gt;
1673          */
1674         public final boolean awaitUntil(Date deadline)
1675                 throws InterruptedException {
1676             long abstime = deadline.getTime();
1677             if (Thread.interrupted())
1678                 throw new InterruptedException();
<span class="line-modified">1679             Node node = addConditionWaiter();</span>
<span class="line-modified">1680             long savedState = fullyRelease(node);</span>
<span class="line-modified">1681             boolean timedout = false;</span>
<span class="line-modified">1682             int interruptMode = 0;</span>
<span class="line-modified">1683             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1684                 if (System.currentTimeMillis() &gt;= abstime) {</span>
<span class="line-modified">1685                     timedout = transferAfterCancelledWait(node);</span>
<span class="line-modified">1686                     break;</span>
<span class="line-modified">1687                 }</span>
<span class="line-modified">1688                 LockSupport.parkUntil(this, abstime);</span>
<span class="line-removed">1689                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">1690                     break;</span>
1691             }
<span class="line-modified">1692             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">1693                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">1694             if (node.nextWaiter != null)</span>
<span class="line-modified">1695                 unlinkCancelledWaiters();</span>
<span class="line-modified">1696             if (interruptMode != 0)</span>
<span class="line-modified">1697                 reportInterruptAfterWait(interruptMode);</span>
<span class="line-modified">1698             return !timedout;</span>


1699         }
1700 
1701         /**
1702          * Implements timed condition wait.
1703          * &lt;ol&gt;
1704          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1705          * &lt;li&gt;Save lock state returned by {@link #getState}.
1706          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1707          *     throwing IllegalMonitorStateException if it fails.
1708          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1709          * &lt;li&gt;Reacquire by invoking specialized version of
1710          *     {@link #acquire} with saved state as argument.
1711          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1712          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1713          * &lt;/ol&gt;
1714          */
1715         public final boolean await(long time, TimeUnit unit)
1716                 throws InterruptedException {
1717             long nanosTimeout = unit.toNanos(time);
1718             if (Thread.interrupted())
1719                 throw new InterruptedException();
<span class="line-modified">1720             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="line-modified">1721             // await(0, unit) as a way to &quot;yield the lock&quot;.</span>
<span class="line-modified">1722             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">1723             Node node = addConditionWaiter();</span>
<span class="line-modified">1724             long savedState = fullyRelease(node);</span>
<span class="line-modified">1725             boolean timedout = false;</span>
<span class="line-modified">1726             int interruptMode = 0;</span>
<span class="line-modified">1727             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">1728                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified">1729                     timedout = transferAfterCancelledWait(node);</span>
<span class="line-modified">1730                     break;</span>
<span class="line-modified">1731                 }</span>
<span class="line-removed">1732                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">1733                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">1734                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">1735                     break;</span>
<span class="line-removed">1736                 nanosTimeout = deadline - System.nanoTime();</span>
1737             }
<span class="line-modified">1738             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">1739                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">1740             if (node.nextWaiter != null)</span>
<span class="line-modified">1741                 unlinkCancelledWaiters();</span>
<span class="line-modified">1742             if (interruptMode != 0)</span>
<span class="line-modified">1743                 reportInterruptAfterWait(interruptMode);</span>
<span class="line-modified">1744             return !timedout;</span>


1745         }
1746 
1747         //  support for instrumentation
1748 
1749         /**
1750          * Returns true if this condition was created by the given
1751          * synchronization object.
1752          *
1753          * @return {@code true} if owned
1754          */
1755         final boolean isOwnedBy(AbstractQueuedLongSynchronizer sync) {
1756             return sync == AbstractQueuedLongSynchronizer.this;
1757         }
1758 
1759         /**
1760          * Queries whether any threads are waiting on this condition.
1761          * Implements {@link AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject)}.
1762          *
1763          * @return {@code true} if there are any waiting threads
1764          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1765          *         returns {@code false}
1766          */
1767         protected final boolean hasWaiters() {
1768             if (!isHeldExclusively())
1769                 throw new IllegalMonitorStateException();
<span class="line-modified">1770             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1771                 if (w.waitStatus == Node.CONDITION)</span>
1772                     return true;
1773             }
1774             return false;
1775         }
1776 
1777         /**
1778          * Returns an estimate of the number of threads waiting on
1779          * this condition.
1780          * Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject)}.
1781          *
1782          * @return the estimated number of waiting threads
1783          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1784          *         returns {@code false}
1785          */
1786         protected final int getWaitQueueLength() {
1787             if (!isHeldExclusively())
1788                 throw new IllegalMonitorStateException();
1789             int n = 0;
<span class="line-modified">1790             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1791                 if (w.waitStatus == Node.CONDITION)</span>
1792                     ++n;
1793             }
1794             return n;
1795         }
1796 
1797         /**
1798          * Returns a collection containing those threads that may be
1799          * waiting on this Condition.
1800          * Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject)}.
1801          *
1802          * @return the collection of threads
1803          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1804          *         returns {@code false}
1805          */
1806         protected final Collection&lt;Thread&gt; getWaitingThreads() {
1807             if (!isHeldExclusively())
1808                 throw new IllegalMonitorStateException();
1809             ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified">1810             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1811                 if (w.waitStatus == Node.CONDITION) {</span>
<span class="line-modified">1812                     Thread t = w.thread;</span>
1813                     if (t != null)
1814                         list.add(t);
1815                 }
1816             }
1817             return list;
1818         }
1819     }
1820 
<span class="line-modified">1821     // VarHandle mechanics</span>
<span class="line-modified">1822     private static final VarHandle STATE;</span>
<span class="line-modified">1823     private static final VarHandle HEAD;</span>
<span class="line-modified">1824     private static final VarHandle TAIL;</span>




1825 
1826     static {
<span class="line-removed">1827         try {</span>
<span class="line-removed">1828             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-removed">1829             STATE = l.findVarHandle(AbstractQueuedLongSynchronizer.class, &quot;state&quot;, long.class);</span>
<span class="line-removed">1830             HEAD = l.findVarHandle(AbstractQueuedLongSynchronizer.class, &quot;head&quot;, Node.class);</span>
<span class="line-removed">1831             TAIL = l.findVarHandle(AbstractQueuedLongSynchronizer.class, &quot;tail&quot;, Node.class);</span>
<span class="line-removed">1832         } catch (ReflectiveOperationException e) {</span>
<span class="line-removed">1833             throw new ExceptionInInitializerError(e);</span>
<span class="line-removed">1834         }</span>
<span class="line-removed">1835 </span>
<span class="line-removed">1836         // Reduce the risk of rare disastrous classloading in first call to</span>
<span class="line-removed">1837         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span>
1838         Class&lt;?&gt; ensureLoaded = LockSupport.class;
1839     }
<span class="line-removed">1840 </span>
<span class="line-removed">1841     /**</span>
<span class="line-removed">1842      * Initializes head and tail fields on first contention.</span>
<span class="line-removed">1843      */</span>
<span class="line-removed">1844     private final void initializeSyncQueue() {</span>
<span class="line-removed">1845         Node h;</span>
<span class="line-removed">1846         if (HEAD.compareAndSet(this, null, (h = new Node())))</span>
<span class="line-removed">1847             tail = h;</span>
<span class="line-removed">1848     }</span>
<span class="line-removed">1849 </span>
<span class="line-removed">1850     /**</span>
<span class="line-removed">1851      * CASes tail field.</span>
<span class="line-removed">1852      */</span>
<span class="line-removed">1853     private final boolean compareAndSetTail(Node expect, Node update) {</span>
<span class="line-removed">1854         return TAIL.compareAndSet(this, expect, update);</span>
<span class="line-removed">1855     }</span>
1856 }
</pre>
</td>
<td>
<hr />
<pre>
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 


  38 import java.util.ArrayList;
  39 import java.util.Collection;
  40 import java.util.Date;
  41 import java.util.concurrent.TimeUnit;
<span class="line-modified">  42 import java.util.concurrent.ForkJoinPool;</span>
<span class="line-added">  43 import jdk.internal.misc.Unsafe;</span>
  44 
  45 /**
  46  * A version of {@link AbstractQueuedSynchronizer} in
  47  * which synchronization state is maintained as a {@code long}.
  48  * This class has exactly the same structure, properties, and methods
  49  * as {@code AbstractQueuedSynchronizer} with the exception
  50  * that all state-related parameters and results are defined
  51  * as {@code long} rather than {@code int}. This class
  52  * may be useful when creating synchronizers such as
  53  * multilevel locks and barriers that require
  54  * 64 bits of state.
  55  *
  56  * &lt;p&gt;See {@link AbstractQueuedSynchronizer} for usage
  57  * notes and examples.
  58  *
  59  * @since 1.6
  60  * @author Doug Lea
  61  */
  62 public abstract class AbstractQueuedLongSynchronizer
  63     extends AbstractOwnableSynchronizer
  64     implements java.io.Serializable {
  65 
  66     private static final long serialVersionUID = 7373984972572414692L;
  67 
  68     /*
  69      * To keep sources in sync, the remainder of this source file is
  70      * exactly cloned from AbstractQueuedSynchronizer, replacing class
  71      * name and changing ints related with sync state to longs. Please
  72      * keep it that way.
  73      */
  74 
<span class="line-modified">  75     // Node status bits, also used as argument and return values</span>
<span class="line-modified">  76     static final int WAITING   = 1;          // must be 1</span>
<span class="line-modified">  77     static final int CANCELLED = 0x80000000; // must be negative</span>
<span class="line-modified">  78     static final int COND      = 2;          // in a condition wait</span>
<span class="line-modified">  79 </span>
<span class="line-added">  80     /** CLH Nodes */</span>
<span class="line-added">  81     abstract static class Node {</span>
<span class="line-added">  82         volatile Node prev;       // initially attached via casTail</span>
<span class="line-added">  83         volatile Node next;       // visibly nonnull when signallable</span>
<span class="line-added">  84         Thread waiter;            // visibly nonnull when enqueued</span>
<span class="line-added">  85         volatile int status;      // written by owner, atomic bit ops by others</span>
<span class="line-added">  86 </span>
<span class="line-added">  87         // methods for atomic operations</span>
<span class="line-added">  88         final boolean casPrev(Node c, Node v) {  // for cleanQueue</span>
<span class="line-added">  89             return U.weakCompareAndSetReference(this, PREV, c, v);</span>
<span class="line-added">  90         }</span>
<span class="line-added">  91         final boolean casNext(Node c, Node v) {  // for cleanQueue</span>
<span class="line-added">  92             return U.weakCompareAndSetReference(this, NEXT, c, v);</span>
<span class="line-added">  93         }</span>
<span class="line-added">  94         final int getAndUnsetStatus(int v) {     // for signalling</span>
<span class="line-added">  95             return U.getAndBitwiseAndInt(this, STATUS, ~v);</span>
<span class="line-added">  96         }</span>
<span class="line-added">  97         final void setPrevRelaxed(Node p) {      // for off-queue assignment</span>
<span class="line-added">  98             U.putReference(this, PREV, p);</span>
<span class="line-added">  99         }</span>
<span class="line-added"> 100         final void setStatusRelaxed(int s) {     // for off-queue assignment</span>
<span class="line-added"> 101             U.putInt(this, STATUS, s);</span>
<span class="line-added"> 102         }</span>
<span class="line-added"> 103         final void clearStatus() {               // for reducing unneeded signals</span>
<span class="line-added"> 104             U.putIntOpaque(this, STATUS, 0);</span>
<span class="line-added"> 105         }</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107         private static final long STATUS</span>
<span class="line-added"> 108             = U.objectFieldOffset(Node.class, &quot;status&quot;);</span>
<span class="line-added"> 109         private static final long NEXT</span>
<span class="line-added"> 110             = U.objectFieldOffset(Node.class, &quot;next&quot;);</span>
<span class="line-added"> 111         private static final long PREV</span>
<span class="line-added"> 112             = U.objectFieldOffset(Node.class, &quot;prev&quot;);</span>
<span class="line-added"> 113     }</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115     // Concrete classes tagged by type</span>
<span class="line-added"> 116     static final class ExclusiveNode extends Node { }</span>
<span class="line-added"> 117     static final class SharedNode extends Node { }</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119     static final class ConditionNode extends Node</span>
<span class="line-added"> 120         implements ForkJoinPool.ManagedBlocker {</span>
<span class="line-added"> 121         ConditionNode nextWaiter;            // link to next waiting node</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123         /**</span>
<span class="line-added"> 124          * Allows Conditions to be used in ForkJoinPools without</span>
<span class="line-added"> 125          * risking fixed pool exhaustion. This is usable only for</span>
<span class="line-added"> 126          * untimed Condition waits, not timed versions.</span>
<span class="line-added"> 127          */</span>
<span class="line-added"> 128         public final boolean isReleasable() {</span>
<span class="line-added"> 129             return status &lt;= 1 || Thread.currentThread().isInterrupted();</span>
<span class="line-added"> 130         }</span>
<span class="line-added"> 131 </span>
<span class="line-added"> 132         public final boolean block() {</span>
<span class="line-added"> 133             while (!isReleasable()) LockSupport.park();</span>
<span class="line-added"> 134             return true;</span>
<span class="line-added"> 135         }</span>
<span class="line-added"> 136     }</span>
 137 
 138     /**
<span class="line-modified"> 139      * Head of the wait queue, lazily initialized.</span>



 140      */
 141     private transient volatile Node head;
 142 
 143     /**
<span class="line-modified"> 144      * Tail of the wait queue. After initialization, modified only via casTail.</span>

 145      */
 146     private transient volatile Node tail;
 147 
 148     /**
 149      * The synchronization state.
 150      */
 151     private volatile long state;
 152 
 153     /**
 154      * Returns the current value of synchronization state.
 155      * This operation has memory semantics of a {@code volatile} read.
 156      * @return current state value
 157      */
 158     protected final long getState() {
 159         return state;
 160     }
 161 
 162     /**
 163      * Sets the value of synchronization state.
 164      * This operation has memory semantics of a {@code volatile} write.
 165      * @param newState the new state value
 166      */
 167     protected final void setState(long newState) {
<span class="line-modified"> 168         state = newState;</span>

 169     }
 170 
 171     /**
 172      * Atomically sets synchronization state to the given updated
 173      * value if the current state value equals the expected value.
 174      * This operation has memory semantics of a {@code volatile} read
 175      * and write.
 176      *
 177      * @param expect the expected value
 178      * @param update the new value
 179      * @return {@code true} if successful. False return indicates that the actual
 180      *         value was not equal to the expected value.
 181      */
 182     protected final boolean compareAndSetState(long expect, long update) {
<span class="line-modified"> 183         return U.compareAndSetLong(this, STATE, expect, update);</span>
 184     }
 185 
 186     // Queuing utilities
 187 
<span class="line-modified"> 188     private boolean casTail(Node c, Node v) {</span>
<span class="line-modified"> 189         return U.compareAndSetReference(this, TAIL, c, v);</span>



























































 190     }
 191 
<span class="line-modified"> 192     /** tries once to CAS a new dummy node for head */</span>
<span class="line-modified"> 193     private void tryInitializeHead() {</span>
<span class="line-modified"> 194         Node h = new ExclusiveNode();</span>
<span class="line-modified"> 195         if (U.compareAndSetReference(this, HEAD, null, h))</span>
<span class="line-modified"> 196             tail = h;</span>

























 197     }
 198 
 199     /**
<span class="line-modified"> 200      * Enqueues the node unless null. (Currently used only for</span>
<span class="line-modified"> 201      * ConditionNodes; other cases are interleaved with acquires.)</span>

 202      */
<span class="line-modified"> 203     final void enqueue(Node node) {</span>
<span class="line-modified"> 204         if (node != null) {</span>
<span class="line-modified"> 205             for (;;) {</span>
<span class="line-modified"> 206                 Node t = tail;</span>
<span class="line-modified"> 207                 node.setPrevRelaxed(t);        // avoid unnecessary fence</span>
<span class="line-modified"> 208                 if (t == null)                 // initialize</span>
<span class="line-modified"> 209                     tryInitializeHead();</span>
<span class="line-modified"> 210                 else if (casTail(t, node)) {</span>
<span class="line-modified"> 211                     t.next = node;</span>
<span class="line-modified"> 212                     if (t.status &lt; 0)          // wake up to clean link</span>
<span class="line-modified"> 213                         LockSupport.unpark(node.waiter);</span>
<span class="line-modified"> 214                     break;</span>








 215                 }



 216             }


 217         }
 218     }
 219 
<span class="line-modified"> 220     /** Returns true if node is found in traversal from tail */</span>
<span class="line-modified"> 221     final boolean isEnqueued(Node node) {</span>
<span class="line-modified"> 222         for (Node t = tail; t != null; t = t.prev)</span>
<span class="line-modified"> 223             if (t == node)</span>
<span class="line-modified"> 224                 return true;</span>
<span class="line-modified"> 225         return false;</span>



























 226     }
 227 


 228     /**
<span class="line-modified"> 229      * Wakes up the successor of given node, if one exists, and unsets its</span>
<span class="line-modified"> 230      * WAITING status to avoid park race. This may fail to wake up an</span>
<span class="line-modified"> 231      * eligible thread when one or more have been cancelled, but</span>
<span class="line-added"> 232      * cancelAcquire ensures liveness.</span>
 233      */
<span class="line-modified"> 234     private static void signalNext(Node h) {</span>
<span class="line-modified"> 235         Node s;</span>
<span class="line-modified"> 236         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp; s.status != 0) {</span>
<span class="line-modified"> 237             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified"> 238             LockSupport.unpark(s.waiter);</span>






































 239         }
 240     }
 241 
<span class="line-modified"> 242     /** Wakes up the given node if in shared mode */</span>
<span class="line-modified"> 243     private static void signalNextIfShared(Node h) {</span>
<span class="line-modified"> 244         Node s;</span>
<span class="line-modified"> 245         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-modified"> 246             (s instanceof SharedNode) &amp;&amp; s.status != 0) {</span>
<span class="line-modified"> 247             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified"> 248             LockSupport.unpark(s.waiter);</span>


























 249         }








 250     }
 251 
 252     /**
<span class="line-modified"> 253      * Main acquire method, invoked by all exported acquire methods.</span>




















 254      *
<span class="line-modified"> 255      * @param node null unless a reacquiring Condition</span>
 256      * @param arg the acquire argument
<span class="line-modified"> 257      * @param shared true if shared mode else exclusive</span>
<span class="line-added"> 258      * @param interruptible if abort and return negative on interrupt</span>
<span class="line-added"> 259      * @param timed if true use timed waits</span>
<span class="line-added"> 260      * @param time if timed, the System.nanoTime value to timeout</span>
<span class="line-added"> 261      * @return positive if acquired, 0 if timed out, negative if interrupted</span>
 262      */
<span class="line-modified"> 263     final int acquire(Node node, long arg, boolean shared,</span>
<span class="line-modified"> 264                       boolean interruptible, boolean timed, long time) {</span>
<span class="line-modified"> 265         Thread current = Thread.currentThread();</span>
<span class="line-modified"> 266         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="line-modified"> 267         boolean interrupted = false, first = false;</span>
<span class="line-modified"> 268         Node pred = null;                // predecessor of node when enqueued</span>














 269 
<span class="line-modified"> 270         /*</span>
<span class="line-modified"> 271          * Repeatedly:</span>
<span class="line-modified"> 272          *  Check if node now first</span>
<span class="line-modified"> 273          *    if so, ensure head stable, else ensure valid predecessor</span>
<span class="line-modified"> 274          *  if node is first or not yet enqueued, try acquiring</span>
<span class="line-modified"> 275          *  else if node not yet created, create it</span>
<span class="line-modified"> 276          *  else if not yet enqueued, try once to enqueue</span>
<span class="line-modified"> 277          *  else if woken from park, retry (up to postSpins times)</span>
<span class="line-modified"> 278          *  else if WAITING status not set, set and retry</span>
<span class="line-modified"> 279          *  else park and clear WAITING status, and check cancellation</span>
<span class="line-modified"> 280          */</span>
<span class="line-modified"> 281 </span>
<span class="line-modified"> 282         for (;;) {</span>
<span class="line-modified"> 283             if (!first &amp;&amp; (pred = (node == null) ? null : node.prev) != null &amp;&amp;</span>
<span class="line-added"> 284                 !(first = (head == pred))) {</span>
<span class="line-added"> 285                 if (pred.status &lt; 0) {</span>
<span class="line-added"> 286                     cleanQueue();           // predecessor cancelled</span>
<span class="line-added"> 287                     continue;</span>
<span class="line-added"> 288                 } else if (pred.prev == null) {</span>
<span class="line-added"> 289                     Thread.onSpinWait();    // ensure serialization</span>
<span class="line-added"> 290                     continue;</span>
 291                 }



 292             }
<span class="line-modified"> 293             if (first || pred == null) {</span>
<span class="line-modified"> 294                 boolean acquired;</span>
<span class="line-modified"> 295                 try {</span>
<span class="line-modified"> 296                     if (shared)</span>
<span class="line-modified"> 297                         acquired = (tryAcquireShared(arg) &gt;= 0);</span>
<span class="line-modified"> 298                     else</span>
<span class="line-modified"> 299                         acquired = tryAcquire(arg);</span>
<span class="line-modified"> 300                 } catch (Throwable ex) {</span>
<span class="line-modified"> 301                     cancelAcquire(node, interrupted, false);</span>
<span class="line-modified"> 302                     throw ex;</span>
















 303                 }
<span class="line-modified"> 304                 if (acquired) {</span>
<span class="line-modified"> 305                     if (first) {</span>
<span class="line-modified"> 306                         node.prev = null;</span>
<span class="line-modified"> 307                         head = node;</span>
<span class="line-added"> 308                         pred.next = null;</span>
<span class="line-added"> 309                         node.waiter = null;</span>
<span class="line-added"> 310                         if (shared)</span>
<span class="line-added"> 311                             signalNextIfShared(node);</span>
<span class="line-added"> 312                         if (interrupted)</span>
<span class="line-added"> 313                             current.interrupt();</span>
<span class="line-added"> 314                     }</span>
<span class="line-added"> 315                     return 1;</span>
 316                 }





 317             }
<span class="line-modified"> 318             if (node == null) {                 // allocate; retry before enqueue</span>
<span class="line-modified"> 319                 if (shared)</span>
<span class="line-modified"> 320                     node = new SharedNode();</span>
<span class="line-added"> 321                 else</span>
<span class="line-added"> 322                     node = new ExclusiveNode();</span>
<span class="line-added"> 323             } else if (pred == null) {          // try to enqueue</span>
<span class="line-added"> 324                 node.waiter = current;</span>
<span class="line-added"> 325                 Node t = tail;</span>
<span class="line-added"> 326                 node.setPrevRelaxed(t);         // avoid unnecessary fence</span>
<span class="line-added"> 327                 if (t == null)</span>
<span class="line-added"> 328                     tryInitializeHead();</span>
<span class="line-added"> 329                 else if (!casTail(t, node))</span>
<span class="line-added"> 330                     node.setPrevRelaxed(null);  // back out</span>
<span class="line-added"> 331                 else</span>
<span class="line-added"> 332                     t.next = node;</span>
<span class="line-added"> 333             } else if (first &amp;&amp; spins != 0) {</span>
<span class="line-added"> 334                 --spins;                        // reduce unfairness on rewaits</span>
<span class="line-added"> 335                 Thread.onSpinWait();</span>
<span class="line-added"> 336             } else if (node.status == 0) {</span>
<span class="line-added"> 337                 node.status = WAITING;          // enable signal and recheck</span>
<span class="line-added"> 338             } else {</span>
<span class="line-added"> 339                 long nanos;</span>
<span class="line-added"> 340                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="line-added"> 341                 if (!timed)</span>
<span class="line-added"> 342                     LockSupport.park(this);</span>
<span class="line-added"> 343                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="line-added"> 344                     LockSupport.parkNanos(this, nanos);</span>
<span class="line-added"> 345                 else</span>
<span class="line-added"> 346                     break;</span>
<span class="line-added"> 347                 node.clearStatus();</span>
<span class="line-added"> 348                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="line-added"> 349                     break;</span>
<span class="line-added"> 350             }</span>
 351         }
<span class="line-added"> 352         return cancelAcquire(node, interrupted, interruptible);</span>
 353     }
 354 
 355     /**
<span class="line-modified"> 356      * Possibly repeatedly traverses from tail, unsplicing cancelled</span>
<span class="line-modified"> 357      * nodes until none are found.</span>
 358      */
<span class="line-modified"> 359     private void cleanQueue() {</span>
<span class="line-modified"> 360         for (;;) {                               // restart point</span>
<span class="line-modified"> 361             for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples</span>
<span class="line-modified"> 362                 if (q == null || (p = q.prev) == null)</span>
<span class="line-modified"> 363                     return;                      // end of list</span>
<span class="line-modified"> 364                 if (s == null ? tail != q : (s.prev != q || s.status &lt; 0))</span>
<span class="line-modified"> 365                     break;                       // inconsistent</span>
<span class="line-modified"> 366                 if (q.status &lt; 0) {              // cancelled</span>
<span class="line-modified"> 367                     if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;</span>
<span class="line-modified"> 368                         q.prev == p) {</span>
<span class="line-modified"> 369                         p.casNext(q, s);         // OK if fails</span>
<span class="line-modified"> 370                         if (p.prev == null)</span>
<span class="line-added"> 371                             signalNext(p);</span>
 372                     }
<span class="line-added"> 373                     break;</span>
 374                 }
<span class="line-modified"> 375                 if ((n = p.next) != q) {         // help finish</span>
<span class="line-modified"> 376                     if (n != null &amp;&amp; q.prev == p) {</span>
<span class="line-modified"> 377                         p.casNext(n, q);</span>
<span class="line-modified"> 378                         if (p.prev == null)</span>
<span class="line-modified"> 379                             signalNext(p);</span>























 380                     }
<span class="line-added"> 381                     break;</span>
 382                 }
<span class="line-modified"> 383                 s = q;</span>
<span class="line-modified"> 384                 q = q.prev;</span>

 385             }



 386         }
 387     }
 388 
 389     /**
<span class="line-modified"> 390      * Cancels an ongoing attempt to acquire.</span>
 391      *
<span class="line-modified"> 392      * @param node the node (may be null if cancelled before enqueuing)</span>
<span class="line-modified"> 393      * @param interrupted true if thread interrupted</span>
<span class="line-modified"> 394      * @param interruptible if should report interruption vs reset</span>
 395      */
<span class="line-modified"> 396     private int cancelAcquire(Node node, boolean interrupted,</span>
<span class="line-modified"> 397                               boolean interruptible) {</span>
<span class="line-modified"> 398         if (node != null) {</span>
<span class="line-modified"> 399             node.waiter = null;</span>
<span class="line-modified"> 400             node.status = CANCELLED;</span>
<span class="line-modified"> 401             if (node.prev != null)</span>
<span class="line-modified"> 402                 cleanQueue();</span>
<span class="line-modified"> 403         }</span>
<span class="line-modified"> 404         if (interrupted) {</span>
<span class="line-modified"> 405             if (interruptible)</span>
<span class="line-modified"> 406                 return CANCELLED;</span>
<span class="line-modified"> 407             else</span>
<span class="line-modified"> 408                 Thread.currentThread().interrupt();</span>


















 409         }
<span class="line-added"> 410         return 0;</span>
 411     }
 412 
 413     // Main exported methods
 414 
 415     /**
 416      * Attempts to acquire in exclusive mode. This method should query
 417      * if the state of the object permits it to be acquired in the
 418      * exclusive mode, and if so to acquire it.
 419      *
 420      * &lt;p&gt;This method is always invoked by the thread performing
 421      * acquire.  If this method reports failure, the acquire method
 422      * may queue the thread, if it is not already queued, until it is
 423      * signalled by a release from some other thread. This can be used
 424      * to implement method {@link Lock#tryLock()}.
 425      *
 426      * &lt;p&gt;The default
 427      * implementation throws {@link UnsupportedOperationException}.
 428      *
 429      * @param arg the acquire argument. This value is always the one
 430      *        passed to an acquire method, or is the value saved on entry
</pre>
<hr />
<pre>
 543      *         {@code false} otherwise
 544      * @throws UnsupportedOperationException if conditions are not supported
 545      */
 546     protected boolean isHeldExclusively() {
 547         throw new UnsupportedOperationException();
 548     }
 549 
 550     /**
 551      * Acquires in exclusive mode, ignoring interrupts.  Implemented
 552      * by invoking at least once {@link #tryAcquire},
 553      * returning on success.  Otherwise the thread is queued, possibly
 554      * repeatedly blocking and unblocking, invoking {@link
 555      * #tryAcquire} until success.  This method can be used
 556      * to implement method {@link Lock#lock}.
 557      *
 558      * @param arg the acquire argument.  This value is conveyed to
 559      *        {@link #tryAcquire} but is otherwise uninterpreted and
 560      *        can represent anything you like.
 561      */
 562     public final void acquire(long arg) {
<span class="line-modified"> 563         if (!tryAcquire(arg))</span>
<span class="line-modified"> 564             acquire(null, arg, false, false, false, 0L);</span>

 565     }
 566 
 567     /**
 568      * Acquires in exclusive mode, aborting if interrupted.
 569      * Implemented by first checking interrupt status, then invoking
 570      * at least once {@link #tryAcquire}, returning on
 571      * success.  Otherwise the thread is queued, possibly repeatedly
 572      * blocking and unblocking, invoking {@link #tryAcquire}
 573      * until success or the thread is interrupted.  This method can be
 574      * used to implement method {@link Lock#lockInterruptibly}.
 575      *
 576      * @param arg the acquire argument.  This value is conveyed to
 577      *        {@link #tryAcquire} but is otherwise uninterpreted and
 578      *        can represent anything you like.
 579      * @throws InterruptedException if the current thread is interrupted
 580      */
 581     public final void acquireInterruptibly(long arg)
<span class="line-modified"> 582         throws InterruptedException {</span>
<span class="line-modified"> 583         if (Thread.interrupted() ||</span>
<span class="line-added"> 584             (!tryAcquire(arg) &amp;&amp; acquire(null, arg, false, true, false, 0L) &lt; 0))</span>
 585             throw new InterruptedException();


 586     }
 587 
 588     /**
 589      * Attempts to acquire in exclusive mode, aborting if interrupted,
 590      * and failing if the given timeout elapses.  Implemented by first
 591      * checking interrupt status, then invoking at least once {@link
 592      * #tryAcquire}, returning on success.  Otherwise, the thread is
 593      * queued, possibly repeatedly blocking and unblocking, invoking
 594      * {@link #tryAcquire} until success or the thread is interrupted
 595      * or the timeout elapses.  This method can be used to implement
 596      * method {@link Lock#tryLock(long, TimeUnit)}.
 597      *
 598      * @param arg the acquire argument.  This value is conveyed to
 599      *        {@link #tryAcquire} but is otherwise uninterpreted and
 600      *        can represent anything you like.
 601      * @param nanosTimeout the maximum number of nanoseconds to wait
 602      * @return {@code true} if acquired; {@code false} if timed out
 603      * @throws InterruptedException if the current thread is interrupted
 604      */
 605     public final boolean tryAcquireNanos(long arg, long nanosTimeout)
<span class="line-modified"> 606         throws InterruptedException {</span>
<span class="line-modified"> 607         if (!Thread.interrupted()) {</span>
<span class="line-modified"> 608             if (tryAcquire(arg))</span>
<span class="line-modified"> 609                 return true;</span>
<span class="line-modified"> 610             if (nanosTimeout &lt;= 0L)</span>
<span class="line-added"> 611                 return false;</span>
<span class="line-added"> 612             int stat = acquire(null, arg, false, true, true,</span>
<span class="line-added"> 613                                System.nanoTime() + nanosTimeout);</span>
<span class="line-added"> 614             if (stat &gt; 0)</span>
<span class="line-added"> 615                 return true;</span>
<span class="line-added"> 616             if (stat == 0)</span>
<span class="line-added"> 617                 return false;</span>
<span class="line-added"> 618         }</span>
<span class="line-added"> 619         throw new InterruptedException();</span>
 620     }
 621 
 622     /**
 623      * Releases in exclusive mode.  Implemented by unblocking one or
 624      * more threads if {@link #tryRelease} returns true.
 625      * This method can be used to implement method {@link Lock#unlock}.
 626      *
 627      * @param arg the release argument.  This value is conveyed to
 628      *        {@link #tryRelease} but is otherwise uninterpreted and
 629      *        can represent anything you like.
 630      * @return the value returned from {@link #tryRelease}
 631      */
 632     public final boolean release(long arg) {
 633         if (tryRelease(arg)) {
<span class="line-modified"> 634             signalNext(head);</span>


 635             return true;
 636         }
 637         return false;
 638     }
 639 
 640     /**
 641      * Acquires in shared mode, ignoring interrupts.  Implemented by
 642      * first invoking at least once {@link #tryAcquireShared},
 643      * returning on success.  Otherwise the thread is queued, possibly
 644      * repeatedly blocking and unblocking, invoking {@link
 645      * #tryAcquireShared} until success.
 646      *
 647      * @param arg the acquire argument.  This value is conveyed to
 648      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 649      *        and can represent anything you like.
 650      */
 651     public final void acquireShared(long arg) {
 652         if (tryAcquireShared(arg) &lt; 0)
<span class="line-modified"> 653             acquire(null, arg, true, false, false, 0L);</span>
 654     }
 655 
 656     /**
 657      * Acquires in shared mode, aborting if interrupted.  Implemented
 658      * by first checking interrupt status, then invoking at least once
 659      * {@link #tryAcquireShared}, returning on success.  Otherwise the
 660      * thread is queued, possibly repeatedly blocking and unblocking,
 661      * invoking {@link #tryAcquireShared} until success or the thread
 662      * is interrupted.
 663      * @param arg the acquire argument.
 664      * This value is conveyed to {@link #tryAcquireShared} but is
 665      * otherwise uninterpreted and can represent anything
 666      * you like.
 667      * @throws InterruptedException if the current thread is interrupted
 668      */
 669     public final void acquireSharedInterruptibly(long arg)
<span class="line-modified"> 670         throws InterruptedException {</span>
<span class="line-modified"> 671         if (Thread.interrupted() ||</span>
<span class="line-added"> 672             (tryAcquireShared(arg) &lt; 0 &amp;&amp;</span>
<span class="line-added"> 673              acquire(null, arg, true, true, false, 0L) &lt; 0))</span>
 674             throw new InterruptedException();


 675     }
 676 
 677     /**
 678      * Attempts to acquire in shared mode, aborting if interrupted, and
 679      * failing if the given timeout elapses.  Implemented by first
 680      * checking interrupt status, then invoking at least once {@link
 681      * #tryAcquireShared}, returning on success.  Otherwise, the
 682      * thread is queued, possibly repeatedly blocking and unblocking,
 683      * invoking {@link #tryAcquireShared} until success or the thread
 684      * is interrupted or the timeout elapses.
 685      *
 686      * @param arg the acquire argument.  This value is conveyed to
 687      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 688      *        and can represent anything you like.
 689      * @param nanosTimeout the maximum number of nanoseconds to wait
 690      * @return {@code true} if acquired; {@code false} if timed out
 691      * @throws InterruptedException if the current thread is interrupted
 692      */
 693     public final boolean tryAcquireSharedNanos(long arg, long nanosTimeout)
 694             throws InterruptedException {
<span class="line-modified"> 695         if (!Thread.interrupted()) {</span>
<span class="line-modified"> 696             if (tryAcquireShared(arg) &gt;= 0)</span>
<span class="line-modified"> 697                 return true;</span>
<span class="line-modified"> 698             if (nanosTimeout &lt;= 0L)</span>
<span class="line-added"> 699                 return false;</span>
<span class="line-added"> 700             int stat = acquire(null, arg, true, true, true,</span>
<span class="line-added"> 701                                System.nanoTime() + nanosTimeout);</span>
<span class="line-added"> 702             if (stat &gt; 0)</span>
<span class="line-added"> 703                 return true;</span>
<span class="line-added"> 704             if (stat == 0)</span>
<span class="line-added"> 705                 return false;</span>
<span class="line-added"> 706         }</span>
<span class="line-added"> 707         throw new InterruptedException();</span>
 708     }
 709 
 710     /**
 711      * Releases in shared mode.  Implemented by unblocking one or more
 712      * threads if {@link #tryReleaseShared} returns true.
 713      *
 714      * @param arg the release argument.  This value is conveyed to
 715      *        {@link #tryReleaseShared} but is otherwise uninterpreted
 716      *        and can represent anything you like.
 717      * @return the value returned from {@link #tryReleaseShared}
 718      */
 719     public final boolean releaseShared(long arg) {
 720         if (tryReleaseShared(arg)) {
<span class="line-modified"> 721             signalNext(head);</span>
 722             return true;
 723         }
 724         return false;
 725     }
 726 
 727     // Queue inspection methods
 728 
 729     /**
 730      * Queries whether any threads are waiting to acquire. Note that
 731      * because cancellations due to interrupts and timeouts may occur
 732      * at any time, a {@code true} return does not guarantee that any
 733      * other thread will ever acquire.
 734      *
 735      * @return {@code true} if there may be other threads waiting to acquire
 736      */
 737     public final boolean hasQueuedThreads() {
 738         for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<span class="line-modified"> 739             if (p.status &gt;= 0)</span>
 740                 return true;
 741         return false;
 742     }
 743 
 744     /**
 745      * Queries whether any threads have ever contended to acquire this
 746      * synchronizer; that is, if an acquire method has ever blocked.
 747      *
 748      * &lt;p&gt;In this implementation, this operation returns in
 749      * constant time.
 750      *
 751      * @return {@code true} if there has ever been contention
 752      */
 753     public final boolean hasContended() {
 754         return head != null;
 755     }
 756 
 757     /**
 758      * Returns the first (longest-waiting) thread in the queue, or
 759      * {@code null} if no threads are currently queued.
 760      *
 761      * &lt;p&gt;In this implementation, this operation normally returns in
 762      * constant time, but may iterate upon contention if other threads are
 763      * concurrently modifying the queue.
 764      *
 765      * @return the first (longest-waiting) thread in the queue, or
 766      *         {@code null} if no threads are currently queued
 767      */
 768     public final Thread getFirstQueuedThread() {
<span class="line-modified"> 769         Thread first = null, w; Node h, s;</span>
<span class="line-modified"> 770         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="line-modified"> 771                                    (first = s.waiter) == null ||</span>
<span class="line-modified"> 772                                    s.prev == null)) {</span>
<span class="line-modified"> 773             // traverse from tail on stale reads</span>
<span class="line-modified"> 774             for (Node p = tail, q; p != null &amp;&amp; (q = p.prev) != null; p = q)</span>
<span class="line-modified"> 775                 if ((w = p.waiter) != null)</span>
<span class="line-modified"> 776                     first = w;</span>





























 777         }
<span class="line-modified"> 778         return first;</span>
 779     }
 780 
 781     /**
 782      * Returns true if the given thread is currently queued.
 783      *
 784      * &lt;p&gt;This implementation traverses the queue to determine
 785      * presence of the given thread.
 786      *
 787      * @param thread the thread
 788      * @return {@code true} if the given thread is on the queue
 789      * @throws NullPointerException if the thread is null
 790      */
 791     public final boolean isQueued(Thread thread) {
 792         if (thread == null)
 793             throw new NullPointerException();
 794         for (Node p = tail; p != null; p = p.prev)
<span class="line-modified"> 795             if (p.waiter == thread)</span>
 796                 return true;
 797         return false;
 798     }
 799 
 800     /**
 801      * Returns {@code true} if the apparent first queued thread, if one
 802      * exists, is waiting in exclusive mode.  If this method returns
 803      * {@code true}, and the current thread is attempting to acquire in
 804      * shared mode (that is, this method is invoked from {@link
 805      * #tryAcquireShared}) then it is guaranteed that the current thread
 806      * is not the first queued thread.  Used only as a heuristic in
 807      * ReentrantReadWriteLock.
 808      */
 809     final boolean apparentlyFirstQueuedIsExclusive() {
 810         Node h, s;
<span class="line-modified"> 811         return (h = head) != null &amp;&amp; (s = h.next)  != null &amp;&amp;</span>
<span class="line-modified"> 812             !(s instanceof SharedNode) &amp;&amp; s.waiter != null;</span>


 813     }
 814 
 815     /**
 816      * Queries whether any threads have been waiting to acquire longer
 817      * than the current thread.
 818      *
 819      * &lt;p&gt;An invocation of this method is equivalent to (but may be
 820      * more efficient than):
 821      * &lt;pre&gt; {@code
 822      * getFirstQueuedThread() != Thread.currentThread()
 823      *   &amp;&amp; hasQueuedThreads()}&lt;/pre&gt;
 824      *
 825      * &lt;p&gt;Note that because cancellations due to interrupts and
 826      * timeouts may occur at any time, a {@code true} return does not
 827      * guarantee that some other thread will acquire before the current
 828      * thread.  Likewise, it is possible for another thread to win a
 829      * race to enqueue after this method has returned {@code false},
 830      * due to the queue being empty.
 831      *
 832      * &lt;p&gt;This method is designed to be used by a fair synchronizer to
 833      * avoid &lt;a href=&quot;AbstractQueuedSynchronizer.html#barging&quot;&gt;barging&lt;/a&gt;.
 834      * Such a synchronizer&#39;s {@link #tryAcquire} method should return
 835      * {@code false}, and its {@link #tryAcquireShared} method should
 836      * return a negative value, if this method returns {@code true}
 837      * (unless this is a reentrant acquire).  For example, the {@code
 838      * tryAcquire} method for a fair, reentrant, exclusive mode
 839      * synchronizer might look like this:
 840      *
 841      * &lt;pre&gt; {@code
<span class="line-modified"> 842      * protected boolean tryAcquire(long arg) {</span>
 843      *   if (isHeldExclusively()) {
 844      *     // A reentrant acquire; increment hold count
 845      *     return true;
 846      *   } else if (hasQueuedPredecessors()) {
 847      *     return false;
 848      *   } else {
 849      *     // try to acquire normally
 850      *   }
 851      * }}&lt;/pre&gt;
 852      *
 853      * @return {@code true} if there is a queued thread preceding the
 854      *         current thread, and {@code false} if the current thread
 855      *         is at the head of the queue or the queue is empty
 856      * @since 1.7
 857      */
 858     public final boolean hasQueuedPredecessors() {
<span class="line-modified"> 859         Thread first = null; Node h, s;</span>
<span class="line-modified"> 860         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="line-modified"> 861                                    (first = s.waiter) == null ||</span>
<span class="line-modified"> 862                                    s.prev == null))</span>
<span class="line-modified"> 863             first = getFirstQueuedThread(); // retry via getFirstQueuedThread</span>
<span class="line-modified"> 864         return first != null &amp;&amp; first != Thread.currentThread();</span>







 865     }
 866 
 867     // Instrumentation and monitoring methods
 868 
 869     /**
 870      * Returns an estimate of the number of threads waiting to
 871      * acquire.  The value is only an estimate because the number of
 872      * threads may change dynamically while this method traverses
 873      * internal data structures.  This method is designed for use in
 874      * monitoring system state, not for synchronization control.
 875      *
 876      * @return the estimated number of threads waiting to acquire
 877      */
 878     public final int getQueueLength() {
 879         int n = 0;
 880         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified"> 881             if (p.waiter != null)</span>
 882                 ++n;
 883         }
 884         return n;
 885     }
 886 
 887     /**
 888      * Returns a collection containing threads that may be waiting to
 889      * acquire.  Because the actual set of threads may change
 890      * dynamically while constructing this result, the returned
 891      * collection is only a best-effort estimate.  The elements of the
 892      * returned collection are in no particular order.  This method is
 893      * designed to facilitate construction of subclasses that provide
 894      * more extensive monitoring facilities.
 895      *
 896      * @return the collection of threads
 897      */
 898     public final Collection&lt;Thread&gt; getQueuedThreads() {
 899         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
 900         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified"> 901             Thread t = p.waiter;</span>
 902             if (t != null)
 903                 list.add(t);
 904         }
 905         return list;
 906     }
 907 
 908     /**
 909      * Returns a collection containing threads that may be waiting to
 910      * acquire in exclusive mode. This has the same properties
 911      * as {@link #getQueuedThreads} except that it only returns
 912      * those threads waiting due to an exclusive acquire.
 913      *
 914      * @return the collection of threads
 915      */
 916     public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
 917         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
 918         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified"> 919             if (!(p instanceof SharedNode)) {</span>
<span class="line-modified"> 920                 Thread t = p.waiter;</span>
 921                 if (t != null)
 922                     list.add(t);
 923             }
 924         }
 925         return list;
 926     }
 927 
 928     /**
 929      * Returns a collection containing threads that may be waiting to
 930      * acquire in shared mode. This has the same properties
 931      * as {@link #getQueuedThreads} except that it only returns
 932      * those threads waiting due to a shared acquire.
 933      *
 934      * @return the collection of threads
 935      */
 936     public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
 937         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
 938         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified"> 939             if (p instanceof SharedNode) {</span>
<span class="line-modified"> 940                 Thread t = p.waiter;</span>
 941                 if (t != null)
 942                     list.add(t);
 943             }
 944         }
 945         return list;
 946     }
 947 
 948     /**
 949      * Returns a string identifying this synchronizer, as well as its state.
 950      * The state, in brackets, includes the String {@code &quot;State =&quot;}
 951      * followed by the current value of {@link #getState}, and either
 952      * {@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
 953      * queue is empty.
 954      *
 955      * @return a string identifying this synchronizer, as well as its state
 956      */
 957     public String toString() {
 958         return super.toString()
 959             + &quot;[State = &quot; + getState() + &quot;, &quot;
 960             + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
 961     }
 962 















































































































 963     // Instrumentation methods for conditions
 964 
 965     /**
 966      * Queries whether the given ConditionObject
 967      * uses this synchronizer as its lock.
 968      *
 969      * @param condition the condition
 970      * @return {@code true} if owned
 971      * @throws NullPointerException if the condition is null
 972      */
 973     public final boolean owns(ConditionObject condition) {
 974         return condition.isOwnedBy(this);
 975     }
 976 
 977     /**
 978      * Queries whether any threads are waiting on the given condition
 979      * associated with this synchronizer. Note that because timeouts
 980      * and interrupts may occur at any time, a {@code true} return
 981      * does not guarantee that a future {@code signal} will awaken
 982      * any threads.  This method is designed primarily for use in
</pre>
<hr />
<pre>
1036      */
1037     public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition) {
1038         if (!owns(condition))
1039             throw new IllegalArgumentException(&quot;Not owner&quot;);
1040         return condition.getWaitingThreads();
1041     }
1042 
1043     /**
1044      * Condition implementation for a {@link AbstractQueuedLongSynchronizer}
1045      * serving as the basis of a {@link Lock} implementation.
1046      *
1047      * &lt;p&gt;Method documentation for this class describes mechanics,
1048      * not behavioral specifications from the point of view of Lock
1049      * and Condition users. Exported versions of this class will in
1050      * general need to be accompanied by documentation describing
1051      * condition semantics that rely on those of the associated
1052      * {@code AbstractQueuedLongSynchronizer}.
1053      *
1054      * &lt;p&gt;This class is Serializable, but all fields are transient,
1055      * so deserialized conditions have no waiters.


1056      */
1057     public class ConditionObject implements Condition, java.io.Serializable {
1058         private static final long serialVersionUID = 1173984872572414699L;
1059         /** First node of condition queue. */
<span class="line-modified">1060         private transient ConditionNode firstWaiter;</span>
1061         /** Last node of condition queue. */
<span class="line-modified">1062         private transient ConditionNode lastWaiter;</span>
1063 
1064         /**
1065          * Creates a new {@code ConditionObject} instance.
1066          */
1067         public ConditionObject() { }
1068 
<span class="line-modified">1069         // Signalling methods</span>
























1070 
1071         /**
<span class="line-modified">1072          * Removes and transfers one or all waiters to sync queue.</span>



1073          */
<span class="line-modified">1074         private void doSignal(ConditionNode first, boolean all) {</span>
<span class="line-modified">1075             while (first != null) {</span>
<span class="line-modified">1076                 ConditionNode next = first.nextWaiter;</span>
<span class="line-added">1077                 if ((firstWaiter = next) == null)</span>
1078                     lastWaiter = null;
<span class="line-modified">1079                 if ((first.getAndUnsetStatus(COND) &amp; COND) != 0) {</span>
<span class="line-modified">1080                     enqueue(first);</span>
<span class="line-modified">1081                     if (!all)</span>
<span class="line-modified">1082                         break;</span>










































1083                 }
<span class="line-modified">1084                 first = next;</span>


1085             }
1086         }
1087 


1088         /**
1089          * Moves the longest-waiting thread, if one exists, from the
1090          * wait queue for this condition to the wait queue for the
1091          * owning lock.
1092          *
1093          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1094          *         returns {@code false}
1095          */
1096         public final void signal() {
<span class="line-added">1097             ConditionNode first = firstWaiter;</span>
1098             if (!isHeldExclusively())
1099                 throw new IllegalMonitorStateException();

1100             if (first != null)
<span class="line-modified">1101                 doSignal(first, false);</span>
1102         }
1103 
1104         /**
1105          * Moves all threads from the wait queue for this condition to
1106          * the wait queue for the owning lock.
1107          *
1108          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1109          *         returns {@code false}
1110          */
1111         public final void signalAll() {
<span class="line-added">1112             ConditionNode first = firstWaiter;</span>
1113             if (!isHeldExclusively())
1114                 throw new IllegalMonitorStateException();

1115             if (first != null)
<span class="line-modified">1116                 doSignal(first, true);</span>
<span class="line-added">1117         }</span>
<span class="line-added">1118 </span>
<span class="line-added">1119         // Waiting methods</span>
<span class="line-added">1120 </span>
<span class="line-added">1121         /**</span>
<span class="line-added">1122          * Adds node to condition list and releases lock.</span>
<span class="line-added">1123          *</span>
<span class="line-added">1124          * @param node the node</span>
<span class="line-added">1125          * @return savedState to reacquire after wait</span>
<span class="line-added">1126          */</span>
<span class="line-added">1127         private long enableWait(ConditionNode node) {</span>
<span class="line-added">1128             if (isHeldExclusively()) {</span>
<span class="line-added">1129                 node.waiter = Thread.currentThread();</span>
<span class="line-added">1130                 node.setStatusRelaxed(COND | WAITING);</span>
<span class="line-added">1131                 ConditionNode last = lastWaiter;</span>
<span class="line-added">1132                 if (last == null)</span>
<span class="line-added">1133                     firstWaiter = node;</span>
<span class="line-added">1134                 else</span>
<span class="line-added">1135                     last.nextWaiter = node;</span>
<span class="line-added">1136                 lastWaiter = node;</span>
<span class="line-added">1137                 long savedState = getState();</span>
<span class="line-added">1138                 if (release(savedState))</span>
<span class="line-added">1139                     return savedState;</span>
<span class="line-added">1140             }</span>
<span class="line-added">1141             node.status = CANCELLED; // lock not held or inconsistent</span>
<span class="line-added">1142             throw new IllegalMonitorStateException();</span>
<span class="line-added">1143         }</span>
<span class="line-added">1144 </span>
<span class="line-added">1145         /**</span>
<span class="line-added">1146          * Returns true if a node that was initially placed on a condition</span>
<span class="line-added">1147          * queue is now ready to reacquire on sync queue.</span>
<span class="line-added">1148          * @param node the node</span>
<span class="line-added">1149          * @return true if is reacquiring</span>
<span class="line-added">1150          */</span>
<span class="line-added">1151         private boolean canReacquire(ConditionNode node) {</span>
<span class="line-added">1152             // check links, not status to avoid enqueue race</span>
<span class="line-added">1153             return node != null &amp;&amp; node.prev != null &amp;&amp; isEnqueued(node);</span>
<span class="line-added">1154         }</span>
<span class="line-added">1155 </span>
<span class="line-added">1156         /**</span>
<span class="line-added">1157          * Unlinks the given node and other non-waiting nodes from</span>
<span class="line-added">1158          * condition queue unless already unlinked.</span>
<span class="line-added">1159          */</span>
<span class="line-added">1160         private void unlinkCancelledWaiters(ConditionNode node) {</span>
<span class="line-added">1161             if (node == null || node.nextWaiter != null || node == lastWaiter) {</span>
<span class="line-added">1162                 ConditionNode w = firstWaiter, trail = null;</span>
<span class="line-added">1163                 while (w != null) {</span>
<span class="line-added">1164                     ConditionNode next = w.nextWaiter;</span>
<span class="line-added">1165                     if ((w.status &amp; COND) == 0) {</span>
<span class="line-added">1166                         w.nextWaiter = null;</span>
<span class="line-added">1167                         if (trail == null)</span>
<span class="line-added">1168                             firstWaiter = next;</span>
<span class="line-added">1169                         else</span>
<span class="line-added">1170                             trail.nextWaiter = next;</span>
<span class="line-added">1171                         if (next == null)</span>
<span class="line-added">1172                             lastWaiter = trail;</span>
<span class="line-added">1173                     } else</span>
<span class="line-added">1174                         trail = w;</span>
<span class="line-added">1175                     w = next;</span>
<span class="line-added">1176                 }</span>
<span class="line-added">1177             }</span>
1178         }
1179 
1180         /**
1181          * Implements uninterruptible condition wait.
1182          * &lt;ol&gt;
1183          * &lt;li&gt;Save lock state returned by {@link #getState}.
1184          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1185          *     throwing IllegalMonitorStateException if it fails.
1186          * &lt;li&gt;Block until signalled.
1187          * &lt;li&gt;Reacquire by invoking specialized version of
1188          *     {@link #acquire} with saved state as argument.
1189          * &lt;/ol&gt;
1190          */
1191         public final void awaitUninterruptibly() {
<span class="line-modified">1192             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1193             long savedState = enableWait(node);</span>
<span class="line-added">1194             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
1195             boolean interrupted = false;
<span class="line-modified">1196             while (!canReacquire(node)) {</span>

1197                 if (Thread.interrupted())
1198                     interrupted = true;
<span class="line-added">1199                 else if ((node.status &amp; COND) != 0) {</span>
<span class="line-added">1200                     try {</span>
<span class="line-added">1201                         ForkJoinPool.managedBlock(node);</span>
<span class="line-added">1202                     } catch (InterruptedException ie) {</span>
<span class="line-added">1203                         interrupted = true;</span>
<span class="line-added">1204                     }</span>
<span class="line-added">1205                 } else</span>
<span class="line-added">1206                     Thread.onSpinWait();    // awoke while enqueuing</span>
1207             }
<span class="line-modified">1208             LockSupport.setCurrentBlocker(null);</span>
<span class="line-modified">1209             node.clearStatus();</span>
<span class="line-modified">1210             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1211             if (interrupted)</span>
<span class="line-modified">1212                 Thread.currentThread().interrupt();</span>
































1213         }
1214 
1215         /**
1216          * Implements interruptible condition wait.
1217          * &lt;ol&gt;
1218          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1219          * &lt;li&gt;Save lock state returned by {@link #getState}.
1220          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1221          *     throwing IllegalMonitorStateException if it fails.
1222          * &lt;li&gt;Block until signalled or interrupted.
1223          * &lt;li&gt;Reacquire by invoking specialized version of
1224          *     {@link #acquire} with saved state as argument.
1225          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1226          * &lt;/ol&gt;
1227          */
1228         public final void await() throws InterruptedException {
1229             if (Thread.interrupted())
1230                 throw new InterruptedException();
<span class="line-modified">1231             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1232             long savedState = enableWait(node);</span>
<span class="line-modified">1233             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
<span class="line-modified">1234             boolean interrupted = false, cancelled = false;</span>
<span class="line-modified">1235             while (!canReacquire(node)) {</span>
<span class="line-modified">1236                 if (interrupted |= Thread.interrupted()) {</span>
<span class="line-modified">1237                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-added">1238                         break;              // else interrupted after signal</span>
<span class="line-added">1239                 } else if ((node.status &amp; COND) != 0) {</span>
<span class="line-added">1240                     try {</span>
<span class="line-added">1241                         ForkJoinPool.managedBlock(node);</span>
<span class="line-added">1242                     } catch (InterruptedException ie) {</span>
<span class="line-added">1243                         interrupted = true;</span>
<span class="line-added">1244                     }</span>
<span class="line-added">1245                 } else</span>
<span class="line-added">1246                     Thread.onSpinWait();    // awoke while enqueuing</span>
<span class="line-added">1247             }</span>
<span class="line-added">1248             LockSupport.setCurrentBlocker(null);</span>
<span class="line-added">1249             node.clearStatus();</span>
<span class="line-added">1250             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-added">1251             if (interrupted) {</span>
<span class="line-added">1252                 if (cancelled) {</span>
<span class="line-added">1253                     unlinkCancelledWaiters(node);</span>
<span class="line-added">1254                     throw new InterruptedException();</span>
<span class="line-added">1255                 }</span>
<span class="line-added">1256                 Thread.currentThread().interrupt();</span>
1257             }






1258         }
1259 
1260         /**
1261          * Implements timed condition wait.
1262          * &lt;ol&gt;
1263          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1264          * &lt;li&gt;Save lock state returned by {@link #getState}.
1265          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1266          *     throwing IllegalMonitorStateException if it fails.
1267          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1268          * &lt;li&gt;Reacquire by invoking specialized version of
1269          *     {@link #acquire} with saved state as argument.
1270          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1271          * &lt;/ol&gt;
1272          */
1273         public final long awaitNanos(long nanosTimeout)
1274                 throws InterruptedException {
1275             if (Thread.interrupted())
1276                 throw new InterruptedException();
<span class="line-modified">1277             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1278             long savedState = enableWait(node);</span>
<span class="line-modified">1279             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="line-modified">1280             long deadline = System.nanoTime() + nanos;</span>
<span class="line-modified">1281             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1282             while (!canReacquire(node)) {</span>
<span class="line-modified">1283                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1284                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-modified">1285                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1286                         break;</span>
<span class="line-modified">1287                 } else</span>
<span class="line-modified">1288                     LockSupport.parkNanos(this, nanos);</span>





1289             }
<span class="line-modified">1290             node.clearStatus();</span>
<span class="line-modified">1291             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1292             if (cancelled) {</span>
<span class="line-modified">1293                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1294                 if (interrupted)</span>
<span class="line-modified">1295                     throw new InterruptedException();</span>
<span class="line-added">1296             } else if (interrupted)</span>
<span class="line-added">1297                 Thread.currentThread().interrupt();</span>
1298             long remaining = deadline - System.nanoTime(); // avoid overflow
<span class="line-modified">1299             return (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;</span>
1300         }
1301 
1302         /**
1303          * Implements absolute timed condition wait.
1304          * &lt;ol&gt;
1305          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1306          * &lt;li&gt;Save lock state returned by {@link #getState}.
1307          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1308          *     throwing IllegalMonitorStateException if it fails.
1309          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1310          * &lt;li&gt;Reacquire by invoking specialized version of
1311          *     {@link #acquire} with saved state as argument.
1312          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1313          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1314          * &lt;/ol&gt;
1315          */
1316         public final boolean awaitUntil(Date deadline)
1317                 throws InterruptedException {
1318             long abstime = deadline.getTime();
1319             if (Thread.interrupted())
1320                 throw new InterruptedException();
<span class="line-modified">1321             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1322             long savedState = enableWait(node);</span>
<span class="line-modified">1323             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1324             while (!canReacquire(node)) {</span>
<span class="line-modified">1325                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1326                     System.currentTimeMillis() &gt;= abstime) {</span>
<span class="line-modified">1327                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1328                         break;</span>
<span class="line-modified">1329                 } else</span>
<span class="line-modified">1330                     LockSupport.parkUntil(this, abstime);</span>


1331             }
<span class="line-modified">1332             node.clearStatus();</span>
<span class="line-modified">1333             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1334             if (cancelled) {</span>
<span class="line-modified">1335                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1336                 if (interrupted)</span>
<span class="line-modified">1337                     throw new InterruptedException();</span>
<span class="line-modified">1338             } else if (interrupted)</span>
<span class="line-added">1339                 Thread.currentThread().interrupt();</span>
<span class="line-added">1340             return !cancelled;</span>
1341         }
1342 
1343         /**
1344          * Implements timed condition wait.
1345          * &lt;ol&gt;
1346          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1347          * &lt;li&gt;Save lock state returned by {@link #getState}.
1348          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1349          *     throwing IllegalMonitorStateException if it fails.
1350          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1351          * &lt;li&gt;Reacquire by invoking specialized version of
1352          *     {@link #acquire} with saved state as argument.
1353          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1354          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1355          * &lt;/ol&gt;
1356          */
1357         public final boolean await(long time, TimeUnit unit)
1358                 throws InterruptedException {
1359             long nanosTimeout = unit.toNanos(time);
1360             if (Thread.interrupted())
1361                 throw new InterruptedException();
<span class="line-modified">1362             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1363             long savedState = enableWait(node);</span>
<span class="line-modified">1364             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="line-modified">1365             long deadline = System.nanoTime() + nanos;</span>
<span class="line-modified">1366             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1367             while (!canReacquire(node)) {</span>
<span class="line-modified">1368                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1369                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-modified">1370                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1371                         break;</span>
<span class="line-modified">1372                 } else</span>
<span class="line-modified">1373                     LockSupport.parkNanos(this, nanos);</span>





1374             }
<span class="line-modified">1375             node.clearStatus();</span>
<span class="line-modified">1376             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1377             if (cancelled) {</span>
<span class="line-modified">1378                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1379                 if (interrupted)</span>
<span class="line-modified">1380                     throw new InterruptedException();</span>
<span class="line-modified">1381             } else if (interrupted)</span>
<span class="line-added">1382                 Thread.currentThread().interrupt();</span>
<span class="line-added">1383             return !cancelled;</span>
1384         }
1385 
1386         //  support for instrumentation
1387 
1388         /**
1389          * Returns true if this condition was created by the given
1390          * synchronization object.
1391          *
1392          * @return {@code true} if owned
1393          */
1394         final boolean isOwnedBy(AbstractQueuedLongSynchronizer sync) {
1395             return sync == AbstractQueuedLongSynchronizer.this;
1396         }
1397 
1398         /**
1399          * Queries whether any threads are waiting on this condition.
1400          * Implements {@link AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject)}.
1401          *
1402          * @return {@code true} if there are any waiting threads
1403          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1404          *         returns {@code false}
1405          */
1406         protected final boolean hasWaiters() {
1407             if (!isHeldExclusively())
1408                 throw new IllegalMonitorStateException();
<span class="line-modified">1409             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1410                 if ((w.status &amp; COND) != 0)</span>
1411                     return true;
1412             }
1413             return false;
1414         }
1415 
1416         /**
1417          * Returns an estimate of the number of threads waiting on
1418          * this condition.
1419          * Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject)}.
1420          *
1421          * @return the estimated number of waiting threads
1422          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1423          *         returns {@code false}
1424          */
1425         protected final int getWaitQueueLength() {
1426             if (!isHeldExclusively())
1427                 throw new IllegalMonitorStateException();
1428             int n = 0;
<span class="line-modified">1429             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1430                 if ((w.status &amp; COND) != 0)</span>
1431                     ++n;
1432             }
1433             return n;
1434         }
1435 
1436         /**
1437          * Returns a collection containing those threads that may be
1438          * waiting on this Condition.
1439          * Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject)}.
1440          *
1441          * @return the collection of threads
1442          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1443          *         returns {@code false}
1444          */
1445         protected final Collection&lt;Thread&gt; getWaitingThreads() {
1446             if (!isHeldExclusively())
1447                 throw new IllegalMonitorStateException();
1448             ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified">1449             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1450                 if ((w.status &amp; COND) != 0) {</span>
<span class="line-modified">1451                     Thread t = w.waiter;</span>
1452                     if (t != null)
1453                         list.add(t);
1454                 }
1455             }
1456             return list;
1457         }
1458     }
1459 
<span class="line-modified">1460     // Unsafe</span>
<span class="line-modified">1461     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="line-modified">1462     private static final long STATE</span>
<span class="line-modified">1463         = U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, &quot;state&quot;);</span>
<span class="line-added">1464     private static final long HEAD</span>
<span class="line-added">1465         = U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, &quot;head&quot;);</span>
<span class="line-added">1466     private static final long TAIL</span>
<span class="line-added">1467         = U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, &quot;tail&quot;);</span>
1468 
1469     static {











1470         Class&lt;?&gt; ensureLoaded = LockSupport.class;
1471     }
















1472 }
</pre>
</td>
</tr>
</table>
<center><a href="../atomic/LongAccumulator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractQueuedSynchronizer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
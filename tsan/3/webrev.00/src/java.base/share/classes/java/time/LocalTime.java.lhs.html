<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/LocalTime.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time;
  63 
  64 import static java.time.temporal.ChronoField.HOUR_OF_DAY;
  65 import static java.time.temporal.ChronoField.MICRO_OF_DAY;
  66 import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
  67 import static java.time.temporal.ChronoField.NANO_OF_DAY;
  68 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  69 import static java.time.temporal.ChronoField.SECOND_OF_DAY;
  70 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
  71 import static java.time.temporal.ChronoUnit.NANOS;
  72 
  73 import java.io.DataInput;
  74 import java.io.DataOutput;
  75 import java.io.IOException;
  76 import java.io.InvalidObjectException;
  77 import java.io.ObjectInputStream;
  78 import java.io.Serializable;
  79 import java.time.format.DateTimeFormatter;
  80 import java.time.format.DateTimeParseException;
  81 import java.time.temporal.ChronoField;
  82 import java.time.temporal.ChronoUnit;
  83 import java.time.temporal.Temporal;
  84 import java.time.temporal.TemporalAccessor;
  85 import java.time.temporal.TemporalAdjuster;
  86 import java.time.temporal.TemporalAmount;
  87 import java.time.temporal.TemporalField;
  88 import java.time.temporal.TemporalQueries;
  89 import java.time.temporal.TemporalQuery;
  90 import java.time.temporal.TemporalUnit;
  91 import java.time.temporal.UnsupportedTemporalTypeException;
  92 import java.time.temporal.ValueRange;
  93 import java.util.Objects;
  94 
  95 /**
  96  * A time without a time-zone in the ISO-8601 calendar system,
  97  * such as {@code 10:15:30}.
  98  * &lt;p&gt;
  99  * {@code LocalTime} is an immutable date-time object that represents a time,
 100  * often viewed as hour-minute-second.
 101  * Time is represented to nanosecond precision.
 102  * For example, the value &quot;13:45.30.123456789&quot; can be stored in a {@code LocalTime}.
 103  * &lt;p&gt;
 104  * This class does not store or represent a date or time-zone.
 105  * Instead, it is a description of the local time as seen on a wall clock.
 106  * It cannot represent an instant on the time-line without additional information
 107  * such as an offset or time-zone.
 108  * &lt;p&gt;
 109  * The ISO-8601 calendar system is the modern civil calendar system used today
 110  * in most of the world. This API assumes that all calendar systems use the same
 111  * representation, this class, for time-of-day.
 112  *
 113  * &lt;p&gt;
 114  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 115  * class; use of identity-sensitive operations (including reference equality
 116  * ({@code ==}), identity hash code, or synchronization) on instances of
 117  * {@code LocalTime} may have unpredictable results and should be avoided.
 118  * The {@code equals} method should be used for comparisons.
 119  *
 120  * @implSpec
 121  * This class is immutable and thread-safe.
 122  *
 123  * @since 1.8
 124  */
 125 public final class LocalTime
 126         implements Temporal, TemporalAdjuster, Comparable&lt;LocalTime&gt;, Serializable {
 127 
 128     /**
 129      * The minimum supported {@code LocalTime}, &#39;00:00&#39;.
 130      * This is the time of midnight at the start of the day.
 131      */
 132     public static final LocalTime MIN;
 133     /**
 134      * The maximum supported {@code LocalTime}, &#39;23:59:59.999999999&#39;.
 135      * This is the time just before midnight at the end of the day.
 136      */
 137     public static final LocalTime MAX;
 138     /**
 139      * The time of midnight at the start of the day, &#39;00:00&#39;.
 140      */
 141     public static final LocalTime MIDNIGHT;
 142     /**
 143      * The time of noon in the middle of the day, &#39;12:00&#39;.
 144      */
 145     public static final LocalTime NOON;
 146     /**
 147      * Constants for the local time of each hour.
 148      */
 149     private static final LocalTime[] HOURS = new LocalTime[24];
 150     static {
 151         for (int i = 0; i &lt; HOURS.length; i++) {
 152             HOURS[i] = new LocalTime(i, 0, 0, 0);
 153         }
 154         MIDNIGHT = HOURS[0];
 155         NOON = HOURS[12];
 156         MIN = HOURS[0];
 157         MAX = new LocalTime(23, 59, 59, 999_999_999);
 158     }
 159 
 160     /**
 161      * Hours per day.
 162      */
 163     static final int HOURS_PER_DAY = 24;
 164     /**
 165      * Minutes per hour.
 166      */
 167     static final int MINUTES_PER_HOUR = 60;
 168     /**
 169      * Minutes per day.
 170      */
 171     static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;
 172     /**
 173      * Seconds per minute.
 174      */
 175     static final int SECONDS_PER_MINUTE = 60;
 176     /**
 177      * Seconds per hour.
 178      */
 179     static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
 180     /**
 181      * Seconds per day.
 182      */
 183     static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
 184     /**
 185      * Milliseconds per day.
 186      */
 187     static final long MILLIS_PER_DAY = SECONDS_PER_DAY * 1000L;
 188     /**
 189      * Microseconds per day.
 190      */
 191     static final long MICROS_PER_DAY = SECONDS_PER_DAY * 1000_000L;
 192     /**
 193      * Nanos per millisecond.
 194      */
 195     static final long NANOS_PER_MILLI = 1000_000L;
 196     /**
 197      * Nanos per second.
 198      */
 199     static final long NANOS_PER_SECOND =  1000_000_000L;
 200     /**
 201      * Nanos per minute.
 202      */
 203     static final long NANOS_PER_MINUTE = NANOS_PER_SECOND * SECONDS_PER_MINUTE;
 204     /**
 205      * Nanos per hour.
 206      */
 207     static final long NANOS_PER_HOUR = NANOS_PER_MINUTE * MINUTES_PER_HOUR;
 208     /**
 209      * Nanos per day.
 210      */
 211     static final long NANOS_PER_DAY = NANOS_PER_HOUR * HOURS_PER_DAY;
 212 
 213     /**
 214      * Serialization version.
 215      */
<a name="2" id="anc2"></a>
 216     private static final long serialVersionUID = 6414437269572265201L;
 217 
 218     /**
 219      * The hour.
 220      */
 221     private final byte hour;
 222     /**
 223      * The minute.
 224      */
 225     private final byte minute;
 226     /**
 227      * The second.
 228      */
 229     private final byte second;
 230     /**
 231      * The nanosecond.
 232      */
 233     private final int nano;
 234 
 235     //-----------------------------------------------------------------------
 236     /**
 237      * Obtains the current time from the system clock in the default time-zone.
 238      * &lt;p&gt;
 239      * This will query the {@link Clock#systemDefaultZone() system clock} in the default
 240      * time-zone to obtain the current time.
 241      * &lt;p&gt;
 242      * Using this method will prevent the ability to use an alternate clock for testing
 243      * because the clock is hard-coded.
 244      *
 245      * @return the current time using the system clock and default time-zone, not null
 246      */
 247     public static LocalTime now() {
 248         return now(Clock.systemDefaultZone());
 249     }
 250 
 251     /**
 252      * Obtains the current time from the system clock in the specified time-zone.
 253      * &lt;p&gt;
 254      * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current time.
 255      * Specifying the time-zone avoids dependence on the default time-zone.
 256      * &lt;p&gt;
 257      * Using this method will prevent the ability to use an alternate clock for testing
 258      * because the clock is hard-coded.
 259      *
 260      * @param zone  the zone ID to use, not null
 261      * @return the current time using the system clock, not null
 262      */
 263     public static LocalTime now(ZoneId zone) {
 264         return now(Clock.system(zone));
 265     }
 266 
 267     /**
 268      * Obtains the current time from the specified clock.
 269      * &lt;p&gt;
 270      * This will query the specified clock to obtain the current time.
 271      * Using this method allows the use of an alternate clock for testing.
 272      * The alternate clock may be introduced using {@link Clock dependency injection}.
 273      *
 274      * @param clock  the clock to use, not null
 275      * @return the current time, not null
 276      */
 277     public static LocalTime now(Clock clock) {
 278         Objects.requireNonNull(clock, &quot;clock&quot;);
 279         final Instant now = clock.instant();  // called once
 280         return ofInstant(now, clock.getZone());
 281     }
 282 
 283     //-----------------------------------------------------------------------
 284     /**
 285      * Obtains an instance of {@code LocalTime} from an hour and minute.
 286      * &lt;p&gt;
 287      * This returns a {@code LocalTime} with the specified hour and minute.
 288      * The second and nanosecond fields will be set to zero.
 289      *
 290      * @param hour  the hour-of-day to represent, from 0 to 23
 291      * @param minute  the minute-of-hour to represent, from 0 to 59
 292      * @return the local time, not null
 293      * @throws DateTimeException if the value of any field is out of range
 294      */
 295     public static LocalTime of(int hour, int minute) {
 296         HOUR_OF_DAY.checkValidValue(hour);
 297         if (minute == 0) {
 298             return HOURS[hour];  // for performance
 299         }
 300         MINUTE_OF_HOUR.checkValidValue(minute);
 301         return new LocalTime(hour, minute, 0, 0);
 302     }
 303 
 304     /**
 305      * Obtains an instance of {@code LocalTime} from an hour, minute and second.
 306      * &lt;p&gt;
 307      * This returns a {@code LocalTime} with the specified hour, minute and second.
 308      * The nanosecond field will be set to zero.
 309      *
 310      * @param hour  the hour-of-day to represent, from 0 to 23
 311      * @param minute  the minute-of-hour to represent, from 0 to 59
 312      * @param second  the second-of-minute to represent, from 0 to 59
 313      * @return the local time, not null
 314      * @throws DateTimeException if the value of any field is out of range
 315      */
 316     public static LocalTime of(int hour, int minute, int second) {
 317         HOUR_OF_DAY.checkValidValue(hour);
 318         if ((minute | second) == 0) {
 319             return HOURS[hour];  // for performance
 320         }
 321         MINUTE_OF_HOUR.checkValidValue(minute);
 322         SECOND_OF_MINUTE.checkValidValue(second);
 323         return new LocalTime(hour, minute, second, 0);
 324     }
 325 
 326     /**
 327      * Obtains an instance of {@code LocalTime} from an hour, minute, second and nanosecond.
 328      * &lt;p&gt;
 329      * This returns a {@code LocalTime} with the specified hour, minute, second and nanosecond.
 330      *
 331      * @param hour  the hour-of-day to represent, from 0 to 23
 332      * @param minute  the minute-of-hour to represent, from 0 to 59
 333      * @param second  the second-of-minute to represent, from 0 to 59
 334      * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
 335      * @return the local time, not null
 336      * @throws DateTimeException if the value of any field is out of range
 337      */
 338     public static LocalTime of(int hour, int minute, int second, int nanoOfSecond) {
 339         HOUR_OF_DAY.checkValidValue(hour);
 340         MINUTE_OF_HOUR.checkValidValue(minute);
 341         SECOND_OF_MINUTE.checkValidValue(second);
 342         NANO_OF_SECOND.checkValidValue(nanoOfSecond);
 343         return create(hour, minute, second, nanoOfSecond);
 344     }
 345 
 346     /**
 347      * Obtains an instance of {@code LocalTime} from an {@code Instant} and zone ID.
 348      * &lt;p&gt;
 349      * This creates a local time based on the specified instant.
 350      * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,
 351      * which is simple as there is only one valid offset for each instant.
 352      * Then, the instant and offset are used to calculate the local time.
 353      *
 354      * @param instant  the instant to create the time from, not null
 355      * @param zone  the time-zone, which may be an offset, not null
 356      * @return the local time, not null
 357      * @since 9
 358      */
 359     public static LocalTime ofInstant(Instant instant, ZoneId zone) {
 360         Objects.requireNonNull(instant, &quot;instant&quot;);
 361         Objects.requireNonNull(zone, &quot;zone&quot;);
 362         ZoneOffset offset = zone.getRules().getOffset(instant);
 363         long localSecond = instant.getEpochSecond() + offset.getTotalSeconds();
 364         int secsOfDay = Math.floorMod(localSecond, SECONDS_PER_DAY);
 365         return ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + instant.getNano());
 366     }
 367 
 368     //-----------------------------------------------------------------------
 369     /**
 370      * Obtains an instance of {@code LocalTime} from a second-of-day value.
 371      * &lt;p&gt;
 372      * This returns a {@code LocalTime} with the specified second-of-day.
 373      * The nanosecond field will be set to zero.
 374      *
 375      * @param secondOfDay  the second-of-day, from {@code 0} to {@code 24 * 60 * 60 - 1}
 376      * @return the local time, not null
 377      * @throws DateTimeException if the second-of-day value is invalid
 378      */
 379     public static LocalTime ofSecondOfDay(long secondOfDay) {
 380         SECOND_OF_DAY.checkValidValue(secondOfDay);
 381         int hours = (int) (secondOfDay / SECONDS_PER_HOUR);
 382         secondOfDay -= hours * SECONDS_PER_HOUR;
 383         int minutes = (int) (secondOfDay / SECONDS_PER_MINUTE);
 384         secondOfDay -= minutes * SECONDS_PER_MINUTE;
 385         return create(hours, minutes, (int) secondOfDay, 0);
 386     }
 387 
 388     /**
 389      * Obtains an instance of {@code LocalTime} from a nanos-of-day value.
 390      * &lt;p&gt;
 391      * This returns a {@code LocalTime} with the specified nanosecond-of-day.
 392      *
 393      * @param nanoOfDay  the nano of day, from {@code 0} to {@code 24 * 60 * 60 * 1,000,000,000 - 1}
 394      * @return the local time, not null
 395      * @throws DateTimeException if the nanos of day value is invalid
 396      */
 397     public static LocalTime ofNanoOfDay(long nanoOfDay) {
 398         NANO_OF_DAY.checkValidValue(nanoOfDay);
 399         int hours = (int) (nanoOfDay / NANOS_PER_HOUR);
 400         nanoOfDay -= hours * NANOS_PER_HOUR;
 401         int minutes = (int) (nanoOfDay / NANOS_PER_MINUTE);
 402         nanoOfDay -= minutes * NANOS_PER_MINUTE;
 403         int seconds = (int) (nanoOfDay / NANOS_PER_SECOND);
 404         nanoOfDay -= seconds * NANOS_PER_SECOND;
 405         return create(hours, minutes, seconds, (int) nanoOfDay);
 406     }
 407 
 408     //-----------------------------------------------------------------------
 409     /**
 410      * Obtains an instance of {@code LocalTime} from a temporal object.
 411      * &lt;p&gt;
 412      * This obtains a local time based on the specified temporal.
 413      * A {@code TemporalAccessor} represents an arbitrary set of date and time information,
 414      * which this factory converts to an instance of {@code LocalTime}.
 415      * &lt;p&gt;
 416      * The conversion uses the {@link TemporalQueries#localTime()} query, which relies
 417      * on extracting the {@link ChronoField#NANO_OF_DAY NANO_OF_DAY} field.
 418      * &lt;p&gt;
 419      * This method matches the signature of the functional interface {@link TemporalQuery}
 420      * allowing it to be used as a query via method reference, {@code LocalTime::from}.
 421      *
 422      * @param temporal  the temporal object to convert, not null
 423      * @return the local time, not null
 424      * @throws DateTimeException if unable to convert to a {@code LocalTime}
 425      */
 426     public static LocalTime from(TemporalAccessor temporal) {
 427         Objects.requireNonNull(temporal, &quot;temporal&quot;);
 428         LocalTime time = temporal.query(TemporalQueries.localTime());
 429         if (time == null) {
 430             throw new DateTimeException(&quot;Unable to obtain LocalTime from TemporalAccessor: &quot; +
 431                     temporal + &quot; of type &quot; + temporal.getClass().getName());
 432         }
 433         return time;
 434     }
 435 
 436     //-----------------------------------------------------------------------
 437     /**
 438      * Obtains an instance of {@code LocalTime} from a text string such as {@code 10:15}.
 439      * &lt;p&gt;
 440      * The string must represent a valid time and is parsed using
 441      * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_TIME}.
 442      *
 443      * @param text  the text to parse such as &quot;10:15:30&quot;, not null
 444      * @return the parsed local time, not null
 445      * @throws DateTimeParseException if the text cannot be parsed
 446      */
 447     public static LocalTime parse(CharSequence text) {
 448         return parse(text, DateTimeFormatter.ISO_LOCAL_TIME);
 449     }
 450 
 451     /**
 452      * Obtains an instance of {@code LocalTime} from a text string using a specific formatter.
 453      * &lt;p&gt;
 454      * The text is parsed using the formatter, returning a time.
 455      *
 456      * @param text  the text to parse, not null
 457      * @param formatter  the formatter to use, not null
 458      * @return the parsed local time, not null
 459      * @throws DateTimeParseException if the text cannot be parsed
 460      */
 461     public static LocalTime parse(CharSequence text, DateTimeFormatter formatter) {
 462         Objects.requireNonNull(formatter, &quot;formatter&quot;);
 463         return formatter.parse(text, LocalTime::from);
 464     }
 465 
 466     //-----------------------------------------------------------------------
 467     /**
 468      * Creates a local time from the hour, minute, second and nanosecond fields.
 469      * &lt;p&gt;
 470      * This factory may return a cached value, but applications must not rely on this.
 471      *
 472      * @param hour  the hour-of-day to represent, validated from 0 to 23
 473      * @param minute  the minute-of-hour to represent, validated from 0 to 59
 474      * @param second  the second-of-minute to represent, validated from 0 to 59
 475      * @param nanoOfSecond  the nano-of-second to represent, validated from 0 to 999,999,999
 476      * @return the local time, not null
 477      */
 478     private static LocalTime create(int hour, int minute, int second, int nanoOfSecond) {
 479         if ((minute | second | nanoOfSecond) == 0) {
 480             return HOURS[hour];
 481         }
 482         return new LocalTime(hour, minute, second, nanoOfSecond);
 483     }
 484 
 485     /**
 486      * Constructor, previously validated.
 487      *
 488      * @param hour  the hour-of-day to represent, validated from 0 to 23
 489      * @param minute  the minute-of-hour to represent, validated from 0 to 59
 490      * @param second  the second-of-minute to represent, validated from 0 to 59
 491      * @param nanoOfSecond  the nano-of-second to represent, validated from 0 to 999,999,999
 492      */
 493     private LocalTime(int hour, int minute, int second, int nanoOfSecond) {
 494         this.hour = (byte) hour;
 495         this.minute = (byte) minute;
 496         this.second = (byte) second;
 497         this.nano = nanoOfSecond;
 498     }
 499 
 500     //-----------------------------------------------------------------------
 501     /**
 502      * Checks if the specified field is supported.
 503      * &lt;p&gt;
 504      * This checks if this time can be queried for the specified field.
 505      * If false, then calling the {@link #range(TemporalField) range},
 506      * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
 507      * methods will throw an exception.
 508      * &lt;p&gt;
 509      * If the field is a {@link ChronoField} then the query is implemented here.
 510      * The supported fields are:
 511      * &lt;ul&gt;
 512      * &lt;li&gt;{@code NANO_OF_SECOND}
 513      * &lt;li&gt;{@code NANO_OF_DAY}
 514      * &lt;li&gt;{@code MICRO_OF_SECOND}
 515      * &lt;li&gt;{@code MICRO_OF_DAY}
 516      * &lt;li&gt;{@code MILLI_OF_SECOND}
 517      * &lt;li&gt;{@code MILLI_OF_DAY}
 518      * &lt;li&gt;{@code SECOND_OF_MINUTE}
 519      * &lt;li&gt;{@code SECOND_OF_DAY}
 520      * &lt;li&gt;{@code MINUTE_OF_HOUR}
 521      * &lt;li&gt;{@code MINUTE_OF_DAY}
 522      * &lt;li&gt;{@code HOUR_OF_AMPM}
 523      * &lt;li&gt;{@code CLOCK_HOUR_OF_AMPM}
 524      * &lt;li&gt;{@code HOUR_OF_DAY}
 525      * &lt;li&gt;{@code CLOCK_HOUR_OF_DAY}
 526      * &lt;li&gt;{@code AMPM_OF_DAY}
 527      * &lt;/ul&gt;
 528      * All other {@code ChronoField} instances will return false.
 529      * &lt;p&gt;
 530      * If the field is not a {@code ChronoField}, then the result of this method
 531      * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
 532      * passing {@code this} as the argument.
 533      * Whether the field is supported is determined by the field.
 534      *
 535      * @param field  the field to check, null returns false
 536      * @return true if the field is supported on this time, false if not
 537      */
 538     @Override
 539     public boolean isSupported(TemporalField field) {
 540         if (field instanceof ChronoField) {
 541             return field.isTimeBased();
 542         }
 543         return field != null &amp;&amp; field.isSupportedBy(this);
 544     }
 545 
 546     /**
 547      * Checks if the specified unit is supported.
 548      * &lt;p&gt;
 549      * This checks if the specified unit can be added to, or subtracted from, this time.
 550      * If false, then calling the {@link #plus(long, TemporalUnit)} and
 551      * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
 552      * &lt;p&gt;
 553      * If the unit is a {@link ChronoUnit} then the query is implemented here.
 554      * The supported units are:
 555      * &lt;ul&gt;
 556      * &lt;li&gt;{@code NANOS}
 557      * &lt;li&gt;{@code MICROS}
 558      * &lt;li&gt;{@code MILLIS}
 559      * &lt;li&gt;{@code SECONDS}
 560      * &lt;li&gt;{@code MINUTES}
 561      * &lt;li&gt;{@code HOURS}
 562      * &lt;li&gt;{@code HALF_DAYS}
 563      * &lt;/ul&gt;
 564      * All other {@code ChronoUnit} instances will return false.
 565      * &lt;p&gt;
 566      * If the unit is not a {@code ChronoUnit}, then the result of this method
 567      * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
 568      * passing {@code this} as the argument.
 569      * Whether the unit is supported is determined by the unit.
 570      *
 571      * @param unit  the unit to check, null returns false
 572      * @return true if the unit can be added/subtracted, false if not
 573      */
 574     @Override  // override for Javadoc
 575     public boolean isSupported(TemporalUnit unit) {
 576         if (unit instanceof ChronoUnit) {
 577             return unit.isTimeBased();
 578         }
 579         return unit != null &amp;&amp; unit.isSupportedBy(this);
 580     }
 581 
 582     //-----------------------------------------------------------------------
 583     /**
 584      * Gets the range of valid values for the specified field.
 585      * &lt;p&gt;
 586      * The range object expresses the minimum and maximum valid values for a field.
 587      * This time is used to enhance the accuracy of the returned range.
 588      * If it is not possible to return the range, because the field is not supported
 589      * or for some other reason, an exception is thrown.
 590      * &lt;p&gt;
 591      * If the field is a {@link ChronoField} then the query is implemented here.
 592      * The {@link #isSupported(TemporalField) supported fields} will return
 593      * appropriate range instances.
 594      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 595      * &lt;p&gt;
 596      * If the field is not a {@code ChronoField}, then the result of this method
 597      * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
 598      * passing {@code this} as the argument.
 599      * Whether the range can be obtained is determined by the field.
 600      *
 601      * @param field  the field to query the range for, not null
 602      * @return the range of valid values for the field, not null
 603      * @throws DateTimeException if the range for the field cannot be obtained
 604      * @throws UnsupportedTemporalTypeException if the field is not supported
 605      */
 606     @Override  // override for Javadoc
 607     public ValueRange range(TemporalField field) {
 608         return Temporal.super.range(field);
 609     }
 610 
 611     /**
 612      * Gets the value of the specified field from this time as an {@code int}.
 613      * &lt;p&gt;
 614      * This queries this time for the value of the specified field.
 615      * The returned value will always be within the valid range of values for the field.
 616      * If it is not possible to return the value, because the field is not supported
 617      * or for some other reason, an exception is thrown.
 618      * &lt;p&gt;
 619      * If the field is a {@link ChronoField} then the query is implemented here.
 620      * The {@link #isSupported(TemporalField) supported fields} will return valid
 621      * values based on this time, except {@code NANO_OF_DAY} and {@code MICRO_OF_DAY}
 622      * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.
 623      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 624      * &lt;p&gt;
 625      * If the field is not a {@code ChronoField}, then the result of this method
 626      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
 627      * passing {@code this} as the argument. Whether the value can be obtained,
 628      * and what the value represents, is determined by the field.
 629      *
 630      * @param field  the field to get, not null
 631      * @return the value for the field
 632      * @throws DateTimeException if a value for the field cannot be obtained or
 633      *         the value is outside the range of valid values for the field
 634      * @throws UnsupportedTemporalTypeException if the field is not supported or
 635      *         the range of values exceeds an {@code int}
 636      * @throws ArithmeticException if numeric overflow occurs
 637      */
 638     @Override  // override for Javadoc and performance
 639     public int get(TemporalField field) {
 640         if (field instanceof ChronoField) {
 641             return get0(field);
 642         }
 643         return Temporal.super.get(field);
 644     }
 645 
 646     /**
 647      * Gets the value of the specified field from this time as a {@code long}.
 648      * &lt;p&gt;
 649      * This queries this time for the value of the specified field.
 650      * If it is not possible to return the value, because the field is not supported
 651      * or for some other reason, an exception is thrown.
 652      * &lt;p&gt;
 653      * If the field is a {@link ChronoField} then the query is implemented here.
 654      * The {@link #isSupported(TemporalField) supported fields} will return valid
 655      * values based on this time.
 656      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 657      * &lt;p&gt;
 658      * If the field is not a {@code ChronoField}, then the result of this method
 659      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
 660      * passing {@code this} as the argument. Whether the value can be obtained,
 661      * and what the value represents, is determined by the field.
 662      *
 663      * @param field  the field to get, not null
 664      * @return the value for the field
 665      * @throws DateTimeException if a value for the field cannot be obtained
 666      * @throws UnsupportedTemporalTypeException if the field is not supported
 667      * @throws ArithmeticException if numeric overflow occurs
 668      */
 669     @Override
 670     public long getLong(TemporalField field) {
 671         if (field instanceof ChronoField) {
 672             if (field == NANO_OF_DAY) {
 673                 return toNanoOfDay();
 674             }
 675             if (field == MICRO_OF_DAY) {
 676                 return toNanoOfDay() / 1000;
 677             }
 678             return get0(field);
 679         }
 680         return field.getFrom(this);
 681     }
 682 
 683     private int get0(TemporalField field) {
 684         switch ((ChronoField) field) {
 685             case NANO_OF_SECOND: return nano;
 686             case NANO_OF_DAY: throw new UnsupportedTemporalTypeException(&quot;Invalid field &#39;NanoOfDay&#39; for get() method, use getLong() instead&quot;);
 687             case MICRO_OF_SECOND: return nano / 1000;
 688             case MICRO_OF_DAY: throw new UnsupportedTemporalTypeException(&quot;Invalid field &#39;MicroOfDay&#39; for get() method, use getLong() instead&quot;);
 689             case MILLI_OF_SECOND: return nano / 1000_000;
 690             case MILLI_OF_DAY: return (int) (toNanoOfDay() / 1000_000);
 691             case SECOND_OF_MINUTE: return second;
 692             case SECOND_OF_DAY: return toSecondOfDay();
 693             case MINUTE_OF_HOUR: return minute;
 694             case MINUTE_OF_DAY: return hour * 60 + minute;
 695             case HOUR_OF_AMPM: return hour % 12;
 696             case CLOCK_HOUR_OF_AMPM: int ham = hour % 12; return (ham % 12 == 0 ? 12 : ham);
 697             case HOUR_OF_DAY: return hour;
 698             case CLOCK_HOUR_OF_DAY: return (hour == 0 ? 24 : hour);
 699             case AMPM_OF_DAY: return hour / 12;
 700         }
 701         throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
 702     }
 703 
 704     //-----------------------------------------------------------------------
 705     /**
 706      * Gets the hour-of-day field.
 707      *
 708      * @return the hour-of-day, from 0 to 23
 709      */
 710     public int getHour() {
 711         return hour;
 712     }
 713 
 714     /**
 715      * Gets the minute-of-hour field.
 716      *
 717      * @return the minute-of-hour, from 0 to 59
 718      */
 719     public int getMinute() {
 720         return minute;
 721     }
 722 
 723     /**
 724      * Gets the second-of-minute field.
 725      *
 726      * @return the second-of-minute, from 0 to 59
 727      */
 728     public int getSecond() {
 729         return second;
 730     }
 731 
 732     /**
 733      * Gets the nano-of-second field.
 734      *
 735      * @return the nano-of-second, from 0 to 999,999,999
 736      */
 737     public int getNano() {
 738         return nano;
 739     }
 740 
 741     //-----------------------------------------------------------------------
 742     /**
 743      * Returns an adjusted copy of this time.
 744      * &lt;p&gt;
 745      * This returns a {@code LocalTime}, based on this one, with the time adjusted.
 746      * The adjustment takes place using the specified adjuster strategy object.
 747      * Read the documentation of the adjuster to understand what adjustment will be made.
 748      * &lt;p&gt;
 749      * A simple adjuster might simply set the one of the fields, such as the hour field.
 750      * A more complex adjuster might set the time to the last hour of the day.
 751      * &lt;p&gt;
 752      * The result of this method is obtained by invoking the
 753      * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
 754      * specified adjuster passing {@code this} as the argument.
 755      * &lt;p&gt;
 756      * This instance is immutable and unaffected by this method call.
 757      *
 758      * @param adjuster the adjuster to use, not null
 759      * @return a {@code LocalTime} based on {@code this} with the adjustment made, not null
 760      * @throws DateTimeException if the adjustment cannot be made
 761      * @throws ArithmeticException if numeric overflow occurs
 762      */
 763     @Override
 764     public LocalTime with(TemporalAdjuster adjuster) {
 765         // optimizations
 766         if (adjuster instanceof LocalTime) {
 767             return (LocalTime) adjuster;
 768         }
 769         return (LocalTime) adjuster.adjustInto(this);
 770     }
 771 
 772     /**
 773      * Returns a copy of this time with the specified field set to a new value.
 774      * &lt;p&gt;
 775      * This returns a {@code LocalTime}, based on this one, with the value
 776      * for the specified field changed.
 777      * This can be used to change any supported field, such as the hour, minute or second.
 778      * If it is not possible to set the value, because the field is not supported or for
 779      * some other reason, an exception is thrown.
 780      * &lt;p&gt;
 781      * If the field is a {@link ChronoField} then the adjustment is implemented here.
 782      * The supported fields behave as follows:
 783      * &lt;ul&gt;
 784      * &lt;li&gt;{@code NANO_OF_SECOND} -
 785      *  Returns a {@code LocalTime} with the specified nano-of-second.
 786      *  The hour, minute and second will be unchanged.
 787      * &lt;li&gt;{@code NANO_OF_DAY} -
 788      *  Returns a {@code LocalTime} with the specified nano-of-day.
 789      *  This completely replaces the time and is equivalent to {@link #ofNanoOfDay(long)}.
 790      * &lt;li&gt;{@code MICRO_OF_SECOND} -
 791      *  Returns a {@code LocalTime} with the nano-of-second replaced by the specified
 792      *  micro-of-second multiplied by 1,000.
 793      *  The hour, minute and second will be unchanged.
 794      * &lt;li&gt;{@code MICRO_OF_DAY} -
 795      *  Returns a {@code LocalTime} with the specified micro-of-day.
 796      *  This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}
 797      *  with the micro-of-day multiplied by 1,000.
 798      * &lt;li&gt;{@code MILLI_OF_SECOND} -
 799      *  Returns a {@code LocalTime} with the nano-of-second replaced by the specified
 800      *  milli-of-second multiplied by 1,000,000.
 801      *  The hour, minute and second will be unchanged.
 802      * &lt;li&gt;{@code MILLI_OF_DAY} -
 803      *  Returns a {@code LocalTime} with the specified milli-of-day.
 804      *  This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}
 805      *  with the milli-of-day multiplied by 1,000,000.
 806      * &lt;li&gt;{@code SECOND_OF_MINUTE} -
 807      *  Returns a {@code LocalTime} with the specified second-of-minute.
 808      *  The hour, minute and nano-of-second will be unchanged.
 809      * &lt;li&gt;{@code SECOND_OF_DAY} -
 810      *  Returns a {@code LocalTime} with the specified second-of-day.
 811      *  The nano-of-second will be unchanged.
 812      * &lt;li&gt;{@code MINUTE_OF_HOUR} -
 813      *  Returns a {@code LocalTime} with the specified minute-of-hour.
 814      *  The hour, second-of-minute and nano-of-second will be unchanged.
 815      * &lt;li&gt;{@code MINUTE_OF_DAY} -
 816      *  Returns a {@code LocalTime} with the specified minute-of-day.
 817      *  The second-of-minute and nano-of-second will be unchanged.
 818      * &lt;li&gt;{@code HOUR_OF_AMPM} -
 819      *  Returns a {@code LocalTime} with the specified hour-of-am-pm.
 820      *  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 821      * &lt;li&gt;{@code CLOCK_HOUR_OF_AMPM} -
 822      *  Returns a {@code LocalTime} with the specified clock-hour-of-am-pm.
 823      *  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 824      * &lt;li&gt;{@code HOUR_OF_DAY} -
 825      *  Returns a {@code LocalTime} with the specified hour-of-day.
 826      *  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 827      * &lt;li&gt;{@code CLOCK_HOUR_OF_DAY} -
 828      *  Returns a {@code LocalTime} with the specified clock-hour-of-day.
 829      *  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 830      * &lt;li&gt;{@code AMPM_OF_DAY} -
 831      *  Returns a {@code LocalTime} with the specified AM/PM.
 832      *  The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 833      * &lt;/ul&gt;
 834      * &lt;p&gt;
 835      * In all cases, if the new value is outside the valid range of values for the field
 836      * then a {@code DateTimeException} will be thrown.
 837      * &lt;p&gt;
 838      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 839      * &lt;p&gt;
 840      * If the field is not a {@code ChronoField}, then the result of this method
 841      * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
 842      * passing {@code this} as the argument. In this case, the field determines
 843      * whether and how to adjust the instant.
 844      * &lt;p&gt;
 845      * This instance is immutable and unaffected by this method call.
 846      *
 847      * @param field  the field to set in the result, not null
 848      * @param newValue  the new value of the field in the result
 849      * @return a {@code LocalTime} based on {@code this} with the specified field set, not null
 850      * @throws DateTimeException if the field cannot be set
 851      * @throws UnsupportedTemporalTypeException if the field is not supported
 852      * @throws ArithmeticException if numeric overflow occurs
 853      */
 854     @Override
 855     public LocalTime with(TemporalField field, long newValue) {
 856         if (field instanceof ChronoField) {
 857             ChronoField f = (ChronoField) field;
 858             f.checkValidValue(newValue);
 859             switch (f) {
 860                 case NANO_OF_SECOND: return withNano((int) newValue);
 861                 case NANO_OF_DAY: return LocalTime.ofNanoOfDay(newValue);
 862                 case MICRO_OF_SECOND: return withNano((int) newValue * 1000);
 863                 case MICRO_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000);
 864                 case MILLI_OF_SECOND: return withNano((int) newValue * 1000_000);
 865                 case MILLI_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000_000);
 866                 case SECOND_OF_MINUTE: return withSecond((int) newValue);
 867                 case SECOND_OF_DAY: return plusSeconds(newValue - toSecondOfDay());
 868                 case MINUTE_OF_HOUR: return withMinute((int) newValue);
 869                 case MINUTE_OF_DAY: return plusMinutes(newValue - (hour * 60 + minute));
 870                 case HOUR_OF_AMPM: return plusHours(newValue - (hour % 12));
 871                 case CLOCK_HOUR_OF_AMPM: return plusHours((newValue == 12 ? 0 : newValue) - (hour % 12));
 872                 case HOUR_OF_DAY: return withHour((int) newValue);
 873                 case CLOCK_HOUR_OF_DAY: return withHour((int) (newValue == 24 ? 0 : newValue));
 874                 case AMPM_OF_DAY: return plusHours((newValue - (hour / 12)) * 12);
 875             }
 876             throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
 877         }
 878         return field.adjustInto(this, newValue);
 879     }
 880 
 881     //-----------------------------------------------------------------------
 882     /**
 883      * Returns a copy of this {@code LocalTime} with the hour-of-day altered.
 884      * &lt;p&gt;
 885      * This instance is immutable and unaffected by this method call.
 886      *
 887      * @param hour  the hour-of-day to set in the result, from 0 to 23
 888      * @return a {@code LocalTime} based on this time with the requested hour, not null
 889      * @throws DateTimeException if the hour value is invalid
 890      */
 891     public LocalTime withHour(int hour) {
 892         if (this.hour == hour) {
 893             return this;
 894         }
 895         HOUR_OF_DAY.checkValidValue(hour);
 896         return create(hour, minute, second, nano);
 897     }
 898 
 899     /**
 900      * Returns a copy of this {@code LocalTime} with the minute-of-hour altered.
 901      * &lt;p&gt;
 902      * This instance is immutable and unaffected by this method call.
 903      *
 904      * @param minute  the minute-of-hour to set in the result, from 0 to 59
 905      * @return a {@code LocalTime} based on this time with the requested minute, not null
 906      * @throws DateTimeException if the minute value is invalid
 907      */
 908     public LocalTime withMinute(int minute) {
 909         if (this.minute == minute) {
 910             return this;
 911         }
 912         MINUTE_OF_HOUR.checkValidValue(minute);
 913         return create(hour, minute, second, nano);
 914     }
 915 
 916     /**
 917      * Returns a copy of this {@code LocalTime} with the second-of-minute altered.
 918      * &lt;p&gt;
 919      * This instance is immutable and unaffected by this method call.
 920      *
 921      * @param second  the second-of-minute to set in the result, from 0 to 59
 922      * @return a {@code LocalTime} based on this time with the requested second, not null
 923      * @throws DateTimeException if the second value is invalid
 924      */
 925     public LocalTime withSecond(int second) {
 926         if (this.second == second) {
 927             return this;
 928         }
 929         SECOND_OF_MINUTE.checkValidValue(second);
 930         return create(hour, minute, second, nano);
 931     }
 932 
 933     /**
 934      * Returns a copy of this {@code LocalTime} with the nano-of-second altered.
 935      * &lt;p&gt;
 936      * This instance is immutable and unaffected by this method call.
 937      *
 938      * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
 939      * @return a {@code LocalTime} based on this time with the requested nanosecond, not null
 940      * @throws DateTimeException if the nanos value is invalid
 941      */
 942     public LocalTime withNano(int nanoOfSecond) {
 943         if (this.nano == nanoOfSecond) {
 944             return this;
 945         }
 946         NANO_OF_SECOND.checkValidValue(nanoOfSecond);
 947         return create(hour, minute, second, nanoOfSecond);
 948     }
 949 
 950     //-----------------------------------------------------------------------
 951     /**
 952      * Returns a copy of this {@code LocalTime} with the time truncated.
 953      * &lt;p&gt;
 954      * Truncation returns a copy of the original time with fields
 955      * smaller than the specified unit set to zero.
 956      * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
 957      * will set the second-of-minute and nano-of-second field to zero.
 958      * &lt;p&gt;
 959      * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
 960      * that divides into the length of a standard day without remainder.
 961      * This includes all supplied time units on {@link ChronoUnit} and
 962      * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
 963      * &lt;p&gt;
 964      * This instance is immutable and unaffected by this method call.
 965      *
 966      * @param unit  the unit to truncate to, not null
 967      * @return a {@code LocalTime} based on this time with the time truncated, not null
 968      * @throws DateTimeException if unable to truncate
 969      * @throws UnsupportedTemporalTypeException if the unit is not supported
 970      */
 971     public LocalTime truncatedTo(TemporalUnit unit) {
 972         if (unit == ChronoUnit.NANOS) {
 973             return this;
 974         }
 975         Duration unitDur = unit.getDuration();
 976         if (unitDur.getSeconds() &gt; SECONDS_PER_DAY) {
 977             throw new UnsupportedTemporalTypeException(&quot;Unit is too large to be used for truncation&quot;);
 978         }
 979         long dur = unitDur.toNanos();
 980         if ((NANOS_PER_DAY % dur) != 0) {
 981             throw new UnsupportedTemporalTypeException(&quot;Unit must divide into a standard day without remainder&quot;);
 982         }
 983         long nod = toNanoOfDay();
 984         return ofNanoOfDay((nod / dur) * dur);
 985     }
 986 
 987     //-----------------------------------------------------------------------
 988     /**
 989      * Returns a copy of this time with the specified amount added.
 990      * &lt;p&gt;
 991      * This returns a {@code LocalTime}, based on this one, with the specified amount added.
 992      * The amount is typically {@link Duration} but may be any other type implementing
 993      * the {@link TemporalAmount} interface.
 994      * &lt;p&gt;
 995      * The calculation is delegated to the amount object by calling
 996      * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
 997      * to implement the addition in any way it wishes, however it typically
 998      * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
 999      * of the amount implementation to determine if it can be successfully added.
1000      * &lt;p&gt;
1001      * This instance is immutable and unaffected by this method call.
1002      *
1003      * @param amountToAdd  the amount to add, not null
1004      * @return a {@code LocalTime} based on this time with the addition made, not null
1005      * @throws DateTimeException if the addition cannot be made
1006      * @throws ArithmeticException if numeric overflow occurs
1007      */
1008     @Override
1009     public LocalTime plus(TemporalAmount amountToAdd) {
1010         return (LocalTime) amountToAdd.addTo(this);
1011     }
1012 
1013     /**
1014      * Returns a copy of this time with the specified amount added.
1015      * &lt;p&gt;
1016      * This returns a {@code LocalTime}, based on this one, with the amount
1017      * in terms of the unit added. If it is not possible to add the amount, because the
1018      * unit is not supported or for some other reason, an exception is thrown.
1019      * &lt;p&gt;
1020      * If the field is a {@link ChronoUnit} then the addition is implemented here.
1021      * The supported fields behave as follows:
1022      * &lt;ul&gt;
1023      * &lt;li&gt;{@code NANOS} -
1024      *  Returns a {@code LocalTime} with the specified number of nanoseconds added.
1025      *  This is equivalent to {@link #plusNanos(long)}.
1026      * &lt;li&gt;{@code MICROS} -
1027      *  Returns a {@code LocalTime} with the specified number of microseconds added.
1028      *  This is equivalent to {@link #plusNanos(long)} with the amount
1029      *  multiplied by 1,000.
1030      * &lt;li&gt;{@code MILLIS} -
1031      *  Returns a {@code LocalTime} with the specified number of milliseconds added.
1032      *  This is equivalent to {@link #plusNanos(long)} with the amount
1033      *  multiplied by 1,000,000.
1034      * &lt;li&gt;{@code SECONDS} -
1035      *  Returns a {@code LocalTime} with the specified number of seconds added.
1036      *  This is equivalent to {@link #plusSeconds(long)}.
1037      * &lt;li&gt;{@code MINUTES} -
1038      *  Returns a {@code LocalTime} with the specified number of minutes added.
1039      *  This is equivalent to {@link #plusMinutes(long)}.
1040      * &lt;li&gt;{@code HOURS} -
1041      *  Returns a {@code LocalTime} with the specified number of hours added.
1042      *  This is equivalent to {@link #plusHours(long)}.
1043      * &lt;li&gt;{@code HALF_DAYS} -
1044      *  Returns a {@code LocalTime} with the specified number of half-days added.
1045      *  This is equivalent to {@link #plusHours(long)} with the amount
1046      *  multiplied by 12.
1047      * &lt;/ul&gt;
1048      * &lt;p&gt;
1049      * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.
1050      * &lt;p&gt;
1051      * If the field is not a {@code ChronoUnit}, then the result of this method
1052      * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
1053      * passing {@code this} as the argument. In this case, the unit determines
1054      * whether and how to perform the addition.
1055      * &lt;p&gt;
1056      * This instance is immutable and unaffected by this method call.
1057      *
1058      * @param amountToAdd  the amount of the unit to add to the result, may be negative
1059      * @param unit  the unit of the amount to add, not null
1060      * @return a {@code LocalTime} based on this time with the specified amount added, not null
1061      * @throws DateTimeException if the addition cannot be made
1062      * @throws UnsupportedTemporalTypeException if the unit is not supported
1063      * @throws ArithmeticException if numeric overflow occurs
1064      */
1065     @Override
1066     public LocalTime plus(long amountToAdd, TemporalUnit unit) {
1067         if (unit instanceof ChronoUnit) {
1068             switch ((ChronoUnit) unit) {
1069                 case NANOS: return plusNanos(amountToAdd);
1070                 case MICROS: return plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);
1071                 case MILLIS: return plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);
1072                 case SECONDS: return plusSeconds(amountToAdd);
1073                 case MINUTES: return plusMinutes(amountToAdd);
1074                 case HOURS: return plusHours(amountToAdd);
1075                 case HALF_DAYS: return plusHours((amountToAdd % 2) * 12);
1076             }
1077             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
1078         }
1079         return unit.addTo(this, amountToAdd);
1080     }
1081 
1082     //-----------------------------------------------------------------------
1083     /**
1084      * Returns a copy of this {@code LocalTime} with the specified number of hours added.
1085      * &lt;p&gt;
1086      * This adds the specified number of hours to this time, returning a new time.
1087      * The calculation wraps around midnight.
1088      * &lt;p&gt;
1089      * This instance is immutable and unaffected by this method call.
1090      *
1091      * @param hoursToAdd  the hours to add, may be negative
1092      * @return a {@code LocalTime} based on this time with the hours added, not null
1093      */
1094     public LocalTime plusHours(long hoursToAdd) {
1095         if (hoursToAdd == 0) {
1096             return this;
1097         }
1098         int newHour = ((int) (hoursToAdd % HOURS_PER_DAY) + hour + HOURS_PER_DAY) % HOURS_PER_DAY;
1099         return create(newHour, minute, second, nano);
1100     }
1101 
1102     /**
1103      * Returns a copy of this {@code LocalTime} with the specified number of minutes added.
1104      * &lt;p&gt;
1105      * This adds the specified number of minutes to this time, returning a new time.
1106      * The calculation wraps around midnight.
1107      * &lt;p&gt;
1108      * This instance is immutable and unaffected by this method call.
1109      *
1110      * @param minutesToAdd  the minutes to add, may be negative
1111      * @return a {@code LocalTime} based on this time with the minutes added, not null
1112      */
1113     public LocalTime plusMinutes(long minutesToAdd) {
1114         if (minutesToAdd == 0) {
1115             return this;
1116         }
1117         int mofd = hour * MINUTES_PER_HOUR + minute;
1118         int newMofd = ((int) (minutesToAdd % MINUTES_PER_DAY) + mofd + MINUTES_PER_DAY) % MINUTES_PER_DAY;
1119         if (mofd == newMofd) {
1120             return this;
1121         }
1122         int newHour = newMofd / MINUTES_PER_HOUR;
1123         int newMinute = newMofd % MINUTES_PER_HOUR;
1124         return create(newHour, newMinute, second, nano);
1125     }
1126 
1127     /**
1128      * Returns a copy of this {@code LocalTime} with the specified number of seconds added.
1129      * &lt;p&gt;
1130      * This adds the specified number of seconds to this time, returning a new time.
1131      * The calculation wraps around midnight.
1132      * &lt;p&gt;
1133      * This instance is immutable and unaffected by this method call.
1134      *
1135      * @param secondstoAdd  the seconds to add, may be negative
1136      * @return a {@code LocalTime} based on this time with the seconds added, not null
1137      */
1138     public LocalTime plusSeconds(long secondstoAdd) {
1139         if (secondstoAdd == 0) {
1140             return this;
1141         }
1142         int sofd = hour * SECONDS_PER_HOUR +
1143                     minute * SECONDS_PER_MINUTE + second;
1144         int newSofd = ((int) (secondstoAdd % SECONDS_PER_DAY) + sofd + SECONDS_PER_DAY) % SECONDS_PER_DAY;
1145         if (sofd == newSofd) {
1146             return this;
1147         }
1148         int newHour = newSofd / SECONDS_PER_HOUR;
1149         int newMinute = (newSofd / SECONDS_PER_MINUTE) % MINUTES_PER_HOUR;
1150         int newSecond = newSofd % SECONDS_PER_MINUTE;
1151         return create(newHour, newMinute, newSecond, nano);
1152     }
1153 
1154     /**
1155      * Returns a copy of this {@code LocalTime} with the specified number of nanoseconds added.
1156      * &lt;p&gt;
1157      * This adds the specified number of nanoseconds to this time, returning a new time.
1158      * The calculation wraps around midnight.
1159      * &lt;p&gt;
1160      * This instance is immutable and unaffected by this method call.
1161      *
1162      * @param nanosToAdd  the nanos to add, may be negative
1163      * @return a {@code LocalTime} based on this time with the nanoseconds added, not null
1164      */
1165     public LocalTime plusNanos(long nanosToAdd) {
1166         if (nanosToAdd == 0) {
1167             return this;
1168         }
1169         long nofd = toNanoOfDay();
1170         long newNofd = ((nanosToAdd % NANOS_PER_DAY) + nofd + NANOS_PER_DAY) % NANOS_PER_DAY;
1171         if (nofd == newNofd) {
1172             return this;
1173         }
1174         int newHour = (int) (newNofd / NANOS_PER_HOUR);
1175         int newMinute = (int) ((newNofd / NANOS_PER_MINUTE) % MINUTES_PER_HOUR);
1176         int newSecond = (int) ((newNofd / NANOS_PER_SECOND) % SECONDS_PER_MINUTE);
1177         int newNano = (int) (newNofd % NANOS_PER_SECOND);
1178         return create(newHour, newMinute, newSecond, newNano);
1179     }
1180 
1181     //-----------------------------------------------------------------------
1182     /**
1183      * Returns a copy of this time with the specified amount subtracted.
1184      * &lt;p&gt;
1185      * This returns a {@code LocalTime}, based on this one, with the specified amount subtracted.
1186      * The amount is typically {@link Duration} but may be any other type implementing
1187      * the {@link TemporalAmount} interface.
1188      * &lt;p&gt;
1189      * The calculation is delegated to the amount object by calling
1190      * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
1191      * to implement the subtraction in any way it wishes, however it typically
1192      * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
1193      * of the amount implementation to determine if it can be successfully subtracted.
1194      * &lt;p&gt;
1195      * This instance is immutable and unaffected by this method call.
1196      *
1197      * @param amountToSubtract  the amount to subtract, not null
1198      * @return a {@code LocalTime} based on this time with the subtraction made, not null
1199      * @throws DateTimeException if the subtraction cannot be made
1200      * @throws ArithmeticException if numeric overflow occurs
1201      */
1202     @Override
1203     public LocalTime minus(TemporalAmount amountToSubtract) {
1204         return (LocalTime) amountToSubtract.subtractFrom(this);
1205     }
1206 
1207     /**
1208      * Returns a copy of this time with the specified amount subtracted.
1209      * &lt;p&gt;
1210      * This returns a {@code LocalTime}, based on this one, with the amount
1211      * in terms of the unit subtracted. If it is not possible to subtract the amount,
1212      * because the unit is not supported or for some other reason, an exception is thrown.
1213      * &lt;p&gt;
1214      * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
1215      * See that method for a full description of how addition, and thus subtraction, works.
1216      * &lt;p&gt;
1217      * This instance is immutable and unaffected by this method call.
1218      *
1219      * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
1220      * @param unit  the unit of the amount to subtract, not null
1221      * @return a {@code LocalTime} based on this time with the specified amount subtracted, not null
1222      * @throws DateTimeException if the subtraction cannot be made
1223      * @throws UnsupportedTemporalTypeException if the unit is not supported
1224      * @throws ArithmeticException if numeric overflow occurs
1225      */
1226     @Override
1227     public LocalTime minus(long amountToSubtract, TemporalUnit unit) {
1228         return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
1229     }
1230 
1231     //-----------------------------------------------------------------------
1232     /**
1233      * Returns a copy of this {@code LocalTime} with the specified number of hours subtracted.
1234      * &lt;p&gt;
1235      * This subtracts the specified number of hours from this time, returning a new time.
1236      * The calculation wraps around midnight.
1237      * &lt;p&gt;
1238      * This instance is immutable and unaffected by this method call.
1239      *
1240      * @param hoursToSubtract  the hours to subtract, may be negative
1241      * @return a {@code LocalTime} based on this time with the hours subtracted, not null
1242      */
1243     public LocalTime minusHours(long hoursToSubtract) {
1244         return plusHours(-(hoursToSubtract % HOURS_PER_DAY));
1245     }
1246 
1247     /**
1248      * Returns a copy of this {@code LocalTime} with the specified number of minutes subtracted.
1249      * &lt;p&gt;
1250      * This subtracts the specified number of minutes from this time, returning a new time.
1251      * The calculation wraps around midnight.
1252      * &lt;p&gt;
1253      * This instance is immutable and unaffected by this method call.
1254      *
1255      * @param minutesToSubtract  the minutes to subtract, may be negative
1256      * @return a {@code LocalTime} based on this time with the minutes subtracted, not null
1257      */
1258     public LocalTime minusMinutes(long minutesToSubtract) {
1259         return plusMinutes(-(minutesToSubtract % MINUTES_PER_DAY));
1260     }
1261 
1262     /**
1263      * Returns a copy of this {@code LocalTime} with the specified number of seconds subtracted.
1264      * &lt;p&gt;
1265      * This subtracts the specified number of seconds from this time, returning a new time.
1266      * The calculation wraps around midnight.
1267      * &lt;p&gt;
1268      * This instance is immutable and unaffected by this method call.
1269      *
1270      * @param secondsToSubtract  the seconds to subtract, may be negative
1271      * @return a {@code LocalTime} based on this time with the seconds subtracted, not null
1272      */
1273     public LocalTime minusSeconds(long secondsToSubtract) {
1274         return plusSeconds(-(secondsToSubtract % SECONDS_PER_DAY));
1275     }
1276 
1277     /**
1278      * Returns a copy of this {@code LocalTime} with the specified number of nanoseconds subtracted.
1279      * &lt;p&gt;
1280      * This subtracts the specified number of nanoseconds from this time, returning a new time.
1281      * The calculation wraps around midnight.
1282      * &lt;p&gt;
1283      * This instance is immutable and unaffected by this method call.
1284      *
1285      * @param nanosToSubtract  the nanos to subtract, may be negative
1286      * @return a {@code LocalTime} based on this time with the nanoseconds subtracted, not null
1287      */
1288     public LocalTime minusNanos(long nanosToSubtract) {
1289         return plusNanos(-(nanosToSubtract % NANOS_PER_DAY));
1290     }
1291 
1292     //-----------------------------------------------------------------------
1293     /**
1294      * Queries this time using the specified query.
1295      * &lt;p&gt;
1296      * This queries this time using the specified query strategy object.
1297      * The {@code TemporalQuery} object defines the logic to be used to
1298      * obtain the result. Read the documentation of the query to understand
1299      * what the result of this method will be.
1300      * &lt;p&gt;
1301      * The result of this method is obtained by invoking the
1302      * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
1303      * specified query passing {@code this} as the argument.
1304      *
1305      * @param &lt;R&gt; the type of the result
1306      * @param query  the query to invoke, not null
1307      * @return the query result, null may be returned (defined by the query)
1308      * @throws DateTimeException if unable to query (defined by the query)
1309      * @throws ArithmeticException if numeric overflow occurs (defined by the query)
1310      */
1311     @SuppressWarnings(&quot;unchecked&quot;)
1312     @Override
1313     public &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) {
1314         if (query == TemporalQueries.chronology() || query == TemporalQueries.zoneId() ||
1315                 query == TemporalQueries.zone() || query == TemporalQueries.offset()) {
1316             return null;
1317         } else if (query == TemporalQueries.localTime()) {
1318             return (R) this;
1319         } else if (query == TemporalQueries.localDate()) {
1320             return null;
1321         } else if (query == TemporalQueries.precision()) {
1322             return (R) NANOS;
1323         }
1324         // inline TemporalAccessor.super.query(query) as an optimization
1325         // non-JDK classes are not permitted to make this optimization
1326         return query.queryFrom(this);
1327     }
1328 
1329     /**
1330      * Adjusts the specified temporal object to have the same time as this object.
1331      * &lt;p&gt;
1332      * This returns a temporal object of the same observable type as the input
1333      * with the time changed to be the same as this.
1334      * &lt;p&gt;
1335      * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
1336      * passing {@link ChronoField#NANO_OF_DAY} as the field.
1337      * &lt;p&gt;
1338      * In most cases, it is clearer to reverse the calling pattern by using
1339      * {@link Temporal#with(TemporalAdjuster)}:
1340      * &lt;pre&gt;
1341      *   // these two lines are equivalent, but the second approach is recommended
1342      *   temporal = thisLocalTime.adjustInto(temporal);
1343      *   temporal = temporal.with(thisLocalTime);
1344      * &lt;/pre&gt;
1345      * &lt;p&gt;
1346      * This instance is immutable and unaffected by this method call.
1347      *
1348      * @param temporal  the target object to be adjusted, not null
1349      * @return the adjusted object, not null
1350      * @throws DateTimeException if unable to make the adjustment
1351      * @throws ArithmeticException if numeric overflow occurs
1352      */
1353     @Override
1354     public Temporal adjustInto(Temporal temporal) {
1355         return temporal.with(NANO_OF_DAY, toNanoOfDay());
1356     }
1357 
1358     /**
1359      * Calculates the amount of time until another time in terms of the specified unit.
1360      * &lt;p&gt;
1361      * This calculates the amount of time between two {@code LocalTime}
1362      * objects in terms of a single {@code TemporalUnit}.
1363      * The start and end points are {@code this} and the specified time.
1364      * The result will be negative if the end is before the start.
1365      * The {@code Temporal} passed to this method is converted to a
1366      * {@code LocalTime} using {@link #from(TemporalAccessor)}.
1367      * For example, the amount in hours between two times can be calculated
1368      * using {@code startTime.until(endTime, HOURS)}.
1369      * &lt;p&gt;
1370      * The calculation returns a whole number, representing the number of
1371      * complete units between the two times.
1372      * For example, the amount in hours between 11:30 and 13:29 will only
1373      * be one hour as it is one minute short of two hours.
1374      * &lt;p&gt;
1375      * There are two equivalent ways of using this method.
1376      * The first is to invoke this method.
1377      * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
1378      * &lt;pre&gt;
1379      *   // these two lines are equivalent
1380      *   amount = start.until(end, MINUTES);
1381      *   amount = MINUTES.between(start, end);
1382      * &lt;/pre&gt;
1383      * The choice should be made based on which makes the code more readable.
1384      * &lt;p&gt;
1385      * The calculation is implemented in this method for {@link ChronoUnit}.
1386      * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
1387      * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS} are supported.
1388      * Other {@code ChronoUnit} values will throw an exception.
1389      * &lt;p&gt;
1390      * If the unit is not a {@code ChronoUnit}, then the result of this method
1391      * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
1392      * passing {@code this} as the first argument and the converted input temporal
1393      * as the second argument.
1394      * &lt;p&gt;
1395      * This instance is immutable and unaffected by this method call.
1396      *
1397      * @param endExclusive  the end time, exclusive, which is converted to a {@code LocalTime}, not null
1398      * @param unit  the unit to measure the amount in, not null
1399      * @return the amount of time between this time and the end time
1400      * @throws DateTimeException if the amount cannot be calculated, or the end
1401      *  temporal cannot be converted to a {@code LocalTime}
1402      * @throws UnsupportedTemporalTypeException if the unit is not supported
1403      * @throws ArithmeticException if numeric overflow occurs
1404      */
1405     @Override
1406     public long until(Temporal endExclusive, TemporalUnit unit) {
1407         LocalTime end = LocalTime.from(endExclusive);
1408         if (unit instanceof ChronoUnit) {
1409             long nanosUntil = end.toNanoOfDay() - toNanoOfDay();  // no overflow
1410             switch ((ChronoUnit) unit) {
1411                 case NANOS: return nanosUntil;
1412                 case MICROS: return nanosUntil / 1000;
1413                 case MILLIS: return nanosUntil / 1000_000;
1414                 case SECONDS: return nanosUntil / NANOS_PER_SECOND;
1415                 case MINUTES: return nanosUntil / NANOS_PER_MINUTE;
1416                 case HOURS: return nanosUntil / NANOS_PER_HOUR;
1417                 case HALF_DAYS: return nanosUntil / (12 * NANOS_PER_HOUR);
1418             }
1419             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
1420         }
1421         return unit.between(this, end);
1422     }
1423 
1424     /**
1425      * Formats this time using the specified formatter.
1426      * &lt;p&gt;
1427      * This time will be passed to the formatter to produce a string.
1428      *
1429      * @param formatter  the formatter to use, not null
1430      * @return the formatted time string, not null
1431      * @throws DateTimeException if an error occurs during printing
1432      */
1433     public String format(DateTimeFormatter formatter) {
1434         Objects.requireNonNull(formatter, &quot;formatter&quot;);
1435         return formatter.format(this);
1436     }
1437 
1438     //-----------------------------------------------------------------------
1439     /**
1440      * Combines this time with a date to create a {@code LocalDateTime}.
1441      * &lt;p&gt;
1442      * This returns a {@code LocalDateTime} formed from this time at the specified date.
1443      * All possible combinations of date and time are valid.
1444      *
1445      * @param date  the date to combine with, not null
1446      * @return the local date-time formed from this time and the specified date, not null
1447      */
1448     public LocalDateTime atDate(LocalDate date) {
1449         return LocalDateTime.of(date, this);
1450     }
1451 
1452     /**
1453      * Combines this time with an offset to create an {@code OffsetTime}.
1454      * &lt;p&gt;
1455      * This returns an {@code OffsetTime} formed from this time at the specified offset.
1456      * All possible combinations of time and offset are valid.
1457      *
1458      * @param offset  the offset to combine with, not null
1459      * @return the offset time formed from this time and the specified offset, not null
1460      */
1461     public OffsetTime atOffset(ZoneOffset offset) {
1462         return OffsetTime.of(this, offset);
1463     }
1464 
1465     //-----------------------------------------------------------------------
1466     /**
1467      * Extracts the time as seconds of day,
1468      * from {@code 0} to {@code 24 * 60 * 60 - 1}.
1469      *
1470      * @return the second-of-day equivalent to this time
1471      */
1472     public int toSecondOfDay() {
1473         int total = hour * SECONDS_PER_HOUR;
1474         total += minute * SECONDS_PER_MINUTE;
1475         total += second;
1476         return total;
1477     }
1478 
1479     /**
1480      * Extracts the time as nanos of day,
1481      * from {@code 0} to {@code 24 * 60 * 60 * 1,000,000,000 - 1}.
1482      *
1483      * @return the nano of day equivalent to this time
1484      */
1485     public long toNanoOfDay() {
1486         long total = hour * NANOS_PER_HOUR;
1487         total += minute * NANOS_PER_MINUTE;
1488         total += second * NANOS_PER_SECOND;
1489         total += nano;
1490         return total;
1491     }
1492 
1493     /**
1494      * Converts this {@code LocalTime} to the number of seconds since the epoch
1495      * of 1970-01-01T00:00:00Z.
1496      * &lt;p&gt;
1497      * This combines this local time with the specified date and
1498      * offset to calculate the epoch-second value, which is the
1499      * number of elapsed seconds from 1970-01-01T00:00:00Z.
1500      * Instants on the time-line after the epoch are positive, earlier
1501      * are negative.
1502      *
1503      * @param date the local date, not null
1504      * @param offset the zone offset, not null
1505      * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
1506      * @since 9
1507      */
1508     public long toEpochSecond(LocalDate date, ZoneOffset offset) {
1509         Objects.requireNonNull(date, &quot;date&quot;);
1510         Objects.requireNonNull(offset, &quot;offset&quot;);
1511         long epochDay = date.toEpochDay();
1512         long secs = epochDay * 86400 + toSecondOfDay();
1513         secs -= offset.getTotalSeconds();
1514         return secs;
1515     }
1516 
1517     //-----------------------------------------------------------------------
1518     /**
1519      * Compares this time to another time.
1520      * &lt;p&gt;
1521      * The comparison is based on the time-line position of the local times within a day.
1522      * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
1523      *
1524      * @param other  the other time to compare to, not null
1525      * @return the comparator value, negative if less, positive if greater
1526      */
1527     @Override
1528     public int compareTo(LocalTime other) {
1529         int cmp = Integer.compare(hour, other.hour);
1530         if (cmp == 0) {
1531             cmp = Integer.compare(minute, other.minute);
1532             if (cmp == 0) {
1533                 cmp = Integer.compare(second, other.second);
1534                 if (cmp == 0) {
1535                     cmp = Integer.compare(nano, other.nano);
1536                 }
1537             }
1538         }
1539         return cmp;
1540     }
1541 
1542     /**
1543      * Checks if this time is after the specified time.
1544      * &lt;p&gt;
1545      * The comparison is based on the time-line position of the time within a day.
1546      *
1547      * @param other  the other time to compare to, not null
1548      * @return true if this is after the specified time
1549      */
1550     public boolean isAfter(LocalTime other) {
1551         return compareTo(other) &gt; 0;
1552     }
1553 
1554     /**
1555      * Checks if this time is before the specified time.
1556      * &lt;p&gt;
1557      * The comparison is based on the time-line position of the time within a day.
1558      *
1559      * @param other  the other time to compare to, not null
1560      * @return true if this point is before the specified time
1561      */
1562     public boolean isBefore(LocalTime other) {
1563         return compareTo(other) &lt; 0;
1564     }
1565 
1566     //-----------------------------------------------------------------------
1567     /**
1568      * Checks if this time is equal to another time.
1569      * &lt;p&gt;
1570      * The comparison is based on the time-line position of the time within a day.
1571      * &lt;p&gt;
1572      * Only objects of type {@code LocalTime} are compared, other types return false.
1573      * To compare the date of two {@code TemporalAccessor} instances, use
1574      * {@link ChronoField#NANO_OF_DAY} as a comparator.
1575      *
1576      * @param obj  the object to check, null returns false
1577      * @return true if this is equal to the other time
1578      */
1579     @Override
1580     public boolean equals(Object obj) {
1581         if (this == obj) {
1582             return true;
1583         }
1584         if (obj instanceof LocalTime) {
1585             LocalTime other = (LocalTime) obj;
1586             return hour == other.hour &amp;&amp; minute == other.minute &amp;&amp;
1587                     second == other.second &amp;&amp; nano == other.nano;
1588         }
1589         return false;
1590     }
1591 
1592     /**
1593      * A hash code for this time.
1594      *
1595      * @return a suitable hash code
1596      */
1597     @Override
1598     public int hashCode() {
1599         long nod = toNanoOfDay();
1600         return (int) (nod ^ (nod &gt;&gt;&gt; 32));
1601     }
1602 
1603     //-----------------------------------------------------------------------
1604     /**
1605      * Outputs this time as a {@code String}, such as {@code 10:15}.
1606      * &lt;p&gt;
1607      * The output will be one of the following ISO-8601 formats:
1608      * &lt;ul&gt;
1609      * &lt;li&gt;{@code HH:mm}&lt;/li&gt;
1610      * &lt;li&gt;{@code HH:mm:ss}&lt;/li&gt;
1611      * &lt;li&gt;{@code HH:mm:ss.SSS}&lt;/li&gt;
1612      * &lt;li&gt;{@code HH:mm:ss.SSSSSS}&lt;/li&gt;
1613      * &lt;li&gt;{@code HH:mm:ss.SSSSSSSSS}&lt;/li&gt;
1614      * &lt;/ul&gt;
1615      * The format used will be the shortest that outputs the full value of
1616      * the time where the omitted parts are implied to be zero.
1617      *
1618      * @return a string representation of this time, not null
1619      */
1620     @Override
1621     public String toString() {
1622         StringBuilder buf = new StringBuilder(18);
1623         int hourValue = hour;
1624         int minuteValue = minute;
1625         int secondValue = second;
1626         int nanoValue = nano;
1627         buf.append(hourValue &lt; 10 ? &quot;0&quot; : &quot;&quot;).append(hourValue)
1628             .append(minuteValue &lt; 10 ? &quot;:0&quot; : &quot;:&quot;).append(minuteValue);
1629         if (secondValue &gt; 0 || nanoValue &gt; 0) {
1630             buf.append(secondValue &lt; 10 ? &quot;:0&quot; : &quot;:&quot;).append(secondValue);
1631             if (nanoValue &gt; 0) {
1632                 buf.append(&#39;.&#39;);
1633                 if (nanoValue % 1000_000 == 0) {
1634                     buf.append(Integer.toString((nanoValue / 1000_000) + 1000).substring(1));
1635                 } else if (nanoValue % 1000 == 0) {
1636                     buf.append(Integer.toString((nanoValue / 1000) + 1000_000).substring(1));
1637                 } else {
1638                     buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));
1639                 }
1640             }
1641         }
1642         return buf.toString();
1643     }
1644 
1645     //-----------------------------------------------------------------------
1646     /**
1647      * Writes the object using a
1648      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1649      * @serialData
1650      * A twos-complement value indicates the remaining values are not in the stream
1651      * and should be set to zero.
1652      * &lt;pre&gt;
1653      *  out.writeByte(4);  // identifies a LocalTime
1654      *  if (nano == 0) {
1655      *    if (second == 0) {
1656      *      if (minute == 0) {
1657      *        out.writeByte(~hour);
1658      *      } else {
1659      *        out.writeByte(hour);
1660      *        out.writeByte(~minute);
1661      *      }
1662      *    } else {
1663      *      out.writeByte(hour);
1664      *      out.writeByte(minute);
1665      *      out.writeByte(~second);
1666      *    }
1667      *  } else {
1668      *    out.writeByte(hour);
1669      *    out.writeByte(minute);
1670      *    out.writeByte(second);
1671      *    out.writeInt(nano);
1672      *  }
1673      * &lt;/pre&gt;
1674      *
1675      * @return the instance of {@code Ser}, not null
1676      */
<a name="3" id="anc3"></a>
1677     private Object writeReplace() {
1678         return new Ser(Ser.LOCAL_TIME_TYPE, this);
1679     }
1680 
1681     /**
1682      * Defend against malicious streams.
1683      *
1684      * @param s the stream to read
1685      * @throws InvalidObjectException always
1686      */
<a name="4" id="anc4"></a>
1687     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1688         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1689     }
1690 
1691     void writeExternal(DataOutput out) throws IOException {
1692         if (nano == 0) {
1693             if (second == 0) {
1694                 if (minute == 0) {
1695                     out.writeByte(~hour);
1696                 } else {
1697                     out.writeByte(hour);
1698                     out.writeByte(~minute);
1699                 }
1700             } else {
1701                 out.writeByte(hour);
1702                 out.writeByte(minute);
1703                 out.writeByte(~second);
1704             }
1705         } else {
1706             out.writeByte(hour);
1707             out.writeByte(minute);
1708             out.writeByte(second);
1709             out.writeInt(nano);
1710         }
1711     }
1712 
1713     static LocalTime readExternal(DataInput in) throws IOException {
1714         int hour = in.readByte();
1715         int minute = 0;
1716         int second = 0;
1717         int nano = 0;
1718         if (hour &lt; 0) {
1719             hour = ~hour;
1720         } else {
1721             minute = in.readByte();
1722             if (minute &lt; 0) {
1723                 minute = ~minute;
1724             } else {
1725                 second = in.readByte();
1726                 if (second &lt; 0) {
1727                     second = ~second;
1728                 } else {
1729                     nano = in.readInt();
1730                 }
1731             }
1732         }
1733         return LocalTime.of(hour, minute, second, nano);
1734     }
1735 
1736 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/HttpURLConnection.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="HttpRetryException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="IDN.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/HttpURLConnection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
364     /**
365      * Constructor for the HttpURLConnection.
366      * @param u the URL
367      */
368     protected HttpURLConnection (URL u) {
369         super(u);
370     }
371 
372     /**
373      * Sets whether HTTP redirects  (requests with response code 3xx) should
374      * be automatically followed by this class.  True by default.  Applets
375      * cannot change this variable.
376      * &lt;p&gt;
377      * If there is a security manager, this method first calls
378      * the security manager&#39;s {@code checkSetFactory} method
379      * to ensure the operation is allowed.
380      * This could result in a SecurityException.
381      *
382      * @param set a {@code boolean} indicating whether or not
383      * to follow HTTP redirects.
<span class="line-modified">384      * @exception  SecurityException  if a security manager exists and its</span>
385      *             {@code checkSetFactory} method doesn&#39;t
386      *             allow the operation.
387      * @see        SecurityManager#checkSetFactory
388      * @see #getFollowRedirects()
389      */
390     public static void setFollowRedirects(boolean set) {
391         SecurityManager sec = System.getSecurityManager();
392         if (sec != null) {
393             // seems to be the best check here...
394             sec.checkSetFactory();
395         }
396         followRedirects = set;
397     }
398 
399     /**
400      * Returns a {@code boolean} indicating
401      * whether or not HTTP redirects (3xx) should
402      * be automatically followed.
403      *
404      * @return {@code true} if HTTP redirects should
</pre>
<hr />
<pre>
439      * @since 1.3
440      */
441      public boolean getInstanceFollowRedirects() {
442          return instanceFollowRedirects;
443      }
444 
445     /**
446      * Set the method for the URL request, one of:
447      * &lt;UL&gt;
448      *  &lt;LI&gt;GET
449      *  &lt;LI&gt;POST
450      *  &lt;LI&gt;HEAD
451      *  &lt;LI&gt;OPTIONS
452      *  &lt;LI&gt;PUT
453      *  &lt;LI&gt;DELETE
454      *  &lt;LI&gt;TRACE
455      * &lt;/UL&gt; are legal, subject to protocol restrictions.  The default
456      * method is GET.
457      *
458      * @param method the HTTP method
<span class="line-modified">459      * @exception ProtocolException if the method cannot be reset or if</span>
460      *              the requested method isn&#39;t valid for HTTP.
<span class="line-modified">461      * @exception SecurityException if a security manager is set and the</span>
462      *              method is &quot;TRACE&quot;, but the &quot;allowHttpTrace&quot;
463      *              NetPermission is not granted.
464      * @see #getRequestMethod()
465      */
466     public void setRequestMethod(String method) throws ProtocolException {
467         if (connected) {
468             throw new ProtocolException(&quot;Can&#39;t reset method: already connected&quot;);
469         }
470         // This restriction will prevent people from using this class to
471         // experiment w/ new HTTP methods using java.  But it should
472         // be placed for security - the request String could be
473         // arbitrarily long.
474 
475         for (int i = 0; i &lt; methods.length; i++) {
476             if (methods[i].equals(method)) {
477                 if (method.equals(&quot;TRACE&quot;)) {
478                     SecurityManager s = System.getSecurityManager();
479                     if (s != null) {
480                         s.checkPermission(new NetPermission(&quot;allowHttpTrace&quot;));
481                     }
</pre>
<hr />
<pre>
601             if (dateString.indexOf(&quot;GMT&quot;) == -1) {
602                 dateString = dateString+&quot; GMT&quot;;
603             }
604             return Date.parse(dateString);
605         } catch (Exception e) {
606         }
607         return Default;
608     }
609 
610 
611     /**
612      * Indicates that other requests to the server
613      * are unlikely in the near future. Calling disconnect()
614      * should not imply that this HttpURLConnection
615      * instance can be reused for other requests.
616      */
617     public abstract void disconnect();
618 
619     /**
620      * Indicates if the connection is going through a proxy.
<span class="line-modified">621      * @return a boolean indicating if the connection is</span>
<span class="line-modified">622      * using a proxy.</span>





623      */
624     public abstract boolean usingProxy();
625 
626     /**
627      * Returns a {@link SocketPermission} object representing the
628      * permission necessary to connect to the destination host and port.
629      *
<span class="line-modified">630      * @exception IOException if an error occurs while computing</span>
631      *            the permission.
632      *
633      * @return a {@code SocketPermission} object representing the
634      *         permission necessary to connect to the destination
635      *         host and port.
636      */
637     public Permission getPermission() throws IOException {
638         int port = url.getPort();
639         port = port &lt; 0 ? 80 : port;
640         String host = url.getHost() + &quot;:&quot; + port;
641         Permission permission = new SocketPermission(host, &quot;connect&quot;);
642         return permission;
643     }
644 
645    /**
646     * Returns the error stream if the connection failed
647     * but the server sent useful data nonetheless. The
648     * typical example is when an HTTP server responds
649     * with a 404, which will cause a FileNotFoundException
650     * to be thrown in connect, but the server sent an HTML
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
364     /**
365      * Constructor for the HttpURLConnection.
366      * @param u the URL
367      */
368     protected HttpURLConnection (URL u) {
369         super(u);
370     }
371 
372     /**
373      * Sets whether HTTP redirects  (requests with response code 3xx) should
374      * be automatically followed by this class.  True by default.  Applets
375      * cannot change this variable.
376      * &lt;p&gt;
377      * If there is a security manager, this method first calls
378      * the security manager&#39;s {@code checkSetFactory} method
379      * to ensure the operation is allowed.
380      * This could result in a SecurityException.
381      *
382      * @param set a {@code boolean} indicating whether or not
383      * to follow HTTP redirects.
<span class="line-modified">384      * @throws     SecurityException  if a security manager exists and its</span>
385      *             {@code checkSetFactory} method doesn&#39;t
386      *             allow the operation.
387      * @see        SecurityManager#checkSetFactory
388      * @see #getFollowRedirects()
389      */
390     public static void setFollowRedirects(boolean set) {
391         SecurityManager sec = System.getSecurityManager();
392         if (sec != null) {
393             // seems to be the best check here...
394             sec.checkSetFactory();
395         }
396         followRedirects = set;
397     }
398 
399     /**
400      * Returns a {@code boolean} indicating
401      * whether or not HTTP redirects (3xx) should
402      * be automatically followed.
403      *
404      * @return {@code true} if HTTP redirects should
</pre>
<hr />
<pre>
439      * @since 1.3
440      */
441      public boolean getInstanceFollowRedirects() {
442          return instanceFollowRedirects;
443      }
444 
445     /**
446      * Set the method for the URL request, one of:
447      * &lt;UL&gt;
448      *  &lt;LI&gt;GET
449      *  &lt;LI&gt;POST
450      *  &lt;LI&gt;HEAD
451      *  &lt;LI&gt;OPTIONS
452      *  &lt;LI&gt;PUT
453      *  &lt;LI&gt;DELETE
454      *  &lt;LI&gt;TRACE
455      * &lt;/UL&gt; are legal, subject to protocol restrictions.  The default
456      * method is GET.
457      *
458      * @param method the HTTP method
<span class="line-modified">459      * @throws    ProtocolException if the method cannot be reset or if</span>
460      *              the requested method isn&#39;t valid for HTTP.
<span class="line-modified">461      * @throws    SecurityException if a security manager is set and the</span>
462      *              method is &quot;TRACE&quot;, but the &quot;allowHttpTrace&quot;
463      *              NetPermission is not granted.
464      * @see #getRequestMethod()
465      */
466     public void setRequestMethod(String method) throws ProtocolException {
467         if (connected) {
468             throw new ProtocolException(&quot;Can&#39;t reset method: already connected&quot;);
469         }
470         // This restriction will prevent people from using this class to
471         // experiment w/ new HTTP methods using java.  But it should
472         // be placed for security - the request String could be
473         // arbitrarily long.
474 
475         for (int i = 0; i &lt; methods.length; i++) {
476             if (methods[i].equals(method)) {
477                 if (method.equals(&quot;TRACE&quot;)) {
478                     SecurityManager s = System.getSecurityManager();
479                     if (s != null) {
480                         s.checkPermission(new NetPermission(&quot;allowHttpTrace&quot;));
481                     }
</pre>
<hr />
<pre>
601             if (dateString.indexOf(&quot;GMT&quot;) == -1) {
602                 dateString = dateString+&quot; GMT&quot;;
603             }
604             return Date.parse(dateString);
605         } catch (Exception e) {
606         }
607         return Default;
608     }
609 
610 
611     /**
612      * Indicates that other requests to the server
613      * are unlikely in the near future. Calling disconnect()
614      * should not imply that this HttpURLConnection
615      * instance can be reused for other requests.
616      */
617     public abstract void disconnect();
618 
619     /**
620      * Indicates if the connection is going through a proxy.
<span class="line-modified">621      *</span>
<span class="line-modified">622      * This method returns {@code true} if the connection is known</span>
<span class="line-added">623      * to be going or has gone through proxies, and returns {@code false}</span>
<span class="line-added">624      * if the connection will never go through a proxy or if</span>
<span class="line-added">625      * the use of a proxy cannot be determined.</span>
<span class="line-added">626      *</span>
<span class="line-added">627      * @return a boolean indicating if the connection is using a proxy.</span>
628      */
629     public abstract boolean usingProxy();
630 
631     /**
632      * Returns a {@link SocketPermission} object representing the
633      * permission necessary to connect to the destination host and port.
634      *
<span class="line-modified">635      * @throws    IOException if an error occurs while computing</span>
636      *            the permission.
637      *
638      * @return a {@code SocketPermission} object representing the
639      *         permission necessary to connect to the destination
640      *         host and port.
641      */
642     public Permission getPermission() throws IOException {
643         int port = url.getPort();
644         port = port &lt; 0 ? 80 : port;
645         String host = url.getHost() + &quot;:&quot; + port;
646         Permission permission = new SocketPermission(host, &quot;connect&quot;);
647         return permission;
648     }
649 
650    /**
651     * Returns the error stream if the connection failed
652     * but the server sent useful data nonetheless. The
653     * typical example is when an HTTP server responds
654     * with a 404, which will cause a FileNotFoundException
655     * to be thrown in connect, but the server sent an HTML
</pre>
</td>
</tr>
</table>
<center><a href="HttpRetryException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="IDN.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
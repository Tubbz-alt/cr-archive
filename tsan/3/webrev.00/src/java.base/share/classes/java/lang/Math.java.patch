diff a/src/java.base/share/classes/java/lang/Math.java b/src/java.base/share/classes/java/lang/Math.java
--- a/src/java.base/share/classes/java/lang/Math.java
+++ b/src/java.base/share/classes/java/lang/Math.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1994, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -90,16 +90,16 @@
  * produce correct results, which in some cases means the operations
  * will not overflow the range of values of the computation.
  * The best practice is to choose the primitive type and algorithm to avoid
  * overflow. In cases where the size is {@code int} or {@code long} and
  * overflow errors need to be detected, the methods {@code addExact},
- * {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}
+ * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},
+ * {@code incrementExact}, {@code decrementExact} and {@code negateExact}
  * throw an {@code ArithmeticException} when the results overflow.
- * For other arithmetic operations such as divide, absolute value,
- * increment by one, decrement by one, and negation, overflow occurs only with
- * a specific minimum or maximum value and should be checked against
- * the minimum or maximum as appropriate.
+ * For the arithmetic operations divide and absolute value, overflow
+ * occurs only with a specific minimum or maximum value and
+ * should be checked against the minimum or maximum as appropriate.
  *
  * @author  unascribed
  * @author  Joseph D. Darcy
  * @since   1.0
  */
@@ -438,10 +438,11 @@
      * @param   a   a value.
      * @return  the smallest (closest to negative infinity)
      *          floating-point value that is greater than or equal to
      *          the argument and is equal to a mathematical integer.
      */
+    @HotSpotIntrinsicCandidate
     public static double ceil(double a) {
         return StrictMath.ceil(a); // default impl. delegates to StrictMath
     }
 
     /**
@@ -457,10 +458,11 @@
      * @param   a   a value.
      * @return  the largest (closest to positive infinity)
      *          floating-point value that less than or equal to the argument
      *          and is equal to a mathematical integer.
      */
+    @HotSpotIntrinsicCandidate
     public static double floor(double a) {
         return StrictMath.floor(a); // default impl. delegates to StrictMath
     }
 
     /**
@@ -476,10 +478,11 @@
      *
      * @param   a   a {@code double} value.
      * @return  the closest floating-point value to {@code a} that is
      *          equal to a mathematical integer.
      */
+    @HotSpotIntrinsicCandidate
     public static double rint(double a) {
         return StrictMath.rint(a); // default impl. delegates to StrictMath
     }
 
     /**
@@ -950,10 +953,11 @@
     }
 
     /**
      * Returns the argument incremented by one, throwing an exception if the
      * result overflows an {@code int}.
+     * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.
      *
      * @param a the value to increment
      * @return the result
      * @throws ArithmeticException if the result overflows an int
      * @since 1.8
@@ -968,10 +972,11 @@
     }
 
     /**
      * Returns the argument incremented by one, throwing an exception if the
      * result overflows a {@code long}.
+     * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.
      *
      * @param a the value to increment
      * @return the result
      * @throws ArithmeticException if the result overflows a long
      * @since 1.8
@@ -986,10 +991,11 @@
     }
 
     /**
      * Returns the argument decremented by one, throwing an exception if the
      * result overflows an {@code int}.
+     * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
      *
      * @param a the value to decrement
      * @return the result
      * @throws ArithmeticException if the result overflows an int
      * @since 1.8
@@ -1004,10 +1010,11 @@
     }
 
     /**
      * Returns the argument decremented by one, throwing an exception if the
      * result overflows a {@code long}.
+     * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
      *
      * @param a the value to decrement
      * @return the result
      * @throws ArithmeticException if the result overflows a long
      * @since 1.8
@@ -1022,10 +1029,11 @@
     }
 
     /**
      * Returns the negation of the argument, throwing an exception if the
      * result overflows an {@code int}.
+     * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
      *
      * @param a the value to negate
      * @return the result
      * @throws ArithmeticException if the result overflows an int
      * @since 1.8
@@ -1040,10 +1048,11 @@
     }
 
     /**
      * Returns the negation of the argument, throwing an exception if the
      * result overflows a {@code long}.
+     * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
      *
      * @param a the value to negate
      * @return the result
      * @throws ArithmeticException if the result overflows a long
      * @since 1.8
@@ -1056,11 +1065,11 @@
 
         return -a;
     }
 
     /**
-     * Returns the value of the {@code long} argument;
+     * Returns the value of the {@code long} argument,
      * throwing an exception if the value overflows an {@code int}.
      *
      * @param value the long value
      * @return the argument as an int
      * @throws ArithmeticException if the {@code argument} overflows an int
@@ -1248,20 +1257,21 @@
      * and the {@code /} operator that returns the integer closest to zero.
      * <p>
      * Examples:
      * <ul>
      *   <li>If the signs of the arguments are the same, the results
-     *       of {@code floorMod} and the {@code %} operator are the same.  <br>
+     *       of {@code floorMod} and the {@code %} operator are the same.<br>
+     *       <ul>
+     *       <li>{@code floorMod(+4, +3) == +1}; &nbsp; and {@code (+4 % +3) == +1}</li>
+     *       <li>{@code floorMod(-4, -3) == -1}; &nbsp; and {@code (-4 % -3) == -1}</li>
+     *       </ul>
+     *   <li>If the signs of the arguments are different, the results
+     *       differ from the {@code %} operator.<br>
      *       <ul>
-     *       <li>{@code floorMod(4, 3) == 1}; &nbsp; and {@code (4 % 3) == 1}</li>
+     *       <li>{@code floorMod(+4, -3) == -2}; &nbsp; and {@code (+4 % -3) == +1}</li>
+     *       <li>{@code floorMod(-4, +3) == +2}; &nbsp; and {@code (-4 % +3) == -1}</li>
      *       </ul>
-     *   <li>If the signs of the arguments are different, the results differ from the {@code %} operator.<br>
-     *      <ul>
-     *      <li>{@code floorMod(+4, -3) == -2}; &nbsp; and {@code (+4 % -3) == +1} </li>
-     *      <li>{@code floorMod(-4, +3) == +2}; &nbsp; and {@code (-4 % +3) == -1} </li>
-     *      <li>{@code floorMod(-4, -3) == -1}; &nbsp; and {@code (-4 % -3) == -1 } </li>
-     *      </ul>
      *   </li>
      * </ul>
      * <p>
      * If the signs of arguments are unknown and a positive modulus
      * is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
@@ -1272,11 +1282,16 @@
      * @throws ArithmeticException if the divisor {@code y} is zero
      * @see #floorDiv(int, int)
      * @since 1.8
      */
     public static int floorMod(int x, int y) {
-        return x - floorDiv(x, y) * y;
+        int mod = x % y;
+        // if the signs are different and modulo not zero, adjust result
+        if ((mod ^ y) < 0 && mod != 0) {
+            mod += y;
+        }
+        return mod;
     }
 
     /**
      * Returns the floor modulus of the {@code long} and {@code int} arguments.
      * <p>
@@ -1299,11 +1314,11 @@
      * @see #floorDiv(long, int)
      * @since 9
      */
     public static int floorMod(long x, int y) {
         // Result cannot overflow the range of int.
-        return (int)(x - floorDiv(x, y) * y);
+        return (int)floorMod(x, (long)y);
     }
 
     /**
      * Returns the floor modulus of the {@code long} arguments.
      * <p>
@@ -1325,11 +1340,16 @@
      * @throws ArithmeticException if the divisor {@code y} is zero
      * @see #floorDiv(long, long)
      * @since 1.8
      */
     public static long floorMod(long x, long y) {
-        return x - floorDiv(x, y) * y;
+        long mod = x % y;
+        // if the signs are different and modulo not zero, adjust result
+        if ((x ^ y) < 0 && mod != 0) {
+            mod += y;
+        }
+        return mod;
     }
 
     /**
      * Returns the absolute value of an {@code int} value.
      * If the argument is not negative, the argument is returned.
@@ -1341,10 +1361,11 @@
      * negative.
      *
      * @param   a   the argument whose absolute value is to be determined
      * @return  the absolute value of the argument.
      */
+    @HotSpotIntrinsicCandidate
     public static int abs(int a) {
         return (a < 0) ? -a : a;
     }
 
     /**
@@ -1358,10 +1379,11 @@
      * is negative.
      *
      * @param   a   the argument whose absolute value is to be determined
      * @return  the absolute value of the argument.
      */
+    @HotSpotIntrinsicCandidate
     public static long abs(long a) {
         return (a < 0) ? -a : a;
     }
 
     /**
@@ -1382,10 +1404,11 @@
      * {@code Float.intBitsToFloat(0x7fffffff & Float.floatToRawIntBits(a))}
      *
      * @param   a   the argument whose absolute value is to be determined
      * @return  the absolute value of the argument.
      */
+    @HotSpotIntrinsicCandidate
     public static float abs(float a) {
         return (a <= 0.0F) ? 0.0F - a : a;
     }
 
     /**

diff a/src/java.base/share/classes/java/text/MessageFormat.java b/src/java.base/share/classes/java/text/MessageFormat.java
--- a/src/java.base/share/classes/java/text/MessageFormat.java
+++ b/src/java.base/share/classes/java/text/MessageFormat.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,31 +48,31 @@
 import java.util.List;
 import java.util.Locale;
 
 
 /**
- * <code>MessageFormat</code> provides a means to produce concatenated
+ * {@code MessageFormat} provides a means to produce concatenated
  * messages in a language-neutral way. Use this to construct messages
  * displayed for end users.
  *
  * <p>
- * <code>MessageFormat</code> takes a set of objects, formats them, then
+ * {@code MessageFormat} takes a set of objects, formats them, then
  * inserts the formatted strings into the pattern at the appropriate places.
  *
  * <p>
  * <strong>Note:</strong>
- * <code>MessageFormat</code> differs from the other <code>Format</code>
- * classes in that you create a <code>MessageFormat</code> object with one
- * of its constructors (not with a <code>getInstance</code> style factory
- * method). The factory methods aren't necessary because <code>MessageFormat</code>
+ * {@code MessageFormat} differs from the other {@code Format}
+ * classes in that you create a {@code MessageFormat} object with one
+ * of its constructors (not with a {@code getInstance} style factory
+ * method). The factory methods aren't necessary because {@code MessageFormat}
  * itself doesn't implement locale specific behavior. Any locale specific
  * behavior is defined by the pattern that you provide as well as the
  * subformats used for inserted arguments.
  *
- * <h3><a id="patterns">Patterns and Their Interpretation</a></h3>
+ * <h2><a id="patterns">Patterns and Their Interpretation</a></h2>
  *
- * <code>MessageFormat</code> uses patterns of the following form:
+ * {@code MessageFormat} uses patterns of the following form:
  * <blockquote><pre>
  * <i>MessageFormatPattern:</i>
  *         <i>String</i>
  *         <i>MessageFormatPattern</i> <i>FormatElement</i> <i>String</i>
  *
@@ -100,11 +100,11 @@
  * pattern string <code>"'{0}'"</code> represents string
  * <code>"{0}"</code>, not a <i>FormatElement</i>. A single quote itself
  * must be represented by doubled single quotes {@code ''} throughout a
  * <i>String</i>.  For example, pattern string <code>"'{''}'"</code> is
  * interpreted as a sequence of <code>'{</code> (start of quoting and a
- * left curly brace), <code>''</code> (a single quote), and
+ * left curly brace), {@code ''} (a single quote), and
  * <code>}'</code> (a right curly brace and end of quoting),
  * <em>not</em> <code>'{'</code> and <code>'}'</code> (quoted left and
  * right curly braces): representing string <code>"{'}"</code>,
  * <em>not</em> <code>"{}"</code>.
  *
@@ -218,20 +218,20 @@
  *       <th scope="row" style="text-weight: normal"><i>SubformatPattern</i>
  *       <td>{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
  * </tbody>
  * </table>
  *
- * <h4>Usage Information</h4>
+ * <h3>Usage Information</h3>
  *
  * <p>
  * Here are some examples of usage.
  * In real internationalized programs, the message format pattern and other
  * static strings will, of course, be obtained from resource bundles.
  * Other parameters will be dynamically determined at runtime.
  * <p>
- * The first example uses the static method <code>MessageFormat.format</code>,
- * which internally creates a <code>MessageFormat</code> for one-time use:
+ * The first example uses the static method {@code MessageFormat.format},
+ * which internally creates a {@code MessageFormat} for one-time use:
  * <blockquote><pre>
  * int planet = 7;
  * String event = "a disturbance in the Force";
  *
  * String result = MessageFormat.format(
@@ -242,11 +242,11 @@
  * <blockquote><pre>
  * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
  * </pre></blockquote>
  *
  * <p>
- * The following example creates a <code>MessageFormat</code> instance that
+ * The following example creates a {@code MessageFormat} instance that
  * can be used repeatedly:
  * <blockquote><pre>
  * int fileCount = 1273;
  * String diskName = "MyDisk";
  * Object[] testArgs = {new Long(fileCount), diskName};
@@ -254,19 +254,19 @@
  * MessageFormat form = new MessageFormat(
  *     "The disk \"{1}\" contains {0} file(s).");
  *
  * System.out.println(form.format(testArgs));
  * </pre></blockquote>
- * The output with different values for <code>fileCount</code>:
+ * The output with different values for {@code fileCount}:
  * <blockquote><pre>
  * The disk "MyDisk" contains 0 file(s).
  * The disk "MyDisk" contains 1 file(s).
  * The disk "MyDisk" contains 1,273 file(s).
  * </pre></blockquote>
  *
  * <p>
- * For more sophisticated patterns, you can use a <code>ChoiceFormat</code>
+ * For more sophisticated patterns, you can use a {@code ChoiceFormat}
  * to produce correct forms for singular and plural:
  * <blockquote><pre>
  * MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
  * double[] filelimits = {0,1,2};
  * String[] filepart = {"no files","one file","{0,number} files"};
@@ -277,31 +277,31 @@
  * String diskName = "MyDisk";
  * Object[] testArgs = {new Long(fileCount), diskName};
  *
  * System.out.println(form.format(testArgs));
  * </pre></blockquote>
- * The output with different values for <code>fileCount</code>:
+ * The output with different values for {@code fileCount}:
  * <blockquote><pre>
  * The disk "MyDisk" contains no files.
  * The disk "MyDisk" contains one file.
  * The disk "MyDisk" contains 1,273 files.
  * </pre></blockquote>
  *
  * <p>
- * You can create the <code>ChoiceFormat</code> programmatically, as in the
+ * You can create the {@code ChoiceFormat} programmatically, as in the
  * above example, or by using a pattern. See {@link ChoiceFormat}
  * for more information.
  * <blockquote><pre>{@code
  * form.applyPattern(
  *    "There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.");
  * }</pre></blockquote>
  *
  * <p>
  * <strong>Note:</strong> As we see above, the string produced
- * by a <code>ChoiceFormat</code> in <code>MessageFormat</code> is treated as special;
+ * by a {@code ChoiceFormat} in {@code MessageFormat} is treated as special;
  * occurrences of '{' are used to indicate subformats, and cause recursion.
- * If you create both a <code>MessageFormat</code> and <code>ChoiceFormat</code>
+ * If you create both a {@code MessageFormat} and {@code ChoiceFormat}
  * programmatically (instead of using the string patterns), then be careful not to
  * produce a format that recurses on itself, which will cause an infinite loop.
  * <p>
  * When a single argument is parsed more than once in the string, the last match
  * will be the final result of the parsing.  For example,
@@ -324,11 +324,11 @@
  * String forParsing = "x, y, z";
  * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
  * // result now equals {new String("z")}
  * </pre></blockquote>
  *
- * <h4><a id="synchronization">Synchronization</a></h4>
+ * <h3><a id="synchronization">Synchronization</a></h3>
  *
  * <p>
  * Message formats are not synchronized.
  * It is recommended to create separate format instances for each thread.
  * If multiple threads access a format concurrently, it must be synchronized
@@ -347,10 +347,11 @@
  * @since 1.1
  */
 
 public class MessageFormat extends Format {
 
+    @java.io.Serial
     private static final long serialVersionUID = 6479157306784022952L;
 
     /**
      * Constructs a MessageFormat for the default
      * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
@@ -359,12 +360,12 @@
      * creates a list of subformats for the format elements contained in it.
      * Patterns and their interpretation are specified in the
      * <a href="#patterns">class description</a>.
      *
      * @param pattern the pattern for this message format
-     * @exception IllegalArgumentException if the pattern is invalid
-     * @exception NullPointerException if {@code pattern} is
+     * @throws    IllegalArgumentException if the pattern is invalid
+     * @throws    NullPointerException if {@code pattern} is
      *            {@code null}
      */
     public MessageFormat(String pattern) {
         this.locale = Locale.getDefault(Locale.Category.FORMAT);
         applyPattern(pattern);
@@ -378,12 +379,12 @@
      * Patterns and their interpretation are specified in the
      * <a href="#patterns">class description</a>.
      *
      * @param pattern the pattern for this message format
      * @param locale the locale for this message format
-     * @exception IllegalArgumentException if the pattern is invalid
-     * @exception NullPointerException if {@code pattern} is
+     * @throws    IllegalArgumentException if the pattern is invalid
+     * @throws    NullPointerException if {@code pattern} is
      *            {@code null}
      * @since 1.4
      */
     public MessageFormat(String pattern, Locale locale) {
         this.locale = locale;
@@ -395,12 +396,12 @@
      * This affects subsequent calls
      * <ul>
      * <li>to the {@link #applyPattern applyPattern}
      *     and {@link #toPattern toPattern} methods if format elements specify
      *     a format type and therefore have the subformats created in the
-     *     <code>applyPattern</code> method, as well as
-     * <li>to the <code>format</code> and
+     *     {@code applyPattern} method, as well as
+     * <li>to the {@code format} and
      *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
      *     if format elements do not specify a format type and therefore have
      *     the subformats created in the formatting methods.
      * </ul>
      * Subformats that have already been created are not affected.
@@ -427,12 +428,12 @@
      * for the format elements contained in it.
      * Patterns and their interpretation are specified in the
      * <a href="#patterns">class description</a>.
      *
      * @param pattern the pattern for this message format
-     * @exception IllegalArgumentException if the pattern is invalid
-     * @exception NullPointerException if {@code pattern} is
+     * @throws    IllegalArgumentException if the pattern is invalid
+     * @throws    NullPointerException if {@code pattern} is
      *            {@code null}
      */
     @SuppressWarnings("fallthrough") // fallthrough in switch is expected, suppress it
     public void applyPattern(String pattern) {
             StringBuilder[] segments = new StringBuilder[4];
@@ -593,29 +594,29 @@
         return result.toString();
     }
 
     /**
      * Sets the formats to use for the values passed into
-     * <code>format</code> methods or returned from <code>parse</code>
-     * methods. The indices of elements in <code>newFormats</code>
+     * {@code format} methods or returned from {@code parse}
+     * methods. The indices of elements in {@code newFormats}
      * correspond to the argument indices used in the previously set
      * pattern string.
-     * The order of formats in <code>newFormats</code> thus corresponds to
-     * the order of elements in the <code>arguments</code> array passed
-     * to the <code>format</code> methods or the result array returned
-     * by the <code>parse</code> methods.
+     * The order of formats in {@code newFormats} thus corresponds to
+     * the order of elements in the {@code arguments} array passed
+     * to the {@code format} methods or the result array returned
+     * by the {@code parse} methods.
      * <p>
      * If an argument index is used for more than one format element
      * in the pattern string, then the corresponding new format is used
      * for all such format elements. If an argument index is not used
      * for any format element in the pattern string, then the
      * corresponding new format is ignored. If fewer formats are provided
      * than needed, then only the formats for argument indices less
-     * than <code>newFormats.length</code> are replaced.
+     * than {@code newFormats.length} are replaced.
      *
      * @param newFormats the new formats to use
-     * @exception NullPointerException if <code>newFormats</code> is null
+     * @throws    NullPointerException if {@code newFormats} is null
      * @since 1.4
      */
     public void setFormatsByArgumentIndex(Format[] newFormats) {
         for (int i = 0; i <= maxOffset; i++) {
             int j = argumentNumbers[i];
@@ -626,28 +627,28 @@
     }
 
     /**
      * Sets the formats to use for the format elements in the
      * previously set pattern string.
-     * The order of formats in <code>newFormats</code> corresponds to
+     * The order of formats in {@code newFormats} corresponds to
      * the order of format elements in the pattern string.
      * <p>
      * If more formats are provided than needed by the pattern string,
      * the remaining ones are ignored. If fewer formats are provided
-     * than needed, then only the first <code>newFormats.length</code>
+     * than needed, then only the first {@code newFormats.length}
      * formats are replaced.
      * <p>
      * Since the order of format elements in a pattern string often
      * changes during localization, it is generally better to use the
      * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
      * method, which assumes an order of formats corresponding to the
-     * order of elements in the <code>arguments</code> array passed to
-     * the <code>format</code> methods or the result array returned by
-     * the <code>parse</code> methods.
+     * order of elements in the {@code arguments} array passed to
+     * the {@code format} methods or the result array returned by
+     * the {@code parse} methods.
      *
      * @param newFormats the new formats to use
-     * @exception NullPointerException if <code>newFormats</code> is null
+     * @throws    NullPointerException if {@code newFormats} is null
      */
     public void setFormats(Format[] newFormats) {
         int runsToCopy = newFormats.length;
         if (runsToCopy > maxOffset + 1) {
             runsToCopy = maxOffset + 1;
@@ -660,13 +661,13 @@
     /**
      * Sets the format to use for the format elements within the
      * previously set pattern string that use the given argument
      * index.
      * The argument index is part of the format element definition and
-     * represents an index into the <code>arguments</code> array passed
-     * to the <code>format</code> methods or the result array returned
-     * by the <code>parse</code> methods.
+     * represents an index into the {@code arguments} array passed
+     * to the {@code format} methods or the result array returned
+     * by the {@code parse} methods.
      * <p>
      * If the argument index is used for more than one format element
      * in the pattern string, then the new format is used for all such
      * format elements. If the argument index is not used for any format
      * element in the pattern string, then the new format is ignored.
@@ -695,11 +696,11 @@
      * method, which accesses format elements based on the argument
      * index they specify.
      *
      * @param formatElementIndex the index of a format element within the pattern
      * @param newFormat the format to use for the specified format element
-     * @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or
+     * @throws    ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or
      *            larger than the number of format elements in the pattern string
      */
     public void setFormat(int formatElementIndex, Format newFormat) {
 
         if (formatElementIndex > maxOffset) {
@@ -708,18 +709,18 @@
         formats[formatElementIndex] = newFormat;
     }
 
     /**
      * Gets the formats used for the values passed into
-     * <code>format</code> methods or returned from <code>parse</code>
+     * {@code format} methods or returned from {@code parse}
      * methods. The indices of elements in the returned array
      * correspond to the argument indices used in the previously set
      * pattern string.
      * The order of formats in the returned array thus corresponds to
-     * the order of elements in the <code>arguments</code> array passed
-     * to the <code>format</code> methods or the result array returned
-     * by the <code>parse</code> methods.
+     * the order of elements in the {@code arguments} array passed
+     * to the {@code format} methods or the result array returned
+     * by the {@code parse} methods.
      * <p>
      * If an argument index is used for more than one format element
      * in the pattern string, then the format used for the last such
      * format element is returned in the array. If an argument index
      * is not used for any format element in the pattern string, then
@@ -750,33 +751,33 @@
      * <p>
      * Since the order of format elements in a pattern string often
      * changes during localization, it's generally better to use the
      * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
      * method, which assumes an order of formats corresponding to the
-     * order of elements in the <code>arguments</code> array passed to
-     * the <code>format</code> methods or the result array returned by
-     * the <code>parse</code> methods.
+     * order of elements in the {@code arguments} array passed to
+     * the {@code format} methods or the result array returned by
+     * the {@code parse} methods.
      *
      * @return the formats used for the format elements in the pattern
      */
     public Format[] getFormats() {
         Format[] resultArray = new Format[maxOffset + 1];
         System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
         return resultArray;
     }
 
     /**
-     * Formats an array of objects and appends the <code>MessageFormat</code>'s
+     * Formats an array of objects and appends the {@code MessageFormat}'s
      * pattern, with format elements replaced by the formatted objects, to the
-     * provided <code>StringBuffer</code>.
+     * provided {@code StringBuffer}.
      * <p>
      * The text substituted for the individual format elements is derived from
      * the current subformat of the format element and the
-     * <code>arguments</code> element at the format element's argument index
+     * {@code arguments} element at the format element's argument index
      * as indicated by the first matching line of the following table. An
-     * argument is <i>unavailable</i> if <code>arguments</code> is
-     * <code>null</code> or has fewer than argumentIndex+1 elements.
+     * argument is <i>unavailable</i> if {@code arguments} is
+     * {@code null} or has fewer than argumentIndex+1 elements.
      *
      * <table class="plain">
      * <caption style="display:none">Examples of subformat,argument,and formatted text</caption>
      * <thead>
      *    <tr>
@@ -788,52 +789,52 @@
      *    <tr>
      *       <th scope="row" style="text-weight-normal" rowspan=2><i>any</i>
      *       <th scope="row" style="text-weight-normal"><i>unavailable</i>
      *       <td><code>"{" + argumentIndex + "}"</code>
      *    <tr>
-     *       <th scope="row" style="text-weight-normal"><code>null</code>
-     *       <td><code>"null"</code>
+     *       <th scope="row" style="text-weight-normal">{@code null}
+     *       <td>{@code "null"}
      *    <tr>
-     *       <th scope="row" style="text-weight-normal"><code>instanceof ChoiceFormat</code>
+     *       <th scope="row" style="text-weight-normal">{@code instanceof ChoiceFormat}
      *       <th scope="row" style="text-weight-normal"><i>any</i>
      *       <td><code>subformat.format(argument).indexOf('{') &gt;= 0 ?<br>
      *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
      *           subformat.format(argument)</code>
      *    <tr>
-     *       <th scope="row" style="text-weight-normal"><code>!= null</code>
+     *       <th scope="row" style="text-weight-normal">{@code != null}
      *       <th scope="row" style="text-weight-normal"><i>any</i>
-     *       <td><code>subformat.format(argument)</code>
+     *       <td>{@code subformat.format(argument)}
      *    <tr>
-     *       <th scope="row" style="text-weight-normal" rowspan=4><code>null</code>
-     *       <th scope="row" style="text-weight-normal"><code>instanceof Number</code>
-     *       <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>
+     *       <th scope="row" style="text-weight-normal" rowspan=4>{@code null}
+     *       <th scope="row" style="text-weight-normal">{@code instanceof Number}
+     *       <td>{@code NumberFormat.getInstance(getLocale()).format(argument)}
      *    <tr>
-     *       <th scope="row" style="text-weight-normal"><code>instanceof Date</code>
-     *       <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)</code>
+     *       <th scope="row" style="text-weight-normal">{@code instanceof Date}
+     *       <td>{@code DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)}
      *    <tr>
-     *       <th scope="row" style="text-weight-normal"><code>instanceof String</code>
-     *       <td><code>argument</code>
+     *       <th scope="row" style="text-weight-normal">{@code instanceof String}
+     *       <td>{@code argument}
      *    <tr>
      *       <th scope="row" style="text-weight-normal"><i>any</i>
-     *       <td><code>argument.toString()</code>
+     *       <td>{@code argument.toString()}
      * </tbody>
      * </table>
      * <p>
-     * If <code>pos</code> is non-null, and refers to
-     * <code>Field.ARGUMENT</code>, the location of the first formatted
+     * If {@code pos} is non-null, and refers to
+     * {@code Field.ARGUMENT}, the location of the first formatted
      * string will be returned.
      *
      * @param arguments an array of objects to be formatted and substituted.
      * @param result where text is appended.
      * @param pos keeps track on the position of the first replaced argument
                   in the output string.
      * @return the string buffer passed in as {@code result}, with formatted
      * text appended
-     * @exception IllegalArgumentException if an argument in the
-     *            <code>arguments</code> array is not of the type
+     * @throws    IllegalArgumentException if an argument in the
+     *            {@code arguments} array is not of the type
      *            expected by the format element(s) that use it.
-     * @exception NullPointerException if {@code result} is {@code null}
+     * @throws    NullPointerException if {@code result} is {@code null}
      */
     public final StringBuffer format(Object[] arguments, StringBuffer result,
                                      FieldPosition pos)
     {
         return subformat(arguments, result, pos, null);
@@ -847,78 +848,78 @@
      * </blockquote>
      *
      * @param pattern   the pattern string
      * @param arguments object(s) to format
      * @return the formatted string
-     * @exception IllegalArgumentException if the pattern is invalid,
-     *            or if an argument in the <code>arguments</code> array
+     * @throws    IllegalArgumentException if the pattern is invalid,
+     *            or if an argument in the {@code arguments} array
      *            is not of the type expected by the format element(s)
      *            that use it.
-     * @exception NullPointerException if {@code pattern} is {@code null}
+     * @throws    NullPointerException if {@code pattern} is {@code null}
      */
     public static String format(String pattern, Object ... arguments) {
         MessageFormat temp = new MessageFormat(pattern);
         return temp.format(arguments);
     }
 
     // Overrides
     /**
-     * Formats an array of objects and appends the <code>MessageFormat</code>'s
+     * Formats an array of objects and appends the {@code MessageFormat}'s
      * pattern, with format elements replaced by the formatted objects, to the
-     * provided <code>StringBuffer</code>.
+     * provided {@code StringBuffer}.
      * This is equivalent to
      * <blockquote>
      *     <code>{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)</code>
      * </blockquote>
      *
      * @param arguments an array of objects to be formatted and substituted.
      * @param result where text is appended.
      * @param pos keeps track on the position of the first replaced argument
      *            in the output string.
-     * @exception IllegalArgumentException if an argument in the
-     *            <code>arguments</code> array is not of the type
+     * @throws    IllegalArgumentException if an argument in the
+     *            {@code arguments} array is not of the type
      *            expected by the format element(s) that use it.
-     * @exception NullPointerException if {@code result} is {@code null}
+     * @throws    NullPointerException if {@code result} is {@code null}
      */
     public final StringBuffer format(Object arguments, StringBuffer result,
                                      FieldPosition pos)
     {
         return subformat((Object[]) arguments, result, pos, null);
     }
 
     /**
      * Formats an array of objects and inserts them into the
-     * <code>MessageFormat</code>'s pattern, producing an
-     * <code>AttributedCharacterIterator</code>.
-     * You can use the returned <code>AttributedCharacterIterator</code>
+     * {@code MessageFormat}'s pattern, producing an
+     * {@code AttributedCharacterIterator}.
+     * You can use the returned {@code AttributedCharacterIterator}
      * to build the resulting String, as well as to determine information
      * about the resulting String.
      * <p>
-     * The text of the returned <code>AttributedCharacterIterator</code> is
+     * The text of the returned {@code AttributedCharacterIterator} is
      * the same that would be returned by
      * <blockquote>
      *     <code>{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()</code>
      * </blockquote>
      * <p>
-     * In addition, the <code>AttributedCharacterIterator</code> contains at
+     * In addition, the {@code AttributedCharacterIterator} contains at
      * least attributes indicating where text was generated from an
-     * argument in the <code>arguments</code> array. The keys of these attributes are of
-     * type <code>MessageFormat.Field</code>, their values are
-     * <code>Integer</code> objects indicating the index in the <code>arguments</code>
+     * argument in the {@code arguments} array. The keys of these attributes are of
+     * type {@code MessageFormat.Field}, their values are
+     * {@code Integer} objects indicating the index in the {@code arguments}
      * array of the argument from which the text was generated.
      * <p>
-     * The attributes/value from the underlying <code>Format</code>
-     * instances that <code>MessageFormat</code> uses will also be
-     * placed in the resulting <code>AttributedCharacterIterator</code>.
+     * The attributes/value from the underlying {@code Format}
+     * instances that {@code MessageFormat} uses will also be
+     * placed in the resulting {@code AttributedCharacterIterator}.
      * This allows you to not only find where an argument is placed in the
      * resulting String, but also which fields it contains in turn.
      *
      * @param arguments an array of objects to be formatted and substituted.
      * @return AttributedCharacterIterator describing the formatted value.
-     * @exception NullPointerException if <code>arguments</code> is null.
-     * @exception IllegalArgumentException if an argument in the
-     *            <code>arguments</code> array is not of the type
+     * @throws    NullPointerException if {@code arguments} is null.
+     * @throws    IllegalArgumentException if an argument in the
+     *            {@code arguments} array is not of the type
      *            expected by the format element(s) that use it.
      * @since 1.4
      */
     public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
         StringBuffer result = new StringBuffer();
@@ -965,11 +966,11 @@
      * If the source is null, return an empty array.
      *
      * @param source the string to parse
      * @param pos    the parse position
      * @return an array of parsed objects
-     * @exception NullPointerException if {@code pos} is {@code null}
+     * @throws    NullPointerException if {@code pos} is {@code null}
      *            for a non-null {@code source} string.
      */
     public Object[] parse(String source, ParsePosition pos) {
         if (source == null) {
             Object[] empty = {};
@@ -1052,13 +1053,13 @@
      * The method may not use the entire text of the given string.
      * <p>
      * See the {@link #parse(String, ParsePosition)} method for more information
      * on message parsing.
      *
-     * @param source A <code>String</code> whose beginning should be parsed.
-     * @return An <code>Object</code> array parsed from the string.
-     * @exception ParseException if the beginning of the specified string
+     * @param source A {@code String} whose beginning should be parsed.
+     * @return An {@code Object} array parsed from the string.
+     * @throws    ParseException if the beginning of the specified string
      *            cannot be parsed.
      */
     public Object[] parse(String source) throws ParseException {
         ParsePosition pos  = new ParsePosition(0);
         Object[] result = parse(source, pos);
@@ -1070,27 +1071,27 @@
 
     /**
      * Parses text from a string to produce an object array.
      * <p>
      * The method attempts to parse text starting at the index given by
-     * <code>pos</code>.
-     * If parsing succeeds, then the index of <code>pos</code> is updated
+     * {@code pos}.
+     * If parsing succeeds, then the index of {@code pos} is updated
      * to the index after the last character used (parsing does not necessarily
      * use all characters up to the end of the string), and the parsed
-     * object array is returned. The updated <code>pos</code> can be used to
+     * object array is returned. The updated {@code pos} can be used to
      * indicate the starting point for the next call to this method.
-     * If an error occurs, then the index of <code>pos</code> is not
-     * changed, the error index of <code>pos</code> is set to the index of
+     * If an error occurs, then the index of {@code pos} is not
+     * changed, the error index of {@code pos} is set to the index of
      * the character where the error occurred, and null is returned.
      * <p>
      * See the {@link #parse(String, ParsePosition)} method for more information
      * on message parsing.
      *
-     * @param source A <code>String</code>, part of which should be parsed.
-     * @param pos A <code>ParsePosition</code> object with index and error
+     * @param source A {@code String}, part of which should be parsed.
+     * @param pos A {@code ParsePosition} object with index and error
      *            index information as described above.
-     * @return An <code>Object</code> array parsed from the string. In case of
+     * @return An {@code Object} array parsed from the string. In case of
      *         error, returns null.
      * @throws NullPointerException if {@code pos} is null.
      */
     public Object parseObject(String source, ParsePosition pos) {
         return parse(source, pos);
@@ -1143,18 +1144,19 @@
     }
 
 
     /**
      * Defines constants that are used as attribute keys in the
-     * <code>AttributedCharacterIterator</code> returned
-     * from <code>MessageFormat.formatToCharacterIterator</code>.
+     * {@code AttributedCharacterIterator} returned
+     * from {@code MessageFormat.formatToCharacterIterator}.
      *
      * @since 1.4
      */
     public static class Field extends Format.Field {
 
         // Proclaim serial compatibility with 1.4 FCS
+        @java.io.Serial
         private static final long serialVersionUID = 7899943957617360810L;
 
         /**
          * Creates a Field with the specified name.
          *
@@ -1169,10 +1171,11 @@
          *
          * @throws InvalidObjectException if the constant could not be
          *         resolved.
          * @return resolved MessageFormat.Field constant
          */
+        @java.io.Serial
         protected Object readResolve() throws InvalidObjectException {
             if (this.getClass() != MessageFormat.Field.class) {
                 throw new InvalidObjectException("subclass didn't correctly implement readResolve");
             }
 
@@ -1183,13 +1186,13 @@
         // The constants
         //
 
         /**
          * Constant identifying a portion of a message that was generated
-         * from an argument passed into <code>formatToCharacterIterator</code>.
-         * The value associated with the key will be an <code>Integer</code>
-         * indicating the index in the <code>arguments</code> array of the
+         * from an argument passed into {@code formatToCharacterIterator}.
+         * The value associated with the key will be an {@code Integer}
+         * indicating the index in the {@code arguments} array of the
          * argument from which the text was generated.
          */
         public static final Field ARGUMENT =
                            new Field("message argument field");
     }
@@ -1232,13 +1235,13 @@
      * @serial
      */
     private int[] argumentNumbers = new int[INITIAL_FORMATS];
 
     /**
-     * One less than the number of entries in <code>offsets</code>.  Can also be thought of
-     * as the index of the highest-numbered element in <code>offsets</code> that is being used.
-     * All of these arrays should have the same number of elements being used as <code>offsets</code>
+     * One less than the number of entries in {@code offsets}.  Can also be thought of
+     * as the index of the highest-numbered element in {@code offsets} that is being used.
+     * All of these arrays should have the same number of elements being used as {@code offsets}
      * does, and so this variable suffices to tell us how many entries are in all of them.
      * @serial
      */
     private int maxOffset = -1;
 
@@ -1248,12 +1251,12 @@
      * subformats as necessary. If {@code characterIterators} is {@code null}
      * and {@code fp} is {@code non-null} and identifies
      * {@code Field.ARGUMENT} as the field attribute, the location of
      * the first replaced argument will be set in it.
      *
-     * @exception IllegalArgumentException if an argument in the
-     *            <code>arguments</code> array is not of the type
+     * @throws    IllegalArgumentException if an argument in the
+     *            {@code arguments} array is not of the type
      *            expected by the format element(s) that use it.
      */
     private StringBuffer subformat(Object[] arguments, StringBuffer result,
                                    FieldPosition fp, List<AttributedCharacterIterator> characterIterators) {
         // note: this implementation assumes a fast substring & index.
@@ -1362,11 +1365,11 @@
         return result;
     }
 
     /**
      * Convenience method to append all the characters in
-     * <code>iterator</code> to the StringBuffer <code>result</code>.
+     * {@code iterator} to the StringBuffer {@code result}.
      */
     private void append(StringBuffer result, CharacterIterator iterator) {
         if (iterator.first() != CharacterIterator.DONE) {
             char aChar;
 
@@ -1599,10 +1602,11 @@
     /**
      * After reading an object from the input stream, do a simple verification
      * to maintain class invariants.
      * @throws InvalidObjectException if the objects read from the stream is invalid.
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
         in.defaultReadObject();
         boolean isValid = maxOffset >= -1
                 && formats.length > maxOffset
                 && offsets.length > maxOffset

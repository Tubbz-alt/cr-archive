<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 
<a name="1" id="anc1"></a>

 27 import jdk.internal.misc.Unsafe;
 28 import jdk.internal.util.Preconditions;
 29 import jdk.internal.vm.annotation.ForceInline;
 30 
 31 import java.nio.ByteBuffer;
 32 import java.nio.ReadOnlyBufferException;
 33 import java.util.Objects;
 34 
 35 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 36 
 37 #warn
 38 
 39 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
 40 
<a name="2" id="anc2"></a>

 41     static final int ALIGN = $BoxType$.BYTES - 1;
 42 
 43 #if[floatingPoint]
 44     @ForceInline
 45     static $rawType$ convEndian(boolean big, $type$ v) {
 46         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 47         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 48     }
 49 
 50     @ForceInline
 51     static $type$ convEndian(boolean big, $rawType$ rv) {
 52         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 53         return $Type$.$rawType$BitsTo$Type$(rv);
 54     }
 55 #else[floatingPoint]
 56     @ForceInline
 57     static $type$ convEndian(boolean big, $type$ n) {
 58         return big == BE ? n : $BoxType$.reverseBytes(n);
 59     }
 60 #end[floatingPoint]
 61 
 62 
 63     private static abstract class ByteArrayViewVarHandle extends VarHandle {
 64         final boolean be;
 65 
 66         ByteArrayViewVarHandle(VarForm form, boolean be) {
 67             super(form);
 68             this.be = be;
 69         }
 70     }
 71 
 72     static final class ArrayHandle extends ByteArrayViewVarHandle {
 73 
 74         ArrayHandle(boolean be) {
 75             super(ArrayHandle.FORM, be);
 76         }
 77 
 78         @Override
 79         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 80             return accessMode.at.accessModeType(byte[].class, $type$.class, int.class);
 81         }
 82 
 83         @ForceInline
 84         static int index(byte[] ba, int index) {
 85             return Preconditions.checkIndex(index, ba.length - ALIGN, null);
 86         }
 87 
 88         @ForceInline
 89         static long address(byte[] ba, int index) {
 90             long address = ((long) index) + Unsafe.ARRAY_BYTE_BASE_OFFSET;
 91             if ((address &amp; ALIGN) != 0)
 92                 throw newIllegalStateExceptionForMisalignedAccess(index);
 93             return address;
 94         }
 95 
 96         @ForceInline
 97         static $type$ get(ArrayHandle handle, Object oba, int index) {
 98             byte[] ba = (byte[]) oba;
 99 #if[floatingPoint]
100             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
101                     ba,
102                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
103                     handle.be);
104             return $Type$.$rawType$BitsTo$Type$(rawValue);
105 #else[floatingPoint]
106             return UNSAFE.get$Type$Unaligned(
107                     ba,
108                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
109                     handle.be);
110 #end[floatingPoint]
111         }
112 
113         @ForceInline
114         static void set(ArrayHandle handle, Object oba, int index, $type$ value) {
115             byte[] ba = (byte[]) oba;
116 #if[floatingPoint]
117             UNSAFE.put$RawType$Unaligned(
118                     ba,
119                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
120                     $Type$.$type$ToRaw$RawType$Bits(value),
121                     handle.be);
122 #else[floatingPoint]
123             UNSAFE.put$RawType$Unaligned(
124                     ba,
125                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
126                     value,
127                     handle.be);
128 #end[floatingPoint]
129         }
130 
131         @ForceInline
132         static $type$ getVolatile(ArrayHandle handle, Object oba, int index) {
133             byte[] ba = (byte[]) oba;
134             return convEndian(handle.be,
135                               UNSAFE.get$RawType$Volatile(
136                                       ba,
137                                       address(ba, index(ba, index))));
138         }
139 
140         @ForceInline
141         static void setVolatile(ArrayHandle handle, Object oba, int index, $type$ value) {
142             byte[] ba = (byte[]) oba;
143             UNSAFE.put$RawType$Volatile(
144                     ba,
145                     address(ba, index(ba, index)),
146                     convEndian(handle.be, value));
147         }
148 
149         @ForceInline
150         static $type$ getAcquire(ArrayHandle handle, Object oba, int index) {
151             byte[] ba = (byte[]) oba;
152             return convEndian(handle.be,
153                               UNSAFE.get$RawType$Acquire(
154                                       ba,
155                                       address(ba, index(ba, index))));
156         }
157 
158         @ForceInline
159         static void setRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
160             byte[] ba = (byte[]) oba;
161             UNSAFE.put$RawType$Release(
162                     ba,
163                     address(ba, index(ba, index)),
164                     convEndian(handle.be, value));
165         }
166 
167         @ForceInline
168         static $type$ getOpaque(ArrayHandle handle, Object oba, int index) {
169             byte[] ba = (byte[]) oba;
170             return convEndian(handle.be,
171                               UNSAFE.get$RawType$Opaque(
172                                       ba,
173                                       address(ba, index(ba, index))));
174         }
175 
176         @ForceInline
177         static void setOpaque(ArrayHandle handle, Object oba, int index, $type$ value) {
178             byte[] ba = (byte[]) oba;
179             UNSAFE.put$RawType$Opaque(
180                     ba,
181                     address(ba, index(ba, index)),
182                     convEndian(handle.be, value));
183         }
184 #if[CAS]
185 
186         @ForceInline
187         static boolean compareAndSet(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
188             byte[] ba = (byte[]) oba;
189 #if[Object]
190             return UNSAFE.compareAndSetReference(
191                     ba,
192                     address(ba, index(ba, index)),
193                     convEndian(handle.be, expected), convEndian(handle.be, value));
194 #else[Object]
195             return UNSAFE.compareAndSet$RawType$(
196                     ba,
197                     address(ba, index(ba, index)),
198                     convEndian(handle.be, expected), convEndian(handle.be, value));
199 #end[Object]
200         }
201 
202         @ForceInline
203         static $type$ compareAndExchange(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
204             byte[] ba = (byte[]) oba;
205             return convEndian(handle.be,
206                               UNSAFE.compareAndExchange$RawType$(
207                                       ba,
208                                       address(ba, index(ba, index)),
209                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
210         }
211 
212         @ForceInline
213         static $type$ compareAndExchangeAcquire(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
214             byte[] ba = (byte[]) oba;
215             return convEndian(handle.be,
216                               UNSAFE.compareAndExchange$RawType$Acquire(
217                                       ba,
218                                       address(ba, index(ba, index)),
219                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
220         }
221 
222         @ForceInline
223         static $type$ compareAndExchangeRelease(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
224             byte[] ba = (byte[]) oba;
225             return convEndian(handle.be,
226                               UNSAFE.compareAndExchange$RawType$Release(
227                                       ba,
228                                       address(ba, index(ba, index)),
229                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
230         }
231 
232         @ForceInline
233         static boolean weakCompareAndSetPlain(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
234             byte[] ba = (byte[]) oba;
235             return UNSAFE.weakCompareAndSet$RawType$Plain(
236                     ba,
237                     address(ba, index(ba, index)),
238                     convEndian(handle.be, expected), convEndian(handle.be, value));
239         }
240 
241         @ForceInline
242         static boolean weakCompareAndSet(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
243             byte[] ba = (byte[]) oba;
244             return UNSAFE.weakCompareAndSet$RawType$(
245                     ba,
246                     address(ba, index(ba, index)),
247                     convEndian(handle.be, expected), convEndian(handle.be, value));
248         }
249 
250         @ForceInline
251         static boolean weakCompareAndSetAcquire(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
252             byte[] ba = (byte[]) oba;
253             return UNSAFE.weakCompareAndSet$RawType$Acquire(
254                     ba,
255                     address(ba, index(ba, index)),
256                     convEndian(handle.be, expected), convEndian(handle.be, value));
257         }
258 
259         @ForceInline
260         static boolean weakCompareAndSetRelease(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
261             byte[] ba = (byte[]) oba;
262             return UNSAFE.weakCompareAndSet$RawType$Release(
263                     ba,
264                     address(ba, index(ba, index)),
265                     convEndian(handle.be, expected), convEndian(handle.be, value));
266         }
267 
268         @ForceInline
269         static $type$ getAndSet(ArrayHandle handle, Object oba, int index, $type$ value) {
270             byte[] ba = (byte[]) oba;
271 #if[Object]
272             return convEndian(handle.be,
273                               UNSAFE.getAndSetReference(
274                                       ba,
275                                       address(ba, index(ba, index)),
276                                       convEndian(handle.be, value)));
277 #else[Object]
278             return convEndian(handle.be,
279                               UNSAFE.getAndSet$RawType$(
280                                       ba,
281                                       address(ba, index(ba, index)),
282                                       convEndian(handle.be, value)));
283 #end[Object]
284         }
285 
286         @ForceInline
287         static $type$ getAndSetAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
288             byte[] ba = (byte[]) oba;
289             return convEndian(handle.be,
290                               UNSAFE.getAndSet$RawType$Acquire(
291                                       ba,
292                                       address(ba, index(ba, index)),
293                                       convEndian(handle.be, value)));
294         }
295 
296         @ForceInline
297         static $type$ getAndSetRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
298             byte[] ba = (byte[]) oba;
299             return convEndian(handle.be,
300                               UNSAFE.getAndSet$RawType$Release(
301                                       ba,
302                                       address(ba, index(ba, index)),
303                                       convEndian(handle.be, value)));
304         }
305 #end[CAS]
306 #if[AtomicAdd]
307 
308         @ForceInline
309         static $type$ getAndAdd(ArrayHandle handle, Object oba, int index, $type$ delta) {
310             byte[] ba = (byte[]) oba;
311             if (handle.be == BE) {
312                 return UNSAFE.getAndAdd$RawType$(
313                         ba,
314                         address(ba, index(ba, index)),
315                         delta);
316             } else {
317                 return getAndAddConvEndianWithCAS(ba, index, delta);
318             }
319         }
320 
321         @ForceInline
322         static $type$ getAndAddAcquire(ArrayHandle handle, Object oba, int index, $type$ delta) {
323             byte[] ba = (byte[]) oba;
324             if (handle.be == BE) {
325                 return UNSAFE.getAndAdd$RawType$Acquire(
326                         ba,
327                         address(ba, index(ba, index)),
328                         delta);
329             } else {
330                 return getAndAddConvEndianWithCAS(ba, index, delta);
331             }
332         }
333 
334         @ForceInline
335         static $type$ getAndAddRelease(ArrayHandle handle, Object oba, int index, $type$ delta) {
336             byte[] ba = (byte[]) oba;
337             if (handle.be == BE) {
338                 return UNSAFE.getAndAdd$RawType$Release(
339                         ba,
340                         address(ba, index(ba, index)),
341                         delta);
342             } else {
343                 return getAndAddConvEndianWithCAS(ba, index, delta);
344             }
345         }
346 
347         @ForceInline
348         static $type$ getAndAddConvEndianWithCAS(byte[] ba, int index, $type$ delta) {
349             $type$ nativeExpectedValue, expectedValue;
350             long offset = address(ba, index(ba, index));
351             do {
352                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
353                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
354             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
355                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
356             return expectedValue;
357         }
358 #end[AtomicAdd]
359 #if[Bitwise]
360 
361         @ForceInline
362         static $type$ getAndBitwiseOr(ArrayHandle handle, Object oba, int index, $type$ value) {
363             byte[] ba = (byte[]) oba;
364             if (handle.be == BE) {
365                 return UNSAFE.getAndBitwiseOr$RawType$(
366                         ba,
367                         address(ba, index(ba, index)),
368                         value);
369             } else {
370                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
371             }
372         }
373 
374         @ForceInline
375         static $type$ getAndBitwiseOrRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
376             byte[] ba = (byte[]) oba;
377             if (handle.be == BE) {
378                 return UNSAFE.getAndBitwiseOr$RawType$Release(
379                         ba,
380                         address(ba, index(ba, index)),
381                         value);
382             } else {
383                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
384             }
385         }
386 
387         @ForceInline
388         static $type$ getAndBitwiseOrAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
389             byte[] ba = (byte[]) oba;
390             if (handle.be == BE) {
391                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
392                         ba,
393                         address(ba, index(ba, index)),
394                         value);
395             } else {
396                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
397             }
398         }
399 
400         @ForceInline
401         static $type$ getAndBitwiseOrConvEndianWithCAS(byte[] ba, int index, $type$ value) {
402             $type$ nativeExpectedValue, expectedValue;
403             long offset = address(ba, index(ba, index));
404             do {
405                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
406                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
407             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
408                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
409             return expectedValue;
410         }
411 
412         @ForceInline
413         static $type$ getAndBitwiseAnd(ArrayHandle handle, Object oba, int index, $type$ value) {
414             byte[] ba = (byte[]) oba;
415             if (handle.be == BE) {
416                 return UNSAFE.getAndBitwiseAnd$RawType$(
417                         ba,
418                         address(ba, index(ba, index)),
419                         value);
420             } else {
421                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
422             }
423         }
424 
425         @ForceInline
426         static $type$ getAndBitwiseAndRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
427             byte[] ba = (byte[]) oba;
428             if (handle.be == BE) {
429                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
430                         ba,
431                         address(ba, index(ba, index)),
432                         value);
433             } else {
434                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
435             }
436         }
437 
438         @ForceInline
439         static $type$ getAndBitwiseAndAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
440             byte[] ba = (byte[]) oba;
441             if (handle.be == BE) {
442                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
443                         ba,
444                         address(ba, index(ba, index)),
445                         value);
446             } else {
447                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
448             }
449         }
450 
451         @ForceInline
452         static $type$ getAndBitwiseAndConvEndianWithCAS(byte[] ba, int index, $type$ value) {
453             $type$ nativeExpectedValue, expectedValue;
454             long offset = address(ba, index(ba, index));
455             do {
456                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
457                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
458             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
459                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
460             return expectedValue;
461         }
462 
463         @ForceInline
464         static $type$ getAndBitwiseXor(ArrayHandle handle, Object oba, int index, $type$ value) {
465             byte[] ba = (byte[]) oba;
466             if (handle.be == BE) {
467                 return UNSAFE.getAndBitwiseXor$RawType$(
468                         ba,
469                         address(ba, index(ba, index)),
470                         value);
471             } else {
472                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
473             }
474         }
475 
476         @ForceInline
477         static $type$ getAndBitwiseXorRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
478             byte[] ba = (byte[]) oba;
479             if (handle.be == BE) {
480                 return UNSAFE.getAndBitwiseXor$RawType$Release(
481                         ba,
482                         address(ba, index(ba, index)),
483                         value);
484             } else {
485                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
486             }
487         }
488 
489         @ForceInline
490         static $type$ getAndBitwiseXorAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
491             byte[] ba = (byte[]) oba;
492             if (handle.be == BE) {
493                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
494                         ba,
495                         address(ba, index(ba, index)),
496                         value);
497             } else {
498                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
499             }
500         }
501 
502         @ForceInline
503         static $type$ getAndBitwiseXorConvEndianWithCAS(byte[] ba, int index, $type$ value) {
504             $type$ nativeExpectedValue, expectedValue;
505             long offset = address(ba, index(ba, index));
506             do {
507                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
508                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
509             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
510                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
511             return expectedValue;
512         }
513 #end[Bitwise]
514 
515         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
516     }
517 
518 
519     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
520 
521         ByteBufferHandle(boolean be) {
522             super(ByteBufferHandle.FORM, be);
523         }
524 
525         @Override
526         final MethodType accessModeTypeUncached(AccessMode accessMode) {
527             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
528         }
529 
530         @ForceInline
531         static int index(ByteBuffer bb, int index) {
<a name="3" id="anc3"></a>
532             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
533         }
534 
535         @ForceInline
536         static int indexRO(ByteBuffer bb, int index) {
537             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
538                 throw new ReadOnlyBufferException();
<a name="4" id="anc4"></a><span class="line-modified">539             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);</span>
540         }
541 
542         @ForceInline
543         static long address(ByteBuffer bb, int index) {
544             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
545             if ((address &amp; ALIGN) != 0)
546                 throw newIllegalStateExceptionForMisalignedAccess(index);
547             return address;
548         }
549 
550         @ForceInline
551         static $type$ get(ByteBufferHandle handle, Object obb, int index) {
552             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
553 #if[floatingPoint]
554             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
555                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
556                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
557                     handle.be);
558             return $Type$.$rawType$BitsTo$Type$(rawValue);
559 #else[floatingPoint]
560             return UNSAFE.get$Type$Unaligned(
561                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
562                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
563                     handle.be);
564 #end[floatingPoint]
565         }
566 
567         @ForceInline
568         static void set(ByteBufferHandle handle, Object obb, int index, $type$ value) {
569             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
570 #if[floatingPoint]
571             UNSAFE.put$RawType$Unaligned(
572                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
573                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
574                     $Type$.$type$ToRaw$RawType$Bits(value),
575                     handle.be);
576 #else[floatingPoint]
577             UNSAFE.put$Type$Unaligned(
578                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
579                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
580                     value,
581                     handle.be);
582 #end[floatingPoint]
583         }
584 
585         @ForceInline
586         static $type$ getVolatile(ByteBufferHandle handle, Object obb, int index) {
587             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
588             return convEndian(handle.be,
589                               UNSAFE.get$RawType$Volatile(
590                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
591                                       address(bb, index(bb, index))));
592         }
593 
594         @ForceInline
595         static void setVolatile(ByteBufferHandle handle, Object obb, int index, $type$ value) {
596             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
597             UNSAFE.put$RawType$Volatile(
598                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
599                     address(bb, indexRO(bb, index)),
600                     convEndian(handle.be, value));
601         }
602 
603         @ForceInline
604         static $type$ getAcquire(ByteBufferHandle handle, Object obb, int index) {
605             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
606             return convEndian(handle.be,
607                               UNSAFE.get$RawType$Acquire(
608                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
609                                       address(bb, index(bb, index))));
610         }
611 
612         @ForceInline
613         static void setRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
614             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
615             UNSAFE.put$RawType$Release(
616                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
617                     address(bb, indexRO(bb, index)),
618                     convEndian(handle.be, value));
619         }
620 
621         @ForceInline
622         static $type$ getOpaque(ByteBufferHandle handle, Object obb, int index) {
623             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
624             return convEndian(handle.be,
625                               UNSAFE.get$RawType$Opaque(
626                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
627                                       address(bb, index(bb, index))));
628         }
629 
630         @ForceInline
631         static void setOpaque(ByteBufferHandle handle, Object obb, int index, $type$ value) {
632             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
633             UNSAFE.put$RawType$Opaque(
634                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
635                     address(bb, indexRO(bb, index)),
636                     convEndian(handle.be, value));
637         }
638 #if[CAS]
639 
640         @ForceInline
641         static boolean compareAndSet(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
642             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
643 #if[Object]
644             return UNSAFE.compareAndSetReference(
645                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
646                     address(bb, indexRO(bb, index)),
647                     convEndian(handle.be, expected), convEndian(handle.be, value));
648 #else[Object]
649             return UNSAFE.compareAndSet$RawType$(
650                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
651                     address(bb, indexRO(bb, index)),
652                     convEndian(handle.be, expected), convEndian(handle.be, value));
653 #end[Object]
654         }
655 
656         @ForceInline
657         static $type$ compareAndExchange(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
658             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
659             return convEndian(handle.be,
660                               UNSAFE.compareAndExchange$RawType$(
661                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
662                                       address(bb, indexRO(bb, index)),
663                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
664         }
665 
666         @ForceInline
667         static $type$ compareAndExchangeAcquire(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
668             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
669             return convEndian(handle.be,
670                               UNSAFE.compareAndExchange$RawType$Acquire(
671                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
672                                       address(bb, indexRO(bb, index)),
673                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
674         }
675 
676         @ForceInline
677         static $type$ compareAndExchangeRelease(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
678             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
679             return convEndian(handle.be,
680                               UNSAFE.compareAndExchange$RawType$Release(
681                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
682                                       address(bb, indexRO(bb, index)),
683                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
684         }
685 
686         @ForceInline
687         static boolean weakCompareAndSetPlain(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
688             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
689             return UNSAFE.weakCompareAndSet$RawType$Plain(
690                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
691                     address(bb, indexRO(bb, index)),
692                     convEndian(handle.be, expected), convEndian(handle.be, value));
693         }
694 
695         @ForceInline
696         static boolean weakCompareAndSet(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
697             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
698             return UNSAFE.weakCompareAndSet$RawType$(
699                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
700                     address(bb, indexRO(bb, index)),
701                     convEndian(handle.be, expected), convEndian(handle.be, value));
702         }
703 
704         @ForceInline
705         static boolean weakCompareAndSetAcquire(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
706             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
707             return UNSAFE.weakCompareAndSet$RawType$Acquire(
708                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
709                     address(bb, indexRO(bb, index)),
710                     convEndian(handle.be, expected), convEndian(handle.be, value));
711         }
712 
713         @ForceInline
714         static boolean weakCompareAndSetRelease(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
715             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
716             return UNSAFE.weakCompareAndSet$RawType$Release(
717                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
718                     address(bb, indexRO(bb, index)),
719                     convEndian(handle.be, expected), convEndian(handle.be, value));
720         }
721 
722         @ForceInline
723         static $type$ getAndSet(ByteBufferHandle handle, Object obb, int index, $type$ value) {
724             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
725 #if[Object]
726             return convEndian(handle.be,
727                               UNSAFE.getAndSetReference(
728                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
729                                       address(bb, indexRO(bb, index)),
730                                       convEndian(handle.be, value)));
731 #else[Object]
732             return convEndian(handle.be,
733                               UNSAFE.getAndSet$RawType$(
734                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
735                                       address(bb, indexRO(bb, index)),
736                                       convEndian(handle.be, value)));
737 #end[Object]
738         }
739 
740         @ForceInline
741         static $type$ getAndSetAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
742             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
743             return convEndian(handle.be,
744                               UNSAFE.getAndSet$RawType$Acquire(
745                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
746                                       address(bb, indexRO(bb, index)),
747                                       convEndian(handle.be, value)));
748         }
749 
750         @ForceInline
751         static $type$ getAndSetRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
752             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
753             return convEndian(handle.be,
754                               UNSAFE.getAndSet$RawType$Release(
755                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
756                                       address(bb, indexRO(bb, index)),
757                                       convEndian(handle.be, value)));
758         }
759 #end[CAS]
760 #if[AtomicAdd]
761 
762         @ForceInline
763         static $type$ getAndAdd(ByteBufferHandle handle, Object obb, int index, $type$ delta) {
764             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
765             if (handle.be == BE) {
766                 return UNSAFE.getAndAdd$RawType$(
767                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
768                         address(bb, indexRO(bb, index)),
769                         delta);
770             } else {
771                 return getAndAddConvEndianWithCAS(bb, index, delta);
772             }
773         }
774 
775         @ForceInline
776         static $type$ getAndAddAcquire(ByteBufferHandle handle, Object obb, int index, $type$ delta) {
777             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
778             if (handle.be == BE) {
779                 return UNSAFE.getAndAdd$RawType$Acquire(
780                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
781                         address(bb, indexRO(bb, index)),
782                         delta);
783             } else {
784                 return getAndAddConvEndianWithCAS(bb, index, delta);
785             }
786         }
787 
788         @ForceInline
789         static $type$ getAndAddRelease(ByteBufferHandle handle, Object obb, int index, $type$ delta) {
790             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
791             if (handle.be == BE) {
792                 return UNSAFE.getAndAdd$RawType$Release(
793                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
794                         address(bb, indexRO(bb, index)),
795                         delta);
796             } else {
797                 return getAndAddConvEndianWithCAS(bb, index, delta);
798             }
799         }
800 
801         @ForceInline
802         static $type$ getAndAddConvEndianWithCAS(ByteBuffer bb, int index, $type$ delta) {
803             $type$ nativeExpectedValue, expectedValue;
804             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
805             long offset = address(bb, indexRO(bb, index));
806             do {
807                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
808                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
809             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
810                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
811             return expectedValue;
812         }
813 #end[AtomicAdd]
814 #if[Bitwise]
815 
816         @ForceInline
817         static $type$ getAndBitwiseOr(ByteBufferHandle handle, Object obb, int index, $type$ value) {
818             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
819             if (handle.be == BE) {
820                 return UNSAFE.getAndBitwiseOr$RawType$(
821                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
822                         address(bb, indexRO(bb, index)),
823                         value);
824             } else {
825                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
826             }
827         }
828 
829         @ForceInline
830         static $type$ getAndBitwiseOrRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
831             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
832             if (handle.be == BE) {
833                 return UNSAFE.getAndBitwiseOr$RawType$Release(
834                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
835                         address(bb, indexRO(bb, index)),
836                         value);
837             } else {
838                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
839             }
840         }
841 
842         @ForceInline
843         static $type$ getAndBitwiseOrAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
844             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
845             if (handle.be == BE) {
846                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
847                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
848                         address(bb, indexRO(bb, index)),
849                         value);
850             } else {
851                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
852             }
853         }
854 
855         @ForceInline
856         static $type$ getAndBitwiseOrConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
857             $type$ nativeExpectedValue, expectedValue;
858             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
859             long offset = address(bb, indexRO(bb, index));
860             do {
861                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
862                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
863             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
864                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
865             return expectedValue;
866         }
867 
868         @ForceInline
869         static $type$ getAndBitwiseAnd(ByteBufferHandle handle, Object obb, int index, $type$ value) {
870             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
871             if (handle.be == BE) {
872                 return UNSAFE.getAndBitwiseAnd$RawType$(
873                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
874                         address(bb, indexRO(bb, index)),
875                         value);
876             } else {
877                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
878             }
879         }
880 
881         @ForceInline
882         static $type$ getAndBitwiseAndRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
883             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
884             if (handle.be == BE) {
885                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
886                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
887                         address(bb, indexRO(bb, index)),
888                         value);
889             } else {
890                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
891             }
892         }
893 
894         @ForceInline
895         static $type$ getAndBitwiseAndAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
896             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
897             if (handle.be == BE) {
898                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
899                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
900                         address(bb, indexRO(bb, index)),
901                         value);
902             } else {
903                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
904             }
905         }
906 
907         @ForceInline
908         static $type$ getAndBitwiseAndConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
909             $type$ nativeExpectedValue, expectedValue;
910             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
911             long offset = address(bb, indexRO(bb, index));
912             do {
913                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
914                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
915             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
916                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
917             return expectedValue;
918         }
919 
920 
921         @ForceInline
922         static $type$ getAndBitwiseXor(ByteBufferHandle handle, Object obb, int index, $type$ value) {
923             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
924             if (handle.be == BE) {
925                 return UNSAFE.getAndBitwiseXor$RawType$(
926                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
927                         address(bb, indexRO(bb, index)),
928                         value);
929             } else {
930                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
931             }
932         }
933 
934         @ForceInline
935         static $type$ getAndBitwiseXorRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
936             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
937             if (handle.be == BE) {
938                 return UNSAFE.getAndBitwiseXor$RawType$Release(
939                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
940                         address(bb, indexRO(bb, index)),
941                         value);
942             } else {
943                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
944             }
945         }
946 
947         @ForceInline
948         static $type$ getAndBitwiseXorAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
949             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
950             if (handle.be == BE) {
951                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
952                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
953                         address(bb, indexRO(bb, index)),
954                         value);
955             } else {
956                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
957             }
958         }
959 
960         @ForceInline
961         static $type$ getAndBitwiseXorConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
962             $type$ nativeExpectedValue, expectedValue;
963             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
964             long offset = address(bb, indexRO(bb, index));
965             do {
966                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
967                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
968             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
969                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
970             return expectedValue;
971         }
972 #end[Bitwise]
973 
974         static final VarForm FORM = new VarForm(ByteBufferHandle.class, ByteBuffer.class, $type$.class, int.class);
975     }
976 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/SocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketImplFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,33 ***</span>
   * questions.
   */
  
  package java.net;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
<span class="line-modified">! import java.io.FileDescriptor;</span>
  import java.util.Set;
  
  /**
   * The abstract class {@code SocketImpl} is a common superclass
   * of all classes that actually implement sockets. It is used to
   * create both client and server sockets.
<span class="line-modified">!  * &lt;p&gt;</span>
<span class="line-modified">!  * A &quot;plain&quot; socket implements these methods exactly as</span>
<span class="line-modified">!  * described, without attempting to go through a firewall or proxy.</span>
   *
   * @author  unascribed
   * @since   1.0
   */
  public abstract class SocketImpl implements SocketOptions {
      /**
<span class="line-modified">!      * The actual Socket object.</span>
       */
<span class="line-modified">!     Socket socket = null;</span>
<span class="line-modified">!     ServerSocket serverSocket = null;</span>
  
      /**
       * The file descriptor object for this socket.
       */
      protected FileDescriptor fd;
<span class="line-new-header">--- 23,68 ---</span>
   * questions.
   */
  
  package java.net;
  
<span class="line-added">+ import java.io.FileDescriptor;</span>
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
<span class="line-modified">! import java.security.AccessController;</span>
<span class="line-added">+ import java.security.PrivilegedAction;</span>
<span class="line-added">+ import java.util.Objects;</span>
  import java.util.Set;
  
<span class="line-added">+ import sun.net.NetProperties;</span>
<span class="line-added">+ import sun.net.PlatformSocketImpl;</span>
<span class="line-added">+ import sun.nio.ch.NioSocketImpl;</span>
<span class="line-added">+ </span>
  /**
   * The abstract class {@code SocketImpl} is a common superclass
   * of all classes that actually implement sockets. It is used to
   * create both client and server sockets.
<span class="line-modified">!  *</span>
<span class="line-modified">!  * @implNote Client and server sockets created with the {@code Socket} and</span>
<span class="line-modified">!  * {@code SocketServer} public constructors create a system-default</span>
<span class="line-added">+  * {@code SocketImpl}. The JDK historically used a {@code SocketImpl}</span>
<span class="line-added">+  * implementation type named &quot;PlainSocketImpl&quot; that has since been replaced by a</span>
<span class="line-added">+  * newer implementation. The JDK continues to ship with the older implementation</span>
<span class="line-added">+  * to allow code to run that depends on unspecified behavior that differs between</span>
<span class="line-added">+  * the old and new implementations. The old implementation will be used if the</span>
<span class="line-added">+  * Java virtual machine is started with the system property {@systemProperty</span>
<span class="line-added">+  * jdk.net.usePlainSocketImpl} set to use the old implementation. It may also be</span>
<span class="line-added">+  * set in the JDK&#39;s network configuration file, located in {@code</span>
<span class="line-added">+  * ${java.home}/conf/net.properties}. The value of the property is the string</span>
<span class="line-added">+  * representation of a boolean. If set without a value then it defaults to {@code</span>
<span class="line-added">+  * true}, hence running with {@code -Djdk.net.usePlainSocketImpl} or {@code</span>
<span class="line-added">+  * -Djdk.net.usePlainSocketImpl=true} will configure the Java virtual machine</span>
<span class="line-added">+  * to use the old implementation. The property and old implementation will be</span>
<span class="line-added">+  * removed in a future version.</span>
   *
   * @author  unascribed
   * @since   1.0
   */
  public abstract class SocketImpl implements SocketOptions {
<span class="line-added">+     private static final boolean USE_PLAINSOCKETIMPL = usePlainSocketImpl();</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static boolean usePlainSocketImpl() {</span>
<span class="line-added">+         PrivilegedAction&lt;String&gt; pa = () -&gt; NetProperties.get(&quot;jdk.net.usePlainSocketImpl&quot;);</span>
<span class="line-added">+         String s = AccessController.doPrivileged(pa);</span>
<span class="line-added">+         return (s != null) &amp;&amp; !s.equalsIgnoreCase(&quot;false&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Creates an instance of platform&#39;s SocketImpl</span>
       */
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!     static &lt;S extends SocketImpl &amp; PlatformSocketImpl&gt; S createPlatformSocketImpl(boolean server) {</span>
<span class="line-added">+         if (USE_PLAINSOCKETIMPL) {</span>
<span class="line-added">+             return (S) new PlainSocketImpl(server);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return (S) new NioSocketImpl(server);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      /**
       * The file descriptor object for this socket.
       */
      protected FileDescriptor fd;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,36 ***</span>
      /**
       * The local port number to which this socket is connected.
       */
      protected int localport;
  
      /**
       * Creates either a stream or a datagram socket.
       *
       * @param      stream   if {@code true}, create a stream socket;
       *                      otherwise, create a datagram socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs while creating the</span>
       *               socket.
       */
      protected abstract void create(boolean stream) throws IOException;
  
      /**
       * Connects this socket to the specified port on the named host.
       *
       * @param      host   the name of the remote host.
       * @param      port   the port number.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when connecting to the</span>
       *               remote host.
       */
      protected abstract void connect(String host, int port) throws IOException;
  
      /**
       * Connects this socket to the specified port number on the specified host.
       *
       * @param      address   the IP address of the remote host.
       * @param      port      the port number.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when attempting a</span>
       *               connection.
       */
      protected abstract void connect(InetAddress address, int port) throws IOException;
  
      /**
<span class="line-new-header">--- 102,41 ---</span>
      /**
       * The local port number to which this socket is connected.
       */
      protected int localport;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Initialize a new instance of this class</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public SocketImpl() { }</span>
<span class="line-added">+ </span>
      /**
       * Creates either a stream or a datagram socket.
       *
       * @param      stream   if {@code true}, create a stream socket;
       *                      otherwise, create a datagram socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs while creating the</span>
       *               socket.
       */
      protected abstract void create(boolean stream) throws IOException;
  
      /**
       * Connects this socket to the specified port on the named host.
       *
       * @param      host   the name of the remote host.
       * @param      port   the port number.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when connecting to the</span>
       *               remote host.
       */
      protected abstract void connect(String host, int port) throws IOException;
  
      /**
       * Connects this socket to the specified port number on the specified host.
       *
       * @param      address   the IP address of the remote host.
       * @param      port      the port number.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when attempting a</span>
       *               connection.
       */
      protected abstract void connect(InetAddress address, int port) throws IOException;
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,91 ***</span>
       * A timeout of zero is interpreted as an infinite timeout. The connection
       * will then block until established or an error occurs.
       *
       * @param      address   the Socket address of the remote host.
       * @param     timeout  the timeout value, in milliseconds, or zero for no timeout.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when attempting a</span>
       *               connection.
       * @since 1.4
       */
      protected abstract void connect(SocketAddress address, int timeout) throws IOException;
  
      /**
       * Binds this socket to the specified local IP address and port number.
       *
       * @param      host   an IP address that belongs to a local interface.
       * @param      port   the port number.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when binding this socket.</span>
       */
      protected abstract void bind(InetAddress host, int port) throws IOException;
  
      /**
       * Sets the maximum queue length for incoming connection indications
       * (a request to connect) to the {@code count} argument. If a
       * connection indication arrives when the queue is full, the
       * connection is refused.
       *
       * @param      backlog   the maximum length of the queue.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the queue.</span>
       */
      protected abstract void listen(int backlog) throws IOException;
  
      /**
       * Accepts a connection.
       *
       * @param      s   the accepted connection.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when accepting the</span>
       *               connection.
       */
      protected abstract void accept(SocketImpl s) throws IOException;
  
      /**
       * Returns an input stream for this socket.
       *
       * @return     a stream for reading from this socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the</span>
       *               input stream.
      */
      protected abstract InputStream getInputStream() throws IOException;
  
      /**
       * Returns an output stream for this socket.
       *
       * @return     an output stream for writing to this socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the</span>
       *               output stream.
       */
      protected abstract OutputStream getOutputStream() throws IOException;
  
      /**
       * Returns the number of bytes that can be read from this socket
       * without blocking.
       *
       * @return     the number of bytes that can be read from this socket
       *             without blocking.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when determining the</span>
       *               number of bytes available.
       */
      protected abstract int available() throws IOException;
  
      /**
       * Closes this socket.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when closing this socket.</span>
       */
      protected abstract void close() throws IOException;
  
      /**
       * Places the input stream for this socket at &quot;end of stream&quot;.
       * Any data sent to this socket is acknowledged and then
       * silently discarded.
       *
       * If you read from a socket input stream after invoking this method on the
       * socket, the stream&#39;s {@code available} method will return 0, and its
       * {@code read} methods will return {@code -1} (end of stream).
       *
<span class="line-modified">!      * @exception IOException if an I/O error occurs when shutting down this</span>
       * socket.
       * @see java.net.Socket#shutdownOutput()
       * @see java.net.Socket#close()
       * @see java.net.Socket#setSoLinger(boolean, int)
       * @since 1.3
<span class="line-new-header">--- 144,100 ---</span>
       * A timeout of zero is interpreted as an infinite timeout. The connection
       * will then block until established or an error occurs.
       *
       * @param      address   the Socket address of the remote host.
       * @param     timeout  the timeout value, in milliseconds, or zero for no timeout.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when attempting a</span>
       *               connection.
       * @since 1.4
       */
      protected abstract void connect(SocketAddress address, int timeout) throws IOException;
  
      /**
       * Binds this socket to the specified local IP address and port number.
       *
       * @param      host   an IP address that belongs to a local interface.
       * @param      port   the port number.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when binding this socket.</span>
       */
      protected abstract void bind(InetAddress host, int port) throws IOException;
  
      /**
       * Sets the maximum queue length for incoming connection indications
       * (a request to connect) to the {@code count} argument. If a
       * connection indication arrives when the queue is full, the
       * connection is refused.
       *
       * @param      backlog   the maximum length of the queue.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the queue.</span>
       */
      protected abstract void listen(int backlog) throws IOException;
  
      /**
       * Accepts a connection.
       *
       * @param      s   the accepted connection.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when accepting the</span>
       *               connection.
       */
      protected abstract void accept(SocketImpl s) throws IOException;
  
      /**
       * Returns an input stream for this socket.
       *
       * @return     a stream for reading from this socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the</span>
       *               input stream.
      */
      protected abstract InputStream getInputStream() throws IOException;
  
      /**
       * Returns an output stream for this socket.
       *
       * @return     an output stream for writing to this socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the</span>
       *               output stream.
       */
      protected abstract OutputStream getOutputStream() throws IOException;
  
      /**
       * Returns the number of bytes that can be read from this socket
       * without blocking.
       *
       * @return     the number of bytes that can be read from this socket
       *             without blocking.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when determining the</span>
       *               number of bytes available.
       */
      protected abstract int available() throws IOException;
  
      /**
       * Closes this socket.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when closing this socket.</span>
       */
      protected abstract void close() throws IOException;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Closes this socket, ignoring any IOException that is thrown by close.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void closeQuietly() {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             close();</span>
<span class="line-added">+         } catch (IOException ignore) { }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Places the input stream for this socket at &quot;end of stream&quot;.
       * Any data sent to this socket is acknowledged and then
       * silently discarded.
       *
       * If you read from a socket input stream after invoking this method on the
       * socket, the stream&#39;s {@code available} method will return 0, and its
       * {@code read} methods will return {@code -1} (end of stream).
       *
<span class="line-modified">!      * @throws    IOException if an I/O error occurs when shutting down this</span>
       * socket.
       * @see java.net.Socket#shutdownOutput()
       * @see java.net.Socket#close()
       * @see java.net.Socket#setSoLinger(boolean, int)
       * @since 1.3
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,11 ***</span>
       *
       * If you write to a socket output stream after invoking
       * shutdownOutput() on the socket, the stream will throw
       * an IOException.
       *
<span class="line-modified">!      * @exception IOException if an I/O error occurs when shutting down this</span>
       * socket.
       * @see java.net.Socket#shutdownInput()
       * @see java.net.Socket#close()
       * @see java.net.Socket#setSoLinger(boolean, int)
       * @since 1.3
<span class="line-new-header">--- 253,11 ---</span>
       *
       * If you write to a socket output stream after invoking
       * shutdownOutput() on the socket, the stream will throw
       * an IOException.
       *
<span class="line-modified">!      * @throws    IOException if an I/O error occurs when shutting down this</span>
       * socket.
       * @see java.net.Socket#shutdownInput()
       * @see java.net.Socket#close()
       * @see java.net.Socket#setSoLinger(boolean, int)
       * @since 1.3
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,11 ***</span>
  
      /**
       * Send one byte of urgent data on the socket.
       * The byte to be sent is the low eight bits of the parameter
       * @param data The byte of data to send
<span class="line-modified">!      * @exception IOException if there is an error</span>
       *  sending the data.
       * @since 1.4
       */
      protected abstract void sendUrgentData (int data) throws IOException;
  
<span class="line-new-header">--- 311,11 ---</span>
  
      /**
       * Send one byte of urgent data on the socket.
       * The byte to be sent is the low eight bits of the parameter
       * @param data The byte of data to send
<span class="line-modified">!      * @throws    IOException if there is an error</span>
       *  sending the data.
       * @since 1.4
       */
      protected abstract void sendUrgentData (int data) throws IOException;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,37 ***</span>
       */
      protected int getLocalPort() {
          return localport;
      }
  
<span class="line-removed">-     void setSocket(Socket soc) {</span>
<span class="line-removed">-         this.socket = soc;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Socket getSocket() {</span>
<span class="line-removed">-         return socket;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setServerSocket(ServerSocket soc) {</span>
<span class="line-removed">-         this.serverSocket = soc;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ServerSocket getServerSocket() {</span>
<span class="line-removed">-         return serverSocket;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Returns the address and port of this socket as a {@code String}.
       *
       * @return  a string representation of this socket.
       */
      public String toString() {
          return &quot;Socket[addr=&quot; + getInetAddress() +
              &quot;,port=&quot; + getPort() + &quot;,localport=&quot; + getLocalPort()  + &quot;]&quot;;
      }
  
<span class="line-modified">!     void reset() throws IOException {</span>
          address = null;
          port = 0;
          localport = 0;
      }
  
<span class="line-new-header">--- 327,22 ---</span>
       */
      protected int getLocalPort() {
          return localport;
      }
  
      /**
       * Returns the address and port of this socket as a {@code String}.
       *
       * @return  a string representation of this socket.
       */
      public String toString() {
          return &quot;Socket[addr=&quot; + getInetAddress() +
              &quot;,port=&quot; + getPort() + &quot;,localport=&quot; + getLocalPort()  + &quot;]&quot;;
      }
  
<span class="line-modified">!     void reset() {</span>
<span class="line-added">+         fd = null;</span>
          address = null;
          port = 0;
          localport = 0;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,122 ***</span>
      }
  
      /**
       * Called to set a socket option.
       *
       * @param &lt;T&gt; The type of the socket option value
       * @param name The socket option
<span class="line-removed">-      *</span>
       * @param value The value of the socket option. A value of {@code null}
       *              may be valid for some options.
       *
       * @throws UnsupportedOperationException if the SocketImpl does not
       *         support the option
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @throws IOException if an I/O error occurs, or if the socket is closed.</span>
       *
       * @since 9
       */
      protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="line-modified">!         if (name == StandardSocketOptions.SO_KEEPALIVE &amp;&amp;</span>
<span class="line-modified">!                 (getSocket() != null)) {</span>
<span class="line-removed">-             setOption(SocketOptions.SO_KEEPALIVE, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_SNDBUF &amp;&amp;</span>
<span class="line-removed">-                 (getSocket() != null)) {</span>
<span class="line-removed">-             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-removed">-             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-removed">-             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_REUSEPORT &amp;&amp;</span>
<span class="line-removed">-             supportedOptions().contains(name)) {</span>
<span class="line-removed">-             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_LINGER &amp;&amp;</span>
<span class="line-removed">-                 (getSocket() != null)) {</span>
<span class="line-removed">-             setOption(SocketOptions.SO_LINGER, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-removed">-             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.TCP_NODELAY &amp;&amp;</span>
<span class="line-removed">-                 (getSocket() != null)) {</span>
<span class="line-removed">-             setOption(SocketOptions.TCP_NODELAY, value);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw new UnsupportedOperationException(&quot;unsupported option&quot;);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Called to get a socket option.
       *
       * @param &lt;T&gt; The type of the socket option value
       * @param name The socket option
<span class="line-removed">-      *</span>
       * @return the value of the named option
       *
       * @throws UnsupportedOperationException if the SocketImpl does not
<span class="line-modified">!      *         support the option.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @throws IOException if an I/O error occurs, or if the socket is closed.</span>
       *
       * @since 9
       */
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
      protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">!         if (name == StandardSocketOptions.SO_KEEPALIVE &amp;&amp;</span>
<span class="line-modified">!                 (getSocket() != null)) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.SO_KEEPALIVE);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_SNDBUF &amp;&amp;</span>
<span class="line-removed">-                 (getSocket() != null)) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_REUSEPORT &amp;&amp;</span>
<span class="line-removed">-             supportedOptions().contains(name)) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.SO_LINGER &amp;&amp;</span>
<span class="line-removed">-                 (getSocket() != null)) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.SO_LINGER);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.IP_TOS);</span>
<span class="line-removed">-         } else if (name == StandardSocketOptions.TCP_NODELAY &amp;&amp;</span>
<span class="line-removed">-                 (getSocket() != null)) {</span>
<span class="line-removed">-             return (T)getOption(SocketOptions.TCP_NODELAY);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw new UnsupportedOperationException(&quot;unsupported option&quot;);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     private static final Set&lt;SocketOption&lt;?&gt;&gt; socketOptions;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static final Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     static {</span>
<span class="line-modified">!         socketOptions = Set.of(StandardSocketOptions.SO_KEEPALIVE,</span>
<span class="line-modified">!                                StandardSocketOptions.SO_SNDBUF,</span>
<span class="line-modified">!                                StandardSocketOptions.SO_RCVBUF,</span>
<span class="line-modified">!                                StandardSocketOptions.SO_REUSEADDR,</span>
<span class="line-modified">!                                StandardSocketOptions.SO_LINGER,</span>
<span class="line-modified">!                                StandardSocketOptions.IP_TOS,</span>
<span class="line-removed">-                                StandardSocketOptions.TCP_NODELAY);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         serverSocketOptions = Set.of(StandardSocketOptions.SO_RCVBUF,</span>
<span class="line-removed">-                                      StandardSocketOptions.SO_REUSEADDR,</span>
<span class="line-removed">-                                      StandardSocketOptions.IP_TOS);</span>
      }
  
      /**
       * Returns a set of SocketOptions supported by this impl
       * and by this impl&#39;s socket (Socket or ServerSocket)
       *
       * @return a Set of SocketOptions
       *
       * @since 9
       */
      protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">!         if (getSocket() != null) {</span>
<span class="line-removed">-             return socketOptions;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return serverSocketOptions;</span>
<span class="line-removed">-         }</span>
      }
  }
<span class="line-new-header">--- 392,84 ---</span>
      }
  
      /**
       * Called to set a socket option.
       *
<span class="line-added">+      * @implSpec</span>
<span class="line-added">+      * The default implementation of this method first checks that the given</span>
<span class="line-added">+      * socket option {@code name} is not null, then throws {@code</span>
<span class="line-added">+      * UnsupportedOperationException}. Subclasses should override this method</span>
<span class="line-added">+      * with an appropriate implementation.</span>
<span class="line-added">+      *</span>
       * @param &lt;T&gt; The type of the socket option value
       * @param name The socket option
       * @param value The value of the socket option. A value of {@code null}
       *              may be valid for some options.
       *
       * @throws UnsupportedOperationException if the SocketImpl does not
       *         support the option
<span class="line-modified">!      * @throws IllegalArgumentException if the value is not valid for</span>
<span class="line-modified">!      *         the option</span>
<span class="line-added">+      * @throws IOException if an I/O error occurs, or if the socket is closed</span>
<span class="line-added">+      * @throws NullPointerException if name is {@code null}</span>
       *
       * @since 9
       */
      protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="line-modified">!         Objects.requireNonNull(name);</span>
<span class="line-modified">!         throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
      }
  
      /**
       * Called to get a socket option.
       *
<span class="line-added">+      * @implSpec</span>
<span class="line-added">+      * The default implementation of this method first checks that the given</span>
<span class="line-added">+      * socket option {@code name} is not null, then throws {@code</span>
<span class="line-added">+      * UnsupportedOperationException}. Subclasses should override this method</span>
<span class="line-added">+      * with an appropriate implementation.</span>
<span class="line-added">+      *</span>
       * @param &lt;T&gt; The type of the socket option value
       * @param name The socket option
       * @return the value of the named option
       *
       * @throws UnsupportedOperationException if the SocketImpl does not
<span class="line-modified">!      *         support the option</span>
<span class="line-modified">!      * @throws IOException if an I/O error occurs, or if the socket is closed</span>
<span class="line-modified">!      * @throws NullPointerException if name is {@code null}</span>
       *
       * @since 9
       */
      protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">!         Objects.requireNonNull(name);</span>
<span class="line-modified">!         throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Attempts to copy socket options from this SocketImpl to a target SocketImpl.</span>
<span class="line-modified">!      * At this time, only the SO_TIMEOUT make sense to copy.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     void copyOptionsTo(SocketImpl target) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             Object timeout = getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-modified">!             if (timeout instanceof Integer) {</span>
<span class="line-modified">!                 target.setOption(SocketOptions.SO_TIMEOUT, timeout);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } catch (IOException ignore) { }</span>
      }
  
      /**
       * Returns a set of SocketOptions supported by this impl
       * and by this impl&#39;s socket (Socket or ServerSocket)
       *
<span class="line-added">+      * @implSpec</span>
<span class="line-added">+      * The default implementation of this method returns an empty set.</span>
<span class="line-added">+      * Subclasses should override this method with an appropriate implementation.</span>
<span class="line-added">+      *</span>
       * @return a Set of SocketOptions
       *
       * @since 9
       */
      protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">!         return Set.of();</span>
      }
  }
</pre>
<center><a href="SocketException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketImplFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
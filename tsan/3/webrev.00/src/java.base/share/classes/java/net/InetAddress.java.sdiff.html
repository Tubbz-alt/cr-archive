<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/InetAddress.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Inet6AddressImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InetSocketAddress.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/InetAddress.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.util.NavigableSet;
  29 import java.util.ArrayList;
  30 import java.util.Objects;
  31 import java.util.Scanner;
  32 import java.security.AccessController;
  33 import java.io.File;
<span class="line-removed">  34 import java.io.FileNotFoundException;</span>
  35 import java.io.ObjectStreamException;
  36 import java.io.ObjectStreamField;
  37 import java.io.IOException;
  38 import java.io.InvalidObjectException;
  39 import java.io.ObjectInputStream;
  40 import java.io.ObjectInputStream.GetField;
  41 import java.io.ObjectOutputStream;
  42 import java.io.ObjectOutputStream.PutField;
  43 import java.lang.annotation.Native;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 import java.util.concurrent.ConcurrentSkipListSet;
  47 import java.util.concurrent.atomic.AtomicLong;

  48 
  49 import jdk.internal.access.JavaNetInetAddressAccess;
  50 import jdk.internal.access.SharedSecrets;
  51 import sun.security.action.*;
  52 import sun.net.InetAddressCachePolicy;
  53 import sun.net.util.IPAddressUtil;

  54 
  55 /**
  56  * This class represents an Internet Protocol (IP) address.
  57  *
  58  * &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
  59  * used by IP, a lower-level protocol on which protocols like UDP and
  60  * TCP are built. The IP address architecture is defined by &lt;a
  61  * href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;790:
  62  * Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a
  63  * href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;1918:
  64  * Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a
  65  * href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
  66  * Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a
  67  * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
  68  * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an
  69  * InetAddress consists of an IP address and possibly its
  70  * corresponding host name (depending on whether it is constructed
  71  * with a host name or whether it has already done reverse host name
  72  * resolution).
  73  *
<span class="line-modified">  74  * &lt;h3&gt; Address types &lt;/h3&gt;</span>
  75  *
  76  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
  77  *   &lt;caption style=&quot;display:none&quot;&gt;Description of unicast and multicast address types&lt;/caption&gt;
  78  *   &lt;thead&gt;
  79  *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Address Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
  80  *   &lt;/thead&gt;
  81  *   &lt;tbody&gt;
  82  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;unicast&lt;/th&gt;
  83  *       &lt;td&gt;An identifier for a single interface. A packet sent to
  84  *         a unicast address is delivered to the interface identified by
  85  *         that address.
  86  *
  87  *         &lt;p&gt; The Unspecified Address -- Also called anylocal or wildcard
  88  *         address. It must never be assigned to any node. It indicates the
  89  *         absence of an address. One example of its use is as the target of
  90  *         bind, which allows a server to accept a client connection on any
  91  *         interface, in case the server host has multiple interfaces.
  92  *
  93  *         &lt;p&gt; The &lt;i&gt;unspecified&lt;/i&gt; address must not be used as
  94  *         the destination address of an IP packet.
  95  *
  96  *         &lt;p&gt; The &lt;i&gt;Loopback&lt;/i&gt; Addresses -- This is the address
  97  *         assigned to the loopback interface. Anything sent to this
  98  *         IP address loops around and becomes IP input on the local
  99  *         host. This address is often used when testing a
 100  *         client.&lt;/td&gt;&lt;/tr&gt;
 101  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;multicast&lt;/th&gt;
 102  *       &lt;td&gt;An identifier for a set of interfaces (typically belonging
 103  *         to different nodes). A packet sent to a multicast address is
 104  *         delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
 105  * &lt;/tbody&gt;
 106  * &lt;/table&gt;
 107  *
<span class="line-modified"> 108  * &lt;h4&gt; IP address scope &lt;/h4&gt;</span>
 109  *
 110  * &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
 111  * on a single link for purposes such as auto-address configuration,
 112  * neighbor discovery, or when no routers are present.
 113  *
 114  * &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
 115  * inside of a site without the need for a global prefix.
 116  *
 117  * &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.
 118  *
<span class="line-modified"> 119  * &lt;h4&gt; Textual representation of IP addresses &lt;/h4&gt;</span>
 120  *
 121  * The textual representation of an IP address is address family specific.
 122  *
 123  * &lt;p&gt;
 124  *
 125  * For IPv4 address format, please refer to &lt;A
 126  * HREF=&quot;Inet4Address.html#format&quot;&gt;Inet4Address#format&lt;/A&gt;; For IPv6
 127  * address format, please refer to &lt;A
 128  * HREF=&quot;Inet6Address.html#format&quot;&gt;Inet6Address#format&lt;/A&gt;.
 129  *
 130  * &lt;P&gt;There is a &lt;a href=&quot;doc-files/net-properties.html#Ipv4IPv6&quot;&gt;couple of
 131  * System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.&lt;/P&gt;
 132  *
<span class="line-modified"> 133  * &lt;h4&gt; Host Name Resolution &lt;/h4&gt;</span>
 134  *
 135  * Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
 136  * the use of a combination of local machine configuration information
 137  * and network naming services such as the Domain Name System (DNS)
 138  * and Network Information Service(NIS). The particular naming
 139  * services(s) being used is by default the local machine configured
 140  * one. For any host name, its corresponding IP address is returned.
 141  *
 142  * &lt;p&gt; &lt;i&gt;Reverse name resolution&lt;/i&gt; means that for any IP address,
 143  * the host associated with the IP address is returned.
 144  *
 145  * &lt;p&gt; The InetAddress class provides methods to resolve host names to
 146  * their IP addresses and vice versa.
 147  *
<span class="line-modified"> 148  * &lt;h4&gt; InetAddress Caching &lt;/h4&gt;</span>
 149  *
 150  * The InetAddress class has a cache to store successful as well as
 151  * unsuccessful host name resolutions.
 152  *
 153  * &lt;p&gt; By default, when a security manager is installed, in order to
 154  * protect against DNS spoofing attacks,
 155  * the result of positive host name resolutions are
 156  * cached forever. When a security manager is not installed, the default
 157  * behavior is to cache entries for a finite (implementation dependent)
 158  * period of time. The result of unsuccessful host
 159  * name resolution is cached for a very short period of time (10
 160  * seconds) to improve performance.
 161  *
 162  * &lt;p&gt; If the default behavior is not desired, then a Java security property
 163  * can be set to a different Time-to-live (TTL) value for positive
 164  * caching. Likewise, a system admin can configure a different
 165  * negative caching TTL value when needed.
 166  *
 167  * &lt;p&gt; Two Java security properties control the TTL values used for
 168  *  positive and negative host name resolution caching:
</pre>
<hr />
<pre>
 178  * &lt;/dd&gt;
 179  * &lt;dt&gt;&lt;b&gt;networkaddress.cache.negative.ttl&lt;/b&gt; (default: 10)&lt;/dt&gt;
 180  * &lt;dd&gt;Indicates the caching policy for un-successful name lookups
 181  * from the name service. The value is specified as an integer to
 182  * indicate the number of seconds to cache the failure for
 183  * un-successful lookups.
 184  * &lt;p&gt;
 185  * A value of 0 indicates &quot;never cache&quot;.
 186  * A value of -1 indicates &quot;cache forever&quot;.
 187  * &lt;/dd&gt;
 188  * &lt;/dl&gt;
 189  *
 190  * @author  Chris Warth
 191  * @see     java.net.InetAddress#getByAddress(byte[])
 192  * @see     java.net.InetAddress#getByAddress(java.lang.String, byte[])
 193  * @see     java.net.InetAddress#getAllByName(java.lang.String)
 194  * @see     java.net.InetAddress#getByName(java.lang.String)
 195  * @see     java.net.InetAddress#getLocalHost()
 196  * @since 1.0
 197  */
<span class="line-modified"> 198 public</span>
<span class="line-removed"> 199 class InetAddress implements java.io.Serializable {</span>
 200 
 201     @Native static final int PREFER_IPV4_VALUE = 0;
 202     @Native static final int PREFER_IPV6_VALUE = 1;
 203     @Native static final int PREFER_SYSTEM_VALUE = 2;
 204 
 205     /**
 206      * Specify the address family: Internet Protocol, Version 4
 207      * @since 1.4
 208      */
 209     @Native static final int IPv4 = 1;
 210 
 211     /**
 212      * Specify the address family: Internet Protocol, Version 6
 213      * @since 1.4
 214      */
 215     @Native static final int IPv6 = 2;
 216 
 217     /* Specify address family preference */
 218     static transient final int preferIPv6Address;
 219 
</pre>
<hr />
<pre>
 272 
 273         /**
 274          * Specifies the address family type, for instance, &#39;1&#39; for IPv4
 275          * addresses, and &#39;2&#39; for IPv6 addresses.
 276          */
 277         int family;
 278 
 279         int getFamily() {
 280             return family;
 281         }
 282     }
 283 
 284     /* Used to store the serializable fields of InetAddress */
 285     final transient InetAddressHolder holder;
 286 
 287     InetAddressHolder holder() {
 288         return holder;
 289     }
 290 
 291     /* Used to store the name service provider */
<span class="line-modified"> 292     private static transient NameService nameService = null;</span>
 293 
 294     /**
 295      * Used to store the best available hostname.
 296      * Lazily initialized via a data race; safe because Strings are immutable.
 297      */
 298     private transient String canonicalHostName = null;
 299 
 300     /** use serialVersionUID from JDK 1.0.2 for interoperability */

 301     private static final long serialVersionUID = 3286316764910316507L;
 302 
 303     /*
 304      * Load net library into runtime, and perform initializations.
 305      */
 306     static {
<span class="line-modified"> 307         String str = java.security.AccessController.doPrivileged(</span>
<span class="line-removed"> 308                 new GetPropertyAction(&quot;java.net.preferIPv6Addresses&quot;));</span>
 309         if (str == null) {
 310             preferIPv6Address = PREFER_IPV4_VALUE;
 311         } else if (str.equalsIgnoreCase(&quot;true&quot;)) {
 312             preferIPv6Address = PREFER_IPV6_VALUE;
 313         } else if (str.equalsIgnoreCase(&quot;false&quot;)) {
 314             preferIPv6Address = PREFER_IPV4_VALUE;
 315         } else if (str.equalsIgnoreCase(&quot;system&quot;)) {
 316             preferIPv6Address = PREFER_SYSTEM_VALUE;
 317         } else {
 318             preferIPv6Address = PREFER_IPV4_VALUE;
 319         }
<span class="line-modified"> 320         AccessController.doPrivileged(</span>
<span class="line-removed"> 321             new java.security.PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed"> 322                 public Void run() {</span>
<span class="line-removed"> 323                     System.loadLibrary(&quot;net&quot;);</span>
<span class="line-removed"> 324                     return null;</span>
<span class="line-removed"> 325                 }</span>
<span class="line-removed"> 326             });</span>
 327         SharedSecrets.setJavaNetInetAddressAccess(
 328                 new JavaNetInetAddressAccess() {
 329                     public String getOriginalHostName(InetAddress ia) {
 330                         return ia.holder.getOriginalHostName();
 331                     }
 332 
 333                     public InetAddress getByName(String hostName,
 334                                                  InetAddress hostAddress)
<span class="line-modified"> 335                             throws UnknownHostException</span>
 336                     {
 337                         return InetAddress.getByName(hostName, hostAddress);
 338                     }








 339                 }
 340         );
 341         init();
 342     }
 343 
 344     /**
 345      * Constructor for the Socket.accept() method.
 346      * This creates an empty InetAddress, which is filled in by
 347      * the accept() method.  This InetAddress, however, is not
 348      * put in the address cache, since it is not created by name.
 349      */
 350     InetAddress() {
 351         holder = new InetAddressHolder();
 352     }
 353 
 354     /**
 355      * Replaces the de-serialized object with an Inet4Address object.
 356      *
 357      * @return the alternate object to the de-serialized object.
 358      *
 359      * @throws ObjectStreamException if a new object replacing this
 360      * object could not be created
 361      */

 362     private Object readResolve() throws ObjectStreamException {
 363         // will replace the deserialized &#39;this&#39; object
 364         return new Inet4Address(holder().getHostName(), holder().getAddress());
 365     }
 366 
 367     /**
 368      * Utility routine to check if the InetAddress is an
 369      * IP multicast address.
 370      * @return a {@code boolean} indicating if the InetAddress is
 371      * an IP multicast address
 372      * @since   1.1
 373      */
 374     public boolean isMulticastAddress() {
 375         return false;
 376     }
 377 
 378     /**
 379      * Utility routine to check if the InetAddress is a wildcard address.
 380      * @return a {@code boolean} indicating if the InetAddress is
 381      *         a wildcard address.
</pre>
<hr />
<pre>
 972                 }
 973             }
 974             return stringifiedAddress;
 975         }
 976 
 977         /**
 978          * Lookup the host name  corresponding to the IP address provided.
 979          * Search the configured host file a host name corresponding to
 980          * the specified IP address.
 981          *
 982          * @param addr byte array representing an IP address
 983          * @return {@code String} representing the host name mapping
 984          * @throws UnknownHostException
 985          *             if no host found for the specified IP address
 986          */
 987         @Override
 988         public String getHostByAddr(byte[] addr) throws UnknownHostException {
 989             String hostEntry;
 990             String host = null;
 991 
<span class="line-modified"> 992             String addrString = addrToString(addr);</span>
<span class="line-modified"> 993             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile), &quot;UTF-8&quot;)) {</span>

 994                 while (hostsFileScanner.hasNextLine()) {
 995                     hostEntry = hostsFileScanner.nextLine();
 996                     if (!hostEntry.startsWith(&quot;#&quot;)) {
 997                         hostEntry = removeComments(hostEntry);
<span class="line-modified"> 998                         if (hostEntry.contains(addrString)) {</span>
<span class="line-modified"> 999                             host = extractHost(hostEntry, addrString);</span>
<span class="line-modified">1000                             if (host != null) {</span>
<span class="line-modified">1001                                 break;</span>
<span class="line-modified">1002                             }</span>
1003                         }
1004                     }
1005                 }
<span class="line-modified">1006             } catch (FileNotFoundException e) {</span>
1007                 throw new UnknownHostException(&quot;Unable to resolve address &quot;
<span class="line-modified">1008                         + addrString + &quot; as hosts file &quot; + hostsFile</span>
1009                         + &quot; not found &quot;);
1010             }
1011 
1012             if ((host == null) || (host.isEmpty()) || (host.equals(&quot; &quot;))) {
1013                 throw new UnknownHostException(&quot;Requested address &quot;
<span class="line-modified">1014                         + addrString</span>
1015                         + &quot; resolves to an invalid entry in hosts file &quot;
1016                         + hostsFile);
1017             }
1018             return host;
1019         }
1020 
1021         /**
1022          * &lt;p&gt;Lookup a host mapping by name. Retrieve the IP addresses
1023          * associated with a host.
1024          *
1025          * &lt;p&gt;Search the configured hosts file for the addresses associated
1026          * with the specified host name.
1027          *
1028          * @param host the specified hostname
1029          * @return array of IP addresses for the requested host
1030          * @throws UnknownHostException
1031          *             if no IP address for the {@code host} could be found
1032          */
1033         public InetAddress[] lookupAllHostAddr(String host)
1034                 throws UnknownHostException {
1035             String hostEntry;
1036             String addrStr = null;
1037             InetAddress[] res = null;
1038             byte addr[] = new byte[4];
1039             ArrayList&lt;InetAddress&gt; inetAddresses = null;
1040 
1041             // lookup the file and create a list InetAddress for the specified host
<span class="line-modified">1042             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile), &quot;UTF-8&quot;)) {</span>


1043                 while (hostsFileScanner.hasNextLine()) {
1044                     hostEntry = hostsFileScanner.nextLine();
1045                     if (!hostEntry.startsWith(&quot;#&quot;)) {
1046                         hostEntry = removeComments(hostEntry);
1047                         if (hostEntry.contains(host)) {
1048                             addrStr = extractHostAddr(hostEntry, host);
1049                             if ((addrStr != null) &amp;&amp; (!addrStr.isEmpty())) {
1050                                 addr = createAddressByteArray(addrStr);
1051                                 if (inetAddresses == null) {
1052                                     inetAddresses = new ArrayList&lt;&gt;(1);
1053                                 }
1054                                 if (addr != null) {
1055                                     inetAddresses.add(InetAddress.getByAddress(host, addr));
1056                                 }
1057                             }
1058                         }
1059                     }
1060                 }
<span class="line-modified">1061             } catch (FileNotFoundException e) {</span>
1062                 throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
1063                         + &quot; as hosts file &quot; + hostsFile + &quot; not found &quot;);
1064             }
1065 
1066             if (inetAddresses != null) {
1067                 res = inetAddresses.toArray(new InetAddress[inetAddresses.size()]);
1068             } else {
1069                 throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
1070                         + &quot; in hosts file &quot; + hostsFile);
1071             }
1072             return res;
1073         }
1074 
1075         private String removeComments(String hostsEntry) {
1076             String filteredEntry = hostsEntry;
1077             int hashIndex;
1078 
1079             if ((hashIndex = hostsEntry.indexOf(&quot;#&quot;)) != -1) {
1080                 filteredEntry = hostsEntry.substring(0, hashIndex);
1081             }
</pre>
<hr />
<pre>
1090                 addrArray = IPAddressUtil.textToNumericFormatV6(addrStr);
1091             }
1092             return addrArray;
1093         }
1094 
1095         /** host to ip address mapping */
1096         private String extractHostAddr(String hostEntry, String host) {
1097             String[] mapping = hostEntry.split(&quot;\\s+&quot;);
1098             String hostAddr = null;
1099 
1100             if (mapping.length &gt;= 2) {
1101                 // look at the host aliases
1102                 for (int i = 1; i &lt; mapping.length; i++) {
1103                     if (mapping[i].equalsIgnoreCase(host)) {
1104                         hostAddr = mapping[0];
1105                     }
1106                 }
1107             }
1108             return hostAddr;
1109         }
<span class="line-removed">1110 </span>
<span class="line-removed">1111         /**</span>
<span class="line-removed">1112          * IP Address to host mapping</span>
<span class="line-removed">1113          * use first host alias in list</span>
<span class="line-removed">1114          */</span>
<span class="line-removed">1115         private String extractHost(String hostEntry, String addrString) {</span>
<span class="line-removed">1116             String[] mapping = hostEntry.split(&quot;\\s+&quot;);</span>
<span class="line-removed">1117             String host = null;</span>
<span class="line-removed">1118 </span>
<span class="line-removed">1119             if (mapping.length &gt;= 2) {</span>
<span class="line-removed">1120                 if (mapping[0].equalsIgnoreCase(addrString)) {</span>
<span class="line-removed">1121                     host = mapping[1];</span>
<span class="line-removed">1122                 }</span>
<span class="line-removed">1123             }</span>
<span class="line-removed">1124             return host;</span>
<span class="line-removed">1125         }</span>
1126     }
1127 
1128     static final InetAddressImpl  impl;
1129 
1130     static {
1131         // create the impl
1132         impl = InetAddressImplFactory.create();
1133 
1134         // create name service
1135         nameService = createNameService();
1136         }
1137 
1138     /**
1139      * Create an instance of the NameService interface based on
1140      * the setting of the {@code jdk.net.hosts.file} system property.
1141      *
1142      * &lt;p&gt;The default NameService is the PlatformNameService, which typically
1143      * delegates name and address resolution calls to the underlying
1144      * OS network libraries.
1145      *
</pre>
<hr />
<pre>
1165 
1166     /**
1167      * Creates an InetAddress based on the provided host name and IP address.
1168      * No name service is checked for the validity of the address.
1169      *
1170      * &lt;p&gt; The host name can either be a machine name, such as
1171      * &quot;{@code www.example.com}&quot;, or a textual representation of its IP
1172      * address.
1173      * &lt;p&gt; No validity checking is done on the host name either.
1174      *
1175      * &lt;p&gt; If addr specifies an IPv4 address an instance of Inet4Address
1176      * will be returned; otherwise, an instance of Inet6Address
1177      * will be returned.
1178      *
1179      * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
1180      * must be 16 bytes long
1181      *
1182      * @param host the specified host
1183      * @param addr the raw IP address in network byte order
1184      * @return  an InetAddress object created from the raw IP address.
<span class="line-modified">1185      * @exception  UnknownHostException  if IP address is of illegal length</span>
1186      * @since 1.4
1187      */
1188     public static InetAddress getByAddress(String host, byte[] addr)
1189         throws UnknownHostException {
1190         if (host != null &amp;&amp; !host.isEmpty() &amp;&amp; host.charAt(0) == &#39;[&#39;) {
1191             if (host.charAt(host.length()-1) == &#39;]&#39;) {
1192                 host = host.substring(1, host.length() -1);
1193             }
1194         }
1195         if (addr != null) {
1196             if (addr.length == Inet4Address.INADDRSZ) {
1197                 return new Inet4Address(host, addr);
1198             } else if (addr.length == Inet6Address.INADDRSZ) {
1199                 byte[] newAddr
1200                     = IPAddressUtil.convertFromIPv4MappedAddress(addr);
1201                 if (newAddr != null) {
1202                     return new Inet4Address(host, newAddr);
1203                 } else {
1204                     return new Inet6Address(host, addr);
1205                 }
</pre>
<hr />
<pre>
1220      * &lt;p&gt; For {@code host} specified in literal IPv6 address,
1221      * either the form defined in RFC 2732 or the literal IPv6 address
1222      * format defined in RFC 2373 is accepted. IPv6 scoped addresses are also
1223      * supported. See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
1224      * scoped addresses.
1225      *
1226      * &lt;p&gt; If the host is {@code null} or {@code host.length()} is equal
1227      * to zero, then an {@code InetAddress} representing an address of the
1228      * loopback interface is returned.
1229      * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
1230      * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
1231      * section&amp;nbsp;2.5.3.
1232      *
1233      * &lt;p&gt; If there is a security manager, and {@code host} is not {@code null}
1234      * or {@code host.length() } is not equal to zero, the security manager&#39;s
1235      * {@code checkConnect} method is called with the hostname and {@code -1}
1236      * as its arguments to determine if the operation is allowed.
1237      *
1238      * @param      host   the specified host, or {@code null}.
1239      * @return     an IP address for the given host name.
<span class="line-modified">1240      * @exception  UnknownHostException  if no IP address for the</span>
1241      *               {@code host} could be found, or if a scope_id was specified
1242      *               for a global IPv6 address.
<span class="line-modified">1243      * @exception  SecurityException if a security manager exists</span>
1244      *             and its checkConnect method doesn&#39;t allow the operation
1245      */
1246     public static InetAddress getByName(String host)
1247         throws UnknownHostException {
1248         return InetAddress.getAllByName(host)[0];
1249     }
1250 
1251     // called from deployment cache manager
1252     private static InetAddress getByName(String host, InetAddress reqAddr)
1253         throws UnknownHostException {
1254         return InetAddress.getAllByName(host, reqAddr)[0];
1255     }
1256 
1257     /**
1258      * Given the name of a host, returns an array of its IP addresses,
1259      * based on the configured name service on the system.
1260      *
1261      * &lt;p&gt; The host name can either be a machine name, such as
1262      * &quot;{@code www.example.com}&quot;, or a textual representation of its IP
1263      * address. If a literal IP address is supplied, only the
</pre>
<hr />
<pre>
1268      * format defined in RFC 2373 is accepted. A literal IPv6 address may
1269      * also be qualified by appending a scoped zone identifier or scope_id.
1270      * The syntax and usage of scope_ids is described
1271      * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
1272      *
1273      * &lt;p&gt; If the host is {@code null} or {@code host.length()} is equal
1274      * to zero, then an {@code InetAddress} representing an address of the
1275      * loopback interface is returned.
1276      * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
1277      * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
1278      * section&amp;nbsp;2.5.3. &lt;/p&gt;
1279      *
1280      * &lt;p&gt; If there is a security manager, and {@code host} is not {@code null}
1281      * or {@code host.length() } is not equal to zero, the security manager&#39;s
1282      * {@code checkConnect} method is called with the hostname and {@code -1}
1283      * as its arguments to determine if the operation is allowed.
1284      *
1285      * @param      host   the name of the host, or {@code null}.
1286      * @return     an array of all the IP addresses for a given host name.
1287      *
<span class="line-modified">1288      * @exception  UnknownHostException  if no IP address for the</span>
1289      *               {@code host} could be found, or if a scope_id was specified
1290      *               for a global IPv6 address.
<span class="line-modified">1291      * @exception  SecurityException  if a security manager exists and its</span>
1292      *               {@code checkConnect} method doesn&#39;t allow the operation.
1293      *
1294      * @see SecurityManager#checkConnect
1295      */
1296     public static InetAddress[] getAllByName(String host)
1297         throws UnknownHostException {
1298         return getAllByName(host, null);
1299     }
1300 
1301     private static InetAddress[] getAllByName(String host, InetAddress reqAddr)
1302         throws UnknownHostException {
1303 
1304         if (host == null || host.isEmpty()) {
1305             InetAddress[] ret = new InetAddress[1];
1306             ret[0] = impl.loopbackAddress();
1307             return ret;
1308         }
1309 
1310         boolean ipv6Expected = false;
1311         if (host.charAt(0) == &#39;[&#39;) {
</pre>
<hr />
<pre>
1546                 addresses[i] = tmp2;
1547             }
1548         }
1549 
1550         return addresses;
1551     }
1552 
1553     /**
1554      * Returns an {@code InetAddress} object given the raw IP address .
1555      * The argument is in network byte order: the highest order
1556      * byte of the address is in {@code getAddress()[0]}.
1557      *
1558      * &lt;p&gt; This method doesn&#39;t block, i.e. no reverse name service lookup
1559      * is performed.
1560      *
1561      * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
1562      * must be 16 bytes long
1563      *
1564      * @param addr the raw IP address in network byte order
1565      * @return  an InetAddress object created from the raw IP address.
<span class="line-modified">1566      * @exception  UnknownHostException  if IP address is of illegal length</span>
1567      * @since 1.4
1568      */
1569     public static InetAddress getByAddress(byte[] addr)
1570         throws UnknownHostException {
1571         return getByAddress(null, addr);
1572     }
1573 
1574     private static final class CachedLocalHost {
1575         final String host;
1576         final InetAddress addr;
1577         final long expiryTime = System.nanoTime() + 5000_000_000L; // now + 5s;
1578 
1579         CachedLocalHost(String host, InetAddress addr) {
1580             this.host = host;
1581             this.addr = addr;
1582         }
1583     }
1584 
1585     private static volatile CachedLocalHost cachedLocalHost;
1586 
1587     /**
1588      * Returns the address of the local host. This is achieved by retrieving
1589      * the name of the host from the system, then resolving that name into
1590      * an {@code InetAddress}.
1591      *
1592      * &lt;P&gt;Note: The resolved address may be cached for a short period of time.
1593      * &lt;/P&gt;
1594      *
1595      * &lt;p&gt;If there is a security manager, its
1596      * {@code checkConnect} method is called
1597      * with the local host name and {@code -1}
1598      * as its arguments to see if the operation is allowed.
1599      * If the operation is not allowed, an InetAddress representing
1600      * the loopback address is returned.
1601      *
1602      * @return     the address of the local host.
1603      *
<span class="line-modified">1604      * @exception  UnknownHostException  if the local host name could not</span>
1605      *             be resolved into an address.
1606      *
1607      * @see SecurityManager#checkConnect
1608      * @see java.net.InetAddress#getByName(java.lang.String)
1609      */
1610     public static InetAddress getLocalHost() throws UnknownHostException {
1611 
1612         SecurityManager security = System.getSecurityManager();
1613         try {
1614             // is cached data still valid?
1615             CachedLocalHost clh = cachedLocalHost;
1616             if (clh != null &amp;&amp; (clh.expiryTime - System.nanoTime()) &gt;= 0L) {
1617                 if (security != null) {
1618                     security.checkConnect(clh.host, -1);
1619                 }
1620                 return clh.addr;
1621             }
1622 
1623             String local = impl.getLocalHostName();
1624 
</pre>
<hr />
<pre>
1693                                &quot;in your properties file.&quot;);
1694         } catch (IllegalAccessException e) {
1695             System.err.println(&quot;Cannot access class: java.net.&quot; + prefix +
1696                                implName + &quot;:\ncheck impl.prefix property &quot; +
1697                                &quot;in your properties file.&quot;);
1698         }
1699 
1700         if (impl == null) {
1701             try {
1702                 @SuppressWarnings(&quot;deprecation&quot;)
1703                 Object tmp = Class.forName(implName).newInstance();
1704                 impl = tmp;
1705             } catch (Exception e) {
1706                 throw new Error(&quot;System property impl.prefix incorrect&quot;);
1707             }
1708         }
1709 
1710         return (InetAddressImpl) impl;
1711     }
1712 

1713     private void readObjectNoData () {
1714         if (getClass().getClassLoader() != null) {
1715             throw new SecurityException (&quot;invalid address type&quot;);
1716         }
1717     }
1718 
1719     private static final jdk.internal.misc.Unsafe UNSAFE
1720             = jdk.internal.misc.Unsafe.getUnsafe();
1721     private static final long FIELDS_OFFSET
1722             = UNSAFE.objectFieldOffset(InetAddress.class, &quot;holder&quot;);
1723 

1724     private void readObject (ObjectInputStream s) throws
1725                          IOException, ClassNotFoundException {
1726         if (getClass().getClassLoader() != null) {
1727             throw new SecurityException (&quot;invalid address type&quot;);
1728         }
1729         GetField gf = s.readFields();
1730         String host = (String)gf.get(&quot;hostName&quot;, null);
1731         int address = gf.get(&quot;address&quot;, 0);
1732         int family = gf.get(&quot;family&quot;, 0);
1733         if (family != IPv4 &amp;&amp; family != IPv6) {
1734             throw new InvalidObjectException(&quot;invalid address family type: &quot; + family);
1735         }
1736         InetAddressHolder h = new InetAddressHolder(host, address, family);
1737         UNSAFE.putReference(this, FIELDS_OFFSET, h);
1738     }
1739 
1740     /* needed because the serializable fields no longer exist */
1741 
1742     /**
1743      * @serialField hostName String
1744      * @serialField address int
1745      * @serialField family int
1746      */

1747     private static final ObjectStreamField[] serialPersistentFields = {
1748         new ObjectStreamField(&quot;hostName&quot;, String.class),
1749         new ObjectStreamField(&quot;address&quot;, int.class),
1750         new ObjectStreamField(&quot;family&quot;, int.class),
1751     };
1752 

1753     private void writeObject (ObjectOutputStream s) throws
1754                         IOException {
1755         if (getClass().getClassLoader() != null) {
1756             throw new SecurityException (&quot;invalid address type&quot;);
1757         }
1758         PutField pf = s.putFields();
1759         pf.put(&quot;hostName&quot;, holder().getHostName());
1760         pf.put(&quot;address&quot;, holder().getAddress());
1761         pf.put(&quot;family&quot;, holder().getFamily());
1762         s.writeFields();
1763     }
1764 }
1765 
1766 /*
1767  * Simple factory to create the impl
1768  */
1769 class InetAddressImplFactory {
1770 
1771     static InetAddressImpl create() {
1772         return InetAddress.loadImpl(isIPv6Supported() ?
</pre>
</td>
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.util.NavigableSet;
  29 import java.util.ArrayList;
  30 import java.util.Objects;
  31 import java.util.Scanner;
  32 import java.security.AccessController;
  33 import java.io.File;

  34 import java.io.ObjectStreamException;
  35 import java.io.ObjectStreamField;
  36 import java.io.IOException;
  37 import java.io.InvalidObjectException;
  38 import java.io.ObjectInputStream;
  39 import java.io.ObjectInputStream.GetField;
  40 import java.io.ObjectOutputStream;
  41 import java.io.ObjectOutputStream.PutField;
  42 import java.lang.annotation.Native;
  43 import java.util.concurrent.ConcurrentHashMap;
  44 import java.util.concurrent.ConcurrentMap;
  45 import java.util.concurrent.ConcurrentSkipListSet;
  46 import java.util.concurrent.atomic.AtomicLong;
<span class="line-added">  47 import java.util.Arrays;</span>
  48 
  49 import jdk.internal.access.JavaNetInetAddressAccess;
  50 import jdk.internal.access.SharedSecrets;
  51 import sun.security.action.*;
  52 import sun.net.InetAddressCachePolicy;
  53 import sun.net.util.IPAddressUtil;
<span class="line-added">  54 import sun.nio.cs.UTF_8;</span>
  55 
  56 /**
  57  * This class represents an Internet Protocol (IP) address.
  58  *
  59  * &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
  60  * used by IP, a lower-level protocol on which protocols like UDP and
  61  * TCP are built. The IP address architecture is defined by &lt;a
  62  * href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;790:
  63  * Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a
  64  * href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;1918:
  65  * Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a
  66  * href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
  67  * Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a
  68  * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
  69  * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an
  70  * InetAddress consists of an IP address and possibly its
  71  * corresponding host name (depending on whether it is constructed
  72  * with a host name or whether it has already done reverse host name
  73  * resolution).
  74  *
<span class="line-modified">  75  * &lt;h2&gt; Address types &lt;/h2&gt;</span>
  76  *
  77  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
  78  *   &lt;caption style=&quot;display:none&quot;&gt;Description of unicast and multicast address types&lt;/caption&gt;
  79  *   &lt;thead&gt;
  80  *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Address Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
  81  *   &lt;/thead&gt;
  82  *   &lt;tbody&gt;
  83  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;unicast&lt;/th&gt;
  84  *       &lt;td&gt;An identifier for a single interface. A packet sent to
  85  *         a unicast address is delivered to the interface identified by
  86  *         that address.
  87  *
  88  *         &lt;p&gt; The Unspecified Address -- Also called anylocal or wildcard
  89  *         address. It must never be assigned to any node. It indicates the
  90  *         absence of an address. One example of its use is as the target of
  91  *         bind, which allows a server to accept a client connection on any
  92  *         interface, in case the server host has multiple interfaces.
  93  *
  94  *         &lt;p&gt; The &lt;i&gt;unspecified&lt;/i&gt; address must not be used as
  95  *         the destination address of an IP packet.
  96  *
  97  *         &lt;p&gt; The &lt;i&gt;Loopback&lt;/i&gt; Addresses -- This is the address
  98  *         assigned to the loopback interface. Anything sent to this
  99  *         IP address loops around and becomes IP input on the local
 100  *         host. This address is often used when testing a
 101  *         client.&lt;/td&gt;&lt;/tr&gt;
 102  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;multicast&lt;/th&gt;
 103  *       &lt;td&gt;An identifier for a set of interfaces (typically belonging
 104  *         to different nodes). A packet sent to a multicast address is
 105  *         delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
 106  * &lt;/tbody&gt;
 107  * &lt;/table&gt;
 108  *
<span class="line-modified"> 109  * &lt;h3&gt; IP address scope &lt;/h3&gt;</span>
 110  *
 111  * &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
 112  * on a single link for purposes such as auto-address configuration,
 113  * neighbor discovery, or when no routers are present.
 114  *
 115  * &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
 116  * inside of a site without the need for a global prefix.
 117  *
 118  * &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.
 119  *
<span class="line-modified"> 120  * &lt;h3&gt; Textual representation of IP addresses &lt;/h3&gt;</span>
 121  *
 122  * The textual representation of an IP address is address family specific.
 123  *
 124  * &lt;p&gt;
 125  *
 126  * For IPv4 address format, please refer to &lt;A
 127  * HREF=&quot;Inet4Address.html#format&quot;&gt;Inet4Address#format&lt;/A&gt;; For IPv6
 128  * address format, please refer to &lt;A
 129  * HREF=&quot;Inet6Address.html#format&quot;&gt;Inet6Address#format&lt;/A&gt;.
 130  *
 131  * &lt;P&gt;There is a &lt;a href=&quot;doc-files/net-properties.html#Ipv4IPv6&quot;&gt;couple of
 132  * System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.&lt;/P&gt;
 133  *
<span class="line-modified"> 134  * &lt;h3&gt; Host Name Resolution &lt;/h3&gt;</span>
 135  *
 136  * Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
 137  * the use of a combination of local machine configuration information
 138  * and network naming services such as the Domain Name System (DNS)
 139  * and Network Information Service(NIS). The particular naming
 140  * services(s) being used is by default the local machine configured
 141  * one. For any host name, its corresponding IP address is returned.
 142  *
 143  * &lt;p&gt; &lt;i&gt;Reverse name resolution&lt;/i&gt; means that for any IP address,
 144  * the host associated with the IP address is returned.
 145  *
 146  * &lt;p&gt; The InetAddress class provides methods to resolve host names to
 147  * their IP addresses and vice versa.
 148  *
<span class="line-modified"> 149  * &lt;h3&gt; InetAddress Caching &lt;/h3&gt;</span>
 150  *
 151  * The InetAddress class has a cache to store successful as well as
 152  * unsuccessful host name resolutions.
 153  *
 154  * &lt;p&gt; By default, when a security manager is installed, in order to
 155  * protect against DNS spoofing attacks,
 156  * the result of positive host name resolutions are
 157  * cached forever. When a security manager is not installed, the default
 158  * behavior is to cache entries for a finite (implementation dependent)
 159  * period of time. The result of unsuccessful host
 160  * name resolution is cached for a very short period of time (10
 161  * seconds) to improve performance.
 162  *
 163  * &lt;p&gt; If the default behavior is not desired, then a Java security property
 164  * can be set to a different Time-to-live (TTL) value for positive
 165  * caching. Likewise, a system admin can configure a different
 166  * negative caching TTL value when needed.
 167  *
 168  * &lt;p&gt; Two Java security properties control the TTL values used for
 169  *  positive and negative host name resolution caching:
</pre>
<hr />
<pre>
 179  * &lt;/dd&gt;
 180  * &lt;dt&gt;&lt;b&gt;networkaddress.cache.negative.ttl&lt;/b&gt; (default: 10)&lt;/dt&gt;
 181  * &lt;dd&gt;Indicates the caching policy for un-successful name lookups
 182  * from the name service. The value is specified as an integer to
 183  * indicate the number of seconds to cache the failure for
 184  * un-successful lookups.
 185  * &lt;p&gt;
 186  * A value of 0 indicates &quot;never cache&quot;.
 187  * A value of -1 indicates &quot;cache forever&quot;.
 188  * &lt;/dd&gt;
 189  * &lt;/dl&gt;
 190  *
 191  * @author  Chris Warth
 192  * @see     java.net.InetAddress#getByAddress(byte[])
 193  * @see     java.net.InetAddress#getByAddress(java.lang.String, byte[])
 194  * @see     java.net.InetAddress#getAllByName(java.lang.String)
 195  * @see     java.net.InetAddress#getByName(java.lang.String)
 196  * @see     java.net.InetAddress#getLocalHost()
 197  * @since 1.0
 198  */
<span class="line-modified"> 199 public class InetAddress implements java.io.Serializable {</span>

 200 
 201     @Native static final int PREFER_IPV4_VALUE = 0;
 202     @Native static final int PREFER_IPV6_VALUE = 1;
 203     @Native static final int PREFER_SYSTEM_VALUE = 2;
 204 
 205     /**
 206      * Specify the address family: Internet Protocol, Version 4
 207      * @since 1.4
 208      */
 209     @Native static final int IPv4 = 1;
 210 
 211     /**
 212      * Specify the address family: Internet Protocol, Version 6
 213      * @since 1.4
 214      */
 215     @Native static final int IPv6 = 2;
 216 
 217     /* Specify address family preference */
 218     static transient final int preferIPv6Address;
 219 
</pre>
<hr />
<pre>
 272 
 273         /**
 274          * Specifies the address family type, for instance, &#39;1&#39; for IPv4
 275          * addresses, and &#39;2&#39; for IPv6 addresses.
 276          */
 277         int family;
 278 
 279         int getFamily() {
 280             return family;
 281         }
 282     }
 283 
 284     /* Used to store the serializable fields of InetAddress */
 285     final transient InetAddressHolder holder;
 286 
 287     InetAddressHolder holder() {
 288         return holder;
 289     }
 290 
 291     /* Used to store the name service provider */
<span class="line-modified"> 292     private static transient NameService nameService;</span>
 293 
 294     /**
 295      * Used to store the best available hostname.
 296      * Lazily initialized via a data race; safe because Strings are immutable.
 297      */
 298     private transient String canonicalHostName = null;
 299 
 300     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added"> 301     @java.io.Serial</span>
 302     private static final long serialVersionUID = 3286316764910316507L;
 303 
 304     /*
 305      * Load net library into runtime, and perform initializations.
 306      */
 307     static {
<span class="line-modified"> 308         String str = GetPropertyAction.privilegedGetProperty(&quot;java.net.preferIPv6Addresses&quot;);</span>

 309         if (str == null) {
 310             preferIPv6Address = PREFER_IPV4_VALUE;
 311         } else if (str.equalsIgnoreCase(&quot;true&quot;)) {
 312             preferIPv6Address = PREFER_IPV6_VALUE;
 313         } else if (str.equalsIgnoreCase(&quot;false&quot;)) {
 314             preferIPv6Address = PREFER_IPV4_VALUE;
 315         } else if (str.equalsIgnoreCase(&quot;system&quot;)) {
 316             preferIPv6Address = PREFER_SYSTEM_VALUE;
 317         } else {
 318             preferIPv6Address = PREFER_IPV4_VALUE;
 319         }
<span class="line-modified"> 320         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 321         SharedSecrets.setJavaNetInetAddressAccess(
 322                 new JavaNetInetAddressAccess() {
 323                     public String getOriginalHostName(InetAddress ia) {
 324                         return ia.holder.getOriginalHostName();
 325                     }
 326 
 327                     public InetAddress getByName(String hostName,
 328                                                  InetAddress hostAddress)
<span class="line-modified"> 329                         throws UnknownHostException</span>
 330                     {
 331                         return InetAddress.getByName(hostName, hostAddress);
 332                     }
<span class="line-added"> 333 </span>
<span class="line-added"> 334                     public int addressValue(Inet4Address inet4Address) {</span>
<span class="line-added"> 335                         return inet4Address.addressValue();</span>
<span class="line-added"> 336                     }</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338                     public byte[] addressBytes(Inet6Address inet6Address) {</span>
<span class="line-added"> 339                         return inet6Address.addressBytes();</span>
<span class="line-added"> 340                     }</span>
 341                 }
 342         );
 343         init();
 344     }
 345 
 346     /**
 347      * Constructor for the Socket.accept() method.
 348      * This creates an empty InetAddress, which is filled in by
 349      * the accept() method.  This InetAddress, however, is not
 350      * put in the address cache, since it is not created by name.
 351      */
 352     InetAddress() {
 353         holder = new InetAddressHolder();
 354     }
 355 
 356     /**
 357      * Replaces the de-serialized object with an Inet4Address object.
 358      *
 359      * @return the alternate object to the de-serialized object.
 360      *
 361      * @throws ObjectStreamException if a new object replacing this
 362      * object could not be created
 363      */
<span class="line-added"> 364     @java.io.Serial</span>
 365     private Object readResolve() throws ObjectStreamException {
 366         // will replace the deserialized &#39;this&#39; object
 367         return new Inet4Address(holder().getHostName(), holder().getAddress());
 368     }
 369 
 370     /**
 371      * Utility routine to check if the InetAddress is an
 372      * IP multicast address.
 373      * @return a {@code boolean} indicating if the InetAddress is
 374      * an IP multicast address
 375      * @since   1.1
 376      */
 377     public boolean isMulticastAddress() {
 378         return false;
 379     }
 380 
 381     /**
 382      * Utility routine to check if the InetAddress is a wildcard address.
 383      * @return a {@code boolean} indicating if the InetAddress is
 384      *         a wildcard address.
</pre>
<hr />
<pre>
 975                 }
 976             }
 977             return stringifiedAddress;
 978         }
 979 
 980         /**
 981          * Lookup the host name  corresponding to the IP address provided.
 982          * Search the configured host file a host name corresponding to
 983          * the specified IP address.
 984          *
 985          * @param addr byte array representing an IP address
 986          * @return {@code String} representing the host name mapping
 987          * @throws UnknownHostException
 988          *             if no host found for the specified IP address
 989          */
 990         @Override
 991         public String getHostByAddr(byte[] addr) throws UnknownHostException {
 992             String hostEntry;
 993             String host = null;
 994 
<span class="line-modified"> 995             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),</span>
<span class="line-modified"> 996                                                         UTF_8.INSTANCE))</span>
<span class="line-added"> 997             {</span>
 998                 while (hostsFileScanner.hasNextLine()) {
 999                     hostEntry = hostsFileScanner.nextLine();
1000                     if (!hostEntry.startsWith(&quot;#&quot;)) {
1001                         hostEntry = removeComments(hostEntry);
<span class="line-modified">1002                         String[] mapping = hostEntry.split(&quot;\\s+&quot;);</span>
<span class="line-modified">1003                         if (mapping.length &gt;= 2 &amp;&amp;</span>
<span class="line-modified">1004                             Arrays.equals(addr, createAddressByteArray(mapping[0]))) {</span>
<span class="line-modified">1005                             host = mapping[1];</span>
<span class="line-modified">1006                             break;</span>
1007                         }
1008                     }
1009                 }
<span class="line-modified">1010             } catch (IOException e) {</span>
1011                 throw new UnknownHostException(&quot;Unable to resolve address &quot;
<span class="line-modified">1012                         + Arrays.toString(addr) + &quot; as hosts file &quot; + hostsFile</span>
1013                         + &quot; not found &quot;);
1014             }
1015 
1016             if ((host == null) || (host.isEmpty()) || (host.equals(&quot; &quot;))) {
1017                 throw new UnknownHostException(&quot;Requested address &quot;
<span class="line-modified">1018                         + Arrays.toString(addr)</span>
1019                         + &quot; resolves to an invalid entry in hosts file &quot;
1020                         + hostsFile);
1021             }
1022             return host;
1023         }
1024 
1025         /**
1026          * &lt;p&gt;Lookup a host mapping by name. Retrieve the IP addresses
1027          * associated with a host.
1028          *
1029          * &lt;p&gt;Search the configured hosts file for the addresses associated
1030          * with the specified host name.
1031          *
1032          * @param host the specified hostname
1033          * @return array of IP addresses for the requested host
1034          * @throws UnknownHostException
1035          *             if no IP address for the {@code host} could be found
1036          */
1037         public InetAddress[] lookupAllHostAddr(String host)
1038                 throws UnknownHostException {
1039             String hostEntry;
1040             String addrStr = null;
1041             InetAddress[] res = null;
1042             byte addr[] = new byte[4];
1043             ArrayList&lt;InetAddress&gt; inetAddresses = null;
1044 
1045             // lookup the file and create a list InetAddress for the specified host
<span class="line-modified">1046             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),</span>
<span class="line-added">1047                                                         UTF_8.INSTANCE))</span>
<span class="line-added">1048             {</span>
1049                 while (hostsFileScanner.hasNextLine()) {
1050                     hostEntry = hostsFileScanner.nextLine();
1051                     if (!hostEntry.startsWith(&quot;#&quot;)) {
1052                         hostEntry = removeComments(hostEntry);
1053                         if (hostEntry.contains(host)) {
1054                             addrStr = extractHostAddr(hostEntry, host);
1055                             if ((addrStr != null) &amp;&amp; (!addrStr.isEmpty())) {
1056                                 addr = createAddressByteArray(addrStr);
1057                                 if (inetAddresses == null) {
1058                                     inetAddresses = new ArrayList&lt;&gt;(1);
1059                                 }
1060                                 if (addr != null) {
1061                                     inetAddresses.add(InetAddress.getByAddress(host, addr));
1062                                 }
1063                             }
1064                         }
1065                     }
1066                 }
<span class="line-modified">1067             } catch (IOException e) {</span>
1068                 throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
1069                         + &quot; as hosts file &quot; + hostsFile + &quot; not found &quot;);
1070             }
1071 
1072             if (inetAddresses != null) {
1073                 res = inetAddresses.toArray(new InetAddress[inetAddresses.size()]);
1074             } else {
1075                 throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
1076                         + &quot; in hosts file &quot; + hostsFile);
1077             }
1078             return res;
1079         }
1080 
1081         private String removeComments(String hostsEntry) {
1082             String filteredEntry = hostsEntry;
1083             int hashIndex;
1084 
1085             if ((hashIndex = hostsEntry.indexOf(&quot;#&quot;)) != -1) {
1086                 filteredEntry = hostsEntry.substring(0, hashIndex);
1087             }
</pre>
<hr />
<pre>
1096                 addrArray = IPAddressUtil.textToNumericFormatV6(addrStr);
1097             }
1098             return addrArray;
1099         }
1100 
1101         /** host to ip address mapping */
1102         private String extractHostAddr(String hostEntry, String host) {
1103             String[] mapping = hostEntry.split(&quot;\\s+&quot;);
1104             String hostAddr = null;
1105 
1106             if (mapping.length &gt;= 2) {
1107                 // look at the host aliases
1108                 for (int i = 1; i &lt; mapping.length; i++) {
1109                     if (mapping[i].equalsIgnoreCase(host)) {
1110                         hostAddr = mapping[0];
1111                     }
1112                 }
1113             }
1114             return hostAddr;
1115         }
















1116     }
1117 
1118     static final InetAddressImpl  impl;
1119 
1120     static {
1121         // create the impl
1122         impl = InetAddressImplFactory.create();
1123 
1124         // create name service
1125         nameService = createNameService();
1126         }
1127 
1128     /**
1129      * Create an instance of the NameService interface based on
1130      * the setting of the {@code jdk.net.hosts.file} system property.
1131      *
1132      * &lt;p&gt;The default NameService is the PlatformNameService, which typically
1133      * delegates name and address resolution calls to the underlying
1134      * OS network libraries.
1135      *
</pre>
<hr />
<pre>
1155 
1156     /**
1157      * Creates an InetAddress based on the provided host name and IP address.
1158      * No name service is checked for the validity of the address.
1159      *
1160      * &lt;p&gt; The host name can either be a machine name, such as
1161      * &quot;{@code www.example.com}&quot;, or a textual representation of its IP
1162      * address.
1163      * &lt;p&gt; No validity checking is done on the host name either.
1164      *
1165      * &lt;p&gt; If addr specifies an IPv4 address an instance of Inet4Address
1166      * will be returned; otherwise, an instance of Inet6Address
1167      * will be returned.
1168      *
1169      * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
1170      * must be 16 bytes long
1171      *
1172      * @param host the specified host
1173      * @param addr the raw IP address in network byte order
1174      * @return  an InetAddress object created from the raw IP address.
<span class="line-modified">1175      * @throws     UnknownHostException  if IP address is of illegal length</span>
1176      * @since 1.4
1177      */
1178     public static InetAddress getByAddress(String host, byte[] addr)
1179         throws UnknownHostException {
1180         if (host != null &amp;&amp; !host.isEmpty() &amp;&amp; host.charAt(0) == &#39;[&#39;) {
1181             if (host.charAt(host.length()-1) == &#39;]&#39;) {
1182                 host = host.substring(1, host.length() -1);
1183             }
1184         }
1185         if (addr != null) {
1186             if (addr.length == Inet4Address.INADDRSZ) {
1187                 return new Inet4Address(host, addr);
1188             } else if (addr.length == Inet6Address.INADDRSZ) {
1189                 byte[] newAddr
1190                     = IPAddressUtil.convertFromIPv4MappedAddress(addr);
1191                 if (newAddr != null) {
1192                     return new Inet4Address(host, newAddr);
1193                 } else {
1194                     return new Inet6Address(host, addr);
1195                 }
</pre>
<hr />
<pre>
1210      * &lt;p&gt; For {@code host} specified in literal IPv6 address,
1211      * either the form defined in RFC 2732 or the literal IPv6 address
1212      * format defined in RFC 2373 is accepted. IPv6 scoped addresses are also
1213      * supported. See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
1214      * scoped addresses.
1215      *
1216      * &lt;p&gt; If the host is {@code null} or {@code host.length()} is equal
1217      * to zero, then an {@code InetAddress} representing an address of the
1218      * loopback interface is returned.
1219      * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
1220      * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
1221      * section&amp;nbsp;2.5.3.
1222      *
1223      * &lt;p&gt; If there is a security manager, and {@code host} is not {@code null}
1224      * or {@code host.length() } is not equal to zero, the security manager&#39;s
1225      * {@code checkConnect} method is called with the hostname and {@code -1}
1226      * as its arguments to determine if the operation is allowed.
1227      *
1228      * @param      host   the specified host, or {@code null}.
1229      * @return     an IP address for the given host name.
<span class="line-modified">1230      * @throws     UnknownHostException  if no IP address for the</span>
1231      *               {@code host} could be found, or if a scope_id was specified
1232      *               for a global IPv6 address.
<span class="line-modified">1233      * @throws     SecurityException if a security manager exists</span>
1234      *             and its checkConnect method doesn&#39;t allow the operation
1235      */
1236     public static InetAddress getByName(String host)
1237         throws UnknownHostException {
1238         return InetAddress.getAllByName(host)[0];
1239     }
1240 
1241     // called from deployment cache manager
1242     private static InetAddress getByName(String host, InetAddress reqAddr)
1243         throws UnknownHostException {
1244         return InetAddress.getAllByName(host, reqAddr)[0];
1245     }
1246 
1247     /**
1248      * Given the name of a host, returns an array of its IP addresses,
1249      * based on the configured name service on the system.
1250      *
1251      * &lt;p&gt; The host name can either be a machine name, such as
1252      * &quot;{@code www.example.com}&quot;, or a textual representation of its IP
1253      * address. If a literal IP address is supplied, only the
</pre>
<hr />
<pre>
1258      * format defined in RFC 2373 is accepted. A literal IPv6 address may
1259      * also be qualified by appending a scoped zone identifier or scope_id.
1260      * The syntax and usage of scope_ids is described
1261      * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
1262      *
1263      * &lt;p&gt; If the host is {@code null} or {@code host.length()} is equal
1264      * to zero, then an {@code InetAddress} representing an address of the
1265      * loopback interface is returned.
1266      * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
1267      * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
1268      * section&amp;nbsp;2.5.3. &lt;/p&gt;
1269      *
1270      * &lt;p&gt; If there is a security manager, and {@code host} is not {@code null}
1271      * or {@code host.length() } is not equal to zero, the security manager&#39;s
1272      * {@code checkConnect} method is called with the hostname and {@code -1}
1273      * as its arguments to determine if the operation is allowed.
1274      *
1275      * @param      host   the name of the host, or {@code null}.
1276      * @return     an array of all the IP addresses for a given host name.
1277      *
<span class="line-modified">1278      * @throws     UnknownHostException  if no IP address for the</span>
1279      *               {@code host} could be found, or if a scope_id was specified
1280      *               for a global IPv6 address.
<span class="line-modified">1281      * @throws     SecurityException  if a security manager exists and its</span>
1282      *               {@code checkConnect} method doesn&#39;t allow the operation.
1283      *
1284      * @see SecurityManager#checkConnect
1285      */
1286     public static InetAddress[] getAllByName(String host)
1287         throws UnknownHostException {
1288         return getAllByName(host, null);
1289     }
1290 
1291     private static InetAddress[] getAllByName(String host, InetAddress reqAddr)
1292         throws UnknownHostException {
1293 
1294         if (host == null || host.isEmpty()) {
1295             InetAddress[] ret = new InetAddress[1];
1296             ret[0] = impl.loopbackAddress();
1297             return ret;
1298         }
1299 
1300         boolean ipv6Expected = false;
1301         if (host.charAt(0) == &#39;[&#39;) {
</pre>
<hr />
<pre>
1536                 addresses[i] = tmp2;
1537             }
1538         }
1539 
1540         return addresses;
1541     }
1542 
1543     /**
1544      * Returns an {@code InetAddress} object given the raw IP address .
1545      * The argument is in network byte order: the highest order
1546      * byte of the address is in {@code getAddress()[0]}.
1547      *
1548      * &lt;p&gt; This method doesn&#39;t block, i.e. no reverse name service lookup
1549      * is performed.
1550      *
1551      * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
1552      * must be 16 bytes long
1553      *
1554      * @param addr the raw IP address in network byte order
1555      * @return  an InetAddress object created from the raw IP address.
<span class="line-modified">1556      * @throws     UnknownHostException  if IP address is of illegal length</span>
1557      * @since 1.4
1558      */
1559     public static InetAddress getByAddress(byte[] addr)
1560         throws UnknownHostException {
1561         return getByAddress(null, addr);
1562     }
1563 
1564     private static final class CachedLocalHost {
1565         final String host;
1566         final InetAddress addr;
1567         final long expiryTime = System.nanoTime() + 5000_000_000L; // now + 5s;
1568 
1569         CachedLocalHost(String host, InetAddress addr) {
1570             this.host = host;
1571             this.addr = addr;
1572         }
1573     }
1574 
1575     private static volatile CachedLocalHost cachedLocalHost;
1576 
1577     /**
1578      * Returns the address of the local host. This is achieved by retrieving
1579      * the name of the host from the system, then resolving that name into
1580      * an {@code InetAddress}.
1581      *
1582      * &lt;P&gt;Note: The resolved address may be cached for a short period of time.
1583      * &lt;/P&gt;
1584      *
1585      * &lt;p&gt;If there is a security manager, its
1586      * {@code checkConnect} method is called
1587      * with the local host name and {@code -1}
1588      * as its arguments to see if the operation is allowed.
1589      * If the operation is not allowed, an InetAddress representing
1590      * the loopback address is returned.
1591      *
1592      * @return     the address of the local host.
1593      *
<span class="line-modified">1594      * @throws     UnknownHostException  if the local host name could not</span>
1595      *             be resolved into an address.
1596      *
1597      * @see SecurityManager#checkConnect
1598      * @see java.net.InetAddress#getByName(java.lang.String)
1599      */
1600     public static InetAddress getLocalHost() throws UnknownHostException {
1601 
1602         SecurityManager security = System.getSecurityManager();
1603         try {
1604             // is cached data still valid?
1605             CachedLocalHost clh = cachedLocalHost;
1606             if (clh != null &amp;&amp; (clh.expiryTime - System.nanoTime()) &gt;= 0L) {
1607                 if (security != null) {
1608                     security.checkConnect(clh.host, -1);
1609                 }
1610                 return clh.addr;
1611             }
1612 
1613             String local = impl.getLocalHostName();
1614 
</pre>
<hr />
<pre>
1683                                &quot;in your properties file.&quot;);
1684         } catch (IllegalAccessException e) {
1685             System.err.println(&quot;Cannot access class: java.net.&quot; + prefix +
1686                                implName + &quot;:\ncheck impl.prefix property &quot; +
1687                                &quot;in your properties file.&quot;);
1688         }
1689 
1690         if (impl == null) {
1691             try {
1692                 @SuppressWarnings(&quot;deprecation&quot;)
1693                 Object tmp = Class.forName(implName).newInstance();
1694                 impl = tmp;
1695             } catch (Exception e) {
1696                 throw new Error(&quot;System property impl.prefix incorrect&quot;);
1697             }
1698         }
1699 
1700         return (InetAddressImpl) impl;
1701     }
1702 
<span class="line-added">1703     @java.io.Serial</span>
1704     private void readObjectNoData () {
1705         if (getClass().getClassLoader() != null) {
1706             throw new SecurityException (&quot;invalid address type&quot;);
1707         }
1708     }
1709 
1710     private static final jdk.internal.misc.Unsafe UNSAFE
1711             = jdk.internal.misc.Unsafe.getUnsafe();
1712     private static final long FIELDS_OFFSET
1713             = UNSAFE.objectFieldOffset(InetAddress.class, &quot;holder&quot;);
1714 
<span class="line-added">1715     @java.io.Serial</span>
1716     private void readObject (ObjectInputStream s) throws
1717                          IOException, ClassNotFoundException {
1718         if (getClass().getClassLoader() != null) {
1719             throw new SecurityException (&quot;invalid address type&quot;);
1720         }
1721         GetField gf = s.readFields();
1722         String host = (String)gf.get(&quot;hostName&quot;, null);
1723         int address = gf.get(&quot;address&quot;, 0);
1724         int family = gf.get(&quot;family&quot;, 0);
1725         if (family != IPv4 &amp;&amp; family != IPv6) {
1726             throw new InvalidObjectException(&quot;invalid address family type: &quot; + family);
1727         }
1728         InetAddressHolder h = new InetAddressHolder(host, address, family);
1729         UNSAFE.putReference(this, FIELDS_OFFSET, h);
1730     }
1731 
1732     /* needed because the serializable fields no longer exist */
1733 
1734     /**
1735      * @serialField hostName String
1736      * @serialField address int
1737      * @serialField family int
1738      */
<span class="line-added">1739     @java.io.Serial</span>
1740     private static final ObjectStreamField[] serialPersistentFields = {
1741         new ObjectStreamField(&quot;hostName&quot;, String.class),
1742         new ObjectStreamField(&quot;address&quot;, int.class),
1743         new ObjectStreamField(&quot;family&quot;, int.class),
1744     };
1745 
<span class="line-added">1746     @java.io.Serial</span>
1747     private void writeObject (ObjectOutputStream s) throws
1748                         IOException {
1749         if (getClass().getClassLoader() != null) {
1750             throw new SecurityException (&quot;invalid address type&quot;);
1751         }
1752         PutField pf = s.putFields();
1753         pf.put(&quot;hostName&quot;, holder().getHostName());
1754         pf.put(&quot;address&quot;, holder().getAddress());
1755         pf.put(&quot;family&quot;, holder().getFamily());
1756         s.writeFields();
1757     }
1758 }
1759 
1760 /*
1761  * Simple factory to create the impl
1762  */
1763 class InetAddressImplFactory {
1764 
1765     static InetAddressImpl create() {
1766         return InetAddress.loadImpl(isIPv6Supported() ?
</pre>
</td>
</tr>
</table>
<center><a href="Inet6AddressImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InetSocketAddress.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/DateFormatSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DateFormat.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DecimalFormat.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/DateFormatSymbols.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 39 package java.text;
 40 
 41 import java.io.IOException;
 42 import java.io.ObjectOutputStream;
 43 import java.io.Serializable;
 44 import java.lang.ref.SoftReference;
 45 import java.text.spi.DateFormatSymbolsProvider;
 46 import java.util.Arrays;
 47 import java.util.Locale;
 48 import java.util.Objects;
 49 import java.util.ResourceBundle;
 50 import java.util.concurrent.ConcurrentHashMap;
 51 import java.util.concurrent.ConcurrentMap;
 52 import sun.util.locale.provider.CalendarDataUtility;
 53 import sun.util.locale.provider.LocaleProviderAdapter;
 54 import sun.util.locale.provider.LocaleServiceProviderPool;
 55 import sun.util.locale.provider.ResourceBundleBasedAdapter;
 56 import sun.util.locale.provider.TimeZoneNameUtility;
 57 
 58 /**
<span class="line-modified"> 59  * &lt;code&gt;DateFormatSymbols&lt;/code&gt; is a public class for encapsulating</span>
 60  * localizable date-time formatting data, such as the names of the
 61  * months, the names of the days of the week, and the time zone data.
<span class="line-modified"> 62  * &lt;code&gt;SimpleDateFormat&lt;/code&gt; uses</span>
<span class="line-modified"> 63  * &lt;code&gt;DateFormatSymbols&lt;/code&gt; to encapsulate this information.</span>
 64  *
 65  * &lt;p&gt;
<span class="line-modified"> 66  * Typically you shouldn&#39;t use &lt;code&gt;DateFormatSymbols&lt;/code&gt; directly.</span>
 67  * Rather, you are encouraged to create a date-time formatter with the
<span class="line-modified"> 68  * &lt;code&gt;DateFormat&lt;/code&gt; class&#39;s factory methods: &lt;code&gt;getTimeInstance&lt;/code&gt;,</span>
<span class="line-modified"> 69  * &lt;code&gt;getDateInstance&lt;/code&gt;, or &lt;code&gt;getDateTimeInstance&lt;/code&gt;.</span>
<span class="line-modified"> 70  * These methods automatically create a &lt;code&gt;DateFormatSymbols&lt;/code&gt; for</span>
 71  * the formatter so that you don&#39;t have to. After the
 72  * formatter is created, you may modify its format pattern using the
<span class="line-modified"> 73  * &lt;code&gt;setPattern&lt;/code&gt; method. For more information about</span>
<span class="line-modified"> 74  * creating formatters using &lt;code&gt;DateFormat&lt;/code&gt;&#39;s factory methods,</span>
 75  * see {@link DateFormat}.
 76  *
 77  * &lt;p&gt;
 78  * If you decide to create a date-time formatter with a specific
 79  * format pattern for a specific locale, you can do so with:
 80  * &lt;blockquote&gt;
 81  * &lt;pre&gt;
 82  * new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).
 83  * &lt;/pre&gt;
 84  * &lt;/blockquote&gt;
 85  *
 86  * &lt;p&gt;If the locale contains &quot;rg&quot; (region override)
 87  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
 88  * the symbols are overridden for the designated region.
 89  *
 90  * &lt;p&gt;
<span class="line-modified"> 91  * &lt;code&gt;DateFormatSymbols&lt;/code&gt; objects are cloneable. When you obtain</span>
<span class="line-modified"> 92  * a &lt;code&gt;DateFormatSymbols&lt;/code&gt; object, feel free to modify the</span>
 93  * date-time formatting data. For instance, you can replace the localized
 94  * date-time format pattern characters with the ones that you feel easy
 95  * to remember. Or you can change the representative cities
 96  * to your favorite ones.
 97  *
 98  * &lt;p&gt;
<span class="line-modified"> 99  * New &lt;code&gt;DateFormatSymbols&lt;/code&gt; subclasses may be added to support</span>
<span class="line-modified">100  * &lt;code&gt;SimpleDateFormat&lt;/code&gt; for date-time formatting for additional locales.</span>
101 
102  * @see          DateFormat
103  * @see          SimpleDateFormat
104  * @see          java.util.SimpleTimeZone
105  * @author       Chen-Lieh Huang
106  * @since 1.1
107  */
108 public class DateFormatSymbols implements Serializable, Cloneable {
109 
110     /**
111      * Construct a DateFormatSymbols object by loading format data from
112      * resources for the default {@link java.util.Locale.Category#FORMAT FORMAT}
113      * locale. This constructor can only
114      * construct instances for the locales supported by the Java
115      * runtime environment, not for those supported by installed
116      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
117      * implementations. For full locale coverage, use the
118      * {@link #getInstance(Locale) getInstance} method.
119      * &lt;p&gt;This is equivalent to calling
120      * {@link #DateFormatSymbols(Locale)
121      *     DateFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))}.
122      * @see #getInstance()
123      * @see java.util.Locale#getDefault(java.util.Locale.Category)
124      * @see java.util.Locale.Category#FORMAT
<span class="line-modified">125      * @exception  java.util.MissingResourceException</span>
126      *             if the resources for the default locale cannot be
127      *             found or cannot be loaded.
128      */
129     public DateFormatSymbols()
130     {
131         initializeData(Locale.getDefault(Locale.Category.FORMAT));
132     }
133 
134     /**
135      * Construct a DateFormatSymbols object by loading format data from
136      * resources for the given locale. This constructor can only
137      * construct instances for the locales supported by the Java
138      * runtime environment, not for those supported by installed
139      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
140      * implementations. For full locale coverage, use the
141      * {@link #getInstance(Locale) getInstance} method.
142      *
143      * @param locale the desired locale
144      * @see #getInstance(Locale)
<span class="line-modified">145      * @exception  java.util.MissingResourceException</span>
146      *             if the resources for the specified locale cannot be
147      *             found or cannot be loaded.
148      */
149     public DateFormatSymbols(Locale locale)
150     {
151         initializeData(locale);
152     }
153 
154     /**
155      * Constructs an uninitialized DateFormatSymbols.
156      */
157     private DateFormatSymbols(boolean flag) {
158     }
159 
160     /**
161      * Era strings. For example: &quot;AD&quot; and &quot;BC&quot;.  An array of 2 strings,
<span class="line-modified">162      * indexed by &lt;code&gt;Calendar.BC&lt;/code&gt; and &lt;code&gt;Calendar.AD&lt;/code&gt;.</span>
163      * @serial
164      */
165     String eras[] = null;
166 
167     /**
168      * Month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.  An array
169      * of 13 strings (some calendars have 13 months), indexed by
<span class="line-modified">170      * &lt;code&gt;Calendar.JANUARY&lt;/code&gt;, &lt;code&gt;Calendar.FEBRUARY&lt;/code&gt;, etc.</span>
171      * @serial
172      */
173     String months[] = null;
174 
175     /**
176      * Short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.  An array of
177      * 13 strings (some calendars have 13 months), indexed by
<span class="line-modified">178      * &lt;code&gt;Calendar.JANUARY&lt;/code&gt;, &lt;code&gt;Calendar.FEBRUARY&lt;/code&gt;, etc.</span>
179 
180      * @serial
181      */
182     String shortMonths[] = null;
183 
184     /**
185      * Weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.  An array
<span class="line-modified">186      * of 8 strings, indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,</span>
<span class="line-modified">187      * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.</span>
<span class="line-modified">188      * The element &lt;code&gt;weekdays[0]&lt;/code&gt; is ignored.</span>
189      * @serial
190      */
191     String weekdays[] = null;
192 
193     /**
194      * Short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.  An array
<span class="line-modified">195      * of 8 strings, indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,</span>
<span class="line-modified">196      * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.</span>
<span class="line-modified">197      * The element &lt;code&gt;shortWeekdays[0]&lt;/code&gt; is ignored.</span>
198      * @serial
199      */
200     String shortWeekdays[] = null;
201 
202     /**
203      * AM and PM strings. For example: &quot;AM&quot; and &quot;PM&quot;.  An array of
<span class="line-modified">204      * 2 strings, indexed by &lt;code&gt;Calendar.AM&lt;/code&gt; and</span>
<span class="line-modified">205      * &lt;code&gt;Calendar.PM&lt;/code&gt;.</span>
206      * @serial
207      */
208     String ampms[] = null;
209 
210     /**
211      * Localized names of time zones in this locale.  This is a
212      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
213      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
<span class="line-modified">214      * entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.</span>
<span class="line-modified">215      * Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from</span>
216      * 0..&lt;em&gt;n&lt;/em&gt;-1):
217      * &lt;ul&gt;
<span class="line-modified">218      * &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;</span>
<span class="line-modified">219      * &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard</span>
220      * time&lt;/li&gt;
<span class="line-modified">221      * &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in</span>
222      * standard time&lt;/li&gt;
<span class="line-modified">223      * &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight</span>
224      * saving time&lt;/li&gt;
<span class="line-modified">225      * &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight</span>
226      * saving time&lt;/li&gt;
227      * &lt;/ul&gt;
228      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
229      * the {@link java.util.TimeZone TimeZone} class that are not
230      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
231      * All other entries are localized names.
232      * @see java.util.TimeZone
233      * @serial
234      */
235     String zoneStrings[][] = null;
236 
237     /**
238      * Indicates that zoneStrings is set externally with setZoneStrings() method.
239      */
240     transient boolean isZoneStringsSet = false;
241 
242     /**
243      * Unlocalized date-time pattern characters. For example: &#39;y&#39;, &#39;d&#39;, etc.
244      * All locales use the same these unlocalized pattern characters.
245      */
</pre>
<hr />
<pre>
257     static final int PATTERN_DAY_OF_WEEK          =  9; // E
258     static final int PATTERN_DAY_OF_YEAR          = 10; // D
259     static final int PATTERN_DAY_OF_WEEK_IN_MONTH = 11; // F
260     static final int PATTERN_WEEK_OF_YEAR         = 12; // w
261     static final int PATTERN_WEEK_OF_MONTH        = 13; // W
262     static final int PATTERN_AM_PM                = 14; // a
263     static final int PATTERN_HOUR1                = 15; // h
264     static final int PATTERN_HOUR0                = 16; // K
265     static final int PATTERN_ZONE_NAME            = 17; // z
266     static final int PATTERN_ZONE_VALUE           = 18; // Z
267     static final int PATTERN_WEEK_YEAR            = 19; // Y
268     static final int PATTERN_ISO_DAY_OF_WEEK      = 20; // u
269     static final int PATTERN_ISO_ZONE             = 21; // X
270     static final int PATTERN_MONTH_STANDALONE     = 22; // L
271 
272     /**
273      * Localized date-time pattern characters. For example, a locale may
274      * wish to use &#39;u&#39; rather than &#39;y&#39; to represent years in its date format
275      * pattern strings.
276      * This string must be exactly 18 characters long, with the index of
<span class="line-modified">277      * the characters described by &lt;code&gt;DateFormat.ERA_FIELD&lt;/code&gt;,</span>
<span class="line-modified">278      * &lt;code&gt;DateFormat.YEAR_FIELD&lt;/code&gt;, etc.  Thus, if the string were</span>
279      * &quot;Xz...&quot;, then localized patterns would use &#39;X&#39; for era and &#39;z&#39; for year.
280      * @serial
281      */
282     String  localPatternChars = null;
283 
284     /**
285      * The locale which is used for initializing this DateFormatSymbols object.
286      *
287      * @since 1.6
288      * @serial
289      */
290     Locale locale = null;
291 
292     /* use serialVersionUID from JDK 1.1.4 for interoperability */

293     static final long serialVersionUID = -5987973545549424702L;
294 
295     /**
296      * Returns an array of all locales for which the
<span class="line-modified">297      * &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return</span>
298      * localized instances.
299      * The returned array represents the union of locales supported by the
300      * Java runtime and by installed
301      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
<span class="line-modified">302      * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
303      * instance equal to {@link java.util.Locale#US Locale.US}.
304      *
305      * @return An array of locales for which localized
<span class="line-modified">306      *         &lt;code&gt;DateFormatSymbols&lt;/code&gt; instances are available.</span>
307      * @since 1.6
308      */
309     public static Locale[] getAvailableLocales() {
310         LocaleServiceProviderPool pool=
311             LocaleServiceProviderPool.getPool(DateFormatSymbolsProvider.class);
312         return pool.getAvailableLocales();
313     }
314 
315     /**
<span class="line-modified">316      * Gets the &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the default</span>
<span class="line-modified">317      * locale.  This method provides access to &lt;code&gt;DateFormatSymbols&lt;/code&gt;</span>
318      * instances for locales supported by the Java runtime itself as well
319      * as for those supported by installed
320      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
321      * implementations.
322      * &lt;p&gt;This is equivalent to calling {@link #getInstance(Locale)
323      *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
324      * @see java.util.Locale#getDefault(java.util.Locale.Category)
325      * @see java.util.Locale.Category#FORMAT
<span class="line-modified">326      * @return a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.</span>
327      * @since 1.6
328      */
329     public static final DateFormatSymbols getInstance() {
330         return getInstance(Locale.getDefault(Locale.Category.FORMAT));
331     }
332 
333     /**
<span class="line-modified">334      * Gets the &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the specified</span>
<span class="line-modified">335      * locale.  This method provides access to &lt;code&gt;DateFormatSymbols&lt;/code&gt;</span>
336      * instances for locales supported by the Java runtime itself as well
337      * as for those supported by installed
338      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
339      * implementations.
340      * @param locale the given locale.
<span class="line-modified">341      * @return a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.</span>
<span class="line-modified">342      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
343      * @since 1.6
344      */
345     public static final DateFormatSymbols getInstance(Locale locale) {
346         DateFormatSymbols dfs = getProviderInstance(locale);
347         if (dfs != null) {
348             return dfs;
349         }
350         throw new RuntimeException(&quot;DateFormatSymbols instance creation failed.&quot;);
351     }
352 
353     /**
354      * Returns a DateFormatSymbols provided by a provider or found in
355      * the cache. Note that this method returns a cached instance,
356      * not its clone. Therefore, the instance should never be given to
357      * an application.
358      */
359     static final DateFormatSymbols getInstanceRef(Locale locale) {
360         DateFormatSymbols dfs = getProviderInstance(locale);
361         if (dfs != null) {
362             return dfs;
</pre>
<hr />
<pre>
520         return Arrays.copyOf(ampms, ampms.length);
521     }
522 
523     /**
524      * Sets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.
525      * @param newAmpms the new ampm strings.
526      */
527     public void setAmPmStrings(String[] newAmpms) {
528         ampms = Arrays.copyOf(newAmpms, newAmpms.length);
529         cachedHashCode = 0;
530     }
531 
532     /**
533      * Gets time zone strings.  Use of this method is discouraged; use
534      * {@link java.util.TimeZone#getDisplayName() TimeZone.getDisplayName()}
535      * instead.
536      * &lt;p&gt;
537      * The value returned is a
538      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
539      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
<span class="line-modified">540      * entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.</span>
<span class="line-modified">541      * Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from</span>
542      * 0..&lt;em&gt;n&lt;/em&gt;-1):
543      * &lt;ul&gt;
<span class="line-modified">544      * &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;</span>
<span class="line-modified">545      * &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard</span>
546      * time&lt;/li&gt;
<span class="line-modified">547      * &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in</span>
548      * standard time&lt;/li&gt;
<span class="line-modified">549      * &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight</span>
550      * saving time&lt;/li&gt;
<span class="line-modified">551      * &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight</span>
552      * saving time&lt;/li&gt;
553      * &lt;/ul&gt;
554      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
555      * the {@link java.util.TimeZone TimeZone} class that are not
556      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
557      * All other entries are localized names.  If a zone does not implement
558      * daylight saving time, the daylight saving time names should not be used.
559      * &lt;p&gt;
560      * If {@link #setZoneStrings(String[][]) setZoneStrings} has been called
<span class="line-modified">561      * on this &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance, then the strings</span>
562      * provided by that call are returned. Otherwise, the returned array
563      * contains names provided by the Java runtime and by installed
564      * {@link java.util.spi.TimeZoneNameProvider TimeZoneNameProvider}
565      * implementations.
566      *
567      * @return the time zone strings.
568      * @see #setZoneStrings(String[][])
569      */
570     public String[][] getZoneStrings() {
571         return getZoneStringsImpl(true);
572     }
573 
574     /**
575      * Sets time zone strings.  The argument must be a
576      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
577      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
<span class="line-modified">578      * entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.</span>
<span class="line-modified">579      * Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from</span>
580      * 0..&lt;em&gt;n&lt;/em&gt;-1):
581      * &lt;ul&gt;
<span class="line-modified">582      * &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;</span>
<span class="line-modified">583      * &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard</span>
584      * time&lt;/li&gt;
<span class="line-modified">585      * &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in</span>
586      * standard time&lt;/li&gt;
<span class="line-modified">587      * &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight</span>
588      * saving time&lt;/li&gt;
<span class="line-modified">589      * &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight</span>
590      * saving time&lt;/li&gt;
591      * &lt;/ul&gt;
592      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
593      * the {@link java.util.TimeZone TimeZone} class that are not
594      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
595      * All other entries are localized names.
596      *
597      * @param newZoneStrings the new time zone strings.
<span class="line-modified">598      * @exception IllegalArgumentException if the length of any row in</span>
<span class="line-modified">599      *    &lt;code&gt;newZoneStrings&lt;/code&gt; is less than 5</span>
<span class="line-modified">600      * @exception NullPointerException if &lt;code&gt;newZoneStrings&lt;/code&gt; is null</span>
601      * @see #getZoneStrings()
602      */
603     public void setZoneStrings(String[][] newZoneStrings) {
604         String[][] aCopy = new String[newZoneStrings.length][];
605         for (int i = 0; i &lt; newZoneStrings.length; ++i) {
606             int len = newZoneStrings[i].length;
607             if (len &lt; 5) {
608                 throw new IllegalArgumentException();
609             }
610             aCopy[i] = Arrays.copyOf(newZoneStrings[i], len);
611         }
612         zoneStrings = aCopy;
613         isZoneStringsSet = true;
614         cachedHashCode = 0;
615     }
616 
617     /**
618      * Gets localized date-time pattern characters. For example: &#39;u&#39;, &#39;t&#39;, etc.
619      * @return the localized date-time pattern characters.
620      */
</pre>
<hr />
<pre>
870     private void copyMembers(DateFormatSymbols src, DateFormatSymbols dst)
871     {
872         dst.locale = src.locale;
873         dst.eras = Arrays.copyOf(src.eras, src.eras.length);
874         dst.months = Arrays.copyOf(src.months, src.months.length);
875         dst.shortMonths = Arrays.copyOf(src.shortMonths, src.shortMonths.length);
876         dst.weekdays = Arrays.copyOf(src.weekdays, src.weekdays.length);
877         dst.shortWeekdays = Arrays.copyOf(src.shortWeekdays, src.shortWeekdays.length);
878         dst.ampms = Arrays.copyOf(src.ampms, src.ampms.length);
879         if (src.zoneStrings != null) {
880             dst.zoneStrings = src.getZoneStringsImpl(true);
881         } else {
882             dst.zoneStrings = null;
883         }
884         dst.localPatternChars = src.localPatternChars;
885         dst.cachedHashCode = 0;
886     }
887 
888     /**
889      * Write out the default serializable data, after ensuring the
<span class="line-modified">890      * &lt;code&gt;zoneStrings&lt;/code&gt; field is initialized in order to make</span>
891      * sure the backward compatibility.
892      *
893      * @since 1.6
894      */

895     private void writeObject(ObjectOutputStream stream) throws IOException {
896         if (zoneStrings == null) {
897             zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
898         }
899         stream.defaultWriteObject();
900     }
901 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 39 package java.text;
 40 
 41 import java.io.IOException;
 42 import java.io.ObjectOutputStream;
 43 import java.io.Serializable;
 44 import java.lang.ref.SoftReference;
 45 import java.text.spi.DateFormatSymbolsProvider;
 46 import java.util.Arrays;
 47 import java.util.Locale;
 48 import java.util.Objects;
 49 import java.util.ResourceBundle;
 50 import java.util.concurrent.ConcurrentHashMap;
 51 import java.util.concurrent.ConcurrentMap;
 52 import sun.util.locale.provider.CalendarDataUtility;
 53 import sun.util.locale.provider.LocaleProviderAdapter;
 54 import sun.util.locale.provider.LocaleServiceProviderPool;
 55 import sun.util.locale.provider.ResourceBundleBasedAdapter;
 56 import sun.util.locale.provider.TimeZoneNameUtility;
 57 
 58 /**
<span class="line-modified"> 59  * {@code DateFormatSymbols} is a public class for encapsulating</span>
 60  * localizable date-time formatting data, such as the names of the
 61  * months, the names of the days of the week, and the time zone data.
<span class="line-modified"> 62  * {@code SimpleDateFormat} uses</span>
<span class="line-modified"> 63  * {@code DateFormatSymbols} to encapsulate this information.</span>
 64  *
 65  * &lt;p&gt;
<span class="line-modified"> 66  * Typically you shouldn&#39;t use {@code DateFormatSymbols} directly.</span>
 67  * Rather, you are encouraged to create a date-time formatter with the
<span class="line-modified"> 68  * {@code DateFormat} class&#39;s factory methods: {@code getTimeInstance},</span>
<span class="line-modified"> 69  * {@code getDateInstance}, or {@code getDateTimeInstance}.</span>
<span class="line-modified"> 70  * These methods automatically create a {@code DateFormatSymbols} for</span>
 71  * the formatter so that you don&#39;t have to. After the
 72  * formatter is created, you may modify its format pattern using the
<span class="line-modified"> 73  * {@code setPattern} method. For more information about</span>
<span class="line-modified"> 74  * creating formatters using {@code DateFormat}&#39;s factory methods,</span>
 75  * see {@link DateFormat}.
 76  *
 77  * &lt;p&gt;
 78  * If you decide to create a date-time formatter with a specific
 79  * format pattern for a specific locale, you can do so with:
 80  * &lt;blockquote&gt;
 81  * &lt;pre&gt;
 82  * new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).
 83  * &lt;/pre&gt;
 84  * &lt;/blockquote&gt;
 85  *
 86  * &lt;p&gt;If the locale contains &quot;rg&quot; (region override)
 87  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
 88  * the symbols are overridden for the designated region.
 89  *
 90  * &lt;p&gt;
<span class="line-modified"> 91  * {@code DateFormatSymbols} objects are cloneable. When you obtain</span>
<span class="line-modified"> 92  * a {@code DateFormatSymbols} object, feel free to modify the</span>
 93  * date-time formatting data. For instance, you can replace the localized
 94  * date-time format pattern characters with the ones that you feel easy
 95  * to remember. Or you can change the representative cities
 96  * to your favorite ones.
 97  *
 98  * &lt;p&gt;
<span class="line-modified"> 99  * New {@code DateFormatSymbols} subclasses may be added to support</span>
<span class="line-modified">100  * {@code SimpleDateFormat} for date-time formatting for additional locales.</span>
101 
102  * @see          DateFormat
103  * @see          SimpleDateFormat
104  * @see          java.util.SimpleTimeZone
105  * @author       Chen-Lieh Huang
106  * @since 1.1
107  */
108 public class DateFormatSymbols implements Serializable, Cloneable {
109 
110     /**
111      * Construct a DateFormatSymbols object by loading format data from
112      * resources for the default {@link java.util.Locale.Category#FORMAT FORMAT}
113      * locale. This constructor can only
114      * construct instances for the locales supported by the Java
115      * runtime environment, not for those supported by installed
116      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
117      * implementations. For full locale coverage, use the
118      * {@link #getInstance(Locale) getInstance} method.
119      * &lt;p&gt;This is equivalent to calling
120      * {@link #DateFormatSymbols(Locale)
121      *     DateFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))}.
122      * @see #getInstance()
123      * @see java.util.Locale#getDefault(java.util.Locale.Category)
124      * @see java.util.Locale.Category#FORMAT
<span class="line-modified">125      * @throws     java.util.MissingResourceException</span>
126      *             if the resources for the default locale cannot be
127      *             found or cannot be loaded.
128      */
129     public DateFormatSymbols()
130     {
131         initializeData(Locale.getDefault(Locale.Category.FORMAT));
132     }
133 
134     /**
135      * Construct a DateFormatSymbols object by loading format data from
136      * resources for the given locale. This constructor can only
137      * construct instances for the locales supported by the Java
138      * runtime environment, not for those supported by installed
139      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
140      * implementations. For full locale coverage, use the
141      * {@link #getInstance(Locale) getInstance} method.
142      *
143      * @param locale the desired locale
144      * @see #getInstance(Locale)
<span class="line-modified">145      * @throws     java.util.MissingResourceException</span>
146      *             if the resources for the specified locale cannot be
147      *             found or cannot be loaded.
148      */
149     public DateFormatSymbols(Locale locale)
150     {
151         initializeData(locale);
152     }
153 
154     /**
155      * Constructs an uninitialized DateFormatSymbols.
156      */
157     private DateFormatSymbols(boolean flag) {
158     }
159 
160     /**
161      * Era strings. For example: &quot;AD&quot; and &quot;BC&quot;.  An array of 2 strings,
<span class="line-modified">162      * indexed by {@code Calendar.BC} and {@code Calendar.AD}.</span>
163      * @serial
164      */
165     String eras[] = null;
166 
167     /**
168      * Month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.  An array
169      * of 13 strings (some calendars have 13 months), indexed by
<span class="line-modified">170      * {@code Calendar.JANUARY}, {@code Calendar.FEBRUARY}, etc.</span>
171      * @serial
172      */
173     String months[] = null;
174 
175     /**
176      * Short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.  An array of
177      * 13 strings (some calendars have 13 months), indexed by
<span class="line-modified">178      * {@code Calendar.JANUARY}, {@code Calendar.FEBRUARY}, etc.</span>
179 
180      * @serial
181      */
182     String shortMonths[] = null;
183 
184     /**
185      * Weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.  An array
<span class="line-modified">186      * of 8 strings, indexed by {@code Calendar.SUNDAY},</span>
<span class="line-modified">187      * {@code Calendar.MONDAY}, etc.</span>
<span class="line-modified">188      * The element {@code weekdays[0]} is ignored.</span>
189      * @serial
190      */
191     String weekdays[] = null;
192 
193     /**
194      * Short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.  An array
<span class="line-modified">195      * of 8 strings, indexed by {@code Calendar.SUNDAY},</span>
<span class="line-modified">196      * {@code Calendar.MONDAY}, etc.</span>
<span class="line-modified">197      * The element {@code shortWeekdays[0]} is ignored.</span>
198      * @serial
199      */
200     String shortWeekdays[] = null;
201 
202     /**
203      * AM and PM strings. For example: &quot;AM&quot; and &quot;PM&quot;.  An array of
<span class="line-modified">204      * 2 strings, indexed by {@code Calendar.AM} and</span>
<span class="line-modified">205      * {@code Calendar.PM}.</span>
206      * @serial
207      */
208     String ampms[] = null;
209 
210     /**
211      * Localized names of time zones in this locale.  This is a
212      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
213      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
<span class="line-modified">214      * entry containing the localized names for a single {@code TimeZone}.</span>
<span class="line-modified">215      * Each such row contains (with {@code i} ranging from</span>
216      * 0..&lt;em&gt;n&lt;/em&gt;-1):
217      * &lt;ul&gt;
<span class="line-modified">218      * &lt;li&gt;{@code zoneStrings[i][0]} - time zone ID&lt;/li&gt;</span>
<span class="line-modified">219      * &lt;li&gt;{@code zoneStrings[i][1]} - long name of zone in standard</span>
220      * time&lt;/li&gt;
<span class="line-modified">221      * &lt;li&gt;{@code zoneStrings[i][2]} - short name of zone in</span>
222      * standard time&lt;/li&gt;
<span class="line-modified">223      * &lt;li&gt;{@code zoneStrings[i][3]} - long name of zone in daylight</span>
224      * saving time&lt;/li&gt;
<span class="line-modified">225      * &lt;li&gt;{@code zoneStrings[i][4]} - short name of zone in daylight</span>
226      * saving time&lt;/li&gt;
227      * &lt;/ul&gt;
228      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
229      * the {@link java.util.TimeZone TimeZone} class that are not
230      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
231      * All other entries are localized names.
232      * @see java.util.TimeZone
233      * @serial
234      */
235     String zoneStrings[][] = null;
236 
237     /**
238      * Indicates that zoneStrings is set externally with setZoneStrings() method.
239      */
240     transient boolean isZoneStringsSet = false;
241 
242     /**
243      * Unlocalized date-time pattern characters. For example: &#39;y&#39;, &#39;d&#39;, etc.
244      * All locales use the same these unlocalized pattern characters.
245      */
</pre>
<hr />
<pre>
257     static final int PATTERN_DAY_OF_WEEK          =  9; // E
258     static final int PATTERN_DAY_OF_YEAR          = 10; // D
259     static final int PATTERN_DAY_OF_WEEK_IN_MONTH = 11; // F
260     static final int PATTERN_WEEK_OF_YEAR         = 12; // w
261     static final int PATTERN_WEEK_OF_MONTH        = 13; // W
262     static final int PATTERN_AM_PM                = 14; // a
263     static final int PATTERN_HOUR1                = 15; // h
264     static final int PATTERN_HOUR0                = 16; // K
265     static final int PATTERN_ZONE_NAME            = 17; // z
266     static final int PATTERN_ZONE_VALUE           = 18; // Z
267     static final int PATTERN_WEEK_YEAR            = 19; // Y
268     static final int PATTERN_ISO_DAY_OF_WEEK      = 20; // u
269     static final int PATTERN_ISO_ZONE             = 21; // X
270     static final int PATTERN_MONTH_STANDALONE     = 22; // L
271 
272     /**
273      * Localized date-time pattern characters. For example, a locale may
274      * wish to use &#39;u&#39; rather than &#39;y&#39; to represent years in its date format
275      * pattern strings.
276      * This string must be exactly 18 characters long, with the index of
<span class="line-modified">277      * the characters described by {@code DateFormat.ERA_FIELD},</span>
<span class="line-modified">278      * {@code DateFormat.YEAR_FIELD}, etc.  Thus, if the string were</span>
279      * &quot;Xz...&quot;, then localized patterns would use &#39;X&#39; for era and &#39;z&#39; for year.
280      * @serial
281      */
282     String  localPatternChars = null;
283 
284     /**
285      * The locale which is used for initializing this DateFormatSymbols object.
286      *
287      * @since 1.6
288      * @serial
289      */
290     Locale locale = null;
291 
292     /* use serialVersionUID from JDK 1.1.4 for interoperability */
<span class="line-added">293     @java.io.Serial</span>
294     static final long serialVersionUID = -5987973545549424702L;
295 
296     /**
297      * Returns an array of all locales for which the
<span class="line-modified">298      * {@code getInstance} methods of this class can return</span>
299      * localized instances.
300      * The returned array represents the union of locales supported by the
301      * Java runtime and by installed
302      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
<span class="line-modified">303      * implementations.  It must contain at least a {@code Locale}</span>
304      * instance equal to {@link java.util.Locale#US Locale.US}.
305      *
306      * @return An array of locales for which localized
<span class="line-modified">307      *         {@code DateFormatSymbols} instances are available.</span>
308      * @since 1.6
309      */
310     public static Locale[] getAvailableLocales() {
311         LocaleServiceProviderPool pool=
312             LocaleServiceProviderPool.getPool(DateFormatSymbolsProvider.class);
313         return pool.getAvailableLocales();
314     }
315 
316     /**
<span class="line-modified">317      * Gets the {@code DateFormatSymbols} instance for the default</span>
<span class="line-modified">318      * locale.  This method provides access to {@code DateFormatSymbols}</span>
319      * instances for locales supported by the Java runtime itself as well
320      * as for those supported by installed
321      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
322      * implementations.
323      * &lt;p&gt;This is equivalent to calling {@link #getInstance(Locale)
324      *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
325      * @see java.util.Locale#getDefault(java.util.Locale.Category)
326      * @see java.util.Locale.Category#FORMAT
<span class="line-modified">327      * @return a {@code DateFormatSymbols} instance.</span>
328      * @since 1.6
329      */
330     public static final DateFormatSymbols getInstance() {
331         return getInstance(Locale.getDefault(Locale.Category.FORMAT));
332     }
333 
334     /**
<span class="line-modified">335      * Gets the {@code DateFormatSymbols} instance for the specified</span>
<span class="line-modified">336      * locale.  This method provides access to {@code DateFormatSymbols}</span>
337      * instances for locales supported by the Java runtime itself as well
338      * as for those supported by installed
339      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
340      * implementations.
341      * @param locale the given locale.
<span class="line-modified">342      * @return a {@code DateFormatSymbols} instance.</span>
<span class="line-modified">343      * @throws    NullPointerException if {@code locale} is null</span>
344      * @since 1.6
345      */
346     public static final DateFormatSymbols getInstance(Locale locale) {
347         DateFormatSymbols dfs = getProviderInstance(locale);
348         if (dfs != null) {
349             return dfs;
350         }
351         throw new RuntimeException(&quot;DateFormatSymbols instance creation failed.&quot;);
352     }
353 
354     /**
355      * Returns a DateFormatSymbols provided by a provider or found in
356      * the cache. Note that this method returns a cached instance,
357      * not its clone. Therefore, the instance should never be given to
358      * an application.
359      */
360     static final DateFormatSymbols getInstanceRef(Locale locale) {
361         DateFormatSymbols dfs = getProviderInstance(locale);
362         if (dfs != null) {
363             return dfs;
</pre>
<hr />
<pre>
521         return Arrays.copyOf(ampms, ampms.length);
522     }
523 
524     /**
525      * Sets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.
526      * @param newAmpms the new ampm strings.
527      */
528     public void setAmPmStrings(String[] newAmpms) {
529         ampms = Arrays.copyOf(newAmpms, newAmpms.length);
530         cachedHashCode = 0;
531     }
532 
533     /**
534      * Gets time zone strings.  Use of this method is discouraged; use
535      * {@link java.util.TimeZone#getDisplayName() TimeZone.getDisplayName()}
536      * instead.
537      * &lt;p&gt;
538      * The value returned is a
539      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
540      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
<span class="line-modified">541      * entry containing the localized names for a single {@code TimeZone}.</span>
<span class="line-modified">542      * Each such row contains (with {@code i} ranging from</span>
543      * 0..&lt;em&gt;n&lt;/em&gt;-1):
544      * &lt;ul&gt;
<span class="line-modified">545      * &lt;li&gt;{@code zoneStrings[i][0]} - time zone ID&lt;/li&gt;</span>
<span class="line-modified">546      * &lt;li&gt;{@code zoneStrings[i][1]} - long name of zone in standard</span>
547      * time&lt;/li&gt;
<span class="line-modified">548      * &lt;li&gt;{@code zoneStrings[i][2]} - short name of zone in</span>
549      * standard time&lt;/li&gt;
<span class="line-modified">550      * &lt;li&gt;{@code zoneStrings[i][3]} - long name of zone in daylight</span>
551      * saving time&lt;/li&gt;
<span class="line-modified">552      * &lt;li&gt;{@code zoneStrings[i][4]} - short name of zone in daylight</span>
553      * saving time&lt;/li&gt;
554      * &lt;/ul&gt;
555      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
556      * the {@link java.util.TimeZone TimeZone} class that are not
557      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
558      * All other entries are localized names.  If a zone does not implement
559      * daylight saving time, the daylight saving time names should not be used.
560      * &lt;p&gt;
561      * If {@link #setZoneStrings(String[][]) setZoneStrings} has been called
<span class="line-modified">562      * on this {@code DateFormatSymbols} instance, then the strings</span>
563      * provided by that call are returned. Otherwise, the returned array
564      * contains names provided by the Java runtime and by installed
565      * {@link java.util.spi.TimeZoneNameProvider TimeZoneNameProvider}
566      * implementations.
567      *
568      * @return the time zone strings.
569      * @see #setZoneStrings(String[][])
570      */
571     public String[][] getZoneStrings() {
572         return getZoneStringsImpl(true);
573     }
574 
575     /**
576      * Sets time zone strings.  The argument must be a
577      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
578      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
<span class="line-modified">579      * entry containing the localized names for a single {@code TimeZone}.</span>
<span class="line-modified">580      * Each such row contains (with {@code i} ranging from</span>
581      * 0..&lt;em&gt;n&lt;/em&gt;-1):
582      * &lt;ul&gt;
<span class="line-modified">583      * &lt;li&gt;{@code zoneStrings[i][0]} - time zone ID&lt;/li&gt;</span>
<span class="line-modified">584      * &lt;li&gt;{@code zoneStrings[i][1]} - long name of zone in standard</span>
585      * time&lt;/li&gt;
<span class="line-modified">586      * &lt;li&gt;{@code zoneStrings[i][2]} - short name of zone in</span>
587      * standard time&lt;/li&gt;
<span class="line-modified">588      * &lt;li&gt;{@code zoneStrings[i][3]} - long name of zone in daylight</span>
589      * saving time&lt;/li&gt;
<span class="line-modified">590      * &lt;li&gt;{@code zoneStrings[i][4]} - short name of zone in daylight</span>
591      * saving time&lt;/li&gt;
592      * &lt;/ul&gt;
593      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
594      * the {@link java.util.TimeZone TimeZone} class that are not
595      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
596      * All other entries are localized names.
597      *
598      * @param newZoneStrings the new time zone strings.
<span class="line-modified">599      * @throws    IllegalArgumentException if the length of any row in</span>
<span class="line-modified">600      *    {@code newZoneStrings} is less than 5</span>
<span class="line-modified">601      * @throws    NullPointerException if {@code newZoneStrings} is null</span>
602      * @see #getZoneStrings()
603      */
604     public void setZoneStrings(String[][] newZoneStrings) {
605         String[][] aCopy = new String[newZoneStrings.length][];
606         for (int i = 0; i &lt; newZoneStrings.length; ++i) {
607             int len = newZoneStrings[i].length;
608             if (len &lt; 5) {
609                 throw new IllegalArgumentException();
610             }
611             aCopy[i] = Arrays.copyOf(newZoneStrings[i], len);
612         }
613         zoneStrings = aCopy;
614         isZoneStringsSet = true;
615         cachedHashCode = 0;
616     }
617 
618     /**
619      * Gets localized date-time pattern characters. For example: &#39;u&#39;, &#39;t&#39;, etc.
620      * @return the localized date-time pattern characters.
621      */
</pre>
<hr />
<pre>
871     private void copyMembers(DateFormatSymbols src, DateFormatSymbols dst)
872     {
873         dst.locale = src.locale;
874         dst.eras = Arrays.copyOf(src.eras, src.eras.length);
875         dst.months = Arrays.copyOf(src.months, src.months.length);
876         dst.shortMonths = Arrays.copyOf(src.shortMonths, src.shortMonths.length);
877         dst.weekdays = Arrays.copyOf(src.weekdays, src.weekdays.length);
878         dst.shortWeekdays = Arrays.copyOf(src.shortWeekdays, src.shortWeekdays.length);
879         dst.ampms = Arrays.copyOf(src.ampms, src.ampms.length);
880         if (src.zoneStrings != null) {
881             dst.zoneStrings = src.getZoneStringsImpl(true);
882         } else {
883             dst.zoneStrings = null;
884         }
885         dst.localPatternChars = src.localPatternChars;
886         dst.cachedHashCode = 0;
887     }
888 
889     /**
890      * Write out the default serializable data, after ensuring the
<span class="line-modified">891      * {@code zoneStrings} field is initialized in order to make</span>
892      * sure the backward compatibility.
893      *
894      * @since 1.6
895      */
<span class="line-added">896     @java.io.Serial</span>
897     private void writeObject(ObjectOutputStream stream) throws IOException {
898         if (zoneStrings == null) {
899             zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
900         }
901         stream.defaultWriteObject();
902     }
903 }
</pre>
</td>
</tr>
</table>
<center><a href="DateFormat.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DecimalFormat.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
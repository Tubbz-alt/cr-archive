diff a/src/java.base/share/classes/java/text/BreakIterator.java b/src/java.base/share/classes/java/text/BreakIterator.java
--- a/src/java.base/share/classes/java/text/BreakIterator.java
+++ b/src/java.base/share/classes/java/text/BreakIterator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -46,27 +46,27 @@
 import sun.util.locale.provider.LocaleProviderAdapter;
 import sun.util.locale.provider.LocaleServiceProviderPool;
 
 
 /**
- * The <code>BreakIterator</code> class implements methods for finding
- * the location of boundaries in text. Instances of <code>BreakIterator</code>
+ * The {@code BreakIterator} class implements methods for finding
+ * the location of boundaries in text. Instances of {@code BreakIterator}
  * maintain a current position and scan over text
  * returning the index of characters where boundaries occur.
- * Internally, <code>BreakIterator</code> scans text using a
- * <code>CharacterIterator</code>, and is thus able to scan text held
- * by any object implementing that protocol. A <code>StringCharacterIterator</code>
- * is used to scan <code>String</code> objects passed to <code>setText</code>.
+ * Internally, {@code BreakIterator} scans text using a
+ * {@code CharacterIterator}, and is thus able to scan text held
+ * by any object implementing that protocol. A {@code StringCharacterIterator}
+ * is used to scan {@code String} objects passed to {@code setText}.
  *
  * <p>
  * You use the factory methods provided by this class to create
  * instances of various types of break iterators. In particular,
- * use <code>getWordInstance</code>, <code>getLineInstance</code>,
- * <code>getSentenceInstance</code>, and <code>getCharacterInstance</code>
- * to create <code>BreakIterator</code>s that perform
+ * use {@code getWordInstance}, {@code getLineInstance},
+ * {@code getSentenceInstance}, and {@code getCharacterInstance}
+ * to create {@code BreakIterator}s that perform
  * word, line, sentence, and character boundary analysis respectively.
- * A single <code>BreakIterator</code> can work only on one unit
+ * A single {@code BreakIterator} can work only on one unit
  * (word, line, sentence, and so on). You must use a different iterator
  * for each unit boundary analysis you wish to perform.
  *
  * <p><a id="line"></a>
  * Line boundary analysis determines where a text string can be
@@ -98,11 +98,11 @@
  * For example, an accented character might be stored as a base character
  * and a diacritical mark. What users consider to be a character can
  * differ between languages.
  *
  * <p>
- * The <code>BreakIterator</code> instances returned by the factory methods
+ * The {@code BreakIterator} instances returned by the factory methods
  * of this class are intended for use with natural languages only, not for
  * programming language text. It is however possible to define subclasses
  * that tokenize a programming language.
  *
  * <P>
@@ -272,80 +272,80 @@
     public abstract int last();
 
     /**
      * Returns the nth boundary from the current boundary. If either
      * the first or last text boundary has been reached, it returns
-     * <code>BreakIterator.DONE</code> and the current position is set to either
+     * {@code BreakIterator.DONE} and the current position is set to either
      * the first or last text boundary depending on which one is reached. Otherwise,
      * the iterator's current position is set to the new boundary.
      * For example, if the iterator's current position is the mth text boundary
      * and three more boundaries exist from the current boundary to the last text
      * boundary, the next(2) call will return m + 2. The new text position is set
      * to the (m + 2)th text boundary. A next(4) call would return
-     * <code>BreakIterator.DONE</code> and the last text boundary would become the
+     * {@code BreakIterator.DONE} and the last text boundary would become the
      * new text position.
      * @param n which boundary to return.  A value of 0
      * does nothing.  Negative values move to previous boundaries
      * and positive values move to later boundaries.
      * @return The character index of the nth boundary from the current position
-     * or <code>BreakIterator.DONE</code> if either first or last text boundary
+     * or {@code BreakIterator.DONE} if either first or last text boundary
      * has been reached.
      */
     public abstract int next(int n);
 
     /**
      * Returns the boundary following the current boundary. If the current boundary
-     * is the last text boundary, it returns <code>BreakIterator.DONE</code> and
+     * is the last text boundary, it returns {@code BreakIterator.DONE} and
      * the iterator's current position is unchanged. Otherwise, the iterator's
      * current position is set to the boundary following the current boundary.
      * @return The character index of the next text boundary or
-     * <code>BreakIterator.DONE</code> if the current boundary is the last text
+     * {@code BreakIterator.DONE} if the current boundary is the last text
      * boundary.
      * Equivalent to next(1).
      * @see #next(int)
      */
     public abstract int next();
 
     /**
      * Returns the boundary preceding the current boundary. If the current boundary
-     * is the first text boundary, it returns <code>BreakIterator.DONE</code> and
+     * is the first text boundary, it returns {@code BreakIterator.DONE} and
      * the iterator's current position is unchanged. Otherwise, the iterator's
      * current position is set to the boundary preceding the current boundary.
      * @return The character index of the previous text boundary or
-     * <code>BreakIterator.DONE</code> if the current boundary is the first text
+     * {@code BreakIterator.DONE} if the current boundary is the first text
      * boundary.
      */
     public abstract int previous();
 
     /**
      * Returns the first boundary following the specified character offset. If the
      * specified offset equals to the last text boundary, it returns
-     * <code>BreakIterator.DONE</code> and the iterator's current position is unchanged.
+     * {@code BreakIterator.DONE} and the iterator's current position is unchanged.
      * Otherwise, the iterator's current position is set to the returned boundary.
      * The value returned is always greater than the offset or the value
-     * <code>BreakIterator.DONE</code>.
+     * {@code BreakIterator.DONE}.
      * @param offset the character offset to begin scanning.
      * @return The first boundary after the specified offset or
-     * <code>BreakIterator.DONE</code> if the last text boundary is passed in
+     * {@code BreakIterator.DONE} if the last text boundary is passed in
      * as the offset.
-     * @exception  IllegalArgumentException if the specified offset is less than
+     * @throws     IllegalArgumentException if the specified offset is less than
      * the first text boundary or greater than the last text boundary.
      */
     public abstract int following(int offset);
 
     /**
      * Returns the last boundary preceding the specified character offset. If the
      * specified offset equals to the first text boundary, it returns
-     * <code>BreakIterator.DONE</code> and the iterator's current position is unchanged.
+     * {@code BreakIterator.DONE} and the iterator's current position is unchanged.
      * Otherwise, the iterator's current position is set to the returned boundary.
      * The value returned is always less than the offset or the value
-     * <code>BreakIterator.DONE</code>.
+     * {@code BreakIterator.DONE}.
      * @param offset the character offset to begin scanning.
      * @return The last boundary before the specified offset or
-     * <code>BreakIterator.DONE</code> if the first text boundary is passed in
+     * {@code BreakIterator.DONE} if the first text boundary is passed in
      * as the offset.
-     * @exception   IllegalArgumentException if the specified offset is less than
+     * @throws      IllegalArgumentException if the specified offset is less than
      * the first text boundary or greater than the last text boundary.
      * @since 1.2
      */
     public int preceding(int offset) {
         // NOTE:  This implementation is here solely because we can't add new
@@ -359,13 +359,13 @@
     }
 
     /**
      * Returns true if the specified character offset is a text boundary.
      * @param offset the character offset to check.
-     * @return <code>true</code> if "offset" is a boundary position,
-     * <code>false</code> otherwise.
-     * @exception   IllegalArgumentException if the specified offset is less than
+     * @return {@code true} if "offset" is a boundary position,
+     * {@code false} otherwise.
+     * @throws      IllegalArgumentException if the specified offset is less than
      * the first text boundary or greater than the last text boundary.
      * @since 1.2
      */
     public boolean isBoundary(int offset) {
         // NOTE: This implementation probably is wrong for most situations
@@ -388,11 +388,11 @@
 
     /**
      * Returns character index of the text boundary that was most
      * recently returned by next(), next(int), previous(), first(), last(),
      * following(int) or preceding(int). If any of these methods returns
-     * <code>BreakIterator.DONE</code> because either first or last text boundary
+     * {@code BreakIterator.DONE} because either first or last text boundary
      * has been reached, it returns the first or last text boundary depending on
      * which one is reached.
      * @return The text boundary returned from the above methods, first or last
      * text boundary.
      * @see #next()
@@ -435,99 +435,99 @@
 
     @SuppressWarnings("unchecked")
     private static final SoftReference<BreakIteratorCache>[] iterCache = (SoftReference<BreakIteratorCache>[]) new SoftReference<?>[4];
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#word">word breaks</a>
      * for the {@linkplain Locale#getDefault() default locale}.
      * @return A break iterator for word breaks
      */
     public static BreakIterator getWordInstance()
     {
         return getWordInstance(Locale.getDefault());
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#word">word breaks</a>
      * for the given locale.
      * @param locale the desired locale
      * @return A break iterator for word breaks
-     * @exception NullPointerException if <code>locale</code> is null
+     * @throws    NullPointerException if {@code locale} is null
      */
     public static BreakIterator getWordInstance(Locale locale)
     {
         return getBreakInstance(locale, WORD_INDEX);
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#line">line breaks</a>
      * for the {@linkplain Locale#getDefault() default locale}.
      * @return A break iterator for line breaks
      */
     public static BreakIterator getLineInstance()
     {
         return getLineInstance(Locale.getDefault());
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#line">line breaks</a>
      * for the given locale.
      * @param locale the desired locale
      * @return A break iterator for line breaks
-     * @exception NullPointerException if <code>locale</code> is null
+     * @throws    NullPointerException if {@code locale} is null
      */
     public static BreakIterator getLineInstance(Locale locale)
     {
         return getBreakInstance(locale, LINE_INDEX);
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#character">character breaks</a>
      * for the {@linkplain Locale#getDefault() default locale}.
      * @return A break iterator for character breaks
      */
     public static BreakIterator getCharacterInstance()
     {
         return getCharacterInstance(Locale.getDefault());
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#character">character breaks</a>
      * for the given locale.
      * @param locale the desired locale
      * @return A break iterator for character breaks
-     * @exception NullPointerException if <code>locale</code> is null
+     * @throws    NullPointerException if {@code locale} is null
      */
     public static BreakIterator getCharacterInstance(Locale locale)
     {
         return getBreakInstance(locale, CHARACTER_INDEX);
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#sentence">sentence breaks</a>
      * for the {@linkplain Locale#getDefault() default locale}.
      * @return A break iterator for sentence breaks
      */
     public static BreakIterator getSentenceInstance()
     {
         return getSentenceInstance(Locale.getDefault());
     }
 
     /**
-     * Returns a new <code>BreakIterator</code> instance
+     * Returns a new {@code BreakIterator} instance
      * for <a href="BreakIterator.html#sentence">sentence breaks</a>
      * for the given locale.
      * @param locale the desired locale
      * @return A break iterator for sentence breaks
-     * @exception NullPointerException if <code>locale</code> is null
+     * @throws    NullPointerException if {@code locale} is null
      */
     public static BreakIterator getSentenceInstance(Locale locale)
     {
         return getBreakInstance(locale, SENTENCE_INDEX);
     }
@@ -578,20 +578,20 @@
         return iterator;
     }
 
     /**
      * Returns an array of all locales for which the
-     * <code>get*Instance</code> methods of this class can return
+     * {@code get*Instance} methods of this class can return
      * localized instances.
      * The returned array represents the union of locales supported by the Java
      * runtime and by installed
      * {@link java.text.spi.BreakIteratorProvider BreakIteratorProvider} implementations.
-     * It must contain at least a <code>Locale</code>
+     * It must contain at least a {@code Locale}
      * instance equal to {@link java.util.Locale#US Locale.US}.
      *
      * @return An array of locales for which localized
-     *         <code>BreakIterator</code> instances are available.
+     *         {@code BreakIterator} instances are available.
      */
     public static synchronized Locale[] getAvailableLocales()
     {
         LocaleServiceProviderPool pool =
             LocaleServiceProviderPool.getPool(BreakIteratorProvider.class);

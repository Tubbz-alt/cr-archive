<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/net/InetAddress.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Inet6AddressImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InetSocketAddress.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/InetAddress.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,11 +29,10 @@</span>
  import java.util.ArrayList;
  import java.util.Objects;
  import java.util.Scanner;
  import java.security.AccessController;
  import java.io.File;
<span class="udiff-line-removed">- import java.io.FileNotFoundException;</span>
  import java.io.ObjectStreamException;
  import java.io.ObjectStreamField;
  import java.io.IOException;
  import java.io.InvalidObjectException;
  import java.io.ObjectInputStream;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -43,16 +42,18 @@</span>
  import java.lang.annotation.Native;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.concurrent.ConcurrentSkipListSet;
  import java.util.concurrent.atomic.AtomicLong;
<span class="udiff-line-added">+ import java.util.Arrays;</span>
  
  import jdk.internal.access.JavaNetInetAddressAccess;
  import jdk.internal.access.SharedSecrets;
  import sun.security.action.*;
  import sun.net.InetAddressCachePolicy;
  import sun.net.util.IPAddressUtil;
<span class="udiff-line-added">+ import sun.nio.cs.UTF_8;</span>
  
  /**
   * This class represents an Internet Protocol (IP) address.
   *
   * &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,11 +70,11 @@</span>
   * InetAddress consists of an IP address and possibly its
   * corresponding host name (depending on whether it is constructed
   * with a host name or whether it has already done reverse host name
   * resolution).
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt; Address types &lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt; Address types &lt;/h2&gt;</span>
   *
   * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
   *   &lt;caption style=&quot;display:none&quot;&gt;Description of unicast and multicast address types&lt;/caption&gt;
   *   &lt;thead&gt;
   *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Address Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,22 +104,22 @@</span>
   *         to different nodes). A packet sent to a multicast address is
   *         delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
   * &lt;/tbody&gt;
   * &lt;/table&gt;
   *
<span class="udiff-line-modified-removed">-  * &lt;h4&gt; IP address scope &lt;/h4&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h3&gt; IP address scope &lt;/h3&gt;</span>
   *
   * &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
   * on a single link for purposes such as auto-address configuration,
   * neighbor discovery, or when no routers are present.
   *
   * &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
   * inside of a site without the need for a global prefix.
   *
   * &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.
   *
<span class="udiff-line-modified-removed">-  * &lt;h4&gt; Textual representation of IP addresses &lt;/h4&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h3&gt; Textual representation of IP addresses &lt;/h3&gt;</span>
   *
   * The textual representation of an IP address is address family specific.
   *
   * &lt;p&gt;
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -128,11 +129,11 @@</span>
   * HREF=&quot;Inet6Address.html#format&quot;&gt;Inet6Address#format&lt;/A&gt;.
   *
   * &lt;P&gt;There is a &lt;a href=&quot;doc-files/net-properties.html#Ipv4IPv6&quot;&gt;couple of
   * System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.&lt;/P&gt;
   *
<span class="udiff-line-modified-removed">-  * &lt;h4&gt; Host Name Resolution &lt;/h4&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h3&gt; Host Name Resolution &lt;/h3&gt;</span>
   *
   * Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
   * the use of a combination of local machine configuration information
   * and network naming services such as the Domain Name System (DNS)
   * and Network Information Service(NIS). The particular naming
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,11 +144,11 @@</span>
   * the host associated with the IP address is returned.
   *
   * &lt;p&gt; The InetAddress class provides methods to resolve host names to
   * their IP addresses and vice versa.
   *
<span class="udiff-line-modified-removed">-  * &lt;h4&gt; InetAddress Caching &lt;/h4&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h3&gt; InetAddress Caching &lt;/h3&gt;</span>
   *
   * The InetAddress class has a cache to store successful as well as
   * unsuccessful host name resolutions.
   *
   * &lt;p&gt; By default, when a security manager is installed, in order to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -193,12 +194,11 @@</span>
   * @see     java.net.InetAddress#getAllByName(java.lang.String)
   * @see     java.net.InetAddress#getByName(java.lang.String)
   * @see     java.net.InetAddress#getLocalHost()
   * @since 1.0
   */
<span class="udiff-line-modified-removed">- public</span>
<span class="udiff-line-removed">- class InetAddress implements java.io.Serializable {</span>
<span class="udiff-line-modified-added">+ public class InetAddress implements java.io.Serializable {</span>
  
      @Native static final int PREFER_IPV4_VALUE = 0;
      @Native static final int PREFER_IPV6_VALUE = 1;
      @Native static final int PREFER_SYSTEM_VALUE = 2;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -287,27 +287,27 @@</span>
      InetAddressHolder holder() {
          return holder;
      }
  
      /* Used to store the name service provider */
<span class="udiff-line-modified-removed">-     private static transient NameService nameService = null;</span>
<span class="udiff-line-modified-added">+     private static transient NameService nameService;</span>
  
      /**
       * Used to store the best available hostname.
       * Lazily initialized via a data race; safe because Strings are immutable.
       */
      private transient String canonicalHostName = null;
  
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 3286316764910316507L;
  
      /*
       * Load net library into runtime, and perform initializations.
       */
      static {
<span class="udiff-line-modified-removed">-         String str = java.security.AccessController.doPrivileged(</span>
<span class="udiff-line-removed">-                 new GetPropertyAction(&quot;java.net.preferIPv6Addresses&quot;));</span>
<span class="udiff-line-modified-added">+         String str = GetPropertyAction.privilegedGetProperty(&quot;java.net.preferIPv6Addresses&quot;);</span>
          if (str == null) {
              preferIPv6Address = PREFER_IPV4_VALUE;
          } else if (str.equalsIgnoreCase(&quot;true&quot;)) {
              preferIPv6Address = PREFER_IPV6_VALUE;
          } else if (str.equalsIgnoreCase(&quot;false&quot;)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -315,29 +315,31 @@</span>
          } else if (str.equalsIgnoreCase(&quot;system&quot;)) {
              preferIPv6Address = PREFER_SYSTEM_VALUE;
          } else {
              preferIPv6Address = PREFER_IPV4_VALUE;
          }
<span class="udiff-line-modified-removed">-         AccessController.doPrivileged(</span>
<span class="udiff-line-removed">-             new java.security.PrivilegedAction&lt;&gt;() {</span>
<span class="udiff-line-removed">-                 public Void run() {</span>
<span class="udiff-line-removed">-                     System.loadLibrary(&quot;net&quot;);</span>
<span class="udiff-line-removed">-                     return null;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             });</span>
<span class="udiff-line-modified-added">+         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>
          SharedSecrets.setJavaNetInetAddressAccess(
                  new JavaNetInetAddressAccess() {
                      public String getOriginalHostName(InetAddress ia) {
                          return ia.holder.getOriginalHostName();
                      }
  
                      public InetAddress getByName(String hostName,
                                                   InetAddress hostAddress)
<span class="udiff-line-modified-removed">-                             throws UnknownHostException</span>
<span class="udiff-line-modified-added">+                         throws UnknownHostException</span>
                      {
                          return InetAddress.getByName(hostName, hostAddress);
                      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     public int addressValue(Inet4Address inet4Address) {</span>
<span class="udiff-line-added">+                         return inet4Address.addressValue();</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     public byte[] addressBytes(Inet6Address inet6Address) {</span>
<span class="udiff-line-added">+                         return inet6Address.addressBytes();</span>
<span class="udiff-line-added">+                     }</span>
                  }
          );
          init();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -357,10 +359,11 @@</span>
       * @return the alternate object to the de-serialized object.
       *
       * @throws ObjectStreamException if a new object replacing this
       * object could not be created
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private Object readResolve() throws ObjectStreamException {
          // will replace the deserialized &#39;this&#39; object
          return new Inet4Address(holder().getHostName(), holder().getAddress());
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -987,33 +990,34 @@</span>
          @Override
          public String getHostByAddr(byte[] addr) throws UnknownHostException {
              String hostEntry;
              String host = null;
  
<span class="udiff-line-modified-removed">-             String addrString = addrToString(addr);</span>
<span class="udiff-line-modified-removed">-             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile), &quot;UTF-8&quot;)) {</span>
<span class="udiff-line-modified-added">+             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),</span>
<span class="udiff-line-modified-added">+                                                         UTF_8.INSTANCE))</span>
<span class="udiff-line-added">+             {</span>
                  while (hostsFileScanner.hasNextLine()) {
                      hostEntry = hostsFileScanner.nextLine();
                      if (!hostEntry.startsWith(&quot;#&quot;)) {
                          hostEntry = removeComments(hostEntry);
<span class="udiff-line-modified-removed">-                         if (hostEntry.contains(addrString)) {</span>
<span class="udiff-line-modified-removed">-                             host = extractHost(hostEntry, addrString);</span>
<span class="udiff-line-modified-removed">-                             if (host != null) {</span>
<span class="udiff-line-modified-removed">-                                 break;</span>
<span class="udiff-line-modified-removed">-                             }</span>
<span class="udiff-line-modified-added">+                         String[] mapping = hostEntry.split(&quot;\\s+&quot;);</span>
<span class="udiff-line-modified-added">+                         if (mapping.length &gt;= 2 &amp;&amp;</span>
<span class="udiff-line-modified-added">+                             Arrays.equals(addr, createAddressByteArray(mapping[0]))) {</span>
<span class="udiff-line-modified-added">+                             host = mapping[1];</span>
<span class="udiff-line-modified-added">+                             break;</span>
                          }
                      }
                  }
<span class="udiff-line-modified-removed">-             } catch (FileNotFoundException e) {</span>
<span class="udiff-line-modified-added">+             } catch (IOException e) {</span>
                  throw new UnknownHostException(&quot;Unable to resolve address &quot;
<span class="udiff-line-modified-removed">-                         + addrString + &quot; as hosts file &quot; + hostsFile</span>
<span class="udiff-line-modified-added">+                         + Arrays.toString(addr) + &quot; as hosts file &quot; + hostsFile</span>
                          + &quot; not found &quot;);
              }
  
              if ((host == null) || (host.isEmpty()) || (host.equals(&quot; &quot;))) {
                  throw new UnknownHostException(&quot;Requested address &quot;
<span class="udiff-line-modified-removed">-                         + addrString</span>
<span class="udiff-line-modified-added">+                         + Arrays.toString(addr)</span>
                          + &quot; resolves to an invalid entry in hosts file &quot;
                          + hostsFile);
              }
              return host;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1037,11 +1041,13 @@</span>
              InetAddress[] res = null;
              byte addr[] = new byte[4];
              ArrayList&lt;InetAddress&gt; inetAddresses = null;
  
              // lookup the file and create a list InetAddress for the specified host
<span class="udiff-line-modified-removed">-             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile), &quot;UTF-8&quot;)) {</span>
<span class="udiff-line-modified-added">+             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),</span>
<span class="udiff-line-added">+                                                         UTF_8.INSTANCE))</span>
<span class="udiff-line-added">+             {</span>
                  while (hostsFileScanner.hasNextLine()) {
                      hostEntry = hostsFileScanner.nextLine();
                      if (!hostEntry.startsWith(&quot;#&quot;)) {
                          hostEntry = removeComments(hostEntry);
                          if (hostEntry.contains(host)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1056,11 +1062,11 @@</span>
                                  }
                              }
                          }
                      }
                  }
<span class="udiff-line-modified-removed">-             } catch (FileNotFoundException e) {</span>
<span class="udiff-line-modified-added">+             } catch (IOException e) {</span>
                  throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
                          + &quot; as hosts file &quot; + hostsFile + &quot; not found &quot;);
              }
  
              if (inetAddresses != null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1105,26 +1111,10 @@</span>
                      }
                  }
              }
              return hostAddr;
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * IP Address to host mapping</span>
<span class="udiff-line-removed">-          * use first host alias in list</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private String extractHost(String hostEntry, String addrString) {</span>
<span class="udiff-line-removed">-             String[] mapping = hostEntry.split(&quot;\\s+&quot;);</span>
<span class="udiff-line-removed">-             String host = null;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (mapping.length &gt;= 2) {</span>
<span class="udiff-line-removed">-                 if (mapping[0].equalsIgnoreCase(addrString)) {</span>
<span class="udiff-line-removed">-                     host = mapping[1];</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return host;</span>
<span class="udiff-line-removed">-         }</span>
      }
  
      static final InetAddressImpl  impl;
  
      static {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1180,11 +1170,11 @@</span>
       * must be 16 bytes long
       *
       * @param host the specified host
       * @param addr the raw IP address in network byte order
       * @return  an InetAddress object created from the raw IP address.
<span class="udiff-line-modified-removed">-      * @exception  UnknownHostException  if IP address is of illegal length</span>
<span class="udiff-line-modified-added">+      * @throws     UnknownHostException  if IP address is of illegal length</span>
       * @since 1.4
       */
      public static InetAddress getByAddress(String host, byte[] addr)
          throws UnknownHostException {
          if (host != null &amp;&amp; !host.isEmpty() &amp;&amp; host.charAt(0) == &#39;[&#39;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1235,14 +1225,14 @@</span>
       * {@code checkConnect} method is called with the hostname and {@code -1}
       * as its arguments to determine if the operation is allowed.
       *
       * @param      host   the specified host, or {@code null}.
       * @return     an IP address for the given host name.
<span class="udiff-line-modified-removed">-      * @exception  UnknownHostException  if no IP address for the</span>
<span class="udiff-line-modified-added">+      * @throws     UnknownHostException  if no IP address for the</span>
       *               {@code host} could be found, or if a scope_id was specified
       *               for a global IPv6 address.
<span class="udiff-line-modified-removed">-      * @exception  SecurityException if a security manager exists</span>
<span class="udiff-line-modified-added">+      * @throws     SecurityException if a security manager exists</span>
       *             and its checkConnect method doesn&#39;t allow the operation
       */
      public static InetAddress getByName(String host)
          throws UnknownHostException {
          return InetAddress.getAllByName(host)[0];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1283,14 +1273,14 @@</span>
       * as its arguments to determine if the operation is allowed.
       *
       * @param      host   the name of the host, or {@code null}.
       * @return     an array of all the IP addresses for a given host name.
       *
<span class="udiff-line-modified-removed">-      * @exception  UnknownHostException  if no IP address for the</span>
<span class="udiff-line-modified-added">+      * @throws     UnknownHostException  if no IP address for the</span>
       *               {@code host} could be found, or if a scope_id was specified
       *               for a global IPv6 address.
<span class="udiff-line-modified-removed">-      * @exception  SecurityException  if a security manager exists and its</span>
<span class="udiff-line-modified-added">+      * @throws     SecurityException  if a security manager exists and its</span>
       *               {@code checkConnect} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkConnect
       */
      public static InetAddress[] getAllByName(String host)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1561,11 +1551,11 @@</span>
       * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
       * must be 16 bytes long
       *
       * @param addr the raw IP address in network byte order
       * @return  an InetAddress object created from the raw IP address.
<span class="udiff-line-modified-removed">-      * @exception  UnknownHostException  if IP address is of illegal length</span>
<span class="udiff-line-modified-added">+      * @throws     UnknownHostException  if IP address is of illegal length</span>
       * @since 1.4
       */
      public static InetAddress getByAddress(byte[] addr)
          throws UnknownHostException {
          return getByAddress(null, addr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1599,11 +1589,11 @@</span>
       * If the operation is not allowed, an InetAddress representing
       * the loopback address is returned.
       *
       * @return     the address of the local host.
       *
<span class="udiff-line-modified-removed">-      * @exception  UnknownHostException  if the local host name could not</span>
<span class="udiff-line-modified-added">+      * @throws     UnknownHostException  if the local host name could not</span>
       *             be resolved into an address.
       *
       * @see SecurityManager#checkConnect
       * @see java.net.InetAddress#getByName(java.lang.String)
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1708,10 +1698,11 @@</span>
          }
  
          return (InetAddressImpl) impl;
      }
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void readObjectNoData () {
          if (getClass().getClassLoader() != null) {
              throw new SecurityException (&quot;invalid address type&quot;);
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1719,10 +1710,11 @@</span>
      private static final jdk.internal.misc.Unsafe UNSAFE
              = jdk.internal.misc.Unsafe.getUnsafe();
      private static final long FIELDS_OFFSET
              = UNSAFE.objectFieldOffset(InetAddress.class, &quot;holder&quot;);
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void readObject (ObjectInputStream s) throws
                           IOException, ClassNotFoundException {
          if (getClass().getClassLoader() != null) {
              throw new SecurityException (&quot;invalid address type&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1742,16 +1734,18 @@</span>
      /**
       * @serialField hostName String
       * @serialField address int
       * @serialField family int
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields = {
          new ObjectStreamField(&quot;hostName&quot;, String.class),
          new ObjectStreamField(&quot;address&quot;, int.class),
          new ObjectStreamField(&quot;family&quot;, int.class),
      };
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void writeObject (ObjectOutputStream s) throws
                          IOException {
          if (getClass().getClassLoader() != null) {
              throw new SecurityException (&quot;invalid address type&quot;);
          }
</pre>
<center><a href="Inet6AddressImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InetSocketAddress.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
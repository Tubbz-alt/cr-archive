<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/Format.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FieldPosition.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MergeCollation.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/Format.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,68 ***</span>
  package java.text;
  
  import java.io.Serializable;
  
  /**
<span class="line-modified">!  * &lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive</span>
   * information such as dates, messages, and numbers.
   *
   * &lt;p&gt;
<span class="line-modified">!  * &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting</span>
<span class="line-modified">!  * locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the</span>
<span class="line-modified">!  * &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back</span>
<span class="line-modified">!  * into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).</span>
   *
   * &lt;p&gt;
<span class="line-modified">!  * Generally, a format&#39;s &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse</span>
<span class="line-modified">!  * any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may</span>
   * be exceptional cases where this is not possible. For example, a
<span class="line-modified">!  * &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with</span>
<span class="line-modified">!  * no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could</span>
   * not tell which digits belong to which number.
   *
<span class="line-modified">!  * &lt;h3&gt;Subclassing&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
<span class="line-modified">!  * The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--</span>
<span class="line-modified">!  * &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and</span>
<span class="line-modified">!  * &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,</span>
   * respectively.
   * &lt;p&gt;
   * Concrete subclasses must implement three methods:
   * &lt;ol&gt;
<span class="line-modified">!  * &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;</span>
   * &lt;/ol&gt;
   * These general methods allow polymorphic parsing and formatting of objects
<span class="line-modified">!  * and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.</span>
<span class="line-modified">!  * Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for</span>
<span class="line-modified">!  * specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific</span>
<span class="line-modified">!  * result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a</span>
<span class="line-modified">!  * &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;</span>
   * when no text in the required format is at the beginning of the input text.
   *
   * &lt;p&gt;
   * Most subclasses will also implement the following factory methods:
   * &lt;ol&gt;
   * &lt;li&gt;
<span class="line-modified">!  * &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate</span>
   * for the current locale
   * &lt;li&gt;
<span class="line-modified">!  * &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format</span>
   * object appropriate for the specified locale
   * &lt;/ol&gt;
   * In addition, some subclasses may also implement other
<span class="line-modified">!  * &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For</span>
<span class="line-modified">!  * example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides</span>
<span class="line-modified">!  * &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;</span>
   * methods for getting specialized number formatters.
   *
   * &lt;p&gt;
<span class="line-modified">!  * Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects</span>
<span class="line-modified">!  * for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)</span>
   * must also implement the following class method:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * public static Locale[] getAvailableLocales()
   * &lt;/pre&gt;
<span class="line-new-header">--- 39,68 ---</span>
  package java.text;
  
  import java.io.Serializable;
  
  /**
<span class="line-modified">!  * {@code Format} is an abstract base class for formatting locale-sensitive</span>
   * information such as dates, messages, and numbers.
   *
   * &lt;p&gt;
<span class="line-modified">!  * {@code Format} defines the programming interface for formatting</span>
<span class="line-modified">!  * locale-sensitive objects into {@code String}s (the</span>
<span class="line-modified">!  * {@code format} method) and for parsing {@code String}s back</span>
<span class="line-modified">!  * into objects (the {@code parseObject} method).</span>
   *
   * &lt;p&gt;
<span class="line-modified">!  * Generally, a format&#39;s {@code parseObject} method must be able to parse</span>
<span class="line-modified">!  * any string formatted by its {@code format} method. However, there may</span>
   * be exceptional cases where this is not possible. For example, a
<span class="line-modified">!  * {@code format} method might create two adjacent integer numbers with</span>
<span class="line-modified">!  * no separator in between, and in this case the {@code parseObject} could</span>
   * not tell which digits belong to which number.
   *
<span class="line-modified">!  * &lt;h2&gt;Subclassing&lt;/h2&gt;</span>
   *
   * &lt;p&gt;
<span class="line-modified">!  * The Java Platform provides three specialized subclasses of {@code Format}--</span>
<span class="line-modified">!  * {@code DateFormat}, {@code MessageFormat}, and</span>
<span class="line-modified">!  * {@code NumberFormat}--for formatting dates, messages, and numbers,</span>
   * respectively.
   * &lt;p&gt;
   * Concrete subclasses must implement three methods:
   * &lt;ol&gt;
<span class="line-modified">!  * &lt;li&gt; {@code format(Object obj, StringBuffer toAppendTo, FieldPosition pos)}</span>
<span class="line-modified">!  * &lt;li&gt; {@code formatToCharacterIterator(Object obj)}</span>
<span class="line-modified">!  * &lt;li&gt; {@code parseObject(String source, ParsePosition pos)}</span>
   * &lt;/ol&gt;
   * These general methods allow polymorphic parsing and formatting of objects
<span class="line-modified">!  * and are used, for example, by {@code MessageFormat}.</span>
<span class="line-modified">!  * Subclasses often also provide additional {@code format} methods for</span>
<span class="line-modified">!  * specific input types as well as {@code parse} methods for specific</span>
<span class="line-modified">!  * result types. Any {@code parse} method that does not take a</span>
<span class="line-modified">!  * {@code ParsePosition} argument should throw {@code ParseException}</span>
   * when no text in the required format is at the beginning of the input text.
   *
   * &lt;p&gt;
   * Most subclasses will also implement the following factory methods:
   * &lt;ol&gt;
   * &lt;li&gt;
<span class="line-modified">!  * {@code getInstance} for getting a useful format object appropriate</span>
   * for the current locale
   * &lt;li&gt;
<span class="line-modified">!  * {@code getInstance(Locale)} for getting a useful format</span>
   * object appropriate for the specified locale
   * &lt;/ol&gt;
   * In addition, some subclasses may also implement other
<span class="line-modified">!  * {@code getXxxxInstance} methods for more specialized control. For</span>
<span class="line-modified">!  * example, the {@code NumberFormat} class provides</span>
<span class="line-modified">!  * {@code getPercentInstance} and {@code getCurrencyInstance}</span>
   * methods for getting specialized number formatters.
   *
   * &lt;p&gt;
<span class="line-modified">!  * Subclasses of {@code Format} that allow programmers to create objects</span>
<span class="line-modified">!  * for locales (with {@code getInstance(Locale)} for example)</span>
   * must also implement the following class method:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * public static Locale[] getAvailableLocales()
   * &lt;/pre&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,14 ***</span>
   * And finally subclasses may define a set of constants to identify the various
   * fields in the formatted output. These constants are used to create a FieldPosition
   * object which identifies what information is contained in the field and its
   * position in the formatted result. These constants should be named
   * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
<span class="line-modified">!  * the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its</span>
   * friends in {@link DateFormat}.
   *
<span class="line-modified">!  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
   *
   * &lt;p&gt;
   * Formats are generally not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
<span class="line-new-header">--- 110,14 ---</span>
   * And finally subclasses may define a set of constants to identify the various
   * fields in the formatted output. These constants are used to create a FieldPosition
   * object which identifies what information is contained in the field and its
   * position in the formatted result. These constants should be named
   * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
<span class="line-modified">!  * the field. For examples of these constants, see {@code ERA_FIELD} and its</span>
   * friends in {@link DateFormat}.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
   * Formats are generally not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,10 ***</span>
<span class="line-new-header">--- 131,11 ---</span>
   * @author       Mark Davis
   * @since 1.1
   */
  public abstract class Format implements Serializable, Cloneable {
  
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = -299282585814624189L;
  
      /**
       * Sole constructor.  (For invocation by subclass constructors, typically
       * implicit.)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,57 ***</span>
       *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
       * &lt;/blockquote&gt;
       *
       * @param obj    The object to format
       * @return       Formatted string.
<span class="line-modified">!      * @exception IllegalArgumentException if the Format cannot format the given</span>
       *            object
       */
      public final String format (Object obj) {
          return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
      }
  
      /**
       * Formats an object and appends the resulting text to a given string
       * buffer.
<span class="line-modified">!      * If the &lt;code&gt;pos&lt;/code&gt; argument identifies a field used by the format,</span>
       * then its indices are set to the beginning and end of the first such
       * field encountered.
       *
       * @param obj    The object to format
       * @param toAppendTo    where the text is to be appended
<span class="line-modified">!      * @param pos    A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field</span>
       *               in the formatted text
<span class="line-modified">!      * @return       the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,</span>
       *               with formatted text appended
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified">!      *            &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified">!      * @exception IllegalArgumentException if the Format cannot format the given</span>
       *            object
       */
      public abstract StringBuffer format(Object obj,
                      StringBuffer toAppendTo,
                      FieldPosition pos);
  
      /**
<span class="line-modified">!      * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">!      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
       * to build the resulting String, as well as to determine information
       * about the resulting String.
       * &lt;p&gt;
       * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified">!      * &lt;code&gt;Field&lt;/code&gt;. It is up to each &lt;code&gt;Format&lt;/code&gt; implementation</span>
       * to define what the legal values are for each attribute in the
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;, but typically the attribute</span>
       * key is also used as the attribute value.
       * &lt;p&gt;The default implementation creates an
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses</span>
       * that support fields should override this and create an
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.</span>
       *
<span class="line-modified">!      * @exception NullPointerException if obj is null.</span>
<span class="line-modified">!      * @exception IllegalArgumentException when the Format cannot format the</span>
       *            given object.
       * @param obj The object to format
       * @return AttributedCharacterIterator describing the formatted value.
       * @since 1.4
       */
<span class="line-new-header">--- 150,57 ---</span>
       *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
       * &lt;/blockquote&gt;
       *
       * @param obj    The object to format
       * @return       Formatted string.
<span class="line-modified">!      * @throws    IllegalArgumentException if the Format cannot format the given</span>
       *            object
       */
      public final String format (Object obj) {
          return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
      }
  
      /**
       * Formats an object and appends the resulting text to a given string
       * buffer.
<span class="line-modified">!      * If the {@code pos} argument identifies a field used by the format,</span>
       * then its indices are set to the beginning and end of the first such
       * field encountered.
       *
       * @param obj    The object to format
       * @param toAppendTo    where the text is to be appended
<span class="line-modified">!      * @param pos    A {@code FieldPosition} identifying a field</span>
       *               in the formatted text
<span class="line-modified">!      * @return       the string buffer passed in as {@code toAppendTo},</span>
       *               with formatted text appended
<span class="line-modified">!      * @throws    NullPointerException if {@code toAppendTo} or</span>
<span class="line-modified">!      *            {@code pos} is null</span>
<span class="line-modified">!      * @throws    IllegalArgumentException if the Format cannot format the given</span>
       *            object
       */
      public abstract StringBuffer format(Object obj,
                      StringBuffer toAppendTo,
                      FieldPosition pos);
  
      /**
<span class="line-modified">!      * Formats an Object producing an {@code AttributedCharacterIterator}.</span>
<span class="line-modified">!      * You can use the returned {@code AttributedCharacterIterator}</span>
       * to build the resulting String, as well as to determine information
       * about the resulting String.
       * &lt;p&gt;
       * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified">!      * {@code Field}. It is up to each {@code Format} implementation</span>
       * to define what the legal values are for each attribute in the
<span class="line-modified">!      * {@code AttributedCharacterIterator}, but typically the attribute</span>
       * key is also used as the attribute value.
       * &lt;p&gt;The default implementation creates an
<span class="line-modified">!      * {@code AttributedCharacterIterator} with no attributes. Subclasses</span>
       * that support fields should override this and create an
<span class="line-modified">!      * {@code AttributedCharacterIterator} with meaningful attributes.</span>
       *
<span class="line-modified">!      * @throws    NullPointerException if obj is null.</span>
<span class="line-modified">!      * @throws    IllegalArgumentException when the Format cannot format the</span>
       *            given object.
       * @param obj The object to format
       * @return AttributedCharacterIterator describing the formatted value.
       * @since 1.4
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,36 ***</span>
  
      /**
       * Parses text from a string to produce an object.
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">!      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
       * the character where the error occurred, and null is returned.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code source} or {@code pos} is null.
       */
      public abstract Object parseObject (String source, ParsePosition pos);
  
      /**
       * Parses text from the beginning of the given string to produce an object.
       * The method may not use the entire text of the given string.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">!      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string.</span>
<span class="line-modified">!      * @exception ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       * @throws NullPointerException if {@code source} is null.
       */
      public Object parseObject(String source) throws ParseException {
          ParsePosition pos = new ParsePosition(0);
<span class="line-new-header">--- 210,36 ---</span>
  
      /**
       * Parses text from a string to produce an object.
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * {@code pos}.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of {@code pos} is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * object is returned. The updated {@code pos} can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">!      * changed, the error index of {@code pos} is set to the index of</span>
       * the character where the error occurred, and null is returned.
       *
<span class="line-modified">!      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A {@code ParsePosition} object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return An {@code Object} parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code source} or {@code pos} is null.
       */
      public abstract Object parseObject (String source, ParsePosition pos);
  
      /**
       * Parses text from the beginning of the given string to produce an object.
       * The method may not use the entire text of the given string.
       *
<span class="line-modified">!      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">!      * @return An {@code Object} parsed from the string.</span>
<span class="line-modified">!      * @throws    ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       * @throws NullPointerException if {@code source} is null.
       */
      public Object parseObject(String source) throws ParseException {
          ParsePosition pos = new ParsePosition(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,12 ***</span>
      // Convenience methods for creating AttributedCharacterIterators from
      // different parameters.
      //
  
      /**
<span class="line-modified">!      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String</span>
<span class="line-modified">!      * &lt;code&gt;s&lt;/code&gt;.</span>
       *
       * @param s String to create AttributedCharacterIterator from
       * @return AttributedCharacterIterator wrapping s
       */
      AttributedCharacterIterator createAttributedCharacterIterator(String s) {
<span class="line-new-header">--- 269,12 ---</span>
      // Convenience methods for creating AttributedCharacterIterators from
      // different parameters.
      //
  
      /**
<span class="line-modified">!      * Creates an {@code AttributedCharacterIterator} for the String</span>
<span class="line-modified">!      * {@code s}.</span>
       *
       * @param s String to create AttributedCharacterIterator from
       * @return AttributedCharacterIterator wrapping s
       */
      AttributedCharacterIterator createAttributedCharacterIterator(String s) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,13 ***</span>
  
          return as.getIterator();
      }
  
      /**
<span class="line-modified">!      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; containing the</span>
       * concatenated contents of the passed in
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;s.</span>
       *
       * @param iterators AttributedCharacterIterators used to create resulting
       *                  AttributedCharacterIterators
       * @return AttributedCharacterIterator wrapping passed in
       *         AttributedCharacterIterators
<span class="line-new-header">--- 282,13 ---</span>
  
          return as.getIterator();
      }
  
      /**
<span class="line-modified">!      * Creates an {@code AttributedCharacterIterator} containing the</span>
       * concatenated contents of the passed in
<span class="line-modified">!      * {@code AttributedCharacterIterator}s.</span>
       *
       * @param iterators AttributedCharacterIterators used to create resulting
       *                  AttributedCharacterIterators
       * @return AttributedCharacterIterator wrapping passed in
       *         AttributedCharacterIterators
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,12 ***</span>
          return as.getIterator();
      }
  
      /**
       * Returns an AttributedCharacterIterator with the String
<span class="line-modified">!      * &lt;code&gt;string&lt;/code&gt; and additional key/value pair &lt;code&gt;key&lt;/code&gt;,</span>
<span class="line-modified">!      * &lt;code&gt;value&lt;/code&gt;.</span>
       *
       * @param string String to create AttributedCharacterIterator from
       * @param key Key for AttributedCharacterIterator
       * @param value Value associated with key in AttributedCharacterIterator
       * @return AttributedCharacterIterator wrapping args
<span class="line-new-header">--- 300,12 ---</span>
          return as.getIterator();
      }
  
      /**
       * Returns an AttributedCharacterIterator with the String
<span class="line-modified">!      * {@code string} and additional key/value pair {@code key},</span>
<span class="line-modified">!      * {@code value}.</span>
       *
       * @param string String to create AttributedCharacterIterator from
       * @param key Key for AttributedCharacterIterator
       * @param value Value associated with key in AttributedCharacterIterator
       * @return AttributedCharacterIterator wrapping args
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,12 ***</span>
          return as.getIterator();
      }
  
      /**
       * Creates an AttributedCharacterIterator with the contents of
<span class="line-modified">!      * &lt;code&gt;iterator&lt;/code&gt; and the additional attribute &lt;code&gt;key&lt;/code&gt;</span>
<span class="line-modified">!      * &lt;code&gt;value&lt;/code&gt;.</span>
       *
       * @param iterator Initial AttributedCharacterIterator to add arg to
       * @param key Key for AttributedCharacterIterator
       * @param value Value associated with key in AttributedCharacterIterator
       * @return AttributedCharacterIterator wrapping args
<span class="line-new-header">--- 319,12 ---</span>
          return as.getIterator();
      }
  
      /**
       * Creates an AttributedCharacterIterator with the contents of
<span class="line-modified">!      * {@code iterator} and the additional attribute {@code key}</span>
<span class="line-modified">!      * {@code value}.</span>
       *
       * @param iterator Initial AttributedCharacterIterator to add arg to
       * @param key Key for AttributedCharacterIterator
       * @param value Value associated with key in AttributedCharacterIterator
       * @return AttributedCharacterIterator wrapping args
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,19 ***</span>
      }
  
  
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">!      * from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">!      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
       *
       * @since 1.4
       */
      public static class Field extends AttributedCharacterIterator.Attribute {
  
          // Proclaim serial compatibility with 1.4 FCS
          private static final long serialVersionUID = 276966692217360283L;
  
          /**
           * Creates a Field with the specified name.
           *
<span class="line-new-header">--- 339,20 ---</span>
      }
  
  
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">!      * from {@code Format.formatToCharacterIterator} and as</span>
<span class="line-modified">!      * field identifiers in {@code FieldPosition}.</span>
       *
       * @since 1.4
       */
      public static class Field extends AttributedCharacterIterator.Attribute {
  
          // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 276966692217360283L;
  
          /**
           * Creates a Field with the specified name.
           *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,27 ***</span>
          }
      }
  
  
      /**
<span class="line-modified">!      * FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;</span>
       * implementations as they are formatting the Objects. This allows for
       * storage of the individual sections of the formatted String for
<span class="line-modified">!      * later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an</span>
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify</span>
       * the delegate of fields in any particular order.
       *
       * @see FieldPosition#getFieldDelegate
       * @see CharacterIteratorFieldDelegate
       */
      interface FieldDelegate {
          /**
           * Notified when a particular region of the String is formatted. This
           * method will be invoked if there is no corresponding integer field id
<span class="line-modified">!          * matching &lt;code&gt;attr&lt;/code&gt;.</span>
           *
           * @param attr Identifies the field matched
           * @param value Value associated with the field
           * @param start Beginning location of the field, will be &gt;= 0
           * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
<span class="line-new-header">--- 363,27 ---</span>
          }
      }
  
  
      /**
<span class="line-modified">!      * FieldDelegate is notified by the various {@code Format}</span>
       * implementations as they are formatting the Objects. This allows for
       * storage of the individual sections of the formatted String for
<span class="line-modified">!      * later use, such as in a {@code FieldPosition} or for an</span>
<span class="line-modified">!      * {@code AttributedCharacterIterator}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * Delegates should NOT assume that the {@code Format} will notify</span>
       * the delegate of fields in any particular order.
       *
       * @see FieldPosition#getFieldDelegate
       * @see CharacterIteratorFieldDelegate
       */
      interface FieldDelegate {
          /**
           * Notified when a particular region of the String is formatted. This
           * method will be invoked if there is no corresponding integer field id
<span class="line-modified">!          * matching {@code attr}.</span>
           *
           * @param attr Identifies the field matched
           * @param value Value associated with the field
           * @param start Beginning location of the field, will be &gt;= 0
           * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
</pre>
<center><a href="FieldPosition.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MergeCollation.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="System.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ThreadDeath.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Thread.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -138,12 +138,11 @@</span>
   * @see     Runtime#exit(int)
   * @see     #run()
   * @see     #stop()
   * @since   1.0
   */
<span class="udiff-line-modified-removed">- public</span>
<span class="udiff-line-removed">- class Thread implements Runnable {</span>
<span class="udiff-line-modified-added">+ public class Thread implements Runnable {</span>
      /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
      private static native void registerNatives();
      static {
          registerNatives();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,10 +151,13 @@</span>
      private int priority;
  
      /* Whether or not the thread is a daemon thread. */
      private boolean daemon = false;
  
<span class="udiff-line-added">+     /* Interrupt state of the thread - read/written directly by JVM */</span>
<span class="udiff-line-added">+     private volatile boolean interrupted;</span>
<span class="udiff-line-added">+ </span>
      /* Fields reserved for exclusive use by the JVM */
      private boolean stillborn = false;
      private long eetop;
  
      /* What will be run. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -191,15 +193,10 @@</span>
       * not specify a stack size.  It is up to the VM to do whatever it
       * likes with this number; some VMs will ignore it.
       */
      private final long stackSize;
  
<span class="udiff-line-removed">-     /*</span>
<span class="udiff-line-removed">-      * JVM-private state that persists after native thread termination.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private long nativeParkEventPointer;</span>
<span class="udiff-line-removed">- </span>
      /*
       * Thread ID
       */
      private final long tid;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -974,32 +971,37 @@</span>
       * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
       * status will be set. &lt;/p&gt;
       *
       * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
       *
<span class="udiff-line-added">+      * @implNote In the JDK Reference Implementation, interruption of a thread</span>
<span class="udiff-line-added">+      * that is not alive still records that the interrupt request was made and</span>
<span class="udiff-line-added">+      * will report it via {@link #interrupted} and {@link #isInterrupted()}.</span>
<span class="udiff-line-added">+      *</span>
       * @throws  SecurityException
       *          if the current thread cannot modify this thread
       *
<span class="udiff-line-modified-removed">-      * @revised 6.0</span>
<span class="udiff-line-modified-added">+      * @revised 6.0, 14</span>
       * @spec JSR-51
       */
      public void interrupt() {
          if (this != Thread.currentThread()) {
              checkAccess();
  
              // thread may be blocked in an I/O operation
              synchronized (blockerLock) {
                  Interruptible b = blocker;
                  if (b != null) {
<span class="udiff-line-modified-removed">-                     interrupt0();  // set interrupt status</span>
<span class="udiff-line-modified-added">+                     interrupted = true;</span>
<span class="udiff-line-added">+                     interrupt0();  // inform VM of interrupt</span>
                      b.interrupt(this);
                      return;
                  }
              }
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         // set interrupt status</span>
<span class="udiff-line-modified-added">+         interrupted = true;</span>
<span class="udiff-line-modified-added">+         // inform VM of interrupt</span>
          interrupt0();
      }
  
      /**
       * Tests whether the current thread has been interrupted.  The
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1007,48 +1009,41 @@</span>
       * other words, if this method were to be called twice in succession, the
       * second call would return false (unless the current thread were
       * interrupted again, after the first call had cleared its interrupted
       * status and before the second call had examined it).
       *
<span class="udiff-line-removed">-      * &lt;p&gt;A thread interruption ignored because a thread was not alive</span>
<span class="udiff-line-removed">-      * at the time of the interrupt will be reflected by this method</span>
<span class="udiff-line-removed">-      * returning false.</span>
<span class="udiff-line-removed">-      *</span>
       * @return  {@code true} if the current thread has been interrupted;
       *          {@code false} otherwise.
       * @see #isInterrupted()
<span class="udiff-line-modified-removed">-      * @revised 6.0</span>
<span class="udiff-line-modified-added">+      * @revised 6.0, 14</span>
       */
      public static boolean interrupted() {
<span class="udiff-line-modified-removed">-         return currentThread().isInterrupted(true);</span>
<span class="udiff-line-modified-added">+         Thread t = currentThread();</span>
<span class="udiff-line-added">+         boolean interrupted = t.interrupted;</span>
<span class="udiff-line-added">+         // We may have been interrupted the moment after we read the field,</span>
<span class="udiff-line-added">+         // so only clear the field if we saw that it was set and will return</span>
<span class="udiff-line-added">+         // true; otherwise we could lose an interrupt.</span>
<span class="udiff-line-added">+         if (interrupted) {</span>
<span class="udiff-line-added">+             t.interrupted = false;</span>
<span class="udiff-line-added">+             clearInterruptEvent();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return interrupted;</span>
      }
  
      /**
       * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
       * status&lt;/i&gt; of the thread is unaffected by this method.
       *
<span class="udiff-line-removed">-      * &lt;p&gt;A thread interruption ignored because a thread was not alive</span>
<span class="udiff-line-removed">-      * at the time of the interrupt will be reflected by this method</span>
<span class="udiff-line-removed">-      * returning false.</span>
<span class="udiff-line-removed">-      *</span>
       * @return  {@code true} if this thread has been interrupted;
       *          {@code false} otherwise.
       * @see     #interrupted()
<span class="udiff-line-modified-removed">-      * @revised 6.0</span>
<span class="udiff-line-modified-added">+      * @revised 6.0, 14</span>
       */
      public boolean isInterrupted() {
<span class="udiff-line-modified-removed">-         return isInterrupted(false);</span>
<span class="udiff-line-modified-added">+         return interrupted;</span>
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Tests if some Thread has been interrupted.  The interrupted state</span>
<span class="udiff-line-removed">-      * is reset or not based on the value of ClearInterrupted that is</span>
<span class="udiff-line-removed">-      * passed.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-removed">-     private native boolean isInterrupted(boolean ClearInterrupted);</span>
<span class="udiff-line-removed">- </span>
      /**
       * Tests if this thread is alive. A thread is alive if it has
       * been started and has not yet died.
       *
       * @return  {@code true} if this thread is alive;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1078,11 +1073,11 @@</span>
       *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
       *   For more information, see
       *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
       *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
       */
<span class="udiff-line-modified-removed">-     @Deprecated(since=&quot;1.2&quot;)</span>
<span class="udiff-line-modified-added">+     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
      public final void suspend() {
          checkAccess();
          suspend0();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1104,11 +1099,11 @@</span>
       *     which has been deprecated because it is deadlock-prone.
       *     For more information, see
       *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
       *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
       */
<span class="udiff-line-modified-removed">-     @Deprecated(since=&quot;1.2&quot;)</span>
<span class="udiff-line-modified-added">+     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
      public final void resume() {
          checkAccess();
          resume0();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1254,24 +1249,24 @@</span>
      public static int enumerate(Thread tarray[]) {
          return currentThread().getThreadGroup().enumerate(tarray);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Counts the number of stack frames in this thread. The thread must</span>
<span class="udiff-line-removed">-      * be suspended.</span>
<span class="udiff-line-modified-added">+      * Throws {@code UnsupportedOperationException}.</span>
       *
<span class="udiff-line-modified-removed">-      * @return     the number of stack frames in this thread.</span>
<span class="udiff-line-modified-removed">-      * @throws     IllegalThreadStateException  if this thread is not</span>
<span class="udiff-line-modified-removed">-      *             suspended.</span>
<span class="udiff-line-modified-removed">-      * @deprecated The definition of this call depends on {@link #suspend},</span>
<span class="udiff-line-modified-removed">-      *             which is deprecated.  Further, the results of this call</span>
<span class="udiff-line-removed">-      *             were never well-defined.</span>
<span class="udiff-line-modified-added">+      * @return     nothing</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @deprecated This method was originally designed to count the number of</span>
<span class="udiff-line-modified-added">+      *             stack frames but the results were never well-defined and it</span>
<span class="udiff-line-modified-added">+      *             depended on thread-suspension.</span>
       *             This method is subject to removal in a future version of Java SE.
       * @see        StackWalker
       */
      @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
<span class="udiff-line-modified-removed">-     public native int countStackFrames();</span>
<span class="udiff-line-modified-added">+     public int countStackFrames() {</span>
<span class="udiff-line-added">+         throw new UnsupportedOperationException();</span>
<span class="udiff-line-added">+     }</span>
  
      /**
       * Waits at most {@code millis} milliseconds for this thread to
       * die. A timeout of {@code 0} means to wait forever.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2083,7 +2078,8 @@</span>
      private native void setPriority0(int newPriority);
      private native void stop0(Object o);
      private native void suspend0();
      private native void resume0();
      private native void interrupt0();
<span class="udiff-line-added">+     private static native void clearInterruptEvent();</span>
      private native void setNativeName(String name);
  }
</pre>
<center><a href="System.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ThreadDeath.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
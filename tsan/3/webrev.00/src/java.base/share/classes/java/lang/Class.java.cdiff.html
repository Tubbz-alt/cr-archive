<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CharacterName.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassCastException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 44,11 ---</span>
  import java.lang.reflect.InvocationTargetException;
  import java.lang.reflect.Member;
  import java.lang.reflect.Method;
  import java.lang.reflect.Modifier;
  import java.lang.reflect.Proxy;
<span class="line-added">+ import java.lang.reflect.RecordComponent;</span>
  import java.lang.reflect.Type;
  import java.lang.reflect.TypeVariable;
  import java.lang.constant.Constable;
  import java.net.URL;
  import java.security.AccessController;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,20 ***</span>
  import sun.security.util.SecurityConstants;
  import sun.reflect.annotation.*;
  import sun.reflect.misc.ReflectUtil;
  
  /**
<span class="line-modified">!  * Instances of the class {@code Class} represent classes and interfaces</span>
<span class="line-modified">!  * in a running Java application. An enum type is a kind of class and an</span>
<span class="line-modified">!  * annotation type is a kind of interface. Every array also</span>
<span class="line-modified">!  * belongs to a class that is reflected as a {@code Class} object</span>
<span class="line-modified">!  * that is shared by all arrays with the same element type and number</span>
<span class="line-modified">!  * of dimensions.  The primitive Java types ({@code boolean},</span>
<span class="line-modified">!  * {@code byte}, {@code char}, {@code short},</span>
<span class="line-modified">!  * {@code int}, {@code long}, {@code float}, and</span>
<span class="line-modified">!  * {@code double}), and the keyword {@code void} are also</span>
<span class="line-removed">-  * represented as {@code Class} objects.</span>
   *
   * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
   * object is constructed automatically by the Java Virtual Machine
   * when a class loader invokes one of the
   * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
<span class="line-new-header">--- 87,19 ---</span>
  import sun.security.util.SecurityConstants;
  import sun.reflect.annotation.*;
  import sun.reflect.misc.ReflectUtil;
  
  /**
<span class="line-modified">!  * Instances of the class {@code Class} represent classes and</span>
<span class="line-modified">!  * interfaces in a running Java application. An enum type and a record</span>
<span class="line-modified">!  * type are kinds of class; an annotation type is a kind of</span>
<span class="line-modified">!  * interface. Every array also belongs to a class that is reflected as</span>
<span class="line-modified">!  * a {@code Class} object that is shared by all arrays with the same</span>
<span class="line-modified">!  * element type and number of dimensions.  The primitive Java types</span>
<span class="line-modified">!  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code</span>
<span class="line-modified">!  * int}, {@code long}, {@code float}, and {@code double}), and the</span>
<span class="line-modified">!  * keyword {@code void} are also represented as {@code Class} objects.</span>
   *
   * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
   * object is constructed automatically by the Java Virtual Machine
   * when a class loader invokes one of the
   * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,12 ***</span>
       * Returns a string describing this {@code Class}, including
       * information about modifiers and type parameters.
       *
       * The string is formatted as a list of type modifiers, if any,
       * followed by the kind of type (empty string for primitive types
<span class="line-modified">!      * and {@code class}, {@code enum}, {@code interface}, or</span>
<span class="line-modified">!      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, as appropriate), followed</span>
       * by the type&#39;s name, followed by an angle-bracketed
       * comma-separated list of the type&#39;s type parameters, if any,
       * including informative bounds on the type parameters, if any.
       *
       * A space is used to separate modifiers from one another and to
<span class="line-new-header">--- 204,12 ---</span>
       * Returns a string describing this {@code Class}, including
       * information about modifiers and type parameters.
       *
       * The string is formatted as a list of type modifiers, if any,
       * followed by the kind of type (empty string for primitive types
<span class="line-modified">!      * and {@code class}, {@code enum}, {@code interface},</span>
<span class="line-modified">!      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed</span>
       * by the type&#39;s name, followed by an angle-bracketed
       * comma-separated list of the type&#39;s type parameters, if any,
       * including informative bounds on the type parameters, if any.
       *
       * A space is used to separate modifiers from one another and to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,10 ***</span>
<span class="line-new-header">--- 231,11 ---</span>
       * @return a string describing this {@code Class}, including
       * information about modifiers and type parameters
       *
       * @since 1.8
       */
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public String toGenericString() {
          if (isPrimitive()) {
              return toString();
          } else {
              StringBuilder sb = new StringBuilder();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,10 ***</span>
<span class="line-new-header">--- 262,12 ---</span>
                  if (isInterface()) { // Note: all annotation types are interfaces
                      sb.append(&quot;interface&quot;);
                  } else {
                      if (isEnum())
                          sb.append(&quot;enum&quot;);
<span class="line-added">+                     else if (isRecord())</span>
<span class="line-added">+                         sb.append(&quot;record&quot;);</span>
                      else
                          sb.append(&quot;class&quot;);
                  }
                  sb.append(&#39; &#39;);
                  sb.append(getName());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,12 ***</span>
                  sb.append(Arrays.stream(typeparms)
                            .map(Class::typeVarBounds)
                            .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
              }
  
<span class="line-modified">!             for (int i = 0; i &lt; arrayDepth; i++)</span>
<span class="line-removed">-                 sb.append(&quot;[]&quot;);</span>
  
              return sb.toString();
          }
      }
  
<span class="line-new-header">--- 278,11 ---</span>
                  sb.append(Arrays.stream(typeparms)
                            .map(Class::typeVarBounds)
                            .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
              }
  
<span class="line-modified">!             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));</span>
  
              return sb.toString();
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,14 ***</span>
       * {@code X} to be initialized.
       *
       * @param      className   the fully qualified name of the desired class.
       * @return     the {@code Class} object for the class with the
       *             specified name.
<span class="line-modified">!      * @exception LinkageError if the linkage fails</span>
<span class="line-modified">!      * @exception ExceptionInInitializerError if the initialization provoked</span>
       *            by this method fails
<span class="line-modified">!      * @exception ClassNotFoundException if the class cannot be located</span>
       */
      @CallerSensitive
      public static Class&lt;?&gt; forName(String className)
                  throws ClassNotFoundException {
          Class&lt;?&gt; caller = Reflection.getCallerClass();
<span class="line-new-header">--- 322,18 ---</span>
       * {@code X} to be initialized.
       *
       * @param      className   the fully qualified name of the desired class.
       * @return     the {@code Class} object for the class with the
       *             specified name.
<span class="line-modified">!      * @throws    LinkageError if the linkage fails</span>
<span class="line-modified">!      * @throws    ExceptionInInitializerError if the initialization provoked</span>
       *            by this method fails
<span class="line-modified">!      * @throws    ClassNotFoundException if the class cannot be located</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @jls 12.2 Loading of Classes and Interfaces</span>
<span class="line-added">+      * @jls 12.3 Linking of Classes and Interfaces</span>
<span class="line-added">+      * @jls 12.4 Initialization of Classes and Interfaces</span>
       */
      @CallerSensitive
      public static Class&lt;?&gt; forName(String className)
                  throws ClassNotFoundException {
          Class&lt;?&gt; caller = Reflection.getCallerClass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,11 ***</span>
      /**
       * Returns the {@code Class} object associated with the class or
       * interface with the given string name, using the given class loader.
       * Given the fully qualified name for a class or interface (in the same
       * format returned by {@code getName}) this method attempts to
<span class="line-modified">!      * locate, load, and link the class or interface.  The specified class</span>
       * loader is used to load the class or interface.  If the parameter
       * {@code loader} is null, the class is loaded through the bootstrap
       * class loader.  The class is initialized only if the
       * {@code initialize} parameter is {@code true} and if it has
       * not been initialized earlier.
<span class="line-new-header">--- 344,11 ---</span>
      /**
       * Returns the {@code Class} object associated with the class or
       * interface with the given string name, using the given class loader.
       * Given the fully qualified name for a class or interface (in the same
       * format returned by {@code getName}) this method attempts to
<span class="line-modified">!      * locate and load the class or interface.  The specified class</span>
       * loader is used to load the class or interface.  If the parameter
       * {@code loader} is null, the class is loaded through the bootstrap
       * class loader.  The class is initialized only if the
       * {@code initialize} parameter is {@code true} and if it has
       * not been initialized earlier.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,35 ***</span>
       *
       * &lt;blockquote&gt;
       *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
       * &lt;/blockquote&gt;
       *
<span class="line-modified">!      * Note that this method throws errors related to loading, linking or</span>
<span class="line-modified">!      * initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The</span>
<span class="line-modified">!      * Java Language Specification&lt;/em&gt;.</span>
       * Note that this method does not check whether the requested class
       * is accessible to its caller.
       *
       * @param name       fully qualified name of the desired class
<span class="line-modified">!      * @param initialize if {@code true} the class will be initialized.</span>
<span class="line-modified">!      *                   See Section 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>
       * @param loader     class loader from which the class must be loaded
       * @return           class object representing the desired class
       *
<span class="line-modified">!      * @exception LinkageError if the linkage fails</span>
<span class="line-modified">!      * @exception ExceptionInInitializerError if the initialization provoked</span>
       *            by this method fails
<span class="line-modified">!      * @exception ClassNotFoundException if the class cannot be located by</span>
       *            the specified class loader
<span class="line-modified">!      * @exception SecurityException</span>
       *            if a security manager is present, and the {@code loader} is
       *            {@code null}, and the caller&#39;s class loader is not
       *            {@code null}, and the caller does not have the
       *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
       *
       * @see       java.lang.Class#forName(String)
       * @see       java.lang.ClassLoader
       * @since     1.2
       */
      @CallerSensitive
      public static Class&lt;?&gt; forName(String name, boolean initialize,
                                     ClassLoader loader)
<span class="line-new-header">--- 372,40 ---</span>
       *
       * &lt;blockquote&gt;
       *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
       * &lt;/blockquote&gt;
       *
<span class="line-modified">!      * Note that this method throws errors related to loading, linking</span>
<span class="line-modified">!      * or initializing as specified in Sections {@jls 12.2}, {@jls</span>
<span class="line-modified">!      * 12.3}, and {@jls 12.4} of &lt;em&gt;The Java Language</span>
<span class="line-added">+      * Specification&lt;/em&gt;.</span>
       * Note that this method does not check whether the requested class
       * is accessible to its caller.
       *
       * @param name       fully qualified name of the desired class
<span class="line-modified">!      * @param initialize if {@code true} the class will be initialized (which implies linking).</span>
<span class="line-modified">!      *                   See Section {@jls 12.4} of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>
       * @param loader     class loader from which the class must be loaded
       * @return           class object representing the desired class
       *
<span class="line-modified">!      * @throws    LinkageError if the linkage fails</span>
<span class="line-modified">!      * @throws    ExceptionInInitializerError if the initialization provoked</span>
       *            by this method fails
<span class="line-modified">!      * @throws    ClassNotFoundException if the class cannot be located by</span>
       *            the specified class loader
<span class="line-modified">!      * @throws    SecurityException</span>
       *            if a security manager is present, and the {@code loader} is
       *            {@code null}, and the caller&#39;s class loader is not
       *            {@code null}, and the caller does not have the
       *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
       *
       * @see       java.lang.Class#forName(String)
       * @see       java.lang.ClassLoader
<span class="line-added">+      *</span>
<span class="line-added">+      * @jls 12.2 Loading of Classes and Interfaces</span>
<span class="line-added">+      * @jls 12.3 Linking of Classes and Interfaces</span>
<span class="line-added">+      * @jls 12.4 Initialization of Classes and Interfaces</span>
       * @since     1.2
       */
      @CallerSensitive
      public static Class&lt;?&gt; forName(String name, boolean initialize,
                                     ClassLoader loader)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,13 ***</span>
  
      /**
       * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
       * binary name&lt;/a&gt; in the given module.
       *
<span class="line-modified">!      * &lt;p&gt; This method attempts to locate, load, and link the class or interface.</span>
<span class="line-modified">!      * It does not run the class initializer.  If the class is not found, this</span>
<span class="line-modified">!      * method returns {@code null}. &lt;/p&gt;</span>
       *
       * &lt;p&gt; If the class loader of the given module defines other modules and
       * the given name is a class defined in a different module, this method
       * returns {@code null} after the class is loaded. &lt;/p&gt;
       *
<span class="line-new-header">--- 437,13 ---</span>
  
      /**
       * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
       * binary name&lt;/a&gt; in the given module.
       *
<span class="line-modified">!      * &lt;p&gt; This method attempts to locate and load the class or interface.</span>
<span class="line-modified">!      * It does not link the class, and does not run the class initializer.</span>
<span class="line-modified">!      * If the class is not found, this method returns {@code null}. &lt;/p&gt;</span>
       *
       * &lt;p&gt; If the class loader of the given module defines other modules and
       * the given name is a class defined in a different module, this method
       * returns {@code null} after the class is loaded. &lt;/p&gt;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,10 ***</span>
<span class="line-new-header">--- 475,12 ---</span>
       *         permission check will be performed when a class loader calls
       *         {@link ModuleReader#open(String)} to read the bytes of a class file
       *         in a module.&lt;/li&gt;
       *         &lt;/ul&gt;
       *
<span class="line-added">+      * @jls 12.2 Loading of Classes and Interfaces</span>
<span class="line-added">+      * @jls 12.3 Linking of Classes and Interfaces</span>
       * @since 9
       * @spec JPMS
       */
      @CallerSensitive
      public static Class&lt;?&gt; forName(Module module, String name) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,18 ***</span>
       *
       * &lt;p&gt; Specifically, this method tests whether the type represented by the
       * specified {@code Class} parameter can be converted to the type
       * represented by this {@code Class} object via an identity conversion
       * or via a widening reference conversion. See &lt;em&gt;The Java Language
<span class="line-modified">!      * Specification&lt;/em&gt;, sections 5.1.1 and 5.1.4 , for details.</span>
       *
<span class="line-modified">!      * @param cls the {@code Class} object to be checked</span>
<span class="line-modified">!      * @return the {@code boolean} value indicating whether objects of the</span>
<span class="line-modified">!      * type {@code cls} can be assigned to objects of this class</span>
<span class="line-modified">!      * @exception NullPointerException if the specified Class parameter is</span>
       *            null.
<span class="line-modified">!      * @since 1.1</span>
       */
      @HotSpotIntrinsicCandidate
      public native boolean isAssignableFrom(Class&lt;?&gt; cls);
  
  
<span class="line-new-header">--- 659,19 ---</span>
       *
       * &lt;p&gt; Specifically, this method tests whether the type represented by the
       * specified {@code Class} parameter can be converted to the type
       * represented by this {@code Class} object via an identity conversion
       * or via a widening reference conversion. See &lt;em&gt;The Java Language
<span class="line-modified">!      * Specification&lt;/em&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
<span class="line-added">+      * for details.</span>
       *
<span class="line-modified">!      * @param     cls the {@code Class} object to be checked</span>
<span class="line-modified">!      * @return    the {@code boolean} value indicating whether objects of the</span>
<span class="line-modified">!      *            type {@code cls} can be assigned to objects of this class</span>
<span class="line-modified">!      * @throws    NullPointerException if the specified Class parameter is</span>
       *            null.
<span class="line-modified">!      * @since     1.1</span>
       */
      @HotSpotIntrinsicCandidate
      public native boolean isAssignableFrom(Class&lt;?&gt; cls);
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,11 ***</span>
       * the entity (class, interface, primitive type or void) represented by
       * this {@code Class}.
       *
       * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
       * object returned must accurately reflect the actual type
<span class="line-modified">!      * parameters used in the source code. The parameterized type</span>
       * representing the superclass is created if it had not been
       * created before. See the declaration of {@link
       * java.lang.reflect.ParameterizedType ParameterizedType} for the
       * semantics of the creation process for parameterized types.  If
       * this {@code Class} represents either the {@code Object}
<span class="line-new-header">--- 930,11 ---</span>
       * the entity (class, interface, primitive type or void) represented by
       * this {@code Class}.
       *
       * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
       * object returned must accurately reflect the actual type
<span class="line-modified">!      * arguments used in the source code. The parameterized type</span>
       * representing the superclass is created if it had not been
       * created before. See the declaration of {@link
       * java.lang.reflect.ParameterizedType ParameterizedType} for the
       * semantics of the creation process for parameterized types.  If
       * this {@code Class} represents either the {@code Object}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 998,11 ***</span>
       *
       * @return the fully qualified package name
       *
       * @since 9
       * @spec JPMS
<span class="line-modified">!      * @jls 6.7  Fully Qualified Names</span>
       */
      public String getPackageName() {
          String pn = this.packageName;
          if (pn == null) {
              Class&lt;?&gt; c = this;
<span class="line-new-header">--- 1012,11 ---</span>
       *
       * @return the fully qualified package name
       *
       * @since 9
       * @spec JPMS
<span class="line-modified">!      * @jls 6.7 Fully Qualified Names</span>
       */
      public String getPackageName() {
          String pn = this.packageName;
          if (pn == null) {
              Class&lt;?&gt; c = this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,11 ***</span>
       * directly implemented by the class or interface represented by
       * this object.
       *
       * &lt;p&gt;If a superinterface is a parameterized type, the
       * {@code Type} object returned for it must accurately reflect
<span class="line-modified">!      * the actual type parameters used in the source code. The</span>
       * parameterized type representing each superinterface is created
       * if it had not been created before. See the declaration of
       * {@link java.lang.reflect.ParameterizedType ParameterizedType}
       * for the semantics of the creation process for parameterized
       * types.
<span class="line-new-header">--- 1110,11 ---</span>
       * directly implemented by the class or interface represented by
       * this object.
       *
       * &lt;p&gt;If a superinterface is a parameterized type, the
       * {@code Type} object returned for it must accurately reflect
<span class="line-modified">!      * the actual type arguments used in the source code. The</span>
       * parameterized type representing each superinterface is created
       * if it had not been created before. See the declaration of
       * {@link java.lang.reflect.ParameterizedType ParameterizedType}
       * for the semantics of the creation process for parameterized
       * types.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1493,11 ***</span>
      /**
       * Returns the immediately enclosing class of the underlying
       * class.  If the underlying class is a top level class this
       * method returns {@code null}.
       * @return the immediately enclosing class of the underlying class
<span class="line-modified">!      * @exception  SecurityException</span>
       *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
       *             class loader is not the same as or an ancestor of the class
       *             loader for the enclosing class and invocation of {@link
       *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
       *             denies access to the package of the enclosing class
<span class="line-new-header">--- 1507,11 ---</span>
      /**
       * Returns the immediately enclosing class of the underlying
       * class.  If the underlying class is a top level class this
       * method returns {@code null}.
       * @return the immediately enclosing class of the underlying class
<span class="line-modified">!      * @throws     SecurityException</span>
       *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
       *             class loader is not the same as or an ancestor of the class
       *             loader for the enclosing class and invocation of {@link
       *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
       *             denies access to the package of the enclosing class
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1587,16 ***</span>
                  int dimensions = 0;
                  do {
                      dimensions++;
                      cl = cl.getComponentType();
                  } while (cl.isArray());
<span class="line-modified">!                 StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">-                 sb.append(cl.getName());</span>
<span class="line-removed">-                 for (int i = 0; i &lt; dimensions; i++) {</span>
<span class="line-removed">-                     sb.append(&quot;[]&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return sb.toString();</span>
              } catch (Throwable e) { /*FALLTHRU*/ }
          }
          return getName();
      }
  
<span class="line-new-header">--- 1601,11 ---</span>
                  int dimensions = 0;
                  do {
                      dimensions++;
                      cl = cl.getComponentType();
                  } while (cl.isArray());
<span class="line-modified">!                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);</span>
              } catch (Throwable e) { /*FALLTHRU*/ }
          }
          return getName();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2253,10 ***</span>
<span class="line-new-header">--- 2262,74 ---</span>
              checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
          }
          return copyFields(privateGetDeclaredFields(false));
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * {@preview Associated with records, a preview feature of the Java language.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview</span>
<span class="line-added">+      *           feature of the Java language. Preview features</span>
<span class="line-added">+      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">+      *           features of the Java language.}</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Returns an array of {@code RecordComponent} objects representing all the</span>
<span class="line-added">+      * record components of this record class, or {@code null} if this class is</span>
<span class="line-added">+      * not a record class.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt; The components are returned in the same order that they are declared</span>
<span class="line-added">+      * in the record header. The array is empty if this record class has no</span>
<span class="line-added">+      * components. If the class is not a record class, that is {@link</span>
<span class="line-added">+      * #isRecord()} returns {@code false}, then this method returns {@code null}.</span>
<span class="line-added">+      * Conversely, if {@link #isRecord()} returns {@code true}, then this method</span>
<span class="line-added">+      * returns a non-null value.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return  An array of {@code RecordComponent} objects representing all the</span>
<span class="line-added">+      *          record components of this record class, or {@code null} if this</span>
<span class="line-added">+      *          class is not a record class</span>
<span class="line-added">+      * @throws  SecurityException</span>
<span class="line-added">+      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the</span>
<span class="line-added">+      *          following conditions is met:</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *          &lt;ul&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *          &lt;li&gt; the caller&#39;s class loader is not the same as the</span>
<span class="line-added">+      *          class loader of this class and invocation of</span>
<span class="line-added">+      *          {@link SecurityManager#checkPermission</span>
<span class="line-added">+      *          s.checkPermission} method with</span>
<span class="line-added">+      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}</span>
<span class="line-added">+      *          denies access to the declared methods within this class</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an</span>
<span class="line-added">+      *          ancestor of the class loader for the current class and</span>
<span class="line-added">+      *          invocation of {@link SecurityManager#checkPackageAccess</span>
<span class="line-added">+      *          s.checkPackageAccess()} denies access to the package</span>
<span class="line-added">+      *          of this class</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *          &lt;/ul&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @jls 8.10 Record Types</span>
<span class="line-added">+      * @since 14</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,</span>
<span class="line-added">+                                  essentialAPI=false)</span>
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     @CallerSensitive</span>
<span class="line-added">+     public RecordComponent[] getRecordComponents() {</span>
<span class="line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+         if (sm != null) {</span>
<span class="line-added">+             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!isRecord()) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         RecordComponent[] recordComponents = getRecordComponents0();</span>
<span class="line-added">+         if (recordComponents == null) {</span>
<span class="line-added">+             return new RecordComponent[0];</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return recordComponents;</span>
<span class="line-added">+     }</span>
  
      /**
       * Returns an array containing {@code Method} objects reflecting all the
       * declared methods of the class or interface represented by this {@code
       * Class} object, including public, protected, default (package)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2326,11 ***</span>
       * class has a default constructor, it is included in the returned array.
       * This method returns an array of length 0 if this {@code Class}
       * object represents an interface, a primitive type, an array class, or
       * void.
       *
<span class="line-modified">!      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.</span>
       *
       * @return  the array of {@code Constructor} objects representing all the
       *          declared constructors of this class
       * @throws  SecurityException
       *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
<span class="line-new-header">--- 2399,11 ---</span>
       * class has a default constructor, it is included in the returned array.
       * This method returns an array of length 0 if this {@code Class}
       * object represents an interface, a primitive type, an array class, or
       * void.
       *
<span class="line-modified">!      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section {@jls 8.2}.</span>
       *
       * @return  the array of {@code Constructor} objects representing all the
       *          declared constructors of this class
       * @throws  SecurityException
       *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3411,27 ***</span>
  
      private native Field[]       getDeclaredFields0(boolean publicOnly);
      private native Method[]      getDeclaredMethods0(boolean publicOnly);
      private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
      private native Class&lt;?&gt;[]   getDeclaredClasses0();
  
      /**
       * Helper method to get the method name from arguments.
       */
      private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
<span class="line-modified">!         StringBuilder sb = new StringBuilder();</span>
<span class="line-modified">!         sb.append(getName() + &quot;.&quot; + name + &quot;(&quot;);</span>
<span class="line-modified">!         if (argTypes != null) {</span>
<span class="line-modified">!             sb.append(Arrays.stream(argTypes)</span>
<span class="line-modified">!                       .map(c -&gt; (c == null) ? &quot;null&quot; : c.getName())</span>
<span class="line-modified">!                       .collect(Collectors.joining(&quot;,&quot;)));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         sb.append(&quot;)&quot;);</span>
<span class="line-removed">-         return sb.toString();</span>
      }
  
      /** use serialVersionUID from JDK 1.1 for interoperability */
      private static final long serialVersionUID = 3206093459760846163L;
  
  
      /**
       * Class Class is special cased within the Serialization Stream Protocol.
<span class="line-new-header">--- 3484,28 ---</span>
  
      private native Field[]       getDeclaredFields0(boolean publicOnly);
      private native Method[]      getDeclaredMethods0(boolean publicOnly);
      private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
      private native Class&lt;?&gt;[]   getDeclaredClasses0();
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private native RecordComponent[] getRecordComponents0();</span>
<span class="line-added">+     private native boolean      isRecord0();</span>
  
      /**
       * Helper method to get the method name from arguments.
       */
      private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
<span class="line-modified">!         return getName() + &#39;.&#39; + name +</span>
<span class="line-modified">!                 ((argTypes == null || argTypes.length == 0) ?</span>
<span class="line-modified">!                 &quot;()&quot; :</span>
<span class="line-modified">!                 Arrays.stream(argTypes)</span>
<span class="line-modified">!                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())</span>
<span class="line-modified">!                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));</span>
      }
  
      /** use serialVersionUID from JDK 1.1 for interoperability */
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 3206093459760846163L;
  
  
      /**
       * Class Class is special cased within the Serialization Stream Protocol.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3447,10 ***</span>
<span class="line-new-header">--- 3521,11 ---</span>
       * is written into the stream. Future references to the class descriptor
       * are written as references to the initial class descriptor instance.
       *
       * @see java.io.ObjectStreamClass
       */
<span class="line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields =
          new ObjectStreamField[0];
  
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3498,22 ***</span>
<span class="line-new-header">--- 3573,70 ---</span>
  
      /**
       * Returns true if and only if this class was declared as an enum in the
       * source code.
       *
<span class="line-added">+      * Note that {@link java.lang.Enum} is not itself an enum type.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Also note that if an enum constant is declared with a class body,</span>
<span class="line-added">+      * the class of that enum constant object is an anonymous class</span>
<span class="line-added">+      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The</span>
<span class="line-added">+      * {@link Enum#getDeclaringClass} method of an enum constant can</span>
<span class="line-added">+      * be used to get the class of the enum type declaring the</span>
<span class="line-added">+      * constant.</span>
<span class="line-added">+      *</span>
       * @return true if and only if this class was declared as an enum in the
       *     source code
       * @since 1.5
<span class="line-added">+      * @jls 8.9.1 Enum Constants</span>
       */
      public boolean isEnum() {
          // An enum must both directly extend java.lang.Enum and have
          // the ENUM bit set; classes for specialized enum constants
          // don&#39;t do the former.
          return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
          this.getSuperclass() == java.lang.Enum.class;
      }
  
<span class="line-added">+     /** java.lang.Record.class */</span>
<span class="line-added">+     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();</span>
<span class="line-added">+     private static Class&lt;?&gt; javaLangRecordClass() {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);</span>
<span class="line-added">+         } catch (ClassNotFoundException e) {</span>
<span class="line-added">+             throw new InternalError(&quot;should not reach here&quot;, e);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * {@preview Associated with records, a preview feature of the Java language.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview</span>
<span class="line-added">+      *           feature of the Java language. Preview features</span>
<span class="line-added">+      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">+      *           features of the Java language.}</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Returns {@code true} if and only if this class is a record class.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record</span>
<span class="line-added">+      * class is {@code java.lang.Record}. A record class has (possibly zero)</span>
<span class="line-added">+      * record components, that is, {@link #getRecordComponents()} returns a</span>
<span class="line-added">+      * non-null value.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking</span>
<span class="line-added">+      * this method on class {@code Record} returns {@code false}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if and only if this class is a record class, otherwise false</span>
<span class="line-added">+      * @jls 8.10 Record Types</span>
<span class="line-added">+      * @since 14</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,</span>
<span class="line-added">+                                  essentialAPI=false)</span>
<span class="line-added">+     public boolean isRecord() {</span>
<span class="line-added">+         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Fetches the factory for reflective objects
      private static ReflectionFactory getReflectionFactory() {
          if (reflectionFactory == null) {
              reflectionFactory =
                  java.security.AccessController.doPrivileged
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3917,11 ***</span>
       *         class loader is not the same as or an ancestor of the class
       *         loader for the returned class and invocation of {@link
       *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
       *         denies access to the package of the returned class
       * @since 11
<span class="line-modified">!      * @jvms 4.7.28 and 4.7.29 NestHost and NestMembers attributes</span>
       * @jvms 5.4.4 Access Control
       */
      @CallerSensitive
      public Class&lt;?&gt; getNestHost() {
          if (isPrimitive() || isArray()) {
<span class="line-new-header">--- 4040,12 ---</span>
       *         class loader is not the same as or an ancestor of the class
       *         loader for the returned class and invocation of {@link
       *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
       *         denies access to the package of the returned class
       * @since 11
<span class="line-modified">!      * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="line-added">+      * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
       * @jvms 5.4.4 Access Control
       */
      @CallerSensitive
      public Class&lt;?&gt; getNestHost() {
          if (isPrimitive() || isArray()) {
</pre>
<center><a href="CharacterName.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassCastException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
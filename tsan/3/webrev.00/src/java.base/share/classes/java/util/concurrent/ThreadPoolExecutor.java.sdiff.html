<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/ThreadPoolExecutor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadLocalRandom.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="atomic/AtomicInteger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/ThreadPoolExecutor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 587      * instead interrupting a task being run.  We implement a simple
 588      * non-reentrant mutual exclusion lock rather than use
 589      * ReentrantLock because we do not want worker tasks to be able to
 590      * reacquire the lock when they invoke pool control methods like
 591      * setCorePoolSize.  Additionally, to suppress interrupts until
 592      * the thread actually starts running tasks, we initialize lock
 593      * state to a negative value, and clear it upon start (in
 594      * runWorker).
 595      */
 596     private final class Worker
 597         extends AbstractQueuedSynchronizer
 598         implements Runnable
 599     {
 600         /**
 601          * This class will never be serialized, but we provide a
 602          * serialVersionUID to suppress a javac warning.
 603          */
 604         private static final long serialVersionUID = 6138294804551838833L;
 605 
 606         /** Thread this worker is running in.  Null if factory fails. */

 607         final Thread thread;
 608         /** Initial task to run.  Possibly null. */

 609         Runnable firstTask;
 610         /** Per-thread task counter */
 611         volatile long completedTasks;
 612 
 613         // TODO: switch to AbstractQueuedLongSynchronizer and move
 614         // completedTasks into the lock word.
 615 
 616         /**
 617          * Creates with given first task and thread from ThreadFactory.
 618          * @param firstTask the first task (null if none)
 619          */
 620         Worker(Runnable firstTask) {
 621             setState(-1); // inhibit interrupts until runWorker
 622             this.firstTask = firstTask;
 623             this.thread = getThreadFactory().newThread(this);
 624         }
 625 
 626         /** Delegates main run loop to outer runWorker. */
 627         public void run() {
 628             runWorker(this);
</pre>
<hr />
<pre>
 905             }
 906         }
 907 
 908         boolean workerStarted = false;
 909         boolean workerAdded = false;
 910         Worker w = null;
 911         try {
 912             w = new Worker(firstTask);
 913             final Thread t = w.thread;
 914             if (t != null) {
 915                 final ReentrantLock mainLock = this.mainLock;
 916                 mainLock.lock();
 917                 try {
 918                     // Recheck while holding lock.
 919                     // Back out on ThreadFactory failure or if
 920                     // shut down before lock acquired.
 921                     int c = ctl.get();
 922 
 923                     if (isRunning(c) ||
 924                         (runStateLessThan(c, STOP) &amp;&amp; firstTask == null)) {
<span class="line-modified"> 925                         if (t.isAlive()) // precheck that t is startable</span>
 926                             throw new IllegalThreadStateException();
 927                         workers.add(w);

 928                         int s = workers.size();
 929                         if (s &gt; largestPoolSize)
 930                             largestPoolSize = s;
<span class="line-removed"> 931                         workerAdded = true;</span>
 932                     }
 933                 } finally {
 934                     mainLock.unlock();
 935                 }
 936                 if (workerAdded) {
 937                     t.start();
 938                     workerStarted = true;
 939                 }
 940             }
 941         } finally {
 942             if (! workerStarted)
 943                 addWorkerFailed(w);
 944         }
 945         return workerStarted;
 946     }
 947 
 948     /**
 949      * Rolls back the worker thread creation.
 950      * - removes worker from workers, if present
 951      * - decrements worker count
</pre>
</td>
<td>
<hr />
<pre>
 587      * instead interrupting a task being run.  We implement a simple
 588      * non-reentrant mutual exclusion lock rather than use
 589      * ReentrantLock because we do not want worker tasks to be able to
 590      * reacquire the lock when they invoke pool control methods like
 591      * setCorePoolSize.  Additionally, to suppress interrupts until
 592      * the thread actually starts running tasks, we initialize lock
 593      * state to a negative value, and clear it upon start (in
 594      * runWorker).
 595      */
 596     private final class Worker
 597         extends AbstractQueuedSynchronizer
 598         implements Runnable
 599     {
 600         /**
 601          * This class will never be serialized, but we provide a
 602          * serialVersionUID to suppress a javac warning.
 603          */
 604         private static final long serialVersionUID = 6138294804551838833L;
 605 
 606         /** Thread this worker is running in.  Null if factory fails. */
<span class="line-added"> 607         @SuppressWarnings(&quot;serial&quot;) // Unlikely to be serializable</span>
 608         final Thread thread;
 609         /** Initial task to run.  Possibly null. */
<span class="line-added"> 610         @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 611         Runnable firstTask;
 612         /** Per-thread task counter */
 613         volatile long completedTasks;
 614 
 615         // TODO: switch to AbstractQueuedLongSynchronizer and move
 616         // completedTasks into the lock word.
 617 
 618         /**
 619          * Creates with given first task and thread from ThreadFactory.
 620          * @param firstTask the first task (null if none)
 621          */
 622         Worker(Runnable firstTask) {
 623             setState(-1); // inhibit interrupts until runWorker
 624             this.firstTask = firstTask;
 625             this.thread = getThreadFactory().newThread(this);
 626         }
 627 
 628         /** Delegates main run loop to outer runWorker. */
 629         public void run() {
 630             runWorker(this);
</pre>
<hr />
<pre>
 907             }
 908         }
 909 
 910         boolean workerStarted = false;
 911         boolean workerAdded = false;
 912         Worker w = null;
 913         try {
 914             w = new Worker(firstTask);
 915             final Thread t = w.thread;
 916             if (t != null) {
 917                 final ReentrantLock mainLock = this.mainLock;
 918                 mainLock.lock();
 919                 try {
 920                     // Recheck while holding lock.
 921                     // Back out on ThreadFactory failure or if
 922                     // shut down before lock acquired.
 923                     int c = ctl.get();
 924 
 925                     if (isRunning(c) ||
 926                         (runStateLessThan(c, STOP) &amp;&amp; firstTask == null)) {
<span class="line-modified"> 927                         if (t.getState() != Thread.State.NEW)</span>
 928                             throw new IllegalThreadStateException();
 929                         workers.add(w);
<span class="line-added"> 930                         workerAdded = true;</span>
 931                         int s = workers.size();
 932                         if (s &gt; largestPoolSize)
 933                             largestPoolSize = s;

 934                     }
 935                 } finally {
 936                     mainLock.unlock();
 937                 }
 938                 if (workerAdded) {
 939                     t.start();
 940                     workerStarted = true;
 941                 }
 942             }
 943         } finally {
 944             if (! workerStarted)
 945                 addWorkerFailed(w);
 946         }
 947         return workerStarted;
 948     }
 949 
 950     /**
 951      * Rolls back the worker thread creation.
 952      * - removes worker from workers, if present
 953      * - decrements worker count
</pre>
</td>
</tr>
</table>
<center><a href="ThreadLocalRandom.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="atomic/AtomicInteger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
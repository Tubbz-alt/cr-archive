<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangInvokeAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.reflect.CallerSensitive;
  34 import jdk.internal.reflect.Reflection;
  35 import jdk.internal.vm.annotation.ForceInline;
  36 import jdk.internal.vm.annotation.Hidden;
  37 import jdk.internal.vm.annotation.Stable;
  38 import sun.invoke.empty.Empty;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyType;
  41 import sun.invoke.util.Wrapper;
  42 
  43 import java.lang.reflect.Array;

  44 import java.util.Arrays;
  45 import java.util.Collections;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.function.Function;
  51 import java.util.stream.Stream;
  52 
  53 import static java.lang.invoke.LambdaForm.*;
  54 import static java.lang.invoke.MethodHandleStatics.*;
  55 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  56 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  57 
  58 /**
  59  * Trusted implementation code for MethodHandle.
  60  * @author jrose
  61  */
<span class="line-modified">  62 /*non-public*/ abstract class MethodHandleImpl {</span>

  63 
  64     /// Factory methods to create method handles:
  65 
  66     static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
  67         if (arrayClass == Object[].class) {
  68             return ArrayAccess.objectAccessor(access);
  69         }
  70         if (!arrayClass.isArray())
  71             throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
  72         MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
  73         int cacheIndex = ArrayAccess.cacheIndex(access);
  74         MethodHandle mh = cache[cacheIndex];
  75         if (mh != null)  return mh;
  76         mh = ArrayAccessor.getAccessor(arrayClass, access);
  77         MethodType correctType = ArrayAccessor.correctType(arrayClass, access);
  78         if (mh.type() != correctType) {
  79             assert(mh.type().parameterType(0) == Object[].class);
  80             /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);
  81             /* if access == GET */ assert(access != ArrayAccess.GET ||
  82                     (mh.type().returnType() == Object.class &amp;&amp;
</pre>
<hr />
<pre>
 666         targetArgPos += chunk;
 667         if (collectValType != void.class) {
 668             targetArgs[targetArgPos++] = names[collectNamePos];
 669         }
 670         chunk = collectArgCount;
 671         if (retainOriginalArgs) {
 672             System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 673             targetArgPos += chunk;   // optionally pass on the collected chunk
 674         }
 675         inputArgPos += chunk;
 676         chunk = targetArgs.length - targetArgPos;  // all the rest
 677         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 678         assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
 679         names[targetNamePos] = new Name(target, (Object[]) targetArgs);
 680 
 681         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
 682         return SimpleMethodHandle.make(srcType, form);
 683     }
 684 
 685     @Hidden
<span class="line-modified"> 686     static</span>
<span class="line-removed"> 687     MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {</span>
 688         if (testResult) {
 689             return target;
 690         } else {
 691             return fallback;
 692         }
 693     }
 694 
 695     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
 696     @Hidden
 697     @jdk.internal.HotSpotIntrinsicCandidate
<span class="line-modified"> 698     static</span>
<span class="line-removed"> 699     boolean profileBoolean(boolean result, int[] counters) {</span>
 700         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
 701         int idx = result ? 1 : 0;
 702         try {
 703             counters[idx] = Math.addExact(counters[idx], 1);
 704         } catch (ArithmeticException e) {
 705             // Avoid continuous overflow by halving the problematic count.
 706             counters[idx] = counters[idx] / 2;
 707         }
 708         return result;
 709     }
 710 
 711     // Intrinsified by C2. Returns true if obj is a compile-time constant.
 712     @Hidden
 713     @jdk.internal.HotSpotIntrinsicCandidate
<span class="line-modified"> 714     static</span>
<span class="line-removed"> 715     boolean isCompileConstant(Object obj) {</span>
 716         return false;
 717     }
 718 
<span class="line-modified"> 719     static</span>
<span class="line-removed"> 720     MethodHandle makeGuardWithTest(MethodHandle test,</span>
 721                                    MethodHandle target,
 722                                    MethodHandle fallback) {
 723         MethodType type = target.type();
 724         assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
 725         MethodType basicType = type.basicType();
 726         LambdaForm form = makeGuardWithTestForm(basicType);
 727         BoundMethodHandle mh;
 728         try {
 729             if (PROFILE_GWT) {
 730                 int[] counts = new int[2];
 731                 mh = (BoundMethodHandle)
 732                         BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
 733                                 (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
 734             } else {
 735                 mh = (BoundMethodHandle)
 736                         BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
 737                                 (Object) test, (Object) profile(target), (Object) profile(fallback));
 738             }
 739         } catch (Throwable ex) {
 740             throw uncaughtException(ex);
 741         }
 742         assert(mh.type() == type);
 743         return mh;
 744     }
 745 
 746 
<span class="line-modified"> 747     static</span>
<span class="line-removed"> 748     MethodHandle profile(MethodHandle target) {</span>
 749         if (DONT_INLINE_THRESHOLD &gt;= 0) {
 750             return makeBlockInliningWrapper(target);
 751         } else {
 752             return target;
 753         }
 754     }
 755 
 756     /**
 757      * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
 758      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
 759      */
<span class="line-modified"> 760     static</span>
<span class="line-removed"> 761     MethodHandle makeBlockInliningWrapper(MethodHandle target) {</span>
 762         LambdaForm lform;
 763         if (DONT_INLINE_THRESHOLD &gt; 0) {
 764             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
 765         } else {
 766             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
 767         }
 768         return new CountingWrapper(target, lform,
 769                 Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
 770                                    DONT_INLINE_THRESHOLD);
 771     }
 772 
 773     private final static class Makers {
 774         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
 775         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 776             @Override
 777             public LambdaForm apply(MethodHandle target) {
 778                 return DelegatingMethodHandle.makeReinvokerForm(target,
 779                                    MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
 780                                    DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);
 781             }
</pre>
<hr />
<pre>
 878              CountingWrapper wrapper = (CountingWrapper) o1;
 879              if (wrapper.countDown()) {
 880                  // Reached invocation threshold. Replace counting behavior with a non-counting one.
 881                  LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
 882                  lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
 883                  wrapper.updateForm(lform);
 884              }
 885         }
 886 
 887         static final NamedFunction NF_maybeStopCounting;
 888         static {
 889             Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
 890             try {
 891                 NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
 892             } catch (ReflectiveOperationException ex) {
 893                 throw newInternalError(ex);
 894             }
 895         }
 896     }
 897 
<span class="line-modified"> 898     static</span>
<span class="line-removed"> 899     LambdaForm makeGuardWithTestForm(MethodType basicType) {</span>
 900         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
 901         if (lform != null)  return lform;
 902         final int THIS_MH      = 0;  // the BMH_LLL
 903         final int ARG_BASE     = 1;  // start of incoming arguments
 904         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 905         int nameCursor = ARG_LIMIT;
 906         final int GET_TEST     = nameCursor++;
 907         final int GET_TARGET   = nameCursor++;
 908         final int GET_FALLBACK = nameCursor++;
 909         final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
 910         final int CALL_TEST    = nameCursor++;
 911         final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
 912         final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST
 913         final int SELECT_ALT   = nameCursor++;
 914         final int CALL_TARGET  = nameCursor++;
 915         assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative
 916 
 917         MethodType lambdaType = basicType.invokerType();
 918         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 919 
</pre>
<hr />
<pre>
1009         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1010         Object[] args = new Object[invokeBasic.type().parameterCount()];
1011         args[0] = names[GET_COLLECT_ARGS];
1012         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
1013         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
1014 
1015         // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);
1016         Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};
1017         names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);
1018 
1019         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1020         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1021         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
1022         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1023 
1024         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
1025 
1026         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
1027     }
1028 
<span class="line-modified">1029     static</span>
<span class="line-removed">1030     MethodHandle makeGuardWithCatch(MethodHandle target,</span>
1031                                     Class&lt;? extends Throwable&gt; exType,
1032                                     MethodHandle catcher) {
1033         MethodType type = target.type();
1034         LambdaForm form = makeGuardWithCatchForm(type.basicType());
1035 
1036         // Prepare auxiliary method handles used during LambdaForm interpretation.
1037         // Box arguments and wrap them into Object[]: ValueConversions.array().
1038         MethodType varargsType = type.changeReturnType(Object[].class);
1039         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1040         MethodHandle unboxResult = unboxResultHandle(type.returnType());
1041 
1042         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
1043         BoundMethodHandle mh;
1044         try {
1045             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,
1046                     (Object) catcher, (Object) collectArgs, (Object) unboxResult);
1047         } catch (Throwable ex) {
1048             throw uncaughtException(ex);
1049         }
1050         assert(mh.type() == type);
</pre>
<hr />
<pre>
1061         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
1062         try {
1063             return target.asFixedArity().invokeWithArguments(av);
1064         } catch (Throwable t) {
1065             if (!exType.isInstance(t)) throw t;
1066             return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
1067         }
1068     }
1069 
1070     /** Prepend elements to an array. */
1071     @Hidden
1072     private static Object[] prepend(Object[] array, Object... elems) {
1073         int nArray = array.length;
1074         int nElems = elems.length;
1075         Object[] newArray = new Object[nArray + nElems];
1076         System.arraycopy(elems, 0, newArray, 0, nElems);
1077         System.arraycopy(array, 0, newArray, nElems, nArray);
1078         return newArray;
1079     }
1080 
<span class="line-modified">1081     static</span>
<span class="line-removed">1082     MethodHandle throwException(MethodType type) {</span>
1083         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
1084         int arity = type.parameterCount();
1085         if (arity &gt; 1) {
1086             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
1087             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
1088             return mh;
1089         }
1090         return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
1091     }
1092 
1093     static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }
1094 
1095     static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];
1096     static MethodHandle fakeMethodHandleInvoke(MemberName method) {
1097         int idx;
1098         assert(method.isMethodHandleInvoke());
1099         switch (method.getName()) {
1100         case &quot;invoke&quot;:       idx = 0; break;
1101         case &quot;invokeExact&quot;:  idx = 1; break;
1102         default:             throw new InternalError(method.getName());
</pre>
<hr />
<pre>
1120         MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,
1121                                                 VarHandle.class, Object[].class);
1122         MethodHandle mh = throwException(type);
1123         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));
1124         if (!method.getInvocationType().equals(mh.type()))
1125             throw new InternalError(method.toString());
1126         mh = mh.withInternalMemberName(method, false);
1127         mh = mh.asVarargsCollector(Object[].class);
1128         assert(method.isVarargs());
1129         return mh;
1130     }
1131 
1132     /**
1133      * Create an alias for the method handle which, when called,
1134      * appears to be called from the same class loader and protection domain
1135      * as hostClass.
1136      * This is an expensive no-op unless the method which is called
1137      * is sensitive to its caller.  A small number of system methods
1138      * are in this category, including Class.forName and Method.invoke.
1139      */
<span class="line-modified">1140     static</span>
<span class="line-removed">1141     MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>
1142         return BindCaller.bindCaller(mh, hostClass);
1143     }
1144 
1145     // Put the whole mess into its own nested class.
1146     // That way we can lazily load the code and set up the constants.
1147     private static class BindCaller {
1148         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1149 
<span class="line-modified">1150         static</span>
<span class="line-removed">1151         MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>
1152             // Code in the boot layer should now be careful while creating method handles or
1153             // functional interface instances created from method references to @CallerSensitive  methods,
1154             // it needs to be ensured the handles or interface instances are kept safe and are not passed
1155             // from the boot layer to untrusted code.
1156             if (hostClass == null
1157                 ||    (hostClass.isArray() ||
1158                        hostClass.isPrimitive() ||
1159                        hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
1160                 throw new InternalError();  // does not happen, and should not anyway
1161             }
1162             // For simplicity, convert mh to a varargs-like method.
1163             MethodHandle vamh = prepareForInvoker(mh);
1164             // Cache the result of makeInjectedInvoker once per argument class.
1165             MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
1166             return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);
1167         }
1168 
1169         private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; hostClass) {
1170             try {
1171                 Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(hostClass, INJECTED_INVOKER_TEMPLATE, null);
</pre>
<hr />
<pre>
1648             Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
1649             Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
1650             MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
1651             MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
1652             mh = buildVarargsArray(builder, producer, nargs);
1653         }
1654         mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
1655         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1656         assert(assertCorrectArity(mh, nargs));
1657         if (nargs &lt; cache.length)
1658             cache[nargs] = mh;
1659         return mh;
1660     }
1661 
1662     private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
1663         Class&lt;?&gt; elemType = arrayType.getComponentType();
1664         assert(elemType.isPrimitive());
1665         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
1666     }
1667 
<span class="line-modified">1668     /*non-public*/ static void assertSame(Object mh1, Object mh2) {</span>

1669         if (mh1 != mh2) {
1670             String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
1671                     mh1, ((MethodHandle)mh1).form,
1672                     mh2, ((MethodHandle)mh2).form);
1673             throw newInternalError(msg);
1674         }
1675     }
1676 
1677     // Local constant functions:
1678 
1679     /* non-public */
1680     static final byte NF_checkSpreadArgument = 0,
1681             NF_guardWithCatch = 1,
1682             NF_throwException = 2,
1683             NF_tryFinally = 3,
1684             NF_loop = 4,
1685             NF_profileBoolean = 5,
1686             NF_LIMIT = 6;
1687 
1688     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
</pre>
<hr />
<pre>
1782                     final String types) {
1783                 return GenerateJLIClassesHelper
1784                         .generateConcreteBMHClassBytes(types);
1785             }
1786 
1787             @Override
1788             public byte[] generateBasicFormsClassBytes(final String className) {
1789                 return GenerateJLIClassesHelper
1790                         .generateBasicFormsClassBytes(className);
1791             }
1792 
1793             @Override
1794             public byte[] generateInvokersHolderClassBytes(final String className,
1795                     MethodType[] invokerMethodTypes,
1796                     MethodType[] callSiteMethodTypes) {
1797                 return GenerateJLIClassesHelper
1798                         .generateInvokersHolderClassBytes(className,
1799                                 invokerMethodTypes, callSiteMethodTypes);
1800             }
1801 






































1802         });
1803     }
1804 
1805     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
1806     private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
1807         if (returnType.isPrimitive()) {
1808             if (returnType == void.class) {
1809                 return ValueConversions.ignore();
1810             } else {
1811                 Wrapper w = Wrapper.forPrimitiveType(returnType);
1812                 return ValueConversions.unboxExact(w);
1813             }
1814         } else {
1815             return MethodHandles.identity(Object.class);
1816         }
1817     }
1818 
1819     /**
1820      * Assembles a loop method handle from the given handles and type information.
1821      *
</pre>
</td>
<td>
<hr />
<pre>
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangInvokeAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.reflect.CallerSensitive;
  34 import jdk.internal.reflect.Reflection;
  35 import jdk.internal.vm.annotation.ForceInline;
  36 import jdk.internal.vm.annotation.Hidden;
  37 import jdk.internal.vm.annotation.Stable;
  38 import sun.invoke.empty.Empty;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyType;
  41 import sun.invoke.util.Wrapper;
  42 
  43 import java.lang.reflect.Array;
<span class="line-added">  44 import java.nio.ByteOrder;</span>
  45 import java.util.Arrays;
  46 import java.util.Collections;
  47 import java.util.HashMap;
  48 import java.util.Iterator;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Function;
  52 import java.util.stream.Stream;
  53 
  54 import static java.lang.invoke.LambdaForm.*;
  55 import static java.lang.invoke.MethodHandleStatics.*;
  56 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  57 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  58 
  59 /**
  60  * Trusted implementation code for MethodHandle.
  61  * @author jrose
  62  */
<span class="line-modified">  63 /*non-public*/</span>
<span class="line-added">  64 abstract class MethodHandleImpl {</span>
  65 
  66     /// Factory methods to create method handles:
  67 
  68     static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
  69         if (arrayClass == Object[].class) {
  70             return ArrayAccess.objectAccessor(access);
  71         }
  72         if (!arrayClass.isArray())
  73             throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
  74         MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
  75         int cacheIndex = ArrayAccess.cacheIndex(access);
  76         MethodHandle mh = cache[cacheIndex];
  77         if (mh != null)  return mh;
  78         mh = ArrayAccessor.getAccessor(arrayClass, access);
  79         MethodType correctType = ArrayAccessor.correctType(arrayClass, access);
  80         if (mh.type() != correctType) {
  81             assert(mh.type().parameterType(0) == Object[].class);
  82             /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);
  83             /* if access == GET */ assert(access != ArrayAccess.GET ||
  84                     (mh.type().returnType() == Object.class &amp;&amp;
</pre>
<hr />
<pre>
 668         targetArgPos += chunk;
 669         if (collectValType != void.class) {
 670             targetArgs[targetArgPos++] = names[collectNamePos];
 671         }
 672         chunk = collectArgCount;
 673         if (retainOriginalArgs) {
 674             System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 675             targetArgPos += chunk;   // optionally pass on the collected chunk
 676         }
 677         inputArgPos += chunk;
 678         chunk = targetArgs.length - targetArgPos;  // all the rest
 679         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 680         assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
 681         names[targetNamePos] = new Name(target, (Object[]) targetArgs);
 682 
 683         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
 684         return SimpleMethodHandle.make(srcType, form);
 685     }
 686 
 687     @Hidden
<span class="line-modified"> 688     static MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {</span>

 689         if (testResult) {
 690             return target;
 691         } else {
 692             return fallback;
 693         }
 694     }
 695 
 696     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
 697     @Hidden
 698     @jdk.internal.HotSpotIntrinsicCandidate
<span class="line-modified"> 699     static boolean profileBoolean(boolean result, int[] counters) {</span>

 700         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
 701         int idx = result ? 1 : 0;
 702         try {
 703             counters[idx] = Math.addExact(counters[idx], 1);
 704         } catch (ArithmeticException e) {
 705             // Avoid continuous overflow by halving the problematic count.
 706             counters[idx] = counters[idx] / 2;
 707         }
 708         return result;
 709     }
 710 
 711     // Intrinsified by C2. Returns true if obj is a compile-time constant.
 712     @Hidden
 713     @jdk.internal.HotSpotIntrinsicCandidate
<span class="line-modified"> 714     static boolean isCompileConstant(Object obj) {</span>

 715         return false;
 716     }
 717 
<span class="line-modified"> 718     static MethodHandle makeGuardWithTest(MethodHandle test,</span>

 719                                    MethodHandle target,
 720                                    MethodHandle fallback) {
 721         MethodType type = target.type();
 722         assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
 723         MethodType basicType = type.basicType();
 724         LambdaForm form = makeGuardWithTestForm(basicType);
 725         BoundMethodHandle mh;
 726         try {
 727             if (PROFILE_GWT) {
 728                 int[] counts = new int[2];
 729                 mh = (BoundMethodHandle)
 730                         BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
 731                                 (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
 732             } else {
 733                 mh = (BoundMethodHandle)
 734                         BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
 735                                 (Object) test, (Object) profile(target), (Object) profile(fallback));
 736             }
 737         } catch (Throwable ex) {
 738             throw uncaughtException(ex);
 739         }
 740         assert(mh.type() == type);
 741         return mh;
 742     }
 743 
 744 
<span class="line-modified"> 745     static MethodHandle profile(MethodHandle target) {</span>

 746         if (DONT_INLINE_THRESHOLD &gt;= 0) {
 747             return makeBlockInliningWrapper(target);
 748         } else {
 749             return target;
 750         }
 751     }
 752 
 753     /**
 754      * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
 755      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
 756      */
<span class="line-modified"> 757     static MethodHandle makeBlockInliningWrapper(MethodHandle target) {</span>

 758         LambdaForm lform;
 759         if (DONT_INLINE_THRESHOLD &gt; 0) {
 760             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
 761         } else {
 762             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
 763         }
 764         return new CountingWrapper(target, lform,
 765                 Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
 766                                    DONT_INLINE_THRESHOLD);
 767     }
 768 
 769     private final static class Makers {
 770         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
 771         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 772             @Override
 773             public LambdaForm apply(MethodHandle target) {
 774                 return DelegatingMethodHandle.makeReinvokerForm(target,
 775                                    MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
 776                                    DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);
 777             }
</pre>
<hr />
<pre>
 874              CountingWrapper wrapper = (CountingWrapper) o1;
 875              if (wrapper.countDown()) {
 876                  // Reached invocation threshold. Replace counting behavior with a non-counting one.
 877                  LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
 878                  lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
 879                  wrapper.updateForm(lform);
 880              }
 881         }
 882 
 883         static final NamedFunction NF_maybeStopCounting;
 884         static {
 885             Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
 886             try {
 887                 NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
 888             } catch (ReflectiveOperationException ex) {
 889                 throw newInternalError(ex);
 890             }
 891         }
 892     }
 893 
<span class="line-modified"> 894     static LambdaForm makeGuardWithTestForm(MethodType basicType) {</span>

 895         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
 896         if (lform != null)  return lform;
 897         final int THIS_MH      = 0;  // the BMH_LLL
 898         final int ARG_BASE     = 1;  // start of incoming arguments
 899         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 900         int nameCursor = ARG_LIMIT;
 901         final int GET_TEST     = nameCursor++;
 902         final int GET_TARGET   = nameCursor++;
 903         final int GET_FALLBACK = nameCursor++;
 904         final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
 905         final int CALL_TEST    = nameCursor++;
 906         final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
 907         final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST
 908         final int SELECT_ALT   = nameCursor++;
 909         final int CALL_TARGET  = nameCursor++;
 910         assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative
 911 
 912         MethodType lambdaType = basicType.invokerType();
 913         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 914 
</pre>
<hr />
<pre>
1004         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1005         Object[] args = new Object[invokeBasic.type().parameterCount()];
1006         args[0] = names[GET_COLLECT_ARGS];
1007         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
1008         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
1009 
1010         // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);
1011         Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};
1012         names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);
1013 
1014         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1015         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1016         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
1017         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1018 
1019         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
1020 
1021         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
1022     }
1023 
<span class="line-modified">1024     static MethodHandle makeGuardWithCatch(MethodHandle target,</span>

1025                                     Class&lt;? extends Throwable&gt; exType,
1026                                     MethodHandle catcher) {
1027         MethodType type = target.type();
1028         LambdaForm form = makeGuardWithCatchForm(type.basicType());
1029 
1030         // Prepare auxiliary method handles used during LambdaForm interpretation.
1031         // Box arguments and wrap them into Object[]: ValueConversions.array().
1032         MethodType varargsType = type.changeReturnType(Object[].class);
1033         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1034         MethodHandle unboxResult = unboxResultHandle(type.returnType());
1035 
1036         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
1037         BoundMethodHandle mh;
1038         try {
1039             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,
1040                     (Object) catcher, (Object) collectArgs, (Object) unboxResult);
1041         } catch (Throwable ex) {
1042             throw uncaughtException(ex);
1043         }
1044         assert(mh.type() == type);
</pre>
<hr />
<pre>
1055         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
1056         try {
1057             return target.asFixedArity().invokeWithArguments(av);
1058         } catch (Throwable t) {
1059             if (!exType.isInstance(t)) throw t;
1060             return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
1061         }
1062     }
1063 
1064     /** Prepend elements to an array. */
1065     @Hidden
1066     private static Object[] prepend(Object[] array, Object... elems) {
1067         int nArray = array.length;
1068         int nElems = elems.length;
1069         Object[] newArray = new Object[nArray + nElems];
1070         System.arraycopy(elems, 0, newArray, 0, nElems);
1071         System.arraycopy(array, 0, newArray, nElems, nArray);
1072         return newArray;
1073     }
1074 
<span class="line-modified">1075     static MethodHandle throwException(MethodType type) {</span>

1076         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
1077         int arity = type.parameterCount();
1078         if (arity &gt; 1) {
1079             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
1080             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
1081             return mh;
1082         }
1083         return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
1084     }
1085 
1086     static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }
1087 
1088     static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];
1089     static MethodHandle fakeMethodHandleInvoke(MemberName method) {
1090         int idx;
1091         assert(method.isMethodHandleInvoke());
1092         switch (method.getName()) {
1093         case &quot;invoke&quot;:       idx = 0; break;
1094         case &quot;invokeExact&quot;:  idx = 1; break;
1095         default:             throw new InternalError(method.getName());
</pre>
<hr />
<pre>
1113         MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,
1114                                                 VarHandle.class, Object[].class);
1115         MethodHandle mh = throwException(type);
1116         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));
1117         if (!method.getInvocationType().equals(mh.type()))
1118             throw new InternalError(method.toString());
1119         mh = mh.withInternalMemberName(method, false);
1120         mh = mh.asVarargsCollector(Object[].class);
1121         assert(method.isVarargs());
1122         return mh;
1123     }
1124 
1125     /**
1126      * Create an alias for the method handle which, when called,
1127      * appears to be called from the same class loader and protection domain
1128      * as hostClass.
1129      * This is an expensive no-op unless the method which is called
1130      * is sensitive to its caller.  A small number of system methods
1131      * are in this category, including Class.forName and Method.invoke.
1132      */
<span class="line-modified">1133     static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>

1134         return BindCaller.bindCaller(mh, hostClass);
1135     }
1136 
1137     // Put the whole mess into its own nested class.
1138     // That way we can lazily load the code and set up the constants.
1139     private static class BindCaller {
1140         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1141 
<span class="line-modified">1142         static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>

1143             // Code in the boot layer should now be careful while creating method handles or
1144             // functional interface instances created from method references to @CallerSensitive  methods,
1145             // it needs to be ensured the handles or interface instances are kept safe and are not passed
1146             // from the boot layer to untrusted code.
1147             if (hostClass == null
1148                 ||    (hostClass.isArray() ||
1149                        hostClass.isPrimitive() ||
1150                        hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
1151                 throw new InternalError();  // does not happen, and should not anyway
1152             }
1153             // For simplicity, convert mh to a varargs-like method.
1154             MethodHandle vamh = prepareForInvoker(mh);
1155             // Cache the result of makeInjectedInvoker once per argument class.
1156             MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
1157             return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);
1158         }
1159 
1160         private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; hostClass) {
1161             try {
1162                 Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(hostClass, INJECTED_INVOKER_TEMPLATE, null);
</pre>
<hr />
<pre>
1639             Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
1640             Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
1641             MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
1642             MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
1643             mh = buildVarargsArray(builder, producer, nargs);
1644         }
1645         mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
1646         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1647         assert(assertCorrectArity(mh, nargs));
1648         if (nargs &lt; cache.length)
1649             cache[nargs] = mh;
1650         return mh;
1651     }
1652 
1653     private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
1654         Class&lt;?&gt; elemType = arrayType.getComponentType();
1655         assert(elemType.isPrimitive());
1656         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
1657     }
1658 
<span class="line-modified">1659     /*non-public*/</span>
<span class="line-added">1660     static void assertSame(Object mh1, Object mh2) {</span>
1661         if (mh1 != mh2) {
1662             String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
1663                     mh1, ((MethodHandle)mh1).form,
1664                     mh2, ((MethodHandle)mh2).form);
1665             throw newInternalError(msg);
1666         }
1667     }
1668 
1669     // Local constant functions:
1670 
1671     /* non-public */
1672     static final byte NF_checkSpreadArgument = 0,
1673             NF_guardWithCatch = 1,
1674             NF_throwException = 2,
1675             NF_tryFinally = 3,
1676             NF_loop = 4,
1677             NF_profileBoolean = 5,
1678             NF_LIMIT = 6;
1679 
1680     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
</pre>
<hr />
<pre>
1774                     final String types) {
1775                 return GenerateJLIClassesHelper
1776                         .generateConcreteBMHClassBytes(types);
1777             }
1778 
1779             @Override
1780             public byte[] generateBasicFormsClassBytes(final String className) {
1781                 return GenerateJLIClassesHelper
1782                         .generateBasicFormsClassBytes(className);
1783             }
1784 
1785             @Override
1786             public byte[] generateInvokersHolderClassBytes(final String className,
1787                     MethodType[] invokerMethodTypes,
1788                     MethodType[] callSiteMethodTypes) {
1789                 return GenerateJLIClassesHelper
1790                         .generateInvokersHolderClassBytes(className,
1791                                 invokerMethodTypes, callSiteMethodTypes);
1792             }
1793 
<span class="line-added">1794             @Override</span>
<span class="line-added">1795             public VarHandle memoryAddressViewVarHandle(Class&lt;?&gt; carrier, long alignmentMask,</span>
<span class="line-added">1796                                                         ByteOrder order, long offset, long[] strides) {</span>
<span class="line-added">1797                 return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);</span>
<span class="line-added">1798             }</span>
<span class="line-added">1799 </span>
<span class="line-added">1800             @Override</span>
<span class="line-added">1801             public Class&lt;?&gt; memoryAddressCarrier(VarHandle handle) {</span>
<span class="line-added">1802                 return checkMemAccessHandle(handle).carrier();</span>
<span class="line-added">1803             }</span>
<span class="line-added">1804 </span>
<span class="line-added">1805             @Override</span>
<span class="line-added">1806             public long memoryAddressAlignmentMask(VarHandle handle) {</span>
<span class="line-added">1807                 return checkMemAccessHandle(handle).alignmentMask;</span>
<span class="line-added">1808             }</span>
<span class="line-added">1809 </span>
<span class="line-added">1810             @Override</span>
<span class="line-added">1811             public ByteOrder memoryAddressByteOrder(VarHandle handle) {</span>
<span class="line-added">1812                 return checkMemAccessHandle(handle).be ?</span>
<span class="line-added">1813                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;</span>
<span class="line-added">1814             }</span>
<span class="line-added">1815 </span>
<span class="line-added">1816             @Override</span>
<span class="line-added">1817             public long memoryAddressOffset(VarHandle handle) {</span>
<span class="line-added">1818                 return checkMemAccessHandle(handle).offset;</span>
<span class="line-added">1819             }</span>
<span class="line-added">1820 </span>
<span class="line-added">1821             @Override</span>
<span class="line-added">1822             public long[] memoryAddressStrides(VarHandle handle) {</span>
<span class="line-added">1823                 return checkMemAccessHandle(handle).strides();</span>
<span class="line-added">1824             }</span>
<span class="line-added">1825 </span>
<span class="line-added">1826             private VarHandleMemoryAddressBase checkMemAccessHandle(VarHandle handle) {</span>
<span class="line-added">1827                 if (!(handle instanceof VarHandleMemoryAddressBase)) {</span>
<span class="line-added">1828                     throw new IllegalArgumentException(&quot;Not a memory access varhandle: &quot; + handle);</span>
<span class="line-added">1829                 }</span>
<span class="line-added">1830                 return (VarHandleMemoryAddressBase) handle;</span>
<span class="line-added">1831             }</span>
1832         });
1833     }
1834 
1835     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
1836     private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
1837         if (returnType.isPrimitive()) {
1838             if (returnType == void.class) {
1839                 return ValueConversions.ignore();
1840             } else {
1841                 Wrapper w = Wrapper.forPrimitiveType(returnType);
1842                 return ValueConversions.unboxExact(w);
1843             }
1844         } else {
1845             return MethodHandles.identity(Object.class);
1846         }
1847     }
1848 
1849     /**
1850      * Assembles a loop method handle from the given handles and type information.
1851      *
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
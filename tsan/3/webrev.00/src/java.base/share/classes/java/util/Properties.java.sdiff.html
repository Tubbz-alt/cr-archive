<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Properties.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PriorityQueue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Properties.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.io.PrintStream;
  30 import java.io.PrintWriter;
  31 import java.io.InputStream;
  32 import java.io.OutputStream;
  33 import java.io.Reader;
  34 import java.io.Writer;
  35 import java.io.OutputStreamWriter;
  36 import java.io.BufferedWriter;
  37 import java.io.ObjectInputStream;
  38 import java.io.ObjectOutputStream;
  39 import java.io.StreamCorruptedException;
  40 import java.io.UnsupportedEncodingException;
  41 import java.nio.charset.Charset;
  42 import java.nio.charset.IllegalCharsetNameException;
  43 import java.nio.charset.UnsupportedCharsetException;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.function.BiConsumer;
  46 import java.util.function.BiFunction;
  47 import java.util.function.Function;
  48 



  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.Unsafe;

  51 import jdk.internal.util.xml.PropertiesDefaultHandler;
  52 
  53 /**
  54  * The {@code Properties} class represents a persistent set of
  55  * properties. The {@code Properties} can be saved to a stream
  56  * or loaded from a stream. Each key and its corresponding value in
  57  * the property list is a string.
  58  * &lt;p&gt;
  59  * A property list can contain another property list as its
  60  * &quot;defaults&quot;; this second property list is searched if
  61  * the property key is not found in the original property list.
  62  * &lt;p&gt;
  63  * Because {@code Properties} inherits from {@code Hashtable}, the
  64  * {@code put} and {@code putAll} methods can be applied to a
  65  * {@code Properties} object.  Their use is strongly discouraged as they
  66  * allow the caller to insert entries whose keys or values are not
  67  * {@code Strings}.  The {@code setProperty} method should be used
  68  * instead.  If the {@code store} or {@code save} method is called
  69  * on a &quot;compromised&quot; {@code Properties} object that contains a
  70  * non-{@code String} key or value, the call will fail. Similarly,
</pre>
<hr />
<pre>
 119  *
 120  *    &amp;lt;!ELEMENT comment (#PCDATA) &amp;gt;
 121  *
 122  *    &amp;lt;!ELEMENT entry (#PCDATA) &amp;gt;
 123  *
 124  *    &amp;lt;!ATTLIST entry key CDATA #REQUIRED&amp;gt;
 125  * &lt;/pre&gt;
 126  *
 127  * &lt;p&gt;This class is thread-safe: multiple threads can share a single
 128  * {@code Properties} object without the need for external synchronization.
 129  *
 130  * @apiNote
 131  * The {@code Properties} class does not inherit the concept of a load factor
 132  * from its superclass, {@code Hashtable}.
 133  *
 134  * @author  Arthur van Hoff
 135  * @author  Michael McCloskey
 136  * @author  Xueming Shen
 137  * @since   1.0
 138  */
<span class="line-modified"> 139 public</span>
<span class="line-removed"> 140 class Properties extends Hashtable&lt;Object,Object&gt; {</span>
 141     /**
 142      * use serialVersionUID from JDK 1.1.X for interoperability
 143      */

 144     private static final long serialVersionUID = 4112578634029874840L;
 145 
 146     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 147 
 148     /**
 149      * A property list that contains default values for any keys not
 150      * found in this property list.
 151      *
 152      * @serial
 153      */
 154     protected volatile Properties defaults;
 155 
 156     /**
 157      * Properties does not store values in its inherited Hashtable, but instead
 158      * in an internal ConcurrentHashMap.  Synchronization is omitted from
 159      * simple read operations.  Writes and bulk operations remain synchronized,
 160      * as in Hashtable.
 161      */
 162     private transient volatile ConcurrentHashMap&lt;Object, Object&gt; map;
 163 
</pre>
<hr />
<pre>
 375      */
 376     public synchronized void load(Reader reader) throws IOException {
 377         Objects.requireNonNull(reader, &quot;reader parameter is null&quot;);
 378         load0(new LineReader(reader));
 379     }
 380 
 381     /**
 382      * Reads a property list (key and element pairs) from the input
 383      * byte stream. The input stream is in a simple line-oriented
 384      * format as specified in
 385      * {@link #load(java.io.Reader) load(Reader)} and is assumed to use
 386      * the ISO 8859-1 character encoding; that is each byte is one Latin1
 387      * character. Characters not in Latin1, and certain special characters,
 388      * are represented in keys and elements using Unicode escapes as defined in
 389      * section 3.3 of
 390      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 391      * &lt;p&gt;
 392      * The specified stream remains open after this method returns.
 393      *
 394      * @param      inStream   the input stream.
<span class="line-modified"> 395      * @exception  IOException  if an error occurred when reading from the</span>
 396      *             input stream.
 397      * @throws     IllegalArgumentException if the input stream contains a
 398      *             malformed Unicode escape sequence.
 399      * @throws     NullPointerException if {@code inStream} is null.
 400      * @since 1.2
 401      */
 402     public synchronized void load(InputStream inStream) throws IOException {
 403         Objects.requireNonNull(inStream, &quot;inStream parameter is null&quot;);
 404         load0(new LineReader(inStream));
 405     }
 406 
<span class="line-modified"> 407     private void load0 (LineReader lr) throws IOException {</span>
<span class="line-modified"> 408         char[] convtBuf = new char[1024];</span>
 409         int limit;
 410         int keyLen;
 411         int valueStart;
<span class="line-removed"> 412         char c;</span>
 413         boolean hasSep;
 414         boolean precedingBackslash;
 415 
 416         while ((limit = lr.readLine()) &gt;= 0) {
<span class="line-removed"> 417             c = 0;</span>
 418             keyLen = 0;
 419             valueStart = limit;
 420             hasSep = false;
 421 
 422             //System.out.println(&quot;line=&lt;&quot; + new String(lineBuf, 0, limit) + &quot;&gt;&quot;);
 423             precedingBackslash = false;
 424             while (keyLen &lt; limit) {
<span class="line-modified"> 425                 c = lr.lineBuf[keyLen];</span>
 426                 //need check if escaped.
 427                 if ((c == &#39;=&#39; ||  c == &#39;:&#39;) &amp;&amp; !precedingBackslash) {
 428                     valueStart = keyLen + 1;
 429                     hasSep = true;
 430                     break;
 431                 } else if ((c == &#39; &#39; || c == &#39;\t&#39; ||  c == &#39;\f&#39;) &amp;&amp; !precedingBackslash) {
 432                     valueStart = keyLen + 1;
 433                     break;
 434                 }
 435                 if (c == &#39;\\&#39;) {
 436                     precedingBackslash = !precedingBackslash;
 437                 } else {
 438                     precedingBackslash = false;
 439                 }
 440                 keyLen++;
 441             }
 442             while (valueStart &lt; limit) {
<span class="line-modified"> 443                 c = lr.lineBuf[valueStart];</span>
 444                 if (c != &#39; &#39; &amp;&amp; c != &#39;\t&#39; &amp;&amp;  c != &#39;\f&#39;) {
 445                     if (!hasSep &amp;&amp; (c == &#39;=&#39; ||  c == &#39;:&#39;)) {
 446                         hasSep = true;
 447                     } else {
 448                         break;
 449                     }
 450                 }
 451                 valueStart++;
 452             }
<span class="line-modified"> 453             String key = loadConvert(lr.lineBuf, 0, keyLen, convtBuf);</span>
<span class="line-modified"> 454             String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf);</span>
 455             put(key, value);
 456         }
 457     }
 458 
 459     /* Read in a &quot;logical line&quot; from an InputStream/Reader, skip all comment
 460      * and blank lines and filter out those leading whitespace characters
 461      * (\u0020, \u0009 and \u000c) from the beginning of a &quot;natural line&quot;.
 462      * Method returns the char length of the &quot;logical line&quot; and stores
 463      * the line in &quot;lineBuf&quot;.
 464      */
<span class="line-modified"> 465     class LineReader {</span>
<span class="line-modified"> 466         public LineReader(InputStream inStream) {</span>
 467             this.inStream = inStream;
 468             inByteBuf = new byte[8192];
 469         }
 470 
<span class="line-modified"> 471         public LineReader(Reader reader) {</span>
 472             this.reader = reader;
 473             inCharBuf = new char[8192];
 474         }
 475 
<span class="line-removed"> 476         byte[] inByteBuf;</span>
<span class="line-removed"> 477         char[] inCharBuf;</span>
 478         char[] lineBuf = new char[1024];
<span class="line-modified"> 479         int inLimit = 0;</span>
<span class="line-modified"> 480         int inOff = 0;</span>
<span class="line-modified"> 481         InputStream inStream;</span>
<span class="line-modified"> 482         Reader reader;</span>


 483 
 484         int readLine() throws IOException {

 485             int len = 0;
<span class="line-modified"> 486             char c = 0;</span>

 487 
 488             boolean skipWhiteSpace = true;
<span class="line-removed"> 489             boolean isCommentLine = false;</span>
<span class="line-removed"> 490             boolean isNewLine = true;</span>
 491             boolean appendedLineBegin = false;
 492             boolean precedingBackslash = false;
<span class="line-modified"> 493             boolean skipLF = false;</span>




 494 
 495             while (true) {
<span class="line-modified"> 496                 if (inOff &gt;= inLimit) {</span>
<span class="line-modified"> 497                     inLimit = (inStream==null)?reader.read(inCharBuf)</span>
<span class="line-modified"> 498                                               :inStream.read(inByteBuf);</span>
<span class="line-modified"> 499                     inOff = 0;</span>
<span class="line-modified"> 500                     if (inLimit &lt;= 0) {</span>
<span class="line-removed"> 501                         if (len == 0 || isCommentLine) {</span>
 502                             return -1;
 503                         }
<span class="line-modified"> 504                         if (precedingBackslash) {</span>
<span class="line-removed"> 505                             len--;</span>
<span class="line-removed"> 506                         }</span>
<span class="line-removed"> 507                         return len;</span>
<span class="line-removed"> 508                     }</span>
<span class="line-removed"> 509                 }</span>
<span class="line-removed"> 510                 if (inStream != null) {</span>
<span class="line-removed"> 511                     //The line below is equivalent to calling a</span>
<span class="line-removed"> 512                     //ISO8859-1 decoder.</span>
<span class="line-removed"> 513                     c = (char)(inByteBuf[inOff++] &amp; 0xFF);</span>
<span class="line-removed"> 514                 } else {</span>
<span class="line-removed"> 515                     c = inCharBuf[inOff++];</span>
<span class="line-removed"> 516                 }</span>
<span class="line-removed"> 517                 if (skipLF) {</span>
<span class="line-removed"> 518                     skipLF = false;</span>
<span class="line-removed"> 519                     if (c == &#39;\n&#39;) {</span>
<span class="line-removed"> 520                         continue;</span>
 521                     }

 522                 }




 523                 if (skipWhiteSpace) {
 524                     if (c == &#39; &#39; || c == &#39;\t&#39; || c == &#39;\f&#39;) {
 525                         continue;
 526                     }
 527                     if (!appendedLineBegin &amp;&amp; (c == &#39;\r&#39; || c == &#39;\n&#39;)) {
 528                         continue;
 529                     }
 530                     skipWhiteSpace = false;
 531                     appendedLineBegin = false;

 532                 }
<span class="line-modified"> 533                 if (isNewLine) {</span>
<span class="line-removed"> 534                     isNewLine = false;</span>
 535                     if (c == &#39;#&#39; || c == &#39;!&#39;) {
<span class="line-modified"> 536                         // Comment, quickly consume the rest of the line,</span>
<span class="line-modified"> 537                         // resume on line-break and backslash.</span>
<span class="line-modified"> 538                         if (inStream != null) {</span>
<span class="line-modified"> 539                             while (inOff &lt; inLimit) {</span>
<span class="line-modified"> 540                                 byte b = inByteBuf[inOff++];</span>
<span class="line-modified"> 541                                 if (b == &#39;\n&#39; || b == &#39;\r&#39; || b == &#39;\\&#39;) {</span>
<span class="line-modified"> 542                                     c = (char)(b &amp; 0xFF);</span>
<span class="line-modified"> 543                                     break;</span>




 544                                 }
<span class="line-modified"> 545                             }</span>
<span class="line-modified"> 546                         } else {</span>
<span class="line-modified"> 547                             while (inOff &lt; inLimit) {</span>
<span class="line-modified"> 548                                 c = inCharBuf[inOff++];</span>
<span class="line-modified"> 549                                 if (c == &#39;\n&#39; || c == &#39;\r&#39; || c == &#39;\\&#39;) {</span>
<span class="line-modified"> 550                                     break;</span>













 551                                 }
 552                             }
 553                         }
<span class="line-modified"> 554                         isCommentLine = true;</span>

 555                     }
 556                 }
 557 
 558                 if (c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
 559                     lineBuf[len++] = c;
 560                     if (len == lineBuf.length) {
<span class="line-modified"> 561                         int newLength = lineBuf.length * 2;</span>
<span class="line-modified"> 562                         if (newLength &lt; 0) {</span>
<span class="line-modified"> 563                             newLength = Integer.MAX_VALUE;</span>
<span class="line-removed"> 564                         }</span>
<span class="line-removed"> 565                         char[] buf = new char[newLength];</span>
<span class="line-removed"> 566                         System.arraycopy(lineBuf, 0, buf, 0, lineBuf.length);</span>
<span class="line-removed"> 567                         lineBuf = buf;</span>
<span class="line-removed"> 568                     }</span>
<span class="line-removed"> 569                     //flip the preceding backslash flag</span>
<span class="line-removed"> 570                     if (c == &#39;\\&#39;) {</span>
<span class="line-removed"> 571                         precedingBackslash = !precedingBackslash;</span>
<span class="line-removed"> 572                     } else {</span>
<span class="line-removed"> 573                         precedingBackslash = false;</span>
 574                     }
<span class="line-modified"> 575                 }</span>
<span class="line-modified"> 576                 else {</span>

 577                     // reached EOL
<span class="line-modified"> 578                     if (isCommentLine || len == 0) {</span>
<span class="line-removed"> 579                         isCommentLine = false;</span>
<span class="line-removed"> 580                         isNewLine = true;</span>
 581                         skipWhiteSpace = true;
<span class="line-removed"> 582                         len = 0;</span>
 583                         continue;
 584                     }
<span class="line-modified"> 585                     if (inOff &gt;= inLimit) {</span>
<span class="line-modified"> 586                         inLimit = (inStream==null)</span>
<span class="line-modified"> 587                                   ?reader.read(inCharBuf)</span>
<span class="line-modified"> 588                                   :inStream.read(inByteBuf);</span>
<span class="line-modified"> 589                         inOff = 0;</span>
<span class="line-modified"> 590                         if (inLimit &lt;= 0) {</span>
<span class="line-removed"> 591                             if (precedingBackslash) {</span>
<span class="line-removed"> 592                                 len--;</span>
<span class="line-removed"> 593                             }</span>
<span class="line-removed"> 594                             return len;</span>
 595                         }
 596                     }
 597                     if (precedingBackslash) {

 598                         len -= 1;
<span class="line-modified"> 599                         //skip the leading whitespace characters in following line</span>
 600                         skipWhiteSpace = true;
 601                         appendedLineBegin = true;
 602                         precedingBackslash = false;

 603                         if (c == &#39;\r&#39;) {
<span class="line-modified"> 604                             skipLF = true;</span>








 605                         }
 606                     } else {

 607                         return len;
 608                     }
 609                 }
 610             }
 611         }
 612     }
 613 
 614     /*
 615      * Converts encoded &amp;#92;uxxxx to unicode chars
 616      * and changes special saved chars to their original forms
 617      */
<span class="line-modified"> 618     private String loadConvert (char[] in, int off, int len, char[] convtBuf) {</span>
<span class="line-removed"> 619         if (convtBuf.length &lt; len) {</span>
<span class="line-removed"> 620             int newLen = len * 2;</span>
<span class="line-removed"> 621             if (newLen &lt; 0) {</span>
<span class="line-removed"> 622                 newLen = Integer.MAX_VALUE;</span>
<span class="line-removed"> 623             }</span>
<span class="line-removed"> 624             convtBuf = new char[newLen];</span>
<span class="line-removed"> 625         }</span>
 626         char aChar;
<span class="line-removed"> 627         char[] out = convtBuf;</span>
<span class="line-removed"> 628         int outLen = 0;</span>
 629         int end = off + len;















 630 
 631         while (off &lt; end) {
 632             aChar = in[off++];
 633             if (aChar == &#39;\\&#39;) {


 634                 aChar = in[off++];
 635                 if(aChar == &#39;u&#39;) {
 636                     // Read the xxxx
<span class="line-modified"> 637                     int value=0;</span>
<span class="line-modified"> 638                     for (int i=0; i&lt;4; i++) {</span>



 639                         aChar = in[off++];
 640                         switch (aChar) {
 641                           case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 642                           case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 643                              value = (value &lt;&lt; 4) + aChar - &#39;0&#39;;
 644                              break;
 645                           case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;:
 646                           case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
 647                              value = (value &lt;&lt; 4) + 10 + aChar - &#39;a&#39;;
 648                              break;
 649                           case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;:
 650                           case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
 651                              value = (value &lt;&lt; 4) + 10 + aChar - &#39;A&#39;;
 652                              break;
 653                           default:
 654                               throw new IllegalArgumentException(
 655                                            &quot;Malformed \\uxxxx encoding.&quot;);
 656                         }
<span class="line-modified"> 657                      }</span>
<span class="line-modified"> 658                     out[outLen++] = (char)value;</span>
 659                 } else {
 660                     if (aChar == &#39;t&#39;) aChar = &#39;\t&#39;;
 661                     else if (aChar == &#39;r&#39;) aChar = &#39;\r&#39;;
 662                     else if (aChar == &#39;n&#39;) aChar = &#39;\n&#39;;
 663                     else if (aChar == &#39;f&#39;) aChar = &#39;\f&#39;;
<span class="line-modified"> 664                     out[outLen++] = aChar;</span>
 665                 }
 666             } else {
<span class="line-modified"> 667                 out[outLen++] = aChar;</span>
 668             }
 669         }
<span class="line-modified"> 670         return new String (out, 0, outLen);</span>
 671     }
 672 
 673     /*
 674      * Converts unicodes to encoded &amp;#92;uxxxx and escapes
 675      * special characters with a preceding slash
 676      */
 677     private String saveConvert(String theString,
 678                                boolean escapeSpace,
 679                                boolean escapeUnicode) {
 680         int len = theString.length();
 681         int bufLen = len * 2;
 682         if (bufLen &lt; 0) {
 683             bufLen = Integer.MAX_VALUE;
 684         }
 685         StringBuilder outBuffer = new StringBuilder(bufLen);
 686 
 687         for(int x=0; x&lt;len; x++) {
 688             char aChar = theString.charAt(x);
 689             // Handle common case first, selecting largest block that
 690             // avoids the specials below
</pre>
<hr />
<pre>
 768             }
 769             current++;
 770         }
 771         if (last != current)
 772             bw.write(comments.substring(last, current));
 773         bw.newLine();
 774     }
 775 
 776     /**
 777      * Calls the {@code store(OutputStream out, String comments)} method
 778      * and suppresses IOExceptions that were thrown.
 779      *
 780      * @deprecated This method does not throw an IOException if an I/O error
 781      * occurs while saving the property list.  The preferred way to save a
 782      * properties list is via the {@code store(OutputStream out,
 783      * String comments)} method or the
 784      * {@code storeToXML(OutputStream os, String comment)} method.
 785      *
 786      * @param   out      an output stream.
 787      * @param   comments   a description of the property list.
<span class="line-modified"> 788      * @exception  ClassCastException  if this {@code Properties} object</span>
 789      *             contains any keys or values that are not
 790      *             {@code Strings}.
 791      */
 792     @Deprecated
 793     public void save(OutputStream out, String comments)  {
 794         try {
 795             store(out, comments);
 796         } catch (IOException e) {
 797         }
 798     }
 799 
 800     /**
 801      * Writes this property list (key and element pairs) in this
 802      * {@code Properties} table to the output character stream in a
 803      * format suitable for using the {@link #load(java.io.Reader) load(Reader)}
 804      * method.
 805      * &lt;p&gt;
 806      * Properties from the defaults table of this {@code Properties}
 807      * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.
 808      * &lt;p&gt;
</pre>
<hr />
<pre>
 820      * {@code #} character, the current date and time (as if produced
 821      * by the {@code toString} method of {@code Date} for the
 822      * current time), and a line separator as generated by the {@code Writer}.
 823      * &lt;p&gt;
 824      * Then every entry in this {@code Properties} table is
 825      * written out, one per line. For each entry the key string is
 826      * written, then an ASCII {@code =}, then the associated
 827      * element string. For the key, all space characters are
 828      * written with a preceding {@code \} character.  For the
 829      * element, leading space characters, but not embedded or trailing
 830      * space characters, are written with a preceding {@code \}
 831      * character. The key and element characters {@code #},
 832      * {@code !}, {@code =}, and {@code :} are written
 833      * with a preceding backslash to ensure that they are properly loaded.
 834      * &lt;p&gt;
 835      * After the entries have been written, the output stream is flushed.
 836      * The output stream remains open after this method returns.
 837      *
 838      * @param   writer      an output character stream writer.
 839      * @param   comments   a description of the property list.
<span class="line-modified"> 840      * @exception  IOException if writing this property list to the specified</span>
 841      *             output stream throws an {@code IOException}.
<span class="line-modified"> 842      * @exception  ClassCastException  if this {@code Properties} object</span>
 843      *             contains any keys or values that are not {@code Strings}.
<span class="line-modified"> 844      * @exception  NullPointerException  if {@code writer} is null.</span>
 845      * @since 1.6
 846      */
 847     public void store(Writer writer, String comments)
 848         throws IOException
 849     {
 850         store0((writer instanceof BufferedWriter)?(BufferedWriter)writer
 851                                                  : new BufferedWriter(writer),
 852                comments,
 853                false);
 854     }
 855 
 856     /**
 857      * Writes this property list (key and element pairs) in this
 858      * {@code Properties} table to the output stream in a format suitable
 859      * for loading into a {@code Properties} table using the
 860      * {@link #load(InputStream) load(InputStream)} method.
 861      * &lt;p&gt;
 862      * Properties from the defaults table of this {@code Properties}
 863      * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.
 864      * &lt;p&gt;
</pre>
<hr />
<pre>
 867      * {@link #store(java.io.Writer, java.lang.String) store(Writer)},
 868      * with the following differences:
 869      * &lt;ul&gt;
 870      * &lt;li&gt;The stream is written using the ISO 8859-1 character encoding.
 871      *
 872      * &lt;li&gt;Characters not in Latin-1 in the comments are written as
 873      * {@code \u005Cu}&lt;i&gt;xxxx&lt;/i&gt; for their appropriate unicode
 874      * hexadecimal value &lt;i&gt;xxxx&lt;/i&gt;.
 875      *
 876      * &lt;li&gt;Characters less than {@code \u005Cu0020} and characters greater
 877      * than {@code \u005Cu007E} in property keys or values are written
 878      * as {@code \u005Cu}&lt;i&gt;xxxx&lt;/i&gt; for the appropriate hexadecimal
 879      * value &lt;i&gt;xxxx&lt;/i&gt;.
 880      * &lt;/ul&gt;
 881      * &lt;p&gt;
 882      * After the entries have been written, the output stream is flushed.
 883      * The output stream remains open after this method returns.
 884      *
 885      * @param   out      an output stream.
 886      * @param   comments   a description of the property list.
<span class="line-modified"> 887      * @exception  IOException if writing this property list to the specified</span>
 888      *             output stream throws an {@code IOException}.
<span class="line-modified"> 889      * @exception  ClassCastException  if this {@code Properties} object</span>
 890      *             contains any keys or values that are not {@code Strings}.
<span class="line-modified"> 891      * @exception  NullPointerException  if {@code out} is null.</span>
 892      * @since 1.2
 893      */
 894     public void store(OutputStream out, String comments)
 895         throws IOException
 896     {
<span class="line-modified"> 897         store0(new BufferedWriter(new OutputStreamWriter(out, &quot;8859_1&quot;)),</span>
 898                comments,
 899                true);
 900     }
 901 
 902     private void store0(BufferedWriter bw, String comments, boolean escUnicode)
 903         throws IOException
 904     {
 905         if (comments != null) {
 906             writeComments(bw, comments);
 907         }
 908         bw.write(&quot;#&quot; + new Date().toString());
 909         bw.newLine();
 910         synchronized (this) {
 911             for (Map.Entry&lt;Object, Object&gt; e : entrySet()) {
 912                 String key = (String)e.getKey();
 913                 String val = (String)e.getValue();
 914                 key = saveConvert(key, true, escUnicode);
 915                 /* No need to escape embedded and trailing spaces for value, hence
 916                  * pass false to flag.
 917                  */
</pre>
<hr />
<pre>
 969      *
 970      * &lt;p&gt; An invocation of this method of the form {@code props.storeToXML(os,
 971      * comment)} behaves in exactly the same way as the invocation
 972      * {@code props.storeToXML(os, comment, &quot;UTF-8&quot;);}.
 973      *
 974      * @param os the output stream on which to emit the XML document.
 975      * @param comment a description of the property list, or {@code null}
 976      *        if no comment is desired.
 977      * @throws IOException if writing to the specified output stream
 978      *         results in an {@code IOException}.
 979      * @throws NullPointerException if {@code os} is null.
 980      * @throws ClassCastException  if this {@code Properties} object
 981      *         contains any keys or values that are not
 982      *         {@code Strings}.
 983      * @see    #loadFromXML(InputStream)
 984      * @since 1.5
 985      */
 986     public void storeToXML(OutputStream os, String comment)
 987         throws IOException
 988     {
<span class="line-modified"> 989         storeToXML(os, comment, &quot;UTF-8&quot;);</span>
 990     }
 991 
 992     /**
 993      * Emits an XML document representing all of the properties contained
 994      * in this table, using the specified encoding.
 995      *
 996      * &lt;p&gt;The XML document will have the following DOCTYPE declaration:
 997      * &lt;pre&gt;
 998      * &amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
 999      * &lt;/pre&gt;
1000      *
1001      * &lt;p&gt;If the specified comment is {@code null} then no comment
1002      * will be stored in the document.
1003      *
1004      * &lt;p&gt; An implementation is required to support writing of XML documents
1005      * that use the &quot;{@code UTF-8}&quot; or &quot;{@code UTF-16}&quot; encoding. An
1006      * implementation may support additional encodings.
1007      *
1008      * &lt;p&gt;The specified stream remains open after this method returns.
1009      *
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.io.PrintStream;
  30 import java.io.PrintWriter;
  31 import java.io.InputStream;
  32 import java.io.OutputStream;
  33 import java.io.Reader;
  34 import java.io.Writer;
  35 import java.io.OutputStreamWriter;
  36 import java.io.BufferedWriter;
  37 import java.io.ObjectInputStream;
  38 import java.io.ObjectOutputStream;
  39 import java.io.StreamCorruptedException;
  40 import java.io.UnsupportedEncodingException;
  41 import java.nio.charset.Charset;
  42 import java.nio.charset.IllegalCharsetNameException;
  43 import java.nio.charset.UnsupportedCharsetException;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.function.BiConsumer;
  46 import java.util.function.BiFunction;
  47 import java.util.function.Function;
  48 
<span class="line-added">  49 import sun.nio.cs.ISO_8859_1;</span>
<span class="line-added">  50 import sun.nio.cs.UTF_8;</span>
<span class="line-added">  51 </span>
  52 import jdk.internal.access.SharedSecrets;
  53 import jdk.internal.misc.Unsafe;
<span class="line-added">  54 import jdk.internal.util.ArraysSupport;</span>
  55 import jdk.internal.util.xml.PropertiesDefaultHandler;
  56 
  57 /**
  58  * The {@code Properties} class represents a persistent set of
  59  * properties. The {@code Properties} can be saved to a stream
  60  * or loaded from a stream. Each key and its corresponding value in
  61  * the property list is a string.
  62  * &lt;p&gt;
  63  * A property list can contain another property list as its
  64  * &quot;defaults&quot;; this second property list is searched if
  65  * the property key is not found in the original property list.
  66  * &lt;p&gt;
  67  * Because {@code Properties} inherits from {@code Hashtable}, the
  68  * {@code put} and {@code putAll} methods can be applied to a
  69  * {@code Properties} object.  Their use is strongly discouraged as they
  70  * allow the caller to insert entries whose keys or values are not
  71  * {@code Strings}.  The {@code setProperty} method should be used
  72  * instead.  If the {@code store} or {@code save} method is called
  73  * on a &quot;compromised&quot; {@code Properties} object that contains a
  74  * non-{@code String} key or value, the call will fail. Similarly,
</pre>
<hr />
<pre>
 123  *
 124  *    &amp;lt;!ELEMENT comment (#PCDATA) &amp;gt;
 125  *
 126  *    &amp;lt;!ELEMENT entry (#PCDATA) &amp;gt;
 127  *
 128  *    &amp;lt;!ATTLIST entry key CDATA #REQUIRED&amp;gt;
 129  * &lt;/pre&gt;
 130  *
 131  * &lt;p&gt;This class is thread-safe: multiple threads can share a single
 132  * {@code Properties} object without the need for external synchronization.
 133  *
 134  * @apiNote
 135  * The {@code Properties} class does not inherit the concept of a load factor
 136  * from its superclass, {@code Hashtable}.
 137  *
 138  * @author  Arthur van Hoff
 139  * @author  Michael McCloskey
 140  * @author  Xueming Shen
 141  * @since   1.0
 142  */
<span class="line-modified"> 143 public class Properties extends Hashtable&lt;Object,Object&gt; {</span>

 144     /**
 145      * use serialVersionUID from JDK 1.1.X for interoperability
 146      */
<span class="line-added"> 147     @java.io.Serial</span>
 148     private static final long serialVersionUID = 4112578634029874840L;
 149 
 150     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 151 
 152     /**
 153      * A property list that contains default values for any keys not
 154      * found in this property list.
 155      *
 156      * @serial
 157      */
 158     protected volatile Properties defaults;
 159 
 160     /**
 161      * Properties does not store values in its inherited Hashtable, but instead
 162      * in an internal ConcurrentHashMap.  Synchronization is omitted from
 163      * simple read operations.  Writes and bulk operations remain synchronized,
 164      * as in Hashtable.
 165      */
 166     private transient volatile ConcurrentHashMap&lt;Object, Object&gt; map;
 167 
</pre>
<hr />
<pre>
 379      */
 380     public synchronized void load(Reader reader) throws IOException {
 381         Objects.requireNonNull(reader, &quot;reader parameter is null&quot;);
 382         load0(new LineReader(reader));
 383     }
 384 
 385     /**
 386      * Reads a property list (key and element pairs) from the input
 387      * byte stream. The input stream is in a simple line-oriented
 388      * format as specified in
 389      * {@link #load(java.io.Reader) load(Reader)} and is assumed to use
 390      * the ISO 8859-1 character encoding; that is each byte is one Latin1
 391      * character. Characters not in Latin1, and certain special characters,
 392      * are represented in keys and elements using Unicode escapes as defined in
 393      * section 3.3 of
 394      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 395      * &lt;p&gt;
 396      * The specified stream remains open after this method returns.
 397      *
 398      * @param      inStream   the input stream.
<span class="line-modified"> 399      * @throws     IOException  if an error occurred when reading from the</span>
 400      *             input stream.
 401      * @throws     IllegalArgumentException if the input stream contains a
 402      *             malformed Unicode escape sequence.
 403      * @throws     NullPointerException if {@code inStream} is null.
 404      * @since 1.2
 405      */
 406     public synchronized void load(InputStream inStream) throws IOException {
 407         Objects.requireNonNull(inStream, &quot;inStream parameter is null&quot;);
 408         load0(new LineReader(inStream));
 409     }
 410 
<span class="line-modified"> 411     private void load0(LineReader lr) throws IOException {</span>
<span class="line-modified"> 412         StringBuilder outBuffer = new StringBuilder();</span>
 413         int limit;
 414         int keyLen;
 415         int valueStart;

 416         boolean hasSep;
 417         boolean precedingBackslash;
 418 
 419         while ((limit = lr.readLine()) &gt;= 0) {

 420             keyLen = 0;
 421             valueStart = limit;
 422             hasSep = false;
 423 
 424             //System.out.println(&quot;line=&lt;&quot; + new String(lineBuf, 0, limit) + &quot;&gt;&quot;);
 425             precedingBackslash = false;
 426             while (keyLen &lt; limit) {
<span class="line-modified"> 427                 char c = lr.lineBuf[keyLen];</span>
 428                 //need check if escaped.
 429                 if ((c == &#39;=&#39; ||  c == &#39;:&#39;) &amp;&amp; !precedingBackslash) {
 430                     valueStart = keyLen + 1;
 431                     hasSep = true;
 432                     break;
 433                 } else if ((c == &#39; &#39; || c == &#39;\t&#39; ||  c == &#39;\f&#39;) &amp;&amp; !precedingBackslash) {
 434                     valueStart = keyLen + 1;
 435                     break;
 436                 }
 437                 if (c == &#39;\\&#39;) {
 438                     precedingBackslash = !precedingBackslash;
 439                 } else {
 440                     precedingBackslash = false;
 441                 }
 442                 keyLen++;
 443             }
 444             while (valueStart &lt; limit) {
<span class="line-modified"> 445                 char c = lr.lineBuf[valueStart];</span>
 446                 if (c != &#39; &#39; &amp;&amp; c != &#39;\t&#39; &amp;&amp;  c != &#39;\f&#39;) {
 447                     if (!hasSep &amp;&amp; (c == &#39;=&#39; ||  c == &#39;:&#39;)) {
 448                         hasSep = true;
 449                     } else {
 450                         break;
 451                     }
 452                 }
 453                 valueStart++;
 454             }
<span class="line-modified"> 455             String key = loadConvert(lr.lineBuf, 0, keyLen, outBuffer);</span>
<span class="line-modified"> 456             String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);</span>
 457             put(key, value);
 458         }
 459     }
 460 
 461     /* Read in a &quot;logical line&quot; from an InputStream/Reader, skip all comment
 462      * and blank lines and filter out those leading whitespace characters
 463      * (\u0020, \u0009 and \u000c) from the beginning of a &quot;natural line&quot;.
 464      * Method returns the char length of the &quot;logical line&quot; and stores
 465      * the line in &quot;lineBuf&quot;.
 466      */
<span class="line-modified"> 467     private static class LineReader {</span>
<span class="line-modified"> 468         LineReader(InputStream inStream) {</span>
 469             this.inStream = inStream;
 470             inByteBuf = new byte[8192];
 471         }
 472 
<span class="line-modified"> 473         LineReader(Reader reader) {</span>
 474             this.reader = reader;
 475             inCharBuf = new char[8192];
 476         }
 477 


 478         char[] lineBuf = new char[1024];
<span class="line-modified"> 479         private byte[] inByteBuf;</span>
<span class="line-modified"> 480         private char[] inCharBuf;</span>
<span class="line-modified"> 481         private int inLimit = 0;</span>
<span class="line-modified"> 482         private int inOff = 0;</span>
<span class="line-added"> 483         private InputStream inStream;</span>
<span class="line-added"> 484         private Reader reader;</span>
 485 
 486         int readLine() throws IOException {
<span class="line-added"> 487             // use locals to optimize for interpreted performance</span>
 488             int len = 0;
<span class="line-modified"> 489             int off = inOff;</span>
<span class="line-added"> 490             int limit = inLimit;</span>
 491 
 492             boolean skipWhiteSpace = true;


 493             boolean appendedLineBegin = false;
 494             boolean precedingBackslash = false;
<span class="line-modified"> 495             boolean fromStream = inStream != null;</span>
<span class="line-added"> 496             byte[] byteBuf = inByteBuf;</span>
<span class="line-added"> 497             char[] charBuf = inCharBuf;</span>
<span class="line-added"> 498             char[] lineBuf = this.lineBuf;</span>
<span class="line-added"> 499             char c;</span>
 500 
 501             while (true) {
<span class="line-modified"> 502                 if (off &gt;= limit) {</span>
<span class="line-modified"> 503                     inLimit = limit = fromStream ? inStream.read(byteBuf)</span>
<span class="line-modified"> 504                                                  : reader.read(charBuf);</span>
<span class="line-modified"> 505                     if (limit &lt;= 0) {</span>
<span class="line-modified"> 506                         if (len == 0) {</span>

 507                             return -1;
 508                         }
<span class="line-modified"> 509                         return precedingBackslash ? len - 1 : len;</span>
















 510                     }
<span class="line-added"> 511                     off = 0;</span>
 512                 }
<span class="line-added"> 513 </span>
<span class="line-added"> 514                 // (char)(byte &amp; 0xFF) is equivalent to calling a ISO8859-1 decoder.</span>
<span class="line-added"> 515                 c = (fromStream) ? (char)(byteBuf[off++] &amp; 0xFF) : charBuf[off++];</span>
<span class="line-added"> 516 </span>
 517                 if (skipWhiteSpace) {
 518                     if (c == &#39; &#39; || c == &#39;\t&#39; || c == &#39;\f&#39;) {
 519                         continue;
 520                     }
 521                     if (!appendedLineBegin &amp;&amp; (c == &#39;\r&#39; || c == &#39;\n&#39;)) {
 522                         continue;
 523                     }
 524                     skipWhiteSpace = false;
 525                     appendedLineBegin = false;
<span class="line-added"> 526 </span>
 527                 }
<span class="line-modified"> 528                 if (len == 0) { // Still on a new logical line</span>

 529                     if (c == &#39;#&#39; || c == &#39;!&#39;) {
<span class="line-modified"> 530                         // Comment, quickly consume the rest of the line</span>
<span class="line-modified"> 531 </span>
<span class="line-modified"> 532                         // When checking for new line characters a range check,</span>
<span class="line-modified"> 533                         // starting with the higher bound (&#39;\r&#39;) means one less</span>
<span class="line-modified"> 534                         // branch in the common case.</span>
<span class="line-modified"> 535                         commentLoop: while (true) {</span>
<span class="line-modified"> 536                             if (fromStream) {</span>
<span class="line-modified"> 537                                 byte b;</span>
<span class="line-added"> 538                                 while (off &lt; limit) {</span>
<span class="line-added"> 539                                     b = byteBuf[off++];</span>
<span class="line-added"> 540                                     if (b &lt;= &#39;\r&#39; &amp;&amp; (b == &#39;\r&#39; || b == &#39;\n&#39;))</span>
<span class="line-added"> 541                                         break commentLoop;</span>
 542                                 }
<span class="line-modified"> 543                                 if (off == limit) {</span>
<span class="line-modified"> 544                                     inLimit = limit = inStream.read(byteBuf);</span>
<span class="line-modified"> 545                                     if (limit &lt;= 0) { // EOF</span>
<span class="line-modified"> 546                                         return -1;</span>
<span class="line-modified"> 547                                     }</span>
<span class="line-modified"> 548                                     off = 0;</span>
<span class="line-added"> 549                                 }</span>
<span class="line-added"> 550                             } else {</span>
<span class="line-added"> 551                                 while (off &lt; limit) {</span>
<span class="line-added"> 552                                     c = charBuf[off++];</span>
<span class="line-added"> 553                                     if (c &lt;= &#39;\r&#39; &amp;&amp; (c == &#39;\r&#39; || c == &#39;\n&#39;))</span>
<span class="line-added"> 554                                         break commentLoop;</span>
<span class="line-added"> 555                                 }</span>
<span class="line-added"> 556                                 if (off == limit) {</span>
<span class="line-added"> 557                                     inLimit = limit = reader.read(charBuf);</span>
<span class="line-added"> 558                                     if (limit &lt;= 0) { // EOF</span>
<span class="line-added"> 559                                         return -1;</span>
<span class="line-added"> 560                                     }</span>
<span class="line-added"> 561                                     off = 0;</span>
 562                                 }
 563                             }
 564                         }
<span class="line-modified"> 565                         skipWhiteSpace = true;</span>
<span class="line-added"> 566                         continue;</span>
 567                     }
 568                 }
 569 
 570                 if (c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
 571                     lineBuf[len++] = c;
 572                     if (len == lineBuf.length) {
<span class="line-modified"> 573                         lineBuf = new char[ArraysSupport.newLength(len, 1, len)];</span>
<span class="line-modified"> 574                         System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);</span>
<span class="line-modified"> 575                         this.lineBuf = lineBuf;</span>










 576                     }
<span class="line-modified"> 577                     // flip the preceding backslash flag</span>
<span class="line-modified"> 578                     precedingBackslash = (c == &#39;\\&#39;) ? !precedingBackslash : false;</span>
<span class="line-added"> 579                 } else {</span>
 580                     // reached EOL
<span class="line-modified"> 581                     if (len == 0) {</span>


 582                         skipWhiteSpace = true;

 583                         continue;
 584                     }
<span class="line-modified"> 585                     if (off &gt;= limit) {</span>
<span class="line-modified"> 586                         inLimit = limit = fromStream ? inStream.read(byteBuf)</span>
<span class="line-modified"> 587                                                      : reader.read(charBuf);</span>
<span class="line-modified"> 588                         off = 0;</span>
<span class="line-modified"> 589                         if (limit &lt;= 0) { // EOF</span>
<span class="line-modified"> 590                             return precedingBackslash ? len - 1 : len;</span>




 591                         }
 592                     }
 593                     if (precedingBackslash) {
<span class="line-added"> 594                         // backslash at EOL is not part of the line</span>
 595                         len -= 1;
<span class="line-modified"> 596                         // skip leading whitespace characters in the following line</span>
 597                         skipWhiteSpace = true;
 598                         appendedLineBegin = true;
 599                         precedingBackslash = false;
<span class="line-added"> 600                         // take care not to include any subsequent \n</span>
 601                         if (c == &#39;\r&#39;) {
<span class="line-modified"> 602                             if (fromStream) {</span>
<span class="line-added"> 603                                 if (byteBuf[off] == &#39;\n&#39;) {</span>
<span class="line-added"> 604                                     off++;</span>
<span class="line-added"> 605                                 }</span>
<span class="line-added"> 606                             } else {</span>
<span class="line-added"> 607                                 if (charBuf[off] == &#39;\n&#39;) {</span>
<span class="line-added"> 608                                     off++;</span>
<span class="line-added"> 609                                 }</span>
<span class="line-added"> 610                             }</span>
 611                         }
 612                     } else {
<span class="line-added"> 613                         inOff = off;</span>
 614                         return len;
 615                     }
 616                 }
 617             }
 618         }
 619     }
 620 
 621     /*
 622      * Converts encoded &amp;#92;uxxxx to unicode chars
 623      * and changes special saved chars to their original forms
 624      */
<span class="line-modified"> 625     private String loadConvert(char[] in, int off, int len, StringBuilder out) {</span>







 626         char aChar;


 627         int end = off + len;
<span class="line-added"> 628         int start = off;</span>
<span class="line-added"> 629         while (off &lt; end) {</span>
<span class="line-added"> 630             aChar = in[off++];</span>
<span class="line-added"> 631             if (aChar == &#39;\\&#39;) {</span>
<span class="line-added"> 632                 break;</span>
<span class="line-added"> 633             }</span>
<span class="line-added"> 634         }</span>
<span class="line-added"> 635         if (off == end) { // No backslash</span>
<span class="line-added"> 636             return new String(in, start, len);</span>
<span class="line-added"> 637         }</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639         // backslash found at off - 1, reset the shared buffer, rewind offset</span>
<span class="line-added"> 640         out.setLength(0);</span>
<span class="line-added"> 641         off--;</span>
<span class="line-added"> 642         out.append(in, start, off - start);</span>
 643 
 644         while (off &lt; end) {
 645             aChar = in[off++];
 646             if (aChar == &#39;\\&#39;) {
<span class="line-added"> 647                 // No need to bounds check since LineReader::readLine excludes</span>
<span class="line-added"> 648                 // unescaped \s at the end of the line</span>
 649                 aChar = in[off++];
 650                 if(aChar == &#39;u&#39;) {
 651                     // Read the xxxx
<span class="line-modified"> 652                     if (off &gt; end - 4)</span>
<span class="line-modified"> 653                         throw new IllegalArgumentException(</span>
<span class="line-added"> 654                                      &quot;Malformed \\uxxxx encoding.&quot;);</span>
<span class="line-added"> 655                     int value = 0;</span>
<span class="line-added"> 656                     for (int i = 0; i &lt; 4; i++) {</span>
 657                         aChar = in[off++];
 658                         switch (aChar) {
 659                           case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 660                           case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 661                              value = (value &lt;&lt; 4) + aChar - &#39;0&#39;;
 662                              break;
 663                           case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;:
 664                           case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
 665                              value = (value &lt;&lt; 4) + 10 + aChar - &#39;a&#39;;
 666                              break;
 667                           case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;:
 668                           case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
 669                              value = (value &lt;&lt; 4) + 10 + aChar - &#39;A&#39;;
 670                              break;
 671                           default:
 672                               throw new IllegalArgumentException(
 673                                            &quot;Malformed \\uxxxx encoding.&quot;);
 674                         }
<span class="line-modified"> 675                     }</span>
<span class="line-modified"> 676                     out.append((char)value);</span>
 677                 } else {
 678                     if (aChar == &#39;t&#39;) aChar = &#39;\t&#39;;
 679                     else if (aChar == &#39;r&#39;) aChar = &#39;\r&#39;;
 680                     else if (aChar == &#39;n&#39;) aChar = &#39;\n&#39;;
 681                     else if (aChar == &#39;f&#39;) aChar = &#39;\f&#39;;
<span class="line-modified"> 682                     out.append(aChar);</span>
 683                 }
 684             } else {
<span class="line-modified"> 685                 out.append(aChar);</span>
 686             }
 687         }
<span class="line-modified"> 688         return out.toString();</span>
 689     }
 690 
 691     /*
 692      * Converts unicodes to encoded &amp;#92;uxxxx and escapes
 693      * special characters with a preceding slash
 694      */
 695     private String saveConvert(String theString,
 696                                boolean escapeSpace,
 697                                boolean escapeUnicode) {
 698         int len = theString.length();
 699         int bufLen = len * 2;
 700         if (bufLen &lt; 0) {
 701             bufLen = Integer.MAX_VALUE;
 702         }
 703         StringBuilder outBuffer = new StringBuilder(bufLen);
 704 
 705         for(int x=0; x&lt;len; x++) {
 706             char aChar = theString.charAt(x);
 707             // Handle common case first, selecting largest block that
 708             // avoids the specials below
</pre>
<hr />
<pre>
 786             }
 787             current++;
 788         }
 789         if (last != current)
 790             bw.write(comments.substring(last, current));
 791         bw.newLine();
 792     }
 793 
 794     /**
 795      * Calls the {@code store(OutputStream out, String comments)} method
 796      * and suppresses IOExceptions that were thrown.
 797      *
 798      * @deprecated This method does not throw an IOException if an I/O error
 799      * occurs while saving the property list.  The preferred way to save a
 800      * properties list is via the {@code store(OutputStream out,
 801      * String comments)} method or the
 802      * {@code storeToXML(OutputStream os, String comment)} method.
 803      *
 804      * @param   out      an output stream.
 805      * @param   comments   a description of the property list.
<span class="line-modified"> 806      * @throws     ClassCastException  if this {@code Properties} object</span>
 807      *             contains any keys or values that are not
 808      *             {@code Strings}.
 809      */
 810     @Deprecated
 811     public void save(OutputStream out, String comments)  {
 812         try {
 813             store(out, comments);
 814         } catch (IOException e) {
 815         }
 816     }
 817 
 818     /**
 819      * Writes this property list (key and element pairs) in this
 820      * {@code Properties} table to the output character stream in a
 821      * format suitable for using the {@link #load(java.io.Reader) load(Reader)}
 822      * method.
 823      * &lt;p&gt;
 824      * Properties from the defaults table of this {@code Properties}
 825      * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.
 826      * &lt;p&gt;
</pre>
<hr />
<pre>
 838      * {@code #} character, the current date and time (as if produced
 839      * by the {@code toString} method of {@code Date} for the
 840      * current time), and a line separator as generated by the {@code Writer}.
 841      * &lt;p&gt;
 842      * Then every entry in this {@code Properties} table is
 843      * written out, one per line. For each entry the key string is
 844      * written, then an ASCII {@code =}, then the associated
 845      * element string. For the key, all space characters are
 846      * written with a preceding {@code \} character.  For the
 847      * element, leading space characters, but not embedded or trailing
 848      * space characters, are written with a preceding {@code \}
 849      * character. The key and element characters {@code #},
 850      * {@code !}, {@code =}, and {@code :} are written
 851      * with a preceding backslash to ensure that they are properly loaded.
 852      * &lt;p&gt;
 853      * After the entries have been written, the output stream is flushed.
 854      * The output stream remains open after this method returns.
 855      *
 856      * @param   writer      an output character stream writer.
 857      * @param   comments   a description of the property list.
<span class="line-modified"> 858      * @throws     IOException if writing this property list to the specified</span>
 859      *             output stream throws an {@code IOException}.
<span class="line-modified"> 860      * @throws     ClassCastException  if this {@code Properties} object</span>
 861      *             contains any keys or values that are not {@code Strings}.
<span class="line-modified"> 862      * @throws     NullPointerException  if {@code writer} is null.</span>
 863      * @since 1.6
 864      */
 865     public void store(Writer writer, String comments)
 866         throws IOException
 867     {
 868         store0((writer instanceof BufferedWriter)?(BufferedWriter)writer
 869                                                  : new BufferedWriter(writer),
 870                comments,
 871                false);
 872     }
 873 
 874     /**
 875      * Writes this property list (key and element pairs) in this
 876      * {@code Properties} table to the output stream in a format suitable
 877      * for loading into a {@code Properties} table using the
 878      * {@link #load(InputStream) load(InputStream)} method.
 879      * &lt;p&gt;
 880      * Properties from the defaults table of this {@code Properties}
 881      * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.
 882      * &lt;p&gt;
</pre>
<hr />
<pre>
 885      * {@link #store(java.io.Writer, java.lang.String) store(Writer)},
 886      * with the following differences:
 887      * &lt;ul&gt;
 888      * &lt;li&gt;The stream is written using the ISO 8859-1 character encoding.
 889      *
 890      * &lt;li&gt;Characters not in Latin-1 in the comments are written as
 891      * {@code \u005Cu}&lt;i&gt;xxxx&lt;/i&gt; for their appropriate unicode
 892      * hexadecimal value &lt;i&gt;xxxx&lt;/i&gt;.
 893      *
 894      * &lt;li&gt;Characters less than {@code \u005Cu0020} and characters greater
 895      * than {@code \u005Cu007E} in property keys or values are written
 896      * as {@code \u005Cu}&lt;i&gt;xxxx&lt;/i&gt; for the appropriate hexadecimal
 897      * value &lt;i&gt;xxxx&lt;/i&gt;.
 898      * &lt;/ul&gt;
 899      * &lt;p&gt;
 900      * After the entries have been written, the output stream is flushed.
 901      * The output stream remains open after this method returns.
 902      *
 903      * @param   out      an output stream.
 904      * @param   comments   a description of the property list.
<span class="line-modified"> 905      * @throws     IOException if writing this property list to the specified</span>
 906      *             output stream throws an {@code IOException}.
<span class="line-modified"> 907      * @throws     ClassCastException  if this {@code Properties} object</span>
 908      *             contains any keys or values that are not {@code Strings}.
<span class="line-modified"> 909      * @throws     NullPointerException  if {@code out} is null.</span>
 910      * @since 1.2
 911      */
 912     public void store(OutputStream out, String comments)
 913         throws IOException
 914     {
<span class="line-modified"> 915         store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),</span>
 916                comments,
 917                true);
 918     }
 919 
 920     private void store0(BufferedWriter bw, String comments, boolean escUnicode)
 921         throws IOException
 922     {
 923         if (comments != null) {
 924             writeComments(bw, comments);
 925         }
 926         bw.write(&quot;#&quot; + new Date().toString());
 927         bw.newLine();
 928         synchronized (this) {
 929             for (Map.Entry&lt;Object, Object&gt; e : entrySet()) {
 930                 String key = (String)e.getKey();
 931                 String val = (String)e.getValue();
 932                 key = saveConvert(key, true, escUnicode);
 933                 /* No need to escape embedded and trailing spaces for value, hence
 934                  * pass false to flag.
 935                  */
</pre>
<hr />
<pre>
 987      *
 988      * &lt;p&gt; An invocation of this method of the form {@code props.storeToXML(os,
 989      * comment)} behaves in exactly the same way as the invocation
 990      * {@code props.storeToXML(os, comment, &quot;UTF-8&quot;);}.
 991      *
 992      * @param os the output stream on which to emit the XML document.
 993      * @param comment a description of the property list, or {@code null}
 994      *        if no comment is desired.
 995      * @throws IOException if writing to the specified output stream
 996      *         results in an {@code IOException}.
 997      * @throws NullPointerException if {@code os} is null.
 998      * @throws ClassCastException  if this {@code Properties} object
 999      *         contains any keys or values that are not
1000      *         {@code Strings}.
1001      * @see    #loadFromXML(InputStream)
1002      * @since 1.5
1003      */
1004     public void storeToXML(OutputStream os, String comment)
1005         throws IOException
1006     {
<span class="line-modified">1007         storeToXML(os, comment, UTF_8.INSTANCE);</span>
1008     }
1009 
1010     /**
1011      * Emits an XML document representing all of the properties contained
1012      * in this table, using the specified encoding.
1013      *
1014      * &lt;p&gt;The XML document will have the following DOCTYPE declaration:
1015      * &lt;pre&gt;
1016      * &amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
1017      * &lt;/pre&gt;
1018      *
1019      * &lt;p&gt;If the specified comment is {@code null} then no comment
1020      * will be stored in the document.
1021      *
1022      * &lt;p&gt; An implementation is required to support writing of XML documents
1023      * that use the &quot;{@code UTF-8}&quot; or &quot;{@code UTF-16}&quot; encoding. An
1024      * implementation may support additional encodings.
1025      *
1026      * &lt;p&gt;The specified stream remains open after this method returns.
1027      *
</pre>
</td>
</tr>
</table>
<center><a href="PriorityQueue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/Collections.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Collection.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Comparators.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Collections.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,10 +24,11 @@</span>
   */
  
  package java.util;
  
  import java.io.IOException;
<span class="udiff-line-added">+ import java.io.ObjectInputStream;</span>
  import java.io.ObjectOutputStream;
  import java.io.Serializable;
  import java.lang.reflect.Array;
  import java.util.function.BiConsumer;
  import java.util.function.BiFunction;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37,10 +38,11 @@</span>
  import java.util.function.Predicate;
  import java.util.function.UnaryOperator;
  import java.util.stream.IntStream;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
<span class="udiff-line-added">+ import jdk.internal.access.SharedSecrets;</span>
  
  /**
   * This class consists exclusively of static methods that operate on or return
   * collections.  It contains polymorphic algorithms that operate on
   * collections, &quot;wrappers&quot;, which return a new collection backed by a
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1017,12 +1019,14 @@</span>
  
      /**
       * @serial include
       */
      static class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1820017752578914078L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Collection&lt;? extends E&gt; c;
  
          UnmodifiableCollection(Collection&lt;? extends E&gt; c) {
              if (c==null)
                  throw new NullPointerException();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1123,10 +1127,11 @@</span>
      /**
       * @serial include
       */
      static class UnmodifiableSet&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
                                   implements Set&lt;E&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -9215047833775013803L;
  
          UnmodifiableSet(Set&lt;? extends E&gt; s)     {super(s);}
          public boolean equals(Object o) {return o == this || c.equals(o);}
          public int hashCode()           {return c.hashCode();}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1156,11 +1161,13 @@</span>
       * @serial include
       */
      static class UnmodifiableSortedSet&lt;E&gt;
                               extends UnmodifiableSet&lt;E&gt;
                               implements SortedSet&lt;E&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -4929149591599911165L;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final SortedSet&lt;E&gt; ss;
  
          UnmodifiableSortedSet(SortedSet&lt;E&gt; s) {super(s); ss = s;}
  
          public Comparator&lt;? super E&gt; comparator() {return ss.comparator();}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1208,36 +1215,40 @@</span>
       */
      static class UnmodifiableNavigableSet&lt;E&gt;
                               extends UnmodifiableSortedSet&lt;E&gt;
                               implements NavigableSet&lt;E&gt;, Serializable {
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -6027448201786391929L;
  
          /**
           * A singleton empty unmodifiable navigable set used for
           * {@link #emptyNavigableSet()}.
           *
           * @param &lt;E&gt; type of elements, if there were any, and bounds
           */
          private static class EmptyNavigableSet&lt;E&gt; extends UnmodifiableNavigableSet&lt;E&gt;
              implements Serializable {
<span class="udiff-line-added">+             @java.io.Serial</span>
              private static final long serialVersionUID = -6291252904449939134L;
  
              public EmptyNavigableSet() {
                  super(new TreeSet&lt;&gt;());
              }
  
<span class="udiff-line-added">+             @java.io.Serial</span>
              private Object readResolve()        { return EMPTY_NAVIGABLE_SET; }
          }
  
          @SuppressWarnings(&quot;rawtypes&quot;)
          private static final NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =
                  new EmptyNavigableSet&lt;&gt;();
  
          /**
           * The instance we are protecting.
           */
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final NavigableSet&lt;E&gt; ns;
  
          UnmodifiableNavigableSet(NavigableSet&lt;E&gt; s)         {super(s); ns = s;}
  
          public E lower(E e)                             { return ns.lower(e); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1291,12 +1302,14 @@</span>
      /**
       * @serial include
       */
      static class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
                                    implements List&lt;E&gt; {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -283967356065247728L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final List&lt;? extends E&gt; list;
  
          UnmodifiableList(List&lt;? extends E&gt; list) {
              super(list);
              this.list = list;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1375,10 +1388,11 @@</span>
           *
           * Note: Unfortunately, UnmodifiableRandomAccessList instances
           * serialized in 1.4.1 and deserialized in 1.4 will become
           * UnmodifiableList instances, as this method was missing in 1.4.
           */
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() {
              return (list instanceof RandomAccess
                      ? new UnmodifiableRandomAccessList&lt;&gt;(list)
                      : this);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1397,18 +1411,20 @@</span>
          public List&lt;E&gt; subList(int fromIndex, int toIndex) {
              return new UnmodifiableRandomAccessList&lt;&gt;(
                  list.subList(fromIndex, toIndex));
          }
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -2542308836966382001L;
  
          /**
           * Allows instances to be deserialized in pre-1.4 JREs (which do
           * not have UnmodifiableRandomAccessList).  UnmodifiableList has
           * a readResolve method that inverts this transformation upon
           * deserialization.
           */
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
              return new UnmodifiableList&lt;&gt;(list);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1433,12 +1449,14 @@</span>
  
      /**
       * @serial include
       */
      private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -1034234728574286014L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final Map&lt;? extends K, ? extends V&gt; m;
  
          UnmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {
              if (m==null)
                  throw new NullPointerException();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1559,10 +1577,11 @@</span>
           *
           * @serial include
           */
          static class UnmodifiableEntrySet&lt;K,V&gt;
              extends UnmodifiableSet&lt;Map.Entry&lt;K,V&gt;&gt; {
<span class="udiff-line-added">+             @java.io.Serial</span>
              private static final long serialVersionUID = 7854390611657943733L;
  
              @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
              UnmodifiableEntrySet(Set&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; s) {
                  // Need to cast to raw in order to work around a limitation in the type system
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1790,12 +1809,14 @@</span>
       * @serial include
       */
      static class UnmodifiableSortedMap&lt;K,V&gt;
            extends UnmodifiableMap&lt;K,V&gt;
            implements SortedMap&lt;K,V&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -8806743815996713206L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final SortedMap&lt;K, ? extends V&gt; sm;
  
          UnmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {super(m); sm = m; }
          public Comparator&lt;? super K&gt; comparator()   { return sm.comparator(); }
          public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1834,10 +1855,11 @@</span>
       * @serial include
       */
      static class UnmodifiableNavigableMap&lt;K,V&gt;
            extends UnmodifiableSortedMap&lt;K,V&gt;
            implements NavigableMap&lt;K,V&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -4858195264774772197L;
  
          /**
           * A class for the {@link EMPTY_NAVIGABLE_MAP} which needs readResolve
           * to preserve singleton property.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,18 +1868,20 @@</span>
           * @param &lt;V&gt; type of values, if there were any
           */
          private static class EmptyNavigableMap&lt;K,V&gt; extends UnmodifiableNavigableMap&lt;K,V&gt;
              implements Serializable {
  
<span class="udiff-line-added">+             @java.io.Serial</span>
              private static final long serialVersionUID = -2239321462712562324L;
  
              EmptyNavigableMap()                       { super(new TreeMap&lt;&gt;()); }
  
              @Override
              public NavigableSet&lt;K&gt; navigableKeySet()
                                                  { return emptyNavigableSet(); }
  
<span class="udiff-line-added">+             @java.io.Serial</span>
              private Object readResolve()        { return EMPTY_NAVIGABLE_MAP; }
          }
  
          /**
           * Singleton for {@link emptyNavigableMap()} which is also immutable.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1866,10 +1890,11 @@</span>
              new EmptyNavigableMap&lt;&gt;();
  
          /**
           * The instance we wrap and protect.
           */
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final NavigableMap&lt;K, ? extends V&gt; nm;
  
          UnmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)
                                                              {super(m); nm = m;}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1994,13 +2019,16 @@</span>
  
      /**
       * @serial include
       */
      static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 3053995032091335093L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Collection&lt;E&gt; c;  // Backing Collection
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Object mutex;     // Object on which to synchronize
  
          SynchronizedCollection(Collection&lt;E&gt; c) {
              this.c = Objects.requireNonNull(c);
              mutex = this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2078,10 +2106,11 @@</span>
          }
          @Override
          public Stream&lt;E&gt; parallelStream() {
              return c.parallelStream(); // Must be manually synched by user!
          }
<span class="udiff-line-added">+         @java.io.Serial</span>
          private void writeObject(ObjectOutputStream s) throws IOException {
              synchronized (mutex) {s.defaultWriteObject();}
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2124,10 +2153,11 @@</span>
       * @serial include
       */
      static class SynchronizedSet&lt;E&gt;
            extends SynchronizedCollection&lt;E&gt;
            implements Set&lt;E&gt; {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 487447009682186044L;
  
          SynchronizedSet(Set&lt;E&gt; s) {
              super(s);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2193,12 +2223,14 @@</span>
       */
      static class SynchronizedSortedSet&lt;E&gt;
          extends SynchronizedSet&lt;E&gt;
          implements SortedSet&lt;E&gt;
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 8695801310862127406L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final SortedSet&lt;E&gt; ss;
  
          SynchronizedSortedSet(SortedSet&lt;E&gt; s) {
              super(s);
              ss = s;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2287,12 +2319,14 @@</span>
       */
      static class SynchronizedNavigableSet&lt;E&gt;
          extends SynchronizedSortedSet&lt;E&gt;
          implements NavigableSet&lt;E&gt;
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -5505529816273629798L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final NavigableSet&lt;E&gt; ns;
  
          SynchronizedNavigableSet(NavigableSet&lt;E&gt; s) {
              super(s);
              ns = s;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2396,12 +2430,14 @@</span>
       * @serial include
       */
      static class SynchronizedList&lt;E&gt;
          extends SynchronizedCollection&lt;E&gt;
          implements List&lt;E&gt; {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -7754090372962971524L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final List&lt;E&gt; list;
  
          SynchronizedList(List&lt;E&gt; list) {
              super(list);
              this.list = list;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2478,10 +2514,11 @@</span>
           *
           * Note: Unfortunately, SynchronizedRandomAccessList instances
           * serialized in 1.4.1 and deserialized in 1.4 will become
           * SynchronizedList instances, as this method was missing in 1.4.
           */
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() {
              return (list instanceof RandomAccess
                      ? new SynchronizedRandomAccessList&lt;&gt;(list)
                      : this);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2507,18 +2544,20 @@</span>
                  return new SynchronizedRandomAccessList&lt;&gt;(
                      list.subList(fromIndex, toIndex), mutex);
              }
          }
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1530674583602358482L;
  
          /**
           * Allows instances to be deserialized in pre-1.4 JREs (which do
           * not have SynchronizedRandomAccessList).  SynchronizedList has
           * a readResolve method that inverts this transformation upon
           * deserialization.
           */
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object writeReplace() {
              return new SynchronizedList&lt;&gt;(list);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2559,13 +2598,16 @@</span>
      /**
       * @serial include
       */
      private static class SynchronizedMap&lt;K,V&gt;
          implements Map&lt;K,V&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1978198479659022715L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final Map&lt;K,V&gt; m;     // Backing Map
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Object      mutex;        // Object on which to synchronize
  
          SynchronizedMap(Map&lt;K,V&gt; m) {
              this.m = Objects.requireNonNull(m);
              mutex = this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2693,10 +2735,11 @@</span>
          public V merge(K key, V value,
                  BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
              synchronized (mutex) {return m.merge(key, value, remappingFunction);}
          }
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private void writeObject(ObjectOutputStream s) throws IOException {
              synchronized (mutex) {s.defaultWriteObject();}
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2754,12 +2797,14 @@</span>
       */
      static class SynchronizedSortedMap&lt;K,V&gt;
          extends SynchronizedMap&lt;K,V&gt;
          implements SortedMap&lt;K,V&gt;
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -8798146769416483793L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final SortedMap&lt;K,V&gt; sm;
  
          SynchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
              super(m);
              sm = m;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2856,12 +2901,14 @@</span>
       */
      static class SynchronizedNavigableMap&lt;K,V&gt;
          extends SynchronizedSortedMap&lt;K,V&gt;
          implements NavigableMap&lt;K,V&gt;
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 699392247599746807L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final NavigableMap&lt;K,V&gt; nm;
  
          SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
              super(m);
              nm = m;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3034,13 +3081,16 @@</span>
  
      /**
       * @serial include
       */
      static class CheckedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1578914078182001775L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Collection&lt;E&gt; c;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Class&lt;E&gt; type;
  
          @SuppressWarnings(&quot;unchecked&quot;)
          E typeCheck(Object o) {
              if (o != null &amp;&amp; !type.isInstance(o))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3092,10 +3142,11 @@</span>
              };
          }
  
          public boolean add(E e)          { return c.add(typeCheck(e)); }
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private E[] zeroLengthElementArray; // Lazily initialized
  
          private E[] zeroLengthElementArray() {
              return zeroLengthElementArray != null ? zeroLengthElementArray :
                  (zeroLengthElementArray = zeroLengthArray(type));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3183,11 +3234,13 @@</span>
       */
      static class CheckedQueue&lt;E&gt;
          extends CheckedCollection&lt;E&gt;
          implements Queue&lt;E&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1433151992604707767L;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Queue&lt;E&gt; queue;
  
          CheckedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; elementType) {
              super(queue, elementType);
              this.queue = queue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3237,10 +3290,11 @@</span>
       * @serial include
       */
      static class CheckedSet&lt;E&gt; extends CheckedCollection&lt;E&gt;
                                   implements Set&lt;E&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 4694047833775013803L;
  
          CheckedSet(Set&lt;E&gt; s, Class&lt;E&gt; elementType) { super(s, elementType); }
  
          public boolean equals(Object o) { return o == this || c.equals(o); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3284,12 +3338,14 @@</span>
       * @serial include
       */
      static class CheckedSortedSet&lt;E&gt; extends CheckedSet&lt;E&gt;
          implements SortedSet&lt;E&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1599911165492914959L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final SortedSet&lt;E&gt; ss;
  
          CheckedSortedSet(SortedSet&lt;E&gt; s, Class&lt;E&gt; type) {
              super(s, type);
              ss = s;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3347,12 +3403,14 @@</span>
       * @serial include
       */
      static class CheckedNavigableSet&lt;E&gt; extends CheckedSortedSet&lt;E&gt;
          implements NavigableSet&lt;E&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -5429120189805438922L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final NavigableSet&lt;E&gt; ns;
  
          CheckedNavigableSet(NavigableSet&lt;E&gt; s, Class&lt;E&gt; type) {
              super(s, type);
              ns = s;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3430,11 +3488,13 @@</span>
       */
      static class CheckedList&lt;E&gt;
          extends CheckedCollection&lt;E&gt;
          implements List&lt;E&gt;
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 65247728283967356L;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final List&lt;E&gt; list;
  
          CheckedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
              super(list, type);
              this.list = list;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3515,10 +3575,11 @@</span>
       * @serial include
       */
      static class CheckedRandomAccessList&lt;E&gt; extends CheckedList&lt;E&gt;
                                              implements RandomAccess
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1638200125423088369L;
  
          CheckedRandomAccessList(List&lt;E&gt; list, Class&lt;E&gt; type) {
              super(list, type);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3576,14 +3637,18 @@</span>
       * @serial include
       */
      private static class CheckedMap&lt;K,V&gt;
          implements Map&lt;K,V&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 5742860141034234728L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final Map&lt;K, V&gt; m;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Class&lt;K&gt; keyType;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Class&lt;V&gt; valueType;
  
          private void typeCheck(Object key, Object value) {
              if (key != null &amp;&amp; !keyType.isInstance(key))
                  throw new ClassCastException(badKeyMsg(key));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3975,12 +4040,14 @@</span>
       * @serial include
       */
      static class CheckedSortedMap&lt;K,V&gt; extends CheckedMap&lt;K,V&gt;
          implements SortedMap&lt;K,V&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1599671320688067438L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final SortedMap&lt;K, V&gt; sm;
  
          CheckedSortedMap(SortedMap&lt;K, V&gt; m,
                           Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
              super(m, keyType, valueType);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4049,12 +4116,14 @@</span>
       * @serial include
       */
      static class CheckedNavigableMap&lt;K,V&gt; extends CheckedSortedMap&lt;K,V&gt;
          implements NavigableMap&lt;K,V&gt;, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -4852462692372534096L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final NavigableMap&lt;K, V&gt; nm;
  
          CheckedNavigableMap(NavigableMap&lt;K, V&gt; m,
                           Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
              super(m, keyType, valueType);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4327,10 +4396,11 @@</span>
       */
      private static class EmptySet&lt;E&gt;
          extends AbstractSet&lt;E&gt;
          implements Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1582296315990362920L;
  
          public Iterator&lt;E&gt; iterator() { return emptyIterator(); }
  
          public int size() {return 0;}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4360,10 +4430,11 @@</span>
          }
          @Override
          public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }
  
          // Preserves singleton property
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() {
              return EMPTY_SET;
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4451,10 +4522,11 @@</span>
       * @serial include
       */
      private static class EmptyList&lt;E&gt;
          extends AbstractList&lt;E&gt;
          implements RandomAccess, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 8842843931221139166L;
  
          public Iterator&lt;E&gt; iterator() {
              return emptyIterator();
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4508,10 +4580,11 @@</span>
  
          @Override
          public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }
  
          // Preserves singleton property
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() {
              return EMPTY_LIST;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4594,10 +4667,11 @@</span>
       */
      private static class EmptyMap&lt;K,V&gt;
          extends AbstractMap&lt;K,V&gt;
          implements Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 6428348081105594320L;
  
          public int size()                          {return 0;}
          public boolean isEmpty()                   {return true;}
          public void clear()                        {}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4674,10 +4748,11 @@</span>
                  BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
              throw new UnsupportedOperationException();
          }
  
          // Preserves singleton property
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() {
              return EMPTY_MAP;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4773,12 +4848,14 @@</span>
       */
      private static class SingletonSet&lt;E&gt;
          extends AbstractSet&lt;E&gt;
          implements Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 3193687207550431679L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final E element;
  
          SingletonSet(E e) {element = e;}
  
          public Iterator&lt;E&gt; iterator() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4826,12 +4903,14 @@</span>
       */
      private static class SingletonList&lt;E&gt;
          extends AbstractList&lt;E&gt;
          implements RandomAccess, Serializable {
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 3093736618740652951L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final E element;
  
          SingletonList(E obj)                {element = obj;}
  
          public Iterator&lt;E&gt; iterator() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4894,13 +4973,16 @@</span>
       * @serial include
       */
      private static class SingletonMap&lt;K,V&gt;
            extends AbstractMap&lt;K,V&gt;
            implements Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -6979724477215052911L;
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final K k;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final V v;
  
          SingletonMap(K key, V value) {
              k = key;
              v = value;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5031,13 +5113,15 @@</span>
       */
      private static class CopiesList&lt;E&gt;
          extends AbstractList&lt;E&gt;
          implements RandomAccess, Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 2739099268398711800L;
  
          final int n;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final E element;
  
          CopiesList(int n, E e) {
              assert n &gt;= 0;
              this.n = n;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5161,10 +5245,16 @@</span>
  
          @Override
          public Spliterator&lt;E&gt; spliterator() {
              return stream().spliterator();
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @java.io.Serial</span>
<span class="udiff-line-added">+         private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {</span>
<span class="udiff-line-added">+             ois.defaultReadObject();</span>
<span class="udiff-line-added">+             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, n);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Returns a comparator that imposes the reverse of the &lt;em&gt;natural
       * ordering&lt;/em&gt; on a collection of objects that implement the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5194,19 +5284,21 @@</span>
       * @serial include
       */
      private static class ReverseComparator
          implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable {
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 7207038068494060240L;
  
          static final ReverseComparator REVERSE_ORDER
              = new ReverseComparator();
  
          public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {
              return c2.compareTo(c1);
          }
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() { return Collections.reverseOrder(); }
  
          @Override
          public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() {
              return Comparator.naturalOrder();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5249,19 +5341,21 @@</span>
       * @serial include
       */
      private static class ReverseComparator2&lt;T&gt; implements Comparator&lt;T&gt;,
          Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 4374092139857L;
  
          /**
           * The comparator specified in the static factory.  This will never
           * be null, as the static factory returns a ReverseComparator
           * instance if its argument is null.
           *
           * @serial
           */
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          final Comparator&lt;T&gt; cmp;
  
          ReverseComparator2(Comparator&lt;T&gt; cmp) {
              assert cmp != null;
              this.cmp = cmp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5539,10 +5633,11 @@</span>
       * @serial include
       */
      private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt;
          implements Set&lt;E&gt;, Serializable
      {
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final Map&lt;E, Boolean&gt; m;  // The backing map
          private transient Set&lt;E&gt; s;       // Its keySet
  
          SetFromMap(Map&lt;E, Boolean&gt; map) {
              if (!map.isEmpty())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5583,12 +5678,14 @@</span>
          @Override
          public Stream&lt;E&gt; stream()           {return s.stream();}
          @Override
          public Stream&lt;E&gt; parallelStream()   {return s.parallelStream();}
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 2454657854757543876L;
  
<span class="udiff-line-added">+         @java.io.Serial</span>
          private void readObject(java.io.ObjectInputStream stream)
              throws IOException, ClassNotFoundException
          {
              stream.defaultReadObject();
              s = m.keySet();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5620,11 +5717,13 @@</span>
      /**
       * @serial include
       */
      static class AsLIFOQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
          implements Queue&lt;E&gt;, Serializable {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 1802017725587941708L;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final Deque&lt;E&gt; q;
          AsLIFOQueue(Deque&lt;E&gt; q)                     { this.q = q; }
          public boolean add(E e)                     { q.addFirst(e); return true; }
          public boolean offer(E e)                   { return q.offerFirst(e); }
          public E poll()                             { return q.pollFirst(); }
</pre>
<center><a href="Collection.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Comparators.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/CallSite.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BoundMethodHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ClassSpecializer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/CallSite.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 70   System.out.println(java.util.Arrays.deepToString(args));
 71 }
 72 private static final MethodHandle printArgs;
 73 static {
 74   MethodHandles.Lookup lookup = MethodHandles.lookup();
 75   Class thisClass = lookup.lookupClass();  // (who am I?)
 76   printArgs = lookup.findStatic(thisClass,
 77       &quot;printArgs&quot;, MethodType.methodType(void.class, Object[].class));
 78 }
 79 private static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {
 80   // ignore caller and name, but match the type:
 81   return new ConstantCallSite(printArgs.asType(type));
 82 }
 83 }&lt;/pre&gt;&lt;/blockquote&gt;
 84  * @author John Rose, JSR 292 EG
 85  * @since 1.7
 86  */
 87 abstract
 88 public class CallSite {
 89 
<span class="line-modified"> 90     // The actual payload of this call site:</span>

 91     /*package-private*/
<span class="line-modified"> 92     MethodHandle target;    // Note: This field is known to the JVM.  Do not change.</span>
 93 
 94     /**
 95      * Make a blank call site object with the given method type.
 96      * An initial target method is supplied which will throw
 97      * an {@link IllegalStateException} if called.
 98      * &lt;p&gt;
 99      * Before this {@code CallSite} object is returned from a bootstrap method,
100      * it is usually provided with a more useful target method,
101      * via a call to {@link CallSite#setTarget(MethodHandle) setTarget}.
102      * @throws NullPointerException if the proposed type is null
103      */
104     /*package-private*/
105     CallSite(MethodType type) {
106         target = makeUninitializedCallSite(type);
107     }
108 
109     /**
110      * Make a call site object equipped with an initial target method handle.
111      * @param target the method handle which will be the initial target of the call site
112      * @throws NullPointerException if the proposed target is null
113      */
114     /*package-private*/
115     CallSite(MethodHandle target) {
116         target.type();  // null check
117         this.target = target;
118     }
119 
120     /**
121      * Make a call site object equipped with an initial target method handle.
122      * @param targetType the desired type of the call site
123      * @param createTargetHook a hook which will bind the call site to the target method handle
124      * @throws WrongMethodTypeException if the hook cannot be invoked on the required arguments,
125      *         or if the target returned by the hook is not of the given {@code targetType}
126      * @throws NullPointerException if the hook returns a null value
127      * @throws ClassCastException if the hook returns something other than a {@code MethodHandle}
128      * @throws Throwable anything else thrown by the hook function
129      */
130     /*package-private*/
131     CallSite(MethodType targetType, MethodHandle createTargetHook) throws Throwable {
<span class="line-modified">132         this(targetType);</span>
133         ConstantCallSite selfCCS = (ConstantCallSite) this;
134         MethodHandle boundTarget = (MethodHandle) createTargetHook.invokeWithArguments(selfCCS);
<span class="line-modified">135         checkTargetChange(this.target, boundTarget);</span>
<span class="line-modified">136         this.target = boundTarget;</span>
137     }
138 
139     /**
140      * {@code CallSite} dependency context.
141      * JVM uses CallSite.context to store nmethod dependencies on the call site target.
142      */
143     private final MethodHandleNatives.CallSiteContext context = MethodHandleNatives.CallSiteContext.make(this);
144 
145     /**
146      * Returns the type of this call site&#39;s target.
147      * Although targets may change, any call site&#39;s type is permanent, and can never change to an unequal type.
148      * The {@code setTarget} method enforces this invariant by refusing any new target that does
149      * not have the previous target&#39;s type.
150      * @return the type of the current target, which is also the type of any future target
151      */
152     public MethodType type() {
153         // warning:  do not call getTarget here, because CCS.getTarget can throw IllegalStateException
154         return target.type();
155     }
156 
</pre>
<hr />
<pre>
173     /**
174      * Updates the target method of this call site, according to the
175      * behavior defined by this call site&#39;s specific class.
176      * The immediate subclasses of {@code CallSite} document the
177      * class-specific behaviors of this method.
178      * &lt;p&gt;
179      * The type of the new target must be {@linkplain MethodType#equals equal to}
180      * the type of the old target.
181      *
182      * @param newTarget the new target
183      * @throws NullPointerException if the proposed new target is null
184      * @throws WrongMethodTypeException if the proposed new target
185      *         has a method type that differs from the previous target
186      * @see CallSite#getTarget
187      * @see ConstantCallSite#setTarget
188      * @see MutableCallSite#setTarget
189      * @see VolatileCallSite#setTarget
190      */
191     public abstract void setTarget(MethodHandle newTarget);
192 
<span class="line-modified">193     void checkTargetChange(MethodHandle oldTarget, MethodHandle newTarget) {</span>
<span class="line-modified">194         MethodType oldType = oldTarget.type();</span>
195         MethodType newType = newTarget.type();  // null check!
<span class="line-modified">196         if (!newType.equals(oldType))</span>
197             throw wrongTargetType(newTarget, oldType);

198     }
199 
200     private static WrongMethodTypeException wrongTargetType(MethodHandle target, MethodType type) {
201         return new WrongMethodTypeException(String.valueOf(target)+&quot; should be of type &quot;+type);
202     }
203 
204     /**
205      * Produces a method handle equivalent to an invokedynamic instruction
206      * which has been linked to this call site.
207      * &lt;p&gt;
208      * This method is equivalent to the following code:
209      * &lt;blockquote&gt;&lt;pre&gt;{@code
210      * MethodHandle getTarget, invoker, result;
211      * getTarget = MethodHandles.publicLookup().bind(this, &quot;getTarget&quot;, MethodType.methodType(MethodHandle.class));
212      * invoker = MethodHandles.exactInvoker(this.type());
213      * result = MethodHandles.foldArguments(invoker, getTarget)
214      * }&lt;/pre&gt;&lt;/blockquote&gt;
215      *
216      * @return a method handle which always invokes this call site&#39;s current target
217      */
218     public abstract MethodHandle dynamicInvoker();
219 
<span class="line-modified">220     /*non-public*/ MethodHandle makeDynamicInvoker() {</span>

221         MethodHandle getTarget = getTargetHandle().bindArgumentL(0, this);
222         MethodHandle invoker = MethodHandles.exactInvoker(this.type());
223         return MethodHandles.foldArguments(invoker, getTarget);
224     }
225 
226     private static @Stable MethodHandle GET_TARGET;
227     private static MethodHandle getTargetHandle() {
228         MethodHandle handle = GET_TARGET;
229         if (handle != null) {
230             return handle;
231         }
232         try {
233             return GET_TARGET = IMPL_LOOKUP.
234                     findVirtual(CallSite.class, &quot;getTarget&quot;,
235                                 MethodType.methodType(MethodHandle.class));
236         } catch (ReflectiveOperationException e) {
237             throw newInternalError(e);
238         }
239     }
240 
</pre>
<hr />
<pre>
265             invoker = uninitializedCallSiteHandle().asType(basicType);
266             invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_UNINIT_CS, invoker);
267         }
268         // unchecked view is OK since no values will be received or returned
269         return invoker.viewAsType(targetType, false);
270     }
271 
272     // unsafe stuff:
273     private static @Stable long TARGET_OFFSET;
274     private static long getTargetOffset() {
275         long offset = TARGET_OFFSET;
276         if (offset &gt; 0) {
277             return offset;
278         }
279         offset = TARGET_OFFSET = UNSAFE.objectFieldOffset(CallSite.class, &quot;target&quot;);
280         assert(offset &gt; 0);
281         return offset;
282     }
283 
284     /*package-private*/
<span class="line-modified">285     void setTargetNormal(MethodHandle newTarget) {</span>

286         MethodHandleNatives.setCallSiteTargetNormal(this, newTarget);
287     }

288     /*package-private*/
<span class="line-modified">289     MethodHandle getTargetVolatile() {</span>
290         return (MethodHandle) UNSAFE.getReferenceVolatile(this, getTargetOffset());
291     }

292     /*package-private*/
<span class="line-modified">293     void setTargetVolatile(MethodHandle newTarget) {</span>

294         MethodHandleNatives.setCallSiteTargetVolatile(this, newTarget);
295     }
296 
297     // this implements the upcall from the JVM, MethodHandleNatives.linkCallSite:

298     static CallSite makeSite(MethodHandle bootstrapMethod,
299                              // Callee information:
300                              String name, MethodType type,
301                              // Extra arguments for BSM, if any:
302                              Object info,
303                              // Caller information:
304                              Class&lt;?&gt; callerClass) {
305         CallSite site;
306         try {
307             Object binding = BootstrapMethodInvoker.invoke(
308                     CallSite.class, bootstrapMethod, name, type, info, callerClass);
309             if (binding instanceof CallSite) {
310                 site = (CallSite) binding;
311             } else {
312                 // See the &quot;Linking Exceptions&quot; section for the invokedynamic
313                 // instruction in JVMS 6.5.
314                 // Throws a runtime exception defining the cause that is then
315                 // in the &quot;catch (Throwable ex)&quot; a few lines below wrapped in
316                 // BootstrapMethodError
317                 throw new ClassCastException(&quot;CallSite bootstrap method failed to produce an instance of CallSite&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 70   System.out.println(java.util.Arrays.deepToString(args));
 71 }
 72 private static final MethodHandle printArgs;
 73 static {
 74   MethodHandles.Lookup lookup = MethodHandles.lookup();
 75   Class thisClass = lookup.lookupClass();  // (who am I?)
 76   printArgs = lookup.findStatic(thisClass,
 77       &quot;printArgs&quot;, MethodType.methodType(void.class, Object[].class));
 78 }
 79 private static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {
 80   // ignore caller and name, but match the type:
 81   return new ConstantCallSite(printArgs.asType(type));
 82 }
 83 }&lt;/pre&gt;&lt;/blockquote&gt;
 84  * @author John Rose, JSR 292 EG
 85  * @since 1.7
 86  */
 87 abstract
 88 public class CallSite {
 89 
<span class="line-modified"> 90     // The actual payload of this call site.</span>
<span class="line-added"> 91     // Can be modified using {@link MethodHandleNatives#setCallSiteTargetNormal} or {@link MethodHandleNatives#setCallSiteTargetVolatile}.</span>
 92     /*package-private*/
<span class="line-modified"> 93     final MethodHandle target;  // Note: This field is known to the JVM.</span>
 94 
 95     /**
 96      * Make a blank call site object with the given method type.
 97      * An initial target method is supplied which will throw
 98      * an {@link IllegalStateException} if called.
 99      * &lt;p&gt;
100      * Before this {@code CallSite} object is returned from a bootstrap method,
101      * it is usually provided with a more useful target method,
102      * via a call to {@link CallSite#setTarget(MethodHandle) setTarget}.
103      * @throws NullPointerException if the proposed type is null
104      */
105     /*package-private*/
106     CallSite(MethodType type) {
107         target = makeUninitializedCallSite(type);
108     }
109 
110     /**
111      * Make a call site object equipped with an initial target method handle.
112      * @param target the method handle which will be the initial target of the call site
113      * @throws NullPointerException if the proposed target is null
114      */
115     /*package-private*/
116     CallSite(MethodHandle target) {
117         target.type();  // null check
118         this.target = target;
119     }
120 
121     /**
122      * Make a call site object equipped with an initial target method handle.
123      * @param targetType the desired type of the call site
124      * @param createTargetHook a hook which will bind the call site to the target method handle
125      * @throws WrongMethodTypeException if the hook cannot be invoked on the required arguments,
126      *         or if the target returned by the hook is not of the given {@code targetType}
127      * @throws NullPointerException if the hook returns a null value
128      * @throws ClassCastException if the hook returns something other than a {@code MethodHandle}
129      * @throws Throwable anything else thrown by the hook function
130      */
131     /*package-private*/
132     CallSite(MethodType targetType, MethodHandle createTargetHook) throws Throwable {
<span class="line-modified">133         this(targetType); // need to initialize target to make CallSite.type() work in createTargetHook</span>
134         ConstantCallSite selfCCS = (ConstantCallSite) this;
135         MethodHandle boundTarget = (MethodHandle) createTargetHook.invokeWithArguments(selfCCS);
<span class="line-modified">136         setTargetNormal(boundTarget); // ConstantCallSite doesn&#39;t publish CallSite.target</span>
<span class="line-modified">137         UNSAFE.storeStoreFence(); // barrier between target and isFrozen updates</span>
138     }
139 
140     /**
141      * {@code CallSite} dependency context.
142      * JVM uses CallSite.context to store nmethod dependencies on the call site target.
143      */
144     private final MethodHandleNatives.CallSiteContext context = MethodHandleNatives.CallSiteContext.make(this);
145 
146     /**
147      * Returns the type of this call site&#39;s target.
148      * Although targets may change, any call site&#39;s type is permanent, and can never change to an unequal type.
149      * The {@code setTarget} method enforces this invariant by refusing any new target that does
150      * not have the previous target&#39;s type.
151      * @return the type of the current target, which is also the type of any future target
152      */
153     public MethodType type() {
154         // warning:  do not call getTarget here, because CCS.getTarget can throw IllegalStateException
155         return target.type();
156     }
157 
</pre>
<hr />
<pre>
174     /**
175      * Updates the target method of this call site, according to the
176      * behavior defined by this call site&#39;s specific class.
177      * The immediate subclasses of {@code CallSite} document the
178      * class-specific behaviors of this method.
179      * &lt;p&gt;
180      * The type of the new target must be {@linkplain MethodType#equals equal to}
181      * the type of the old target.
182      *
183      * @param newTarget the new target
184      * @throws NullPointerException if the proposed new target is null
185      * @throws WrongMethodTypeException if the proposed new target
186      *         has a method type that differs from the previous target
187      * @see CallSite#getTarget
188      * @see ConstantCallSite#setTarget
189      * @see MutableCallSite#setTarget
190      * @see VolatileCallSite#setTarget
191      */
192     public abstract void setTarget(MethodHandle newTarget);
193 
<span class="line-modified">194     private void checkTargetChange(MethodHandle newTarget) {</span>
<span class="line-modified">195         MethodType oldType = target.type(); // target is always present</span>
196         MethodType newType = newTarget.type();  // null check!
<span class="line-modified">197         if (newType != oldType) {</span>
198             throw wrongTargetType(newTarget, oldType);
<span class="line-added">199         }</span>
200     }
201 
202     private static WrongMethodTypeException wrongTargetType(MethodHandle target, MethodType type) {
203         return new WrongMethodTypeException(String.valueOf(target)+&quot; should be of type &quot;+type);
204     }
205 
206     /**
207      * Produces a method handle equivalent to an invokedynamic instruction
208      * which has been linked to this call site.
209      * &lt;p&gt;
210      * This method is equivalent to the following code:
211      * &lt;blockquote&gt;&lt;pre&gt;{@code
212      * MethodHandle getTarget, invoker, result;
213      * getTarget = MethodHandles.publicLookup().bind(this, &quot;getTarget&quot;, MethodType.methodType(MethodHandle.class));
214      * invoker = MethodHandles.exactInvoker(this.type());
215      * result = MethodHandles.foldArguments(invoker, getTarget)
216      * }&lt;/pre&gt;&lt;/blockquote&gt;
217      *
218      * @return a method handle which always invokes this call site&#39;s current target
219      */
220     public abstract MethodHandle dynamicInvoker();
221 
<span class="line-modified">222     /*package-private*/</span>
<span class="line-added">223     MethodHandle makeDynamicInvoker() {</span>
224         MethodHandle getTarget = getTargetHandle().bindArgumentL(0, this);
225         MethodHandle invoker = MethodHandles.exactInvoker(this.type());
226         return MethodHandles.foldArguments(invoker, getTarget);
227     }
228 
229     private static @Stable MethodHandle GET_TARGET;
230     private static MethodHandle getTargetHandle() {
231         MethodHandle handle = GET_TARGET;
232         if (handle != null) {
233             return handle;
234         }
235         try {
236             return GET_TARGET = IMPL_LOOKUP.
237                     findVirtual(CallSite.class, &quot;getTarget&quot;,
238                                 MethodType.methodType(MethodHandle.class));
239         } catch (ReflectiveOperationException e) {
240             throw newInternalError(e);
241         }
242     }
243 
</pre>
<hr />
<pre>
268             invoker = uninitializedCallSiteHandle().asType(basicType);
269             invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_UNINIT_CS, invoker);
270         }
271         // unchecked view is OK since no values will be received or returned
272         return invoker.viewAsType(targetType, false);
273     }
274 
275     // unsafe stuff:
276     private static @Stable long TARGET_OFFSET;
277     private static long getTargetOffset() {
278         long offset = TARGET_OFFSET;
279         if (offset &gt; 0) {
280             return offset;
281         }
282         offset = TARGET_OFFSET = UNSAFE.objectFieldOffset(CallSite.class, &quot;target&quot;);
283         assert(offset &gt; 0);
284         return offset;
285     }
286 
287     /*package-private*/
<span class="line-modified">288     final void setTargetNormal(MethodHandle newTarget) {</span>
<span class="line-added">289         checkTargetChange(newTarget);</span>
290         MethodHandleNatives.setCallSiteTargetNormal(this, newTarget);
291     }
<span class="line-added">292 </span>
293     /*package-private*/
<span class="line-modified">294     final MethodHandle getTargetVolatile() {</span>
295         return (MethodHandle) UNSAFE.getReferenceVolatile(this, getTargetOffset());
296     }
<span class="line-added">297 </span>
298     /*package-private*/
<span class="line-modified">299     final void setTargetVolatile(MethodHandle newTarget) {</span>
<span class="line-added">300         checkTargetChange(newTarget);</span>
301         MethodHandleNatives.setCallSiteTargetVolatile(this, newTarget);
302     }
303 
304     // this implements the upcall from the JVM, MethodHandleNatives.linkCallSite:
<span class="line-added">305     /*package-private*/</span>
306     static CallSite makeSite(MethodHandle bootstrapMethod,
307                              // Callee information:
308                              String name, MethodType type,
309                              // Extra arguments for BSM, if any:
310                              Object info,
311                              // Caller information:
312                              Class&lt;?&gt; callerClass) {
313         CallSite site;
314         try {
315             Object binding = BootstrapMethodInvoker.invoke(
316                     CallSite.class, bootstrapMethod, name, type, info, callerClass);
317             if (binding instanceof CallSite) {
318                 site = (CallSite) binding;
319             } else {
320                 // See the &quot;Linking Exceptions&quot; section for the invokedynamic
321                 // instruction in JVMS 6.5.
322                 // Throws a runtime exception defining the cause that is then
323                 // in the &quot;catch (Throwable ex)&quot; a few lines below wrapped in
324                 // BootstrapMethodError
325                 throw new ClassCastException(&quot;CallSite bootstrap method failed to produce an instance of CallSite&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="BoundMethodHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ClassSpecializer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
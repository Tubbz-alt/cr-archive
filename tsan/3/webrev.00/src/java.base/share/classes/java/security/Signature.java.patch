diff a/src/java.base/share/classes/java/security/Signature.java b/src/java.base/share/classes/java/security/Signature.java
--- a/src/java.base/share/classes/java/security/Signature.java
+++ b/src/java.base/share/classes/java/security/Signature.java
@@ -38,10 +38,12 @@
 
 import javax.crypto.Cipher;
 import javax.crypto.IllegalBlockSizeException;
 import javax.crypto.BadPaddingException;
 import javax.crypto.NoSuchPaddingException;
+import jdk.internal.access.JavaSecuritySignatureAccess;
+import jdk.internal.access.SharedSecrets;
 
 import sun.security.util.Debug;
 import sun.security.jca.*;
 import sun.security.jca.GetInstance.Instance;
 
@@ -116,10 +118,38 @@
  *
  */
 
 public abstract class Signature extends SignatureSpi {
 
+    static {
+        SharedSecrets.setJavaSecuritySignatureAccess(
+            new JavaSecuritySignatureAccess() {
+                @Override
+                public void initVerify(Signature s, PublicKey publicKey,
+                        AlgorithmParameterSpec params)
+                        throws InvalidKeyException,
+                        InvalidAlgorithmParameterException {
+                    s.initVerify(publicKey, params);
+                }
+                @Override
+                public void initVerify(Signature s,
+                        java.security.cert.Certificate certificate,
+                        AlgorithmParameterSpec params)
+                        throws InvalidKeyException,
+                        InvalidAlgorithmParameterException {
+                    s.initVerify(certificate, params);
+                }
+                @Override
+                public void initSign(Signature s, PrivateKey privateKey,
+                        AlgorithmParameterSpec params, SecureRandom random)
+                        throws InvalidKeyException,
+                        InvalidAlgorithmParameterException {
+                    s.initSign(privateKey, params, random);
+                }
+        });
+    }
+
     private static final Debug debug =
                         Debug.getInstance("jca", "Signature");
 
     private static final Debug pdebug =
                         Debug.getInstance("provider", "Provider");
@@ -466,11 +496,11 @@
      * of this call.
      *
      * @param publicKey the public key of the identity whose signature is
      * going to be verified.
      *
-     * @exception InvalidKeyException if the key is invalid.
+     * @throws    InvalidKeyException if the key is invalid.
      */
     public final void initVerify(PublicKey publicKey)
             throws InvalidKeyException {
         engineInitVerify(publicKey);
         state = VERIFY;
@@ -479,10 +509,57 @@
             pdebug.println("Signature." + algorithm +
                 " verification algorithm from: " + getProviderName());
         }
     }
 
+    /**
+     * Initialize this object for verification. If this method is called
+     * again with different arguments, it negates the effect
+     * of this call.
+     *
+     * @param publicKey the public key of the identity whose signature is
+     * going to be verified.
+     * @param params the parameters used for verifying this signature.
+     *
+     * @throws    InvalidKeyException if the key is invalid.
+     * @throws    InvalidAlgorithmParameterException if the params is invalid.
+     */
+    final void initVerify(PublicKey publicKey, AlgorithmParameterSpec params)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        engineInitVerify(publicKey, params);
+        state = VERIFY;
+
+        if (!skipDebug && pdebug != null) {
+            pdebug.println("Signature." + algorithm +
+                " verification algorithm from: " + getProviderName());
+        }
+    }
+
+    private static PublicKey getPublicKeyFromCert(Certificate cert)
+            throws InvalidKeyException {
+        // If the certificate is of type X509Certificate,
+        // we should check whether it has a Key Usage
+        // extension marked as critical.
+        //if (cert instanceof java.security.cert.X509Certificate) {
+        if (cert instanceof X509Certificate) {
+            // Check whether the cert has a key usage extension
+            // marked as a critical extension.
+            // The OID for KeyUsage extension is 2.5.29.15.
+            X509Certificate c = (X509Certificate)cert;
+            Set<String> critSet = c.getCriticalExtensionOIDs();
+
+            if (critSet != null && !critSet.isEmpty()
+                && critSet.contains("2.5.29.15")) {
+                boolean[] keyUsageInfo = c.getKeyUsage();
+                // keyUsageInfo[0] is for digitalSignature.
+                if ((keyUsageInfo != null) && (keyUsageInfo[0] == false))
+                    throw new InvalidKeyException("Wrong key usage");
+            }
+        }
+        return cert.getPublicKey();
+    }
+
     /**
      * Initializes this object for verification, using the public key from
      * the given certificate.
      * <p>If the certificate is of type X.509 and has a <i>key usage</i>
      * extension field marked as critical, and the value of the <i>key usage</i>
@@ -492,38 +569,51 @@
      * {@code InvalidKeyException} is thrown.
      *
      * @param certificate the certificate of the identity whose signature is
      * going to be verified.
      *
-     * @exception InvalidKeyException  if the public key in the certificate
+     * @throws    InvalidKeyException  if the public key in the certificate
      * is not encoded properly or does not include required  parameter
      * information or cannot be used for digital signature purposes.
      * @since 1.3
      */
     public final void initVerify(Certificate certificate)
             throws InvalidKeyException {
-        // If the certificate is of type X509Certificate,
-        // we should check whether it has a Key Usage
-        // extension marked as critical.
-        if (certificate instanceof java.security.cert.X509Certificate) {
-            // Check whether the cert has a key usage extension
-            // marked as a critical extension.
-            // The OID for KeyUsage extension is 2.5.29.15.
-            X509Certificate cert = (X509Certificate)certificate;
-            Set<String> critSet = cert.getCriticalExtensionOIDs();
+        engineInitVerify(getPublicKeyFromCert(certificate));
+        state = VERIFY;
 
-            if (critSet != null && !critSet.isEmpty()
-                && critSet.contains("2.5.29.15")) {
-                boolean[] keyUsageInfo = cert.getKeyUsage();
-                // keyUsageInfo[0] is for digitalSignature.
-                if ((keyUsageInfo != null) && (keyUsageInfo[0] == false))
-                    throw new InvalidKeyException("Wrong key usage");
-            }
+        if (!skipDebug && pdebug != null) {
+            pdebug.println("Signature." + algorithm +
+                " verification algorithm from: " + getProviderName());
         }
+    }
 
-        PublicKey publicKey = certificate.getPublicKey();
-        engineInitVerify(publicKey);
+    /**
+     * Initializes this object for verification, using the public key from
+     * the given certificate.
+     * <p>If the certificate is of type X.509 and has a <i>key usage</i>
+     * extension field marked as critical, and the value of the <i>key usage</i>
+     * extension field implies that the public key in
+     * the certificate and its corresponding private key are not
+     * supposed to be used for digital signatures, an
+     * {@code InvalidKeyException} is thrown.
+     *
+     * @param certificate the certificate of the identity whose signature is
+     * going to be verified.
+     * @param params the parameters used for verifying this signature.
+     *
+     * @throws    InvalidKeyException  if the public key in the certificate
+     * is not encoded properly or does not include required  parameter
+     * information or cannot be used for digital signature purposes.
+     * @throws    InvalidAlgorithmParameterException if the params is invalid.
+     *
+     * @since 13
+     */
+    final void initVerify(Certificate certificate,
+            AlgorithmParameterSpec params)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        engineInitVerify(getPublicKeyFromCert(certificate), params);
         state = VERIFY;
 
         if (!skipDebug && pdebug != null) {
             pdebug.println("Signature." + algorithm +
                 " verification algorithm from: " + getProviderName());
@@ -536,11 +626,11 @@
      * of this call.
      *
      * @param privateKey the private key of the identity whose signature
      * is going to be generated.
      *
-     * @exception InvalidKeyException if the key is invalid.
+     * @throws    InvalidKeyException if the key is invalid.
      */
     public final void initSign(PrivateKey privateKey)
             throws InvalidKeyException {
         engineInitSign(privateKey);
         state = SIGN;
@@ -559,11 +649,11 @@
      * @param privateKey the private key of the identity whose signature
      * is going to be generated.
      *
      * @param random the source of randomness for this signature.
      *
-     * @exception InvalidKeyException if the key is invalid.
+     * @throws    InvalidKeyException if the key is invalid.
      */
     public final void initSign(PrivateKey privateKey, SecureRandom random)
             throws InvalidKeyException {
         engineInitSign(privateKey, random);
         state = SIGN;
@@ -572,10 +662,35 @@
             pdebug.println("Signature." + algorithm +
                 " signing algorithm from: " + getProviderName());
         }
     }
 
+    /**
+     * Initialize this object for signing. If this method is called
+     * again with different arguments, it negates the effect
+     * of this call.
+     *
+     * @param privateKey the private key of the identity whose signature
+     * is going to be generated.
+     * @param params the parameters used for generating signature.
+     * @param random the source of randomness for this signature.
+     *
+     * @throws    InvalidKeyException if the key is invalid.
+     * @throws    InvalidAlgorithmParameterException if the params is invalid
+     */
+    final void initSign(PrivateKey privateKey,
+            AlgorithmParameterSpec params, SecureRandom random)
+            throws InvalidKeyException, InvalidAlgorithmParameterException {
+        engineInitSign(privateKey, params, random);
+        state = SIGN;
+
+        if (!skipDebug && pdebug != null) {
+            pdebug.println("Signature." + algorithm +
+                " signing algorithm from: " + getProviderName());
+        }
+    }
+
     /**
      * Returns the signature bytes of all the data updated.
      * The format of the signature depends on the underlying
      * signature scheme.
      *
@@ -586,11 +701,11 @@
      * signer, if desired, via new calls to {@code update} and
      * {@code sign}.
      *
      * @return the signature bytes of the signing operation's result.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      * initialized properly or if this signature algorithm is unable to
      * process the input data provided.
      */
     public final byte[] sign() throws SignatureException {
         if (state == SIGN) {
@@ -619,15 +734,15 @@
      * @param len number of bytes within {@code outbuf} allotted for the
      * signature.
      *
      * @return the number of bytes placed into {@code outbuf}.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      *     initialized properly, if this signature algorithm is unable to
      *     process the input data provided, or if {@code len} is less
      *     than the actual signature length.
-     * @exception IllegalArgumentException if {@code outbuf} is {@code null},
+     * @throws    IllegalArgumentException if {@code outbuf} is {@code null},
      *     or {@code offset} or {@code len} is less than 0, or the sum of
      *     {@code offset} and {@code len} is greater than the length of
      *     {@code outbuf}.
      *
      * @since 1.2
@@ -662,11 +777,11 @@
      *
      * @param signature the signature bytes to be verified.
      *
      * @return true if the signature was verified, false if not.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      * initialized properly, the passed-in signature is improperly
      * encoded or of the wrong type, if this signature algorithm is unable to
      * process the input data provided, etc.
      */
     public final boolean verify(byte[] signature) throws SignatureException {
@@ -692,15 +807,15 @@
      * @param offset the offset to start from in the array of bytes.
      * @param length the number of bytes to use, starting at offset.
      *
      * @return true if the signature was verified, false if not.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      * initialized properly, the passed-in signature is improperly
      * encoded or of the wrong type, if this signature algorithm is unable to
      * process the input data provided, etc.
-     * @exception IllegalArgumentException if the {@code signature}
+     * @throws    IllegalArgumentException if the {@code signature}
      * byte array is {@code null}, or the {@code offset} or {@code length}
      * is less than 0, or the sum of the {@code offset} and
      * {@code length} is greater than the length of the
      * {@code signature} byte array.
      * @since 1.4
@@ -729,11 +844,11 @@
     /**
      * Updates the data to be signed or verified by a byte.
      *
      * @param b the byte to use for the update.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      * initialized properly.
      */
     public final void update(byte b) throws SignatureException {
         if (state == VERIFY || state == SIGN) {
             engineUpdate(b);
@@ -747,11 +862,11 @@
      * Updates the data to be signed or verified, using the specified
      * array of bytes.
      *
      * @param data the byte array to use for the update.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      * initialized properly.
      */
     public final void update(byte[] data) throws SignatureException {
         update(data, 0, data.length);
     }
@@ -762,13 +877,13 @@
      *
      * @param data the array of bytes.
      * @param off the offset to start from in the array of bytes.
      * @param len the number of bytes to use, starting at offset.
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      *     initialized properly.
-     * @exception IllegalArgumentException if {@code data} is {@code null},
+     * @throws    IllegalArgumentException if {@code data} is {@code null},
      *     or {@code off} or {@code len} is less than 0, or the sum of
      *     {@code off} and {@code len} is greater than the length of
      *     {@code data}.
      */
     public final void update(byte[] data, int off, int len)
@@ -798,11 +913,11 @@
      * Upon return, the buffer's position will be equal to its limit;
      * its limit will not have changed.
      *
      * @param data the ByteBuffer
      *
-     * @exception SignatureException if this signature object is not
+     * @throws    SignatureException if this signature object is not
      * initialized properly.
      * @since 1.5
      */
     public final void update(ByteBuffer data) throws SignatureException {
         if ((state != SIGN) && (state != VERIFY)) {
@@ -859,11 +974,11 @@
      * at this time.
      *
      * @param param the string identifier of the parameter.
      * @param value the parameter value.
      *
-     * @exception InvalidParameterException if {@code param} is an
+     * @throws    InvalidParameterException if {@code param} is an
      * invalid parameter for this signature algorithm engine,
      * the parameter is already set
      * and cannot be set again, a security exception occurs, and so on.
      *
      * @see #getParameter
@@ -881,11 +996,11 @@
     /**
      * Initializes this signature engine with the specified parameter set.
      *
      * @param params the parameters
      *
-     * @exception InvalidAlgorithmParameterException if the given parameters
+     * @throws    InvalidAlgorithmParameterException if the given parameters
      * are inappropriate for this signature engine
      *
      * @see #getParameters
      */
     public final void setParameter(AlgorithmParameterSpec params)
@@ -926,11 +1041,11 @@
      * @param param the string name of the parameter.
      *
      * @return the object that represents the parameter value, or {@code null} if
      * there is none.
      *
-     * @exception InvalidParameterException if {@code param} is an invalid
+     * @throws    InvalidParameterException if {@code param} is an invalid
      * parameter for this engine, or another exception occurs while
      * trying to get this parameter.
      *
      * @see #setParameter(String, Object)
      *
@@ -945,11 +1060,11 @@
     /**
      * Returns a clone if the implementation is cloneable.
      *
      * @return a clone if the implementation is cloneable.
      *
-     * @exception CloneNotSupportedException if this is called
+     * @throws    CloneNotSupportedException if this is called
      * on an implementation that does not support {@code Cloneable}.
      */
     public Object clone() throws CloneNotSupportedException {
         if (this instanceof Cloneable) {
             return super.clone();
@@ -1009,11 +1124,11 @@
         /**
          * Returns a clone if the delegate is cloneable.
          *
          * @return a clone if the delegate is cloneable.
          *
-         * @exception CloneNotSupportedException if this is called on a
+         * @throws    CloneNotSupportedException if this is called on a
          * delegate that does not support {@code Cloneable}.
          */
         public Object clone() throws CloneNotSupportedException {
             chooseFirstProvider();
             if (sigSpi instanceof Cloneable) {
@@ -1108,15 +1223,17 @@
                 }
                 throw e;
             }
         }
 
-        private void chooseProvider(int type, Key key, SecureRandom random)
-                throws InvalidKeyException {
+        // Used by engineSetParameter/engineInitSign/engineInitVerify() to
+        // find the right provider with the supplied key, parameters, random source
+        private void chooseProvider(int type, Key key,
+                AlgorithmParameterSpec params, SecureRandom random)
+                throws InvalidKeyException, InvalidAlgorithmParameterException {
             synchronized (lock) {
                 if (sigSpi != null) {
-                    init(sigSpi, type, key, random);
                     return;
                 }
                 Exception lastException = null;
                 while ((firstService != null) || serviceIterator.hasNext()) {
                     Service s;
@@ -1125,20 +1242,20 @@
                         firstService = null;
                     } else {
                         s = serviceIterator.next();
                     }
                     // if provider says it does not support this key, ignore it
-                    if (s.supportsParameter(key) == false) {
+                    if (key != null && s.supportsParameter(key) == false) {
                         continue;
                     }
                     // if instance is not a SignatureSpi, ignore it
                     if (isSpi(s) == false) {
                         continue;
                     }
                     try {
                         SignatureSpi spi = newInstance(s);
-                        init(spi, type, key, random);
+                        tryOperation(spi, type, key, params, random);
                         provider = s.getProvider();
                         sigSpi = spi;
                         firstService = null;
                         serviceIterator = null;
                         return;
@@ -1156,62 +1273,114 @@
                     throw (InvalidKeyException)lastException;
                 }
                 if (lastException instanceof RuntimeException) {
                     throw (RuntimeException)lastException;
                 }
+                if (lastException instanceof InvalidAlgorithmParameterException) {
+                    throw (InvalidAlgorithmParameterException)lastException;
+                }
+
                 String k = (key != null) ? key.getClass().getName() : "(null)";
                 throw new InvalidKeyException
                     ("No installed provider supports this key: "
                     + k, lastException);
             }
         }
 
-        private static final int I_PUB     = 1;
-        private static final int I_PRIV    = 2;
-        private static final int I_PRIV_SR = 3;
+        private static final int I_PUB           = 1;
+        private static final int I_PRIV          = 2;
+        private static final int I_PRIV_SR       = 3;
+        private static final int I_PUB_PARAM     = 4;
+        private static final int I_PRIV_PARAM_SR = 5;
+        private static final int S_PARAM         = 6;
 
-        private void init(SignatureSpi spi, int type, Key  key,
-                SecureRandom random) throws InvalidKeyException {
+        private void tryOperation(SignatureSpi spi, int type, Key  key,
+                AlgorithmParameterSpec params, SecureRandom random)
+                throws InvalidKeyException, InvalidAlgorithmParameterException {
             switch (type) {
             case I_PUB:
                 spi.engineInitVerify((PublicKey)key);
                 break;
+            case I_PUB_PARAM:
+                spi.engineInitVerify((PublicKey)key, params);
+                break;
             case I_PRIV:
                 spi.engineInitSign((PrivateKey)key);
                 break;
             case I_PRIV_SR:
                 spi.engineInitSign((PrivateKey)key, random);
                 break;
+            case I_PRIV_PARAM_SR:
+                spi.engineInitSign((PrivateKey)key, params, random);
+                break;
+            case S_PARAM:
+                spi.engineSetParameter(params);
+                break;
             default:
                 throw new AssertionError("Internal error: " + type);
             }
         }
 
         protected void engineInitVerify(PublicKey publicKey)
                 throws InvalidKeyException {
             if (sigSpi != null) {
                 sigSpi.engineInitVerify(publicKey);
             } else {
-                chooseProvider(I_PUB, publicKey, null);
+                try {
+                    chooseProvider(I_PUB, publicKey, null, null);
+                } catch (InvalidAlgorithmParameterException iape) {
+                    // should not happen, re-throw as IKE just in case
+                    throw new InvalidKeyException(iape);
+                }
+            }
+        }
+
+        void engineInitVerify(PublicKey publicKey,
+                AlgorithmParameterSpec params)
+                throws InvalidKeyException, InvalidAlgorithmParameterException {
+            if (sigSpi != null) {
+                sigSpi.engineInitVerify(publicKey, params);
+            } else {
+                chooseProvider(I_PUB_PARAM, publicKey, params, null);
             }
         }
 
         protected void engineInitSign(PrivateKey privateKey)
                 throws InvalidKeyException {
             if (sigSpi != null) {
                 sigSpi.engineInitSign(privateKey);
             } else {
-                chooseProvider(I_PRIV, privateKey, null);
+                try {
+                    chooseProvider(I_PRIV, privateKey, null, null);
+                } catch (InvalidAlgorithmParameterException iape) {
+                    // should not happen, re-throw as IKE just in case
+                    throw new InvalidKeyException(iape);
+                }
             }
         }
 
         protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
                 throws InvalidKeyException {
             if (sigSpi != null) {
                 sigSpi.engineInitSign(privateKey, sr);
             } else {
-                chooseProvider(I_PRIV_SR, privateKey, sr);
+                try {
+                    chooseProvider(I_PRIV_SR, privateKey, null, sr);
+                } catch (InvalidAlgorithmParameterException iape) {
+                    // should not happen, re-throw as IKE just in case
+                    throw new InvalidKeyException(iape);
+                }
+            }
+        }
+
+        void engineInitSign(PrivateKey privateKey,
+                AlgorithmParameterSpec params, SecureRandom sr)
+                throws InvalidKeyException, InvalidAlgorithmParameterException {
+            if (sigSpi != null) {
+                sigSpi.engineInitSign(privateKey, params, sr);
+            } else {
+                chooseProvider(I_PRIV_PARAM_SR, privateKey, params, sr);
             }
         }
 
         protected void engineUpdate(byte b) throws SignatureException {
             chooseFirstProvider();
@@ -1258,12 +1427,20 @@
             sigSpi.engineSetParameter(param, value);
         }
 
         protected void engineSetParameter(AlgorithmParameterSpec params)
                 throws InvalidAlgorithmParameterException {
-            chooseFirstProvider();
-            sigSpi.engineSetParameter(params);
+            if (sigSpi != null) {
+                sigSpi.engineSetParameter(params);
+            } else {
+                try {
+                    chooseProvider(S_PARAM, null, params, null);
+                } catch (InvalidKeyException ike) {
+                    // should never happen, rethrow just in case
+                    throw new InvalidAlgorithmParameterException(ike);
+                }
+            }
         }
 
         protected Object engineGetParameter(String param)
                 throws InvalidParameterException {
             chooseFirstProvider();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Direct-X-Buffer-bin.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Heap-X-Buffer.java.template.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #warn This file is preprocessed before being compiled
 27 
 28 package java.nio;
 29 
 30 import java.io.FileDescriptor;
 31 import java.lang.ref.Reference;
 32 import java.util.Objects;

 33 import jdk.internal.misc.VM;
 34 import jdk.internal.ref.Cleaner;
 35 import sun.nio.ch.DirectBuffer;
 36 
 37 
 38 class Direct$Type$Buffer$RW$$BO$
 39 #if[rw]
 40     extends {#if[byte]?Mapped$Type$Buffer:$Type$Buffer}
 41 #else[rw]
 42     extends Direct$Type$Buffer$BO$
 43 #end[rw]
 44     implements DirectBuffer
 45 {
 46 
 47 #if[rw]
 48 
 49     // Cached array base offset
 50     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);
 51 
 52     // Cached unaligned-access capability
</pre>
<hr />
<pre>
 95     }
 96 
 97     private final Cleaner cleaner;
 98 
 99     public Cleaner cleaner() { return cleaner; }
100 
101 #else[byte]
102 
103     public Cleaner cleaner() { return null; }
104 
105 #end[byte]
106 
107 #end[rw]
108 
109 #if[byte]
110 
111     // Primary constructor
112     //
113     Direct$Type$Buffer$RW$(int cap) {                   // package-private
114 #if[rw]
<span class="line-modified">115         super(-1, 0, cap, cap);</span>
116         boolean pa = VM.isDirectMemoryPageAligned();
117         int ps = Bits.pageSize();
118         long size = Math.max(1L, (long)cap + (pa ? ps : 0));
119         Bits.reserveMemory(size, cap);
120 
121         long base = 0;
122         try {
123             base = UNSAFE.allocateMemory(size);
124         } catch (OutOfMemoryError x) {
125             Bits.unreserveMemory(size, cap);
126             throw x;
127         }
128         UNSAFE.setMemory(base, size, (byte) 0);
129         if (pa &amp;&amp; (base % ps != 0)) {
130             // Round up to page boundary
131             address = base + ps - (base &amp; (ps - 1));
132         } else {
133             address = base;
134         }
135         cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
136         att = null;
137 #else[rw]
138         super(cap);
139         this.isReadOnly = true;
140 #end[rw]
141     }
142 
143 #if[rw]
144 
145     // Invoked to construct a direct ByteBuffer referring to the block of
146     // memory. A given arbitrary object may also be attached to the buffer.
147     //
<span class="line-modified">148     Direct$Type$Buffer(long addr, int cap, Object ob) {</span>
<span class="line-modified">149         super(-1, 0, cap, cap);</span>
150         address = addr;
151         cleaner = null;
152         att = ob;
153     }
154 
155 
156     // Invoked only by JNI: NewDirectByteBuffer(void*, long)
157     //
158     private Direct$Type$Buffer(long addr, int cap) {
<span class="line-modified">159         super(-1, 0, cap, cap);</span>
160         address = addr;
161         cleaner = null;
162         att = null;
163     }
164 
165 #end[rw]
166 
167     // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
168     //
169     protected Direct$Type$Buffer$RW$(int cap, long addr,
170                                      FileDescriptor fd,
<span class="line-modified">171                                      Runnable unmapper)</span>

172     {
173 #if[rw]
<span class="line-modified">174         super(-1, 0, cap, cap, fd);</span>
175         address = addr;
176         cleaner = Cleaner.create(this, unmapper);
177         att = null;
178 #else[rw]
<span class="line-modified">179         super(cap, addr, fd, unmapper);</span>
180         this.isReadOnly = true;
181 #end[rw]
182     }
183 
184 #end[byte]
185 
186     // For duplicates and slices
187     //
188     Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private
189                                int mark, int pos, int lim, int cap,
<span class="line-modified">190                                int off)</span>
191     {
192 #if[rw]
<span class="line-modified">193         super(mark, pos, lim, cap);</span>
194         address = db.address() + off;
195 #if[byte]
196         cleaner = null;
197 #end[byte]
198         Object attachment = db.attachment();
199         att = (attachment == null ? db : attachment);
200 #else[rw]
<span class="line-modified">201         super(db, mark, pos, lim, cap, off);</span>
202         this.isReadOnly = true;
203 #end[rw]
204     }
205 
206     @Override
207     Object base() {
208         return null;
209     }
210 
211     public $Type$Buffer slice() {
212         int pos = this.position();
213         int lim = this.limit();
214         assert (pos &lt;= lim);
215         int rem = (pos &lt;= lim ? lim - pos : 0);
216         int off = (pos &lt;&lt; $LG_BYTES_PER_VALUE$);
217         assert (off &gt;= 0);
<span class="line-modified">218         return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off);</span>
219     }
220 
221     @Override
222     public $Type$Buffer slice(int index, int length) {
223         Objects.checkFromIndexSize(index, length, limit());
224         return new Direct$Type$Buffer$RW$$BO$(this,
225                                               -1,
226                                               0,
227                                               length,
228                                               length,
<span class="line-modified">229                                               index);</span>
230     }
231 
232     public $Type$Buffer duplicate() {
233         return new Direct$Type$Buffer$RW$$BO$(this,
234                                               this.markValue(),
235                                               this.position(),
236                                               this.limit(),
237                                               this.capacity(),
<span class="line-modified">238                                               0);</span>
239     }
240 
241     public $Type$Buffer asReadOnlyBuffer() {
242 #if[rw]
243         return new Direct$Type$BufferR$BO$(this,
244                                            this.markValue(),
245                                            this.position(),
246                                            this.limit(),
247                                            this.capacity(),
<span class="line-modified">248                                            0);</span>
249 #else[rw]
250         return duplicate();
251 #end[rw]
252     }
253 
254 #if[rw]
255 
256     public long address() {
257         return address;
258     }
259 
260     private long ix(int i) {
261         return address + ((long)i &lt;&lt; $LG_BYTES_PER_VALUE$);
262     }
263 
264     public $type$ get() {
265         try {

266             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));
267         } finally {
268             Reference.reachabilityFence(this);
269         }
270     }
271 
272     public $type$ get(int i) {
273         try {

274             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));
275         } finally {
276             Reference.reachabilityFence(this);
277         }
278     }
279 
280 #if[streamableType]
281     $type$ getUnchecked(int i) {
282         try {
283             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(i))));
284         } finally {
285             Reference.reachabilityFence(this);
286         }
287     }
288 #end[streamableType]
289 
290     public $Type$Buffer get($type$[] dst, int offset, int length) {
291 #if[rw]

292         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
<span class="line-modified">293             checkBounds(offset, length, dst.length);</span>
294             int pos = position();
295             int lim = limit();
296             assert (pos &lt;= lim);
297             int rem = (pos &lt;= lim ? lim - pos : 0);
298             if (length &gt; rem)
299                 throw new BufferUnderflowException();
300 
301             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
302             try {
303 #if[!byte]
304                 if (order() != ByteOrder.nativeOrder())
305                     UNSAFE.copySwapMemory(null,
306                                           ix(pos),
307                                           dst,
308                                           dstOffset,
309                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
310                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
311                 else
312 #end[!byte]
313                     UNSAFE.copyMemory(null,
314                                       ix(pos),
315                                       dst,
316                                       dstOffset,
317                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
318             } finally {
319                 Reference.reachabilityFence(this);
320             }
321             position(pos + length);
322         } else {
323             super.get(dst, offset, length);
324         }
325         return this;
326 #else[rw]
327         throw new ReadOnlyBufferException();
328 #end[rw]
329     }
330 
331     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
332 #if[rw]

333         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
334             Objects.checkFromIndexSize(index, length, limit());
335             Objects.checkFromIndexSize(offset, length, dst.length);
336 
337             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
338             try {
339 #if[!byte]
340                 if (order() != ByteOrder.nativeOrder())
341                     UNSAFE.copySwapMemory(null,
342                                           ix(index),
343                                           dst,
344                                           dstOffset,
345                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
346                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
347                 else
348 #end[!byte]
349                     UNSAFE.copyMemory(null,
350                                       ix(index),
351                                       dst,
352                                       dstOffset,
353                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
354             } finally {
355                 Reference.reachabilityFence(this);
356             }
357         } else {
358             super.get(index, dst, offset, length);
359         }
360         return this;
361 #else[rw]
362         throw new ReadOnlyBufferException();
363 #end[rw]
364     }
365 #end[rw]
366 
367     public $Type$Buffer put($type$ x) {
368 #if[rw]
369         try {

370             UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));
371         } finally {
372             Reference.reachabilityFence(this);
373         }
374         return this;
375 #else[rw]
376         throw new ReadOnlyBufferException();
377 #end[rw]
378     }
379 
380     public $Type$Buffer put(int i, $type$ x) {
381 #if[rw]
382         try {

383             UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));
384         } finally {
385             Reference.reachabilityFence(this);
386         }
387         return this;
388 #else[rw]
389         throw new ReadOnlyBufferException();
390 #end[rw]
391     }
392 
393     public $Type$Buffer put($Type$Buffer src) {
394 #if[rw]

395         if (src instanceof Direct$Type$Buffer$BO$) {
396             if (src == this)
397                 throw createSameBufferException();
398             Direct$Type$Buffer$RW$$BO$ sb = (Direct$Type$Buffer$RW$$BO$)src;
399 
400             int spos = sb.position();
401             int slim = sb.limit();
402             assert (spos &lt;= slim);
403             int srem = (spos &lt;= slim ? slim - spos : 0);
404 
405             int pos = position();
406             int lim = limit();
407             assert (pos &lt;= lim);
408             int rem = (pos &lt;= lim ? lim - pos : 0);
409 
410             if (srem &gt; rem)
411                 throw new BufferOverflowException();
412             try {
413                 UNSAFE.copyMemory(sb.ix(spos), ix(pos), (long)srem &lt;&lt; $LG_BYTES_PER_VALUE$);
414             } finally {
</pre>
<hr />
<pre>
421 
422             int spos = src.position();
423             int slim = src.limit();
424             assert (spos &lt;= slim);
425             int srem = (spos &lt;= slim ? slim - spos : 0);
426 
427             put(src.hb, src.offset + spos, srem);
428             src.position(spos + srem);
429 
430         } else {
431             super.put(src);
432         }
433         return this;
434 #else[rw]
435         throw new ReadOnlyBufferException();
436 #end[rw]
437     }
438 
439     public $Type$Buffer put($type$[] src, int offset, int length) {
440 #if[rw]

441         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
<span class="line-modified">442             checkBounds(offset, length, src.length);</span>
443             int pos = position();
444             int lim = limit();
445             assert (pos &lt;= lim);
446             int rem = (pos &lt;= lim ? lim - pos : 0);
447             if (length &gt; rem)
448                 throw new BufferOverflowException();
449 
450             long srcOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
451             try {
452 #if[!byte]
453                 if (order() != ByteOrder.nativeOrder())
454                     UNSAFE.copySwapMemory(src,
455                                           srcOffset,
456                                           null,
457                                           ix(pos),
458                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
459                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
460                 else
461 #end[!byte]
462                     UNSAFE.copyMemory(src,
463                                       srcOffset,
464                                       null,
465                                       ix(pos),
466                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
467             } finally {
468                 Reference.reachabilityFence(this);
469             }
470             position(pos + length);
471         } else {
472             super.put(src, offset, length);
473         }
474         return this;
475 #else[rw]
476         throw new ReadOnlyBufferException();
477 #end[rw]
478     }
479 
480     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
481 #if[rw]

482         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
483             Objects.checkFromIndexSize(index, length, limit());
484             Objects.checkFromIndexSize(offset, length, src.length);
485 
486 
487             long srcOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
488             try {
489 #if[!byte]
490                 if (order() != ByteOrder.nativeOrder())
491                     UNSAFE.copySwapMemory(src,
492                                           srcOffset,
493                                           null,
494                                           ix(index),
495                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
496                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
497                 else
498 #end[!byte]
499                     UNSAFE.copyMemory(src,
500                                       srcOffset,
501                                       null,
</pre>
<hr />
<pre>
528         limit(capacity());
529         discardMark();
530         return this;
531 #else[rw]
532         throw new ReadOnlyBufferException();
533 #end[rw]
534     }
535 
536     public boolean isDirect() {
537         return true;
538     }
539 
540     public boolean isReadOnly() {
541         return {#if[rw]?false:true};
542     }
543 
544 
545 #if[char]
546 
547     public String toString(int start, int end) {
<span class="line-modified">548         if ((end &gt; limit()) || (start &gt; end))</span>
<span class="line-removed">549             throw new IndexOutOfBoundsException();</span>
550         try {
551             int len = end - start;
552             char[] ca = new char[len];
553             CharBuffer cb = CharBuffer.wrap(ca);
554             CharBuffer db = this.duplicate();
555             db.position(start);
556             db.limit(end);
557             cb.put(db);
558             return new String(ca);
559         } catch (StringIndexOutOfBoundsException x) {
560             throw new IndexOutOfBoundsException();
561         }
562     }
563 
564 
565     // --- Methods to support CharSequence ---
566 
567     public CharBuffer subSequence(int start, int end) {
568         int pos = position();
569         int lim = limit();
570         assert (pos &lt;= lim);
571         pos = (pos &lt;= lim ? pos : lim);
572         int len = lim - pos;
573 
<span class="line-modified">574         if ((start &lt; 0) || (end &gt; len) || (start &gt; end))</span>
<span class="line-removed">575             throw new IndexOutOfBoundsException();</span>
576         return new DirectCharBuffer$RW$$BO$(this,
577                                             -1,
578                                             pos + start,
579                                             pos + end,
580                                             capacity(),
<span class="line-modified">581                                             offset);</span>
582     }
583 
584 #end[char]
585 
586 
587 
588 #if[!byte]
589 
590     public ByteOrder order() {
591 #if[boS]
592         return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
593                 ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
594 #end[boS]
595 #if[boU]
596         return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
597                 ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
598 #end[boU]
599     }
600 
601 #end[!byte]
</pre>
</td>
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #warn This file is preprocessed before being compiled
 27 
 28 package java.nio;
 29 
 30 import java.io.FileDescriptor;
 31 import java.lang.ref.Reference;
 32 import java.util.Objects;
<span class="line-added"> 33 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
 34 import jdk.internal.misc.VM;
 35 import jdk.internal.ref.Cleaner;
 36 import sun.nio.ch.DirectBuffer;
 37 
 38 
 39 class Direct$Type$Buffer$RW$$BO$
 40 #if[rw]
 41     extends {#if[byte]?Mapped$Type$Buffer:$Type$Buffer}
 42 #else[rw]
 43     extends Direct$Type$Buffer$BO$
 44 #end[rw]
 45     implements DirectBuffer
 46 {
 47 
 48 #if[rw]
 49 
 50     // Cached array base offset
 51     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);
 52 
 53     // Cached unaligned-access capability
</pre>
<hr />
<pre>
 96     }
 97 
 98     private final Cleaner cleaner;
 99 
100     public Cleaner cleaner() { return cleaner; }
101 
102 #else[byte]
103 
104     public Cleaner cleaner() { return null; }
105 
106 #end[byte]
107 
108 #end[rw]
109 
110 #if[byte]
111 
112     // Primary constructor
113     //
114     Direct$Type$Buffer$RW$(int cap) {                   // package-private
115 #if[rw]
<span class="line-modified">116         super(-1, 0, cap, cap, null);</span>
117         boolean pa = VM.isDirectMemoryPageAligned();
118         int ps = Bits.pageSize();
119         long size = Math.max(1L, (long)cap + (pa ? ps : 0));
120         Bits.reserveMemory(size, cap);
121 
122         long base = 0;
123         try {
124             base = UNSAFE.allocateMemory(size);
125         } catch (OutOfMemoryError x) {
126             Bits.unreserveMemory(size, cap);
127             throw x;
128         }
129         UNSAFE.setMemory(base, size, (byte) 0);
130         if (pa &amp;&amp; (base % ps != 0)) {
131             // Round up to page boundary
132             address = base + ps - (base &amp; (ps - 1));
133         } else {
134             address = base;
135         }
136         cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
137         att = null;
138 #else[rw]
139         super(cap);
140         this.isReadOnly = true;
141 #end[rw]
142     }
143 
144 #if[rw]
145 
146     // Invoked to construct a direct ByteBuffer referring to the block of
147     // memory. A given arbitrary object may also be attached to the buffer.
148     //
<span class="line-modified">149     Direct$Type$Buffer(long addr, int cap, Object ob, MemorySegmentProxy segment) {</span>
<span class="line-modified">150         super(-1, 0, cap, cap, segment);</span>
151         address = addr;
152         cleaner = null;
153         att = ob;
154     }
155 
156 
157     // Invoked only by JNI: NewDirectByteBuffer(void*, long)
158     //
159     private Direct$Type$Buffer(long addr, int cap) {
<span class="line-modified">160         super(-1, 0, cap, cap, null);</span>
161         address = addr;
162         cleaner = null;
163         att = null;
164     }
165 
166 #end[rw]
167 
168     // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
169     //
170     protected Direct$Type$Buffer$RW$(int cap, long addr,
171                                      FileDescriptor fd,
<span class="line-modified">172                                      Runnable unmapper,</span>
<span class="line-added">173                                      boolean isSync, MemorySegmentProxy segment)</span>
174     {
175 #if[rw]
<span class="line-modified">176         super(-1, 0, cap, cap, fd, isSync, segment);</span>
177         address = addr;
178         cleaner = Cleaner.create(this, unmapper);
179         att = null;
180 #else[rw]
<span class="line-modified">181         super(cap, addr, fd, unmapper, isSync, segment);</span>
182         this.isReadOnly = true;
183 #end[rw]
184     }
185 
186 #end[byte]
187 
188     // For duplicates and slices
189     //
190     Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private
191                                int mark, int pos, int lim, int cap,
<span class="line-modified">192                                int off, MemorySegmentProxy segment)</span>
193     {
194 #if[rw]
<span class="line-modified">195         super(mark, pos, lim, cap, segment);</span>
196         address = db.address() + off;
197 #if[byte]
198         cleaner = null;
199 #end[byte]
200         Object attachment = db.attachment();
201         att = (attachment == null ? db : attachment);
202 #else[rw]
<span class="line-modified">203         super(db, mark, pos, lim, cap, off, segment);</span>
204         this.isReadOnly = true;
205 #end[rw]
206     }
207 
208     @Override
209     Object base() {
210         return null;
211     }
212 
213     public $Type$Buffer slice() {
214         int pos = this.position();
215         int lim = this.limit();
216         assert (pos &lt;= lim);
217         int rem = (pos &lt;= lim ? lim - pos : 0);
218         int off = (pos &lt;&lt; $LG_BYTES_PER_VALUE$);
219         assert (off &gt;= 0);
<span class="line-modified">220         return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off, segment);</span>
221     }
222 
223     @Override
224     public $Type$Buffer slice(int index, int length) {
225         Objects.checkFromIndexSize(index, length, limit());
226         return new Direct$Type$Buffer$RW$$BO$(this,
227                                               -1,
228                                               0,
229                                               length,
230                                               length,
<span class="line-modified">231                                               index, segment);</span>
232     }
233 
234     public $Type$Buffer duplicate() {
235         return new Direct$Type$Buffer$RW$$BO$(this,
236                                               this.markValue(),
237                                               this.position(),
238                                               this.limit(),
239                                               this.capacity(),
<span class="line-modified">240                                               0, segment);</span>
241     }
242 
243     public $Type$Buffer asReadOnlyBuffer() {
244 #if[rw]
245         return new Direct$Type$BufferR$BO$(this,
246                                            this.markValue(),
247                                            this.position(),
248                                            this.limit(),
249                                            this.capacity(),
<span class="line-modified">250                                            0, segment);</span>
251 #else[rw]
252         return duplicate();
253 #end[rw]
254     }
255 
256 #if[rw]
257 
258     public long address() {
259         return address;
260     }
261 
262     private long ix(int i) {
263         return address + ((long)i &lt;&lt; $LG_BYTES_PER_VALUE$);
264     }
265 
266     public $type$ get() {
267         try {
<span class="line-added">268             checkSegment();</span>
269             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));
270         } finally {
271             Reference.reachabilityFence(this);
272         }
273     }
274 
275     public $type$ get(int i) {
276         try {
<span class="line-added">277             checkSegment();</span>
278             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));
279         } finally {
280             Reference.reachabilityFence(this);
281         }
282     }
283 
284 #if[streamableType]
285     $type$ getUnchecked(int i) {
286         try {
287             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(i))));
288         } finally {
289             Reference.reachabilityFence(this);
290         }
291     }
292 #end[streamableType]
293 
294     public $Type$Buffer get($type$[] dst, int offset, int length) {
295 #if[rw]
<span class="line-added">296         checkSegment();</span>
297         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
<span class="line-modified">298             Objects.checkFromIndexSize(offset, length, dst.length);</span>
299             int pos = position();
300             int lim = limit();
301             assert (pos &lt;= lim);
302             int rem = (pos &lt;= lim ? lim - pos : 0);
303             if (length &gt; rem)
304                 throw new BufferUnderflowException();
305 
306             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
307             try {
308 #if[!byte]
309                 if (order() != ByteOrder.nativeOrder())
310                     UNSAFE.copySwapMemory(null,
311                                           ix(pos),
312                                           dst,
313                                           dstOffset,
314                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
315                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
316                 else
317 #end[!byte]
318                     UNSAFE.copyMemory(null,
319                                       ix(pos),
320                                       dst,
321                                       dstOffset,
322                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
323             } finally {
324                 Reference.reachabilityFence(this);
325             }
326             position(pos + length);
327         } else {
328             super.get(dst, offset, length);
329         }
330         return this;
331 #else[rw]
332         throw new ReadOnlyBufferException();
333 #end[rw]
334     }
335 
336     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
337 #if[rw]
<span class="line-added">338         checkSegment();</span>
339         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
340             Objects.checkFromIndexSize(index, length, limit());
341             Objects.checkFromIndexSize(offset, length, dst.length);
342 
343             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
344             try {
345 #if[!byte]
346                 if (order() != ByteOrder.nativeOrder())
347                     UNSAFE.copySwapMemory(null,
348                                           ix(index),
349                                           dst,
350                                           dstOffset,
351                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
352                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
353                 else
354 #end[!byte]
355                     UNSAFE.copyMemory(null,
356                                       ix(index),
357                                       dst,
358                                       dstOffset,
359                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
360             } finally {
361                 Reference.reachabilityFence(this);
362             }
363         } else {
364             super.get(index, dst, offset, length);
365         }
366         return this;
367 #else[rw]
368         throw new ReadOnlyBufferException();
369 #end[rw]
370     }
371 #end[rw]
372 
373     public $Type$Buffer put($type$ x) {
374 #if[rw]
375         try {
<span class="line-added">376             checkSegment();</span>
377             UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));
378         } finally {
379             Reference.reachabilityFence(this);
380         }
381         return this;
382 #else[rw]
383         throw new ReadOnlyBufferException();
384 #end[rw]
385     }
386 
387     public $Type$Buffer put(int i, $type$ x) {
388 #if[rw]
389         try {
<span class="line-added">390             checkSegment();</span>
391             UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));
392         } finally {
393             Reference.reachabilityFence(this);
394         }
395         return this;
396 #else[rw]
397         throw new ReadOnlyBufferException();
398 #end[rw]
399     }
400 
401     public $Type$Buffer put($Type$Buffer src) {
402 #if[rw]
<span class="line-added">403         checkSegment();</span>
404         if (src instanceof Direct$Type$Buffer$BO$) {
405             if (src == this)
406                 throw createSameBufferException();
407             Direct$Type$Buffer$RW$$BO$ sb = (Direct$Type$Buffer$RW$$BO$)src;
408 
409             int spos = sb.position();
410             int slim = sb.limit();
411             assert (spos &lt;= slim);
412             int srem = (spos &lt;= slim ? slim - spos : 0);
413 
414             int pos = position();
415             int lim = limit();
416             assert (pos &lt;= lim);
417             int rem = (pos &lt;= lim ? lim - pos : 0);
418 
419             if (srem &gt; rem)
420                 throw new BufferOverflowException();
421             try {
422                 UNSAFE.copyMemory(sb.ix(spos), ix(pos), (long)srem &lt;&lt; $LG_BYTES_PER_VALUE$);
423             } finally {
</pre>
<hr />
<pre>
430 
431             int spos = src.position();
432             int slim = src.limit();
433             assert (spos &lt;= slim);
434             int srem = (spos &lt;= slim ? slim - spos : 0);
435 
436             put(src.hb, src.offset + spos, srem);
437             src.position(spos + srem);
438 
439         } else {
440             super.put(src);
441         }
442         return this;
443 #else[rw]
444         throw new ReadOnlyBufferException();
445 #end[rw]
446     }
447 
448     public $Type$Buffer put($type$[] src, int offset, int length) {
449 #if[rw]
<span class="line-added">450         checkSegment();</span>
451         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
<span class="line-modified">452             Objects.checkFromIndexSize(offset, length, src.length);</span>
453             int pos = position();
454             int lim = limit();
455             assert (pos &lt;= lim);
456             int rem = (pos &lt;= lim ? lim - pos : 0);
457             if (length &gt; rem)
458                 throw new BufferOverflowException();
459 
460             long srcOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
461             try {
462 #if[!byte]
463                 if (order() != ByteOrder.nativeOrder())
464                     UNSAFE.copySwapMemory(src,
465                                           srcOffset,
466                                           null,
467                                           ix(pos),
468                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
469                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
470                 else
471 #end[!byte]
472                     UNSAFE.copyMemory(src,
473                                       srcOffset,
474                                       null,
475                                       ix(pos),
476                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
477             } finally {
478                 Reference.reachabilityFence(this);
479             }
480             position(pos + length);
481         } else {
482             super.put(src, offset, length);
483         }
484         return this;
485 #else[rw]
486         throw new ReadOnlyBufferException();
487 #end[rw]
488     }
489 
490     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
491 #if[rw]
<span class="line-added">492         checkSegment();</span>
493         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
494             Objects.checkFromIndexSize(index, length, limit());
495             Objects.checkFromIndexSize(offset, length, src.length);
496 
497 
498             long srcOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
499             try {
500 #if[!byte]
501                 if (order() != ByteOrder.nativeOrder())
502                     UNSAFE.copySwapMemory(src,
503                                           srcOffset,
504                                           null,
505                                           ix(index),
506                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
507                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
508                 else
509 #end[!byte]
510                     UNSAFE.copyMemory(src,
511                                       srcOffset,
512                                       null,
</pre>
<hr />
<pre>
539         limit(capacity());
540         discardMark();
541         return this;
542 #else[rw]
543         throw new ReadOnlyBufferException();
544 #end[rw]
545     }
546 
547     public boolean isDirect() {
548         return true;
549     }
550 
551     public boolean isReadOnly() {
552         return {#if[rw]?false:true};
553     }
554 
555 
556 #if[char]
557 
558     public String toString(int start, int end) {
<span class="line-modified">559         Objects.checkFromToIndex(start, end, limit());</span>

560         try {
561             int len = end - start;
562             char[] ca = new char[len];
563             CharBuffer cb = CharBuffer.wrap(ca);
564             CharBuffer db = this.duplicate();
565             db.position(start);
566             db.limit(end);
567             cb.put(db);
568             return new String(ca);
569         } catch (StringIndexOutOfBoundsException x) {
570             throw new IndexOutOfBoundsException();
571         }
572     }
573 
574 
575     // --- Methods to support CharSequence ---
576 
577     public CharBuffer subSequence(int start, int end) {
578         int pos = position();
579         int lim = limit();
580         assert (pos &lt;= lim);
581         pos = (pos &lt;= lim ? pos : lim);
582         int len = lim - pos;
583 
<span class="line-modified">584         Objects.checkFromToIndex(start, end, len);</span>

585         return new DirectCharBuffer$RW$$BO$(this,
586                                             -1,
587                                             pos + start,
588                                             pos + end,
589                                             capacity(),
<span class="line-modified">590                                             offset, segment);</span>
591     }
592 
593 #end[char]
594 
595 
596 
597 #if[!byte]
598 
599     public ByteOrder order() {
600 #if[boS]
601         return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
602                 ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
603 #end[boS]
604 #if[boU]
605         return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
606                 ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
607 #end[boU]
608     }
609 
610 #end[!byte]
</pre>
</td>
</tr>
</table>
<center><a href="Direct-X-Buffer-bin.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Heap-X-Buffer.java.template.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
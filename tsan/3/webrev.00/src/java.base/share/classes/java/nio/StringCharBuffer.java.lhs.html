<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/StringCharBuffer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio;
 27 
 28 import java.util.Objects;
 29 
 30 // ## If the sequence is a string, use reflection to share its array
 31 
 32 class StringCharBuffer                                  // package-private
 33     extends CharBuffer
 34 {
 35     CharSequence str;
 36 
 37     StringCharBuffer(CharSequence s, int start, int end) { // package-private
<a name="1" id="anc1"></a><span class="line-modified"> 38         super(-1, start, end, s.length());</span>
 39         int n = s.length();
<a name="2" id="anc2"></a><span class="line-modified"> 40         if ((start &lt; 0) || (start &gt; n) || (end &lt; start) || (end &gt; n))</span>
<span class="line-removed"> 41             throw new IndexOutOfBoundsException();</span>
 42         str = s;
 43         this.isReadOnly = true;
 44     }
 45 
 46     public CharBuffer slice() {
 47         return new StringCharBuffer(str,
 48                                     -1,
 49                                     0,
 50                                     this.remaining(),
 51                                     this.remaining(),
 52                                     offset + this.position());
 53     }
 54 
 55     @Override
 56     public CharBuffer slice(int index, int length) {
 57         Objects.checkFromIndexSize(index, length, limit());
 58         return new StringCharBuffer(str,
 59                                     -1,
 60                                     0,
 61                                     length,
 62                                     length,
 63                                     offset + index);
 64     }
 65 
 66     private StringCharBuffer(CharSequence s,
 67                              int mark,
 68                              int pos,
 69                              int limit,
 70                              int cap,
 71                              int offset) {
<a name="3" id="anc3"></a><span class="line-modified"> 72         super(mark, pos, limit, cap, null, offset);</span>
 73         str = s;
 74         this.isReadOnly = true;
 75     }
 76 
 77     public CharBuffer duplicate() {
 78         return new StringCharBuffer(str, markValue(),
 79                                     position(), limit(), capacity(), offset);
 80     }
 81 
 82     public CharBuffer asReadOnlyBuffer() {
 83         return duplicate();
 84     }
 85 
 86     public final char get() {
 87         return str.charAt(nextGetIndex() + offset);
 88     }
 89 
 90     public final char get(int index) {
 91         return str.charAt(checkIndex(index) + offset);
 92     }
 93 
 94     char getUnchecked(int index) {
 95         return str.charAt(index + offset);
 96     }
 97 
 98     // ## Override bulk get methods for better performance
 99 
100     public final CharBuffer put(char c) {
101         throw new ReadOnlyBufferException();
102     }
103 
104     public final CharBuffer put(int index, char c) {
105         throw new ReadOnlyBufferException();
106     }
107 
108     public final CharBuffer compact() {
109         throw new ReadOnlyBufferException();
110     }
111 
112     public final boolean isReadOnly() {
113         return true;
114     }
115 
116     final String toString(int start, int end) {
117         return str.subSequence(start + offset, end + offset).toString();
118     }
119 
120     public final CharBuffer subSequence(int start, int end) {
121         try {
122             int pos = position();
123             return new StringCharBuffer(str,
124                                         -1,
125                                         pos + checkIndex(start, pos),
126                                         pos + checkIndex(end, pos),
127                                         capacity(),
128                                         offset);
129         } catch (IllegalArgumentException x) {
130             throw new IndexOutOfBoundsException();
131         }
132     }
133 
134     public boolean isDirect() {
135         return false;
136     }
137 
138     public ByteOrder order() {
139         return ByteOrder.nativeOrder();
140     }
141 
142     ByteOrder charRegionOrder() {
143         return null;
144     }
145 
146     public boolean equals(Object ob) {
147         if (this == ob)
148             return true;
149         if (!(ob instanceof CharBuffer))
150             return false;
151         CharBuffer that = (CharBuffer)ob;
152         if (this.remaining() != that.remaining())
153             return false;
154         return BufferMismatch.mismatch(this, this.position(),
155                                        that, that.position(),
156                                        this.remaining()) &lt; 0;
157     }
158 
159     public int compareTo(CharBuffer that) {
160         int i = BufferMismatch.mismatch(this, this.position(),
161                                         that, that.position(),
162                                         Math.min(this.remaining(), that.remaining()));
163         if (i &gt;= 0) {
164             return Character.compare(this.get(this.position() + i), that.get(that.position() + i));
165         }
166         return this.remaining() - that.remaining();
167     }
168 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
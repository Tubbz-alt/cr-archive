diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java
@@ -150,12 +150,11 @@
     // private constructors, or interfaces with multiple but related
     // entry points, must be covered by hand-written or automatically
     // generated adapter classes.
     //
     @CallerSensitive
-    public static
-    <T> T asInterfaceInstance(final Class<T> intfc, final MethodHandle target) {
+    public static <T> T asInterfaceInstance(final Class<T> intfc, final MethodHandle target) {
         if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
             throw newIllegalArgumentException("not a public interface", intfc.getName());
         final MethodHandle mh;
         if (System.getSecurityManager() != null) {
             final Class<?> caller = Reflection.getCallerClass();
@@ -233,12 +232,11 @@
     /**
      * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
      * @param x any reference
      * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
      */
-    public static
-    boolean isWrapperInstance(Object x) {
+    public static boolean isWrapperInstance(Object x) {
         return x instanceof WrapperInstance;
     }
 
     private static WrapperInstance asWrapperInstance(Object x) {
         try {
@@ -256,12 +254,11 @@
      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
      * @param x any reference
      * @return a method handle implementing the unique method
      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
      */
-    public static
-    MethodHandle wrapperInstanceTarget(Object x) {
+    public static MethodHandle wrapperInstanceTarget(Object x) {
         return asWrapperInstance(x).getWrapperInstanceTarget();
     }
 
     /**
      * Recovers the unique single-method interface type for which this wrapper instance was created.
@@ -269,17 +266,15 @@
      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
      * @param x any reference
      * @return the single-method interface type for which the wrapper was created
      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
      */
-    public static
-    Class<?> wrapperInstanceType(Object x) {
+    public static Class<?> wrapperInstanceType(Object x) {
         return asWrapperInstance(x).getWrapperInstanceType();
     }
 
-    private static
-    boolean isObjectMethod(Method m) {
+    private static boolean isObjectMethod(Method m) {
         switch (m.getName()) {
         case "toString":
             return (m.getReturnType() == String.class
                     && m.getParameterTypes().length == 0);
         case "hashCode":
@@ -291,12 +286,11 @@
                     && m.getParameterTypes()[0] == Object.class);
         }
         return false;
     }
 
-    private static
-    Object callObjectMethod(Object self, Method m, Object[] args) {
+    private static Object callObjectMethod(Object self, Method m, Object[] args) {
         assert(isObjectMethod(m)) : m;
         switch (m.getName()) {
         case "toString":
             return self.getClass().getName() + "@" + Integer.toHexString(self.hashCode());
         case "hashCode":
@@ -305,12 +299,11 @@
             return (self == args[0]);
         }
         return null;
     }
 
-    private static
-    Method[] getSingleNameMethods(Class<?> intfc) {
+    private static Method[] getSingleNameMethods(Class<?> intfc) {
         ArrayList<Method> methods = new ArrayList<>();
         String uniqueName = null;
         for (Method m : intfc.getMethods()) {
             if (isObjectMethod(m))  continue;
             if (!Modifier.isAbstract(m.getModifiers()))  continue;
@@ -323,28 +316,25 @@
         }
         if (uniqueName == null)  return null;
         return methods.toArray(new Method[methods.size()]);
     }
 
-    private static
-    boolean isDefaultMethod(Method m) {
+    private static boolean isDefaultMethod(Method m) {
         return !Modifier.isAbstract(m.getModifiers());
     }
 
-    private static
-    boolean hasDefaultMethods(Class<?> intfc) {
+    private static boolean hasDefaultMethods(Class<?> intfc) {
         for (Method m : intfc.getMethods()) {
             if (!isObjectMethod(m) &&
                 !Modifier.isAbstract(m.getModifiers())) {
                 return true;
             }
         }
         return false;
     }
 
-    private static
-    Object callDefaultMethod(ConcurrentHashMap<Method, MethodHandle> defaultMethodMap,
+    private static Object callDefaultMethod(ConcurrentHashMap<Method, MethodHandle> defaultMethodMap,
                              Object self, Class<?> intfc, Method m, Object[] args) throws Throwable {
         assert(isDefaultMethod(m) && !isObjectMethod(m)) : m;
 
         // Lazily compute the associated method handle from the method
         MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -> {

diff a/src/java.base/share/classes/java/lang/Class.java b/src/java.base/share/classes/java/lang/Class.java
--- a/src/java.base/share/classes/java/lang/Class.java
+++ b/src/java.base/share/classes/java/lang/Class.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -44,10 +44,11 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
+import java.lang.reflect.RecordComponent;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.constant.Constable;
 import java.net.URL;
 import java.security.AccessController;
@@ -86,20 +87,19 @@
 import sun.security.util.SecurityConstants;
 import sun.reflect.annotation.*;
 import sun.reflect.misc.ReflectUtil;
 
 /**
- * Instances of the class {@code Class} represent classes and interfaces
- * in a running Java application. An enum type is a kind of class and an
- * annotation type is a kind of interface. Every array also
- * belongs to a class that is reflected as a {@code Class} object
- * that is shared by all arrays with the same element type and number
- * of dimensions.  The primitive Java types ({@code boolean},
- * {@code byte}, {@code char}, {@code short},
- * {@code int}, {@code long}, {@code float}, and
- * {@code double}), and the keyword {@code void} are also
- * represented as {@code Class} objects.
+ * Instances of the class {@code Class} represent classes and
+ * interfaces in a running Java application. An enum type and a record
+ * type are kinds of class; an annotation type is a kind of
+ * interface. Every array also belongs to a class that is reflected as
+ * a {@code Class} object that is shared by all arrays with the same
+ * element type and number of dimensions.  The primitive Java types
+ * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
+ * int}, {@code long}, {@code float}, and {@code double}), and the
+ * keyword {@code void} are also represented as {@code Class} objects.
  *
  * <p> {@code Class} has no public constructor. Instead a {@code Class}
  * object is constructed automatically by the Java Virtual Machine
  * when a class loader invokes one of the
  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
@@ -204,12 +204,12 @@
      * Returns a string describing this {@code Class}, including
      * information about modifiers and type parameters.
      *
      * The string is formatted as a list of type modifiers, if any,
      * followed by the kind of type (empty string for primitive types
-     * and {@code class}, {@code enum}, {@code interface}, or
-     * <code>&#64;</code>{@code interface}, as appropriate), followed
+     * and {@code class}, {@code enum}, {@code interface},
+     * <code>&#64;</code>{@code interface}, or {@code record} as appropriate), followed
      * by the type's name, followed by an angle-bracketed
      * comma-separated list of the type's type parameters, if any,
      * including informative bounds on the type parameters, if any.
      *
      * A space is used to separate modifiers from one another and to
@@ -231,10 +231,11 @@
      * @return a string describing this {@code Class}, including
      * information about modifiers and type parameters
      *
      * @since 1.8
      */
+    @SuppressWarnings("preview")
     public String toGenericString() {
         if (isPrimitive()) {
             return toString();
         } else {
             StringBuilder sb = new StringBuilder();
@@ -261,10 +262,12 @@
                 if (isInterface()) { // Note: all annotation types are interfaces
                     sb.append("interface");
                 } else {
                     if (isEnum())
                         sb.append("enum");
+                    else if (isRecord())
+                        sb.append("record");
                     else
                         sb.append("class");
                 }
                 sb.append(' ');
                 sb.append(getName());
@@ -275,12 +278,11 @@
                 sb.append(Arrays.stream(typeparms)
                           .map(Class::typeVarBounds)
                           .collect(Collectors.joining(",", "<", ">")));
             }
 
-            for (int i = 0; i < arrayDepth; i++)
-                sb.append("[]");
+            if (arrayDepth > 0) sb.append("[]".repeat(arrayDepth));
 
             return sb.toString();
         }
     }
 
@@ -320,14 +322,18 @@
      * {@code X} to be initialized.
      *
      * @param      className   the fully qualified name of the desired class.
      * @return     the {@code Class} object for the class with the
      *             specified name.
-     * @exception LinkageError if the linkage fails
-     * @exception ExceptionInInitializerError if the initialization provoked
+     * @throws    LinkageError if the linkage fails
+     * @throws    ExceptionInInitializerError if the initialization provoked
      *            by this method fails
-     * @exception ClassNotFoundException if the class cannot be located
+     * @throws    ClassNotFoundException if the class cannot be located
+     *
+     * @jls 12.2 Loading of Classes and Interfaces
+     * @jls 12.3 Linking of Classes and Interfaces
+     * @jls 12.4 Initialization of Classes and Interfaces
      */
     @CallerSensitive
     public static Class<?> forName(String className)
                 throws ClassNotFoundException {
         Class<?> caller = Reflection.getCallerClass();
@@ -338,11 +344,11 @@
     /**
      * Returns the {@code Class} object associated with the class or
      * interface with the given string name, using the given class loader.
      * Given the fully qualified name for a class or interface (in the same
      * format returned by {@code getName}) this method attempts to
-     * locate, load, and link the class or interface.  The specified class
+     * locate and load the class or interface.  The specified class
      * loader is used to load the class or interface.  If the parameter
      * {@code loader} is null, the class is loaded through the bootstrap
      * class loader.  The class is initialized only if the
      * {@code initialize} parameter is {@code true} and if it has
      * not been initialized earlier.
@@ -366,35 +372,40 @@
      *
      * <blockquote>
      *  {@code Class.forName("Foo", true, this.getClass().getClassLoader())}
      * </blockquote>
      *
-     * Note that this method throws errors related to loading, linking or
-     * initializing as specified in Sections 12.2, 12.3 and 12.4 of <em>The
-     * Java Language Specification</em>.
+     * Note that this method throws errors related to loading, linking
+     * or initializing as specified in Sections {@jls 12.2}, {@jls
+     * 12.3}, and {@jls 12.4} of <em>The Java Language
+     * Specification</em>.
      * Note that this method does not check whether the requested class
      * is accessible to its caller.
      *
      * @param name       fully qualified name of the desired class
-     * @param initialize if {@code true} the class will be initialized.
-     *                   See Section 12.4 of <em>The Java Language Specification</em>.
+     * @param initialize if {@code true} the class will be initialized (which implies linking).
+     *                   See Section {@jls 12.4} of <em>The Java Language Specification</em>.
      * @param loader     class loader from which the class must be loaded
      * @return           class object representing the desired class
      *
-     * @exception LinkageError if the linkage fails
-     * @exception ExceptionInInitializerError if the initialization provoked
+     * @throws    LinkageError if the linkage fails
+     * @throws    ExceptionInInitializerError if the initialization provoked
      *            by this method fails
-     * @exception ClassNotFoundException if the class cannot be located by
+     * @throws    ClassNotFoundException if the class cannot be located by
      *            the specified class loader
-     * @exception SecurityException
+     * @throws    SecurityException
      *            if a security manager is present, and the {@code loader} is
      *            {@code null}, and the caller's class loader is not
      *            {@code null}, and the caller does not have the
      *            {@link RuntimePermission}{@code ("getClassLoader")}
      *
      * @see       java.lang.Class#forName(String)
      * @see       java.lang.ClassLoader
+     *
+     * @jls 12.2 Loading of Classes and Interfaces
+     * @jls 12.3 Linking of Classes and Interfaces
+     * @jls 12.4 Initialization of Classes and Interfaces
      * @since     1.2
      */
     @CallerSensitive
     public static Class<?> forName(String name, boolean initialize,
                                    ClassLoader loader)
@@ -426,13 +437,13 @@
 
     /**
      * Returns the {@code Class} with the given <a href="ClassLoader.html#binary-name">
      * binary name</a> in the given module.
      *
-     * <p> This method attempts to locate, load, and link the class or interface.
-     * It does not run the class initializer.  If the class is not found, this
-     * method returns {@code null}. </p>
+     * <p> This method attempts to locate and load the class or interface.
+     * It does not link the class, and does not run the class initializer.
+     * If the class is not found, this method returns {@code null}. </p>
      *
      * <p> If the class loader of the given module defines other modules and
      * the given name is a class defined in a different module, this method
      * returns {@code null} after the class is loaded. </p>
      *
@@ -464,10 +475,12 @@
      *         permission check will be performed when a class loader calls
      *         {@link ModuleReader#open(String)} to read the bytes of a class file
      *         in a module.</li>
      *         </ul>
      *
+     * @jls 12.2 Loading of Classes and Interfaces
+     * @jls 12.3 Linking of Classes and Interfaces
      * @since 9
      * @spec JPMS
      */
     @CallerSensitive
     public static Class<?> forName(Module module, String name) {
@@ -646,18 +659,19 @@
      *
      * <p> Specifically, this method tests whether the type represented by the
      * specified {@code Class} parameter can be converted to the type
      * represented by this {@code Class} object via an identity conversion
      * or via a widening reference conversion. See <em>The Java Language
-     * Specification</em>, sections 5.1.1 and 5.1.4 , for details.
+     * Specification</em>, sections {@jls 5.1.1} and {@jls 5.1.4},
+     * for details.
      *
-     * @param cls the {@code Class} object to be checked
-     * @return the {@code boolean} value indicating whether objects of the
-     * type {@code cls} can be assigned to objects of this class
-     * @exception NullPointerException if the specified Class parameter is
+     * @param     cls the {@code Class} object to be checked
+     * @return    the {@code boolean} value indicating whether objects of the
+     *            type {@code cls} can be assigned to objects of this class
+     * @throws    NullPointerException if the specified Class parameter is
      *            null.
-     * @since 1.1
+     * @since     1.1
      */
     @HotSpotIntrinsicCandidate
     public native boolean isAssignableFrom(Class<?> cls);
 
 
@@ -916,11 +930,11 @@
      * the entity (class, interface, primitive type or void) represented by
      * this {@code Class}.
      *
      * <p>If the superclass is a parameterized type, the {@code Type}
      * object returned must accurately reflect the actual type
-     * parameters used in the source code. The parameterized type
+     * arguments used in the source code. The parameterized type
      * representing the superclass is created if it had not been
      * created before. See the declaration of {@link
      * java.lang.reflect.ParameterizedType ParameterizedType} for the
      * semantics of the creation process for parameterized types.  If
      * this {@code Class} represents either the {@code Object}
@@ -998,11 +1012,11 @@
      *
      * @return the fully qualified package name
      *
      * @since 9
      * @spec JPMS
-     * @jls 6.7  Fully Qualified Names
+     * @jls 6.7 Fully Qualified Names
      */
     public String getPackageName() {
         String pn = this.packageName;
         if (pn == null) {
             Class<?> c = this;
@@ -1096,11 +1110,11 @@
      * directly implemented by the class or interface represented by
      * this object.
      *
      * <p>If a superinterface is a parameterized type, the
      * {@code Type} object returned for it must accurately reflect
-     * the actual type parameters used in the source code. The
+     * the actual type arguments used in the source code. The
      * parameterized type representing each superinterface is created
      * if it had not been created before. See the declaration of
      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
      * for the semantics of the creation process for parameterized
      * types.
@@ -1493,11 +1507,11 @@
     /**
      * Returns the immediately enclosing class of the underlying
      * class.  If the underlying class is a top level class this
      * method returns {@code null}.
      * @return the immediately enclosing class of the underlying class
-     * @exception  SecurityException
+     * @throws     SecurityException
      *             If a security manager, <i>s</i>, is present and the caller's
      *             class loader is not the same as or an ancestor of the class
      *             loader for the enclosing class and invocation of {@link
      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
      *             denies access to the package of the enclosing class
@@ -1587,16 +1601,11 @@
                 int dimensions = 0;
                 do {
                     dimensions++;
                     cl = cl.getComponentType();
                 } while (cl.isArray());
-                StringBuilder sb = new StringBuilder();
-                sb.append(cl.getName());
-                for (int i = 0; i < dimensions; i++) {
-                    sb.append("[]");
-                }
-                return sb.toString();
+                return cl.getName() + "[]".repeat(dimensions);
             } catch (Throwable e) { /*FALLTHRU*/ }
         }
         return getName();
     }
 
@@ -2253,10 +2262,74 @@
             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
         }
         return copyFields(privateGetDeclaredFields(false));
     }
 
+    /**
+     * {@preview Associated with records, a preview feature of the Java language.
+     *
+     *           This method is associated with <i>records</i>, a preview
+     *           feature of the Java language. Preview features
+     *           may be removed in a future release, or upgraded to permanent
+     *           features of the Java language.}
+     *
+     * Returns an array of {@code RecordComponent} objects representing all the
+     * record components of this record class, or {@code null} if this class is
+     * not a record class.
+     *
+     * <p> The components are returned in the same order that they are declared
+     * in the record header. The array is empty if this record class has no
+     * components. If the class is not a record class, that is {@link
+     * #isRecord()} returns {@code false}, then this method returns {@code null}.
+     * Conversely, if {@link #isRecord()} returns {@code true}, then this method
+     * returns a non-null value.
+     *
+     * @return  An array of {@code RecordComponent} objects representing all the
+     *          record components of this record class, or {@code null} if this
+     *          class is not a record class
+     * @throws  SecurityException
+     *          If a security manager, <i>s</i>, is present and any of the
+     *          following conditions is met:
+     *
+     *          <ul>
+     *
+     *          <li> the caller's class loader is not the same as the
+     *          class loader of this class and invocation of
+     *          {@link SecurityManager#checkPermission
+     *          s.checkPermission} method with
+     *          {@code RuntimePermission("accessDeclaredMembers")}
+     *          denies access to the declared methods within this class
+     *
+     *          <li> the caller's class loader is not the same as or an
+     *          ancestor of the class loader for the current class and
+     *          invocation of {@link SecurityManager#checkPackageAccess
+     *          s.checkPackageAccess()} denies access to the package
+     *          of this class
+     *
+     *          </ul>
+     *
+     * @jls 8.10 Record Types
+     * @since 14
+     */
+    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
+                                 essentialAPI=false)
+    @SuppressWarnings("preview")
+    @CallerSensitive
+    public RecordComponent[] getRecordComponents() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
+        }
+        if (!isRecord()) {
+            return null;
+        }
+        RecordComponent[] recordComponents = getRecordComponents0();
+        if (recordComponents == null) {
+            return new RecordComponent[0];
+        }
+        return recordComponents;
+    }
 
     /**
      * Returns an array containing {@code Method} objects reflecting all the
      * declared methods of the class or interface represented by this {@code
      * Class} object, including public, protected, default (package)
@@ -2326,11 +2399,11 @@
      * class has a default constructor, it is included in the returned array.
      * This method returns an array of length 0 if this {@code Class}
      * object represents an interface, a primitive type, an array class, or
      * void.
      *
-     * <p> See <em>The Java Language Specification</em>, section 8.2.
+     * <p> See <em>The Java Language Specification</em>, section {@jls 8.2}.
      *
      * @return  the array of {@code Constructor} objects representing all the
      *          declared constructors of this class
      * @throws  SecurityException
      *          If a security manager, <i>s</i>, is present and any of the
@@ -3411,27 +3484,28 @@
 
     private native Field[]       getDeclaredFields0(boolean publicOnly);
     private native Method[]      getDeclaredMethods0(boolean publicOnly);
     private native Constructor<T>[] getDeclaredConstructors0(boolean publicOnly);
     private native Class<?>[]   getDeclaredClasses0();
+    @SuppressWarnings("preview")
+    private native RecordComponent[] getRecordComponents0();
+    private native boolean      isRecord0();
 
     /**
      * Helper method to get the method name from arguments.
      */
     private String methodToString(String name, Class<?>[] argTypes) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(getName() + "." + name + "(");
-        if (argTypes != null) {
-            sb.append(Arrays.stream(argTypes)
-                      .map(c -> (c == null) ? "null" : c.getName())
-                      .collect(Collectors.joining(",")));
-        }
-        sb.append(")");
-        return sb.toString();
+        return getName() + '.' + name +
+                ((argTypes == null || argTypes.length == 0) ?
+                "()" :
+                Arrays.stream(argTypes)
+                        .map(c -> c == null ? "null" : c.getName())
+                        .collect(Collectors.joining(",", "(", ")")));
     }
 
     /** use serialVersionUID from JDK 1.1 for interoperability */
+    @java.io.Serial
     private static final long serialVersionUID = 3206093459760846163L;
 
 
     /**
      * Class Class is special cased within the Serialization Stream Protocol.
@@ -3447,10 +3521,11 @@
      * is written into the stream. Future references to the class descriptor
      * are written as references to the initial class descriptor instance.
      *
      * @see java.io.ObjectStreamClass
      */
+    @java.io.Serial
     private static final ObjectStreamField[] serialPersistentFields =
         new ObjectStreamField[0];
 
 
     /**
@@ -3498,22 +3573,70 @@
 
     /**
      * Returns true if and only if this class was declared as an enum in the
      * source code.
      *
+     * Note that {@link java.lang.Enum} is not itself an enum type.
+     *
+     * Also note that if an enum constant is declared with a class body,
+     * the class of that enum constant object is an anonymous class
+     * and <em>not</em> the class of the declaring enum type. The
+     * {@link Enum#getDeclaringClass} method of an enum constant can
+     * be used to get the class of the enum type declaring the
+     * constant.
+     *
      * @return true if and only if this class was declared as an enum in the
      *     source code
      * @since 1.5
+     * @jls 8.9.1 Enum Constants
      */
     public boolean isEnum() {
         // An enum must both directly extend java.lang.Enum and have
         // the ENUM bit set; classes for specialized enum constants
         // don't do the former.
         return (this.getModifiers() & ENUM) != 0 &&
         this.getSuperclass() == java.lang.Enum.class;
     }
 
+    /** java.lang.Record.class */
+    private static final Class<?> JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
+    private static Class<?> javaLangRecordClass() {
+        try {
+            return Class.forName0("java.lang.Record", false, null, null);
+        } catch (ClassNotFoundException e) {
+            throw new InternalError("should not reach here", e);
+        }
+    }
+
+    /**
+     * {@preview Associated with records, a preview feature of the Java language.
+     *
+     *           This method is associated with <i>records</i>, a preview
+     *           feature of the Java language. Preview features
+     *           may be removed in a future release, or upgraded to permanent
+     *           features of the Java language.}
+     *
+     * Returns {@code true} if and only if this class is a record class.
+     *
+     * <p> The {@linkplain #getSuperclass() direct superclass} of a record
+     * class is {@code java.lang.Record}. A record class has (possibly zero)
+     * record components, that is, {@link #getRecordComponents()} returns a
+     * non-null value.
+     *
+     * <p> Note that class {@link Record} is not a record type and thus invoking
+     * this method on class {@code Record} returns {@code false}.
+     *
+     * @return true if and only if this class is a record class, otherwise false
+     * @jls 8.10 Record Types
+     * @since 14
+     */
+    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
+                                 essentialAPI=false)
+    public boolean isRecord() {
+        return getSuperclass() == JAVA_LANG_RECORD_CLASS && isRecord0();
+    }
+
     // Fetches the factory for reflective objects
     private static ReflectionFactory getReflectionFactory() {
         if (reflectionFactory == null) {
             reflectionFactory =
                 java.security.AccessController.doPrivileged
@@ -3917,11 +4040,12 @@
      *         class loader is not the same as or an ancestor of the class
      *         loader for the returned class and invocation of {@link
      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
      *         denies access to the package of the returned class
      * @since 11
-     * @jvms 4.7.28 and 4.7.29 NestHost and NestMembers attributes
+     * @jvms 4.7.28 The {@code NestHost} Attribute
+     * @jvms 4.7.29 The {@code NestMembers} Attribute
      * @jvms 5.4.4 Access Control
      */
     @CallerSensitive
     public Class<?> getNestHost() {
         if (isPrimitive() || isArray()) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/AbstractStringBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import jdk.internal.math.FloatingDecimal;
<a name="1" id="anc1"></a><span class="line-added">  29 </span>
  30 import java.util.Arrays;
  31 import java.util.Spliterator;
  32 import java.util.stream.IntStream;
  33 import java.util.stream.StreamSupport;
  34 
  35 import static java.lang.String.COMPACT_STRINGS;
  36 import static java.lang.String.UTF16;
  37 import static java.lang.String.LATIN1;
  38 import static java.lang.String.checkIndex;
  39 import static java.lang.String.checkOffset;
  40 
  41 /**
  42  * A mutable sequence of characters.
  43  * &lt;p&gt;
  44  * Implements a modifiable string. At any point in time it contains some
  45  * particular sequence of characters, but the length and content of the
  46  * sequence can be changed through certain method calls.
  47  *
  48  * &lt;p&gt;Unless otherwise noted, passing a {@code null} argument to a constructor
  49  * or method in this class will cause a {@link NullPointerException} to be
  50  * thrown.
  51  *
  52  * @author      Michael McCloskey
  53  * @author      Martin Buchholz
  54  * @author      Ulf Zibis
  55  * @since       1.5
  56  */
  57 abstract class AbstractStringBuilder implements Appendable, CharSequence {
  58     /**
  59      * The value is used for character storage.
  60      */
  61     byte[] value;
  62 
  63     /**
  64      * The id of the encoding used to encode the bytes in {@code value}.
  65      */
  66     byte coder;
  67 
  68     /**
  69      * The count is the number of characters used.
  70      */
  71     int count;
  72 
  73     private static final byte[] EMPTYVALUE = new byte[0];
  74 
  75     /**
  76      * This no-arg constructor is necessary for serialization of subclasses.
  77      */
  78     AbstractStringBuilder() {
  79         value = EMPTYVALUE;
  80     }
  81 
  82     /**
  83      * Creates an AbstractStringBuilder of the specified capacity.
  84      */
  85     AbstractStringBuilder(int capacity) {
  86         if (COMPACT_STRINGS) {
  87             value = new byte[capacity];
  88             coder = LATIN1;
  89         } else {
  90             value = StringUTF16.newBytesFor(capacity);
  91             coder = UTF16;
  92         }
  93     }
  94 
  95     /**
<a name="2" id="anc2"></a><span class="line-modified">  96      * Constructs an AbstractStringBuilder that contains the same characters</span>
<span class="line-modified">  97      * as the specified {@code String}. The initial capacity of</span>
<span class="line-modified">  98      * the string builder is {@code 16} plus the length of the</span>
<span class="line-added">  99      * {@code String} argument.</span>
<span class="line-added"> 100      *</span>
<span class="line-added"> 101      * @param      str   the string to copy.</span>
<span class="line-added"> 102      */</span>
<span class="line-added"> 103     AbstractStringBuilder(String str) {</span>
<span class="line-added"> 104         int length = str.length();</span>
<span class="line-added"> 105         int capacity = (length &lt; Integer.MAX_VALUE - 16)</span>
<span class="line-added"> 106                 ? length + 16 : Integer.MAX_VALUE;</span>
<span class="line-added"> 107         final byte initCoder = str.coder();</span>
<span class="line-added"> 108         coder = initCoder;</span>
<span class="line-added"> 109         value = (initCoder == LATIN1)</span>
<span class="line-added"> 110                 ? new byte[capacity] : StringUTF16.newBytesFor(capacity);</span>
<span class="line-added"> 111         append(str);</span>
<span class="line-added"> 112     }</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114     /**</span>
<span class="line-added"> 115      * Constructs an AbstractStringBuilder that contains the same characters</span>
<span class="line-added"> 116      * as the specified {@code CharSequence}. The initial capacity of</span>
<span class="line-added"> 117      * the string builder is {@code 16} plus the length of the</span>
<span class="line-added"> 118      * {@code CharSequence} argument.</span>
<span class="line-added"> 119      *</span>
<span class="line-added"> 120      * @param      seq   the sequence to copy.</span>
 121      */
<a name="3" id="anc3"></a><span class="line-modified"> 122     AbstractStringBuilder(CharSequence seq) {</span>
<span class="line-added"> 123         int length = seq.length();</span>
 124         if (length &lt; 0) {
 125             throw new NegativeArraySizeException(&quot;Negative length: &quot; + length);
 126         }
<a name="4" id="anc4"></a><span class="line-modified"> 127         int capacity = (length &lt; Integer.MAX_VALUE - 16)</span>
<span class="line-modified"> 128                 ? length + 16 : Integer.MAX_VALUE;</span>
<span class="line-modified"> 129 </span>
<span class="line-modified"> 130         final byte initCoder;</span>
<span class="line-added"> 131         if (COMPACT_STRINGS) {</span>
<span class="line-added"> 132             if (seq instanceof AbstractStringBuilder) {</span>
<span class="line-added"> 133                 initCoder = ((AbstractStringBuilder)seq).getCoder();</span>
<span class="line-added"> 134             } else if (seq instanceof String) {</span>
<span class="line-added"> 135                 initCoder = ((String)seq).coder();</span>
<span class="line-added"> 136             } else {</span>
<span class="line-added"> 137                 initCoder = LATIN1;</span>
<span class="line-added"> 138             }</span>
<span class="line-added"> 139         } else {</span>
<span class="line-added"> 140             initCoder = UTF16;</span>
<span class="line-added"> 141         }</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143         coder = initCoder;</span>
<span class="line-added"> 144         value = (initCoder == LATIN1)</span>
 145                 ? new byte[capacity] : StringUTF16.newBytesFor(capacity);
<a name="5" id="anc5"></a><span class="line-added"> 146         append(seq);</span>
 147     }
 148 
 149     /**
 150      * Compares the objects of two AbstractStringBuilder implementations lexicographically.
 151      *
 152      * @since 11
 153      */
 154     int compareTo(AbstractStringBuilder another) {
 155         if (this == another) {
 156             return 0;
 157         }
 158 
 159         byte val1[] = value;
 160         byte val2[] = another.value;
 161         int count1 = this.count;
 162         int count2 = another.count;
 163 
 164         if (coder == another.coder) {
 165             return isLatin1() ? StringLatin1.compareTo(val1, val2, count1, count2)
 166                               : StringUTF16.compareTo(val1, val2, count1, count2);
 167         }
 168         return isLatin1() ? StringLatin1.compareToUTF16(val1, val2, count1, count2)
 169                           : StringUTF16.compareToLatin1(val1, val2, count1, count2);
 170     }
 171 
 172     /**
 173      * Returns the length (character count).
 174      *
 175      * @return  the length of the sequence of characters currently
 176      *          represented by this object
 177      */
 178     @Override
 179     public int length() {
 180         return count;
 181     }
 182 
 183     /**
<a name="6" id="anc6"></a><span class="line-modified"> 184      * Returns the current capacity. The capacity is the number of characters</span>
<span class="line-modified"> 185      * that can be stored (including already written characters), beyond which</span>
<span class="line-modified"> 186      * an allocation will occur.</span>
 187      *
 188      * @return  the current capacity
 189      */
 190     public int capacity() {
 191         return value.length &gt;&gt; coder;
 192     }
 193 
 194     /**
 195      * Ensures that the capacity is at least equal to the specified minimum.
 196      * If the current capacity is less than the argument, then a new internal
 197      * array is allocated with greater capacity. The new capacity is the
 198      * larger of:
 199      * &lt;ul&gt;
 200      * &lt;li&gt;The {@code minimumCapacity} argument.
 201      * &lt;li&gt;Twice the old capacity, plus {@code 2}.
 202      * &lt;/ul&gt;
 203      * If the {@code minimumCapacity} argument is nonpositive, this
 204      * method takes no action and simply returns.
 205      * Note that subsequent operations on this object can reduce the
 206      * actual capacity below that requested here.
 207      *
 208      * @param   minimumCapacity   the minimum desired capacity.
 209      */
 210     public void ensureCapacity(int minimumCapacity) {
 211         if (minimumCapacity &gt; 0) {
 212             ensureCapacityInternal(minimumCapacity);
 213         }
 214     }
 215 
 216     /**
 217      * For positive values of {@code minimumCapacity}, this method
 218      * behaves like {@code ensureCapacity}, however it is never
 219      * synchronized.
 220      * If {@code minimumCapacity} is non positive due to numeric
 221      * overflow, this method throws {@code OutOfMemoryError}.
 222      */
 223     private void ensureCapacityInternal(int minimumCapacity) {
 224         // overflow-conscious code
 225         int oldCapacity = value.length &gt;&gt; coder;
 226         if (minimumCapacity - oldCapacity &gt; 0) {
 227             value = Arrays.copyOf(value,
 228                     newCapacity(minimumCapacity) &lt;&lt; coder);
 229         }
 230     }
 231 
 232     /**
 233      * The maximum size of array to allocate (unless necessary).
 234      * Some VMs reserve some header words in an array.
 235      * Attempts to allocate larger arrays may result in
 236      * OutOfMemoryError: Requested array size exceeds VM limit
 237      */
 238     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
 239 
 240     /**
 241      * Returns a capacity at least as large as the given minimum capacity.
 242      * Returns the current capacity increased by the same amount + 2 if
 243      * that suffices.
 244      * Will not return a capacity greater than
 245      * {@code (MAX_ARRAY_SIZE &gt;&gt; coder)} unless the given minimum capacity
 246      * is greater than that.
 247      *
 248      * @param  minCapacity the desired minimum capacity
 249      * @throws OutOfMemoryError if minCapacity is less than zero or
 250      *         greater than (Integer.MAX_VALUE &gt;&gt; coder)
 251      */
 252     private int newCapacity(int minCapacity) {
 253         // overflow-conscious code
 254         int oldCapacity = value.length &gt;&gt; coder;
 255         int newCapacity = (oldCapacity &lt;&lt; 1) + 2;
 256         if (newCapacity - minCapacity &lt; 0) {
 257             newCapacity = minCapacity;
 258         }
 259         int SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder;
 260         return (newCapacity &lt;= 0 || SAFE_BOUND - newCapacity &lt; 0)
 261             ? hugeCapacity(minCapacity)
 262             : newCapacity;
 263     }
 264 
 265     private int hugeCapacity(int minCapacity) {
 266         int SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder;
 267         int UNSAFE_BOUND = Integer.MAX_VALUE &gt;&gt; coder;
 268         if (UNSAFE_BOUND - minCapacity &lt; 0) { // overflow
 269             throw new OutOfMemoryError();
 270         }
 271         return (minCapacity &gt; SAFE_BOUND)
 272             ? minCapacity : SAFE_BOUND;
 273     }
 274 
 275     /**
 276      * If the coder is &quot;isLatin1&quot;, this inflates the internal 8-bit storage
 277      * to 16-bit &lt;hi=0, low&gt; pair storage.
 278      */
 279     private void inflate() {
 280         if (!isLatin1()) {
 281             return;
 282         }
 283         byte[] buf = StringUTF16.newBytesFor(value.length);
 284         StringLatin1.inflate(value, 0, buf, 0, count);
 285         this.value = buf;
 286         this.coder = UTF16;
 287     }
 288 
 289     /**
 290      * Attempts to reduce storage used for the character sequence.
 291      * If the buffer is larger than necessary to hold its current sequence of
 292      * characters, then it may be resized to become more space efficient.
 293      * Calling this method may, but is not required to, affect the value
 294      * returned by a subsequent call to the {@link #capacity()} method.
 295      */
 296     public void trimToSize() {
 297         int length = count &lt;&lt; coder;
 298         if (length &lt; value.length) {
 299             value = Arrays.copyOf(value, length);
 300         }
 301     }
 302 
 303     /**
 304      * Sets the length of the character sequence.
 305      * The sequence is changed to a new character sequence
 306      * whose length is specified by the argument. For every nonnegative
 307      * index &lt;i&gt;k&lt;/i&gt; less than {@code newLength}, the character at
 308      * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is the same as the
 309      * character at index &lt;i&gt;k&lt;/i&gt; in the old sequence if &lt;i&gt;k&lt;/i&gt; is less
 310      * than the length of the old character sequence; otherwise, it is the
 311      * null character {@code &#39;\u005Cu0000&#39;}.
 312      *
 313      * In other words, if the {@code newLength} argument is less than
 314      * the current length, the length is changed to the specified length.
 315      * &lt;p&gt;
 316      * If the {@code newLength} argument is greater than or equal
 317      * to the current length, sufficient null characters
 318      * ({@code &#39;\u005Cu0000&#39;}) are appended so that
 319      * length becomes the {@code newLength} argument.
 320      * &lt;p&gt;
 321      * The {@code newLength} argument must be greater than or equal
 322      * to {@code 0}.
 323      *
 324      * @param      newLength   the new length
 325      * @throws     IndexOutOfBoundsException  if the
 326      *               {@code newLength} argument is negative.
 327      */
 328     public void setLength(int newLength) {
 329         if (newLength &lt; 0) {
 330             throw new StringIndexOutOfBoundsException(newLength);
 331         }
 332         ensureCapacityInternal(newLength);
 333         if (count &lt; newLength) {
 334             if (isLatin1()) {
 335                 StringLatin1.fillNull(value, count, newLength);
 336             } else {
 337                 StringUTF16.fillNull(value, count, newLength);
 338             }
 339         }
 340         count = newLength;
 341     }
 342 
 343     /**
 344      * Returns the {@code char} value in this sequence at the specified index.
 345      * The first {@code char} value is at index {@code 0}, the next at index
 346      * {@code 1}, and so on, as in array indexing.
 347      * &lt;p&gt;
 348      * The index argument must be greater than or equal to
 349      * {@code 0}, and less than the length of this sequence.
 350      *
 351      * &lt;p&gt;If the {@code char} value specified by the index is a
 352      * &lt;a href=&quot;Character.html#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate
 353      * value is returned.
 354      *
 355      * @param      index   the index of the desired {@code char} value.
 356      * @return     the {@code char} value at the specified index.
 357      * @throws     IndexOutOfBoundsException  if {@code index} is
 358      *             negative or greater than or equal to {@code length()}.
 359      */
 360     @Override
 361     public char charAt(int index) {
 362         checkIndex(index, count);
 363         if (isLatin1()) {
 364             return (char)(value[index] &amp; 0xff);
 365         }
 366         return StringUTF16.charAt(value, index);
 367     }
 368 
 369     /**
 370      * Returns the character (Unicode code point) at the specified
 371      * index. The index refers to {@code char} values
 372      * (Unicode code units) and ranges from {@code 0} to
 373      * {@link #length()}{@code  - 1}.
 374      *
 375      * &lt;p&gt; If the {@code char} value specified at the given index
 376      * is in the high-surrogate range, the following index is less
 377      * than the length of this sequence, and the
 378      * {@code char} value at the following index is in the
 379      * low-surrogate range, then the supplementary code point
 380      * corresponding to this surrogate pair is returned. Otherwise,
 381      * the {@code char} value at the given index is returned.
 382      *
 383      * @param      index the index to the {@code char} values
 384      * @return     the code point value of the character at the
 385      *             {@code index}
 386      * @throws     IndexOutOfBoundsException  if the {@code index}
 387      *             argument is negative or not less than the length of this
 388      *             sequence.
 389      */
 390     public int codePointAt(int index) {
 391         int count = this.count;
 392         byte[] value = this.value;
 393         checkIndex(index, count);
 394         if (isLatin1()) {
 395             return value[index] &amp; 0xff;
 396         }
 397         return StringUTF16.codePointAtSB(value, index, count);
 398     }
 399 
 400     /**
 401      * Returns the character (Unicode code point) before the specified
 402      * index. The index refers to {@code char} values
 403      * (Unicode code units) and ranges from {@code 1} to {@link
 404      * #length()}.
 405      *
 406      * &lt;p&gt; If the {@code char} value at {@code (index - 1)}
 407      * is in the low-surrogate range, {@code (index - 2)} is not
 408      * negative, and the {@code char} value at {@code (index -
 409      * 2)} is in the high-surrogate range, then the
 410      * supplementary code point value of the surrogate pair is
 411      * returned. If the {@code char} value at {@code index -
 412      * 1} is an unpaired low-surrogate or a high-surrogate, the
 413      * surrogate value is returned.
 414      *
 415      * @param     index the index following the code point that should be returned
 416      * @return    the Unicode code point value before the given index.
 417      * @throws    IndexOutOfBoundsException if the {@code index}
 418      *            argument is less than 1 or greater than the length
 419      *            of this sequence.
 420      */
 421     public int codePointBefore(int index) {
 422         int i = index - 1;
 423         if (i &lt; 0 || i &gt;= count) {
 424             throw new StringIndexOutOfBoundsException(index);
 425         }
 426         if (isLatin1()) {
 427             return value[i] &amp; 0xff;
 428         }
 429         return StringUTF16.codePointBeforeSB(value, index);
 430     }
 431 
 432     /**
 433      * Returns the number of Unicode code points in the specified text
 434      * range of this sequence. The text range begins at the specified
 435      * {@code beginIndex} and extends to the {@code char} at
 436      * index {@code endIndex - 1}. Thus the length (in
 437      * {@code char}s) of the text range is
 438      * {@code endIndex-beginIndex}. Unpaired surrogates within
 439      * this sequence count as one code point each.
 440      *
 441      * @param beginIndex the index to the first {@code char} of
 442      * the text range.
 443      * @param endIndex the index after the last {@code char} of
 444      * the text range.
 445      * @return the number of Unicode code points in the specified text
 446      * range
 447      * @throws    IndexOutOfBoundsException if the
 448      * {@code beginIndex} is negative, or {@code endIndex}
 449      * is larger than the length of this sequence, or
 450      * {@code beginIndex} is larger than {@code endIndex}.
 451      */
 452     public int codePointCount(int beginIndex, int endIndex) {
 453         if (beginIndex &lt; 0 || endIndex &gt; count || beginIndex &gt; endIndex) {
 454             throw new IndexOutOfBoundsException();
 455         }
 456         if (isLatin1()) {
 457             return endIndex - beginIndex;
 458         }
 459         return StringUTF16.codePointCountSB(value, beginIndex, endIndex);
 460     }
 461 
 462     /**
 463      * Returns the index within this sequence that is offset from the
 464      * given {@code index} by {@code codePointOffset} code
 465      * points. Unpaired surrogates within the text range given by
 466      * {@code index} and {@code codePointOffset} count as
 467      * one code point each.
 468      *
 469      * @param index the index to be offset
 470      * @param codePointOffset the offset in code points
 471      * @return the index within this sequence
 472      * @throws    IndexOutOfBoundsException if {@code index}
 473      *   is negative or larger then the length of this sequence,
 474      *   or if {@code codePointOffset} is positive and the subsequence
 475      *   starting with {@code index} has fewer than
 476      *   {@code codePointOffset} code points,
 477      *   or if {@code codePointOffset} is negative and the subsequence
 478      *   before {@code index} has fewer than the absolute value of
 479      *   {@code codePointOffset} code points.
 480      */
 481     public int offsetByCodePoints(int index, int codePointOffset) {
 482         if (index &lt; 0 || index &gt; count) {
 483             throw new IndexOutOfBoundsException();
 484         }
 485         return Character.offsetByCodePoints(this,
 486                                             index, codePointOffset);
 487     }
 488 
 489     /**
 490      * Characters are copied from this sequence into the
 491      * destination character array {@code dst}. The first character to
 492      * be copied is at index {@code srcBegin}; the last character to
 493      * be copied is at index {@code srcEnd-1}. The total number of
 494      * characters to be copied is {@code srcEnd-srcBegin}. The
 495      * characters are copied into the subarray of {@code dst} starting
 496      * at index {@code dstBegin} and ending at index:
 497      * &lt;pre&gt;{@code
 498      * dstbegin + (srcEnd-srcBegin) - 1
 499      * }&lt;/pre&gt;
 500      *
 501      * @param      srcBegin   start copying at this offset.
 502      * @param      srcEnd     stop copying at this offset.
 503      * @param      dst        the array to copy the data into.
 504      * @param      dstBegin   offset into {@code dst}.
 505      * @throws     IndexOutOfBoundsException  if any of the following is true:
 506      *             &lt;ul&gt;
 507      *             &lt;li&gt;{@code srcBegin} is negative
 508      *             &lt;li&gt;{@code dstBegin} is negative
 509      *             &lt;li&gt;the {@code srcBegin} argument is greater than
 510      *             the {@code srcEnd} argument.
 511      *             &lt;li&gt;{@code srcEnd} is greater than
 512      *             {@code this.length()}.
 513      *             &lt;li&gt;{@code dstBegin+srcEnd-srcBegin} is greater than
 514      *             {@code dst.length}
 515      *             &lt;/ul&gt;
 516      */
 517     public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
 518     {
 519         checkRangeSIOOBE(srcBegin, srcEnd, count);  // compatible to old version
 520         int n = srcEnd - srcBegin;
 521         checkRange(dstBegin, dstBegin + n, dst.length);
 522         if (isLatin1()) {
 523             StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);
 524         } else {
 525             StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);
 526         }
 527     }
 528 
 529     /**
 530      * The character at the specified index is set to {@code ch}. This
 531      * sequence is altered to represent a new character sequence that is
 532      * identical to the old character sequence, except that it contains the
 533      * character {@code ch} at position {@code index}.
 534      * &lt;p&gt;
 535      * The index argument must be greater than or equal to
 536      * {@code 0}, and less than the length of this sequence.
 537      *
 538      * @param      index   the index of the character to modify.
 539      * @param      ch      the new character.
 540      * @throws     IndexOutOfBoundsException  if {@code index} is
 541      *             negative or greater than or equal to {@code length()}.
 542      */
 543     public void setCharAt(int index, char ch) {
 544         checkIndex(index, count);
 545         if (isLatin1() &amp;&amp; StringLatin1.canEncode(ch)) {
 546             value[index] = (byte)ch;
 547         } else {
 548             if (isLatin1()) {
 549                 inflate();
 550             }
 551             StringUTF16.putCharSB(value, index, ch);
 552         }
 553     }
 554 
 555     /**
 556      * Appends the string representation of the {@code Object} argument.
 557      * &lt;p&gt;
 558      * The overall effect is exactly as if the argument were converted
 559      * to a string by the method {@link String#valueOf(Object)},
 560      * and the characters of that string were then
 561      * {@link #append(String) appended} to this character sequence.
 562      *
 563      * @param   obj   an {@code Object}.
 564      * @return  a reference to this object.
 565      */
 566     public AbstractStringBuilder append(Object obj) {
 567         return append(String.valueOf(obj));
 568     }
 569 
 570     /**
 571      * Appends the specified string to this character sequence.
 572      * &lt;p&gt;
 573      * The characters of the {@code String} argument are appended, in
 574      * order, increasing the length of this sequence by the length of the
 575      * argument. If {@code str} is {@code null}, then the four
 576      * characters {@code &quot;null&quot;} are appended.
 577      * &lt;p&gt;
 578      * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to
 579      * execution of the {@code append} method. Then the character at
 580      * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character
 581      * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less
 582      * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index
 583      * &lt;i&gt;k-n&lt;/i&gt; in the argument {@code str}.
 584      *
 585      * @param   str   a string.
 586      * @return  a reference to this object.
 587      */
 588     public AbstractStringBuilder append(String str) {
 589         if (str == null) {
 590             return appendNull();
 591         }
 592         int len = str.length();
 593         ensureCapacityInternal(count + len);
 594         putStringAt(count, str);
 595         count += len;
 596         return this;
 597     }
 598 
 599     // Documentation in subclasses because of synchro difference
 600     public AbstractStringBuilder append(StringBuffer sb) {
 601         return this.append((AbstractStringBuilder)sb);
 602     }
 603 
 604     /**
 605      * @since 1.8
 606      */
 607     AbstractStringBuilder append(AbstractStringBuilder asb) {
 608         if (asb == null) {
 609             return appendNull();
 610         }
 611         int len = asb.length();
 612         ensureCapacityInternal(count + len);
 613         if (getCoder() != asb.getCoder()) {
 614             inflate();
 615         }
 616         asb.getBytes(value, count, coder);
 617         count += len;
 618         return this;
 619     }
 620 
 621     // Documentation in subclasses because of synchro difference
 622     @Override
 623     public AbstractStringBuilder append(CharSequence s) {
 624         if (s == null) {
 625             return appendNull();
 626         }
 627         if (s instanceof String) {
 628             return this.append((String)s);
 629         }
 630         if (s instanceof AbstractStringBuilder) {
 631             return this.append((AbstractStringBuilder)s);
 632         }
 633         return this.append(s, 0, s.length());
 634     }
 635 
 636     private AbstractStringBuilder appendNull() {
 637         ensureCapacityInternal(count + 4);
 638         int count = this.count;
 639         byte[] val = this.value;
 640         if (isLatin1()) {
 641             val[count++] = &#39;n&#39;;
 642             val[count++] = &#39;u&#39;;
 643             val[count++] = &#39;l&#39;;
 644             val[count++] = &#39;l&#39;;
 645         } else {
 646             count = StringUTF16.putCharsAt(val, count, &#39;n&#39;, &#39;u&#39;, &#39;l&#39;, &#39;l&#39;);
 647         }
 648         this.count = count;
 649         return this;
 650     }
 651 
 652     /**
 653      * Appends a subsequence of the specified {@code CharSequence} to this
 654      * sequence.
 655      * &lt;p&gt;
 656      * Characters of the argument {@code s}, starting at
 657      * index {@code start}, are appended, in order, to the contents of
 658      * this sequence up to the (exclusive) index {@code end}. The length
 659      * of this sequence is increased by the value of {@code end - start}.
 660      * &lt;p&gt;
 661      * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to
 662      * execution of the {@code append} method. Then the character at
 663      * index &lt;i&gt;k&lt;/i&gt; in this character sequence becomes equal to the
 664      * character at index &lt;i&gt;k&lt;/i&gt; in this sequence, if &lt;i&gt;k&lt;/i&gt; is less than
 665      * &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index
 666      * &lt;i&gt;k+start-n&lt;/i&gt; in the argument {@code s}.
 667      * &lt;p&gt;
 668      * If {@code s} is {@code null}, then this method appends
 669      * characters as if the s parameter was a sequence containing the four
 670      * characters {@code &quot;null&quot;}.
 671      *
 672      * @param   s the sequence to append.
 673      * @param   start   the starting index of the subsequence to be appended.
 674      * @param   end     the end index of the subsequence to be appended.
 675      * @return  a reference to this object.
 676      * @throws     IndexOutOfBoundsException if
 677      *             {@code start} is negative, or
 678      *             {@code start} is greater than {@code end} or
 679      *             {@code end} is greater than {@code s.length()}
 680      */
 681     @Override
 682     public AbstractStringBuilder append(CharSequence s, int start, int end) {
 683         if (s == null) {
 684             s = &quot;null&quot;;
 685         }
 686         checkRange(start, end, s.length());
 687         int len = end - start;
 688         ensureCapacityInternal(count + len);
<a name="7" id="anc7"></a><span class="line-modified"> 689         if (s instanceof String) {</span>
<span class="line-added"> 690             appendChars((String)s, start, end);</span>
<span class="line-added"> 691         } else {</span>
<span class="line-added"> 692             appendChars(s, start, end);</span>
<span class="line-added"> 693         }</span>
 694         return this;
 695     }
 696 
<a name="8" id="anc8"></a><span class="line-added"> 697 </span>
 698     /**
 699      * Appends the string representation of the {@code char} array
 700      * argument to this sequence.
 701      * &lt;p&gt;
 702      * The characters of the array argument are appended, in order, to
 703      * the contents of this sequence. The length of this sequence
 704      * increases by the length of the argument.
 705      * &lt;p&gt;
 706      * The overall effect is exactly as if the argument were converted
 707      * to a string by the method {@link String#valueOf(char[])},
 708      * and the characters of that string were then
 709      * {@link #append(String) appended} to this character sequence.
 710      *
 711      * @param   str   the characters to be appended.
 712      * @return  a reference to this object.
 713      */
 714     public AbstractStringBuilder append(char[] str) {
 715         int len = str.length;
 716         ensureCapacityInternal(count + len);
 717         appendChars(str, 0, len);
 718         return this;
 719     }
 720 
 721     /**
 722      * Appends the string representation of a subarray of the
 723      * {@code char} array argument to this sequence.
 724      * &lt;p&gt;
 725      * Characters of the {@code char} array {@code str}, starting at
 726      * index {@code offset}, are appended, in order, to the contents
 727      * of this sequence. The length of this sequence increases
 728      * by the value of {@code len}.
 729      * &lt;p&gt;
 730      * The overall effect is exactly as if the arguments were converted
 731      * to a string by the method {@link String#valueOf(char[],int,int)},
 732      * and the characters of that string were then
 733      * {@link #append(String) appended} to this character sequence.
 734      *
 735      * @param   str      the characters to be appended.
 736      * @param   offset   the index of the first {@code char} to append.
 737      * @param   len      the number of {@code char}s to append.
 738      * @return  a reference to this object.
 739      * @throws IndexOutOfBoundsException
 740      *         if {@code offset &lt; 0} or {@code len &lt; 0}
 741      *         or {@code offset+len &gt; str.length}
 742      */
 743     public AbstractStringBuilder append(char str[], int offset, int len) {
 744         int end = offset + len;
 745         checkRange(offset, end, str.length);
 746         ensureCapacityInternal(count + len);
 747         appendChars(str, offset, end);
 748         return this;
 749     }
 750 
 751     /**
 752      * Appends the string representation of the {@code boolean}
 753      * argument to the sequence.
 754      * &lt;p&gt;
 755      * The overall effect is exactly as if the argument were converted
 756      * to a string by the method {@link String#valueOf(boolean)},
 757      * and the characters of that string were then
 758      * {@link #append(String) appended} to this character sequence.
 759      *
 760      * @param   b   a {@code boolean}.
 761      * @return  a reference to this object.
 762      */
 763     public AbstractStringBuilder append(boolean b) {
 764         ensureCapacityInternal(count + (b ? 4 : 5));
 765         int count = this.count;
 766         byte[] val = this.value;
 767         if (isLatin1()) {
 768             if (b) {
 769                 val[count++] = &#39;t&#39;;
 770                 val[count++] = &#39;r&#39;;
 771                 val[count++] = &#39;u&#39;;
 772                 val[count++] = &#39;e&#39;;
 773             } else {
 774                 val[count++] = &#39;f&#39;;
 775                 val[count++] = &#39;a&#39;;
 776                 val[count++] = &#39;l&#39;;
 777                 val[count++] = &#39;s&#39;;
 778                 val[count++] = &#39;e&#39;;
 779             }
 780         } else {
 781             if (b) {
 782                 count = StringUTF16.putCharsAt(val, count, &#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;);
 783             } else {
 784                 count = StringUTF16.putCharsAt(val, count, &#39;f&#39;, &#39;a&#39;, &#39;l&#39;, &#39;s&#39;, &#39;e&#39;);
 785             }
 786         }
 787         this.count = count;
 788         return this;
 789     }
 790 
 791     /**
 792      * Appends the string representation of the {@code char}
 793      * argument to this sequence.
 794      * &lt;p&gt;
 795      * The argument is appended to the contents of this sequence.
 796      * The length of this sequence increases by {@code 1}.
 797      * &lt;p&gt;
 798      * The overall effect is exactly as if the argument were converted
 799      * to a string by the method {@link String#valueOf(char)},
 800      * and the character in that string were then
 801      * {@link #append(String) appended} to this character sequence.
 802      *
 803      * @param   c   a {@code char}.
 804      * @return  a reference to this object.
 805      */
 806     @Override
 807     public AbstractStringBuilder append(char c) {
 808         ensureCapacityInternal(count + 1);
 809         if (isLatin1() &amp;&amp; StringLatin1.canEncode(c)) {
 810             value[count++] = (byte)c;
 811         } else {
 812             if (isLatin1()) {
 813                 inflate();
 814             }
 815             StringUTF16.putCharSB(value, count++, c);
 816         }
 817         return this;
 818     }
 819 
 820     /**
 821      * Appends the string representation of the {@code int}
 822      * argument to this sequence.
 823      * &lt;p&gt;
 824      * The overall effect is exactly as if the argument were converted
 825      * to a string by the method {@link String#valueOf(int)},
 826      * and the characters of that string were then
 827      * {@link #append(String) appended} to this character sequence.
 828      *
 829      * @param   i   an {@code int}.
 830      * @return  a reference to this object.
 831      */
 832     public AbstractStringBuilder append(int i) {
 833         int count = this.count;
 834         int spaceNeeded = count + Integer.stringSize(i);
 835         ensureCapacityInternal(spaceNeeded);
 836         if (isLatin1()) {
 837             Integer.getChars(i, spaceNeeded, value);
 838         } else {
 839             StringUTF16.getChars(i, count, spaceNeeded, value);
 840         }
 841         this.count = spaceNeeded;
 842         return this;
 843     }
 844 
 845     /**
 846      * Appends the string representation of the {@code long}
 847      * argument to this sequence.
 848      * &lt;p&gt;
 849      * The overall effect is exactly as if the argument were converted
 850      * to a string by the method {@link String#valueOf(long)},
 851      * and the characters of that string were then
 852      * {@link #append(String) appended} to this character sequence.
 853      *
 854      * @param   l   a {@code long}.
 855      * @return  a reference to this object.
 856      */
 857     public AbstractStringBuilder append(long l) {
 858         int count = this.count;
 859         int spaceNeeded = count + Long.stringSize(l);
 860         ensureCapacityInternal(spaceNeeded);
 861         if (isLatin1()) {
 862             Long.getChars(l, spaceNeeded, value);
 863         } else {
 864             StringUTF16.getChars(l, count, spaceNeeded, value);
 865         }
 866         this.count = spaceNeeded;
 867         return this;
 868     }
 869 
 870     /**
 871      * Appends the string representation of the {@code float}
 872      * argument to this sequence.
 873      * &lt;p&gt;
 874      * The overall effect is exactly as if the argument were converted
 875      * to a string by the method {@link String#valueOf(float)},
 876      * and the characters of that string were then
 877      * {@link #append(String) appended} to this character sequence.
 878      *
 879      * @param   f   a {@code float}.
 880      * @return  a reference to this object.
 881      */
 882     public AbstractStringBuilder append(float f) {
 883         FloatingDecimal.appendTo(f,this);
 884         return this;
 885     }
 886 
 887     /**
 888      * Appends the string representation of the {@code double}
 889      * argument to this sequence.
 890      * &lt;p&gt;
 891      * The overall effect is exactly as if the argument were converted
 892      * to a string by the method {@link String#valueOf(double)},
 893      * and the characters of that string were then
 894      * {@link #append(String) appended} to this character sequence.
 895      *
 896      * @param   d   a {@code double}.
 897      * @return  a reference to this object.
 898      */
 899     public AbstractStringBuilder append(double d) {
 900         FloatingDecimal.appendTo(d,this);
 901         return this;
 902     }
 903 
 904     /**
 905      * Removes the characters in a substring of this sequence.
 906      * The substring begins at the specified {@code start} and extends to
 907      * the character at index {@code end - 1} or to the end of the
 908      * sequence if no such character exists. If
 909      * {@code start} is equal to {@code end}, no changes are made.
 910      *
 911      * @param      start  The beginning index, inclusive.
 912      * @param      end    The ending index, exclusive.
 913      * @return     This object.
 914      * @throws     StringIndexOutOfBoundsException  if {@code start}
 915      *             is negative, greater than {@code length()}, or
 916      *             greater than {@code end}.
 917      */
 918     public AbstractStringBuilder delete(int start, int end) {
 919         int count = this.count;
 920         if (end &gt; count) {
 921             end = count;
 922         }
 923         checkRangeSIOOBE(start, end, count);
 924         int len = end - start;
 925         if (len &gt; 0) {
 926             shift(end, -len);
 927             this.count = count - len;
 928         }
 929         return this;
 930     }
 931 
 932     /**
 933      * Appends the string representation of the {@code codePoint}
 934      * argument to this sequence.
 935      *
 936      * &lt;p&gt; The argument is appended to the contents of this sequence.
 937      * The length of this sequence increases by
 938      * {@link Character#charCount(int) Character.charCount(codePoint)}.
 939      *
 940      * &lt;p&gt; The overall effect is exactly as if the argument were
 941      * converted to a {@code char} array by the method
 942      * {@link Character#toChars(int)} and the character in that array
 943      * were then {@link #append(char[]) appended} to this character
 944      * sequence.
 945      *
 946      * @param   codePoint   a Unicode code point
 947      * @return  a reference to this object.
 948      * @throws    IllegalArgumentException if the specified
 949      * {@code codePoint} isn&#39;t a valid Unicode code point
 950      */
 951     public AbstractStringBuilder appendCodePoint(int codePoint) {
 952         if (Character.isBmpCodePoint(codePoint)) {
 953             return append((char)codePoint);
 954         }
 955         return append(Character.toChars(codePoint));
 956     }
 957 
 958     /**
 959      * Removes the {@code char} at the specified position in this
 960      * sequence. This sequence is shortened by one {@code char}.
 961      *
 962      * &lt;p&gt;Note: If the character at the given index is a supplementary
 963      * character, this method does not remove the entire character. If
 964      * correct handling of supplementary characters is required,
 965      * determine the number of {@code char}s to remove by calling
 966      * {@code Character.charCount(thisSequence.codePointAt(index))},
 967      * where {@code thisSequence} is this sequence.
 968      *
 969      * @param       index  Index of {@code char} to remove
 970      * @return      This object.
 971      * @throws      StringIndexOutOfBoundsException  if the {@code index}
 972      *              is negative or greater than or equal to
 973      *              {@code length()}.
 974      */
 975     public AbstractStringBuilder deleteCharAt(int index) {
 976         checkIndex(index, count);
 977         shift(index + 1, -1);
 978         count--;
 979         return this;
 980     }
 981 
 982     /**
 983      * Replaces the characters in a substring of this sequence
 984      * with characters in the specified {@code String}. The substring
 985      * begins at the specified {@code start} and extends to the character
 986      * at index {@code end - 1} or to the end of the
 987      * sequence if no such character exists. First the
 988      * characters in the substring are removed and then the specified
 989      * {@code String} is inserted at {@code start}. (This
 990      * sequence will be lengthened to accommodate the
 991      * specified String if necessary.)
 992      *
 993      * @param      start    The beginning index, inclusive.
 994      * @param      end      The ending index, exclusive.
 995      * @param      str   String that will replace previous contents.
 996      * @return     This object.
 997      * @throws     StringIndexOutOfBoundsException  if {@code start}
 998      *             is negative, greater than {@code length()}, or
 999      *             greater than {@code end}.
1000      */
1001     public AbstractStringBuilder replace(int start, int end, String str) {
1002         int count = this.count;
1003         if (end &gt; count) {
1004             end = count;
1005         }
1006         checkRangeSIOOBE(start, end, count);
1007         int len = str.length();
1008         int newCount = count + len - (end - start);
1009         ensureCapacityInternal(newCount);
1010         shift(end, newCount - count);
1011         this.count = newCount;
1012         putStringAt(start, str);
1013         return this;
1014     }
1015 
1016     /**
1017      * Returns a new {@code String} that contains a subsequence of
1018      * characters currently contained in this character sequence. The
1019      * substring begins at the specified index and extends to the end of
1020      * this sequence.
1021      *
1022      * @param      start    The beginning index, inclusive.
1023      * @return     The new string.
1024      * @throws     StringIndexOutOfBoundsException  if {@code start} is
1025      *             less than zero, or greater than the length of this object.
1026      */
1027     public String substring(int start) {
1028         return substring(start, count);
1029     }
1030 
1031     /**
1032      * Returns a new character sequence that is a subsequence of this sequence.
1033      *
1034      * &lt;p&gt; An invocation of this method of the form
1035      *
1036      * &lt;pre&gt;{@code
1037      * sb.subSequence(begin,&amp;nbsp;end)}&lt;/pre&gt;
1038      *
1039      * behaves in exactly the same way as the invocation
1040      *
1041      * &lt;pre&gt;{@code
1042      * sb.substring(begin,&amp;nbsp;end)}&lt;/pre&gt;
1043      *
1044      * This method is provided so that this class can
1045      * implement the {@link CharSequence} interface.
1046      *
1047      * @param      start   the start index, inclusive.
1048      * @param      end     the end index, exclusive.
1049      * @return     the specified subsequence.
1050      *
1051      * @throws  IndexOutOfBoundsException
1052      *          if {@code start} or {@code end} are negative,
1053      *          if {@code end} is greater than {@code length()},
1054      *          or if {@code start} is greater than {@code end}
1055      * @spec JSR-51
1056      */
1057     @Override
1058     public CharSequence subSequence(int start, int end) {
1059         return substring(start, end);
1060     }
1061 
1062     /**
1063      * Returns a new {@code String} that contains a subsequence of
1064      * characters currently contained in this sequence. The
1065      * substring begins at the specified {@code start} and
1066      * extends to the character at index {@code end - 1}.
1067      *
1068      * @param      start    The beginning index, inclusive.
1069      * @param      end      The ending index, exclusive.
1070      * @return     The new string.
1071      * @throws     StringIndexOutOfBoundsException  if {@code start}
1072      *             or {@code end} are negative or greater than
1073      *             {@code length()}, or {@code start} is
1074      *             greater than {@code end}.
1075      */
1076     public String substring(int start, int end) {
1077         checkRangeSIOOBE(start, end, count);
1078         if (isLatin1()) {
1079             return StringLatin1.newString(value, start, end - start);
1080         }
1081         return StringUTF16.newString(value, start, end - start);
1082     }
1083 
1084     private void shift(int offset, int n) {
1085         System.arraycopy(value, offset &lt;&lt; coder,
1086                          value, (offset + n) &lt;&lt; coder, (count - offset) &lt;&lt; coder);
1087     }
1088 
1089     /**
1090      * Inserts the string representation of a subarray of the {@code str}
1091      * array argument into this sequence. The subarray begins at the
1092      * specified {@code offset} and extends {@code len} {@code char}s.
1093      * The characters of the subarray are inserted into this sequence at
1094      * the position indicated by {@code index}. The length of this
1095      * sequence increases by {@code len} {@code char}s.
1096      *
1097      * @param      index    position at which to insert subarray.
1098      * @param      str       A {@code char} array.
1099      * @param      offset   the index of the first {@code char} in subarray to
1100      *             be inserted.
1101      * @param      len      the number of {@code char}s in the subarray to
1102      *             be inserted.
1103      * @return     This object
1104      * @throws     StringIndexOutOfBoundsException  if {@code index}
1105      *             is negative or greater than {@code length()}, or
1106      *             {@code offset} or {@code len} are negative, or
1107      *             {@code (offset+len)} is greater than
1108      *             {@code str.length}.
1109      */
1110     public AbstractStringBuilder insert(int index, char[] str, int offset,
1111                                         int len)
1112     {
1113         checkOffset(index, count);
1114         checkRangeSIOOBE(offset, offset + len, str.length);
1115         ensureCapacityInternal(count + len);
1116         shift(index, len);
1117         count += len;
1118         putCharsAt(index, str, offset, offset + len);
1119         return this;
1120     }
1121 
1122     /**
1123      * Inserts the string representation of the {@code Object}
1124      * argument into this character sequence.
1125      * &lt;p&gt;
1126      * The overall effect is exactly as if the second argument were
1127      * converted to a string by the method {@link String#valueOf(Object)},
1128      * and the characters of that string were then
1129      * {@link #insert(int,String) inserted} into this character
1130      * sequence at the indicated offset.
1131      * &lt;p&gt;
1132      * The {@code offset} argument must be greater than or equal to
1133      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1134      * of this sequence.
1135      *
1136      * @param      offset   the offset.
1137      * @param      obj      an {@code Object}.
1138      * @return     a reference to this object.
1139      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1140      */
1141     public AbstractStringBuilder insert(int offset, Object obj) {
1142         return insert(offset, String.valueOf(obj));
1143     }
1144 
1145     /**
1146      * Inserts the string into this character sequence.
1147      * &lt;p&gt;
1148      * The characters of the {@code String} argument are inserted, in
1149      * order, into this sequence at the indicated offset, moving up any
1150      * characters originally above that position and increasing the length
1151      * of this sequence by the length of the argument. If
1152      * {@code str} is {@code null}, then the four characters
1153      * {@code &quot;null&quot;} are inserted into this sequence.
1154      * &lt;p&gt;
1155      * The character at index &lt;i&gt;k&lt;/i&gt; in the new character sequence is
1156      * equal to:
1157      * &lt;ul&gt;
1158      * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if
1159      * &lt;i&gt;k&lt;/i&gt; is less than {@code offset}
1160      * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -offset} in the
1161      * argument {@code str}, if &lt;i&gt;k&lt;/i&gt; is not less than
1162      * {@code offset} but is less than {@code offset+str.length()}
1163      * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -str.length()} in the
1164      * old character sequence, if &lt;i&gt;k&lt;/i&gt; is not less than
1165      * {@code offset+str.length()}
1166      * &lt;/ul&gt;&lt;p&gt;
1167      * The {@code offset} argument must be greater than or equal to
1168      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1169      * of this sequence.
1170      *
1171      * @param      offset   the offset.
1172      * @param      str      a string.
1173      * @return     a reference to this object.
1174      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1175      */
1176     public AbstractStringBuilder insert(int offset, String str) {
1177         checkOffset(offset, count);
1178         if (str == null) {
1179             str = &quot;null&quot;;
1180         }
1181         int len = str.length();
1182         ensureCapacityInternal(count + len);
1183         shift(offset, len);
1184         count += len;
1185         putStringAt(offset, str);
1186         return this;
1187     }
1188 
1189     /**
1190      * Inserts the string representation of the {@code char} array
1191      * argument into this sequence.
1192      * &lt;p&gt;
1193      * The characters of the array argument are inserted into the
1194      * contents of this sequence at the position indicated by
1195      * {@code offset}. The length of this sequence increases by
1196      * the length of the argument.
1197      * &lt;p&gt;
1198      * The overall effect is exactly as if the second argument were
1199      * converted to a string by the method {@link String#valueOf(char[])},
1200      * and the characters of that string were then
1201      * {@link #insert(int,String) inserted} into this character
1202      * sequence at the indicated offset.
1203      * &lt;p&gt;
1204      * The {@code offset} argument must be greater than or equal to
1205      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1206      * of this sequence.
1207      *
1208      * @param      offset   the offset.
1209      * @param      str      a character array.
1210      * @return     a reference to this object.
1211      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1212      */
1213     public AbstractStringBuilder insert(int offset, char[] str) {
1214         checkOffset(offset, count);
1215         int len = str.length;
1216         ensureCapacityInternal(count + len);
1217         shift(offset, len);
1218         count += len;
1219         putCharsAt(offset, str, 0, len);
1220         return this;
1221     }
1222 
1223     /**
1224      * Inserts the specified {@code CharSequence} into this sequence.
1225      * &lt;p&gt;
1226      * The characters of the {@code CharSequence} argument are inserted,
1227      * in order, into this sequence at the indicated offset, moving up
1228      * any characters originally above that position and increasing the length
1229      * of this sequence by the length of the argument s.
1230      * &lt;p&gt;
1231      * The result of this method is exactly the same as if it were an
1232      * invocation of this object&#39;s
1233      * {@link #insert(int,CharSequence,int,int) insert}(dstOffset, s, 0, s.length())
1234      * method.
1235      *
1236      * &lt;p&gt;If {@code s} is {@code null}, then the four characters
1237      * {@code &quot;null&quot;} are inserted into this sequence.
1238      *
1239      * @param      dstOffset   the offset.
1240      * @param      s the sequence to be inserted
1241      * @return     a reference to this object.
1242      * @throws     IndexOutOfBoundsException  if the offset is invalid.
1243      */
1244     public AbstractStringBuilder insert(int dstOffset, CharSequence s) {
1245         if (s == null) {
1246             s = &quot;null&quot;;
1247         }
1248         if (s instanceof String) {
1249             return this.insert(dstOffset, (String)s);
1250         }
1251         return this.insert(dstOffset, s, 0, s.length());
1252     }
1253 
1254     /**
1255      * Inserts a subsequence of the specified {@code CharSequence} into
1256      * this sequence.
1257      * &lt;p&gt;
1258      * The subsequence of the argument {@code s} specified by
1259      * {@code start} and {@code end} are inserted,
1260      * in order, into this sequence at the specified destination offset, moving
1261      * up any characters originally above that position. The length of this
1262      * sequence is increased by {@code end - start}.
1263      * &lt;p&gt;
1264      * The character at index &lt;i&gt;k&lt;/i&gt; in this sequence becomes equal to:
1265      * &lt;ul&gt;
1266      * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt; in this sequence, if
1267      * &lt;i&gt;k&lt;/i&gt; is less than {@code dstOffset}
1268      * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code +start-dstOffset} in
1269      * the argument {@code s}, if &lt;i&gt;k&lt;/i&gt; is greater than or equal to
1270      * {@code dstOffset} but is less than {@code dstOffset+end-start}
1271      * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -(end-start)} in this
1272      * sequence, if &lt;i&gt;k&lt;/i&gt; is greater than or equal to
1273      * {@code dstOffset+end-start}
1274      * &lt;/ul&gt;&lt;p&gt;
1275      * The {@code dstOffset} argument must be greater than or equal to
1276      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1277      * of this sequence.
1278      * &lt;p&gt;The start argument must be nonnegative, and not greater than
1279      * {@code end}.
1280      * &lt;p&gt;The end argument must be greater than or equal to
1281      * {@code start}, and less than or equal to the length of s.
1282      *
1283      * &lt;p&gt;If {@code s} is {@code null}, then this method inserts
1284      * characters as if the s parameter was a sequence containing the four
1285      * characters {@code &quot;null&quot;}.
1286      *
1287      * @param      dstOffset   the offset in this sequence.
1288      * @param      s       the sequence to be inserted.
1289      * @param      start   the starting index of the subsequence to be inserted.
1290      * @param      end     the end index of the subsequence to be inserted.
1291      * @return     a reference to this object.
1292      * @throws     IndexOutOfBoundsException  if {@code dstOffset}
1293      *             is negative or greater than {@code this.length()}, or
1294      *              {@code start} or {@code end} are negative, or
1295      *              {@code start} is greater than {@code end} or
1296      *              {@code end} is greater than {@code s.length()}
1297      */
1298     public AbstractStringBuilder insert(int dstOffset, CharSequence s,
1299                                         int start, int end)
1300     {
1301         if (s == null) {
1302             s = &quot;null&quot;;
1303         }
1304         checkOffset(dstOffset, count);
1305         checkRange(start, end, s.length());
1306         int len = end - start;
1307         ensureCapacityInternal(count + len);
1308         shift(dstOffset, len);
1309         count += len;
1310         putCharsAt(dstOffset, s, start, end);
1311         return this;
1312     }
1313 
1314     /**
1315      * Inserts the string representation of the {@code boolean}
1316      * argument into this sequence.
1317      * &lt;p&gt;
1318      * The overall effect is exactly as if the second argument were
1319      * converted to a string by the method {@link String#valueOf(boolean)},
1320      * and the characters of that string were then
1321      * {@link #insert(int,String) inserted} into this character
1322      * sequence at the indicated offset.
1323      * &lt;p&gt;
1324      * The {@code offset} argument must be greater than or equal to
1325      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1326      * of this sequence.
1327      *
1328      * @param      offset   the offset.
1329      * @param      b        a {@code boolean}.
1330      * @return     a reference to this object.
1331      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1332      */
1333     public AbstractStringBuilder insert(int offset, boolean b) {
1334         return insert(offset, String.valueOf(b));
1335     }
1336 
1337     /**
1338      * Inserts the string representation of the {@code char}
1339      * argument into this sequence.
1340      * &lt;p&gt;
1341      * The overall effect is exactly as if the second argument were
1342      * converted to a string by the method {@link String#valueOf(char)},
1343      * and the character in that string were then
1344      * {@link #insert(int,String) inserted} into this character
1345      * sequence at the indicated offset.
1346      * &lt;p&gt;
1347      * The {@code offset} argument must be greater than or equal to
1348      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1349      * of this sequence.
1350      *
1351      * @param      offset   the offset.
1352      * @param      c        a {@code char}.
1353      * @return     a reference to this object.
1354      * @throws     IndexOutOfBoundsException  if the offset is invalid.
1355      */
1356     public AbstractStringBuilder insert(int offset, char c) {
1357         checkOffset(offset, count);
1358         ensureCapacityInternal(count + 1);
1359         shift(offset, 1);
1360         count += 1;
1361         if (isLatin1() &amp;&amp; StringLatin1.canEncode(c)) {
1362             value[offset] = (byte)c;
1363         } else {
1364             if (isLatin1()) {
1365                 inflate();
1366             }
1367             StringUTF16.putCharSB(value, offset, c);
1368         }
1369         return this;
1370     }
1371 
1372     /**
1373      * Inserts the string representation of the second {@code int}
1374      * argument into this sequence.
1375      * &lt;p&gt;
1376      * The overall effect is exactly as if the second argument were
1377      * converted to a string by the method {@link String#valueOf(int)},
1378      * and the characters of that string were then
1379      * {@link #insert(int,String) inserted} into this character
1380      * sequence at the indicated offset.
1381      * &lt;p&gt;
1382      * The {@code offset} argument must be greater than or equal to
1383      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1384      * of this sequence.
1385      *
1386      * @param      offset   the offset.
1387      * @param      i        an {@code int}.
1388      * @return     a reference to this object.
1389      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1390      */
1391     public AbstractStringBuilder insert(int offset, int i) {
1392         return insert(offset, String.valueOf(i));
1393     }
1394 
1395     /**
1396      * Inserts the string representation of the {@code long}
1397      * argument into this sequence.
1398      * &lt;p&gt;
1399      * The overall effect is exactly as if the second argument were
1400      * converted to a string by the method {@link String#valueOf(long)},
1401      * and the characters of that string were then
1402      * {@link #insert(int,String) inserted} into this character
1403      * sequence at the indicated offset.
1404      * &lt;p&gt;
1405      * The {@code offset} argument must be greater than or equal to
1406      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1407      * of this sequence.
1408      *
1409      * @param      offset   the offset.
1410      * @param      l        a {@code long}.
1411      * @return     a reference to this object.
1412      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1413      */
1414     public AbstractStringBuilder insert(int offset, long l) {
1415         return insert(offset, String.valueOf(l));
1416     }
1417 
1418     /**
1419      * Inserts the string representation of the {@code float}
1420      * argument into this sequence.
1421      * &lt;p&gt;
1422      * The overall effect is exactly as if the second argument were
1423      * converted to a string by the method {@link String#valueOf(float)},
1424      * and the characters of that string were then
1425      * {@link #insert(int,String) inserted} into this character
1426      * sequence at the indicated offset.
1427      * &lt;p&gt;
1428      * The {@code offset} argument must be greater than or equal to
1429      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1430      * of this sequence.
1431      *
1432      * @param      offset   the offset.
1433      * @param      f        a {@code float}.
1434      * @return     a reference to this object.
1435      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1436      */
1437     public AbstractStringBuilder insert(int offset, float f) {
1438         return insert(offset, String.valueOf(f));
1439     }
1440 
1441     /**
1442      * Inserts the string representation of the {@code double}
1443      * argument into this sequence.
1444      * &lt;p&gt;
1445      * The overall effect is exactly as if the second argument were
1446      * converted to a string by the method {@link String#valueOf(double)},
1447      * and the characters of that string were then
1448      * {@link #insert(int,String) inserted} into this character
1449      * sequence at the indicated offset.
1450      * &lt;p&gt;
1451      * The {@code offset} argument must be greater than or equal to
1452      * {@code 0}, and less than or equal to the {@linkplain #length() length}
1453      * of this sequence.
1454      *
1455      * @param      offset   the offset.
1456      * @param      d        a {@code double}.
1457      * @return     a reference to this object.
1458      * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
1459      */
1460     public AbstractStringBuilder insert(int offset, double d) {
1461         return insert(offset, String.valueOf(d));
1462     }
1463 
1464     /**
1465      * Returns the index within this string of the first occurrence of the
1466      * specified substring.
1467      *
1468      * &lt;p&gt;The returned index is the smallest value {@code k} for which:
1469      * &lt;pre&gt;{@code
1470      * this.toString().startsWith(str, k)
1471      * }&lt;/pre&gt;
1472      * If no such value of {@code k} exists, then {@code -1} is returned.
1473      *
1474      * @param   str   the substring to search for.
1475      * @return  the index of the first occurrence of the specified substring,
1476      *          or {@code -1} if there is no such occurrence.
1477      */
1478     public int indexOf(String str) {
1479         return indexOf(str, 0);
1480     }
1481 
1482     /**
1483      * Returns the index within this string of the first occurrence of the
1484      * specified substring, starting at the specified index.
1485      *
1486      * &lt;p&gt;The returned index is the smallest value {@code k} for which:
1487      * &lt;pre&gt;{@code
1488      *     k &gt;= Math.min(fromIndex, this.length()) &amp;&amp;
1489      *                   this.toString().startsWith(str, k)
1490      * }&lt;/pre&gt;
1491      * If no such value of {@code k} exists, then {@code -1} is returned.
1492      *
1493      * @param   str         the substring to search for.
1494      * @param   fromIndex   the index from which to start the search.
1495      * @return  the index of the first occurrence of the specified substring,
1496      *          starting at the specified index,
1497      *          or {@code -1} if there is no such occurrence.
1498      */
1499     public int indexOf(String str, int fromIndex) {
1500         return String.indexOf(value, coder, count, str, fromIndex);
1501     }
1502 
1503     /**
1504      * Returns the index within this string of the last occurrence of the
1505      * specified substring.  The last occurrence of the empty string &quot;&quot; is
1506      * considered to occur at the index value {@code this.length()}.
1507      *
1508      * &lt;p&gt;The returned index is the largest value {@code k} for which:
1509      * &lt;pre&gt;{@code
1510      * this.toString().startsWith(str, k)
1511      * }&lt;/pre&gt;
1512      * If no such value of {@code k} exists, then {@code -1} is returned.
1513      *
1514      * @param   str   the substring to search for.
1515      * @return  the index of the last occurrence of the specified substring,
1516      *          or {@code -1} if there is no such occurrence.
1517      */
1518     public int lastIndexOf(String str) {
1519         return lastIndexOf(str, count);
1520     }
1521 
1522     /**
1523      * Returns the index within this string of the last occurrence of the
1524      * specified substring, searching backward starting at the specified index.
1525      *
1526      * &lt;p&gt;The returned index is the largest value {@code k} for which:
1527      * &lt;pre&gt;{@code
1528      *     k &lt;= Math.min(fromIndex, this.length()) &amp;&amp;
1529      *                   this.toString().startsWith(str, k)
1530      * }&lt;/pre&gt;
1531      * If no such value of {@code k} exists, then {@code -1} is returned.
1532      *
1533      * @param   str         the substring to search for.
1534      * @param   fromIndex   the index to start the search from.
1535      * @return  the index of the last occurrence of the specified substring,
1536      *          searching backward from the specified index,
1537      *          or {@code -1} if there is no such occurrence.
1538      */
1539     public int lastIndexOf(String str, int fromIndex) {
1540         return String.lastIndexOf(value, coder, count, str, fromIndex);
1541     }
1542 
1543     /**
1544      * Causes this character sequence to be replaced by the reverse of
1545      * the sequence. If there are any surrogate pairs included in the
1546      * sequence, these are treated as single characters for the
1547      * reverse operation. Thus, the order of the high-low surrogates
1548      * is never reversed.
1549      *
1550      * Let &lt;i&gt;n&lt;/i&gt; be the character length of this character sequence
1551      * (not the length in {@code char} values) just prior to
1552      * execution of the {@code reverse} method. Then the
1553      * character at index &lt;i&gt;k&lt;/i&gt; in the new character sequence is
1554      * equal to the character at index &lt;i&gt;n-k-1&lt;/i&gt; in the old
1555      * character sequence.
1556      *
1557      * &lt;p&gt;Note that the reverse operation may result in producing
1558      * surrogate pairs that were unpaired low-surrogates and
1559      * high-surrogates before the operation. For example, reversing
1560      * &quot;\u005CuDC00\u005CuD800&quot; produces &quot;\u005CuD800\u005CuDC00&quot; which is
1561      * a valid surrogate pair.
1562      *
1563      * @return  a reference to this object.
1564      */
1565     public AbstractStringBuilder reverse() {
1566         byte[] val = this.value;
1567         int count = this.count;
1568         int coder = this.coder;
1569         int n = count - 1;
1570         if (COMPACT_STRINGS &amp;&amp; coder == LATIN1) {
1571             for (int j = (n-1) &gt;&gt; 1; j &gt;= 0; j--) {
1572                 int k = n - j;
1573                 byte cj = val[j];
1574                 val[j] = val[k];
1575                 val[k] = cj;
1576             }
1577         } else {
1578             StringUTF16.reverse(val, count);
1579         }
1580         return this;
1581     }
1582 
1583     /**
1584      * Returns a string representing the data in this sequence.
1585      * A new {@code String} object is allocated and initialized to
1586      * contain the character sequence currently represented by this
1587      * object. This {@code String} is then returned. Subsequent
1588      * changes to this sequence do not affect the contents of the
1589      * {@code String}.
1590      *
1591      * @return  a string representation of this sequence of characters.
1592      */
1593     @Override
1594     public abstract String toString();
1595 
1596     /**
1597      * {@inheritDoc}
1598      * @since 9
1599      */
1600     @Override
1601     public IntStream chars() {
1602         // Reuse String-based spliterator. This requires a supplier to
1603         // capture the value and count when the terminal operation is executed
1604         return StreamSupport.intStream(
1605                 () -&gt; {
1606                     // The combined set of field reads are not atomic and thread
1607                     // safe but bounds checks will ensure no unsafe reads from
1608                     // the byte array
1609                     byte[] val = this.value;
1610                     int count = this.count;
1611                     byte coder = this.coder;
1612                     return coder == LATIN1
1613                            ? new StringLatin1.CharsSpliterator(val, 0, count, 0)
1614                            : new StringUTF16.CharsSpliterator(val, 0, count, 0);
1615                 },
1616                 Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED,
1617                 false);
1618     }
1619 
1620     /**
1621      * {@inheritDoc}
1622      * @since 9
1623      */
1624     @Override
1625     public IntStream codePoints() {
1626         // Reuse String-based spliterator. This requires a supplier to
1627         // capture the value and count when the terminal operation is executed
1628         return StreamSupport.intStream(
1629                 () -&gt; {
1630                     // The combined set of field reads are not atomic and thread
1631                     // safe but bounds checks will ensure no unsafe reads from
1632                     // the byte array
1633                     byte[] val = this.value;
1634                     int count = this.count;
1635                     byte coder = this.coder;
1636                     return coder == LATIN1
1637                            ? new StringLatin1.CharsSpliterator(val, 0, count, 0)
1638                            : new StringUTF16.CodePointsSpliterator(val, 0, count, 0);
1639                 },
1640                 Spliterator.ORDERED,
1641                 false);
1642     }
1643 
1644     /**
1645      * Needed by {@code String} for the contentEquals method.
1646      */
1647     final byte[] getValue() {
1648         return value;
1649     }
1650 
1651     /*
1652      * Invoker guarantees it is in UTF16 (inflate itself for asb), if two
1653      * coders are different and the dstBegin has enough space
1654      *
1655      * @param dstBegin  the char index, not offset of byte[]
1656      * @param coder     the coder of dst[]
1657      */
1658     void getBytes(byte dst[], int dstBegin, byte coder) {
1659         if (this.coder == coder) {
1660             System.arraycopy(value, 0, dst, dstBegin &lt;&lt; coder, count &lt;&lt; coder);
1661         } else {        // this.coder == LATIN &amp;&amp; coder == UTF16
1662             StringLatin1.inflate(value, 0, dst, dstBegin, count);
1663         }
1664     }
1665 
1666     /* for readObject() */
1667     void initBytes(char[] value, int off, int len) {
1668         if (String.COMPACT_STRINGS) {
1669             this.value = StringUTF16.compress(value, off, len);
1670             if (this.value != null) {
1671                 this.coder = LATIN1;
1672                 return;
1673             }
1674         }
1675         this.coder = UTF16;
1676         this.value = StringUTF16.toBytes(value, off, len);
1677     }
1678 
1679     final byte getCoder() {
1680         return COMPACT_STRINGS ? coder : UTF16;
1681     }
1682 
1683     final boolean isLatin1() {
1684         return COMPACT_STRINGS &amp;&amp; coder == LATIN1;
1685     }
1686 
1687     private final void putCharsAt(int index, char[] s, int off, int end) {
1688         if (isLatin1()) {
1689             byte[] val = this.value;
1690             for (int i = off, j = index; i &lt; end; i++) {
1691                 char c = s[i];
1692                 if (StringLatin1.canEncode(c)) {
1693                     val[j++] = (byte)c;
1694                 } else {
1695                     inflate();
1696                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1697                     return;
1698                 }
1699             }
1700         } else {
1701             StringUTF16.putCharsSB(this.value, index, s, off, end);
1702         }
1703     }
1704 
1705     private final void putCharsAt(int index, CharSequence s, int off, int end) {
1706         if (isLatin1()) {
1707             byte[] val = this.value;
1708             for (int i = off, j = index; i &lt; end; i++) {
1709                 char c = s.charAt(i);
1710                 if (StringLatin1.canEncode(c)) {
1711                     val[j++] = (byte)c;
1712                 } else {
1713                     inflate();
1714                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1715                     return;
1716                 }
1717             }
1718         } else {
1719             StringUTF16.putCharsSB(this.value, index, s, off, end);
1720         }
1721     }
1722 
1723     private final void putStringAt(int index, String str) {
1724         if (getCoder() != str.coder()) {
1725             inflate();
1726         }
1727         str.getBytes(value, index, coder);
1728     }
1729 
1730     private final void appendChars(char[] s, int off, int end) {
1731         int count = this.count;
1732         if (isLatin1()) {
1733             byte[] val = this.value;
1734             for (int i = off, j = count; i &lt; end; i++) {
1735                 char c = s[i];
1736                 if (StringLatin1.canEncode(c)) {
1737                     val[j++] = (byte)c;
1738                 } else {
1739                     this.count = count = j;
1740                     inflate();
1741                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1742                     this.count = count + end - i;
1743                     return;
1744                 }
1745             }
1746         } else {
1747             StringUTF16.putCharsSB(this.value, count, s, off, end);
1748         }
1749         this.count = count + end - off;
1750     }
1751 
<a name="9" id="anc9"></a><span class="line-added">1752     private final void appendChars(String s, int off, int end) {</span>
<span class="line-added">1753         if (isLatin1()) {</span>
<span class="line-added">1754             if (s.isLatin1()) {</span>
<span class="line-added">1755                 System.arraycopy(s.value(), off, this.value, this.count, end - off);</span>
<span class="line-added">1756             } else {</span>
<span class="line-added">1757                 // We might need to inflate, but do it as late as possible since</span>
<span class="line-added">1758                 // the range of characters we&#39;re copying might all be latin1</span>
<span class="line-added">1759                 byte[] val = this.value;</span>
<span class="line-added">1760                 for (int i = off, j = count; i &lt; end; i++) {</span>
<span class="line-added">1761                     char c = s.charAt(i);</span>
<span class="line-added">1762                     if (StringLatin1.canEncode(c)) {</span>
<span class="line-added">1763                         val[j++] = (byte) c;</span>
<span class="line-added">1764                     } else {</span>
<span class="line-added">1765                         count = j;</span>
<span class="line-added">1766                         inflate();</span>
<span class="line-added">1767                         System.arraycopy(s.value(), i &lt;&lt; UTF16, this.value, j &lt;&lt; UTF16, (end - i) &lt;&lt; UTF16);</span>
<span class="line-added">1768                         count += end - i;</span>
<span class="line-added">1769                         return;</span>
<span class="line-added">1770                     }</span>
<span class="line-added">1771                 }</span>
<span class="line-added">1772             }</span>
<span class="line-added">1773         } else if (s.isLatin1()) {</span>
<span class="line-added">1774             StringUTF16.putCharsSB(this.value, this.count, s, off, end);</span>
<span class="line-added">1775         } else { // both UTF16</span>
<span class="line-added">1776             System.arraycopy(s.value(), off &lt;&lt; UTF16, this.value, this.count &lt;&lt; UTF16, (end - off) &lt;&lt; UTF16);</span>
<span class="line-added">1777         }</span>
<span class="line-added">1778         count += end - off;</span>
<span class="line-added">1779     }</span>
<span class="line-added">1780 </span>
1781     private final void appendChars(CharSequence s, int off, int end) {
1782         if (isLatin1()) {
1783             byte[] val = this.value;
1784             for (int i = off, j = count; i &lt; end; i++) {
1785                 char c = s.charAt(i);
1786                 if (StringLatin1.canEncode(c)) {
1787                     val[j++] = (byte)c;
1788                 } else {
1789                     count = j;
1790                     inflate();
1791                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1792                     count += end - i;
1793                     return;
1794                 }
1795             }
1796         } else {
1797             StringUTF16.putCharsSB(this.value, count, s, off, end);
1798         }
1799         count += end - off;
1800     }
1801 
1802     /* IndexOutOfBoundsException, if out of bounds */
1803     private static void checkRange(int start, int end, int len) {
1804         if (start &lt; 0 || start &gt; end || end &gt; len) {
1805             throw new IndexOutOfBoundsException(
1806                 &quot;start &quot; + start + &quot;, end &quot; + end + &quot;, length &quot; + len);
1807         }
1808     }
1809 
1810     /* StringIndexOutOfBoundsException, if out of bounds */
1811     private static void checkRangeSIOOBE(int start, int end, int len) {
1812         if (start &lt; 0 || start &gt; end || end &gt; len) {
1813             throw new StringIndexOutOfBoundsException(
1814                 &quot;start &quot; + start + &quot;, end &quot; + end + &quot;, length &quot; + len);
1815         }
1816     }
1817 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
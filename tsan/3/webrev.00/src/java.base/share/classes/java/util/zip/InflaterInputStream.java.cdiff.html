<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/zip/InflaterInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="GZIPOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipCoder.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/InflaterInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,12 ***</span>
   *
   * @see         Inflater
   * @author      David Connelly
   * @since 1.1
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class InflaterInputStream extends FilterInputStream {</span>
      /**
       * Decompressor for this stream.
       */
      protected Inflater inf;
  
<span class="line-new-header">--- 37,11 ---</span>
   *
   * @see         Inflater
   * @author      David Connelly
   * @since 1.1
   */
<span class="line-modified">! public class InflaterInputStream extends FilterInputStream {</span>
      /**
       * Decompressor for this stream.
       */
      protected Inflater inf;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,11 ***</span>
       * Creates a new input stream with the specified decompressor and
       * buffer size.
       * @param in the input stream
       * @param inf the decompressor (&quot;inflater&quot;)
       * @param size the input buffer size
<span class="line-modified">!      * @exception IllegalArgumentException if {@code size &lt;= 0}</span>
       */
      public InflaterInputStream(InputStream in, Inflater inf, int size) {
          super(in);
          if (in == null || inf == null) {
              throw new NullPointerException();
<span class="line-new-header">--- 73,11 ---</span>
       * Creates a new input stream with the specified decompressor and
       * buffer size.
       * @param in the input stream
       * @param inf the decompressor (&quot;inflater&quot;)
       * @param size the input buffer size
<span class="line-modified">!      * @throws    IllegalArgumentException if {@code size &lt;= 0}</span>
       */
      public InflaterInputStream(InputStream in, Inflater inf, int size) {
          super(in);
          if (in == null || inf == null) {
              throw new NullPointerException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,32 ***</span>
  
      /**
       * Reads a byte of uncompressed data. This method will block until
       * enough input is available for decompression.
       * @return the byte read, or -1 if end of compressed input is reached
<span class="line-modified">!      * @exception IOException if an I/O error has occurred</span>
       */
      public int read() throws IOException {
          ensureOpen();
          return read(singleByteBuf, 0, 1) == -1 ? -1 : Byte.toUnsignedInt(singleByteBuf[0]);
      }
  
      /**
<span class="line-modified">!      * Reads uncompressed data into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not</span>
       * zero, the method will block until some input can be decompressed; otherwise,
<span class="line-modified">!      * no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
       * @param b the buffer into which the data is read
<span class="line-modified">!      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
       * @param len the maximum number of bytes read
       * @return the actual number of bytes read, or -1 if the end of the
       *         compressed input is reached or a preset dictionary is needed
<span class="line-modified">!      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">!      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">!      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">!      * @exception ZipException if a ZIP format error has occurred</span>
<span class="line-modified">!      * @exception IOException if an I/O error has occurred</span>
       */
      public int read(byte[] b, int off, int len) throws IOException {
          ensureOpen();
          if (b == null) {
              throw new NullPointerException();
<span class="line-new-header">--- 113,32 ---</span>
  
      /**
       * Reads a byte of uncompressed data. This method will block until
       * enough input is available for decompression.
       * @return the byte read, or -1 if end of compressed input is reached
<span class="line-modified">!      * @throws    IOException if an I/O error has occurred</span>
       */
      public int read() throws IOException {
          ensureOpen();
          return read(singleByteBuf, 0, 1) == -1 ? -1 : Byte.toUnsignedInt(singleByteBuf[0]);
      }
  
      /**
<span class="line-modified">!      * Reads uncompressed data into an array of bytes. If {@code len} is not</span>
       * zero, the method will block until some input can be decompressed; otherwise,
<span class="line-modified">!      * no bytes are read and {@code 0} is returned.</span>
       * @param b the buffer into which the data is read
<span class="line-modified">!      * @param off the start offset in the destination array {@code b}</span>
       * @param len the maximum number of bytes read
       * @return the actual number of bytes read, or -1 if the end of the
       *         compressed input is reached or a preset dictionary is needed
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      * {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      * {@code b.length - off}</span>
<span class="line-modified">!      * @throws    ZipException if a ZIP format error has occurred</span>
<span class="line-modified">!      * @throws    IOException if an I/O error has occurred</span>
       */
      public int read(byte[] b, int off, int len) throws IOException {
          ensureOpen();
          if (b == null) {
              throw new NullPointerException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,11 ***</span>
       * &lt;p&gt;
       * Programs should not count on this method to return the actual number
       * of bytes that could be read without blocking.
       *
       * @return     1 before EOF and 0 after EOF.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       *
       */
      public int available() throws IOException {
          ensureOpen();
          if (reachEOF) {
<span class="line-new-header">--- 170,11 ---</span>
       * &lt;p&gt;
       * Programs should not count on this method to return the actual number
       * of bytes that could be read without blocking.
       *
       * @return     1 before EOF and 0 after EOF.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       *
       */
      public int available() throws IOException {
          ensureOpen();
          if (reachEOF) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,12 ***</span>
  
      /**
       * Skips specified number of bytes of uncompressed data.
       * @param n the number of bytes to skip
       * @return the actual number of bytes skipped.
<span class="line-modified">!      * @exception IOException if an I/O error has occurred</span>
<span class="line-modified">!      * @exception IllegalArgumentException if {@code n &lt; 0}</span>
       */
      public long skip(long n) throws IOException {
          if (n &lt; 0) {
              throw new IllegalArgumentException(&quot;negative skip length&quot;);
          }
<span class="line-new-header">--- 192,12 ---</span>
  
      /**
       * Skips specified number of bytes of uncompressed data.
       * @param n the number of bytes to skip
       * @return the actual number of bytes skipped.
<span class="line-modified">!      * @throws    IOException if an I/O error has occurred</span>
<span class="line-modified">!      * @throws    IllegalArgumentException if {@code n &lt; 0}</span>
       */
      public long skip(long n) throws IOException {
          if (n &lt; 0) {
              throw new IllegalArgumentException(&quot;negative skip length&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,11 ***</span>
      }
  
      /**
       * Closes this input stream and releases any system resources associated
       * with the stream.
<span class="line-modified">!      * @exception IOException if an I/O error has occurred</span>
       */
      public void close() throws IOException {
          if (!closed) {
              if (usesDefaultInflater)
                  inf.end();
<span class="line-new-header">--- 220,11 ---</span>
      }
  
      /**
       * Closes this input stream and releases any system resources associated
       * with the stream.
<span class="line-modified">!      * @throws    IOException if an I/O error has occurred</span>
       */
      public void close() throws IOException {
          if (!closed) {
              if (usesDefaultInflater)
                  inf.end();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,11 ***</span>
          }
      }
  
      /**
       * Fills input buffer with more data to decompress.
<span class="line-modified">!      * @exception IOException if an I/O error has occurred</span>
       */
      protected void fill() throws IOException {
          ensureOpen();
          len = in.read(buf, 0, buf.length);
          if (len == -1) {
<span class="line-new-header">--- 233,11 ---</span>
          }
      }
  
      /**
       * Fills input buffer with more data to decompress.
<span class="line-modified">!      * @throws    IOException if an I/O error has occurred</span>
       */
      protected void fill() throws IOException {
          ensureOpen();
          len = in.read(buf, 0, buf.length);
          if (len == -1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,28 ***</span>
          }
          inf.setInput(buf, 0, len);
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;reset&lt;/code&gt; methods. The &lt;code&gt;markSupported&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;InflaterInputStream&lt;/code&gt; returns</span>
<span class="line-modified">!      * &lt;code&gt;false&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @return  a &lt;code&gt;boolean&lt;/code&gt; indicating if this stream type supports</span>
<span class="line-modified">!      *          the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
          return false;
      }
  
      /**
       * Marks the current position in this input stream.
       *
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InflaterInputStream&lt;/code&gt;</span>
       * does nothing.
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.InputStream#reset()
<span class="line-new-header">--- 245,28 ---</span>
          }
          inf.setInput(buf, 0, len);
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the {@code mark} and</span>
<span class="line-modified">!      * {@code reset} methods. The {@code markSupported}</span>
<span class="line-modified">!      * method of {@code InflaterInputStream} returns</span>
<span class="line-modified">!      * {@code false}.</span>
       *
<span class="line-modified">!      * @return  a {@code boolean} indicating if this stream type supports</span>
<span class="line-modified">!      *          the {@code mark} and {@code reset} methods.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
          return false;
      }
  
      /**
       * Marks the current position in this input stream.
       *
<span class="line-modified">!      * &lt;p&gt; The {@code mark} method of {@code InflaterInputStream}</span>
       * does nothing.
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.InputStream#reset()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,17 ***</span>
      public synchronized void mark(int readlimit) {
      }
  
      /**
       * Repositions this stream to the position at the time the
<span class="line-modified">!      * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The method &lt;code&gt;reset&lt;/code&gt; for class</span>
<span class="line-modified">!      * &lt;code&gt;InflaterInputStream&lt;/code&gt; does nothing except throw an</span>
<span class="line-modified">!      * &lt;code&gt;IOException&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @exception  IOException  if this method is invoked.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.IOException
       */
      public synchronized void reset() throws IOException {
          throw new IOException(&quot;mark/reset not supported&quot;);
<span class="line-new-header">--- 274,17 ---</span>
      public synchronized void mark(int readlimit) {
      }
  
      /**
       * Repositions this stream to the position at the time the
<span class="line-modified">!      * {@code mark} method was last called on this input stream.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The method {@code reset} for class</span>
<span class="line-modified">!      * {@code InflaterInputStream} does nothing except throw an</span>
<span class="line-modified">!      * {@code IOException}.</span>
       *
<span class="line-modified">!      * @throws     IOException  if this method is invoked.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.IOException
       */
      public synchronized void reset() throws IOException {
          throw new IOException(&quot;mark/reset not supported&quot;);
</pre>
<center><a href="GZIPOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipCoder.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/Arrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.util.ArraysSupport;
  30 
  31 import java.io.Serializable;
  32 import java.lang.reflect.Array;
  33 import java.util.concurrent.ForkJoinPool;
  34 import java.util.function.BinaryOperator;
  35 import java.util.function.Consumer;
  36 import java.util.function.DoubleBinaryOperator;
  37 import java.util.function.IntBinaryOperator;
  38 import java.util.function.IntFunction;
  39 import java.util.function.IntToDoubleFunction;
  40 import java.util.function.IntToLongFunction;
  41 import java.util.function.IntUnaryOperator;
  42 import java.util.function.LongBinaryOperator;
  43 import java.util.function.UnaryOperator;
  44 import java.util.stream.DoubleStream;
  45 import java.util.stream.IntStream;
  46 import java.util.stream.LongStream;
  47 import java.util.stream.Stream;
  48 import java.util.stream.StreamSupport;
  49 
  50 /**
  51  * This class contains various methods for manipulating arrays (such as
  52  * sorting and searching). This class also contains a static factory
  53  * that allows arrays to be viewed as lists.
  54  *
  55  * &lt;p&gt;The methods in this class all throw a {@code NullPointerException},
  56  * if the specified array reference is null, except where noted.
  57  *
  58  * &lt;p&gt;The documentation for the methods contained in this class includes
  59  * brief descriptions of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should
  60  * be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the
  61  * &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other
  62  * algorithms, so long as the specification itself is adhered to. (For
  63  * example, the algorithm used by {@code sort(Object[])} does not have to be
  64  * a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
  65  *
  66  * &lt;p&gt;This class is a member of the
  67  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
  68  * Java Collections Framework&lt;/a&gt;.
  69  *
  70  * @author Josh Bloch
  71  * @author Neal Gafter
  72  * @author John Rose
  73  * @since  1.2
  74  */
  75 public class Arrays {
  76 
  77     /**
  78      * The minimum array length below which a parallel sorting
  79      * algorithm will not further partition the sorting task. Using
  80      * smaller sizes typically results in memory contention across
  81      * tasks that makes parallel speedups unlikely.
  82      */
  83     private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;
  84 
  85     // Suppresses default constructor, ensuring non-instantiability.
  86     private Arrays() {}
  87 
  88     /**
  89      * A comparator that implements the natural ordering of a group of
  90      * mutually comparable elements. May be used when a supplied
  91      * comparator is null. To simplify code-sharing within underlying
  92      * implementations, the compare method only declares type Object
  93      * for its second argument.
  94      *
  95      * Arrays class implementor&#39;s note: It is an empirical matter
  96      * whether ComparableTimSort offers any performance benefit over
  97      * TimSort used with this comparator.  If not, you are better off
  98      * deleting or bypassing ComparableTimSort.  There is currently no
  99      * empirical case for separating them for parallel sorting, so all
 100      * public Object parallelSort methods use the same comparator
 101      * based implementation.
 102      */
 103     static final class NaturalOrder implements Comparator&lt;Object&gt; {
 104         @SuppressWarnings(&quot;unchecked&quot;)
 105         public int compare(Object first, Object second) {
 106             return ((Comparable&lt;Object&gt;)first).compareTo(second);
 107         }
 108         static final NaturalOrder INSTANCE = new NaturalOrder();
 109     }
 110 
 111     /**
 112      * Checks that {@code fromIndex} and {@code toIndex} are in
 113      * the range and throws an exception if they aren&#39;t.
 114      */
 115     static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {
 116         if (fromIndex &gt; toIndex) {
 117             throw new IllegalArgumentException(
 118                     &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
 119         }
 120         if (fromIndex &lt; 0) {
 121             throw new ArrayIndexOutOfBoundsException(fromIndex);
 122         }
 123         if (toIndex &gt; arrayLength) {
 124             throw new ArrayIndexOutOfBoundsException(toIndex);
 125         }
 126     }
 127 
 128     /*
 129      * Sorting methods. Note that all public &quot;sort&quot; methods take the
 130      * same form: Performing argument checks if necessary, and then
 131      * expanding arguments into those required for the internal
 132      * implementation methods residing in other package-private
 133      * classes (except for legacyMergeSort, included in this class).
 134      */
 135 
 136     /**
 137      * Sorts the specified array into ascending numerical order.
 138      *
 139      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 140      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 141      * offers O(n log(n)) performance on many data sets that cause other
 142      * quicksorts to degrade to quadratic performance, and is typically
 143      * faster than traditional (one-pivot) Quicksort implementations.
 144      *
 145      * @param a the array to be sorted
 146      */
 147     public static void sort(int[] a) {
 148         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 149     }
 150 
 151     /**
 152      * Sorts the specified range of the array into ascending order. The range
 153      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 154      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 155      * the range to be sorted is empty.
 156      *
 157      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 158      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 159      * offers O(n log(n)) performance on many data sets that cause other
 160      * quicksorts to degrade to quadratic performance, and is typically
 161      * faster than traditional (one-pivot) Quicksort implementations.
 162      *
 163      * @param a the array to be sorted
 164      * @param fromIndex the index of the first element, inclusive, to be sorted
 165      * @param toIndex the index of the last element, exclusive, to be sorted
 166      *
 167      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 168      * @throws ArrayIndexOutOfBoundsException
 169      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 170      */
 171     public static void sort(int[] a, int fromIndex, int toIndex) {
 172         rangeCheck(a.length, fromIndex, toIndex);
 173         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 174     }
 175 
 176     /**
 177      * Sorts the specified array into ascending numerical order.
 178      *
 179      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 180      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 181      * offers O(n log(n)) performance on many data sets that cause other
 182      * quicksorts to degrade to quadratic performance, and is typically
 183      * faster than traditional (one-pivot) Quicksort implementations.
 184      *
 185      * @param a the array to be sorted
 186      */
 187     public static void sort(long[] a) {
 188         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 189     }
 190 
 191     /**
 192      * Sorts the specified range of the array into ascending order. The range
 193      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 194      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 195      * the range to be sorted is empty.
 196      *
 197      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 198      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 199      * offers O(n log(n)) performance on many data sets that cause other
 200      * quicksorts to degrade to quadratic performance, and is typically
 201      * faster than traditional (one-pivot) Quicksort implementations.
 202      *
 203      * @param a the array to be sorted
 204      * @param fromIndex the index of the first element, inclusive, to be sorted
 205      * @param toIndex the index of the last element, exclusive, to be sorted
 206      *
 207      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 208      * @throws ArrayIndexOutOfBoundsException
 209      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 210      */
 211     public static void sort(long[] a, int fromIndex, int toIndex) {
 212         rangeCheck(a.length, fromIndex, toIndex);
 213         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 214     }
 215 
 216     /**
 217      * Sorts the specified array into ascending numerical order.
 218      *
 219      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 220      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 221      * offers O(n log(n)) performance on many data sets that cause other
 222      * quicksorts to degrade to quadratic performance, and is typically
 223      * faster than traditional (one-pivot) Quicksort implementations.
 224      *
 225      * @param a the array to be sorted
 226      */
 227     public static void sort(short[] a) {
 228         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 229     }
 230 
 231     /**
 232      * Sorts the specified range of the array into ascending order. The range
 233      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 234      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 235      * the range to be sorted is empty.
 236      *
 237      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 238      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 239      * offers O(n log(n)) performance on many data sets that cause other
 240      * quicksorts to degrade to quadratic performance, and is typically
 241      * faster than traditional (one-pivot) Quicksort implementations.
 242      *
 243      * @param a the array to be sorted
 244      * @param fromIndex the index of the first element, inclusive, to be sorted
 245      * @param toIndex the index of the last element, exclusive, to be sorted
 246      *
 247      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 248      * @throws ArrayIndexOutOfBoundsException
 249      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 250      */
 251     public static void sort(short[] a, int fromIndex, int toIndex) {
 252         rangeCheck(a.length, fromIndex, toIndex);
 253         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 254     }
 255 
 256     /**
 257      * Sorts the specified array into ascending numerical order.
 258      *
 259      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 260      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 261      * offers O(n log(n)) performance on many data sets that cause other
 262      * quicksorts to degrade to quadratic performance, and is typically
 263      * faster than traditional (one-pivot) Quicksort implementations.
 264      *
 265      * @param a the array to be sorted
 266      */
 267     public static void sort(char[] a) {
 268         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 269     }
 270 
 271     /**
 272      * Sorts the specified range of the array into ascending order. The range
 273      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 274      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 275      * the range to be sorted is empty.
 276      *
 277      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 278      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 279      * offers O(n log(n)) performance on many data sets that cause other
 280      * quicksorts to degrade to quadratic performance, and is typically
 281      * faster than traditional (one-pivot) Quicksort implementations.
 282      *
 283      * @param a the array to be sorted
 284      * @param fromIndex the index of the first element, inclusive, to be sorted
 285      * @param toIndex the index of the last element, exclusive, to be sorted
 286      *
 287      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 288      * @throws ArrayIndexOutOfBoundsException
 289      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 290      */
 291     public static void sort(char[] a, int fromIndex, int toIndex) {
 292         rangeCheck(a.length, fromIndex, toIndex);
 293         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 294     }
 295 
 296     /**
 297      * Sorts the specified array into ascending numerical order.
 298      *
 299      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 300      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 301      * offers O(n log(n)) performance on many data sets that cause other
 302      * quicksorts to degrade to quadratic performance, and is typically
 303      * faster than traditional (one-pivot) Quicksort implementations.
 304      *
 305      * @param a the array to be sorted
 306      */
 307     public static void sort(byte[] a) {
 308         DualPivotQuicksort.sort(a, 0, a.length - 1);
 309     }
 310 
 311     /**
 312      * Sorts the specified range of the array into ascending order. The range
 313      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 314      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 315      * the range to be sorted is empty.
 316      *
 317      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 318      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 319      * offers O(n log(n)) performance on many data sets that cause other
 320      * quicksorts to degrade to quadratic performance, and is typically
 321      * faster than traditional (one-pivot) Quicksort implementations.
 322      *
 323      * @param a the array to be sorted
 324      * @param fromIndex the index of the first element, inclusive, to be sorted
 325      * @param toIndex the index of the last element, exclusive, to be sorted
 326      *
 327      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 328      * @throws ArrayIndexOutOfBoundsException
 329      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 330      */
 331     public static void sort(byte[] a, int fromIndex, int toIndex) {
 332         rangeCheck(a.length, fromIndex, toIndex);
 333         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);
 334     }
 335 
 336     /**
 337      * Sorts the specified array into ascending numerical order.
 338      *
 339      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 340      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 341      * value compares neither less than, greater than, nor equal to any value,
 342      * even itself. This method uses the total order imposed by the method
 343      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 344      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 345      * other value and all {@code Float.NaN} values are considered equal.
 346      *
 347      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 348      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 349      * offers O(n log(n)) performance on many data sets that cause other
 350      * quicksorts to degrade to quadratic performance, and is typically
 351      * faster than traditional (one-pivot) Quicksort implementations.
 352      *
 353      * @param a the array to be sorted
 354      */
 355     public static void sort(float[] a) {
 356         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 357     }
 358 
 359     /**
 360      * Sorts the specified range of the array into ascending order. The range
 361      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 362      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 363      * the range to be sorted is empty.
 364      *
 365      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 366      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 367      * value compares neither less than, greater than, nor equal to any value,
 368      * even itself. This method uses the total order imposed by the method
 369      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 370      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 371      * other value and all {@code Float.NaN} values are considered equal.
 372      *
 373      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 374      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 375      * offers O(n log(n)) performance on many data sets that cause other
 376      * quicksorts to degrade to quadratic performance, and is typically
 377      * faster than traditional (one-pivot) Quicksort implementations.
 378      *
 379      * @param a the array to be sorted
 380      * @param fromIndex the index of the first element, inclusive, to be sorted
 381      * @param toIndex the index of the last element, exclusive, to be sorted
 382      *
 383      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 384      * @throws ArrayIndexOutOfBoundsException
 385      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 386      */
 387     public static void sort(float[] a, int fromIndex, int toIndex) {
 388         rangeCheck(a.length, fromIndex, toIndex);
 389         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 390     }
 391 
 392     /**
 393      * Sorts the specified array into ascending numerical order.
 394      *
 395      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 396      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 397      * value compares neither less than, greater than, nor equal to any value,
 398      * even itself. This method uses the total order imposed by the method
 399      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 400      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 401      * other value and all {@code Double.NaN} values are considered equal.
 402      *
 403      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 404      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 405      * offers O(n log(n)) performance on many data sets that cause other
 406      * quicksorts to degrade to quadratic performance, and is typically
 407      * faster than traditional (one-pivot) Quicksort implementations.
 408      *
 409      * @param a the array to be sorted
 410      */
 411     public static void sort(double[] a) {
 412         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
 413     }
 414 
 415     /**
 416      * Sorts the specified range of the array into ascending order. The range
 417      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 418      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 419      * the range to be sorted is empty.
 420      *
 421      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 422      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 423      * value compares neither less than, greater than, nor equal to any value,
 424      * even itself. This method uses the total order imposed by the method
 425      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 426      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 427      * other value and all {@code Double.NaN} values are considered equal.
 428      *
 429      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 430      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 431      * offers O(n log(n)) performance on many data sets that cause other
 432      * quicksorts to degrade to quadratic performance, and is typically
 433      * faster than traditional (one-pivot) Quicksort implementations.
 434      *
 435      * @param a the array to be sorted
 436      * @param fromIndex the index of the first element, inclusive, to be sorted
 437      * @param toIndex the index of the last element, exclusive, to be sorted
 438      *
 439      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 440      * @throws ArrayIndexOutOfBoundsException
 441      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 442      */
 443     public static void sort(double[] a, int fromIndex, int toIndex) {
 444         rangeCheck(a.length, fromIndex, toIndex);
 445         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 446     }
 447 
 448     /**
 449      * Sorts the specified array into ascending numerical order.
 450      *
 451      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 452      * array into sub-arrays that are themselves sorted and then merged. When
 453      * the sub-array length reaches a minimum granularity, the sub-array is
 454      * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}
 455      * method. If the length of the specified array is less than the minimum
 456      * granularity, then it is sorted using the appropriate {@link
 457      * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a
 458      * working space no greater than the size of the original array. The
 459      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 460      * execute any parallel tasks.
 461      *
 462      * @param a the array to be sorted
 463      *
 464      * @since 1.8
 465      */
 466     public static void parallelSort(byte[] a) {
 467         int n = a.length, p, g;
 468         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 469             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 470             DualPivotQuicksort.sort(a, 0, n - 1);
 471         else
 472             new ArraysParallelSortHelpers.FJByte.Sorter
 473                 (null, a, new byte[n], 0, n, 0,
 474                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 475                  MIN_ARRAY_SORT_GRAN : g).invoke();
 476     }
 477 
 478     /**
 479      * Sorts the specified range of the array into ascending numerical order.
 480      * The range to be sorted extends from the index {@code fromIndex},
 481      * inclusive, to the index {@code toIndex}, exclusive. If
 482      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 483      *
 484      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 485      * array into sub-arrays that are themselves sorted and then merged. When
 486      * the sub-array length reaches a minimum granularity, the sub-array is
 487      * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}
 488      * method. If the length of the specified array is less than the minimum
 489      * granularity, then it is sorted using the appropriate {@link
 490      * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a working
 491      * space no greater than the size of the specified range of the original
 492      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 493      * used to execute any parallel tasks.
 494      *
 495      * @param a the array to be sorted
 496      * @param fromIndex the index of the first element, inclusive, to be sorted
 497      * @param toIndex the index of the last element, exclusive, to be sorted
 498      *
 499      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 500      * @throws ArrayIndexOutOfBoundsException
 501      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 502      *
 503      * @since 1.8
 504      */
 505     public static void parallelSort(byte[] a, int fromIndex, int toIndex) {
 506         rangeCheck(a.length, fromIndex, toIndex);
 507         int n = toIndex - fromIndex, p, g;
 508         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 509             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 510             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);
 511         else
 512             new ArraysParallelSortHelpers.FJByte.Sorter
 513                 (null, a, new byte[n], fromIndex, n, 0,
 514                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 515                  MIN_ARRAY_SORT_GRAN : g).invoke();
 516     }
 517 
 518     /**
 519      * Sorts the specified array into ascending numerical order.
 520      *
 521      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 522      * array into sub-arrays that are themselves sorted and then merged. When
 523      * the sub-array length reaches a minimum granularity, the sub-array is
 524      * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}
 525      * method. If the length of the specified array is less than the minimum
 526      * granularity, then it is sorted using the appropriate {@link
 527      * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a
 528      * working space no greater than the size of the original array. The
 529      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 530      * execute any parallel tasks.
 531      *
 532      * @param a the array to be sorted
 533      *
 534      * @since 1.8
 535      */
 536     public static void parallelSort(char[] a) {
 537         int n = a.length, p, g;
 538         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 539             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 540             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
 541         else
 542             new ArraysParallelSortHelpers.FJChar.Sorter
 543                 (null, a, new char[n], 0, n, 0,
 544                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 545                  MIN_ARRAY_SORT_GRAN : g).invoke();
 546     }
 547 
 548     /**
 549      * Sorts the specified range of the array into ascending numerical order.
 550      * The range to be sorted extends from the index {@code fromIndex},
 551      * inclusive, to the index {@code toIndex}, exclusive. If
 552      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 553      *
 554       @implNote The sorting algorithm is a parallel sort-merge that breaks the
 555      * array into sub-arrays that are themselves sorted and then merged. When
 556      * the sub-array length reaches a minimum granularity, the sub-array is
 557      * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}
 558      * method. If the length of the specified array is less than the minimum
 559      * granularity, then it is sorted using the appropriate {@link
 560      * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a working
 561      * space no greater than the size of the specified range of the original
 562      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 563      * used to execute any parallel tasks.
 564      *
 565      * @param a the array to be sorted
 566      * @param fromIndex the index of the first element, inclusive, to be sorted
 567      * @param toIndex the index of the last element, exclusive, to be sorted
 568      *
 569      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 570      * @throws ArrayIndexOutOfBoundsException
 571      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 572      *
 573      * @since 1.8
 574      */
 575     public static void parallelSort(char[] a, int fromIndex, int toIndex) {
 576         rangeCheck(a.length, fromIndex, toIndex);
 577         int n = toIndex - fromIndex, p, g;
 578         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 579             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 580             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 581         else
 582             new ArraysParallelSortHelpers.FJChar.Sorter
 583                 (null, a, new char[n], fromIndex, n, 0,
 584                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 585                  MIN_ARRAY_SORT_GRAN : g).invoke();
 586     }
 587 
 588     /**
 589      * Sorts the specified array into ascending numerical order.
 590      *
 591      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 592      * array into sub-arrays that are themselves sorted and then merged. When
 593      * the sub-array length reaches a minimum granularity, the sub-array is
 594      * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}
 595      * method. If the length of the specified array is less than the minimum
 596      * granularity, then it is sorted using the appropriate {@link
 597      * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a
 598      * working space no greater than the size of the original array. The
 599      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 600      * execute any parallel tasks.
 601      *
 602      * @param a the array to be sorted
 603      *
 604      * @since 1.8
 605      */
 606     public static void parallelSort(short[] a) {
 607         int n = a.length, p, g;
 608         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 609             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 610             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
 611         else
 612             new ArraysParallelSortHelpers.FJShort.Sorter
 613                 (null, a, new short[n], 0, n, 0,
 614                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 615                  MIN_ARRAY_SORT_GRAN : g).invoke();
 616     }
 617 
 618     /**
 619      * Sorts the specified range of the array into ascending numerical order.
 620      * The range to be sorted extends from the index {@code fromIndex},
 621      * inclusive, to the index {@code toIndex}, exclusive. If
 622      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 623      *
 624      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 625      * array into sub-arrays that are themselves sorted and then merged. When
 626      * the sub-array length reaches a minimum granularity, the sub-array is
 627      * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}
 628      * method. If the length of the specified array is less than the minimum
 629      * granularity, then it is sorted using the appropriate {@link
 630      * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a working
 631      * space no greater than the size of the specified range of the original
 632      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 633      * used to execute any parallel tasks.
 634      *
 635      * @param a the array to be sorted
 636      * @param fromIndex the index of the first element, inclusive, to be sorted
 637      * @param toIndex the index of the last element, exclusive, to be sorted
 638      *
 639      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 640      * @throws ArrayIndexOutOfBoundsException
 641      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 642      *
 643      * @since 1.8
 644      */
 645     public static void parallelSort(short[] a, int fromIndex, int toIndex) {
 646         rangeCheck(a.length, fromIndex, toIndex);
 647         int n = toIndex - fromIndex, p, g;
 648         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 649             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 650             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 651         else
 652             new ArraysParallelSortHelpers.FJShort.Sorter
 653                 (null, a, new short[n], fromIndex, n, 0,
 654                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 655                  MIN_ARRAY_SORT_GRAN : g).invoke();
 656     }
 657 
 658     /**
 659      * Sorts the specified array into ascending numerical order.
 660      *
 661      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 662      * array into sub-arrays that are themselves sorted and then merged. When
 663      * the sub-array length reaches a minimum granularity, the sub-array is
 664      * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}
 665      * method. If the length of the specified array is less than the minimum
 666      * granularity, then it is sorted using the appropriate {@link
 667      * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a
 668      * working space no greater than the size of the original array. The
 669      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 670      * execute any parallel tasks.
 671      *
 672      * @param a the array to be sorted
 673      *
 674      * @since 1.8
 675      */
 676     public static void parallelSort(int[] a) {
 677         int n = a.length, p, g;
 678         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 679             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 680             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
 681         else
 682             new ArraysParallelSortHelpers.FJInt.Sorter
 683                 (null, a, new int[n], 0, n, 0,
 684                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 685                  MIN_ARRAY_SORT_GRAN : g).invoke();
 686     }
 687 
 688     /**
 689      * Sorts the specified range of the array into ascending numerical order.
 690      * The range to be sorted extends from the index {@code fromIndex},
 691      * inclusive, to the index {@code toIndex}, exclusive. If
 692      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 693      *
 694      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 695      * array into sub-arrays that are themselves sorted and then merged. When
 696      * the sub-array length reaches a minimum granularity, the sub-array is
 697      * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}
 698      * method. If the length of the specified array is less than the minimum
 699      * granularity, then it is sorted using the appropriate {@link
 700      * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a working
 701      * space no greater than the size of the specified range of the original
 702      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 703      * used to execute any parallel tasks.
 704      *
 705      * @param a the array to be sorted
 706      * @param fromIndex the index of the first element, inclusive, to be sorted
 707      * @param toIndex the index of the last element, exclusive, to be sorted
 708      *
 709      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 710      * @throws ArrayIndexOutOfBoundsException
 711      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 712      *
 713      * @since 1.8
 714      */
 715     public static void parallelSort(int[] a, int fromIndex, int toIndex) {
 716         rangeCheck(a.length, fromIndex, toIndex);
 717         int n = toIndex - fromIndex, p, g;
 718         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 719             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 720             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 721         else
 722             new ArraysParallelSortHelpers.FJInt.Sorter
 723                 (null, a, new int[n], fromIndex, n, 0,
 724                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 725                  MIN_ARRAY_SORT_GRAN : g).invoke();
 726     }
 727 
 728     /**
 729      * Sorts the specified array into ascending numerical order.
 730      *
 731      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 732      * array into sub-arrays that are themselves sorted and then merged. When
 733      * the sub-array length reaches a minimum granularity, the sub-array is
 734      * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}
 735      * method. If the length of the specified array is less than the minimum
 736      * granularity, then it is sorted using the appropriate {@link
 737      * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a
 738      * working space no greater than the size of the original array. The
 739      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 740      * execute any parallel tasks.
 741      *
 742      * @param a the array to be sorted
 743      *
 744      * @since 1.8
 745      */
 746     public static void parallelSort(long[] a) {
 747         int n = a.length, p, g;
 748         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 749             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 750             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
 751         else
 752             new ArraysParallelSortHelpers.FJLong.Sorter
 753                 (null, a, new long[n], 0, n, 0,
 754                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 755                  MIN_ARRAY_SORT_GRAN : g).invoke();
 756     }
 757 
 758     /**
 759      * Sorts the specified range of the array into ascending numerical order.
 760      * The range to be sorted extends from the index {@code fromIndex},
 761      * inclusive, to the index {@code toIndex}, exclusive. If
 762      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 763      *
 764      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 765      * array into sub-arrays that are themselves sorted and then merged. When
 766      * the sub-array length reaches a minimum granularity, the sub-array is
 767      * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}
 768      * method. If the length of the specified array is less than the minimum
 769      * granularity, then it is sorted using the appropriate {@link
 770      * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a working
 771      * space no greater than the size of the specified range of the original
 772      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 773      * used to execute any parallel tasks.
 774      *
 775      * @param a the array to be sorted
 776      * @param fromIndex the index of the first element, inclusive, to be sorted
 777      * @param toIndex the index of the last element, exclusive, to be sorted
 778      *
 779      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 780      * @throws ArrayIndexOutOfBoundsException
 781      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 782      *
 783      * @since 1.8
 784      */
 785     public static void parallelSort(long[] a, int fromIndex, int toIndex) {
 786         rangeCheck(a.length, fromIndex, toIndex);
 787         int n = toIndex - fromIndex, p, g;
 788         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 789             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 790             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 791         else
 792             new ArraysParallelSortHelpers.FJLong.Sorter
 793                 (null, a, new long[n], fromIndex, n, 0,
 794                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 795                  MIN_ARRAY_SORT_GRAN : g).invoke();
 796     }
 797 
 798     /**
 799      * Sorts the specified array into ascending numerical order.
 800      *
 801      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 802      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 803      * value compares neither less than, greater than, nor equal to any value,
 804      * even itself. This method uses the total order imposed by the method
 805      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 806      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 807      * other value and all {@code Float.NaN} values are considered equal.
 808      *
 809      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 810      * array into sub-arrays that are themselves sorted and then merged. When
 811      * the sub-array length reaches a minimum granularity, the sub-array is
 812      * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}
 813      * method. If the length of the specified array is less than the minimum
 814      * granularity, then it is sorted using the appropriate {@link
 815      * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a
 816      * working space no greater than the size of the original array. The
 817      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 818      * execute any parallel tasks.
 819      *
 820      * @param a the array to be sorted
 821      *
 822      * @since 1.8
 823      */
 824     public static void parallelSort(float[] a) {
 825         int n = a.length, p, g;
 826         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 827             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 828             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
 829         else
 830             new ArraysParallelSortHelpers.FJFloat.Sorter
 831                 (null, a, new float[n], 0, n, 0,
 832                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 833                  MIN_ARRAY_SORT_GRAN : g).invoke();
 834     }
 835 
 836     /**
 837      * Sorts the specified range of the array into ascending numerical order.
 838      * The range to be sorted extends from the index {@code fromIndex},
 839      * inclusive, to the index {@code toIndex}, exclusive. If
 840      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 841      *
 842      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 843      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 844      * value compares neither less than, greater than, nor equal to any value,
 845      * even itself. This method uses the total order imposed by the method
 846      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 847      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 848      * other value and all {@code Float.NaN} values are considered equal.
 849      *
 850      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 851      * array into sub-arrays that are themselves sorted and then merged. When
 852      * the sub-array length reaches a minimum granularity, the sub-array is
 853      * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}
 854      * method. If the length of the specified array is less than the minimum
 855      * granularity, then it is sorted using the appropriate {@link
 856      * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a working
 857      * space no greater than the size of the specified range of the original
 858      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 859      * used to execute any parallel tasks.
 860      *
 861      * @param a the array to be sorted
 862      * @param fromIndex the index of the first element, inclusive, to be sorted
 863      * @param toIndex the index of the last element, exclusive, to be sorted
 864      *
 865      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 866      * @throws ArrayIndexOutOfBoundsException
 867      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 868      *
 869      * @since 1.8
 870      */
 871     public static void parallelSort(float[] a, int fromIndex, int toIndex) {
 872         rangeCheck(a.length, fromIndex, toIndex);
 873         int n = toIndex - fromIndex, p, g;
 874         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 875             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 876             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 877         else
 878             new ArraysParallelSortHelpers.FJFloat.Sorter
 879                 (null, a, new float[n], fromIndex, n, 0,
 880                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 881                  MIN_ARRAY_SORT_GRAN : g).invoke();
 882     }
 883 
 884     /**
 885      * Sorts the specified array into ascending numerical order.
 886      *
 887      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 888      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 889      * value compares neither less than, greater than, nor equal to any value,
 890      * even itself. This method uses the total order imposed by the method
 891      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 892      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 893      * other value and all {@code Double.NaN} values are considered equal.
 894      *
 895      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 896      * array into sub-arrays that are themselves sorted and then merged. When
 897      * the sub-array length reaches a minimum granularity, the sub-array is
 898      * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}
 899      * method. If the length of the specified array is less than the minimum
 900      * granularity, then it is sorted using the appropriate {@link
 901      * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a
 902      * working space no greater than the size of the original array. The
 903      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 904      * execute any parallel tasks.
 905      *
 906      * @param a the array to be sorted
 907      *
 908      * @since 1.8
 909      */
 910     public static void parallelSort(double[] a) {
 911         int n = a.length, p, g;
 912         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 913             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 914             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
 915         else
 916             new ArraysParallelSortHelpers.FJDouble.Sorter
 917                 (null, a, new double[n], 0, n, 0,
 918                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 919                  MIN_ARRAY_SORT_GRAN : g).invoke();
 920     }
 921 
 922     /**
 923      * Sorts the specified range of the array into ascending numerical order.
 924      * The range to be sorted extends from the index {@code fromIndex},
 925      * inclusive, to the index {@code toIndex}, exclusive. If
 926      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 927      *
 928      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 929      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 930      * value compares neither less than, greater than, nor equal to any value,
 931      * even itself. This method uses the total order imposed by the method
 932      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 933      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 934      * other value and all {@code Double.NaN} values are considered equal.
 935      *
 936      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 937      * array into sub-arrays that are themselves sorted and then merged. When
 938      * the sub-array length reaches a minimum granularity, the sub-array is
 939      * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}
 940      * method. If the length of the specified array is less than the minimum
 941      * granularity, then it is sorted using the appropriate {@link
 942      * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a working
 943      * space no greater than the size of the specified range of the original
 944      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
 945      * used to execute any parallel tasks.
 946      *
 947      * @param a the array to be sorted
 948      * @param fromIndex the index of the first element, inclusive, to be sorted
 949      * @param toIndex the index of the last element, exclusive, to be sorted
 950      *
 951      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 952      * @throws ArrayIndexOutOfBoundsException
 953      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 954      *
 955      * @since 1.8
 956      */
 957     public static void parallelSort(double[] a, int fromIndex, int toIndex) {
 958         rangeCheck(a.length, fromIndex, toIndex);
 959         int n = toIndex - fromIndex, p, g;
 960         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
 961             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
 962             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
 963         else
 964             new ArraysParallelSortHelpers.FJDouble.Sorter
 965                 (null, a, new double[n], fromIndex, n, 0,
 966                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
 967                  MIN_ARRAY_SORT_GRAN : g).invoke();
 968     }
 969 
 970     /**
 971      * Sorts the specified array of objects into ascending order, according
 972      * to the {@linkplain Comparable natural ordering} of its elements.
 973      * All elements in the array must implement the {@link Comparable}
 974      * interface.  Furthermore, all elements in the array must be
 975      * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
 976      * not throw a {@code ClassCastException} for any elements {@code e1}
 977      * and {@code e2} in the array).
 978      *
 979      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 980      * not be reordered as a result of the sort.
 981      *
 982      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 983      * array into sub-arrays that are themselves sorted and then merged. When
 984      * the sub-array length reaches a minimum granularity, the sub-array is
 985      * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
 986      * method. If the length of the specified array is less than the minimum
 987      * granularity, then it is sorted using the appropriate {@link
 988      * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
 989      * working space no greater than the size of the original array. The
 990      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
 991      * execute any parallel tasks.
 992      *
 993      * @param &lt;T&gt; the class of the objects to be sorted
 994      * @param a the array to be sorted
 995      *
 996      * @throws ClassCastException if the array contains elements that are not
 997      *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)
 998      * @throws IllegalArgumentException (optional) if the natural
 999      *         ordering of the array elements is found to violate the
1000      *         {@link Comparable} contract
1001      *
1002      * @since 1.8
1003      */
1004     @SuppressWarnings(&quot;unchecked&quot;)
1005     public static &lt;T extends Comparable&lt;? super T&gt;&gt; void parallelSort(T[] a) {
1006         int n = a.length, p, g;
1007         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
1008             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
1009             TimSort.sort(a, 0, n, NaturalOrder.INSTANCE, null, 0, 0);
1010         else
1011             new ArraysParallelSortHelpers.FJObject.Sorter&lt;&gt;
1012                 (null, a,
1013                  (T[])Array.newInstance(a.getClass().getComponentType(), n),
1014                  0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
1015                  MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();
1016     }
1017 
1018     /**
1019      * Sorts the specified range of the specified array of objects into
1020      * ascending order, according to the
1021      * {@linkplain Comparable natural ordering} of its
1022      * elements.  The range to be sorted extends from index
1023      * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.
1024      * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All
1025      * elements in this range must implement the {@link Comparable}
1026      * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
1027      * comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a
1028      * {@code ClassCastException} for any elements {@code e1} and
1029      * {@code e2} in the array).
1030      *
1031      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1032      * not be reordered as a result of the sort.
1033      *
1034      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
1035      * array into sub-arrays that are themselves sorted and then merged. When
1036      * the sub-array length reaches a minimum granularity, the sub-array is
1037      * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
1038      * method. If the length of the specified array is less than the minimum
1039      * granularity, then it is sorted using the appropriate {@link
1040      * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working
1041      * space no greater than the size of the specified range of the original
1042      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
1043      * used to execute any parallel tasks.
1044      *
1045      * @param &lt;T&gt; the class of the objects to be sorted
1046      * @param a the array to be sorted
1047      * @param fromIndex the index of the first element (inclusive) to be
1048      *        sorted
1049      * @param toIndex the index of the last element (exclusive) to be sorted
1050      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
1051      *         (optional) if the natural ordering of the array elements is
1052      *         found to violate the {@link Comparable} contract
1053      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
1054      *         {@code toIndex &gt; a.length}
1055      * @throws ClassCastException if the array contains elements that are
1056      *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
1057      *         integers).
1058      *
1059      * @since 1.8
1060      */
1061     @SuppressWarnings(&quot;unchecked&quot;)
1062     public static &lt;T extends Comparable&lt;? super T&gt;&gt;
1063     void parallelSort(T[] a, int fromIndex, int toIndex) {
1064         rangeCheck(a.length, fromIndex, toIndex);
1065         int n = toIndex - fromIndex, p, g;
1066         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
1067             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
1068             TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, null, 0, 0);
1069         else
1070             new ArraysParallelSortHelpers.FJObject.Sorter&lt;&gt;
1071                 (null, a,
1072                  (T[])Array.newInstance(a.getClass().getComponentType(), n),
1073                  fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
1074                  MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();
1075     }
1076 
1077     /**
1078      * Sorts the specified array of objects according to the order induced by
1079      * the specified comparator.  All elements in the array must be
1080      * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
1081      * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
1082      * for any elements {@code e1} and {@code e2} in the array).
1083      *
1084      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1085      * not be reordered as a result of the sort.
1086      *
1087      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
1088      * array into sub-arrays that are themselves sorted and then merged. When
1089      * the sub-array length reaches a minimum granularity, the sub-array is
1090      * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
1091      * method. If the length of the specified array is less than the minimum
1092      * granularity, then it is sorted using the appropriate {@link
1093      * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
1094      * working space no greater than the size of the original array. The
1095      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
1096      * execute any parallel tasks.
1097      *
1098      * @param &lt;T&gt; the class of the objects to be sorted
1099      * @param a the array to be sorted
1100      * @param cmp the comparator to determine the order of the array.  A
1101      *        {@code null} value indicates that the elements&#39;
1102      *        {@linkplain Comparable natural ordering} should be used.
1103      * @throws ClassCastException if the array contains elements that are
1104      *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
1105      * @throws IllegalArgumentException (optional) if the comparator is
1106      *         found to violate the {@link java.util.Comparator} contract
1107      *
1108      * @since 1.8
1109      */
1110     @SuppressWarnings(&quot;unchecked&quot;)
1111     public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) {
1112         if (cmp == null)
1113             cmp = NaturalOrder.INSTANCE;
1114         int n = a.length, p, g;
1115         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
1116             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
1117             TimSort.sort(a, 0, n, cmp, null, 0, 0);
1118         else
1119             new ArraysParallelSortHelpers.FJObject.Sorter&lt;&gt;
1120                 (null, a,
1121                  (T[])Array.newInstance(a.getClass().getComponentType(), n),
1122                  0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
1123                  MIN_ARRAY_SORT_GRAN : g, cmp).invoke();
1124     }
1125 
1126     /**
1127      * Sorts the specified range of the specified array of objects according
1128      * to the order induced by the specified comparator.  The range to be
1129      * sorted extends from index {@code fromIndex}, inclusive, to index
1130      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
1131      * range to be sorted is empty.)  All elements in the range must be
1132      * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
1133      * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
1134      * for any elements {@code e1} and {@code e2} in the range).
1135      *
1136      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1137      * not be reordered as a result of the sort.
1138      *
1139      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
1140      * array into sub-arrays that are themselves sorted and then merged. When
1141      * the sub-array length reaches a minimum granularity, the sub-array is
1142      * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
1143      * method. If the length of the specified array is less than the minimum
1144      * granularity, then it is sorted using the appropriate {@link
1145      * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working
1146      * space no greater than the size of the specified range of the original
1147      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
1148      * used to execute any parallel tasks.
1149      *
1150      * @param &lt;T&gt; the class of the objects to be sorted
1151      * @param a the array to be sorted
1152      * @param fromIndex the index of the first element (inclusive) to be
1153      *        sorted
1154      * @param toIndex the index of the last element (exclusive) to be sorted
1155      * @param cmp the comparator to determine the order of the array.  A
1156      *        {@code null} value indicates that the elements&#39;
1157      *        {@linkplain Comparable natural ordering} should be used.
1158      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
1159      *         (optional) if the natural ordering of the array elements is
1160      *         found to violate the {@link Comparable} contract
1161      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
1162      *         {@code toIndex &gt; a.length}
1163      * @throws ClassCastException if the array contains elements that are
1164      *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
1165      *         integers).
1166      *
1167      * @since 1.8
1168      */
1169     @SuppressWarnings(&quot;unchecked&quot;)
1170     public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex,
1171                                         Comparator&lt;? super T&gt; cmp) {
1172         rangeCheck(a.length, fromIndex, toIndex);
1173         if (cmp == null)
1174             cmp = NaturalOrder.INSTANCE;
1175         int n = toIndex - fromIndex, p, g;
1176         if (n &lt;= MIN_ARRAY_SORT_GRAN ||
1177             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
1178             TimSort.sort(a, fromIndex, toIndex, cmp, null, 0, 0);
1179         else
1180             new ArraysParallelSortHelpers.FJObject.Sorter&lt;&gt;
1181                 (null, a,
1182                  (T[])Array.newInstance(a.getClass().getComponentType(), n),
1183                  fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
1184                  MIN_ARRAY_SORT_GRAN : g, cmp).invoke();
1185     }
1186 
1187     /*
1188      * Sorting of complex type arrays.
1189      */
1190 
1191     /**
1192      * Old merge sort implementation can be selected (for
1193      * compatibility with broken comparators) using a system property.
1194      * Cannot be a static boolean in the enclosing class due to
1195      * circular dependencies. To be removed in a future release.
1196      */
1197     static final class LegacyMergeSort {
1198         private static final boolean userRequested =
1199             java.security.AccessController.doPrivileged(
1200                 new sun.security.action.GetBooleanAction(
1201                     &quot;java.util.Arrays.useLegacyMergeSort&quot;)).booleanValue();
1202     }
1203 
1204     /**
1205      * Sorts the specified array of objects into ascending order, according
1206      * to the {@linkplain Comparable natural ordering} of its elements.
1207      * All elements in the array must implement the {@link Comparable}
1208      * interface.  Furthermore, all elements in the array must be
1209      * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
1210      * not throw a {@code ClassCastException} for any elements {@code e1}
1211      * and {@code e2} in the array).
1212      *
1213      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1214      * not be reordered as a result of the sort.
1215      *
1216      * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
1217      * iterative mergesort that requires far fewer than n lg(n) comparisons
1218      * when the input array is partially sorted, while offering the
1219      * performance of a traditional mergesort when the input array is
1220      * randomly ordered.  If the input array is nearly sorted, the
1221      * implementation requires approximately n comparisons.  Temporary
1222      * storage requirements vary from a small constant for nearly sorted
1223      * input arrays to n/2 object references for randomly ordered input
1224      * arrays.
1225      *
1226      * &lt;p&gt;The implementation takes equal advantage of ascending and
1227      * descending order in its input array, and can take advantage of
1228      * ascending and descending order in different parts of the same
1229      * input array.  It is well-suited to merging two or more sorted arrays:
1230      * simply concatenate the arrays and sort the resulting array.
1231      *
1232      * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
1233      * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
1234      * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
1235      * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
1236      * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
1237      * January 1993.
1238      *
1239      * @param a the array to be sorted
1240      * @throws ClassCastException if the array contains elements that are not
1241      *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)
1242      * @throws IllegalArgumentException (optional) if the natural
1243      *         ordering of the array elements is found to violate the
1244      *         {@link Comparable} contract
1245      */
1246     public static void sort(Object[] a) {
1247         if (LegacyMergeSort.userRequested)
1248             legacyMergeSort(a);
1249         else
1250             ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
1251     }
1252 
1253     /** To be removed in a future release. */
1254     private static void legacyMergeSort(Object[] a) {
1255         Object[] aux = a.clone();
1256         mergeSort(aux, a, 0, a.length, 0);
1257     }
1258 
1259     /**
1260      * Sorts the specified range of the specified array of objects into
1261      * ascending order, according to the
1262      * {@linkplain Comparable natural ordering} of its
1263      * elements.  The range to be sorted extends from index
1264      * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.
1265      * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All
1266      * elements in this range must implement the {@link Comparable}
1267      * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
1268      * comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a
1269      * {@code ClassCastException} for any elements {@code e1} and
1270      * {@code e2} in the array).
1271      *
1272      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1273      * not be reordered as a result of the sort.
1274      *
1275      * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
1276      * iterative mergesort that requires far fewer than n lg(n) comparisons
1277      * when the input array is partially sorted, while offering the
1278      * performance of a traditional mergesort when the input array is
1279      * randomly ordered.  If the input array is nearly sorted, the
1280      * implementation requires approximately n comparisons.  Temporary
1281      * storage requirements vary from a small constant for nearly sorted
1282      * input arrays to n/2 object references for randomly ordered input
1283      * arrays.
1284      *
1285      * &lt;p&gt;The implementation takes equal advantage of ascending and
1286      * descending order in its input array, and can take advantage of
1287      * ascending and descending order in different parts of the same
1288      * input array.  It is well-suited to merging two or more sorted arrays:
1289      * simply concatenate the arrays and sort the resulting array.
1290      *
1291      * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
1292      * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
1293      * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
1294      * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
1295      * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
1296      * January 1993.
1297      *
1298      * @param a the array to be sorted
1299      * @param fromIndex the index of the first element (inclusive) to be
1300      *        sorted
1301      * @param toIndex the index of the last element (exclusive) to be sorted
1302      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
1303      *         (optional) if the natural ordering of the array elements is
1304      *         found to violate the {@link Comparable} contract
1305      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
1306      *         {@code toIndex &gt; a.length}
1307      * @throws ClassCastException if the array contains elements that are
1308      *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
1309      *         integers).
1310      */
1311     public static void sort(Object[] a, int fromIndex, int toIndex) {
1312         rangeCheck(a.length, fromIndex, toIndex);
1313         if (LegacyMergeSort.userRequested)
1314             legacyMergeSort(a, fromIndex, toIndex);
1315         else
1316             ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
1317     }
1318 
1319     /** To be removed in a future release. */
1320     private static void legacyMergeSort(Object[] a,
1321                                         int fromIndex, int toIndex) {
1322         Object[] aux = copyOfRange(a, fromIndex, toIndex);
1323         mergeSort(aux, a, fromIndex, toIndex, -fromIndex);
1324     }
1325 
1326     /**
1327      * Tuning parameter: list size at or below which insertion sort will be
1328      * used in preference to mergesort.
1329      * To be removed in a future release.
1330      */
1331     private static final int INSERTIONSORT_THRESHOLD = 7;
1332 
1333     /**
1334      * Src is the source array that starts at index 0
1335      * Dest is the (possibly larger) array destination with a possible offset
1336      * low is the index in dest to start sorting
1337      * high is the end index in dest to end sorting
1338      * off is the offset to generate corresponding low, high in src
1339      * To be removed in a future release.
1340      */
1341     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
1342     private static void mergeSort(Object[] src,
1343                                   Object[] dest,
1344                                   int low,
1345                                   int high,
1346                                   int off) {
1347         int length = high - low;
1348 
1349         // Insertion sort on smallest arrays
1350         if (length &lt; INSERTIONSORT_THRESHOLD) {
1351             for (int i=low; i&lt;high; i++)
1352                 for (int j=i; j&gt;low &amp;&amp;
1353                          ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)
1354                     swap(dest, j, j-1);
1355             return;
1356         }
1357 
1358         // Recursively sort halves of dest into src
1359         int destLow  = low;
1360         int destHigh = high;
1361         low  += off;
1362         high += off;
1363         int mid = (low + high) &gt;&gt;&gt; 1;
1364         mergeSort(dest, src, low, mid, -off);
1365         mergeSort(dest, src, mid, high, -off);
1366 
1367         // If list is already sorted, just copy from src to dest.  This is an
1368         // optimization that results in faster sorts for nearly ordered lists.
1369         if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) {
1370             System.arraycopy(src, low, dest, destLow, length);
1371             return;
1372         }
1373 
1374         // Merge sorted halves (now in src) into dest
1375         for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {
1376             if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)
1377                 dest[i] = src[p++];
1378             else
1379                 dest[i] = src[q++];
1380         }
1381     }
1382 
1383     /**
1384      * Swaps x[a] with x[b].
1385      */
1386     private static void swap(Object[] x, int a, int b) {
1387         Object t = x[a];
1388         x[a] = x[b];
1389         x[b] = t;
1390     }
1391 
1392     /**
1393      * Sorts the specified array of objects according to the order induced by
1394      * the specified comparator.  All elements in the array must be
1395      * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
1396      * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
1397      * for any elements {@code e1} and {@code e2} in the array).
1398      *
1399      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1400      * not be reordered as a result of the sort.
1401      *
1402      * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
1403      * iterative mergesort that requires far fewer than n lg(n) comparisons
1404      * when the input array is partially sorted, while offering the
1405      * performance of a traditional mergesort when the input array is
1406      * randomly ordered.  If the input array is nearly sorted, the
1407      * implementation requires approximately n comparisons.  Temporary
1408      * storage requirements vary from a small constant for nearly sorted
1409      * input arrays to n/2 object references for randomly ordered input
1410      * arrays.
1411      *
1412      * &lt;p&gt;The implementation takes equal advantage of ascending and
1413      * descending order in its input array, and can take advantage of
1414      * ascending and descending order in different parts of the same
1415      * input array.  It is well-suited to merging two or more sorted arrays:
1416      * simply concatenate the arrays and sort the resulting array.
1417      *
1418      * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
1419      * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
1420      * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
1421      * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
1422      * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
1423      * January 1993.
1424      *
1425      * @param &lt;T&gt; the class of the objects to be sorted
1426      * @param a the array to be sorted
1427      * @param c the comparator to determine the order of the array.  A
1428      *        {@code null} value indicates that the elements&#39;
1429      *        {@linkplain Comparable natural ordering} should be used.
1430      * @throws ClassCastException if the array contains elements that are
1431      *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
1432      * @throws IllegalArgumentException (optional) if the comparator is
1433      *         found to violate the {@link Comparator} contract
1434      */
1435     public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {
1436         if (c == null) {
1437             sort(a);
1438         } else {
1439             if (LegacyMergeSort.userRequested)
1440                 legacyMergeSort(a, c);
1441             else
1442                 TimSort.sort(a, 0, a.length, c, null, 0, 0);
1443         }
1444     }
1445 
1446     /** To be removed in a future release. */
1447     private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) {
1448         T[] aux = a.clone();
1449         if (c==null)
1450             mergeSort(aux, a, 0, a.length, 0);
1451         else
1452             mergeSort(aux, a, 0, a.length, 0, c);
1453     }
1454 
1455     /**
1456      * Sorts the specified range of the specified array of objects according
1457      * to the order induced by the specified comparator.  The range to be
1458      * sorted extends from index {@code fromIndex}, inclusive, to index
1459      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
1460      * range to be sorted is empty.)  All elements in the range must be
1461      * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
1462      * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}
1463      * for any elements {@code e1} and {@code e2} in the range).
1464      *
1465      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
1466      * not be reordered as a result of the sort.
1467      *
1468      * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
1469      * iterative mergesort that requires far fewer than n lg(n) comparisons
1470      * when the input array is partially sorted, while offering the
1471      * performance of a traditional mergesort when the input array is
1472      * randomly ordered.  If the input array is nearly sorted, the
1473      * implementation requires approximately n comparisons.  Temporary
1474      * storage requirements vary from a small constant for nearly sorted
1475      * input arrays to n/2 object references for randomly ordered input
1476      * arrays.
1477      *
1478      * &lt;p&gt;The implementation takes equal advantage of ascending and
1479      * descending order in its input array, and can take advantage of
1480      * ascending and descending order in different parts of the same
1481      * input array.  It is well-suited to merging two or more sorted arrays:
1482      * simply concatenate the arrays and sort the resulting array.
1483      *
1484      * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
1485      * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
1486      * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
1487      * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
1488      * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
1489      * January 1993.
1490      *
1491      * @param &lt;T&gt; the class of the objects to be sorted
1492      * @param a the array to be sorted
1493      * @param fromIndex the index of the first element (inclusive) to be
1494      *        sorted
1495      * @param toIndex the index of the last element (exclusive) to be sorted
1496      * @param c the comparator to determine the order of the array.  A
1497      *        {@code null} value indicates that the elements&#39;
1498      *        {@linkplain Comparable natural ordering} should be used.
1499      * @throws ClassCastException if the array contains elements that are not
1500      *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.
1501      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex} or
1502      *         (optional) if the comparator is found to violate the
1503      *         {@link Comparator} contract
1504      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
1505      *         {@code toIndex &gt; a.length}
1506      */
1507     public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,
1508                                 Comparator&lt;? super T&gt; c) {
1509         if (c == null) {
1510             sort(a, fromIndex, toIndex);
1511         } else {
1512             rangeCheck(a.length, fromIndex, toIndex);
1513             if (LegacyMergeSort.userRequested)
1514                 legacyMergeSort(a, fromIndex, toIndex, c);
1515             else
1516                 TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
1517         }
1518     }
1519 
1520     /** To be removed in a future release. */
1521     private static &lt;T&gt; void legacyMergeSort(T[] a, int fromIndex, int toIndex,
1522                                             Comparator&lt;? super T&gt; c) {
1523         T[] aux = copyOfRange(a, fromIndex, toIndex);
1524         if (c==null)
1525             mergeSort(aux, a, fromIndex, toIndex, -fromIndex);
1526         else
1527             mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);
1528     }
1529 
1530     /**
1531      * Src is the source array that starts at index 0
1532      * Dest is the (possibly larger) array destination with a possible offset
1533      * low is the index in dest to start sorting
1534      * high is the end index in dest to end sorting
1535      * off is the offset into src corresponding to low in dest
1536      * To be removed in a future release.
1537      */
1538     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1539     private static void mergeSort(Object[] src,
1540                                   Object[] dest,
1541                                   int low, int high, int off,
1542                                   Comparator c) {
1543         int length = high - low;
1544 
1545         // Insertion sort on smallest arrays
1546         if (length &lt; INSERTIONSORT_THRESHOLD) {
1547             for (int i=low; i&lt;high; i++)
1548                 for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)
1549                     swap(dest, j, j-1);
1550             return;
1551         }
1552 
1553         // Recursively sort halves of dest into src
1554         int destLow  = low;
1555         int destHigh = high;
1556         low  += off;
1557         high += off;
1558         int mid = (low + high) &gt;&gt;&gt; 1;
1559         mergeSort(dest, src, low, mid, -off, c);
1560         mergeSort(dest, src, mid, high, -off, c);
1561 
1562         // If list is already sorted, just copy from src to dest.  This is an
1563         // optimization that results in faster sorts for nearly ordered lists.
1564         if (c.compare(src[mid-1], src[mid]) &lt;= 0) {
1565            System.arraycopy(src, low, dest, destLow, length);
1566            return;
1567         }
1568 
1569         // Merge sorted halves (now in src) into dest
1570         for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {
1571             if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)
1572                 dest[i] = src[p++];
1573             else
1574                 dest[i] = src[q++];
1575         }
1576     }
1577 
1578     // Parallel prefix
1579 
1580     /**
1581      * Cumulates, in parallel, each element of the given array in place,
1582      * using the supplied function. For example if the array initially
1583      * holds {@code [2, 1, 0, 3]} and the operation performs addition,
1584      * then upon return the array holds {@code [2, 3, 3, 6]}.
1585      * Parallel prefix computation is usually more efficient than
1586      * sequential loops for large arrays.
1587      *
1588      * @param &lt;T&gt; the class of the objects in the array
1589      * @param array the array, which is modified in-place by this method
1590      * @param op a side-effect-free, associative function to perform the
1591      * cumulation
1592      * @throws NullPointerException if the specified array or function is null
1593      * @since 1.8
1594      */
1595     public static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op) {
1596         Objects.requireNonNull(op);
1597         if (array.length &gt; 0)
1598             new ArrayPrefixHelpers.CumulateTask&lt;&gt;
1599                     (null, op, array, 0, array.length).invoke();
1600     }
1601 
1602     /**
1603      * Performs {@link #parallelPrefix(Object[], BinaryOperator)}
1604      * for the given subrange of the array.
1605      *
1606      * @param &lt;T&gt; the class of the objects in the array
1607      * @param array the array
1608      * @param fromIndex the index of the first element, inclusive
1609      * @param toIndex the index of the last element, exclusive
1610      * @param op a side-effect-free, associative function to perform the
1611      * cumulation
1612      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
1613      * @throws ArrayIndexOutOfBoundsException
1614      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
1615      * @throws NullPointerException if the specified array or function is null
1616      * @since 1.8
1617      */
1618     public static &lt;T&gt; void parallelPrefix(T[] array, int fromIndex,
1619                                           int toIndex, BinaryOperator&lt;T&gt; op) {
1620         Objects.requireNonNull(op);
1621         rangeCheck(array.length, fromIndex, toIndex);
1622         if (fromIndex &lt; toIndex)
1623             new ArrayPrefixHelpers.CumulateTask&lt;&gt;
1624                     (null, op, array, fromIndex, toIndex).invoke();
1625     }
1626 
1627     /**
1628      * Cumulates, in parallel, each element of the given array in place,
1629      * using the supplied function. For example if the array initially
1630      * holds {@code [2, 1, 0, 3]} and the operation performs addition,
1631      * then upon return the array holds {@code [2, 3, 3, 6]}.
1632      * Parallel prefix computation is usually more efficient than
1633      * sequential loops for large arrays.
1634      *
1635      * @param array the array, which is modified in-place by this method
1636      * @param op a side-effect-free, associative function to perform the
1637      * cumulation
1638      * @throws NullPointerException if the specified array or function is null
1639      * @since 1.8
1640      */
1641     public static void parallelPrefix(long[] array, LongBinaryOperator op) {
1642         Objects.requireNonNull(op);
1643         if (array.length &gt; 0)
1644             new ArrayPrefixHelpers.LongCumulateTask
1645                     (null, op, array, 0, array.length).invoke();
1646     }
1647 
1648     /**
1649      * Performs {@link #parallelPrefix(long[], LongBinaryOperator)}
1650      * for the given subrange of the array.
1651      *
1652      * @param array the array
1653      * @param fromIndex the index of the first element, inclusive
1654      * @param toIndex the index of the last element, exclusive
1655      * @param op a side-effect-free, associative function to perform the
1656      * cumulation
1657      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
1658      * @throws ArrayIndexOutOfBoundsException
1659      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
1660      * @throws NullPointerException if the specified array or function is null
1661      * @since 1.8
1662      */
1663     public static void parallelPrefix(long[] array, int fromIndex,
1664                                       int toIndex, LongBinaryOperator op) {
1665         Objects.requireNonNull(op);
1666         rangeCheck(array.length, fromIndex, toIndex);
1667         if (fromIndex &lt; toIndex)
1668             new ArrayPrefixHelpers.LongCumulateTask
1669                     (null, op, array, fromIndex, toIndex).invoke();
1670     }
1671 
1672     /**
1673      * Cumulates, in parallel, each element of the given array in place,
1674      * using the supplied function. For example if the array initially
1675      * holds {@code [2.0, 1.0, 0.0, 3.0]} and the operation performs addition,
1676      * then upon return the array holds {@code [2.0, 3.0, 3.0, 6.0]}.
1677      * Parallel prefix computation is usually more efficient than
1678      * sequential loops for large arrays.
1679      *
1680      * &lt;p&gt; Because floating-point operations may not be strictly associative,
1681      * the returned result may not be identical to the value that would be
1682      * obtained if the operation was performed sequentially.
1683      *
1684      * @param array the array, which is modified in-place by this method
1685      * @param op a side-effect-free function to perform the cumulation
1686      * @throws NullPointerException if the specified array or function is null
1687      * @since 1.8
1688      */
1689     public static void parallelPrefix(double[] array, DoubleBinaryOperator op) {
1690         Objects.requireNonNull(op);
1691         if (array.length &gt; 0)
1692             new ArrayPrefixHelpers.DoubleCumulateTask
1693                     (null, op, array, 0, array.length).invoke();
1694     }
1695 
1696     /**
1697      * Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}
1698      * for the given subrange of the array.
1699      *
1700      * @param array the array
1701      * @param fromIndex the index of the first element, inclusive
1702      * @param toIndex the index of the last element, exclusive
1703      * @param op a side-effect-free, associative function to perform the
1704      * cumulation
1705      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
1706      * @throws ArrayIndexOutOfBoundsException
1707      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
1708      * @throws NullPointerException if the specified array or function is null
1709      * @since 1.8
1710      */
1711     public static void parallelPrefix(double[] array, int fromIndex,
1712                                       int toIndex, DoubleBinaryOperator op) {
1713         Objects.requireNonNull(op);
1714         rangeCheck(array.length, fromIndex, toIndex);
1715         if (fromIndex &lt; toIndex)
1716             new ArrayPrefixHelpers.DoubleCumulateTask
1717                     (null, op, array, fromIndex, toIndex).invoke();
1718     }
1719 
1720     /**
1721      * Cumulates, in parallel, each element of the given array in place,
1722      * using the supplied function. For example if the array initially
1723      * holds {@code [2, 1, 0, 3]} and the operation performs addition,
1724      * then upon return the array holds {@code [2, 3, 3, 6]}.
1725      * Parallel prefix computation is usually more efficient than
1726      * sequential loops for large arrays.
1727      *
1728      * @param array the array, which is modified in-place by this method
1729      * @param op a side-effect-free, associative function to perform the
1730      * cumulation
1731      * @throws NullPointerException if the specified array or function is null
1732      * @since 1.8
1733      */
1734     public static void parallelPrefix(int[] array, IntBinaryOperator op) {
1735         Objects.requireNonNull(op);
1736         if (array.length &gt; 0)
1737             new ArrayPrefixHelpers.IntCumulateTask
1738                     (null, op, array, 0, array.length).invoke();
1739     }
1740 
1741     /**
1742      * Performs {@link #parallelPrefix(int[], IntBinaryOperator)}
1743      * for the given subrange of the array.
1744      *
1745      * @param array the array
1746      * @param fromIndex the index of the first element, inclusive
1747      * @param toIndex the index of the last element, exclusive
1748      * @param op a side-effect-free, associative function to perform the
1749      * cumulation
1750      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
1751      * @throws ArrayIndexOutOfBoundsException
1752      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
1753      * @throws NullPointerException if the specified array or function is null
1754      * @since 1.8
1755      */
1756     public static void parallelPrefix(int[] array, int fromIndex,
1757                                       int toIndex, IntBinaryOperator op) {
1758         Objects.requireNonNull(op);
1759         rangeCheck(array.length, fromIndex, toIndex);
1760         if (fromIndex &lt; toIndex)
1761             new ArrayPrefixHelpers.IntCumulateTask
1762                     (null, op, array, fromIndex, toIndex).invoke();
1763     }
1764 
1765     // Searching
1766 
1767     /**
1768      * Searches the specified array of longs for the specified value using the
1769      * binary search algorithm.  The array must be sorted (as
1770      * by the {@link #sort(long[])} method) prior to making this call.  If it
1771      * is not sorted, the results are undefined.  If the array contains
1772      * multiple elements with the specified value, there is no guarantee which
1773      * one will be found.
1774      *
1775      * @param a the array to be searched
1776      * @param key the value to be searched for
1777      * @return index of the search key, if it is contained in the array;
1778      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
1779      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
1780      *         key would be inserted into the array: the index of the first
1781      *         element greater than the key, or {@code a.length} if all
1782      *         elements in the array are less than the specified key.  Note
1783      *         that this guarantees that the return value will be &amp;gt;= 0 if
1784      *         and only if the key is found.
1785      */
1786     public static int binarySearch(long[] a, long key) {
1787         return binarySearch0(a, 0, a.length, key);
1788     }
1789 
1790     /**
1791      * Searches a range of
1792      * the specified array of longs for the specified value using the
1793      * binary search algorithm.
1794      * The range must be sorted (as
1795      * by the {@link #sort(long[], int, int)} method)
1796      * prior to making this call.  If it
1797      * is not sorted, the results are undefined.  If the range contains
1798      * multiple elements with the specified value, there is no guarantee which
1799      * one will be found.
1800      *
1801      * @param a the array to be searched
1802      * @param fromIndex the index of the first element (inclusive) to be
1803      *          searched
1804      * @param toIndex the index of the last element (exclusive) to be searched
1805      * @param key the value to be searched for
1806      * @return index of the search key, if it is contained in the array
1807      *         within the specified range;
1808      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
1809      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
1810      *         key would be inserted into the array: the index of the first
1811      *         element in the range greater than the key,
1812      *         or {@code toIndex} if all
1813      *         elements in the range are less than the specified key.  Note
1814      *         that this guarantees that the return value will be &amp;gt;= 0 if
1815      *         and only if the key is found.
1816      * @throws IllegalArgumentException
1817      *         if {@code fromIndex &gt; toIndex}
1818      * @throws ArrayIndexOutOfBoundsException
1819      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
1820      * @since 1.6
1821      */
1822     public static int binarySearch(long[] a, int fromIndex, int toIndex,
1823                                    long key) {
1824         rangeCheck(a.length, fromIndex, toIndex);
1825         return binarySearch0(a, fromIndex, toIndex, key);
1826     }
1827 
1828     // Like public version, but without range checks.
1829     private static int binarySearch0(long[] a, int fromIndex, int toIndex,
1830                                      long key) {
1831         int low = fromIndex;
1832         int high = toIndex - 1;
1833 
1834         while (low &lt;= high) {
1835             int mid = (low + high) &gt;&gt;&gt; 1;
1836             long midVal = a[mid];
1837 
1838             if (midVal &lt; key)
1839                 low = mid + 1;
1840             else if (midVal &gt; key)
1841                 high = mid - 1;
1842             else
1843                 return mid; // key found
1844         }
1845         return -(low + 1);  // key not found.
1846     }
1847 
1848     /**
1849      * Searches the specified array of ints for the specified value using the
1850      * binary search algorithm.  The array must be sorted (as
1851      * by the {@link #sort(int[])} method) prior to making this call.  If it
1852      * is not sorted, the results are undefined.  If the array contains
1853      * multiple elements with the specified value, there is no guarantee which
1854      * one will be found.
1855      *
1856      * @param a the array to be searched
1857      * @param key the value to be searched for
1858      * @return index of the search key, if it is contained in the array;
1859      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
1860      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
1861      *         key would be inserted into the array: the index of the first
1862      *         element greater than the key, or {@code a.length} if all
1863      *         elements in the array are less than the specified key.  Note
1864      *         that this guarantees that the return value will be &amp;gt;= 0 if
1865      *         and only if the key is found.
1866      */
1867     public static int binarySearch(int[] a, int key) {
1868         return binarySearch0(a, 0, a.length, key);
1869     }
1870 
1871     /**
1872      * Searches a range of
1873      * the specified array of ints for the specified value using the
1874      * binary search algorithm.
1875      * The range must be sorted (as
1876      * by the {@link #sort(int[], int, int)} method)
1877      * prior to making this call.  If it
1878      * is not sorted, the results are undefined.  If the range contains
1879      * multiple elements with the specified value, there is no guarantee which
1880      * one will be found.
1881      *
1882      * @param a the array to be searched
1883      * @param fromIndex the index of the first element (inclusive) to be
1884      *          searched
1885      * @param toIndex the index of the last element (exclusive) to be searched
1886      * @param key the value to be searched for
1887      * @return index of the search key, if it is contained in the array
1888      *         within the specified range;
1889      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
1890      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
1891      *         key would be inserted into the array: the index of the first
1892      *         element in the range greater than the key,
1893      *         or {@code toIndex} if all
1894      *         elements in the range are less than the specified key.  Note
1895      *         that this guarantees that the return value will be &amp;gt;= 0 if
1896      *         and only if the key is found.
1897      * @throws IllegalArgumentException
1898      *         if {@code fromIndex &gt; toIndex}
1899      * @throws ArrayIndexOutOfBoundsException
1900      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
1901      * @since 1.6
1902      */
1903     public static int binarySearch(int[] a, int fromIndex, int toIndex,
1904                                    int key) {
1905         rangeCheck(a.length, fromIndex, toIndex);
1906         return binarySearch0(a, fromIndex, toIndex, key);
1907     }
1908 
1909     // Like public version, but without range checks.
1910     private static int binarySearch0(int[] a, int fromIndex, int toIndex,
1911                                      int key) {
1912         int low = fromIndex;
1913         int high = toIndex - 1;
1914 
1915         while (low &lt;= high) {
1916             int mid = (low + high) &gt;&gt;&gt; 1;
1917             int midVal = a[mid];
1918 
1919             if (midVal &lt; key)
1920                 low = mid + 1;
1921             else if (midVal &gt; key)
1922                 high = mid - 1;
1923             else
1924                 return mid; // key found
1925         }
1926         return -(low + 1);  // key not found.
1927     }
1928 
1929     /**
1930      * Searches the specified array of shorts for the specified value using
1931      * the binary search algorithm.  The array must be sorted
1932      * (as by the {@link #sort(short[])} method) prior to making this call.  If
1933      * it is not sorted, the results are undefined.  If the array contains
1934      * multiple elements with the specified value, there is no guarantee which
1935      * one will be found.
1936      *
1937      * @param a the array to be searched
1938      * @param key the value to be searched for
1939      * @return index of the search key, if it is contained in the array;
1940      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
1941      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
1942      *         key would be inserted into the array: the index of the first
1943      *         element greater than the key, or {@code a.length} if all
1944      *         elements in the array are less than the specified key.  Note
1945      *         that this guarantees that the return value will be &amp;gt;= 0 if
1946      *         and only if the key is found.
1947      */
1948     public static int binarySearch(short[] a, short key) {
1949         return binarySearch0(a, 0, a.length, key);
1950     }
1951 
1952     /**
1953      * Searches a range of
1954      * the specified array of shorts for the specified value using
1955      * the binary search algorithm.
1956      * The range must be sorted
1957      * (as by the {@link #sort(short[], int, int)} method)
1958      * prior to making this call.  If
1959      * it is not sorted, the results are undefined.  If the range contains
1960      * multiple elements with the specified value, there is no guarantee which
1961      * one will be found.
1962      *
1963      * @param a the array to be searched
1964      * @param fromIndex the index of the first element (inclusive) to be
1965      *          searched
1966      * @param toIndex the index of the last element (exclusive) to be searched
1967      * @param key the value to be searched for
1968      * @return index of the search key, if it is contained in the array
1969      *         within the specified range;
1970      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
1971      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
1972      *         key would be inserted into the array: the index of the first
1973      *         element in the range greater than the key,
1974      *         or {@code toIndex} if all
1975      *         elements in the range are less than the specified key.  Note
1976      *         that this guarantees that the return value will be &amp;gt;= 0 if
1977      *         and only if the key is found.
1978      * @throws IllegalArgumentException
1979      *         if {@code fromIndex &gt; toIndex}
1980      * @throws ArrayIndexOutOfBoundsException
1981      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
1982      * @since 1.6
1983      */
1984     public static int binarySearch(short[] a, int fromIndex, int toIndex,
1985                                    short key) {
1986         rangeCheck(a.length, fromIndex, toIndex);
1987         return binarySearch0(a, fromIndex, toIndex, key);
1988     }
1989 
1990     // Like public version, but without range checks.
1991     private static int binarySearch0(short[] a, int fromIndex, int toIndex,
1992                                      short key) {
1993         int low = fromIndex;
1994         int high = toIndex - 1;
1995 
1996         while (low &lt;= high) {
1997             int mid = (low + high) &gt;&gt;&gt; 1;
1998             short midVal = a[mid];
1999 
2000             if (midVal &lt; key)
2001                 low = mid + 1;
2002             else if (midVal &gt; key)
2003                 high = mid - 1;
2004             else
2005                 return mid; // key found
2006         }
2007         return -(low + 1);  // key not found.
2008     }
2009 
2010     /**
2011      * Searches the specified array of chars for the specified value using the
2012      * binary search algorithm.  The array must be sorted (as
2013      * by the {@link #sort(char[])} method) prior to making this call.  If it
2014      * is not sorted, the results are undefined.  If the array contains
2015      * multiple elements with the specified value, there is no guarantee which
2016      * one will be found.
2017      *
2018      * @param a the array to be searched
2019      * @param key the value to be searched for
2020      * @return index of the search key, if it is contained in the array;
2021      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2022      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2023      *         key would be inserted into the array: the index of the first
2024      *         element greater than the key, or {@code a.length} if all
2025      *         elements in the array are less than the specified key.  Note
2026      *         that this guarantees that the return value will be &amp;gt;= 0 if
2027      *         and only if the key is found.
2028      */
2029     public static int binarySearch(char[] a, char key) {
2030         return binarySearch0(a, 0, a.length, key);
2031     }
2032 
2033     /**
2034      * Searches a range of
2035      * the specified array of chars for the specified value using the
2036      * binary search algorithm.
2037      * The range must be sorted (as
2038      * by the {@link #sort(char[], int, int)} method)
2039      * prior to making this call.  If it
2040      * is not sorted, the results are undefined.  If the range contains
2041      * multiple elements with the specified value, there is no guarantee which
2042      * one will be found.
2043      *
2044      * @param a the array to be searched
2045      * @param fromIndex the index of the first element (inclusive) to be
2046      *          searched
2047      * @param toIndex the index of the last element (exclusive) to be searched
2048      * @param key the value to be searched for
2049      * @return index of the search key, if it is contained in the array
2050      *         within the specified range;
2051      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2052      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2053      *         key would be inserted into the array: the index of the first
2054      *         element in the range greater than the key,
2055      *         or {@code toIndex} if all
2056      *         elements in the range are less than the specified key.  Note
2057      *         that this guarantees that the return value will be &amp;gt;= 0 if
2058      *         and only if the key is found.
2059      * @throws IllegalArgumentException
2060      *         if {@code fromIndex &gt; toIndex}
2061      * @throws ArrayIndexOutOfBoundsException
2062      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
2063      * @since 1.6
2064      */
2065     public static int binarySearch(char[] a, int fromIndex, int toIndex,
2066                                    char key) {
2067         rangeCheck(a.length, fromIndex, toIndex);
2068         return binarySearch0(a, fromIndex, toIndex, key);
2069     }
2070 
2071     // Like public version, but without range checks.
2072     private static int binarySearch0(char[] a, int fromIndex, int toIndex,
2073                                      char key) {
2074         int low = fromIndex;
2075         int high = toIndex - 1;
2076 
2077         while (low &lt;= high) {
2078             int mid = (low + high) &gt;&gt;&gt; 1;
2079             char midVal = a[mid];
2080 
2081             if (midVal &lt; key)
2082                 low = mid + 1;
2083             else if (midVal &gt; key)
2084                 high = mid - 1;
2085             else
2086                 return mid; // key found
2087         }
2088         return -(low + 1);  // key not found.
2089     }
2090 
2091     /**
2092      * Searches the specified array of bytes for the specified value using the
2093      * binary search algorithm.  The array must be sorted (as
2094      * by the {@link #sort(byte[])} method) prior to making this call.  If it
2095      * is not sorted, the results are undefined.  If the array contains
2096      * multiple elements with the specified value, there is no guarantee which
2097      * one will be found.
2098      *
2099      * @param a the array to be searched
2100      * @param key the value to be searched for
2101      * @return index of the search key, if it is contained in the array;
2102      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2103      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2104      *         key would be inserted into the array: the index of the first
2105      *         element greater than the key, or {@code a.length} if all
2106      *         elements in the array are less than the specified key.  Note
2107      *         that this guarantees that the return value will be &amp;gt;= 0 if
2108      *         and only if the key is found.
2109      */
2110     public static int binarySearch(byte[] a, byte key) {
2111         return binarySearch0(a, 0, a.length, key);
2112     }
2113 
2114     /**
2115      * Searches a range of
2116      * the specified array of bytes for the specified value using the
2117      * binary search algorithm.
2118      * The range must be sorted (as
2119      * by the {@link #sort(byte[], int, int)} method)
2120      * prior to making this call.  If it
2121      * is not sorted, the results are undefined.  If the range contains
2122      * multiple elements with the specified value, there is no guarantee which
2123      * one will be found.
2124      *
2125      * @param a the array to be searched
2126      * @param fromIndex the index of the first element (inclusive) to be
2127      *          searched
2128      * @param toIndex the index of the last element (exclusive) to be searched
2129      * @param key the value to be searched for
2130      * @return index of the search key, if it is contained in the array
2131      *         within the specified range;
2132      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2133      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2134      *         key would be inserted into the array: the index of the first
2135      *         element in the range greater than the key,
2136      *         or {@code toIndex} if all
2137      *         elements in the range are less than the specified key.  Note
2138      *         that this guarantees that the return value will be &amp;gt;= 0 if
2139      *         and only if the key is found.
2140      * @throws IllegalArgumentException
2141      *         if {@code fromIndex &gt; toIndex}
2142      * @throws ArrayIndexOutOfBoundsException
2143      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
2144      * @since 1.6
2145      */
2146     public static int binarySearch(byte[] a, int fromIndex, int toIndex,
2147                                    byte key) {
2148         rangeCheck(a.length, fromIndex, toIndex);
2149         return binarySearch0(a, fromIndex, toIndex, key);
2150     }
2151 
2152     // Like public version, but without range checks.
2153     private static int binarySearch0(byte[] a, int fromIndex, int toIndex,
2154                                      byte key) {
2155         int low = fromIndex;
2156         int high = toIndex - 1;
2157 
2158         while (low &lt;= high) {
2159             int mid = (low + high) &gt;&gt;&gt; 1;
2160             byte midVal = a[mid];
2161 
2162             if (midVal &lt; key)
2163                 low = mid + 1;
2164             else if (midVal &gt; key)
2165                 high = mid - 1;
2166             else
2167                 return mid; // key found
2168         }
2169         return -(low + 1);  // key not found.
2170     }
2171 
2172     /**
2173      * Searches the specified array of doubles for the specified value using
2174      * the binary search algorithm.  The array must be sorted
2175      * (as by the {@link #sort(double[])} method) prior to making this call.
2176      * If it is not sorted, the results are undefined.  If the array contains
2177      * multiple elements with the specified value, there is no guarantee which
2178      * one will be found.  This method considers all NaN values to be
2179      * equivalent and equal.
2180      *
2181      * @param a the array to be searched
2182      * @param key the value to be searched for
2183      * @return index of the search key, if it is contained in the array;
2184      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2185      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2186      *         key would be inserted into the array: the index of the first
2187      *         element greater than the key, or {@code a.length} if all
2188      *         elements in the array are less than the specified key.  Note
2189      *         that this guarantees that the return value will be &amp;gt;= 0 if
2190      *         and only if the key is found.
2191      */
2192     public static int binarySearch(double[] a, double key) {
2193         return binarySearch0(a, 0, a.length, key);
2194     }
2195 
2196     /**
2197      * Searches a range of
2198      * the specified array of doubles for the specified value using
2199      * the binary search algorithm.
2200      * The range must be sorted
2201      * (as by the {@link #sort(double[], int, int)} method)
2202      * prior to making this call.
2203      * If it is not sorted, the results are undefined.  If the range contains
2204      * multiple elements with the specified value, there is no guarantee which
2205      * one will be found.  This method considers all NaN values to be
2206      * equivalent and equal.
2207      *
2208      * @param a the array to be searched
2209      * @param fromIndex the index of the first element (inclusive) to be
2210      *          searched
2211      * @param toIndex the index of the last element (exclusive) to be searched
2212      * @param key the value to be searched for
2213      * @return index of the search key, if it is contained in the array
2214      *         within the specified range;
2215      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2216      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2217      *         key would be inserted into the array: the index of the first
2218      *         element in the range greater than the key,
2219      *         or {@code toIndex} if all
2220      *         elements in the range are less than the specified key.  Note
2221      *         that this guarantees that the return value will be &amp;gt;= 0 if
2222      *         and only if the key is found.
2223      * @throws IllegalArgumentException
2224      *         if {@code fromIndex &gt; toIndex}
2225      * @throws ArrayIndexOutOfBoundsException
2226      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
2227      * @since 1.6
2228      */
2229     public static int binarySearch(double[] a, int fromIndex, int toIndex,
2230                                    double key) {
2231         rangeCheck(a.length, fromIndex, toIndex);
2232         return binarySearch0(a, fromIndex, toIndex, key);
2233     }
2234 
2235     // Like public version, but without range checks.
2236     private static int binarySearch0(double[] a, int fromIndex, int toIndex,
2237                                      double key) {
2238         int low = fromIndex;
2239         int high = toIndex - 1;
2240 
2241         while (low &lt;= high) {
2242             int mid = (low + high) &gt;&gt;&gt; 1;
2243             double midVal = a[mid];
2244 
2245             if (midVal &lt; key)
2246                 low = mid + 1;  // Neither val is NaN, thisVal is smaller
2247             else if (midVal &gt; key)
2248                 high = mid - 1; // Neither val is NaN, thisVal is larger
2249             else {
2250                 long midBits = Double.doubleToLongBits(midVal);
2251                 long keyBits = Double.doubleToLongBits(key);
2252                 if (midBits == keyBits)     // Values are equal
2253                     return mid;             // Key found
2254                 else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)
2255                     low = mid + 1;
2256                 else                        // (0.0, -0.0) or (NaN, !NaN)
2257                     high = mid - 1;
2258             }
2259         }
2260         return -(low + 1);  // key not found.
2261     }
2262 
2263     /**
2264      * Searches the specified array of floats for the specified value using
2265      * the binary search algorithm. The array must be sorted
2266      * (as by the {@link #sort(float[])} method) prior to making this call. If
2267      * it is not sorted, the results are undefined. If the array contains
2268      * multiple elements with the specified value, there is no guarantee which
2269      * one will be found. This method considers all NaN values to be
2270      * equivalent and equal.
2271      *
2272      * @param a the array to be searched
2273      * @param key the value to be searched for
2274      * @return index of the search key, if it is contained in the array;
2275      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;. The
2276      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2277      *         key would be inserted into the array: the index of the first
2278      *         element greater than the key, or {@code a.length} if all
2279      *         elements in the array are less than the specified key. Note
2280      *         that this guarantees that the return value will be &amp;gt;= 0 if
2281      *         and only if the key is found.
2282      */
2283     public static int binarySearch(float[] a, float key) {
2284         return binarySearch0(a, 0, a.length, key);
2285     }
2286 
2287     /**
2288      * Searches a range of
2289      * the specified array of floats for the specified value using
2290      * the binary search algorithm.
2291      * The range must be sorted
2292      * (as by the {@link #sort(float[], int, int)} method)
2293      * prior to making this call. If
2294      * it is not sorted, the results are undefined. If the range contains
2295      * multiple elements with the specified value, there is no guarantee which
2296      * one will be found. This method considers all NaN values to be
2297      * equivalent and equal.
2298      *
2299      * @param a the array to be searched
2300      * @param fromIndex the index of the first element (inclusive) to be
2301      *          searched
2302      * @param toIndex the index of the last element (exclusive) to be searched
2303      * @param key the value to be searched for
2304      * @return index of the search key, if it is contained in the array
2305      *         within the specified range;
2306      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;. The
2307      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2308      *         key would be inserted into the array: the index of the first
2309      *         element in the range greater than the key,
2310      *         or {@code toIndex} if all
2311      *         elements in the range are less than the specified key. Note
2312      *         that this guarantees that the return value will be &amp;gt;= 0 if
2313      *         and only if the key is found.
2314      * @throws IllegalArgumentException
2315      *         if {@code fromIndex &gt; toIndex}
2316      * @throws ArrayIndexOutOfBoundsException
2317      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
2318      * @since 1.6
2319      */
2320     public static int binarySearch(float[] a, int fromIndex, int toIndex,
2321                                    float key) {
2322         rangeCheck(a.length, fromIndex, toIndex);
2323         return binarySearch0(a, fromIndex, toIndex, key);
2324     }
2325 
2326     // Like public version, but without range checks.
2327     private static int binarySearch0(float[] a, int fromIndex, int toIndex,
2328                                      float key) {
2329         int low = fromIndex;
2330         int high = toIndex - 1;
2331 
2332         while (low &lt;= high) {
2333             int mid = (low + high) &gt;&gt;&gt; 1;
2334             float midVal = a[mid];
2335 
2336             if (midVal &lt; key)
2337                 low = mid + 1;  // Neither val is NaN, thisVal is smaller
2338             else if (midVal &gt; key)
2339                 high = mid - 1; // Neither val is NaN, thisVal is larger
2340             else {
2341                 int midBits = Float.floatToIntBits(midVal);
2342                 int keyBits = Float.floatToIntBits(key);
2343                 if (midBits == keyBits)     // Values are equal
2344                     return mid;             // Key found
2345                 else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)
2346                     low = mid + 1;
2347                 else                        // (0.0, -0.0) or (NaN, !NaN)
2348                     high = mid - 1;
2349             }
2350         }
2351         return -(low + 1);  // key not found.
2352     }
2353 
2354     /**
2355      * Searches the specified array for the specified object using the binary
2356      * search algorithm. The array must be sorted into ascending order
2357      * according to the
2358      * {@linkplain Comparable natural ordering}
2359      * of its elements (as by the
2360      * {@link #sort(Object[])} method) prior to making this call.
2361      * If it is not sorted, the results are undefined.
2362      * (If the array contains elements that are not mutually comparable (for
2363      * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
2364      * to the natural ordering of its elements, hence results are undefined.)
2365      * If the array contains multiple
2366      * elements equal to the specified object, there is no guarantee which
2367      * one will be found.
2368      *
2369      * @param a the array to be searched
2370      * @param key the value to be searched for
2371      * @return index of the search key, if it is contained in the array;
2372      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2373      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2374      *         key would be inserted into the array: the index of the first
2375      *         element greater than the key, or {@code a.length} if all
2376      *         elements in the array are less than the specified key.  Note
2377      *         that this guarantees that the return value will be &amp;gt;= 0 if
2378      *         and only if the key is found.
2379      * @throws ClassCastException if the search key is not comparable to the
2380      *         elements of the array.
2381      */
2382     public static int binarySearch(Object[] a, Object key) {
2383         return binarySearch0(a, 0, a.length, key);
2384     }
2385 
2386     /**
2387      * Searches a range of
2388      * the specified array for the specified object using the binary
2389      * search algorithm.
2390      * The range must be sorted into ascending order
2391      * according to the
2392      * {@linkplain Comparable natural ordering}
2393      * of its elements (as by the
2394      * {@link #sort(Object[], int, int)} method) prior to making this
2395      * call.  If it is not sorted, the results are undefined.
2396      * (If the range contains elements that are not mutually comparable (for
2397      * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
2398      * to the natural ordering of its elements, hence results are undefined.)
2399      * If the range contains multiple
2400      * elements equal to the specified object, there is no guarantee which
2401      * one will be found.
2402      *
2403      * @param a the array to be searched
2404      * @param fromIndex the index of the first element (inclusive) to be
2405      *          searched
2406      * @param toIndex the index of the last element (exclusive) to be searched
2407      * @param key the value to be searched for
2408      * @return index of the search key, if it is contained in the array
2409      *         within the specified range;
2410      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2411      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2412      *         key would be inserted into the array: the index of the first
2413      *         element in the range greater than the key,
2414      *         or {@code toIndex} if all
2415      *         elements in the range are less than the specified key.  Note
2416      *         that this guarantees that the return value will be &amp;gt;= 0 if
2417      *         and only if the key is found.
2418      * @throws ClassCastException if the search key is not comparable to the
2419      *         elements of the array within the specified range.
2420      * @throws IllegalArgumentException
2421      *         if {@code fromIndex &gt; toIndex}
2422      * @throws ArrayIndexOutOfBoundsException
2423      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
2424      * @since 1.6
2425      */
2426     public static int binarySearch(Object[] a, int fromIndex, int toIndex,
2427                                    Object key) {
2428         rangeCheck(a.length, fromIndex, toIndex);
2429         return binarySearch0(a, fromIndex, toIndex, key);
2430     }
2431 
2432     // Like public version, but without range checks.
2433     private static int binarySearch0(Object[] a, int fromIndex, int toIndex,
2434                                      Object key) {
2435         int low = fromIndex;
2436         int high = toIndex - 1;
2437 
2438         while (low &lt;= high) {
2439             int mid = (low + high) &gt;&gt;&gt; 1;
2440             @SuppressWarnings(&quot;rawtypes&quot;)
2441             Comparable midVal = (Comparable)a[mid];
2442             @SuppressWarnings(&quot;unchecked&quot;)
2443             int cmp = midVal.compareTo(key);
2444 
2445             if (cmp &lt; 0)
2446                 low = mid + 1;
2447             else if (cmp &gt; 0)
2448                 high = mid - 1;
2449             else
2450                 return mid; // key found
2451         }
2452         return -(low + 1);  // key not found.
2453     }
2454 
2455     /**
2456      * Searches the specified array for the specified object using the binary
2457      * search algorithm.  The array must be sorted into ascending order
2458      * according to the specified comparator (as by the
2459      * {@link #sort(Object[], Comparator) sort(T[], Comparator)}
2460      * method) prior to making this call.  If it is
2461      * not sorted, the results are undefined.
2462      * If the array contains multiple
2463      * elements equal to the specified object, there is no guarantee which one
2464      * will be found.
2465      *
2466      * @param &lt;T&gt; the class of the objects in the array
2467      * @param a the array to be searched
2468      * @param key the value to be searched for
2469      * @param c the comparator by which the array is ordered.  A
2470      *        {@code null} value indicates that the elements&#39;
2471      *        {@linkplain Comparable natural ordering} should be used.
2472      * @return index of the search key, if it is contained in the array;
2473      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2474      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2475      *         key would be inserted into the array: the index of the first
2476      *         element greater than the key, or {@code a.length} if all
2477      *         elements in the array are less than the specified key.  Note
2478      *         that this guarantees that the return value will be &amp;gt;= 0 if
2479      *         and only if the key is found.
2480      * @throws ClassCastException if the array contains elements that are not
2481      *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
2482      *         or the search key is not comparable to the
2483      *         elements of the array using this comparator.
2484      */
2485     public static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) {
2486         return binarySearch0(a, 0, a.length, key, c);
2487     }
2488 
2489     /**
2490      * Searches a range of
2491      * the specified array for the specified object using the binary
2492      * search algorithm.
2493      * The range must be sorted into ascending order
2494      * according to the specified comparator (as by the
2495      * {@link #sort(Object[], int, int, Comparator)
2496      * sort(T[], int, int, Comparator)}
2497      * method) prior to making this call.
2498      * If it is not sorted, the results are undefined.
2499      * If the range contains multiple elements equal to the specified object,
2500      * there is no guarantee which one will be found.
2501      *
2502      * @param &lt;T&gt; the class of the objects in the array
2503      * @param a the array to be searched
2504      * @param fromIndex the index of the first element (inclusive) to be
2505      *          searched
2506      * @param toIndex the index of the last element (exclusive) to be searched
2507      * @param key the value to be searched for
2508      * @param c the comparator by which the array is ordered.  A
2509      *        {@code null} value indicates that the elements&#39;
2510      *        {@linkplain Comparable natural ordering} should be used.
2511      * @return index of the search key, if it is contained in the array
2512      *         within the specified range;
2513      *         otherwise, &lt;code&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/code&gt;.  The
2514      *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
2515      *         key would be inserted into the array: the index of the first
2516      *         element in the range greater than the key,
2517      *         or {@code toIndex} if all
2518      *         elements in the range are less than the specified key.  Note
2519      *         that this guarantees that the return value will be &amp;gt;= 0 if
2520      *         and only if the key is found.
2521      * @throws ClassCastException if the range contains elements that are not
2522      *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
2523      *         or the search key is not comparable to the
2524      *         elements in the range using this comparator.
2525      * @throws IllegalArgumentException
2526      *         if {@code fromIndex &gt; toIndex}
2527      * @throws ArrayIndexOutOfBoundsException
2528      *         if {@code fromIndex &lt; 0 or toIndex &gt; a.length}
2529      * @since 1.6
2530      */
2531     public static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex,
2532                                        T key, Comparator&lt;? super T&gt; c) {
2533         rangeCheck(a.length, fromIndex, toIndex);
2534         return binarySearch0(a, fromIndex, toIndex, key, c);
2535     }
2536 
2537     // Like public version, but without range checks.
2538     private static &lt;T&gt; int binarySearch0(T[] a, int fromIndex, int toIndex,
2539                                          T key, Comparator&lt;? super T&gt; c) {
2540         if (c == null) {
2541             return binarySearch0(a, fromIndex, toIndex, key);
2542         }
2543         int low = fromIndex;
2544         int high = toIndex - 1;
2545 
2546         while (low &lt;= high) {
2547             int mid = (low + high) &gt;&gt;&gt; 1;
2548             T midVal = a[mid];
2549             int cmp = c.compare(midVal, key);
2550             if (cmp &lt; 0)
2551                 low = mid + 1;
2552             else if (cmp &gt; 0)
2553                 high = mid - 1;
2554             else
2555                 return mid; // key found
2556         }
2557         return -(low + 1);  // key not found.
2558     }
2559 
2560     // Equality Testing
2561 
2562     /**
2563      * Returns {@code true} if the two specified arrays of longs are
2564      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2565      * arrays contain the same number of elements, and all corresponding pairs
2566      * of elements in the two arrays are equal.  In other words, two arrays
2567      * are equal if they contain the same elements in the same order.  Also,
2568      * two array references are considered equal if both are {@code null}.
2569      *
2570      * @param a one array to be tested for equality
2571      * @param a2 the other array to be tested for equality
2572      * @return {@code true} if the two arrays are equal
2573      */
2574     public static boolean equals(long[] a, long[] a2) {
2575         if (a==a2)
2576             return true;
2577         if (a==null || a2==null)
2578             return false;
2579 
2580         int length = a.length;
2581         if (a2.length != length)
2582             return false;
2583 
2584         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2585     }
2586 
2587     /**
2588      * Returns true if the two specified arrays of longs, over the specified
2589      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2590      *
2591      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2592      * each range is the same, and all corresponding pairs of elements over the
2593      * specified ranges in the two arrays are equal.  In other words, two arrays
2594      * are equal if they contain, over the specified ranges, the same elements
2595      * in the same order.
2596      *
2597      * @param a the first array to be tested for equality
2598      * @param aFromIndex the index (inclusive) of the first element in the
2599      *                   first array to be tested
2600      * @param aToIndex the index (exclusive) of the last element in the
2601      *                 first array to be tested
2602      * @param b the second array to be tested fro equality
2603      * @param bFromIndex the index (inclusive) of the first element in the
2604      *                   second array to be tested
2605      * @param bToIndex the index (exclusive) of the last element in the
2606      *                 second array to be tested
2607      * @return {@code true} if the two arrays, over the specified ranges, are
2608      *         equal
2609      * @throws IllegalArgumentException
2610      *         if {@code aFromIndex &gt; aToIndex} or
2611      *         if {@code bFromIndex &gt; bToIndex}
2612      * @throws ArrayIndexOutOfBoundsException
2613      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2614      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2615      * @throws NullPointerException
2616      *         if either array is {@code null}
2617      * @since 9
2618      */
2619     public static boolean equals(long[] a, int aFromIndex, int aToIndex,
2620                                  long[] b, int bFromIndex, int bToIndex) {
2621         rangeCheck(a.length, aFromIndex, aToIndex);
2622         rangeCheck(b.length, bFromIndex, bToIndex);
2623 
2624         int aLength = aToIndex - aFromIndex;
2625         int bLength = bToIndex - bFromIndex;
2626         if (aLength != bLength)
2627             return false;
2628 
2629         return ArraysSupport.mismatch(a, aFromIndex,
2630                                       b, bFromIndex,
2631                                       aLength) &lt; 0;
2632     }
2633 
2634     /**
2635      * Returns {@code true} if the two specified arrays of ints are
2636      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2637      * arrays contain the same number of elements, and all corresponding pairs
2638      * of elements in the two arrays are equal.  In other words, two arrays
2639      * are equal if they contain the same elements in the same order.  Also,
2640      * two array references are considered equal if both are {@code null}.
2641      *
2642      * @param a one array to be tested for equality
2643      * @param a2 the other array to be tested for equality
2644      * @return {@code true} if the two arrays are equal
2645      */
2646     public static boolean equals(int[] a, int[] a2) {
2647         if (a==a2)
2648             return true;
2649         if (a==null || a2==null)
2650             return false;
2651 
2652         int length = a.length;
2653         if (a2.length != length)
2654             return false;
2655 
2656         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2657     }
2658 
2659     /**
2660      * Returns true if the two specified arrays of ints, over the specified
2661      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2662      *
2663      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2664      * each range is the same, and all corresponding pairs of elements over the
2665      * specified ranges in the two arrays are equal.  In other words, two arrays
2666      * are equal if they contain, over the specified ranges, the same elements
2667      * in the same order.
2668      *
2669      * @param a the first array to be tested for equality
2670      * @param aFromIndex the index (inclusive) of the first element in the
2671      *                   first array to be tested
2672      * @param aToIndex the index (exclusive) of the last element in the
2673      *                 first array to be tested
2674      * @param b the second array to be tested fro equality
2675      * @param bFromIndex the index (inclusive) of the first element in the
2676      *                   second array to be tested
2677      * @param bToIndex the index (exclusive) of the last element in the
2678      *                 second array to be tested
2679      * @return {@code true} if the two arrays, over the specified ranges, are
2680      *         equal
2681      * @throws IllegalArgumentException
2682      *         if {@code aFromIndex &gt; aToIndex} or
2683      *         if {@code bFromIndex &gt; bToIndex}
2684      * @throws ArrayIndexOutOfBoundsException
2685      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2686      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2687      * @throws NullPointerException
2688      *         if either array is {@code null}
2689      * @since 9
2690      */
2691     public static boolean equals(int[] a, int aFromIndex, int aToIndex,
2692                                  int[] b, int bFromIndex, int bToIndex) {
2693         rangeCheck(a.length, aFromIndex, aToIndex);
2694         rangeCheck(b.length, bFromIndex, bToIndex);
2695 
2696         int aLength = aToIndex - aFromIndex;
2697         int bLength = bToIndex - bFromIndex;
2698         if (aLength != bLength)
2699             return false;
2700 
2701         return ArraysSupport.mismatch(a, aFromIndex,
2702                                       b, bFromIndex,
2703                                       aLength) &lt; 0;
2704     }
2705 
2706     /**
2707      * Returns {@code true} if the two specified arrays of shorts are
2708      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2709      * arrays contain the same number of elements, and all corresponding pairs
2710      * of elements in the two arrays are equal.  In other words, two arrays
2711      * are equal if they contain the same elements in the same order.  Also,
2712      * two array references are considered equal if both are {@code null}.
2713      *
2714      * @param a one array to be tested for equality
2715      * @param a2 the other array to be tested for equality
2716      * @return {@code true} if the two arrays are equal
2717      */
2718     public static boolean equals(short[] a, short a2[]) {
2719         if (a==a2)
2720             return true;
2721         if (a==null || a2==null)
2722             return false;
2723 
2724         int length = a.length;
2725         if (a2.length != length)
2726             return false;
2727 
2728         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2729     }
2730 
2731     /**
2732      * Returns true if the two specified arrays of shorts, over the specified
2733      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2734      *
2735      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2736      * each range is the same, and all corresponding pairs of elements over the
2737      * specified ranges in the two arrays are equal.  In other words, two arrays
2738      * are equal if they contain, over the specified ranges, the same elements
2739      * in the same order.
2740      *
2741      * @param a the first array to be tested for equality
2742      * @param aFromIndex the index (inclusive) of the first element in the
2743      *                   first array to be tested
2744      * @param aToIndex the index (exclusive) of the last element in the
2745      *                 first array to be tested
2746      * @param b the second array to be tested fro equality
2747      * @param bFromIndex the index (inclusive) of the first element in the
2748      *                   second array to be tested
2749      * @param bToIndex the index (exclusive) of the last element in the
2750      *                 second array to be tested
2751      * @return {@code true} if the two arrays, over the specified ranges, are
2752      *         equal
2753      * @throws IllegalArgumentException
2754      *         if {@code aFromIndex &gt; aToIndex} or
2755      *         if {@code bFromIndex &gt; bToIndex}
2756      * @throws ArrayIndexOutOfBoundsException
2757      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2758      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2759      * @throws NullPointerException
2760      *         if either array is {@code null}
2761      * @since 9
2762      */
2763     public static boolean equals(short[] a, int aFromIndex, int aToIndex,
2764                                  short[] b, int bFromIndex, int bToIndex) {
2765         rangeCheck(a.length, aFromIndex, aToIndex);
2766         rangeCheck(b.length, bFromIndex, bToIndex);
2767 
2768         int aLength = aToIndex - aFromIndex;
2769         int bLength = bToIndex - bFromIndex;
2770         if (aLength != bLength)
2771             return false;
2772 
2773         return ArraysSupport.mismatch(a, aFromIndex,
2774                                       b, bFromIndex,
2775                                       aLength) &lt; 0;
2776     }
2777 
2778     /**
2779      * Returns {@code true} if the two specified arrays of chars are
2780      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2781      * arrays contain the same number of elements, and all corresponding pairs
2782      * of elements in the two arrays are equal.  In other words, two arrays
2783      * are equal if they contain the same elements in the same order.  Also,
2784      * two array references are considered equal if both are {@code null}.
2785      *
2786      * @param a one array to be tested for equality
2787      * @param a2 the other array to be tested for equality
2788      * @return {@code true} if the two arrays are equal
2789      */
2790     @HotSpotIntrinsicCandidate
2791     public static boolean equals(char[] a, char[] a2) {
2792         if (a==a2)
2793             return true;
2794         if (a==null || a2==null)
2795             return false;
2796 
2797         int length = a.length;
2798         if (a2.length != length)
2799             return false;
2800 
2801         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2802     }
2803 
2804     /**
2805      * Returns true if the two specified arrays of chars, over the specified
2806      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2807      *
2808      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2809      * each range is the same, and all corresponding pairs of elements over the
2810      * specified ranges in the two arrays are equal.  In other words, two arrays
2811      * are equal if they contain, over the specified ranges, the same elements
2812      * in the same order.
2813      *
2814      * @param a the first array to be tested for equality
2815      * @param aFromIndex the index (inclusive) of the first element in the
2816      *                   first array to be tested
2817      * @param aToIndex the index (exclusive) of the last element in the
2818      *                 first array to be tested
2819      * @param b the second array to be tested fro equality
2820      * @param bFromIndex the index (inclusive) of the first element in the
2821      *                   second array to be tested
2822      * @param bToIndex the index (exclusive) of the last element in the
2823      *                 second array to be tested
2824      * @return {@code true} if the two arrays, over the specified ranges, are
2825      *         equal
2826      * @throws IllegalArgumentException
2827      *         if {@code aFromIndex &gt; aToIndex} or
2828      *         if {@code bFromIndex &gt; bToIndex}
2829      * @throws ArrayIndexOutOfBoundsException
2830      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2831      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2832      * @throws NullPointerException
2833      *         if either array is {@code null}
2834      * @since 9
2835      */
2836     public static boolean equals(char[] a, int aFromIndex, int aToIndex,
2837                                  char[] b, int bFromIndex, int bToIndex) {
2838         rangeCheck(a.length, aFromIndex, aToIndex);
2839         rangeCheck(b.length, bFromIndex, bToIndex);
2840 
2841         int aLength = aToIndex - aFromIndex;
2842         int bLength = bToIndex - bFromIndex;
2843         if (aLength != bLength)
2844             return false;
2845 
2846         return ArraysSupport.mismatch(a, aFromIndex,
2847                                       b, bFromIndex,
2848                                       aLength) &lt; 0;
2849     }
2850 
2851     /**
2852      * Returns {@code true} if the two specified arrays of bytes are
2853      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2854      * arrays contain the same number of elements, and all corresponding pairs
2855      * of elements in the two arrays are equal.  In other words, two arrays
2856      * are equal if they contain the same elements in the same order.  Also,
2857      * two array references are considered equal if both are {@code null}.
2858      *
2859      * @param a one array to be tested for equality
2860      * @param a2 the other array to be tested for equality
2861      * @return {@code true} if the two arrays are equal
2862      */
2863     @HotSpotIntrinsicCandidate
2864     public static boolean equals(byte[] a, byte[] a2) {
2865         if (a==a2)
2866             return true;
2867         if (a==null || a2==null)
2868             return false;
2869 
2870         int length = a.length;
2871         if (a2.length != length)
2872             return false;
2873 
2874         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2875     }
2876 
2877     /**
2878      * Returns true if the two specified arrays of bytes, over the specified
2879      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2880      *
2881      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2882      * each range is the same, and all corresponding pairs of elements over the
2883      * specified ranges in the two arrays are equal.  In other words, two arrays
2884      * are equal if they contain, over the specified ranges, the same elements
2885      * in the same order.
2886      *
2887      * @param a the first array to be tested for equality
2888      * @param aFromIndex the index (inclusive) of the first element in the
2889      *                   first array to be tested
2890      * @param aToIndex the index (exclusive) of the last element in the
2891      *                 first array to be tested
2892      * @param b the second array to be tested fro equality
2893      * @param bFromIndex the index (inclusive) of the first element in the
2894      *                   second array to be tested
2895      * @param bToIndex the index (exclusive) of the last element in the
2896      *                 second array to be tested
2897      * @return {@code true} if the two arrays, over the specified ranges, are
2898      *         equal
2899      * @throws IllegalArgumentException
2900      *         if {@code aFromIndex &gt; aToIndex} or
2901      *         if {@code bFromIndex &gt; bToIndex}
2902      * @throws ArrayIndexOutOfBoundsException
2903      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2904      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2905      * @throws NullPointerException
2906      *         if either array is {@code null}
2907      * @since 9
2908      */
2909     public static boolean equals(byte[] a, int aFromIndex, int aToIndex,
2910                                  byte[] b, int bFromIndex, int bToIndex) {
2911         rangeCheck(a.length, aFromIndex, aToIndex);
2912         rangeCheck(b.length, bFromIndex, bToIndex);
2913 
2914         int aLength = aToIndex - aFromIndex;
2915         int bLength = bToIndex - bFromIndex;
2916         if (aLength != bLength)
2917             return false;
2918 
2919         return ArraysSupport.mismatch(a, aFromIndex,
2920                                       b, bFromIndex,
2921                                       aLength) &lt; 0;
2922     }
2923 
2924     /**
2925      * Returns {@code true} if the two specified arrays of booleans are
2926      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2927      * arrays contain the same number of elements, and all corresponding pairs
2928      * of elements in the two arrays are equal.  In other words, two arrays
2929      * are equal if they contain the same elements in the same order.  Also,
2930      * two array references are considered equal if both are {@code null}.
2931      *
2932      * @param a one array to be tested for equality
2933      * @param a2 the other array to be tested for equality
2934      * @return {@code true} if the two arrays are equal
2935      */
2936     public static boolean equals(boolean[] a, boolean[] a2) {
2937         if (a==a2)
2938             return true;
2939         if (a==null || a2==null)
2940             return false;
2941 
2942         int length = a.length;
2943         if (a2.length != length)
2944             return false;
2945 
2946         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2947     }
2948 
2949     /**
2950      * Returns true if the two specified arrays of booleans, over the specified
2951      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2952      *
2953      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2954      * each range is the same, and all corresponding pairs of elements over the
2955      * specified ranges in the two arrays are equal.  In other words, two arrays
2956      * are equal if they contain, over the specified ranges, the same elements
2957      * in the same order.
2958      *
2959      * @param a the first array to be tested for equality
2960      * @param aFromIndex the index (inclusive) of the first element in the
2961      *                   first array to be tested
2962      * @param aToIndex the index (exclusive) of the last element in the
2963      *                 first array to be tested
2964      * @param b the second array to be tested fro equality
2965      * @param bFromIndex the index (inclusive) of the first element in the
2966      *                   second array to be tested
2967      * @param bToIndex the index (exclusive) of the last element in the
2968      *                 second array to be tested
2969      * @return {@code true} if the two arrays, over the specified ranges, are
2970      *         equal
2971      * @throws IllegalArgumentException
2972      *         if {@code aFromIndex &gt; aToIndex} or
2973      *         if {@code bFromIndex &gt; bToIndex}
2974      * @throws ArrayIndexOutOfBoundsException
2975      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2976      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2977      * @throws NullPointerException
2978      *         if either array is {@code null}
2979      * @since 9
2980      */
2981     public static boolean equals(boolean[] a, int aFromIndex, int aToIndex,
2982                                  boolean[] b, int bFromIndex, int bToIndex) {
2983         rangeCheck(a.length, aFromIndex, aToIndex);
2984         rangeCheck(b.length, bFromIndex, bToIndex);
2985 
2986         int aLength = aToIndex - aFromIndex;
2987         int bLength = bToIndex - bFromIndex;
2988         if (aLength != bLength)
2989             return false;
2990 
2991         return ArraysSupport.mismatch(a, aFromIndex,
2992                                       b, bFromIndex,
2993                                       aLength) &lt; 0;
2994     }
2995 
2996     /**
2997      * Returns {@code true} if the two specified arrays of doubles are
2998      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2999      * arrays contain the same number of elements, and all corresponding pairs
3000      * of elements in the two arrays are equal.  In other words, two arrays
3001      * are equal if they contain the same elements in the same order.  Also,
3002      * two array references are considered equal if both are {@code null}.
3003      *
3004      * Two doubles {@code d1} and {@code d2} are considered equal if:
3005      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
3006      * (Unlike the {@code ==} operator, this method considers
3007      * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)
3008      *
3009      * @param a one array to be tested for equality
3010      * @param a2 the other array to be tested for equality
3011      * @return {@code true} if the two arrays are equal
3012      * @see Double#equals(Object)
3013      */
3014     public static boolean equals(double[] a, double[] a2) {
3015         if (a==a2)
3016             return true;
3017         if (a==null || a2==null)
3018             return false;
3019 
3020         int length = a.length;
3021         if (a2.length != length)
3022             return false;
3023 
3024         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
3025     }
3026 
3027     /**
3028      * Returns true if the two specified arrays of doubles, over the specified
3029      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3030      *
3031      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3032      * each range is the same, and all corresponding pairs of elements over the
3033      * specified ranges in the two arrays are equal.  In other words, two arrays
3034      * are equal if they contain, over the specified ranges, the same elements
3035      * in the same order.
3036      *
3037      * &lt;p&gt;Two doubles {@code d1} and {@code d2} are considered equal if:
3038      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
3039      * (Unlike the {@code ==} operator, this method considers
3040      * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)
3041      *
3042      * @param a the first array to be tested for equality
3043      * @param aFromIndex the index (inclusive) of the first element in the
3044      *                   first array to be tested
3045      * @param aToIndex the index (exclusive) of the last element in the
3046      *                 first array to be tested
3047      * @param b the second array to be tested fro equality
3048      * @param bFromIndex the index (inclusive) of the first element in the
3049      *                   second array to be tested
3050      * @param bToIndex the index (exclusive) of the last element in the
3051      *                 second array to be tested
3052      * @return {@code true} if the two arrays, over the specified ranges, are
3053      *         equal
3054      * @throws IllegalArgumentException
3055      *         if {@code aFromIndex &gt; aToIndex} or
3056      *         if {@code bFromIndex &gt; bToIndex}
3057      * @throws ArrayIndexOutOfBoundsException
3058      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3059      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3060      * @throws NullPointerException
3061      *         if either array is {@code null}
3062      * @see Double#equals(Object)
3063      * @since 9
3064      */
3065     public static boolean equals(double[] a, int aFromIndex, int aToIndex,
3066                                  double[] b, int bFromIndex, int bToIndex) {
3067         rangeCheck(a.length, aFromIndex, aToIndex);
3068         rangeCheck(b.length, bFromIndex, bToIndex);
3069 
3070         int aLength = aToIndex - aFromIndex;
3071         int bLength = bToIndex - bFromIndex;
3072         if (aLength != bLength)
3073             return false;
3074 
3075         return ArraysSupport.mismatch(a, aFromIndex,
3076                                       b, bFromIndex, aLength) &lt; 0;
3077     }
3078 
3079     /**
3080      * Returns {@code true} if the two specified arrays of floats are
3081      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
3082      * arrays contain the same number of elements, and all corresponding pairs
3083      * of elements in the two arrays are equal.  In other words, two arrays
3084      * are equal if they contain the same elements in the same order.  Also,
3085      * two array references are considered equal if both are {@code null}.
3086      *
3087      * Two floats {@code f1} and {@code f2} are considered equal if:
3088      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
3089      * (Unlike the {@code ==} operator, this method considers
3090      * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)
3091      *
3092      * @param a one array to be tested for equality
3093      * @param a2 the other array to be tested for equality
3094      * @return {@code true} if the two arrays are equal
3095      * @see Float#equals(Object)
3096      */
3097     public static boolean equals(float[] a, float[] a2) {
3098         if (a==a2)
3099             return true;
3100         if (a==null || a2==null)
3101             return false;
3102 
3103         int length = a.length;
3104         if (a2.length != length)
3105             return false;
3106 
3107         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
3108     }
3109 
3110     /**
3111      * Returns true if the two specified arrays of floats, over the specified
3112      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3113      *
3114      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3115      * each range is the same, and all corresponding pairs of elements over the
3116      * specified ranges in the two arrays are equal.  In other words, two arrays
3117      * are equal if they contain, over the specified ranges, the same elements
3118      * in the same order.
3119      *
3120      * &lt;p&gt;Two floats {@code f1} and {@code f2} are considered equal if:
3121      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
3122      * (Unlike the {@code ==} operator, this method considers
3123      * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)
3124      *
3125      * @param a the first array to be tested for equality
3126      * @param aFromIndex the index (inclusive) of the first element in the
3127      *                   first array to be tested
3128      * @param aToIndex the index (exclusive) of the last element in the
3129      *                 first array to be tested
3130      * @param b the second array to be tested fro equality
3131      * @param bFromIndex the index (inclusive) of the first element in the
3132      *                   second array to be tested
3133      * @param bToIndex the index (exclusive) of the last element in the
3134      *                 second array to be tested
3135      * @return {@code true} if the two arrays, over the specified ranges, are
3136      *         equal
3137      * @throws IllegalArgumentException
3138      *         if {@code aFromIndex &gt; aToIndex} or
3139      *         if {@code bFromIndex &gt; bToIndex}
3140      * @throws ArrayIndexOutOfBoundsException
3141      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3142      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3143      * @throws NullPointerException
3144      *         if either array is {@code null}
3145      * @see Float#equals(Object)
3146      * @since 9
3147      */
3148     public static boolean equals(float[] a, int aFromIndex, int aToIndex,
3149                                  float[] b, int bFromIndex, int bToIndex) {
3150         rangeCheck(a.length, aFromIndex, aToIndex);
3151         rangeCheck(b.length, bFromIndex, bToIndex);
3152 
3153         int aLength = aToIndex - aFromIndex;
3154         int bLength = bToIndex - bFromIndex;
3155         if (aLength != bLength)
3156             return false;
3157 
3158         return ArraysSupport.mismatch(a, aFromIndex,
3159                                       b, bFromIndex, aLength) &lt; 0;
3160     }
3161 
3162     /**
3163      * Returns {@code true} if the two specified arrays of Objects are
3164      * &lt;i&gt;equal&lt;/i&gt; to one another.  The two arrays are considered equal if
3165      * both arrays contain the same number of elements, and all corresponding
3166      * pairs of elements in the two arrays are equal.  Two objects {@code e1}
3167      * and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if
3168      * {@code Objects.equals(e1, e2)}.
3169      * In other words, the two arrays are equal if
3170      * they contain the same elements in the same order.  Also, two array
3171      * references are considered equal if both are {@code null}.
3172      *
3173      * @param a one array to be tested for equality
3174      * @param a2 the other array to be tested for equality
3175      * @return {@code true} if the two arrays are equal
3176      */
3177     public static boolean equals(Object[] a, Object[] a2) {
3178         if (a==a2)
3179             return true;
3180         if (a==null || a2==null)
3181             return false;
3182 
3183         int length = a.length;
3184         if (a2.length != length)
3185             return false;
3186 
3187         for (int i=0; i&lt;length; i++) {
3188             if (!Objects.equals(a[i], a2[i]))
3189                 return false;
3190         }
3191 
3192         return true;
3193     }
3194 
3195     /**
3196      * Returns true if the two specified arrays of Objects, over the specified
3197      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3198      *
3199      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3200      * each range is the same, and all corresponding pairs of elements over the
3201      * specified ranges in the two arrays are equal.  In other words, two arrays
3202      * are equal if they contain, over the specified ranges, the same elements
3203      * in the same order.
3204      *
3205      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if
3206      * {@code Objects.equals(e1, e2)}.
3207      *
3208      * @param a the first array to be tested for equality
3209      * @param aFromIndex the index (inclusive) of the first element in the
3210      *                   first array to be tested
3211      * @param aToIndex the index (exclusive) of the last element in the
3212      *                 first array to be tested
3213      * @param b the second array to be tested fro equality
3214      * @param bFromIndex the index (inclusive) of the first element in the
3215      *                   second array to be tested
3216      * @param bToIndex the index (exclusive) of the last element in the
3217      *                 second array to be tested
3218      * @return {@code true} if the two arrays, over the specified ranges, are
3219      *         equal
3220      * @throws IllegalArgumentException
3221      *         if {@code aFromIndex &gt; aToIndex} or
3222      *         if {@code bFromIndex &gt; bToIndex}
3223      * @throws ArrayIndexOutOfBoundsException
3224      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3225      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3226      * @throws NullPointerException
3227      *         if either array is {@code null}
3228      * @since 9
3229      */
3230     public static boolean equals(Object[] a, int aFromIndex, int aToIndex,
3231                                  Object[] b, int bFromIndex, int bToIndex) {
3232         rangeCheck(a.length, aFromIndex, aToIndex);
3233         rangeCheck(b.length, bFromIndex, bToIndex);
3234 
3235         int aLength = aToIndex - aFromIndex;
3236         int bLength = bToIndex - bFromIndex;
3237         if (aLength != bLength)
3238             return false;
3239 
3240         for (int i = 0; i &lt; aLength; i++) {
3241             if (!Objects.equals(a[aFromIndex++], b[bFromIndex++]))
3242                 return false;
3243         }
3244 
3245         return true;
3246     }
3247 
3248     /**
3249      * Returns {@code true} if the two specified arrays of Objects are
3250      * &lt;i&gt;equal&lt;/i&gt; to one another.
3251      *
3252      * &lt;p&gt;Two arrays are considered equal if both arrays contain the same number
3253      * of elements, and all corresponding pairs of elements in the two arrays
3254      * are equal.  In other words, the two arrays are equal if they contain the
3255      * same elements in the same order.  Also, two array references are
3256      * considered equal if both are {@code null}.
3257      *
3258      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if,
3259      * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.
3260      *
3261      * @param a one array to be tested for equality
3262      * @param a2 the other array to be tested for equality
3263      * @param cmp the comparator to compare array elements
3264      * @param &lt;T&gt; the type of array elements
3265      * @return {@code true} if the two arrays are equal
3266      * @throws NullPointerException if the comparator is {@code null}
3267      * @since 9
3268      */
3269     public static &lt;T&gt; boolean equals(T[] a, T[] a2, Comparator&lt;? super T&gt; cmp) {
3270         Objects.requireNonNull(cmp);
3271         if (a==a2)
3272             return true;
3273         if (a==null || a2==null)
3274             return false;
3275 
3276         int length = a.length;
3277         if (a2.length != length)
3278             return false;
3279 
3280         for (int i=0; i&lt;length; i++) {
3281             if (cmp.compare(a[i], a2[i]) != 0)
3282                 return false;
3283         }
3284 
3285         return true;
3286     }
3287 
3288     /**
3289      * Returns true if the two specified arrays of Objects, over the specified
3290      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3291      *
3292      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3293      * each range is the same, and all corresponding pairs of elements over the
3294      * specified ranges in the two arrays are equal.  In other words, two arrays
3295      * are equal if they contain, over the specified ranges, the same elements
3296      * in the same order.
3297      *
3298      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if,
3299      * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.
3300      *
3301      * @param a the first array to be tested for equality
3302      * @param aFromIndex the index (inclusive) of the first element in the
3303      *                   first array to be tested
3304      * @param aToIndex the index (exclusive) of the last element in the
3305      *                 first array to be tested
3306      * @param b the second array to be tested fro equality
3307      * @param bFromIndex the index (inclusive) of the first element in the
3308      *                   second array to be tested
3309      * @param bToIndex the index (exclusive) of the last element in the
3310      *                 second array to be tested
3311      * @param cmp the comparator to compare array elements
3312      * @param &lt;T&gt; the type of array elements
3313      * @return {@code true} if the two arrays, over the specified ranges, are
3314      *         equal
3315      * @throws IllegalArgumentException
3316      *         if {@code aFromIndex &gt; aToIndex} or
3317      *         if {@code bFromIndex &gt; bToIndex}
3318      * @throws ArrayIndexOutOfBoundsException
3319      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3320      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3321      * @throws NullPointerException
3322      *         if either array or the comparator is {@code null}
3323      * @since 9
3324      */
3325     public static &lt;T&gt; boolean equals(T[] a, int aFromIndex, int aToIndex,
3326                                      T[] b, int bFromIndex, int bToIndex,
3327                                      Comparator&lt;? super T&gt; cmp) {
3328         Objects.requireNonNull(cmp);
3329         rangeCheck(a.length, aFromIndex, aToIndex);
3330         rangeCheck(b.length, bFromIndex, bToIndex);
3331 
3332         int aLength = aToIndex - aFromIndex;
3333         int bLength = bToIndex - bFromIndex;
3334         if (aLength != bLength)
3335             return false;
3336 
3337         for (int i = 0; i &lt; aLength; i++) {
3338             if (cmp.compare(a[aFromIndex++], b[bFromIndex++]) != 0)
3339                 return false;
3340         }
3341 
3342         return true;
3343     }
3344 
3345     // Filling
3346 
3347     /**
3348      * Assigns the specified long value to each element of the specified array
3349      * of longs.
3350      *
3351      * @param a the array to be filled
3352      * @param val the value to be stored in all elements of the array
3353      */
3354     public static void fill(long[] a, long val) {
3355         for (int i = 0, len = a.length; i &lt; len; i++)
3356             a[i] = val;
3357     }
3358 
3359     /**
3360      * Assigns the specified long value to each element of the specified
3361      * range of the specified array of longs.  The range to be filled
3362      * extends from index {@code fromIndex}, inclusive, to index
3363      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3364      * range to be filled is empty.)
3365      *
3366      * @param a the array to be filled
3367      * @param fromIndex the index of the first element (inclusive) to be
3368      *        filled with the specified value
3369      * @param toIndex the index of the last element (exclusive) to be
3370      *        filled with the specified value
3371      * @param val the value to be stored in all elements of the array
3372      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3373      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3374      *         {@code toIndex &gt; a.length}
3375      */
3376     public static void fill(long[] a, int fromIndex, int toIndex, long val) {
3377         rangeCheck(a.length, fromIndex, toIndex);
3378         for (int i = fromIndex; i &lt; toIndex; i++)
3379             a[i] = val;
3380     }
3381 
3382     /**
3383      * Assigns the specified int value to each element of the specified array
3384      * of ints.
3385      *
3386      * @param a the array to be filled
3387      * @param val the value to be stored in all elements of the array
3388      */
3389     public static void fill(int[] a, int val) {
3390         for (int i = 0, len = a.length; i &lt; len; i++)
3391             a[i] = val;
3392     }
3393 
3394     /**
3395      * Assigns the specified int value to each element of the specified
3396      * range of the specified array of ints.  The range to be filled
3397      * extends from index {@code fromIndex}, inclusive, to index
3398      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3399      * range to be filled is empty.)
3400      *
3401      * @param a the array to be filled
3402      * @param fromIndex the index of the first element (inclusive) to be
3403      *        filled with the specified value
3404      * @param toIndex the index of the last element (exclusive) to be
3405      *        filled with the specified value
3406      * @param val the value to be stored in all elements of the array
3407      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3408      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3409      *         {@code toIndex &gt; a.length}
3410      */
3411     public static void fill(int[] a, int fromIndex, int toIndex, int val) {
3412         rangeCheck(a.length, fromIndex, toIndex);
3413         for (int i = fromIndex; i &lt; toIndex; i++)
3414             a[i] = val;
3415     }
3416 
3417     /**
3418      * Assigns the specified short value to each element of the specified array
3419      * of shorts.
3420      *
3421      * @param a the array to be filled
3422      * @param val the value to be stored in all elements of the array
3423      */
3424     public static void fill(short[] a, short val) {
3425         for (int i = 0, len = a.length; i &lt; len; i++)
3426             a[i] = val;
3427     }
3428 
3429     /**
3430      * Assigns the specified short value to each element of the specified
3431      * range of the specified array of shorts.  The range to be filled
3432      * extends from index {@code fromIndex}, inclusive, to index
3433      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3434      * range to be filled is empty.)
3435      *
3436      * @param a the array to be filled
3437      * @param fromIndex the index of the first element (inclusive) to be
3438      *        filled with the specified value
3439      * @param toIndex the index of the last element (exclusive) to be
3440      *        filled with the specified value
3441      * @param val the value to be stored in all elements of the array
3442      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3443      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3444      *         {@code toIndex &gt; a.length}
3445      */
3446     public static void fill(short[] a, int fromIndex, int toIndex, short val) {
3447         rangeCheck(a.length, fromIndex, toIndex);
3448         for (int i = fromIndex; i &lt; toIndex; i++)
3449             a[i] = val;
3450     }
3451 
3452     /**
3453      * Assigns the specified char value to each element of the specified array
3454      * of chars.
3455      *
3456      * @param a the array to be filled
3457      * @param val the value to be stored in all elements of the array
3458      */
3459     public static void fill(char[] a, char val) {
3460         for (int i = 0, len = a.length; i &lt; len; i++)
3461             a[i] = val;
3462     }
3463 
3464     /**
3465      * Assigns the specified char value to each element of the specified
3466      * range of the specified array of chars.  The range to be filled
3467      * extends from index {@code fromIndex}, inclusive, to index
3468      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3469      * range to be filled is empty.)
3470      *
3471      * @param a the array to be filled
3472      * @param fromIndex the index of the first element (inclusive) to be
3473      *        filled with the specified value
3474      * @param toIndex the index of the last element (exclusive) to be
3475      *        filled with the specified value
3476      * @param val the value to be stored in all elements of the array
3477      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3478      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3479      *         {@code toIndex &gt; a.length}
3480      */
3481     public static void fill(char[] a, int fromIndex, int toIndex, char val) {
3482         rangeCheck(a.length, fromIndex, toIndex);
3483         for (int i = fromIndex; i &lt; toIndex; i++)
3484             a[i] = val;
3485     }
3486 
3487     /**
3488      * Assigns the specified byte value to each element of the specified array
3489      * of bytes.
3490      *
3491      * @param a the array to be filled
3492      * @param val the value to be stored in all elements of the array
3493      */
3494     public static void fill(byte[] a, byte val) {
3495         for (int i = 0, len = a.length; i &lt; len; i++)
3496             a[i] = val;
3497     }
3498 
3499     /**
3500      * Assigns the specified byte value to each element of the specified
3501      * range of the specified array of bytes.  The range to be filled
3502      * extends from index {@code fromIndex}, inclusive, to index
3503      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3504      * range to be filled is empty.)
3505      *
3506      * @param a the array to be filled
3507      * @param fromIndex the index of the first element (inclusive) to be
3508      *        filled with the specified value
3509      * @param toIndex the index of the last element (exclusive) to be
3510      *        filled with the specified value
3511      * @param val the value to be stored in all elements of the array
3512      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3513      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3514      *         {@code toIndex &gt; a.length}
3515      */
3516     public static void fill(byte[] a, int fromIndex, int toIndex, byte val) {
3517         rangeCheck(a.length, fromIndex, toIndex);
3518         for (int i = fromIndex; i &lt; toIndex; i++)
3519             a[i] = val;
3520     }
3521 
3522     /**
3523      * Assigns the specified boolean value to each element of the specified
3524      * array of booleans.
3525      *
3526      * @param a the array to be filled
3527      * @param val the value to be stored in all elements of the array
3528      */
3529     public static void fill(boolean[] a, boolean val) {
3530         for (int i = 0, len = a.length; i &lt; len; i++)
3531             a[i] = val;
3532     }
3533 
3534     /**
3535      * Assigns the specified boolean value to each element of the specified
3536      * range of the specified array of booleans.  The range to be filled
3537      * extends from index {@code fromIndex}, inclusive, to index
3538      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3539      * range to be filled is empty.)
3540      *
3541      * @param a the array to be filled
3542      * @param fromIndex the index of the first element (inclusive) to be
3543      *        filled with the specified value
3544      * @param toIndex the index of the last element (exclusive) to be
3545      *        filled with the specified value
3546      * @param val the value to be stored in all elements of the array
3547      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3548      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3549      *         {@code toIndex &gt; a.length}
3550      */
3551     public static void fill(boolean[] a, int fromIndex, int toIndex,
3552                             boolean val) {
3553         rangeCheck(a.length, fromIndex, toIndex);
3554         for (int i = fromIndex; i &lt; toIndex; i++)
3555             a[i] = val;
3556     }
3557 
3558     /**
3559      * Assigns the specified double value to each element of the specified
3560      * array of doubles.
3561      *
3562      * @param a the array to be filled
3563      * @param val the value to be stored in all elements of the array
3564      */
3565     public static void fill(double[] a, double val) {
3566         for (int i = 0, len = a.length; i &lt; len; i++)
3567             a[i] = val;
3568     }
3569 
3570     /**
3571      * Assigns the specified double value to each element of the specified
3572      * range of the specified array of doubles.  The range to be filled
3573      * extends from index {@code fromIndex}, inclusive, to index
3574      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3575      * range to be filled is empty.)
3576      *
3577      * @param a the array to be filled
3578      * @param fromIndex the index of the first element (inclusive) to be
3579      *        filled with the specified value
3580      * @param toIndex the index of the last element (exclusive) to be
3581      *        filled with the specified value
3582      * @param val the value to be stored in all elements of the array
3583      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3584      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3585      *         {@code toIndex &gt; a.length}
3586      */
3587     public static void fill(double[] a, int fromIndex, int toIndex,double val){
3588         rangeCheck(a.length, fromIndex, toIndex);
3589         for (int i = fromIndex; i &lt; toIndex; i++)
3590             a[i] = val;
3591     }
3592 
3593     /**
3594      * Assigns the specified float value to each element of the specified array
3595      * of floats.
3596      *
3597      * @param a the array to be filled
3598      * @param val the value to be stored in all elements of the array
3599      */
3600     public static void fill(float[] a, float val) {
3601         for (int i = 0, len = a.length; i &lt; len; i++)
3602             a[i] = val;
3603     }
3604 
3605     /**
3606      * Assigns the specified float value to each element of the specified
3607      * range of the specified array of floats.  The range to be filled
3608      * extends from index {@code fromIndex}, inclusive, to index
3609      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3610      * range to be filled is empty.)
3611      *
3612      * @param a the array to be filled
3613      * @param fromIndex the index of the first element (inclusive) to be
3614      *        filled with the specified value
3615      * @param toIndex the index of the last element (exclusive) to be
3616      *        filled with the specified value
3617      * @param val the value to be stored in all elements of the array
3618      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3619      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3620      *         {@code toIndex &gt; a.length}
3621      */
3622     public static void fill(float[] a, int fromIndex, int toIndex, float val) {
3623         rangeCheck(a.length, fromIndex, toIndex);
3624         for (int i = fromIndex; i &lt; toIndex; i++)
3625             a[i] = val;
3626     }
3627 
3628     /**
3629      * Assigns the specified Object reference to each element of the specified
3630      * array of Objects.
3631      *
3632      * @param a the array to be filled
3633      * @param val the value to be stored in all elements of the array
3634      * @throws ArrayStoreException if the specified value is not of a
3635      *         runtime type that can be stored in the specified array
3636      */
3637     public static void fill(Object[] a, Object val) {
3638         for (int i = 0, len = a.length; i &lt; len; i++)
3639             a[i] = val;
3640     }
3641 
3642     /**
3643      * Assigns the specified Object reference to each element of the specified
3644      * range of the specified array of Objects.  The range to be filled
3645      * extends from index {@code fromIndex}, inclusive, to index
3646      * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
3647      * range to be filled is empty.)
3648      *
3649      * @param a the array to be filled
3650      * @param fromIndex the index of the first element (inclusive) to be
3651      *        filled with the specified value
3652      * @param toIndex the index of the last element (exclusive) to be
3653      *        filled with the specified value
3654      * @param val the value to be stored in all elements of the array
3655      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
3656      * @throws ArrayIndexOutOfBoundsException if {@code fromIndex &lt; 0} or
3657      *         {@code toIndex &gt; a.length}
3658      * @throws ArrayStoreException if the specified value is not of a
3659      *         runtime type that can be stored in the specified array
3660      */
3661     public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {
3662         rangeCheck(a.length, fromIndex, toIndex);
3663         for (int i = fromIndex; i &lt; toIndex; i++)
3664             a[i] = val;
3665     }
3666 
3667     // Cloning
3668 
3669     /**
3670      * Copies the specified array, truncating or padding with nulls (if necessary)
3671      * so the copy has the specified length.  For all indices that are
3672      * valid in both the original array and the copy, the two arrays will
3673      * contain identical values.  For any indices that are valid in the
3674      * copy but not the original, the copy will contain {@code null}.
3675      * Such indices will exist if and only if the specified length
3676      * is greater than that of the original array.
3677      * The resulting array is of exactly the same class as the original array.
3678      *
3679      * @param &lt;T&gt; the class of the objects in the array
3680      * @param original the array to be copied
3681      * @param newLength the length of the copy to be returned
3682      * @return a copy of the original array, truncated or padded with nulls
3683      *     to obtain the specified length
3684      * @throws NegativeArraySizeException if {@code newLength} is negative
3685      * @throws NullPointerException if {@code original} is null
3686      * @since 1.6
3687      */
3688     @SuppressWarnings(&quot;unchecked&quot;)
3689     public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
3690         return (T[]) copyOf(original, newLength, original.getClass());
3691     }
3692 
3693     /**
3694      * Copies the specified array, truncating or padding with nulls (if necessary)
3695      * so the copy has the specified length.  For all indices that are
3696      * valid in both the original array and the copy, the two arrays will
3697      * contain identical values.  For any indices that are valid in the
3698      * copy but not the original, the copy will contain {@code null}.
3699      * Such indices will exist if and only if the specified length
3700      * is greater than that of the original array.
3701      * The resulting array is of the class {@code newType}.
3702      *
3703      * @param &lt;U&gt; the class of the objects in the original array
3704      * @param &lt;T&gt; the class of the objects in the returned array
3705      * @param original the array to be copied
3706      * @param newLength the length of the copy to be returned
3707      * @param newType the class of the copy to be returned
3708      * @return a copy of the original array, truncated or padded with nulls
3709      *     to obtain the specified length
3710      * @throws NegativeArraySizeException if {@code newLength} is negative
3711      * @throws NullPointerException if {@code original} is null
3712      * @throws ArrayStoreException if an element copied from
3713      *     {@code original} is not of a runtime type that can be stored in
3714      *     an array of class {@code newType}
3715      * @since 1.6
3716      */
3717     @HotSpotIntrinsicCandidate
3718     public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
3719         @SuppressWarnings(&quot;unchecked&quot;)
3720         T[] copy = ((Object)newType == (Object)Object[].class)
3721             ? (T[]) new Object[newLength]
3722             : (T[]) Array.newInstance(newType.getComponentType(), newLength);
3723         System.arraycopy(original, 0, copy, 0,
3724                          Math.min(original.length, newLength));
3725         return copy;
3726     }
3727 
3728     /**
3729      * Copies the specified array, truncating or padding with zeros (if necessary)
3730      * so the copy has the specified length.  For all indices that are
3731      * valid in both the original array and the copy, the two arrays will
3732      * contain identical values.  For any indices that are valid in the
3733      * copy but not the original, the copy will contain {@code (byte)0}.
3734      * Such indices will exist if and only if the specified length
3735      * is greater than that of the original array.
3736      *
3737      * @param original the array to be copied
3738      * @param newLength the length of the copy to be returned
3739      * @return a copy of the original array, truncated or padded with zeros
3740      *     to obtain the specified length
3741      * @throws NegativeArraySizeException if {@code newLength} is negative
3742      * @throws NullPointerException if {@code original} is null
3743      * @since 1.6
3744      */
3745     public static byte[] copyOf(byte[] original, int newLength) {
3746         byte[] copy = new byte[newLength];
3747         System.arraycopy(original, 0, copy, 0,
3748                          Math.min(original.length, newLength));
3749         return copy;
3750     }
3751 
3752     /**
3753      * Copies the specified array, truncating or padding with zeros (if necessary)
3754      * so the copy has the specified length.  For all indices that are
3755      * valid in both the original array and the copy, the two arrays will
3756      * contain identical values.  For any indices that are valid in the
3757      * copy but not the original, the copy will contain {@code (short)0}.
3758      * Such indices will exist if and only if the specified length
3759      * is greater than that of the original array.
3760      *
3761      * @param original the array to be copied
3762      * @param newLength the length of the copy to be returned
3763      * @return a copy of the original array, truncated or padded with zeros
3764      *     to obtain the specified length
3765      * @throws NegativeArraySizeException if {@code newLength} is negative
3766      * @throws NullPointerException if {@code original} is null
3767      * @since 1.6
3768      */
3769     public static short[] copyOf(short[] original, int newLength) {
3770         short[] copy = new short[newLength];
3771         System.arraycopy(original, 0, copy, 0,
3772                          Math.min(original.length, newLength));
3773         return copy;
3774     }
3775 
3776     /**
3777      * Copies the specified array, truncating or padding with zeros (if necessary)
3778      * so the copy has the specified length.  For all indices that are
3779      * valid in both the original array and the copy, the two arrays will
3780      * contain identical values.  For any indices that are valid in the
3781      * copy but not the original, the copy will contain {@code 0}.
3782      * Such indices will exist if and only if the specified length
3783      * is greater than that of the original array.
3784      *
3785      * @param original the array to be copied
3786      * @param newLength the length of the copy to be returned
3787      * @return a copy of the original array, truncated or padded with zeros
3788      *     to obtain the specified length
3789      * @throws NegativeArraySizeException if {@code newLength} is negative
3790      * @throws NullPointerException if {@code original} is null
3791      * @since 1.6
3792      */
3793     public static int[] copyOf(int[] original, int newLength) {
3794         int[] copy = new int[newLength];
3795         System.arraycopy(original, 0, copy, 0,
3796                          Math.min(original.length, newLength));
3797         return copy;
3798     }
3799 
3800     /**
3801      * Copies the specified array, truncating or padding with zeros (if necessary)
3802      * so the copy has the specified length.  For all indices that are
3803      * valid in both the original array and the copy, the two arrays will
3804      * contain identical values.  For any indices that are valid in the
3805      * copy but not the original, the copy will contain {@code 0L}.
3806      * Such indices will exist if and only if the specified length
3807      * is greater than that of the original array.
3808      *
3809      * @param original the array to be copied
3810      * @param newLength the length of the copy to be returned
3811      * @return a copy of the original array, truncated or padded with zeros
3812      *     to obtain the specified length
3813      * @throws NegativeArraySizeException if {@code newLength} is negative
3814      * @throws NullPointerException if {@code original} is null
3815      * @since 1.6
3816      */
3817     public static long[] copyOf(long[] original, int newLength) {
3818         long[] copy = new long[newLength];
3819         System.arraycopy(original, 0, copy, 0,
3820                          Math.min(original.length, newLength));
3821         return copy;
3822     }
3823 
3824     /**
3825      * Copies the specified array, truncating or padding with null characters (if necessary)
3826      * so the copy has the specified length.  For all indices that are valid
3827      * in both the original array and the copy, the two arrays will contain
3828      * identical values.  For any indices that are valid in the copy but not
3829      * the original, the copy will contain {@code &#39;\\u000&#39;}.  Such indices
3830      * will exist if and only if the specified length is greater than that of
3831      * the original array.
3832      *
3833      * @param original the array to be copied
3834      * @param newLength the length of the copy to be returned
3835      * @return a copy of the original array, truncated or padded with null characters
3836      *     to obtain the specified length
3837      * @throws NegativeArraySizeException if {@code newLength} is negative
3838      * @throws NullPointerException if {@code original} is null
3839      * @since 1.6
3840      */
3841     public static char[] copyOf(char[] original, int newLength) {
3842         char[] copy = new char[newLength];
3843         System.arraycopy(original, 0, copy, 0,
3844                          Math.min(original.length, newLength));
3845         return copy;
3846     }
3847 
3848     /**
3849      * Copies the specified array, truncating or padding with zeros (if necessary)
3850      * so the copy has the specified length.  For all indices that are
3851      * valid in both the original array and the copy, the two arrays will
3852      * contain identical values.  For any indices that are valid in the
3853      * copy but not the original, the copy will contain {@code 0f}.
3854      * Such indices will exist if and only if the specified length
3855      * is greater than that of the original array.
3856      *
3857      * @param original the array to be copied
3858      * @param newLength the length of the copy to be returned
3859      * @return a copy of the original array, truncated or padded with zeros
3860      *     to obtain the specified length
3861      * @throws NegativeArraySizeException if {@code newLength} is negative
3862      * @throws NullPointerException if {@code original} is null
3863      * @since 1.6
3864      */
3865     public static float[] copyOf(float[] original, int newLength) {
3866         float[] copy = new float[newLength];
3867         System.arraycopy(original, 0, copy, 0,
3868                          Math.min(original.length, newLength));
3869         return copy;
3870     }
3871 
3872     /**
3873      * Copies the specified array, truncating or padding with zeros (if necessary)
3874      * so the copy has the specified length.  For all indices that are
3875      * valid in both the original array and the copy, the two arrays will
3876      * contain identical values.  For any indices that are valid in the
3877      * copy but not the original, the copy will contain {@code 0d}.
3878      * Such indices will exist if and only if the specified length
3879      * is greater than that of the original array.
3880      *
3881      * @param original the array to be copied
3882      * @param newLength the length of the copy to be returned
3883      * @return a copy of the original array, truncated or padded with zeros
3884      *     to obtain the specified length
3885      * @throws NegativeArraySizeException if {@code newLength} is negative
3886      * @throws NullPointerException if {@code original} is null
3887      * @since 1.6
3888      */
3889     public static double[] copyOf(double[] original, int newLength) {
3890         double[] copy = new double[newLength];
3891         System.arraycopy(original, 0, copy, 0,
3892                          Math.min(original.length, newLength));
3893         return copy;
3894     }
3895 
3896     /**
3897      * Copies the specified array, truncating or padding with {@code false} (if necessary)
3898      * so the copy has the specified length.  For all indices that are
3899      * valid in both the original array and the copy, the two arrays will
3900      * contain identical values.  For any indices that are valid in the
3901      * copy but not the original, the copy will contain {@code false}.
3902      * Such indices will exist if and only if the specified length
3903      * is greater than that of the original array.
3904      *
3905      * @param original the array to be copied
3906      * @param newLength the length of the copy to be returned
3907      * @return a copy of the original array, truncated or padded with false elements
3908      *     to obtain the specified length
3909      * @throws NegativeArraySizeException if {@code newLength} is negative
3910      * @throws NullPointerException if {@code original} is null
3911      * @since 1.6
3912      */
3913     public static boolean[] copyOf(boolean[] original, int newLength) {
3914         boolean[] copy = new boolean[newLength];
3915         System.arraycopy(original, 0, copy, 0,
3916                          Math.min(original.length, newLength));
3917         return copy;
3918     }
3919 
3920     /**
3921      * Copies the specified range of the specified array into a new array.
3922      * The initial index of the range ({@code from}) must lie between zero
3923      * and {@code original.length}, inclusive.  The value at
3924      * {@code original[from]} is placed into the initial element of the copy
3925      * (unless {@code from == original.length} or {@code from == to}).
3926      * Values from subsequent elements in the original array are placed into
3927      * subsequent elements in the copy.  The final index of the range
3928      * ({@code to}), which must be greater than or equal to {@code from},
3929      * may be greater than {@code original.length}, in which case
3930      * {@code null} is placed in all elements of the copy whose index is
3931      * greater than or equal to {@code original.length - from}.  The length
3932      * of the returned array will be {@code to - from}.
3933      * &lt;p&gt;
3934      * The resulting array is of exactly the same class as the original array.
3935      *
3936      * @param &lt;T&gt; the class of the objects in the array
3937      * @param original the array from which a range is to be copied
3938      * @param from the initial index of the range to be copied, inclusive
3939      * @param to the final index of the range to be copied, exclusive.
3940      *     (This index may lie outside the array.)
3941      * @return a new array containing the specified range from the original array,
3942      *     truncated or padded with nulls to obtain the required length
3943      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
3944      *     or {@code from &gt; original.length}
3945      * @throws IllegalArgumentException if {@code from &gt; to}
3946      * @throws NullPointerException if {@code original} is null
3947      * @since 1.6
3948      */
3949     @SuppressWarnings(&quot;unchecked&quot;)
3950     public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) {
3951         return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());
3952     }
3953 
3954     /**
3955      * Copies the specified range of the specified array into a new array.
3956      * The initial index of the range ({@code from}) must lie between zero
3957      * and {@code original.length}, inclusive.  The value at
3958      * {@code original[from]} is placed into the initial element of the copy
3959      * (unless {@code from == original.length} or {@code from == to}).
3960      * Values from subsequent elements in the original array are placed into
3961      * subsequent elements in the copy.  The final index of the range
3962      * ({@code to}), which must be greater than or equal to {@code from},
3963      * may be greater than {@code original.length}, in which case
3964      * {@code null} is placed in all elements of the copy whose index is
3965      * greater than or equal to {@code original.length - from}.  The length
3966      * of the returned array will be {@code to - from}.
3967      * The resulting array is of the class {@code newType}.
3968      *
3969      * @param &lt;U&gt; the class of the objects in the original array
3970      * @param &lt;T&gt; the class of the objects in the returned array
3971      * @param original the array from which a range is to be copied
3972      * @param from the initial index of the range to be copied, inclusive
3973      * @param to the final index of the range to be copied, exclusive.
3974      *     (This index may lie outside the array.)
3975      * @param newType the class of the copy to be returned
3976      * @return a new array containing the specified range from the original array,
3977      *     truncated or padded with nulls to obtain the required length
3978      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
3979      *     or {@code from &gt; original.length}
3980      * @throws IllegalArgumentException if {@code from &gt; to}
3981      * @throws NullPointerException if {@code original} is null
3982      * @throws ArrayStoreException if an element copied from
3983      *     {@code original} is not of a runtime type that can be stored in
3984      *     an array of class {@code newType}.
3985      * @since 1.6
3986      */
3987     @HotSpotIntrinsicCandidate
3988     public static &lt;T,U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) {
3989         int newLength = to - from;
3990         if (newLength &lt; 0)
3991             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
3992         @SuppressWarnings(&quot;unchecked&quot;)
3993         T[] copy = ((Object)newType == (Object)Object[].class)
3994             ? (T[]) new Object[newLength]
3995             : (T[]) Array.newInstance(newType.getComponentType(), newLength);
3996         System.arraycopy(original, from, copy, 0,
3997                          Math.min(original.length - from, newLength));
3998         return copy;
3999     }
4000 
4001     /**
4002      * Copies the specified range of the specified array into a new array.
4003      * The initial index of the range ({@code from}) must lie between zero
4004      * and {@code original.length}, inclusive.  The value at
4005      * {@code original[from]} is placed into the initial element of the copy
4006      * (unless {@code from == original.length} or {@code from == to}).
4007      * Values from subsequent elements in the original array are placed into
4008      * subsequent elements in the copy.  The final index of the range
4009      * ({@code to}), which must be greater than or equal to {@code from},
4010      * may be greater than {@code original.length}, in which case
4011      * {@code (byte)0} is placed in all elements of the copy whose index is
4012      * greater than or equal to {@code original.length - from}.  The length
4013      * of the returned array will be {@code to - from}.
4014      *
4015      * @param original the array from which a range is to be copied
4016      * @param from the initial index of the range to be copied, inclusive
4017      * @param to the final index of the range to be copied, exclusive.
4018      *     (This index may lie outside the array.)
4019      * @return a new array containing the specified range from the original array,
4020      *     truncated or padded with zeros to obtain the required length
4021      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4022      *     or {@code from &gt; original.length}
4023      * @throws IllegalArgumentException if {@code from &gt; to}
4024      * @throws NullPointerException if {@code original} is null
4025      * @since 1.6
4026      */
4027     public static byte[] copyOfRange(byte[] original, int from, int to) {
4028         int newLength = to - from;
4029         if (newLength &lt; 0)
4030             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4031         byte[] copy = new byte[newLength];
4032         System.arraycopy(original, from, copy, 0,
4033                          Math.min(original.length - from, newLength));
4034         return copy;
4035     }
4036 
4037     /**
4038      * Copies the specified range of the specified array into a new array.
4039      * The initial index of the range ({@code from}) must lie between zero
4040      * and {@code original.length}, inclusive.  The value at
4041      * {@code original[from]} is placed into the initial element of the copy
4042      * (unless {@code from == original.length} or {@code from == to}).
4043      * Values from subsequent elements in the original array are placed into
4044      * subsequent elements in the copy.  The final index of the range
4045      * ({@code to}), which must be greater than or equal to {@code from},
4046      * may be greater than {@code original.length}, in which case
4047      * {@code (short)0} is placed in all elements of the copy whose index is
4048      * greater than or equal to {@code original.length - from}.  The length
4049      * of the returned array will be {@code to - from}.
4050      *
4051      * @param original the array from which a range is to be copied
4052      * @param from the initial index of the range to be copied, inclusive
4053      * @param to the final index of the range to be copied, exclusive.
4054      *     (This index may lie outside the array.)
4055      * @return a new array containing the specified range from the original array,
4056      *     truncated or padded with zeros to obtain the required length
4057      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4058      *     or {@code from &gt; original.length}
4059      * @throws IllegalArgumentException if {@code from &gt; to}
4060      * @throws NullPointerException if {@code original} is null
4061      * @since 1.6
4062      */
4063     public static short[] copyOfRange(short[] original, int from, int to) {
4064         int newLength = to - from;
4065         if (newLength &lt; 0)
4066             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4067         short[] copy = new short[newLength];
4068         System.arraycopy(original, from, copy, 0,
4069                          Math.min(original.length - from, newLength));
4070         return copy;
4071     }
4072 
4073     /**
4074      * Copies the specified range of the specified array into a new array.
4075      * The initial index of the range ({@code from}) must lie between zero
4076      * and {@code original.length}, inclusive.  The value at
4077      * {@code original[from]} is placed into the initial element of the copy
4078      * (unless {@code from == original.length} or {@code from == to}).
4079      * Values from subsequent elements in the original array are placed into
4080      * subsequent elements in the copy.  The final index of the range
4081      * ({@code to}), which must be greater than or equal to {@code from},
4082      * may be greater than {@code original.length}, in which case
4083      * {@code 0} is placed in all elements of the copy whose index is
4084      * greater than or equal to {@code original.length - from}.  The length
4085      * of the returned array will be {@code to - from}.
4086      *
4087      * @param original the array from which a range is to be copied
4088      * @param from the initial index of the range to be copied, inclusive
4089      * @param to the final index of the range to be copied, exclusive.
4090      *     (This index may lie outside the array.)
4091      * @return a new array containing the specified range from the original array,
4092      *     truncated or padded with zeros to obtain the required length
4093      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4094      *     or {@code from &gt; original.length}
4095      * @throws IllegalArgumentException if {@code from &gt; to}
4096      * @throws NullPointerException if {@code original} is null
4097      * @since 1.6
4098      */
4099     public static int[] copyOfRange(int[] original, int from, int to) {
4100         int newLength = to - from;
4101         if (newLength &lt; 0)
4102             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4103         int[] copy = new int[newLength];
4104         System.arraycopy(original, from, copy, 0,
4105                          Math.min(original.length - from, newLength));
4106         return copy;
4107     }
4108 
4109     /**
4110      * Copies the specified range of the specified array into a new array.
4111      * The initial index of the range ({@code from}) must lie between zero
4112      * and {@code original.length}, inclusive.  The value at
4113      * {@code original[from]} is placed into the initial element of the copy
4114      * (unless {@code from == original.length} or {@code from == to}).
4115      * Values from subsequent elements in the original array are placed into
4116      * subsequent elements in the copy.  The final index of the range
4117      * ({@code to}), which must be greater than or equal to {@code from},
4118      * may be greater than {@code original.length}, in which case
4119      * {@code 0L} is placed in all elements of the copy whose index is
4120      * greater than or equal to {@code original.length - from}.  The length
4121      * of the returned array will be {@code to - from}.
4122      *
4123      * @param original the array from which a range is to be copied
4124      * @param from the initial index of the range to be copied, inclusive
4125      * @param to the final index of the range to be copied, exclusive.
4126      *     (This index may lie outside the array.)
4127      * @return a new array containing the specified range from the original array,
4128      *     truncated or padded with zeros to obtain the required length
4129      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4130      *     or {@code from &gt; original.length}
4131      * @throws IllegalArgumentException if {@code from &gt; to}
4132      * @throws NullPointerException if {@code original} is null
4133      * @since 1.6
4134      */
4135     public static long[] copyOfRange(long[] original, int from, int to) {
4136         int newLength = to - from;
4137         if (newLength &lt; 0)
4138             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4139         long[] copy = new long[newLength];
4140         System.arraycopy(original, from, copy, 0,
4141                          Math.min(original.length - from, newLength));
4142         return copy;
4143     }
4144 
4145     /**
4146      * Copies the specified range of the specified array into a new array.
4147      * The initial index of the range ({@code from}) must lie between zero
4148      * and {@code original.length}, inclusive.  The value at
4149      * {@code original[from]} is placed into the initial element of the copy
4150      * (unless {@code from == original.length} or {@code from == to}).
4151      * Values from subsequent elements in the original array are placed into
4152      * subsequent elements in the copy.  The final index of the range
4153      * ({@code to}), which must be greater than or equal to {@code from},
4154      * may be greater than {@code original.length}, in which case
4155      * {@code &#39;\\u000&#39;} is placed in all elements of the copy whose index is
4156      * greater than or equal to {@code original.length - from}.  The length
4157      * of the returned array will be {@code to - from}.
4158      *
4159      * @param original the array from which a range is to be copied
4160      * @param from the initial index of the range to be copied, inclusive
4161      * @param to the final index of the range to be copied, exclusive.
4162      *     (This index may lie outside the array.)
4163      * @return a new array containing the specified range from the original array,
4164      *     truncated or padded with null characters to obtain the required length
4165      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4166      *     or {@code from &gt; original.length}
4167      * @throws IllegalArgumentException if {@code from &gt; to}
4168      * @throws NullPointerException if {@code original} is null
4169      * @since 1.6
4170      */
4171     public static char[] copyOfRange(char[] original, int from, int to) {
4172         int newLength = to - from;
4173         if (newLength &lt; 0)
4174             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4175         char[] copy = new char[newLength];
4176         System.arraycopy(original, from, copy, 0,
4177                          Math.min(original.length - from, newLength));
4178         return copy;
4179     }
4180 
4181     /**
4182      * Copies the specified range of the specified array into a new array.
4183      * The initial index of the range ({@code from}) must lie between zero
4184      * and {@code original.length}, inclusive.  The value at
4185      * {@code original[from]} is placed into the initial element of the copy
4186      * (unless {@code from == original.length} or {@code from == to}).
4187      * Values from subsequent elements in the original array are placed into
4188      * subsequent elements in the copy.  The final index of the range
4189      * ({@code to}), which must be greater than or equal to {@code from},
4190      * may be greater than {@code original.length}, in which case
4191      * {@code 0f} is placed in all elements of the copy whose index is
4192      * greater than or equal to {@code original.length - from}.  The length
4193      * of the returned array will be {@code to - from}.
4194      *
4195      * @param original the array from which a range is to be copied
4196      * @param from the initial index of the range to be copied, inclusive
4197      * @param to the final index of the range to be copied, exclusive.
4198      *     (This index may lie outside the array.)
4199      * @return a new array containing the specified range from the original array,
4200      *     truncated or padded with zeros to obtain the required length
4201      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4202      *     or {@code from &gt; original.length}
4203      * @throws IllegalArgumentException if {@code from &gt; to}
4204      * @throws NullPointerException if {@code original} is null
4205      * @since 1.6
4206      */
4207     public static float[] copyOfRange(float[] original, int from, int to) {
4208         int newLength = to - from;
4209         if (newLength &lt; 0)
4210             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4211         float[] copy = new float[newLength];
4212         System.arraycopy(original, from, copy, 0,
4213                          Math.min(original.length - from, newLength));
4214         return copy;
4215     }
4216 
4217     /**
4218      * Copies the specified range of the specified array into a new array.
4219      * The initial index of the range ({@code from}) must lie between zero
4220      * and {@code original.length}, inclusive.  The value at
4221      * {@code original[from]} is placed into the initial element of the copy
4222      * (unless {@code from == original.length} or {@code from == to}).
4223      * Values from subsequent elements in the original array are placed into
4224      * subsequent elements in the copy.  The final index of the range
4225      * ({@code to}), which must be greater than or equal to {@code from},
4226      * may be greater than {@code original.length}, in which case
4227      * {@code 0d} is placed in all elements of the copy whose index is
4228      * greater than or equal to {@code original.length - from}.  The length
4229      * of the returned array will be {@code to - from}.
4230      *
4231      * @param original the array from which a range is to be copied
4232      * @param from the initial index of the range to be copied, inclusive
4233      * @param to the final index of the range to be copied, exclusive.
4234      *     (This index may lie outside the array.)
4235      * @return a new array containing the specified range from the original array,
4236      *     truncated or padded with zeros to obtain the required length
4237      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4238      *     or {@code from &gt; original.length}
4239      * @throws IllegalArgumentException if {@code from &gt; to}
4240      * @throws NullPointerException if {@code original} is null
4241      * @since 1.6
4242      */
4243     public static double[] copyOfRange(double[] original, int from, int to) {
4244         int newLength = to - from;
4245         if (newLength &lt; 0)
4246             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4247         double[] copy = new double[newLength];
4248         System.arraycopy(original, from, copy, 0,
4249                          Math.min(original.length - from, newLength));
4250         return copy;
4251     }
4252 
4253     /**
4254      * Copies the specified range of the specified array into a new array.
4255      * The initial index of the range ({@code from}) must lie between zero
4256      * and {@code original.length}, inclusive.  The value at
4257      * {@code original[from]} is placed into the initial element of the copy
4258      * (unless {@code from == original.length} or {@code from == to}).
4259      * Values from subsequent elements in the original array are placed into
4260      * subsequent elements in the copy.  The final index of the range
4261      * ({@code to}), which must be greater than or equal to {@code from},
4262      * may be greater than {@code original.length}, in which case
4263      * {@code false} is placed in all elements of the copy whose index is
4264      * greater than or equal to {@code original.length - from}.  The length
4265      * of the returned array will be {@code to - from}.
4266      *
4267      * @param original the array from which a range is to be copied
4268      * @param from the initial index of the range to be copied, inclusive
4269      * @param to the final index of the range to be copied, exclusive.
4270      *     (This index may lie outside the array.)
4271      * @return a new array containing the specified range from the original array,
4272      *     truncated or padded with false elements to obtain the required length
4273      * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
4274      *     or {@code from &gt; original.length}
4275      * @throws IllegalArgumentException if {@code from &gt; to}
4276      * @throws NullPointerException if {@code original} is null
4277      * @since 1.6
4278      */
4279     public static boolean[] copyOfRange(boolean[] original, int from, int to) {
4280         int newLength = to - from;
4281         if (newLength &lt; 0)
4282             throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
4283         boolean[] copy = new boolean[newLength];
4284         System.arraycopy(original, from, copy, 0,
4285                          Math.min(original.length - from, newLength));
4286         return copy;
4287     }
4288 
4289     // Misc
4290 
4291     /**
4292      * Returns a fixed-size list backed by the specified array. Changes made to
4293      * the array will be visible in the returned list, and changes made to the
4294      * list will be visible in the array. The returned list is
4295      * {@link Serializable} and implements {@link RandomAccess}.
4296      *
4297      * &lt;p&gt;The returned list implements the optional {@code Collection} methods, except
4298      * those that would change the size of the returned list. Those methods leave
4299      * the list unchanged and throw {@link UnsupportedOperationException}.
4300      *
4301      * @apiNote
4302      * This method acts as bridge between array-based and collection-based
4303      * APIs, in combination with {@link Collection#toArray}.
4304      *
4305      * &lt;p&gt;This method provides a way to wrap an existing array:
4306      * &lt;pre&gt;{@code
4307      *     Integer[] numbers = ...
4308      *     ...
4309      *     List&lt;Integer&gt; values = Arrays.asList(numbers);
4310      * }&lt;/pre&gt;
4311      *
4312      * &lt;p&gt;This method also provides a convenient way to create a fixed-size
4313      * list initialized to contain several elements:
4314      * &lt;pre&gt;{@code
4315      *     List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
4316      * }&lt;/pre&gt;
4317      *
4318      * &lt;p&gt;&lt;em&gt;The list returned by this method is modifiable.&lt;/em&gt;
4319      * To create an unmodifiable list, use
4320      * {@link Collections#unmodifiableList Collections.unmodifiableList}
4321      * or &lt;a href=&quot;List.html#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt;.
4322      *
4323      * @param &lt;T&gt; the class of the objects in the array
4324      * @param a the array by which the list will be backed
4325      * @return a list view of the specified array
4326      * @throws NullPointerException if the specified array is {@code null}
4327      */
4328     @SafeVarargs
4329     @SuppressWarnings(&quot;varargs&quot;)
4330     public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
4331         return new ArrayList&lt;&gt;(a);
4332     }
4333 
4334     /**
4335      * @serial include
4336      */
4337     private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
4338         implements RandomAccess, java.io.Serializable
4339     {
4340         private static final long serialVersionUID = -2764017481108945198L;
4341         private final E[] a;
4342 
4343         ArrayList(E[] array) {
4344             a = Objects.requireNonNull(array);
4345         }
4346 
4347         @Override
4348         public int size() {
4349             return a.length;
4350         }
4351 
4352         @Override
4353         public Object[] toArray() {
4354             return Arrays.copyOf(a, a.length, Object[].class);
4355         }
4356 
4357         @Override
4358         @SuppressWarnings(&quot;unchecked&quot;)
4359         public &lt;T&gt; T[] toArray(T[] a) {
4360             int size = size();
4361             if (a.length &lt; size)
4362                 return Arrays.copyOf(this.a, size,
4363                                      (Class&lt;? extends T[]&gt;) a.getClass());
4364             System.arraycopy(this.a, 0, a, 0, size);
4365             if (a.length &gt; size)
4366                 a[size] = null;
4367             return a;
4368         }
4369 
4370         @Override
4371         public E get(int index) {
4372             return a[index];
4373         }
4374 
4375         @Override
4376         public E set(int index, E element) {
4377             E oldValue = a[index];
4378             a[index] = element;
4379             return oldValue;
4380         }
4381 
4382         @Override
4383         public int indexOf(Object o) {
4384             E[] a = this.a;
4385             if (o == null) {
4386                 for (int i = 0; i &lt; a.length; i++)
4387                     if (a[i] == null)
4388                         return i;
4389             } else {
4390                 for (int i = 0; i &lt; a.length; i++)
4391                     if (o.equals(a[i]))
4392                         return i;
4393             }
4394             return -1;
4395         }
4396 
4397         @Override
4398         public boolean contains(Object o) {
4399             return indexOf(o) &gt;= 0;
4400         }
4401 
4402         @Override
4403         public Spliterator&lt;E&gt; spliterator() {
4404             return Spliterators.spliterator(a, Spliterator.ORDERED);
4405         }
4406 
4407         @Override
4408         public void forEach(Consumer&lt;? super E&gt; action) {
4409             Objects.requireNonNull(action);
4410             for (E e : a) {
4411                 action.accept(e);
4412             }
4413         }
4414 
4415         @Override
4416         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
4417             Objects.requireNonNull(operator);
4418             E[] a = this.a;
4419             for (int i = 0; i &lt; a.length; i++) {
4420                 a[i] = operator.apply(a[i]);
4421             }
4422         }
4423 
4424         @Override
4425         public void sort(Comparator&lt;? super E&gt; c) {
4426             Arrays.sort(a, c);
4427         }
4428 
4429         @Override
4430         public Iterator&lt;E&gt; iterator() {
4431             return new ArrayItr&lt;&gt;(a);
4432         }
4433     }
4434 
4435     private static class ArrayItr&lt;E&gt; implements Iterator&lt;E&gt; {
4436         private int cursor;
4437         private final E[] a;
4438 
4439         ArrayItr(E[] a) {
4440             this.a = a;
4441         }
4442 
4443         @Override
4444         public boolean hasNext() {
4445             return cursor &lt; a.length;
4446         }
4447 
4448         @Override
4449         public E next() {
4450             int i = cursor;
4451             if (i &gt;= a.length) {
4452                 throw new NoSuchElementException();
4453             }
4454             cursor = i + 1;
4455             return a[i];
4456         }
4457     }
4458 
4459     /**
4460      * Returns a hash code based on the contents of the specified array.
4461      * For any two {@code long} arrays {@code a} and {@code b}
4462      * such that {@code Arrays.equals(a, b)}, it is also the case that
4463      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4464      *
4465      * &lt;p&gt;The value returned by this method is the same value that would be
4466      * obtained by invoking the {@link List#hashCode() hashCode}
4467      * method on a {@link List} containing a sequence of {@link Long}
4468      * instances representing the elements of {@code a} in the same order.
4469      * If {@code a} is {@code null}, this method returns 0.
4470      *
4471      * @param a the array whose hash value to compute
4472      * @return a content-based hash code for {@code a}
4473      * @since 1.5
4474      */
4475     public static int hashCode(long a[]) {
4476         if (a == null)
4477             return 0;
4478 
4479         int result = 1;
4480         for (long element : a) {
4481             int elementHash = (int)(element ^ (element &gt;&gt;&gt; 32));
4482             result = 31 * result + elementHash;
4483         }
4484 
4485         return result;
4486     }
4487 
4488     /**
4489      * Returns a hash code based on the contents of the specified array.
4490      * For any two non-null {@code int} arrays {@code a} and {@code b}
4491      * such that {@code Arrays.equals(a, b)}, it is also the case that
4492      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4493      *
4494      * &lt;p&gt;The value returned by this method is the same value that would be
4495      * obtained by invoking the {@link List#hashCode() hashCode}
4496      * method on a {@link List} containing a sequence of {@link Integer}
4497      * instances representing the elements of {@code a} in the same order.
4498      * If {@code a} is {@code null}, this method returns 0.
4499      *
4500      * @param a the array whose hash value to compute
4501      * @return a content-based hash code for {@code a}
4502      * @since 1.5
4503      */
4504     public static int hashCode(int a[]) {
4505         if (a == null)
4506             return 0;
4507 
4508         int result = 1;
4509         for (int element : a)
4510             result = 31 * result + element;
4511 
4512         return result;
4513     }
4514 
4515     /**
4516      * Returns a hash code based on the contents of the specified array.
4517      * For any two {@code short} arrays {@code a} and {@code b}
4518      * such that {@code Arrays.equals(a, b)}, it is also the case that
4519      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4520      *
4521      * &lt;p&gt;The value returned by this method is the same value that would be
4522      * obtained by invoking the {@link List#hashCode() hashCode}
4523      * method on a {@link List} containing a sequence of {@link Short}
4524      * instances representing the elements of {@code a} in the same order.
4525      * If {@code a} is {@code null}, this method returns 0.
4526      *
4527      * @param a the array whose hash value to compute
4528      * @return a content-based hash code for {@code a}
4529      * @since 1.5
4530      */
4531     public static int hashCode(short a[]) {
4532         if (a == null)
4533             return 0;
4534 
4535         int result = 1;
4536         for (short element : a)
4537             result = 31 * result + element;
4538 
4539         return result;
4540     }
4541 
4542     /**
4543      * Returns a hash code based on the contents of the specified array.
4544      * For any two {@code char} arrays {@code a} and {@code b}
4545      * such that {@code Arrays.equals(a, b)}, it is also the case that
4546      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4547      *
4548      * &lt;p&gt;The value returned by this method is the same value that would be
4549      * obtained by invoking the {@link List#hashCode() hashCode}
4550      * method on a {@link List} containing a sequence of {@link Character}
4551      * instances representing the elements of {@code a} in the same order.
4552      * If {@code a} is {@code null}, this method returns 0.
4553      *
4554      * @param a the array whose hash value to compute
4555      * @return a content-based hash code for {@code a}
4556      * @since 1.5
4557      */
4558     public static int hashCode(char a[]) {
4559         if (a == null)
4560             return 0;
4561 
4562         int result = 1;
4563         for (char element : a)
4564             result = 31 * result + element;
4565 
4566         return result;
4567     }
4568 
4569     /**
4570      * Returns a hash code based on the contents of the specified array.
4571      * For any two {@code byte} arrays {@code a} and {@code b}
4572      * such that {@code Arrays.equals(a, b)}, it is also the case that
4573      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4574      *
4575      * &lt;p&gt;The value returned by this method is the same value that would be
4576      * obtained by invoking the {@link List#hashCode() hashCode}
4577      * method on a {@link List} containing a sequence of {@link Byte}
4578      * instances representing the elements of {@code a} in the same order.
4579      * If {@code a} is {@code null}, this method returns 0.
4580      *
4581      * @param a the array whose hash value to compute
4582      * @return a content-based hash code for {@code a}
4583      * @since 1.5
4584      */
4585     public static int hashCode(byte a[]) {
4586         if (a == null)
4587             return 0;
4588 
4589         int result = 1;
4590         for (byte element : a)
4591             result = 31 * result + element;
4592 
4593         return result;
4594     }
4595 
4596     /**
4597      * Returns a hash code based on the contents of the specified array.
4598      * For any two {@code boolean} arrays {@code a} and {@code b}
4599      * such that {@code Arrays.equals(a, b)}, it is also the case that
4600      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4601      *
4602      * &lt;p&gt;The value returned by this method is the same value that would be
4603      * obtained by invoking the {@link List#hashCode() hashCode}
4604      * method on a {@link List} containing a sequence of {@link Boolean}
4605      * instances representing the elements of {@code a} in the same order.
4606      * If {@code a} is {@code null}, this method returns 0.
4607      *
4608      * @param a the array whose hash value to compute
4609      * @return a content-based hash code for {@code a}
4610      * @since 1.5
4611      */
4612     public static int hashCode(boolean a[]) {
4613         if (a == null)
4614             return 0;
4615 
4616         int result = 1;
4617         for (boolean element : a)
4618             result = 31 * result + (element ? 1231 : 1237);
4619 
4620         return result;
4621     }
4622 
4623     /**
4624      * Returns a hash code based on the contents of the specified array.
4625      * For any two {@code float} arrays {@code a} and {@code b}
4626      * such that {@code Arrays.equals(a, b)}, it is also the case that
4627      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4628      *
4629      * &lt;p&gt;The value returned by this method is the same value that would be
4630      * obtained by invoking the {@link List#hashCode() hashCode}
4631      * method on a {@link List} containing a sequence of {@link Float}
4632      * instances representing the elements of {@code a} in the same order.
4633      * If {@code a} is {@code null}, this method returns 0.
4634      *
4635      * @param a the array whose hash value to compute
4636      * @return a content-based hash code for {@code a}
4637      * @since 1.5
4638      */
4639     public static int hashCode(float a[]) {
4640         if (a == null)
4641             return 0;
4642 
4643         int result = 1;
4644         for (float element : a)
4645             result = 31 * result + Float.floatToIntBits(element);
4646 
4647         return result;
4648     }
4649 
4650     /**
4651      * Returns a hash code based on the contents of the specified array.
4652      * For any two {@code double} arrays {@code a} and {@code b}
4653      * such that {@code Arrays.equals(a, b)}, it is also the case that
4654      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4655      *
4656      * &lt;p&gt;The value returned by this method is the same value that would be
4657      * obtained by invoking the {@link List#hashCode() hashCode}
4658      * method on a {@link List} containing a sequence of {@link Double}
4659      * instances representing the elements of {@code a} in the same order.
4660      * If {@code a} is {@code null}, this method returns 0.
4661      *
4662      * @param a the array whose hash value to compute
4663      * @return a content-based hash code for {@code a}
4664      * @since 1.5
4665      */
4666     public static int hashCode(double a[]) {
4667         if (a == null)
4668             return 0;
4669 
4670         int result = 1;
4671         for (double element : a) {
4672             long bits = Double.doubleToLongBits(element);
4673             result = 31 * result + (int)(bits ^ (bits &gt;&gt;&gt; 32));
4674         }
4675         return result;
4676     }
4677 
4678     /**
4679      * Returns a hash code based on the contents of the specified array.  If
4680      * the array contains other arrays as elements, the hash code is based on
4681      * their identities rather than their contents.  It is therefore
4682      * acceptable to invoke this method on an array that contains itself as an
4683      * element,  either directly or indirectly through one or more levels of
4684      * arrays.
4685      *
4686      * &lt;p&gt;For any two arrays {@code a} and {@code b} such that
4687      * {@code Arrays.equals(a, b)}, it is also the case that
4688      * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.
4689      *
4690      * &lt;p&gt;The value returned by this method is equal to the value that would
4691      * be returned by {@code Arrays.asList(a).hashCode()}, unless {@code a}
4692      * is {@code null}, in which case {@code 0} is returned.
4693      *
4694      * @param a the array whose content-based hash code to compute
4695      * @return a content-based hash code for {@code a}
4696      * @see #deepHashCode(Object[])
4697      * @since 1.5
4698      */
4699     public static int hashCode(Object a[]) {
4700         if (a == null)
4701             return 0;
4702 
4703         int result = 1;
4704 
4705         for (Object element : a)
4706             result = 31 * result + (element == null ? 0 : element.hashCode());
4707 
4708         return result;
4709     }
4710 
4711     /**
4712      * Returns a hash code based on the &quot;deep contents&quot; of the specified
4713      * array.  If the array contains other arrays as elements, the
4714      * hash code is based on their contents and so on, ad infinitum.
4715      * It is therefore unacceptable to invoke this method on an array that
4716      * contains itself as an element, either directly or indirectly through
4717      * one or more levels of arrays.  The behavior of such an invocation is
4718      * undefined.
4719      *
4720      * &lt;p&gt;For any two arrays {@code a} and {@code b} such that
4721      * {@code Arrays.deepEquals(a, b)}, it is also the case that
4722      * {@code Arrays.deepHashCode(a) == Arrays.deepHashCode(b)}.
4723      *
4724      * &lt;p&gt;The computation of the value returned by this method is similar to
4725      * that of the value returned by {@link List#hashCode()} on a list
4726      * containing the same elements as {@code a} in the same order, with one
4727      * difference: If an element {@code e} of {@code a} is itself an array,
4728      * its hash code is computed not by calling {@code e.hashCode()}, but as
4729      * by calling the appropriate overloading of {@code Arrays.hashCode(e)}
4730      * if {@code e} is an array of a primitive type, or as by calling
4731      * {@code Arrays.deepHashCode(e)} recursively if {@code e} is an array
4732      * of a reference type.  If {@code a} is {@code null}, this method
4733      * returns 0.
4734      *
4735      * @param a the array whose deep-content-based hash code to compute
4736      * @return a deep-content-based hash code for {@code a}
4737      * @see #hashCode(Object[])
4738      * @since 1.5
4739      */
4740     public static int deepHashCode(Object a[]) {
4741         if (a == null)
4742             return 0;
4743 
4744         int result = 1;
4745 
4746         for (Object element : a) {
4747             final int elementHash;
4748             final Class&lt;?&gt; cl;
4749             if (element == null)
4750                 elementHash = 0;
4751             else if ((cl = element.getClass().getComponentType()) == null)
4752                 elementHash = element.hashCode();
4753             else if (element instanceof Object[])
4754                 elementHash = deepHashCode((Object[]) element);
4755             else
4756                 elementHash = primitiveArrayHashCode(element, cl);
4757 
4758             result = 31 * result + elementHash;
4759         }
4760 
4761         return result;
4762     }
4763 
4764     private static int primitiveArrayHashCode(Object a, Class&lt;?&gt; cl) {
4765         return
4766             (cl == byte.class)    ? hashCode((byte[]) a)    :
4767             (cl == int.class)     ? hashCode((int[]) a)     :
4768             (cl == long.class)    ? hashCode((long[]) a)    :
4769             (cl == char.class)    ? hashCode((char[]) a)    :
4770             (cl == short.class)   ? hashCode((short[]) a)   :
4771             (cl == boolean.class) ? hashCode((boolean[]) a) :
4772             (cl == double.class)  ? hashCode((double[]) a)  :
4773             // If new primitive types are ever added, this method must be
4774             // expanded or we will fail here with ClassCastException.
4775             hashCode((float[]) a);
4776     }
4777 
4778     /**
4779      * Returns {@code true} if the two specified arrays are &lt;i&gt;deeply
4780      * equal&lt;/i&gt; to one another.  Unlike the {@link #equals(Object[],Object[])}
4781      * method, this method is appropriate for use with nested arrays of
4782      * arbitrary depth.
4783      *
4784      * &lt;p&gt;Two array references are considered deeply equal if both
4785      * are {@code null}, or if they refer to arrays that contain the same
4786      * number of elements and all corresponding pairs of elements in the two
4787      * arrays are deeply equal.
4788      *
4789      * &lt;p&gt;Two possibly {@code null} elements {@code e1} and {@code e2} are
4790      * deeply equal if any of the following conditions hold:
4791      * &lt;ul&gt;
4792      *    &lt;li&gt; {@code e1} and {@code e2} are both arrays of object reference
4793      *         types, and {@code Arrays.deepEquals(e1, e2) would return true}
4794      *    &lt;li&gt; {@code e1} and {@code e2} are arrays of the same primitive
4795      *         type, and the appropriate overloading of
4796      *         {@code Arrays.equals(e1, e2)} would return true.
4797      *    &lt;li&gt; {@code e1 == e2}
4798      *    &lt;li&gt; {@code e1.equals(e2)} would return true.
4799      * &lt;/ul&gt;
4800      * Note that this definition permits {@code null} elements at any depth.
4801      *
4802      * &lt;p&gt;If either of the specified arrays contain themselves as elements
4803      * either directly or indirectly through one or more levels of arrays,
4804      * the behavior of this method is undefined.
4805      *
4806      * @param a1 one array to be tested for equality
4807      * @param a2 the other array to be tested for equality
4808      * @return {@code true} if the two arrays are equal
4809      * @see #equals(Object[],Object[])
4810      * @see Objects#deepEquals(Object, Object)
4811      * @since 1.5
4812      */
4813     public static boolean deepEquals(Object[] a1, Object[] a2) {
4814         if (a1 == a2)
4815             return true;
4816         if (a1 == null || a2==null)
4817             return false;
4818         int length = a1.length;
4819         if (a2.length != length)
4820             return false;
4821 
4822         for (int i = 0; i &lt; length; i++) {
4823             Object e1 = a1[i];
4824             Object e2 = a2[i];
4825 
4826             if (e1 == e2)
4827                 continue;
4828             if (e1 == null)
4829                 return false;
4830 
4831             // Figure out whether the two elements are equal
4832             boolean eq = deepEquals0(e1, e2);
4833 
4834             if (!eq)
4835                 return false;
4836         }
4837         return true;
4838     }
4839 
4840     static boolean deepEquals0(Object e1, Object e2) {
4841         assert e1 != null;
4842         boolean eq;
4843         if (e1 instanceof Object[] &amp;&amp; e2 instanceof Object[])
4844             eq = deepEquals ((Object[]) e1, (Object[]) e2);
4845         else if (e1 instanceof byte[] &amp;&amp; e2 instanceof byte[])
4846             eq = equals((byte[]) e1, (byte[]) e2);
4847         else if (e1 instanceof short[] &amp;&amp; e2 instanceof short[])
4848             eq = equals((short[]) e1, (short[]) e2);
4849         else if (e1 instanceof int[] &amp;&amp; e2 instanceof int[])
4850             eq = equals((int[]) e1, (int[]) e2);
4851         else if (e1 instanceof long[] &amp;&amp; e2 instanceof long[])
4852             eq = equals((long[]) e1, (long[]) e2);
4853         else if (e1 instanceof char[] &amp;&amp; e2 instanceof char[])
4854             eq = equals((char[]) e1, (char[]) e2);
4855         else if (e1 instanceof float[] &amp;&amp; e2 instanceof float[])
4856             eq = equals((float[]) e1, (float[]) e2);
4857         else if (e1 instanceof double[] &amp;&amp; e2 instanceof double[])
4858             eq = equals((double[]) e1, (double[]) e2);
4859         else if (e1 instanceof boolean[] &amp;&amp; e2 instanceof boolean[])
4860             eq = equals((boolean[]) e1, (boolean[]) e2);
4861         else
4862             eq = e1.equals(e2);
4863         return eq;
4864     }
4865 
4866     /**
4867      * Returns a string representation of the contents of the specified array.
4868      * The string representation consists of a list of the array&#39;s elements,
4869      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
4870      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
4871      * space).  Elements are converted to strings as by
4872      * {@code String.valueOf(long)}.  Returns {@code &quot;null&quot;} if {@code a}
4873      * is {@code null}.
4874      *
4875      * @param a the array whose string representation to return
4876      * @return a string representation of {@code a}
4877      * @since 1.5
4878      */
4879     public static String toString(long[] a) {
4880         if (a == null)
4881             return &quot;null&quot;;
4882         int iMax = a.length - 1;
4883         if (iMax == -1)
4884             return &quot;[]&quot;;
4885 
4886         StringBuilder b = new StringBuilder();
4887         b.append(&#39;[&#39;);
4888         for (int i = 0; ; i++) {
4889             b.append(a[i]);
4890             if (i == iMax)
4891                 return b.append(&#39;]&#39;).toString();
4892             b.append(&quot;, &quot;);
4893         }
4894     }
4895 
4896     /**
4897      * Returns a string representation of the contents of the specified array.
4898      * The string representation consists of a list of the array&#39;s elements,
4899      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
4900      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
4901      * space).  Elements are converted to strings as by
4902      * {@code String.valueOf(int)}.  Returns {@code &quot;null&quot;} if {@code a} is
4903      * {@code null}.
4904      *
4905      * @param a the array whose string representation to return
4906      * @return a string representation of {@code a}
4907      * @since 1.5
4908      */
4909     public static String toString(int[] a) {
4910         if (a == null)
4911             return &quot;null&quot;;
4912         int iMax = a.length - 1;
4913         if (iMax == -1)
4914             return &quot;[]&quot;;
4915 
4916         StringBuilder b = new StringBuilder();
4917         b.append(&#39;[&#39;);
4918         for (int i = 0; ; i++) {
4919             b.append(a[i]);
4920             if (i == iMax)
4921                 return b.append(&#39;]&#39;).toString();
4922             b.append(&quot;, &quot;);
4923         }
4924     }
4925 
4926     /**
4927      * Returns a string representation of the contents of the specified array.
4928      * The string representation consists of a list of the array&#39;s elements,
4929      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
4930      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
4931      * space).  Elements are converted to strings as by
4932      * {@code String.valueOf(short)}.  Returns {@code &quot;null&quot;} if {@code a}
4933      * is {@code null}.
4934      *
4935      * @param a the array whose string representation to return
4936      * @return a string representation of {@code a}
4937      * @since 1.5
4938      */
4939     public static String toString(short[] a) {
4940         if (a == null)
4941             return &quot;null&quot;;
4942         int iMax = a.length - 1;
4943         if (iMax == -1)
4944             return &quot;[]&quot;;
4945 
4946         StringBuilder b = new StringBuilder();
4947         b.append(&#39;[&#39;);
4948         for (int i = 0; ; i++) {
4949             b.append(a[i]);
4950             if (i == iMax)
4951                 return b.append(&#39;]&#39;).toString();
4952             b.append(&quot;, &quot;);
4953         }
4954     }
4955 
4956     /**
4957      * Returns a string representation of the contents of the specified array.
4958      * The string representation consists of a list of the array&#39;s elements,
4959      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
4960      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
4961      * space).  Elements are converted to strings as by
4962      * {@code String.valueOf(char)}.  Returns {@code &quot;null&quot;} if {@code a}
4963      * is {@code null}.
4964      *
4965      * @param a the array whose string representation to return
4966      * @return a string representation of {@code a}
4967      * @since 1.5
4968      */
4969     public static String toString(char[] a) {
4970         if (a == null)
4971             return &quot;null&quot;;
4972         int iMax = a.length - 1;
4973         if (iMax == -1)
4974             return &quot;[]&quot;;
4975 
4976         StringBuilder b = new StringBuilder();
4977         b.append(&#39;[&#39;);
4978         for (int i = 0; ; i++) {
4979             b.append(a[i]);
4980             if (i == iMax)
4981                 return b.append(&#39;]&#39;).toString();
4982             b.append(&quot;, &quot;);
4983         }
4984     }
4985 
4986     /**
4987      * Returns a string representation of the contents of the specified array.
4988      * The string representation consists of a list of the array&#39;s elements,
4989      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements
4990      * are separated by the characters {@code &quot;, &quot;} (a comma followed
4991      * by a space).  Elements are converted to strings as by
4992      * {@code String.valueOf(byte)}.  Returns {@code &quot;null&quot;} if
4993      * {@code a} is {@code null}.
4994      *
4995      * @param a the array whose string representation to return
4996      * @return a string representation of {@code a}
4997      * @since 1.5
4998      */
4999     public static String toString(byte[] a) {
5000         if (a == null)
5001             return &quot;null&quot;;
5002         int iMax = a.length - 1;
5003         if (iMax == -1)
5004             return &quot;[]&quot;;
5005 
5006         StringBuilder b = new StringBuilder();
5007         b.append(&#39;[&#39;);
5008         for (int i = 0; ; i++) {
5009             b.append(a[i]);
5010             if (i == iMax)
5011                 return b.append(&#39;]&#39;).toString();
5012             b.append(&quot;, &quot;);
5013         }
5014     }
5015 
5016     /**
5017      * Returns a string representation of the contents of the specified array.
5018      * The string representation consists of a list of the array&#39;s elements,
5019      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
5020      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
5021      * space).  Elements are converted to strings as by
5022      * {@code String.valueOf(boolean)}.  Returns {@code &quot;null&quot;} if
5023      * {@code a} is {@code null}.
5024      *
5025      * @param a the array whose string representation to return
5026      * @return a string representation of {@code a}
5027      * @since 1.5
5028      */
5029     public static String toString(boolean[] a) {
5030         if (a == null)
5031             return &quot;null&quot;;
5032         int iMax = a.length - 1;
5033         if (iMax == -1)
5034             return &quot;[]&quot;;
5035 
5036         StringBuilder b = new StringBuilder();
5037         b.append(&#39;[&#39;);
5038         for (int i = 0; ; i++) {
5039             b.append(a[i]);
5040             if (i == iMax)
5041                 return b.append(&#39;]&#39;).toString();
5042             b.append(&quot;, &quot;);
5043         }
5044     }
5045 
5046     /**
5047      * Returns a string representation of the contents of the specified array.
5048      * The string representation consists of a list of the array&#39;s elements,
5049      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
5050      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
5051      * space).  Elements are converted to strings as by
5052      * {@code String.valueOf(float)}.  Returns {@code &quot;null&quot;} if {@code a}
5053      * is {@code null}.
5054      *
5055      * @param a the array whose string representation to return
5056      * @return a string representation of {@code a}
5057      * @since 1.5
5058      */
5059     public static String toString(float[] a) {
5060         if (a == null)
5061             return &quot;null&quot;;
5062 
5063         int iMax = a.length - 1;
5064         if (iMax == -1)
5065             return &quot;[]&quot;;
5066 
5067         StringBuilder b = new StringBuilder();
5068         b.append(&#39;[&#39;);
5069         for (int i = 0; ; i++) {
5070             b.append(a[i]);
5071             if (i == iMax)
5072                 return b.append(&#39;]&#39;).toString();
5073             b.append(&quot;, &quot;);
5074         }
5075     }
5076 
5077     /**
5078      * Returns a string representation of the contents of the specified array.
5079      * The string representation consists of a list of the array&#39;s elements,
5080      * enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent elements are
5081      * separated by the characters {@code &quot;, &quot;} (a comma followed by a
5082      * space).  Elements are converted to strings as by
5083      * {@code String.valueOf(double)}.  Returns {@code &quot;null&quot;} if {@code a}
5084      * is {@code null}.
5085      *
5086      * @param a the array whose string representation to return
5087      * @return a string representation of {@code a}
5088      * @since 1.5
5089      */
5090     public static String toString(double[] a) {
5091         if (a == null)
5092             return &quot;null&quot;;
5093         int iMax = a.length - 1;
5094         if (iMax == -1)
5095             return &quot;[]&quot;;
5096 
5097         StringBuilder b = new StringBuilder();
5098         b.append(&#39;[&#39;);
5099         for (int i = 0; ; i++) {
5100             b.append(a[i]);
5101             if (i == iMax)
5102                 return b.append(&#39;]&#39;).toString();
5103             b.append(&quot;, &quot;);
5104         }
5105     }
5106 
5107     /**
5108      * Returns a string representation of the contents of the specified array.
5109      * If the array contains other arrays as elements, they are converted to
5110      * strings by the {@link Object#toString} method inherited from
5111      * {@code Object}, which describes their &lt;i&gt;identities&lt;/i&gt; rather than
5112      * their contents.
5113      *
5114      * &lt;p&gt;The value returned by this method is equal to the value that would
5115      * be returned by {@code Arrays.asList(a).toString()}, unless {@code a}
5116      * is {@code null}, in which case {@code &quot;null&quot;} is returned.
5117      *
5118      * @param a the array whose string representation to return
5119      * @return a string representation of {@code a}
5120      * @see #deepToString(Object[])
5121      * @since 1.5
5122      */
5123     public static String toString(Object[] a) {
5124         if (a == null)
5125             return &quot;null&quot;;
5126 
5127         int iMax = a.length - 1;
5128         if (iMax == -1)
5129             return &quot;[]&quot;;
5130 
5131         StringBuilder b = new StringBuilder();
5132         b.append(&#39;[&#39;);
5133         for (int i = 0; ; i++) {
5134             b.append(String.valueOf(a[i]));
5135             if (i == iMax)
5136                 return b.append(&#39;]&#39;).toString();
5137             b.append(&quot;, &quot;);
5138         }
5139     }
5140 
5141     /**
5142      * Returns a string representation of the &quot;deep contents&quot; of the specified
5143      * array.  If the array contains other arrays as elements, the string
5144      * representation contains their contents and so on.  This method is
5145      * designed for converting multidimensional arrays to strings.
5146      *
5147      * &lt;p&gt;The string representation consists of a list of the array&#39;s
5148      * elements, enclosed in square brackets ({@code &quot;[]&quot;}).  Adjacent
5149      * elements are separated by the characters {@code &quot;, &quot;} (a comma
5150      * followed by a space).  Elements are converted to strings as by
5151      * {@code String.valueOf(Object)}, unless they are themselves
5152      * arrays.
5153      *
5154      * &lt;p&gt;If an element {@code e} is an array of a primitive type, it is
5155      * converted to a string as by invoking the appropriate overloading of
5156      * {@code Arrays.toString(e)}.  If an element {@code e} is an array of a
5157      * reference type, it is converted to a string as by invoking
5158      * this method recursively.
5159      *
5160      * &lt;p&gt;To avoid infinite recursion, if the specified array contains itself
5161      * as an element, or contains an indirect reference to itself through one
5162      * or more levels of arrays, the self-reference is converted to the string
5163      * {@code &quot;[...]&quot;}.  For example, an array containing only a reference
5164      * to itself would be rendered as {@code &quot;[[...]]&quot;}.
5165      *
5166      * &lt;p&gt;This method returns {@code &quot;null&quot;} if the specified array
5167      * is {@code null}.
5168      *
5169      * @param a the array whose string representation to return
5170      * @return a string representation of {@code a}
5171      * @see #toString(Object[])
5172      * @since 1.5
5173      */
5174     public static String deepToString(Object[] a) {
5175         if (a == null)
5176             return &quot;null&quot;;
5177 
5178         int bufLen = 20 * a.length;
5179         if (a.length != 0 &amp;&amp; bufLen &lt;= 0)
5180             bufLen = Integer.MAX_VALUE;
5181         StringBuilder buf = new StringBuilder(bufLen);
5182         deepToString(a, buf, new HashSet&lt;&gt;());
5183         return buf.toString();
5184     }
5185 
5186     private static void deepToString(Object[] a, StringBuilder buf,
5187                                      Set&lt;Object[]&gt; dejaVu) {
5188         if (a == null) {
5189             buf.append(&quot;null&quot;);
5190             return;
5191         }
5192         int iMax = a.length - 1;
5193         if (iMax == -1) {
5194             buf.append(&quot;[]&quot;);
5195             return;
5196         }
5197 
5198         dejaVu.add(a);
5199         buf.append(&#39;[&#39;);
5200         for (int i = 0; ; i++) {
5201 
5202             Object element = a[i];
5203             if (element == null) {
5204                 buf.append(&quot;null&quot;);
5205             } else {
5206                 Class&lt;?&gt; eClass = element.getClass();
5207 
5208                 if (eClass.isArray()) {
5209                     if (eClass == byte[].class)
5210                         buf.append(toString((byte[]) element));
5211                     else if (eClass == short[].class)
5212                         buf.append(toString((short[]) element));
5213                     else if (eClass == int[].class)
5214                         buf.append(toString((int[]) element));
5215                     else if (eClass == long[].class)
5216                         buf.append(toString((long[]) element));
5217                     else if (eClass == char[].class)
5218                         buf.append(toString((char[]) element));
5219                     else if (eClass == float[].class)
5220                         buf.append(toString((float[]) element));
5221                     else if (eClass == double[].class)
5222                         buf.append(toString((double[]) element));
5223                     else if (eClass == boolean[].class)
5224                         buf.append(toString((boolean[]) element));
5225                     else { // element is an array of object references
5226                         if (dejaVu.contains(element))
5227                             buf.append(&quot;[...]&quot;);
5228                         else
5229                             deepToString((Object[])element, buf, dejaVu);
5230                     }
5231                 } else {  // element is non-null and not an array
5232                     buf.append(element.toString());
5233                 }
5234             }
5235             if (i == iMax)
5236                 break;
5237             buf.append(&quot;, &quot;);
5238         }
5239         buf.append(&#39;]&#39;);
5240         dejaVu.remove(a);
5241     }
5242 
5243 
5244     /**
5245      * Set all elements of the specified array, using the provided
5246      * generator function to compute each element.
5247      *
5248      * &lt;p&gt;If the generator function throws an exception, it is relayed to
5249      * the caller and the array is left in an indeterminate state.
5250      *
5251      * @apiNote
5252      * Setting a subrange of an array, using a generator function to compute
5253      * each element, can be written as follows:
5254      * &lt;pre&gt;{@code
5255      * IntStream.range(startInclusive, endExclusive)
5256      *          .forEach(i -&gt; array[i] = generator.apply(i));
5257      * }&lt;/pre&gt;
5258      *
5259      * @param &lt;T&gt; type of elements of the array
5260      * @param array array to be initialized
5261      * @param generator a function accepting an index and producing the desired
5262      *        value for that position
5263      * @throws NullPointerException if the generator is null
5264      * @since 1.8
5265      */
5266     public static &lt;T&gt; void setAll(T[] array, IntFunction&lt;? extends T&gt; generator) {
5267         Objects.requireNonNull(generator);
5268         for (int i = 0; i &lt; array.length; i++)
5269             array[i] = generator.apply(i);
5270     }
5271 
5272     /**
5273      * Set all elements of the specified array, in parallel, using the
5274      * provided generator function to compute each element.
5275      *
5276      * &lt;p&gt;If the generator function throws an exception, an unchecked exception
5277      * is thrown from {@code parallelSetAll} and the array is left in an
5278      * indeterminate state.
5279      *
5280      * @apiNote
5281      * Setting a subrange of an array, in parallel, using a generator function
5282      * to compute each element, can be written as follows:
5283      * &lt;pre&gt;{@code
5284      * IntStream.range(startInclusive, endExclusive)
5285      *          .parallel()
5286      *          .forEach(i -&gt; array[i] = generator.apply(i));
5287      * }&lt;/pre&gt;
5288      *
5289      * @param &lt;T&gt; type of elements of the array
5290      * @param array array to be initialized
5291      * @param generator a function accepting an index and producing the desired
5292      *        value for that position
5293      * @throws NullPointerException if the generator is null
5294      * @since 1.8
5295      */
5296     public static &lt;T&gt; void parallelSetAll(T[] array, IntFunction&lt;? extends T&gt; generator) {
5297         Objects.requireNonNull(generator);
5298         IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.apply(i); });
5299     }
5300 
5301     /**
5302      * Set all elements of the specified array, using the provided
5303      * generator function to compute each element.
5304      *
5305      * &lt;p&gt;If the generator function throws an exception, it is relayed to
5306      * the caller and the array is left in an indeterminate state.
5307      *
5308      * @apiNote
5309      * Setting a subrange of an array, using a generator function to compute
5310      * each element, can be written as follows:
5311      * &lt;pre&gt;{@code
5312      * IntStream.range(startInclusive, endExclusive)
5313      *          .forEach(i -&gt; array[i] = generator.applyAsInt(i));
5314      * }&lt;/pre&gt;
5315      *
5316      * @param array array to be initialized
5317      * @param generator a function accepting an index and producing the desired
5318      *        value for that position
5319      * @throws NullPointerException if the generator is null
5320      * @since 1.8
5321      */
5322     public static void setAll(int[] array, IntUnaryOperator generator) {
5323         Objects.requireNonNull(generator);
5324         for (int i = 0; i &lt; array.length; i++)
5325             array[i] = generator.applyAsInt(i);
5326     }
5327 
5328     /**
5329      * Set all elements of the specified array, in parallel, using the
5330      * provided generator function to compute each element.
5331      *
5332      * &lt;p&gt;If the generator function throws an exception, an unchecked exception
5333      * is thrown from {@code parallelSetAll} and the array is left in an
5334      * indeterminate state.
5335      *
5336      * @apiNote
5337      * Setting a subrange of an array, in parallel, using a generator function
5338      * to compute each element, can be written as follows:
5339      * &lt;pre&gt;{@code
5340      * IntStream.range(startInclusive, endExclusive)
5341      *          .parallel()
5342      *          .forEach(i -&gt; array[i] = generator.applyAsInt(i));
5343      * }&lt;/pre&gt;
5344      *
5345      * @param array array to be initialized
5346      * @param generator a function accepting an index and producing the desired
5347      * value for that position
5348      * @throws NullPointerException if the generator is null
5349      * @since 1.8
5350      */
5351     public static void parallelSetAll(int[] array, IntUnaryOperator generator) {
5352         Objects.requireNonNull(generator);
5353         IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsInt(i); });
5354     }
5355 
5356     /**
5357      * Set all elements of the specified array, using the provided
5358      * generator function to compute each element.
5359      *
5360      * &lt;p&gt;If the generator function throws an exception, it is relayed to
5361      * the caller and the array is left in an indeterminate state.
5362      *
5363      * @apiNote
5364      * Setting a subrange of an array, using a generator function to compute
5365      * each element, can be written as follows:
5366      * &lt;pre&gt;{@code
5367      * IntStream.range(startInclusive, endExclusive)
5368      *          .forEach(i -&gt; array[i] = generator.applyAsLong(i));
5369      * }&lt;/pre&gt;
5370      *
5371      * @param array array to be initialized
5372      * @param generator a function accepting an index and producing the desired
5373      *        value for that position
5374      * @throws NullPointerException if the generator is null
5375      * @since 1.8
5376      */
5377     public static void setAll(long[] array, IntToLongFunction generator) {
5378         Objects.requireNonNull(generator);
5379         for (int i = 0; i &lt; array.length; i++)
5380             array[i] = generator.applyAsLong(i);
5381     }
5382 
5383     /**
5384      * Set all elements of the specified array, in parallel, using the
5385      * provided generator function to compute each element.
5386      *
5387      * &lt;p&gt;If the generator function throws an exception, an unchecked exception
5388      * is thrown from {@code parallelSetAll} and the array is left in an
5389      * indeterminate state.
5390      *
5391      * @apiNote
5392      * Setting a subrange of an array, in parallel, using a generator function
5393      * to compute each element, can be written as follows:
5394      * &lt;pre&gt;{@code
5395      * IntStream.range(startInclusive, endExclusive)
5396      *          .parallel()
5397      *          .forEach(i -&gt; array[i] = generator.applyAsLong(i));
5398      * }&lt;/pre&gt;
5399      *
5400      * @param array array to be initialized
5401      * @param generator a function accepting an index and producing the desired
5402      *        value for that position
5403      * @throws NullPointerException if the generator is null
5404      * @since 1.8
5405      */
5406     public static void parallelSetAll(long[] array, IntToLongFunction generator) {
5407         Objects.requireNonNull(generator);
5408         IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsLong(i); });
5409     }
5410 
5411     /**
5412      * Set all elements of the specified array, using the provided
5413      * generator function to compute each element.
5414      *
5415      * &lt;p&gt;If the generator function throws an exception, it is relayed to
5416      * the caller and the array is left in an indeterminate state.
5417      *
5418      * @apiNote
5419      * Setting a subrange of an array, using a generator function to compute
5420      * each element, can be written as follows:
5421      * &lt;pre&gt;{@code
5422      * IntStream.range(startInclusive, endExclusive)
5423      *          .forEach(i -&gt; array[i] = generator.applyAsDouble(i));
5424      * }&lt;/pre&gt;
5425      *
5426      * @param array array to be initialized
5427      * @param generator a function accepting an index and producing the desired
5428      *        value for that position
5429      * @throws NullPointerException if the generator is null
5430      * @since 1.8
5431      */
5432     public static void setAll(double[] array, IntToDoubleFunction generator) {
5433         Objects.requireNonNull(generator);
5434         for (int i = 0; i &lt; array.length; i++)
5435             array[i] = generator.applyAsDouble(i);
5436     }
5437 
5438     /**
5439      * Set all elements of the specified array, in parallel, using the
5440      * provided generator function to compute each element.
5441      *
5442      * &lt;p&gt;If the generator function throws an exception, an unchecked exception
5443      * is thrown from {@code parallelSetAll} and the array is left in an
5444      * indeterminate state.
5445      *
5446      * @apiNote
5447      * Setting a subrange of an array, in parallel, using a generator function
5448      * to compute each element, can be written as follows:
5449      * &lt;pre&gt;{@code
5450      * IntStream.range(startInclusive, endExclusive)
5451      *          .parallel()
5452      *          .forEach(i -&gt; array[i] = generator.applyAsDouble(i));
5453      * }&lt;/pre&gt;
5454      *
5455      * @param array array to be initialized
5456      * @param generator a function accepting an index and producing the desired
5457      *        value for that position
5458      * @throws NullPointerException if the generator is null
5459      * @since 1.8
5460      */
5461     public static void parallelSetAll(double[] array, IntToDoubleFunction generator) {
5462         Objects.requireNonNull(generator);
5463         IntStream.range(0, array.length).parallel().forEach(i -&gt; { array[i] = generator.applyAsDouble(i); });
5464     }
5465 
5466     /**
5467      * Returns a {@link Spliterator} covering all of the specified array.
5468      *
5469      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5470      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5471      * {@link Spliterator#IMMUTABLE}.
5472      *
5473      * @param &lt;T&gt; type of elements
5474      * @param array the array, assumed to be unmodified during use
5475      * @return a spliterator for the array elements
5476      * @since 1.8
5477      */
5478     public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array) {
5479         return Spliterators.spliterator(array,
5480                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5481     }
5482 
5483     /**
5484      * Returns a {@link Spliterator} covering the specified range of the
5485      * specified array.
5486      *
5487      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5488      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5489      * {@link Spliterator#IMMUTABLE}.
5490      *
5491      * @param &lt;T&gt; type of elements
5492      * @param array the array, assumed to be unmodified during use
5493      * @param startInclusive the first index to cover, inclusive
5494      * @param endExclusive index immediately past the last index to cover
5495      * @return a spliterator for the array elements
5496      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5497      *         negative, {@code endExclusive} is less than
5498      *         {@code startInclusive}, or {@code endExclusive} is greater than
5499      *         the array size
5500      * @since 1.8
5501      */
5502     public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array, int startInclusive, int endExclusive) {
5503         return Spliterators.spliterator(array, startInclusive, endExclusive,
5504                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5505     }
5506 
5507     /**
5508      * Returns a {@link Spliterator.OfInt} covering all of the specified array.
5509      *
5510      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5511      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5512      * {@link Spliterator#IMMUTABLE}.
5513      *
5514      * @param array the array, assumed to be unmodified during use
5515      * @return a spliterator for the array elements
5516      * @since 1.8
5517      */
5518     public static Spliterator.OfInt spliterator(int[] array) {
5519         return Spliterators.spliterator(array,
5520                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5521     }
5522 
5523     /**
5524      * Returns a {@link Spliterator.OfInt} covering the specified range of the
5525      * specified array.
5526      *
5527      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5528      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5529      * {@link Spliterator#IMMUTABLE}.
5530      *
5531      * @param array the array, assumed to be unmodified during use
5532      * @param startInclusive the first index to cover, inclusive
5533      * @param endExclusive index immediately past the last index to cover
5534      * @return a spliterator for the array elements
5535      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5536      *         negative, {@code endExclusive} is less than
5537      *         {@code startInclusive}, or {@code endExclusive} is greater than
5538      *         the array size
5539      * @since 1.8
5540      */
5541     public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive) {
5542         return Spliterators.spliterator(array, startInclusive, endExclusive,
5543                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5544     }
5545 
5546     /**
5547      * Returns a {@link Spliterator.OfLong} covering all of the specified array.
5548      *
5549      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5550      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5551      * {@link Spliterator#IMMUTABLE}.
5552      *
5553      * @param array the array, assumed to be unmodified during use
5554      * @return the spliterator for the array elements
5555      * @since 1.8
5556      */
5557     public static Spliterator.OfLong spliterator(long[] array) {
5558         return Spliterators.spliterator(array,
5559                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5560     }
5561 
5562     /**
5563      * Returns a {@link Spliterator.OfLong} covering the specified range of the
5564      * specified array.
5565      *
5566      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5567      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5568      * {@link Spliterator#IMMUTABLE}.
5569      *
5570      * @param array the array, assumed to be unmodified during use
5571      * @param startInclusive the first index to cover, inclusive
5572      * @param endExclusive index immediately past the last index to cover
5573      * @return a spliterator for the array elements
5574      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5575      *         negative, {@code endExclusive} is less than
5576      *         {@code startInclusive}, or {@code endExclusive} is greater than
5577      *         the array size
5578      * @since 1.8
5579      */
5580     public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive) {
5581         return Spliterators.spliterator(array, startInclusive, endExclusive,
5582                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5583     }
5584 
5585     /**
5586      * Returns a {@link Spliterator.OfDouble} covering all of the specified
5587      * array.
5588      *
5589      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5590      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5591      * {@link Spliterator#IMMUTABLE}.
5592      *
5593      * @param array the array, assumed to be unmodified during use
5594      * @return a spliterator for the array elements
5595      * @since 1.8
5596      */
5597     public static Spliterator.OfDouble spliterator(double[] array) {
5598         return Spliterators.spliterator(array,
5599                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5600     }
5601 
5602     /**
5603      * Returns a {@link Spliterator.OfDouble} covering the specified range of
5604      * the specified array.
5605      *
5606      * &lt;p&gt;The spliterator reports {@link Spliterator#SIZED},
5607      * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and
5608      * {@link Spliterator#IMMUTABLE}.
5609      *
5610      * @param array the array, assumed to be unmodified during use
5611      * @param startInclusive the first index to cover, inclusive
5612      * @param endExclusive index immediately past the last index to cover
5613      * @return a spliterator for the array elements
5614      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5615      *         negative, {@code endExclusive} is less than
5616      *         {@code startInclusive}, or {@code endExclusive} is greater than
5617      *         the array size
5618      * @since 1.8
5619      */
5620     public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive) {
5621         return Spliterators.spliterator(array, startInclusive, endExclusive,
5622                                         Spliterator.ORDERED | Spliterator.IMMUTABLE);
5623     }
5624 
5625     /**
5626      * Returns a sequential {@link Stream} with the specified array as its
5627      * source.
5628      *
5629      * @param &lt;T&gt; The type of the array elements
5630      * @param array The array, assumed to be unmodified during use
5631      * @return a {@code Stream} for the array
5632      * @since 1.8
5633      */
5634     public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) {
5635         return stream(array, 0, array.length);
5636     }
5637 
5638     /**
5639      * Returns a sequential {@link Stream} with the specified range of the
5640      * specified array as its source.
5641      *
5642      * @param &lt;T&gt; the type of the array elements
5643      * @param array the array, assumed to be unmodified during use
5644      * @param startInclusive the first index to cover, inclusive
5645      * @param endExclusive index immediately past the last index to cover
5646      * @return a {@code Stream} for the array range
5647      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5648      *         negative, {@code endExclusive} is less than
5649      *         {@code startInclusive}, or {@code endExclusive} is greater than
5650      *         the array size
5651      * @since 1.8
5652      */
5653     public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive) {
5654         return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);
5655     }
5656 
5657     /**
5658      * Returns a sequential {@link IntStream} with the specified array as its
5659      * source.
5660      *
5661      * @param array the array, assumed to be unmodified during use
5662      * @return an {@code IntStream} for the array
5663      * @since 1.8
5664      */
5665     public static IntStream stream(int[] array) {
5666         return stream(array, 0, array.length);
5667     }
5668 
5669     /**
5670      * Returns a sequential {@link IntStream} with the specified range of the
5671      * specified array as its source.
5672      *
5673      * @param array the array, assumed to be unmodified during use
5674      * @param startInclusive the first index to cover, inclusive
5675      * @param endExclusive index immediately past the last index to cover
5676      * @return an {@code IntStream} for the array range
5677      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5678      *         negative, {@code endExclusive} is less than
5679      *         {@code startInclusive}, or {@code endExclusive} is greater than
5680      *         the array size
5681      * @since 1.8
5682      */
5683     public static IntStream stream(int[] array, int startInclusive, int endExclusive) {
5684         return StreamSupport.intStream(spliterator(array, startInclusive, endExclusive), false);
5685     }
5686 
5687     /**
5688      * Returns a sequential {@link LongStream} with the specified array as its
5689      * source.
5690      *
5691      * @param array the array, assumed to be unmodified during use
5692      * @return a {@code LongStream} for the array
5693      * @since 1.8
5694      */
5695     public static LongStream stream(long[] array) {
5696         return stream(array, 0, array.length);
5697     }
5698 
5699     /**
5700      * Returns a sequential {@link LongStream} with the specified range of the
5701      * specified array as its source.
5702      *
5703      * @param array the array, assumed to be unmodified during use
5704      * @param startInclusive the first index to cover, inclusive
5705      * @param endExclusive index immediately past the last index to cover
5706      * @return a {@code LongStream} for the array range
5707      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5708      *         negative, {@code endExclusive} is less than
5709      *         {@code startInclusive}, or {@code endExclusive} is greater than
5710      *         the array size
5711      * @since 1.8
5712      */
5713     public static LongStream stream(long[] array, int startInclusive, int endExclusive) {
5714         return StreamSupport.longStream(spliterator(array, startInclusive, endExclusive), false);
5715     }
5716 
5717     /**
5718      * Returns a sequential {@link DoubleStream} with the specified array as its
5719      * source.
5720      *
5721      * @param array the array, assumed to be unmodified during use
5722      * @return a {@code DoubleStream} for the array
5723      * @since 1.8
5724      */
5725     public static DoubleStream stream(double[] array) {
5726         return stream(array, 0, array.length);
5727     }
5728 
5729     /**
5730      * Returns a sequential {@link DoubleStream} with the specified range of the
5731      * specified array as its source.
5732      *
5733      * @param array the array, assumed to be unmodified during use
5734      * @param startInclusive the first index to cover, inclusive
5735      * @param endExclusive index immediately past the last index to cover
5736      * @return a {@code DoubleStream} for the array range
5737      * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
5738      *         negative, {@code endExclusive} is less than
5739      *         {@code startInclusive}, or {@code endExclusive} is greater than
5740      *         the array size
5741      * @since 1.8
5742      */
5743     public static DoubleStream stream(double[] array, int startInclusive, int endExclusive) {
5744         return StreamSupport.doubleStream(spliterator(array, startInclusive, endExclusive), false);
5745     }
5746 
5747 
5748     // Comparison methods
5749 
5750     // Compare boolean
5751 
5752     /**
5753      * Compares two {@code boolean} arrays lexicographically.
5754      *
5755      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
5756      * comparison is the result of comparing two elements, as if by
5757      * {@link Boolean#compare(boolean, boolean)}, at an index within the
5758      * respective arrays that is the prefix length.
5759      * Otherwise, one array is a proper prefix of the other and, lexicographic
5760      * comparison is the result of comparing the two array lengths.
5761      * (See {@link #mismatch(boolean[], boolean[])} for the definition of a
5762      * common and proper prefix.)
5763      *
5764      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
5765      * than a non-{@code null} array reference.  Two {@code null} array
5766      * references are considered equal.
5767      *
5768      * &lt;p&gt;The comparison is consistent with {@link #equals(boolean[], boolean[]) equals},
5769      * more specifically the following holds for arrays {@code a} and {@code b}:
5770      * &lt;pre&gt;{@code
5771      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
5772      * }&lt;/pre&gt;
5773      *
5774      * @apiNote
5775      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
5776      * &lt;pre&gt;{@code
5777      *     int i = Arrays.mismatch(a, b);
5778      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
5779      *         return Boolean.compare(a[i], b[i]);
5780      *     return a.length - b.length;
5781      * }&lt;/pre&gt;
5782      *
5783      * @param a the first array to compare
5784      * @param b the second array to compare
5785      * @return the value {@code 0} if the first and second array are equal and
5786      *         contain the same elements in the same order;
5787      *         a value less than {@code 0} if the first array is
5788      *         lexicographically less than the second array; and
5789      *         a value greater than {@code 0} if the first array is
5790      *         lexicographically greater than the second array
5791      * @since 9
5792      */
5793     public static int compare(boolean[] a, boolean[] b) {
5794         if (a == b)
5795             return 0;
5796         if (a == null || b == null)
5797             return a == null ? -1 : 1;
5798 
5799         int i = ArraysSupport.mismatch(a, b,
5800                                        Math.min(a.length, b.length));
5801         if (i &gt;= 0) {
5802             return Boolean.compare(a[i], b[i]);
5803         }
5804 
5805         return a.length - b.length;
5806     }
5807 
5808     /**
5809      * Compares two {@code boolean} arrays lexicographically over the specified
5810      * ranges.
5811      *
5812      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
5813      * then the lexicographic comparison is the result of comparing two
5814      * elements, as if by {@link Boolean#compare(boolean, boolean)}, at a
5815      * relative index within the respective arrays that is the length of the
5816      * prefix.
5817      * Otherwise, one array is a proper prefix of the other and, lexicographic
5818      * comparison is the result of comparing the two range lengths.
5819      * (See {@link #mismatch(boolean[], int, int, boolean[], int, int)} for the
5820      * definition of a common and proper prefix.)
5821      *
5822      * &lt;p&gt;The comparison is consistent with
5823      * {@link #equals(boolean[], int, int, boolean[], int, int) equals}, more
5824      * specifically the following holds for arrays {@code a} and {@code b} with
5825      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
5826      * [{@code bFromIndex}, {@code btoIndex}) respectively:
5827      * &lt;pre&gt;{@code
5828      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
5829      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
5830      * }&lt;/pre&gt;
5831      *
5832      * @apiNote
5833      * &lt;p&gt;This method behaves as if:
5834      * &lt;pre&gt;{@code
5835      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
5836      *                             b, bFromIndex, bToIndex);
5837      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
5838      *         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);
5839      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
5840      * }&lt;/pre&gt;
5841      *
5842      * @param a the first array to compare
5843      * @param aFromIndex the index (inclusive) of the first element in the
5844      *                   first array to be compared
5845      * @param aToIndex the index (exclusive) of the last element in the
5846      *                 first array to be compared
5847      * @param b the second array to compare
5848      * @param bFromIndex the index (inclusive) of the first element in the
5849      *                   second array to be compared
5850      * @param bToIndex the index (exclusive) of the last element in the
5851      *                 second array to be compared
5852      * @return the value {@code 0} if, over the specified ranges, the first and
5853      *         second array are equal and contain the same elements in the same
5854      *         order;
5855      *         a value less than {@code 0} if, over the specified ranges, the
5856      *         first array is lexicographically less than the second array; and
5857      *         a value greater than {@code 0} if, over the specified ranges, the
5858      *         first array is lexicographically greater than the second array
5859      * @throws IllegalArgumentException
5860      *         if {@code aFromIndex &gt; aToIndex} or
5861      *         if {@code bFromIndex &gt; bToIndex}
5862      * @throws ArrayIndexOutOfBoundsException
5863      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
5864      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
5865      * @throws NullPointerException
5866      *         if either array is {@code null}
5867      * @since 9
5868      */
5869     public static int compare(boolean[] a, int aFromIndex, int aToIndex,
5870                               boolean[] b, int bFromIndex, int bToIndex) {
5871         rangeCheck(a.length, aFromIndex, aToIndex);
5872         rangeCheck(b.length, bFromIndex, bToIndex);
5873 
5874         int aLength = aToIndex - aFromIndex;
5875         int bLength = bToIndex - bFromIndex;
5876         int i = ArraysSupport.mismatch(a, aFromIndex,
5877                                        b, bFromIndex,
5878                                        Math.min(aLength, bLength));
5879         if (i &gt;= 0) {
5880             return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);
5881         }
5882 
5883         return aLength - bLength;
5884     }
5885 
5886     // Compare byte
5887 
5888     /**
5889      * Compares two {@code byte} arrays lexicographically.
5890      *
5891      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
5892      * comparison is the result of comparing two elements, as if by
5893      * {@link Byte#compare(byte, byte)}, at an index within the respective
5894      * arrays that is the prefix length.
5895      * Otherwise, one array is a proper prefix of the other and, lexicographic
5896      * comparison is the result of comparing the two array lengths.
5897      * (See {@link #mismatch(byte[], byte[])} for the definition of a common and
5898      * proper prefix.)
5899      *
5900      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
5901      * than a non-{@code null} array reference.  Two {@code null} array
5902      * references are considered equal.
5903      *
5904      * &lt;p&gt;The comparison is consistent with {@link #equals(byte[], byte[]) equals},
5905      * more specifically the following holds for arrays {@code a} and {@code b}:
5906      * &lt;pre&gt;{@code
5907      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
5908      * }&lt;/pre&gt;
5909      *
5910      * @apiNote
5911      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
5912      * &lt;pre&gt;{@code
5913      *     int i = Arrays.mismatch(a, b);
5914      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
5915      *         return Byte.compare(a[i], b[i]);
5916      *     return a.length - b.length;
5917      * }&lt;/pre&gt;
5918      *
5919      * @param a the first array to compare
5920      * @param b the second array to compare
5921      * @return the value {@code 0} if the first and second array are equal and
5922      *         contain the same elements in the same order;
5923      *         a value less than {@code 0} if the first array is
5924      *         lexicographically less than the second array; and
5925      *         a value greater than {@code 0} if the first array is
5926      *         lexicographically greater than the second array
5927      * @since 9
5928      */
5929     public static int compare(byte[] a, byte[] b) {
5930         if (a == b)
5931             return 0;
5932         if (a == null || b == null)
5933             return a == null ? -1 : 1;
5934 
5935         int i = ArraysSupport.mismatch(a, b,
5936                                        Math.min(a.length, b.length));
5937         if (i &gt;= 0) {
5938             return Byte.compare(a[i], b[i]);
5939         }
5940 
5941         return a.length - b.length;
5942     }
5943 
5944     /**
5945      * Compares two {@code byte} arrays lexicographically over the specified
5946      * ranges.
5947      *
5948      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
5949      * then the lexicographic comparison is the result of comparing two
5950      * elements, as if by {@link Byte#compare(byte, byte)}, at a relative index
5951      * within the respective arrays that is the length of the prefix.
5952      * Otherwise, one array is a proper prefix of the other and, lexicographic
5953      * comparison is the result of comparing the two range lengths.
5954      * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the
5955      * definition of a common and proper prefix.)
5956      *
5957      * &lt;p&gt;The comparison is consistent with
5958      * {@link #equals(byte[], int, int, byte[], int, int) equals}, more
5959      * specifically the following holds for arrays {@code a} and {@code b} with
5960      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
5961      * [{@code bFromIndex}, {@code btoIndex}) respectively:
5962      * &lt;pre&gt;{@code
5963      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
5964      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
5965      * }&lt;/pre&gt;
5966      *
5967      * @apiNote
5968      * &lt;p&gt;This method behaves as if:
5969      * &lt;pre&gt;{@code
5970      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
5971      *                             b, bFromIndex, bToIndex);
5972      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
5973      *         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);
5974      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
5975      * }&lt;/pre&gt;
5976      *
5977      * @param a the first array to compare
5978      * @param aFromIndex the index (inclusive) of the first element in the
5979      *                   first array to be compared
5980      * @param aToIndex the index (exclusive) of the last element in the
5981      *                 first array to be compared
5982      * @param b the second array to compare
5983      * @param bFromIndex the index (inclusive) of the first element in the
5984      *                   second array to be compared
5985      * @param bToIndex the index (exclusive) of the last element in the
5986      *                 second array to be compared
5987      * @return the value {@code 0} if, over the specified ranges, the first and
5988      *         second array are equal and contain the same elements in the same
5989      *         order;
5990      *         a value less than {@code 0} if, over the specified ranges, the
5991      *         first array is lexicographically less than the second array; and
5992      *         a value greater than {@code 0} if, over the specified ranges, the
5993      *         first array is lexicographically greater than the second array
5994      * @throws IllegalArgumentException
5995      *         if {@code aFromIndex &gt; aToIndex} or
5996      *         if {@code bFromIndex &gt; bToIndex}
5997      * @throws ArrayIndexOutOfBoundsException
5998      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
5999      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6000      * @throws NullPointerException
6001      *         if either array is {@code null}
6002      * @since 9
6003      */
6004     public static int compare(byte[] a, int aFromIndex, int aToIndex,
6005                               byte[] b, int bFromIndex, int bToIndex) {
6006         rangeCheck(a.length, aFromIndex, aToIndex);
6007         rangeCheck(b.length, bFromIndex, bToIndex);
6008 
6009         int aLength = aToIndex - aFromIndex;
6010         int bLength = bToIndex - bFromIndex;
6011         int i = ArraysSupport.mismatch(a, aFromIndex,
6012                                        b, bFromIndex,
6013                                        Math.min(aLength, bLength));
6014         if (i &gt;= 0) {
6015             return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);
6016         }
6017 
6018         return aLength - bLength;
6019     }
6020 
6021     /**
6022      * Compares two {@code byte} arrays lexicographically, numerically treating
6023      * elements as unsigned.
6024      *
6025      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6026      * comparison is the result of comparing two elements, as if by
6027      * {@link Byte#compareUnsigned(byte, byte)}, at an index within the
6028      * respective arrays that is the prefix length.
6029      * Otherwise, one array is a proper prefix of the other and, lexicographic
6030      * comparison is the result of comparing the two array lengths.
6031      * (See {@link #mismatch(byte[], byte[])} for the definition of a common
6032      * and proper prefix.)
6033      *
6034      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6035      * than a non-{@code null} array reference.  Two {@code null} array
6036      * references are considered equal.
6037      *
6038      * @apiNote
6039      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6040      * &lt;pre&gt;{@code
6041      *     int i = Arrays.mismatch(a, b);
6042      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6043      *         return Byte.compareUnsigned(a[i], b[i]);
6044      *     return a.length - b.length;
6045      * }&lt;/pre&gt;
6046      *
6047      * @param a the first array to compare
6048      * @param b the second array to compare
6049      * @return the value {@code 0} if the first and second array are
6050      *         equal and contain the same elements in the same order;
6051      *         a value less than {@code 0} if the first array is
6052      *         lexicographically less than the second array; and
6053      *         a value greater than {@code 0} if the first array is
6054      *         lexicographically greater than the second array
6055      * @since 9
6056      */
6057     public static int compareUnsigned(byte[] a, byte[] b) {
6058         if (a == b)
6059             return 0;
6060         if (a == null || b == null)
6061             return a == null ? -1 : 1;
6062 
6063         int i = ArraysSupport.mismatch(a, b,
6064                                        Math.min(a.length, b.length));
6065         if (i &gt;= 0) {
6066             return Byte.compareUnsigned(a[i], b[i]);
6067         }
6068 
6069         return a.length - b.length;
6070     }
6071 
6072 
6073     /**
6074      * Compares two {@code byte} arrays lexicographically over the specified
6075      * ranges, numerically treating elements as unsigned.
6076      *
6077      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6078      * then the lexicographic comparison is the result of comparing two
6079      * elements, as if by {@link Byte#compareUnsigned(byte, byte)}, at a
6080      * relative index within the respective arrays that is the length of the
6081      * prefix.
6082      * Otherwise, one array is a proper prefix of the other and, lexicographic
6083      * comparison is the result of comparing the two range lengths.
6084      * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the
6085      * definition of a common and proper prefix.)
6086      *
6087      * @apiNote
6088      * &lt;p&gt;This method behaves as if:
6089      * &lt;pre&gt;{@code
6090      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6091      *                             b, bFromIndex, bToIndex);
6092      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6093      *         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6094      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6095      * }&lt;/pre&gt;
6096      *
6097      * @param a the first array to compare
6098      * @param aFromIndex the index (inclusive) of the first element in the
6099      *                   first array to be compared
6100      * @param aToIndex the index (exclusive) of the last element in the
6101      *                 first array to be compared
6102      * @param b the second array to compare
6103      * @param bFromIndex the index (inclusive) of the first element in the
6104      *                   second array to be compared
6105      * @param bToIndex the index (exclusive) of the last element in the
6106      *                 second array to be compared
6107      * @return the value {@code 0} if, over the specified ranges, the first and
6108      *         second array are equal and contain the same elements in the same
6109      *         order;
6110      *         a value less than {@code 0} if, over the specified ranges, the
6111      *         first array is lexicographically less than the second array; and
6112      *         a value greater than {@code 0} if, over the specified ranges, the
6113      *         first array is lexicographically greater than the second array
6114      * @throws IllegalArgumentException
6115      *         if {@code aFromIndex &gt; aToIndex} or
6116      *         if {@code bFromIndex &gt; bToIndex}
6117      * @throws ArrayIndexOutOfBoundsException
6118      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6119      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6120      * @throws NullPointerException
6121      *         if either array is null
6122      * @since 9
6123      */
6124     public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex,
6125                                       byte[] b, int bFromIndex, int bToIndex) {
6126         rangeCheck(a.length, aFromIndex, aToIndex);
6127         rangeCheck(b.length, bFromIndex, bToIndex);
6128 
6129         int aLength = aToIndex - aFromIndex;
6130         int bLength = bToIndex - bFromIndex;
6131         int i = ArraysSupport.mismatch(a, aFromIndex,
6132                                        b, bFromIndex,
6133                                        Math.min(aLength, bLength));
6134         if (i &gt;= 0) {
6135             return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6136         }
6137 
6138         return aLength - bLength;
6139     }
6140 
6141     // Compare short
6142 
6143     /**
6144      * Compares two {@code short} arrays lexicographically.
6145      *
6146      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6147      * comparison is the result of comparing two elements, as if by
6148      * {@link Short#compare(short, short)}, at an index within the respective
6149      * arrays that is the prefix length.
6150      * Otherwise, one array is a proper prefix of the other and, lexicographic
6151      * comparison is the result of comparing the two array lengths.
6152      * (See {@link #mismatch(short[], short[])} for the definition of a common
6153      * and proper prefix.)
6154      *
6155      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6156      * than a non-{@code null} array reference.  Two {@code null} array
6157      * references are considered equal.
6158      *
6159      * &lt;p&gt;The comparison is consistent with {@link #equals(short[], short[]) equals},
6160      * more specifically the following holds for arrays {@code a} and {@code b}:
6161      * &lt;pre&gt;{@code
6162      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
6163      * }&lt;/pre&gt;
6164      *
6165      * @apiNote
6166      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6167      * &lt;pre&gt;{@code
6168      *     int i = Arrays.mismatch(a, b);
6169      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6170      *         return Short.compare(a[i], b[i]);
6171      *     return a.length - b.length;
6172      * }&lt;/pre&gt;
6173      *
6174      * @param a the first array to compare
6175      * @param b the second array to compare
6176      * @return the value {@code 0} if the first and second array are equal and
6177      *         contain the same elements in the same order;
6178      *         a value less than {@code 0} if the first array is
6179      *         lexicographically less than the second array; and
6180      *         a value greater than {@code 0} if the first array is
6181      *         lexicographically greater than the second array
6182      * @since 9
6183      */
6184     public static int compare(short[] a, short[] b) {
6185         if (a == b)
6186             return 0;
6187         if (a == null || b == null)
6188             return a == null ? -1 : 1;
6189 
6190         int i = ArraysSupport.mismatch(a, b,
6191                                        Math.min(a.length, b.length));
6192         if (i &gt;= 0) {
6193             return Short.compare(a[i], b[i]);
6194         }
6195 
6196         return a.length - b.length;
6197     }
6198 
6199     /**
6200      * Compares two {@code short} arrays lexicographically over the specified
6201      * ranges.
6202      *
6203      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6204      * then the lexicographic comparison is the result of comparing two
6205      * elements, as if by {@link Short#compare(short, short)}, at a relative
6206      * index within the respective arrays that is the length of the prefix.
6207      * Otherwise, one array is a proper prefix of the other and, lexicographic
6208      * comparison is the result of comparing the two range lengths.
6209      * (See {@link #mismatch(short[], int, int, short[], int, int)} for the
6210      * definition of a common and proper prefix.)
6211      *
6212      * &lt;p&gt;The comparison is consistent with
6213      * {@link #equals(short[], int, int, short[], int, int) equals}, more
6214      * specifically the following holds for arrays {@code a} and {@code b} with
6215      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
6216      * [{@code bFromIndex}, {@code btoIndex}) respectively:
6217      * &lt;pre&gt;{@code
6218      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
6219      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
6220      * }&lt;/pre&gt;
6221      *
6222      * @apiNote
6223      * &lt;p&gt;This method behaves as if:
6224      * &lt;pre&gt;{@code
6225      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6226      *                             b, bFromIndex, bToIndex);
6227      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6228      *         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);
6229      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6230      * }&lt;/pre&gt;
6231      *
6232      * @param a the first array to compare
6233      * @param aFromIndex the index (inclusive) of the first element in the
6234      *                   first array to be compared
6235      * @param aToIndex the index (exclusive) of the last element in the
6236      *                 first array to be compared
6237      * @param b the second array to compare
6238      * @param bFromIndex the index (inclusive) of the first element in the
6239      *                   second array to be compared
6240      * @param bToIndex the index (exclusive) of the last element in the
6241      *                 second array to be compared
6242      * @return the value {@code 0} if, over the specified ranges, the first and
6243      *         second array are equal and contain the same elements in the same
6244      *         order;
6245      *         a value less than {@code 0} if, over the specified ranges, the
6246      *         first array is lexicographically less than the second array; and
6247      *         a value greater than {@code 0} if, over the specified ranges, the
6248      *         first array is lexicographically greater than the second array
6249      * @throws IllegalArgumentException
6250      *         if {@code aFromIndex &gt; aToIndex} or
6251      *         if {@code bFromIndex &gt; bToIndex}
6252      * @throws ArrayIndexOutOfBoundsException
6253      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6254      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6255      * @throws NullPointerException
6256      *         if either array is {@code null}
6257      * @since 9
6258      */
6259     public static int compare(short[] a, int aFromIndex, int aToIndex,
6260                               short[] b, int bFromIndex, int bToIndex) {
6261         rangeCheck(a.length, aFromIndex, aToIndex);
6262         rangeCheck(b.length, bFromIndex, bToIndex);
6263 
6264         int aLength = aToIndex - aFromIndex;
6265         int bLength = bToIndex - bFromIndex;
6266         int i = ArraysSupport.mismatch(a, aFromIndex,
6267                                        b, bFromIndex,
6268                                        Math.min(aLength, bLength));
6269         if (i &gt;= 0) {
6270             return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);
6271         }
6272 
6273         return aLength - bLength;
6274     }
6275 
6276     /**
6277      * Compares two {@code short} arrays lexicographically, numerically treating
6278      * elements as unsigned.
6279      *
6280      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6281      * comparison is the result of comparing two elements, as if by
6282      * {@link Short#compareUnsigned(short, short)}, at an index within the
6283      * respective arrays that is the prefix length.
6284      * Otherwise, one array is a proper prefix of the other and, lexicographic
6285      * comparison is the result of comparing the two array lengths.
6286      * (See {@link #mismatch(short[], short[])} for the definition of a common
6287      * and proper prefix.)
6288      *
6289      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6290      * than a non-{@code null} array reference.  Two {@code null} array
6291      * references are considered equal.
6292      *
6293      * @apiNote
6294      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6295      * &lt;pre&gt;{@code
6296      *     int i = Arrays.mismatch(a, b);
6297      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6298      *         return Short.compareUnsigned(a[i], b[i]);
6299      *     return a.length - b.length;
6300      * }&lt;/pre&gt;
6301      *
6302      * @param a the first array to compare
6303      * @param b the second array to compare
6304      * @return the value {@code 0} if the first and second array are
6305      *         equal and contain the same elements in the same order;
6306      *         a value less than {@code 0} if the first array is
6307      *         lexicographically less than the second array; and
6308      *         a value greater than {@code 0} if the first array is
6309      *         lexicographically greater than the second array
6310      * @since 9
6311      */
6312     public static int compareUnsigned(short[] a, short[] b) {
6313         if (a == b)
6314             return 0;
6315         if (a == null || b == null)
6316             return a == null ? -1 : 1;
6317 
6318         int i = ArraysSupport.mismatch(a, b,
6319                                        Math.min(a.length, b.length));
6320         if (i &gt;= 0) {
6321             return Short.compareUnsigned(a[i], b[i]);
6322         }
6323 
6324         return a.length - b.length;
6325     }
6326 
6327     /**
6328      * Compares two {@code short} arrays lexicographically over the specified
6329      * ranges, numerically treating elements as unsigned.
6330      *
6331      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6332      * then the lexicographic comparison is the result of comparing two
6333      * elements, as if by {@link Short#compareUnsigned(short, short)}, at a
6334      * relative index within the respective arrays that is the length of the
6335      * prefix.
6336      * Otherwise, one array is a proper prefix of the other and, lexicographic
6337      * comparison is the result of comparing the two range lengths.
6338      * (See {@link #mismatch(short[], int, int, short[], int, int)} for the
6339      * definition of a common and proper prefix.)
6340      *
6341      * @apiNote
6342      * &lt;p&gt;This method behaves as if:
6343      * &lt;pre&gt;{@code
6344      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6345      *                             b, bFromIndex, bToIndex);
6346      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6347      *         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6348      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6349      * }&lt;/pre&gt;
6350      *
6351      * @param a the first array to compare
6352      * @param aFromIndex the index (inclusive) of the first element in the
6353      *                   first array to be compared
6354      * @param aToIndex the index (exclusive) of the last element in the
6355      *                 first array to be compared
6356      * @param b the second array to compare
6357      * @param bFromIndex the index (inclusive) of the first element in the
6358      *                   second array to be compared
6359      * @param bToIndex the index (exclusive) of the last element in the
6360      *                 second array to be compared
6361      * @return the value {@code 0} if, over the specified ranges, the first and
6362      *         second array are equal and contain the same elements in the same
6363      *         order;
6364      *         a value less than {@code 0} if, over the specified ranges, the
6365      *         first array is lexicographically less than the second array; and
6366      *         a value greater than {@code 0} if, over the specified ranges, the
6367      *         first array is lexicographically greater than the second array
6368      * @throws IllegalArgumentException
6369      *         if {@code aFromIndex &gt; aToIndex} or
6370      *         if {@code bFromIndex &gt; bToIndex}
6371      * @throws ArrayIndexOutOfBoundsException
6372      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6373      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6374      * @throws NullPointerException
6375      *         if either array is null
6376      * @since 9
6377      */
6378     public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex,
6379                                       short[] b, int bFromIndex, int bToIndex) {
6380         rangeCheck(a.length, aFromIndex, aToIndex);
6381         rangeCheck(b.length, bFromIndex, bToIndex);
6382 
6383         int aLength = aToIndex - aFromIndex;
6384         int bLength = bToIndex - bFromIndex;
6385         int i = ArraysSupport.mismatch(a, aFromIndex,
6386                                        b, bFromIndex,
6387                                        Math.min(aLength, bLength));
6388         if (i &gt;= 0) {
6389             return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6390         }
6391 
6392         return aLength - bLength;
6393     }
6394 
6395     // Compare char
6396 
6397     /**
6398      * Compares two {@code char} arrays lexicographically.
6399      *
6400      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6401      * comparison is the result of comparing two elements, as if by
6402      * {@link Character#compare(char, char)}, at an index within the respective
6403      * arrays that is the prefix length.
6404      * Otherwise, one array is a proper prefix of the other and, lexicographic
6405      * comparison is the result of comparing the two array lengths.
6406      * (See {@link #mismatch(char[], char[])} for the definition of a common and
6407      * proper prefix.)
6408      *
6409      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6410      * than a non-{@code null} array reference.  Two {@code null} array
6411      * references are considered equal.
6412      *
6413      * &lt;p&gt;The comparison is consistent with {@link #equals(char[], char[]) equals},
6414      * more specifically the following holds for arrays {@code a} and {@code b}:
6415      * &lt;pre&gt;{@code
6416      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
6417      * }&lt;/pre&gt;
6418      *
6419      * @apiNote
6420      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6421      * &lt;pre&gt;{@code
6422      *     int i = Arrays.mismatch(a, b);
6423      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6424      *         return Character.compare(a[i], b[i]);
6425      *     return a.length - b.length;
6426      * }&lt;/pre&gt;
6427      *
6428      * @param a the first array to compare
6429      * @param b the second array to compare
6430      * @return the value {@code 0} if the first and second array are equal and
6431      *         contain the same elements in the same order;
6432      *         a value less than {@code 0} if the first array is
6433      *         lexicographically less than the second array; and
6434      *         a value greater than {@code 0} if the first array is
6435      *         lexicographically greater than the second array
6436      * @since 9
6437      */
6438     public static int compare(char[] a, char[] b) {
6439         if (a == b)
6440             return 0;
6441         if (a == null || b == null)
6442             return a == null ? -1 : 1;
6443 
6444         int i = ArraysSupport.mismatch(a, b,
6445                                        Math.min(a.length, b.length));
6446         if (i &gt;= 0) {
6447             return Character.compare(a[i], b[i]);
6448         }
6449 
6450         return a.length - b.length;
6451     }
6452 
6453     /**
6454      * Compares two {@code char} arrays lexicographically over the specified
6455      * ranges.
6456      *
6457      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6458      * then the lexicographic comparison is the result of comparing two
6459      * elements, as if by {@link Character#compare(char, char)}, at a relative
6460      * index within the respective arrays that is the length of the prefix.
6461      * Otherwise, one array is a proper prefix of the other and, lexicographic
6462      * comparison is the result of comparing the two range lengths.
6463      * (See {@link #mismatch(char[], int, int, char[], int, int)} for the
6464      * definition of a common and proper prefix.)
6465      *
6466      * &lt;p&gt;The comparison is consistent with
6467      * {@link #equals(char[], int, int, char[], int, int) equals}, more
6468      * specifically the following holds for arrays {@code a} and {@code b} with
6469      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
6470      * [{@code bFromIndex}, {@code btoIndex}) respectively:
6471      * &lt;pre&gt;{@code
6472      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
6473      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
6474      * }&lt;/pre&gt;
6475      *
6476      * @apiNote
6477      * &lt;p&gt;This method behaves as if:
6478      * &lt;pre&gt;{@code
6479      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6480      *                             b, bFromIndex, bToIndex);
6481      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6482      *         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);
6483      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6484      * }&lt;/pre&gt;
6485      *
6486      * @param a the first array to compare
6487      * @param aFromIndex the index (inclusive) of the first element in the
6488      *                   first array to be compared
6489      * @param aToIndex the index (exclusive) of the last element in the
6490      *                 first array to be compared
6491      * @param b the second array to compare
6492      * @param bFromIndex the index (inclusive) of the first element in the
6493      *                   second array to be compared
6494      * @param bToIndex the index (exclusive) of the last element in the
6495      *                 second array to be compared
6496      * @return the value {@code 0} if, over the specified ranges, the first and
6497      *         second array are equal and contain the same elements in the same
6498      *         order;
6499      *         a value less than {@code 0} if, over the specified ranges, the
6500      *         first array is lexicographically less than the second array; and
6501      *         a value greater than {@code 0} if, over the specified ranges, the
6502      *         first array is lexicographically greater than the second array
6503      * @throws IllegalArgumentException
6504      *         if {@code aFromIndex &gt; aToIndex} or
6505      *         if {@code bFromIndex &gt; bToIndex}
6506      * @throws ArrayIndexOutOfBoundsException
6507      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6508      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6509      * @throws NullPointerException
6510      *         if either array is {@code null}
6511      * @since 9
6512      */
6513     public static int compare(char[] a, int aFromIndex, int aToIndex,
6514                               char[] b, int bFromIndex, int bToIndex) {
6515         rangeCheck(a.length, aFromIndex, aToIndex);
6516         rangeCheck(b.length, bFromIndex, bToIndex);
6517 
6518         int aLength = aToIndex - aFromIndex;
6519         int bLength = bToIndex - bFromIndex;
6520         int i = ArraysSupport.mismatch(a, aFromIndex,
6521                                        b, bFromIndex,
6522                                        Math.min(aLength, bLength));
6523         if (i &gt;= 0) {
6524             return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);
6525         }
6526 
6527         return aLength - bLength;
6528     }
6529 
6530     // Compare int
6531 
6532     /**
6533      * Compares two {@code int} arrays lexicographically.
6534      *
6535      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6536      * comparison is the result of comparing two elements, as if by
6537      * {@link Integer#compare(int, int)}, at an index within the respective
6538      * arrays that is the prefix length.
6539      * Otherwise, one array is a proper prefix of the other and, lexicographic
6540      * comparison is the result of comparing the two array lengths.
6541      * (See {@link #mismatch(int[], int[])} for the definition of a common and
6542      * proper prefix.)
6543      *
6544      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6545      * than a non-{@code null} array reference.  Two {@code null} array
6546      * references are considered equal.
6547      *
6548      * &lt;p&gt;The comparison is consistent with {@link #equals(int[], int[]) equals},
6549      * more specifically the following holds for arrays {@code a} and {@code b}:
6550      * &lt;pre&gt;{@code
6551      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
6552      * }&lt;/pre&gt;
6553      *
6554      * @apiNote
6555      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6556      * &lt;pre&gt;{@code
6557      *     int i = Arrays.mismatch(a, b);
6558      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6559      *         return Integer.compare(a[i], b[i]);
6560      *     return a.length - b.length;
6561      * }&lt;/pre&gt;
6562      *
6563      * @param a the first array to compare
6564      * @param b the second array to compare
6565      * @return the value {@code 0} if the first and second array are equal and
6566      *         contain the same elements in the same order;
6567      *         a value less than {@code 0} if the first array is
6568      *         lexicographically less than the second array; and
6569      *         a value greater than {@code 0} if the first array is
6570      *         lexicographically greater than the second array
6571      * @since 9
6572      */
6573     public static int compare(int[] a, int[] b) {
6574         if (a == b)
6575             return 0;
6576         if (a == null || b == null)
6577             return a == null ? -1 : 1;
6578 
6579         int i = ArraysSupport.mismatch(a, b,
6580                                        Math.min(a.length, b.length));
6581         if (i &gt;= 0) {
6582             return Integer.compare(a[i], b[i]);
6583         }
6584 
6585         return a.length - b.length;
6586     }
6587 
6588     /**
6589      * Compares two {@code int} arrays lexicographically over the specified
6590      * ranges.
6591      *
6592      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6593      * then the lexicographic comparison is the result of comparing two
6594      * elements, as if by {@link Integer#compare(int, int)}, at a relative index
6595      * within the respective arrays that is the length of the prefix.
6596      * Otherwise, one array is a proper prefix of the other and, lexicographic
6597      * comparison is the result of comparing the two range lengths.
6598      * (See {@link #mismatch(int[], int, int, int[], int, int)} for the
6599      * definition of a common and proper prefix.)
6600      *
6601      * &lt;p&gt;The comparison is consistent with
6602      * {@link #equals(int[], int, int, int[], int, int) equals}, more
6603      * specifically the following holds for arrays {@code a} and {@code b} with
6604      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
6605      * [{@code bFromIndex}, {@code btoIndex}) respectively:
6606      * &lt;pre&gt;{@code
6607      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
6608      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
6609      * }&lt;/pre&gt;
6610      *
6611      * @apiNote
6612      * &lt;p&gt;This method behaves as if:
6613      * &lt;pre&gt;{@code
6614      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6615      *                             b, bFromIndex, bToIndex);
6616      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6617      *         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);
6618      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6619      * }&lt;/pre&gt;
6620      *
6621      * @param a the first array to compare
6622      * @param aFromIndex the index (inclusive) of the first element in the
6623      *                   first array to be compared
6624      * @param aToIndex the index (exclusive) of the last element in the
6625      *                 first array to be compared
6626      * @param b the second array to compare
6627      * @param bFromIndex the index (inclusive) of the first element in the
6628      *                   second array to be compared
6629      * @param bToIndex the index (exclusive) of the last element in the
6630      *                 second array to be compared
6631      * @return the value {@code 0} if, over the specified ranges, the first and
6632      *         second array are equal and contain the same elements in the same
6633      *         order;
6634      *         a value less than {@code 0} if, over the specified ranges, the
6635      *         first array is lexicographically less than the second array; and
6636      *         a value greater than {@code 0} if, over the specified ranges, the
6637      *         first array is lexicographically greater than the second array
6638      * @throws IllegalArgumentException
6639      *         if {@code aFromIndex &gt; aToIndex} or
6640      *         if {@code bFromIndex &gt; bToIndex}
6641      * @throws ArrayIndexOutOfBoundsException
6642      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6643      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6644      * @throws NullPointerException
6645      *         if either array is {@code null}
6646      * @since 9
6647      */
6648     public static int compare(int[] a, int aFromIndex, int aToIndex,
6649                               int[] b, int bFromIndex, int bToIndex) {
6650         rangeCheck(a.length, aFromIndex, aToIndex);
6651         rangeCheck(b.length, bFromIndex, bToIndex);
6652 
6653         int aLength = aToIndex - aFromIndex;
6654         int bLength = bToIndex - bFromIndex;
6655         int i = ArraysSupport.mismatch(a, aFromIndex,
6656                                        b, bFromIndex,
6657                                        Math.min(aLength, bLength));
6658         if (i &gt;= 0) {
6659             return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);
6660         }
6661 
6662         return aLength - bLength;
6663     }
6664 
6665     /**
6666      * Compares two {@code int} arrays lexicographically, numerically treating
6667      * elements as unsigned.
6668      *
6669      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6670      * comparison is the result of comparing two elements, as if by
6671      * {@link Integer#compareUnsigned(int, int)}, at an index within the
6672      * respective arrays that is the prefix length.
6673      * Otherwise, one array is a proper prefix of the other and, lexicographic
6674      * comparison is the result of comparing the two array lengths.
6675      * (See {@link #mismatch(int[], int[])} for the definition of a common
6676      * and proper prefix.)
6677      *
6678      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6679      * than a non-{@code null} array reference.  Two {@code null} array
6680      * references are considered equal.
6681      *
6682      * @apiNote
6683      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6684      * &lt;pre&gt;{@code
6685      *     int i = Arrays.mismatch(a, b);
6686      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6687      *         return Integer.compareUnsigned(a[i], b[i]);
6688      *     return a.length - b.length;
6689      * }&lt;/pre&gt;
6690      *
6691      * @param a the first array to compare
6692      * @param b the second array to compare
6693      * @return the value {@code 0} if the first and second array are
6694      *         equal and contain the same elements in the same order;
6695      *         a value less than {@code 0} if the first array is
6696      *         lexicographically less than the second array; and
6697      *         a value greater than {@code 0} if the first array is
6698      *         lexicographically greater than the second array
6699      * @since 9
6700      */
6701     public static int compareUnsigned(int[] a, int[] b) {
6702         if (a == b)
6703             return 0;
6704         if (a == null || b == null)
6705             return a == null ? -1 : 1;
6706 
6707         int i = ArraysSupport.mismatch(a, b,
6708                                        Math.min(a.length, b.length));
6709         if (i &gt;= 0) {
6710             return Integer.compareUnsigned(a[i], b[i]);
6711         }
6712 
6713         return a.length - b.length;
6714     }
6715 
6716     /**
6717      * Compares two {@code int} arrays lexicographically over the specified
6718      * ranges, numerically treating elements as unsigned.
6719      *
6720      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6721      * then the lexicographic comparison is the result of comparing two
6722      * elements, as if by {@link Integer#compareUnsigned(int, int)}, at a
6723      * relative index within the respective arrays that is the length of the
6724      * prefix.
6725      * Otherwise, one array is a proper prefix of the other and, lexicographic
6726      * comparison is the result of comparing the two range lengths.
6727      * (See {@link #mismatch(int[], int, int, int[], int, int)} for the
6728      * definition of a common and proper prefix.)
6729      *
6730      * @apiNote
6731      * &lt;p&gt;This method behaves as if:
6732      * &lt;pre&gt;{@code
6733      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6734      *                             b, bFromIndex, bToIndex);
6735      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6736      *         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6737      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6738      * }&lt;/pre&gt;
6739      *
6740      * @param a the first array to compare
6741      * @param aFromIndex the index (inclusive) of the first element in the
6742      *                   first array to be compared
6743      * @param aToIndex the index (exclusive) of the last element in the
6744      *                 first array to be compared
6745      * @param b the second array to compare
6746      * @param bFromIndex the index (inclusive) of the first element in the
6747      *                   second array to be compared
6748      * @param bToIndex the index (exclusive) of the last element in the
6749      *                 second array to be compared
6750      * @return the value {@code 0} if, over the specified ranges, the first and
6751      *         second array are equal and contain the same elements in the same
6752      *         order;
6753      *         a value less than {@code 0} if, over the specified ranges, the
6754      *         first array is lexicographically less than the second array; and
6755      *         a value greater than {@code 0} if, over the specified ranges, the
6756      *         first array is lexicographically greater than the second array
6757      * @throws IllegalArgumentException
6758      *         if {@code aFromIndex &gt; aToIndex} or
6759      *         if {@code bFromIndex &gt; bToIndex}
6760      * @throws ArrayIndexOutOfBoundsException
6761      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6762      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6763      * @throws NullPointerException
6764      *         if either array is null
6765      * @since 9
6766      */
6767     public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex,
6768                                       int[] b, int bFromIndex, int bToIndex) {
6769         rangeCheck(a.length, aFromIndex, aToIndex);
6770         rangeCheck(b.length, bFromIndex, bToIndex);
6771 
6772         int aLength = aToIndex - aFromIndex;
6773         int bLength = bToIndex - bFromIndex;
6774         int i = ArraysSupport.mismatch(a, aFromIndex,
6775                                        b, bFromIndex,
6776                                        Math.min(aLength, bLength));
6777         if (i &gt;= 0) {
6778             return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6779         }
6780 
6781         return aLength - bLength;
6782     }
6783 
6784     // Compare long
6785 
6786     /**
6787      * Compares two {@code long} arrays lexicographically.
6788      *
6789      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6790      * comparison is the result of comparing two elements, as if by
6791      * {@link Long#compare(long, long)}, at an index within the respective
6792      * arrays that is the prefix length.
6793      * Otherwise, one array is a proper prefix of the other and, lexicographic
6794      * comparison is the result of comparing the two array lengths.
6795      * (See {@link #mismatch(long[], long[])} for the definition of a common and
6796      * proper prefix.)
6797      *
6798      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6799      * than a non-{@code null} array reference.  Two {@code null} array
6800      * references are considered equal.
6801      *
6802      * &lt;p&gt;The comparison is consistent with {@link #equals(long[], long[]) equals},
6803      * more specifically the following holds for arrays {@code a} and {@code b}:
6804      * &lt;pre&gt;{@code
6805      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
6806      * }&lt;/pre&gt;
6807      *
6808      * @apiNote
6809      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6810      * &lt;pre&gt;{@code
6811      *     int i = Arrays.mismatch(a, b);
6812      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6813      *         return Long.compare(a[i], b[i]);
6814      *     return a.length - b.length;
6815      * }&lt;/pre&gt;
6816      *
6817      * @param a the first array to compare
6818      * @param b the second array to compare
6819      * @return the value {@code 0} if the first and second array are equal and
6820      *         contain the same elements in the same order;
6821      *         a value less than {@code 0} if the first array is
6822      *         lexicographically less than the second array; and
6823      *         a value greater than {@code 0} if the first array is
6824      *         lexicographically greater than the second array
6825      * @since 9
6826      */
6827     public static int compare(long[] a, long[] b) {
6828         if (a == b)
6829             return 0;
6830         if (a == null || b == null)
6831             return a == null ? -1 : 1;
6832 
6833         int i = ArraysSupport.mismatch(a, b,
6834                                        Math.min(a.length, b.length));
6835         if (i &gt;= 0) {
6836             return Long.compare(a[i], b[i]);
6837         }
6838 
6839         return a.length - b.length;
6840     }
6841 
6842     /**
6843      * Compares two {@code long} arrays lexicographically over the specified
6844      * ranges.
6845      *
6846      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6847      * then the lexicographic comparison is the result of comparing two
6848      * elements, as if by {@link Long#compare(long, long)}, at a relative index
6849      * within the respective arrays that is the length of the prefix.
6850      * Otherwise, one array is a proper prefix of the other and, lexicographic
6851      * comparison is the result of comparing the two range lengths.
6852      * (See {@link #mismatch(long[], int, int, long[], int, int)} for the
6853      * definition of a common and proper prefix.)
6854      *
6855      * &lt;p&gt;The comparison is consistent with
6856      * {@link #equals(long[], int, int, long[], int, int) equals}, more
6857      * specifically the following holds for arrays {@code a} and {@code b} with
6858      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
6859      * [{@code bFromIndex}, {@code btoIndex}) respectively:
6860      * &lt;pre&gt;{@code
6861      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
6862      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
6863      * }&lt;/pre&gt;
6864      *
6865      * @apiNote
6866      * &lt;p&gt;This method behaves as if:
6867      * &lt;pre&gt;{@code
6868      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6869      *                             b, bFromIndex, bToIndex);
6870      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6871      *         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);
6872      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6873      * }&lt;/pre&gt;
6874      *
6875      * @param a the first array to compare
6876      * @param aFromIndex the index (inclusive) of the first element in the
6877      *                   first array to be compared
6878      * @param aToIndex the index (exclusive) of the last element in the
6879      *                 first array to be compared
6880      * @param b the second array to compare
6881      * @param bFromIndex the index (inclusive) of the first element in the
6882      *                   second array to be compared
6883      * @param bToIndex the index (exclusive) of the last element in the
6884      *                 second array to be compared
6885      * @return the value {@code 0} if, over the specified ranges, the first and
6886      *         second array are equal and contain the same elements in the same
6887      *         order;
6888      *         a value less than {@code 0} if, over the specified ranges, the
6889      *         first array is lexicographically less than the second array; and
6890      *         a value greater than {@code 0} if, over the specified ranges, the
6891      *         first array is lexicographically greater than the second array
6892      * @throws IllegalArgumentException
6893      *         if {@code aFromIndex &gt; aToIndex} or
6894      *         if {@code bFromIndex &gt; bToIndex}
6895      * @throws ArrayIndexOutOfBoundsException
6896      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
6897      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
6898      * @throws NullPointerException
6899      *         if either array is {@code null}
6900      * @since 9
6901      */
6902     public static int compare(long[] a, int aFromIndex, int aToIndex,
6903                               long[] b, int bFromIndex, int bToIndex) {
6904         rangeCheck(a.length, aFromIndex, aToIndex);
6905         rangeCheck(b.length, bFromIndex, bToIndex);
6906 
6907         int aLength = aToIndex - aFromIndex;
6908         int bLength = bToIndex - bFromIndex;
6909         int i = ArraysSupport.mismatch(a, aFromIndex,
6910                                        b, bFromIndex,
6911                                        Math.min(aLength, bLength));
6912         if (i &gt;= 0) {
6913             return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);
6914         }
6915 
6916         return aLength - bLength;
6917     }
6918 
6919     /**
6920      * Compares two {@code long} arrays lexicographically, numerically treating
6921      * elements as unsigned.
6922      *
6923      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
6924      * comparison is the result of comparing two elements, as if by
6925      * {@link Long#compareUnsigned(long, long)}, at an index within the
6926      * respective arrays that is the prefix length.
6927      * Otherwise, one array is a proper prefix of the other and, lexicographic
6928      * comparison is the result of comparing the two array lengths.
6929      * (See {@link #mismatch(long[], long[])} for the definition of a common
6930      * and proper prefix.)
6931      *
6932      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
6933      * than a non-{@code null} array reference.  Two {@code null} array
6934      * references are considered equal.
6935      *
6936      * @apiNote
6937      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
6938      * &lt;pre&gt;{@code
6939      *     int i = Arrays.mismatch(a, b);
6940      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
6941      *         return Long.compareUnsigned(a[i], b[i]);
6942      *     return a.length - b.length;
6943      * }&lt;/pre&gt;
6944      *
6945      * @param a the first array to compare
6946      * @param b the second array to compare
6947      * @return the value {@code 0} if the first and second array are
6948      *         equal and contain the same elements in the same order;
6949      *         a value less than {@code 0} if the first array is
6950      *         lexicographically less than the second array; and
6951      *         a value greater than {@code 0} if the first array is
6952      *         lexicographically greater than the second array
6953      * @since 9
6954      */
6955     public static int compareUnsigned(long[] a, long[] b) {
6956         if (a == b)
6957             return 0;
6958         if (a == null || b == null)
6959             return a == null ? -1 : 1;
6960 
6961         int i = ArraysSupport.mismatch(a, b,
6962                                        Math.min(a.length, b.length));
6963         if (i &gt;= 0) {
6964             return Long.compareUnsigned(a[i], b[i]);
6965         }
6966 
6967         return a.length - b.length;
6968     }
6969 
6970     /**
6971      * Compares two {@code long} arrays lexicographically over the specified
6972      * ranges, numerically treating elements as unsigned.
6973      *
6974      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
6975      * then the lexicographic comparison is the result of comparing two
6976      * elements, as if by {@link Long#compareUnsigned(long, long)}, at a
6977      * relative index within the respective arrays that is the length of the
6978      * prefix.
6979      * Otherwise, one array is a proper prefix of the other and, lexicographic
6980      * comparison is the result of comparing the two range lengths.
6981      * (See {@link #mismatch(long[], int, int, long[], int, int)} for the
6982      * definition of a common and proper prefix.)
6983      *
6984      * @apiNote
6985      * &lt;p&gt;This method behaves as if:
6986      * &lt;pre&gt;{@code
6987      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
6988      *                             b, bFromIndex, bToIndex);
6989      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
6990      *         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
6991      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
6992      * }&lt;/pre&gt;
6993      *
6994      * @param a the first array to compare
6995      * @param aFromIndex the index (inclusive) of the first element in the
6996      *                   first array to be compared
6997      * @param aToIndex the index (exclusive) of the last element in the
6998      *                 first array to be compared
6999      * @param b the second array to compare
7000      * @param bFromIndex the index (inclusive) of the first element in the
7001      *                   second array to be compared
7002      * @param bToIndex the index (exclusive) of the last element in the
7003      *                 second array to be compared
7004      * @return the value {@code 0} if, over the specified ranges, the first and
7005      *         second array are equal and contain the same elements in the same
7006      *         order;
7007      *         a value less than {@code 0} if, over the specified ranges, the
7008      *         first array is lexicographically less than the second array; and
7009      *         a value greater than {@code 0} if, over the specified ranges, the
7010      *         first array is lexicographically greater than the second array
7011      * @throws IllegalArgumentException
7012      *         if {@code aFromIndex &gt; aToIndex} or
7013      *         if {@code bFromIndex &gt; bToIndex}
7014      * @throws ArrayIndexOutOfBoundsException
7015      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7016      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7017      * @throws NullPointerException
7018      *         if either array is null
7019      * @since 9
7020      */
7021     public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex,
7022                                       long[] b, int bFromIndex, int bToIndex) {
7023         rangeCheck(a.length, aFromIndex, aToIndex);
7024         rangeCheck(b.length, bFromIndex, bToIndex);
7025 
7026         int aLength = aToIndex - aFromIndex;
7027         int bLength = bToIndex - bFromIndex;
7028         int i = ArraysSupport.mismatch(a, aFromIndex,
7029                                        b, bFromIndex,
7030                                        Math.min(aLength, bLength));
7031         if (i &gt;= 0) {
7032             return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
7033         }
7034 
7035         return aLength - bLength;
7036     }
7037 
7038     // Compare float
7039 
7040     /**
7041      * Compares two {@code float} arrays lexicographically.
7042      *
7043      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
7044      * comparison is the result of comparing two elements, as if by
7045      * {@link Float#compare(float, float)}, at an index within the respective
7046      * arrays that is the prefix length.
7047      * Otherwise, one array is a proper prefix of the other and, lexicographic
7048      * comparison is the result of comparing the two array lengths.
7049      * (See {@link #mismatch(float[], float[])} for the definition of a common
7050      * and proper prefix.)
7051      *
7052      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
7053      * than a non-{@code null} array reference.  Two {@code null} array
7054      * references are considered equal.
7055      *
7056      * &lt;p&gt;The comparison is consistent with {@link #equals(float[], float[]) equals},
7057      * more specifically the following holds for arrays {@code a} and {@code b}:
7058      * &lt;pre&gt;{@code
7059      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
7060      * }&lt;/pre&gt;
7061      *
7062      * @apiNote
7063      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
7064      * &lt;pre&gt;{@code
7065      *     int i = Arrays.mismatch(a, b);
7066      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
7067      *         return Float.compare(a[i], b[i]);
7068      *     return a.length - b.length;
7069      * }&lt;/pre&gt;
7070      *
7071      * @param a the first array to compare
7072      * @param b the second array to compare
7073      * @return the value {@code 0} if the first and second array are equal and
7074      *         contain the same elements in the same order;
7075      *         a value less than {@code 0} if the first array is
7076      *         lexicographically less than the second array; and
7077      *         a value greater than {@code 0} if the first array is
7078      *         lexicographically greater than the second array
7079      * @since 9
7080      */
7081     public static int compare(float[] a, float[] b) {
7082         if (a == b)
7083             return 0;
7084         if (a == null || b == null)
7085             return a == null ? -1 : 1;
7086 
7087         int i = ArraysSupport.mismatch(a, b,
7088                                        Math.min(a.length, b.length));
7089         if (i &gt;= 0) {
7090             return Float.compare(a[i], b[i]);
7091         }
7092 
7093         return a.length - b.length;
7094     }
7095 
7096     /**
7097      * Compares two {@code float} arrays lexicographically over the specified
7098      * ranges.
7099      *
7100      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7101      * then the lexicographic comparison is the result of comparing two
7102      * elements, as if by {@link Float#compare(float, float)}, at a relative
7103      * index within the respective arrays that is the length of the prefix.
7104      * Otherwise, one array is a proper prefix of the other and, lexicographic
7105      * comparison is the result of comparing the two range lengths.
7106      * (See {@link #mismatch(float[], int, int, float[], int, int)} for the
7107      * definition of a common and proper prefix.)
7108      *
7109      * &lt;p&gt;The comparison is consistent with
7110      * {@link #equals(float[], int, int, float[], int, int) equals}, more
7111      * specifically the following holds for arrays {@code a} and {@code b} with
7112      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
7113      * [{@code bFromIndex}, {@code btoIndex}) respectively:
7114      * &lt;pre&gt;{@code
7115      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
7116      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
7117      * }&lt;/pre&gt;
7118      *
7119      * @apiNote
7120      * &lt;p&gt;This method behaves as if:
7121      * &lt;pre&gt;{@code
7122      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
7123      *                             b, bFromIndex, bToIndex);
7124      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7125      *         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);
7126      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
7127      * }&lt;/pre&gt;
7128      *
7129      * @param a the first array to compare
7130      * @param aFromIndex the index (inclusive) of the first element in the
7131      *                   first array to be compared
7132      * @param aToIndex the index (exclusive) of the last element in the
7133      *                 first array to be compared
7134      * @param b the second array to compare
7135      * @param bFromIndex the index (inclusive) of the first element in the
7136      *                   second array to be compared
7137      * @param bToIndex the index (exclusive) of the last element in the
7138      *                 second array to be compared
7139      * @return the value {@code 0} if, over the specified ranges, the first and
7140      *         second array are equal and contain the same elements in the same
7141      *         order;
7142      *         a value less than {@code 0} if, over the specified ranges, the
7143      *         first array is lexicographically less than the second array; and
7144      *         a value greater than {@code 0} if, over the specified ranges, the
7145      *         first array is lexicographically greater than the second array
7146      * @throws IllegalArgumentException
7147      *         if {@code aFromIndex &gt; aToIndex} or
7148      *         if {@code bFromIndex &gt; bToIndex}
7149      * @throws ArrayIndexOutOfBoundsException
7150      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7151      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7152      * @throws NullPointerException
7153      *         if either array is {@code null}
7154      * @since 9
7155      */
7156     public static int compare(float[] a, int aFromIndex, int aToIndex,
7157                               float[] b, int bFromIndex, int bToIndex) {
7158         rangeCheck(a.length, aFromIndex, aToIndex);
7159         rangeCheck(b.length, bFromIndex, bToIndex);
7160 
7161         int aLength = aToIndex - aFromIndex;
7162         int bLength = bToIndex - bFromIndex;
7163         int i = ArraysSupport.mismatch(a, aFromIndex,
7164                                        b, bFromIndex,
7165                                        Math.min(aLength, bLength));
7166         if (i &gt;= 0) {
7167             return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);
7168         }
7169 
7170         return aLength - bLength;
7171     }
7172 
7173     // Compare double
7174 
7175     /**
7176      * Compares two {@code double} arrays lexicographically.
7177      *
7178      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
7179      * comparison is the result of comparing two elements, as if by
7180      * {@link Double#compare(double, double)}, at an index within the respective
7181      * arrays that is the prefix length.
7182      * Otherwise, one array is a proper prefix of the other and, lexicographic
7183      * comparison is the result of comparing the two array lengths.
7184      * (See {@link #mismatch(double[], double[])} for the definition of a common
7185      * and proper prefix.)
7186      *
7187      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
7188      * than a non-{@code null} array reference.  Two {@code null} array
7189      * references are considered equal.
7190      *
7191      * &lt;p&gt;The comparison is consistent with {@link #equals(double[], double[]) equals},
7192      * more specifically the following holds for arrays {@code a} and {@code b}:
7193      * &lt;pre&gt;{@code
7194      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
7195      * }&lt;/pre&gt;
7196      *
7197      * @apiNote
7198      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
7199      * &lt;pre&gt;{@code
7200      *     int i = Arrays.mismatch(a, b);
7201      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
7202      *         return Double.compare(a[i], b[i]);
7203      *     return a.length - b.length;
7204      * }&lt;/pre&gt;
7205      *
7206      * @param a the first array to compare
7207      * @param b the second array to compare
7208      * @return the value {@code 0} if the first and second array are equal and
7209      *         contain the same elements in the same order;
7210      *         a value less than {@code 0} if the first array is
7211      *         lexicographically less than the second array; and
7212      *         a value greater than {@code 0} if the first array is
7213      *         lexicographically greater than the second array
7214      * @since 9
7215      */
7216     public static int compare(double[] a, double[] b) {
7217         if (a == b)
7218             return 0;
7219         if (a == null || b == null)
7220             return a == null ? -1 : 1;
7221 
7222         int i = ArraysSupport.mismatch(a, b,
7223                                        Math.min(a.length, b.length));
7224         if (i &gt;= 0) {
7225             return Double.compare(a[i], b[i]);
7226         }
7227 
7228         return a.length - b.length;
7229     }
7230 
7231     /**
7232      * Compares two {@code double} arrays lexicographically over the specified
7233      * ranges.
7234      *
7235      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7236      * then the lexicographic comparison is the result of comparing two
7237      * elements, as if by {@link Double#compare(double, double)}, at a relative
7238      * index within the respective arrays that is the length of the prefix.
7239      * Otherwise, one array is a proper prefix of the other and, lexicographic
7240      * comparison is the result of comparing the two range lengths.
7241      * (See {@link #mismatch(double[], int, int, double[], int, int)} for the
7242      * definition of a common and proper prefix.)
7243      *
7244      * &lt;p&gt;The comparison is consistent with
7245      * {@link #equals(double[], int, int, double[], int, int) equals}, more
7246      * specifically the following holds for arrays {@code a} and {@code b} with
7247      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
7248      * [{@code bFromIndex}, {@code btoIndex}) respectively:
7249      * &lt;pre&gt;{@code
7250      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
7251      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
7252      * }&lt;/pre&gt;
7253      *
7254      * @apiNote
7255      * &lt;p&gt;This method behaves as if:
7256      * &lt;pre&gt;{@code
7257      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
7258      *                             b, bFromIndex, bToIndex);
7259      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7260      *         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);
7261      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
7262      * }&lt;/pre&gt;
7263      *
7264      * @param a the first array to compare
7265      * @param aFromIndex the index (inclusive) of the first element in the
7266      *                   first array to be compared
7267      * @param aToIndex the index (exclusive) of the last element in the
7268      *                 first array to be compared
7269      * @param b the second array to compare
7270      * @param bFromIndex the index (inclusive) of the first element in the
7271      *                   second array to be compared
7272      * @param bToIndex the index (exclusive) of the last element in the
7273      *                 second array to be compared
7274      * @return the value {@code 0} if, over the specified ranges, the first and
7275      *         second array are equal and contain the same elements in the same
7276      *         order;
7277      *         a value less than {@code 0} if, over the specified ranges, the
7278      *         first array is lexicographically less than the second array; and
7279      *         a value greater than {@code 0} if, over the specified ranges, the
7280      *         first array is lexicographically greater than the second array
7281      * @throws IllegalArgumentException
7282      *         if {@code aFromIndex &gt; aToIndex} or
7283      *         if {@code bFromIndex &gt; bToIndex}
7284      * @throws ArrayIndexOutOfBoundsException
7285      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7286      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7287      * @throws NullPointerException
7288      *         if either array is {@code null}
7289      * @since 9
7290      */
7291     public static int compare(double[] a, int aFromIndex, int aToIndex,
7292                               double[] b, int bFromIndex, int bToIndex) {
7293         rangeCheck(a.length, aFromIndex, aToIndex);
7294         rangeCheck(b.length, bFromIndex, bToIndex);
7295 
7296         int aLength = aToIndex - aFromIndex;
7297         int bLength = bToIndex - bFromIndex;
7298         int i = ArraysSupport.mismatch(a, aFromIndex,
7299                                        b, bFromIndex,
7300                                        Math.min(aLength, bLength));
7301         if (i &gt;= 0) {
7302             return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);
7303         }
7304 
7305         return aLength - bLength;
7306     }
7307 
7308     // Compare objects
7309 
7310     /**
7311      * Compares two {@code Object} arrays, within comparable elements,
7312      * lexicographically.
7313      *
7314      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
7315      * comparison is the result of comparing two elements of type {@code T} at
7316      * an index {@code i} within the respective arrays that is the prefix
7317      * length, as if by:
7318      * &lt;pre&gt;{@code
7319      *     Comparator.nullsFirst(Comparator.&lt;T&gt;naturalOrder()).
7320      *         compare(a[i], b[i])
7321      * }&lt;/pre&gt;
7322      * Otherwise, one array is a proper prefix of the other and, lexicographic
7323      * comparison is the result of comparing the two array lengths.
7324      * (See {@link #mismatch(Object[], Object[])} for the definition of a common
7325      * and proper prefix.)
7326      *
7327      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
7328      * than a non-{@code null} array reference.  Two {@code null} array
7329      * references are considered equal.
7330      * A {@code null} array element is considered lexicographically than a
7331      * non-{@code null} array element.  Two {@code null} array elements are
7332      * considered equal.
7333      *
7334      * &lt;p&gt;The comparison is consistent with {@link #equals(Object[], Object[]) equals},
7335      * more specifically the following holds for arrays {@code a} and {@code b}:
7336      * &lt;pre&gt;{@code
7337      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
7338      * }&lt;/pre&gt;
7339      *
7340      * @apiNote
7341      * &lt;p&gt;This method behaves as if (for non-{@code null} array references
7342      * and elements):
7343      * &lt;pre&gt;{@code
7344      *     int i = Arrays.mismatch(a, b);
7345      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
7346      *         return a[i].compareTo(b[i]);
7347      *     return a.length - b.length;
7348      * }&lt;/pre&gt;
7349      *
7350      * @param a the first array to compare
7351      * @param b the second array to compare
7352      * @param &lt;T&gt; the type of comparable array elements
7353      * @return the value {@code 0} if the first and second array are equal and
7354      *         contain the same elements in the same order;
7355      *         a value less than {@code 0} if the first array is
7356      *         lexicographically less than the second array; and
7357      *         a value greater than {@code 0} if the first array is
7358      *         lexicographically greater than the second array
7359      * @since 9
7360      */
7361     public static &lt;T extends Comparable&lt;? super T&gt;&gt; int compare(T[] a, T[] b) {
7362         if (a == b)
7363             return 0;
7364         // A null array is less than a non-null array
7365         if (a == null || b == null)
7366             return a == null ? -1 : 1;
7367 
7368         int length = Math.min(a.length, b.length);
7369         for (int i = 0; i &lt; length; i++) {
7370             T oa = a[i];
7371             T ob = b[i];
7372             if (oa != ob) {
7373                 // A null element is less than a non-null element
7374                 if (oa == null || ob == null)
7375                     return oa == null ? -1 : 1;
7376                 int v = oa.compareTo(ob);
7377                 if (v != 0) {
7378                     return v;
7379                 }
7380             }
7381         }
7382 
7383         return a.length - b.length;
7384     }
7385 
7386     /**
7387      * Compares two {@code Object} arrays lexicographically over the specified
7388      * ranges.
7389      *
7390      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7391      * then the lexicographic comparison is the result of comparing two
7392      * elements of type {@code T} at a relative index {@code i} within the
7393      * respective arrays that is the prefix length, as if by:
7394      * &lt;pre&gt;{@code
7395      *     Comparator.nullsFirst(Comparator.&lt;T&gt;naturalOrder()).
7396      *         compare(a[aFromIndex + i, b[bFromIndex + i])
7397      * }&lt;/pre&gt;
7398      * Otherwise, one array is a proper prefix of the other and, lexicographic
7399      * comparison is the result of comparing the two range lengths.
7400      * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the
7401      * definition of a common and proper prefix.)
7402      *
7403      * &lt;p&gt;The comparison is consistent with
7404      * {@link #equals(Object[], int, int, Object[], int, int) equals}, more
7405      * specifically the following holds for arrays {@code a} and {@code b} with
7406      * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
7407      * [{@code bFromIndex}, {@code btoIndex}) respectively:
7408      * &lt;pre&gt;{@code
7409      *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
7410      *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
7411      * }&lt;/pre&gt;
7412      *
7413      * @apiNote
7414      * &lt;p&gt;This method behaves as if (for non-{@code null} array elements):
7415      * &lt;pre&gt;{@code
7416      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
7417      *                             b, bFromIndex, bToIndex);
7418      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7419      *         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);
7420      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
7421      * }&lt;/pre&gt;
7422      *
7423      * @param a the first array to compare
7424      * @param aFromIndex the index (inclusive) of the first element in the
7425      *                   first array to be compared
7426      * @param aToIndex the index (exclusive) of the last element in the
7427      *                 first array to be compared
7428      * @param b the second array to compare
7429      * @param bFromIndex the index (inclusive) of the first element in the
7430      *                   second array to be compared
7431      * @param bToIndex the index (exclusive) of the last element in the
7432      *                 second array to be compared
7433      * @param &lt;T&gt; the type of comparable array elements
7434      * @return the value {@code 0} if, over the specified ranges, the first and
7435      *         second array are equal and contain the same elements in the same
7436      *         order;
7437      *         a value less than {@code 0} if, over the specified ranges, the
7438      *         first array is lexicographically less than the second array; and
7439      *         a value greater than {@code 0} if, over the specified ranges, the
7440      *         first array is lexicographically greater than the second array
7441      * @throws IllegalArgumentException
7442      *         if {@code aFromIndex &gt; aToIndex} or
7443      *         if {@code bFromIndex &gt; bToIndex}
7444      * @throws ArrayIndexOutOfBoundsException
7445      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7446      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7447      * @throws NullPointerException
7448      *         if either array is {@code null}
7449      * @since 9
7450      */
7451     public static &lt;T extends Comparable&lt;? super T&gt;&gt; int compare(
7452             T[] a, int aFromIndex, int aToIndex,
7453             T[] b, int bFromIndex, int bToIndex) {
7454         rangeCheck(a.length, aFromIndex, aToIndex);
7455         rangeCheck(b.length, bFromIndex, bToIndex);
7456 
7457         int aLength = aToIndex - aFromIndex;
7458         int bLength = bToIndex - bFromIndex;
7459         int length = Math.min(aLength, bLength);
7460         for (int i = 0; i &lt; length; i++) {
7461             T oa = a[aFromIndex++];
7462             T ob = b[bFromIndex++];
7463             if (oa != ob) {
7464                 if (oa == null || ob == null)
7465                     return oa == null ? -1 : 1;
7466                 int v = oa.compareTo(ob);
7467                 if (v != 0) {
7468                     return v;
7469                 }
7470             }
7471         }
7472 
7473         return aLength - bLength;
7474     }
7475 
7476     /**
7477      * Compares two {@code Object} arrays lexicographically using a specified
7478      * comparator.
7479      *
7480      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
7481      * comparison is the result of comparing with the specified comparator two
7482      * elements at an index within the respective arrays that is the prefix
7483      * length.
7484      * Otherwise, one array is a proper prefix of the other and, lexicographic
7485      * comparison is the result of comparing the two array lengths.
7486      * (See {@link #mismatch(Object[], Object[])} for the definition of a common
7487      * and proper prefix.)
7488      *
7489      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
7490      * than a non-{@code null} array reference.  Two {@code null} array
7491      * references are considered equal.
7492      *
7493      * @apiNote
7494      * &lt;p&gt;This method behaves as if (for non-{@code null} array references):
7495      * &lt;pre&gt;{@code
7496      *     int i = Arrays.mismatch(a, b, cmp);
7497      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
7498      *         return cmp.compare(a[i], b[i]);
7499      *     return a.length - b.length;
7500      * }&lt;/pre&gt;
7501      *
7502      * @param a the first array to compare
7503      * @param b the second array to compare
7504      * @param cmp the comparator to compare array elements
7505      * @param &lt;T&gt; the type of array elements
7506      * @return the value {@code 0} if the first and second array are equal and
7507      *         contain the same elements in the same order;
7508      *         a value less than {@code 0} if the first array is
7509      *         lexicographically less than the second array; and
7510      *         a value greater than {@code 0} if the first array is
7511      *         lexicographically greater than the second array
7512      * @throws NullPointerException if the comparator is {@code null}
7513      * @since 9
7514      */
7515     public static &lt;T&gt; int compare(T[] a, T[] b,
7516                                   Comparator&lt;? super T&gt; cmp) {
7517         Objects.requireNonNull(cmp);
7518         if (a == b)
7519             return 0;
7520         if (a == null || b == null)
7521             return a == null ? -1 : 1;
7522 
7523         int length = Math.min(a.length, b.length);
7524         for (int i = 0; i &lt; length; i++) {
7525             T oa = a[i];
7526             T ob = b[i];
7527             if (oa != ob) {
7528                 // Null-value comparison is deferred to the comparator
7529                 int v = cmp.compare(oa, ob);
7530                 if (v != 0) {
7531                     return v;
7532                 }
7533             }
7534         }
7535 
7536         return a.length - b.length;
7537     }
7538 
7539     /**
7540      * Compares two {@code Object} arrays lexicographically over the specified
7541      * ranges.
7542      *
7543      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7544      * then the lexicographic comparison is the result of comparing with the
7545      * specified comparator two elements at a relative index within the
7546      * respective arrays that is the prefix length.
7547      * Otherwise, one array is a proper prefix of the other and, lexicographic
7548      * comparison is the result of comparing the two range lengths.
7549      * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the
7550      * definition of a common and proper prefix.)
7551      *
7552      * @apiNote
7553      * &lt;p&gt;This method behaves as if (for non-{@code null} array elements):
7554      * &lt;pre&gt;{@code
7555      *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
7556      *                             b, bFromIndex, bToIndex, cmp);
7557      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7558      *         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);
7559      *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
7560      * }&lt;/pre&gt;
7561      *
7562      * @param a the first array to compare
7563      * @param aFromIndex the index (inclusive) of the first element in the
7564      *                   first array to be compared
7565      * @param aToIndex the index (exclusive) of the last element in the
7566      *                 first array to be compared
7567      * @param b the second array to compare
7568      * @param bFromIndex the index (inclusive) of the first element in the
7569      *                   second array to be compared
7570      * @param bToIndex the index (exclusive) of the last element in the
7571      *                 second array to be compared
7572      * @param cmp the comparator to compare array elements
7573      * @param &lt;T&gt; the type of array elements
7574      * @return the value {@code 0} if, over the specified ranges, the first and
7575      *         second array are equal and contain the same elements in the same
7576      *         order;
7577      *         a value less than {@code 0} if, over the specified ranges, the
7578      *         first array is lexicographically less than the second array; and
7579      *         a value greater than {@code 0} if, over the specified ranges, the
7580      *         first array is lexicographically greater than the second array
7581      * @throws IllegalArgumentException
7582      *         if {@code aFromIndex &gt; aToIndex} or
7583      *         if {@code bFromIndex &gt; bToIndex}
7584      * @throws ArrayIndexOutOfBoundsException
7585      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7586      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7587      * @throws NullPointerException
7588      *         if either array or the comparator is {@code null}
7589      * @since 9
7590      */
7591     public static &lt;T&gt; int compare(
7592             T[] a, int aFromIndex, int aToIndex,
7593             T[] b, int bFromIndex, int bToIndex,
7594             Comparator&lt;? super T&gt; cmp) {
7595         Objects.requireNonNull(cmp);
7596         rangeCheck(a.length, aFromIndex, aToIndex);
7597         rangeCheck(b.length, bFromIndex, bToIndex);
7598 
7599         int aLength = aToIndex - aFromIndex;
7600         int bLength = bToIndex - bFromIndex;
7601         int length = Math.min(aLength, bLength);
7602         for (int i = 0; i &lt; length; i++) {
7603             T oa = a[aFromIndex++];
7604             T ob = b[bFromIndex++];
7605             if (oa != ob) {
7606                 // Null-value comparison is deferred to the comparator
7607                 int v = cmp.compare(oa, ob);
7608                 if (v != 0) {
7609                     return v;
7610                 }
7611             }
7612         }
7613 
7614         return aLength - bLength;
7615     }
7616 
7617 
7618     // Mismatch methods
7619 
7620     // Mismatch boolean
7621 
7622     /**
7623      * Finds and returns the index of the first mismatch between two
7624      * {@code boolean} arrays, otherwise return -1 if no mismatch is found.  The
7625      * index will be in the range of 0 (inclusive) up to the length (inclusive)
7626      * of the smaller array.
7627      *
7628      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
7629      * length of the common prefix and it follows that there is a mismatch
7630      * between the two elements at that index within the respective arrays.
7631      * If one array is a proper prefix of the other then the returned index is
7632      * the length of the smaller array and it follows that the index is only
7633      * valid for the larger array.
7634      * Otherwise, there is no mismatch.
7635      *
7636      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
7637      * prefix of length {@code pl} if the following expression is true:
7638      * &lt;pre&gt;{@code
7639      *     pl &gt;= 0 &amp;&amp;
7640      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
7641      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
7642      *     a[pl] != b[pl]
7643      * }&lt;/pre&gt;
7644      * Note that a common prefix length of {@code 0} indicates that the first
7645      * elements from each array mismatch.
7646      *
7647      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
7648      * prefix if the following expression is true:
7649      * &lt;pre&gt;{@code
7650      *     a.length != b.length &amp;&amp;
7651      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
7652      *                   b, 0, Math.min(a.length, b.length))
7653      * }&lt;/pre&gt;
7654      *
7655      * @param a the first array to be tested for a mismatch
7656      * @param b the second array to be tested for a mismatch
7657      * @return the index of the first mismatch between the two arrays,
7658      *         otherwise {@code -1}.
7659      * @throws NullPointerException
7660      *         if either array is {@code null}
7661      * @since 9
7662      */
7663     public static int mismatch(boolean[] a, boolean[] b) {
7664         int length = Math.min(a.length, b.length); // Check null array refs
7665         if (a == b)
7666             return -1;
7667 
7668         int i = ArraysSupport.mismatch(a, b, length);
7669         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
7670     }
7671 
7672     /**
7673      * Finds and returns the relative index of the first mismatch between two
7674      * {@code boolean} arrays over the specified ranges, otherwise return -1 if
7675      * no mismatch is found.  The index will be in the range of 0 (inclusive) up
7676      * to the length (inclusive) of the smaller range.
7677      *
7678      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7679      * then the returned relative index is the length of the common prefix and
7680      * it follows that there is a mismatch between the two elements at that
7681      * relative index within the respective arrays.
7682      * If one array is a proper prefix of the other, over the specified ranges,
7683      * then the returned relative index is the length of the smaller range and
7684      * it follows that the relative index is only valid for the array with the
7685      * larger range.
7686      * Otherwise, there is no mismatch.
7687      *
7688      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7689      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7690      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7691      * prefix of length {@code pl} if the following expression is true:
7692      * &lt;pre&gt;{@code
7693      *     pl &gt;= 0 &amp;&amp;
7694      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7695      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7696      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7697      * }&lt;/pre&gt;
7698      * Note that a common prefix length of {@code 0} indicates that the first
7699      * elements from each array mismatch.
7700      *
7701      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7702      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7703      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
7704      * if the following expression is true:
7705      * &lt;pre&gt;{@code
7706      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7707      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7708      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7709      * }&lt;/pre&gt;
7710      *
7711      * @param a the first array to be tested for a mismatch
7712      * @param aFromIndex the index (inclusive) of the first element in the
7713      *                   first array to be tested
7714      * @param aToIndex the index (exclusive) of the last element in the
7715      *                 first array to be tested
7716      * @param b the second array to be tested for a mismatch
7717      * @param bFromIndex the index (inclusive) of the first element in the
7718      *                   second array to be tested
7719      * @param bToIndex the index (exclusive) of the last element in the
7720      *                 second array to be tested
7721      * @return the relative index of the first mismatch between the two arrays
7722      *         over the specified ranges, otherwise {@code -1}.
7723      * @throws IllegalArgumentException
7724      *         if {@code aFromIndex &gt; aToIndex} or
7725      *         if {@code bFromIndex &gt; bToIndex}
7726      * @throws ArrayIndexOutOfBoundsException
7727      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7728      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7729      * @throws NullPointerException
7730      *         if either array is {@code null}
7731      * @since 9
7732      */
7733     public static int mismatch(boolean[] a, int aFromIndex, int aToIndex,
7734                                boolean[] b, int bFromIndex, int bToIndex) {
7735         rangeCheck(a.length, aFromIndex, aToIndex);
7736         rangeCheck(b.length, bFromIndex, bToIndex);
7737 
7738         int aLength = aToIndex - aFromIndex;
7739         int bLength = bToIndex - bFromIndex;
7740         int length = Math.min(aLength, bLength);
7741         int i = ArraysSupport.mismatch(a, aFromIndex,
7742                                        b, bFromIndex,
7743                                        length);
7744         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
7745     }
7746 
7747     // Mismatch byte
7748 
7749     /**
7750      * Finds and returns the index of the first mismatch between two {@code byte}
7751      * arrays, otherwise return -1 if no mismatch is found.  The index will be
7752      * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
7753      * array.
7754      *
7755      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
7756      * length of the common prefix and it follows that there is a mismatch
7757      * between the two elements at that index within the respective arrays.
7758      * If one array is a proper prefix of the other then the returned index is
7759      * the length of the smaller array and it follows that the index is only
7760      * valid for the larger array.
7761      * Otherwise, there is no mismatch.
7762      *
7763      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
7764      * prefix of length {@code pl} if the following expression is true:
7765      * &lt;pre&gt;{@code
7766      *     pl &gt;= 0 &amp;&amp;
7767      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
7768      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
7769      *     a[pl] != b[pl]
7770      * }&lt;/pre&gt;
7771      * Note that a common prefix length of {@code 0} indicates that the first
7772      * elements from each array mismatch.
7773      *
7774      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
7775      * prefix if the following expression is true:
7776      * &lt;pre&gt;{@code
7777      *     a.length != b.length &amp;&amp;
7778      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
7779      *                   b, 0, Math.min(a.length, b.length))
7780      * }&lt;/pre&gt;
7781      *
7782      * @param a the first array to be tested for a mismatch
7783      * @param b the second array to be tested for a mismatch
7784      * @return the index of the first mismatch between the two arrays,
7785      *         otherwise {@code -1}.
7786      * @throws NullPointerException
7787      *         if either array is {@code null}
7788      * @since 9
7789      */
7790     public static int mismatch(byte[] a, byte[] b) {
7791         int length = Math.min(a.length, b.length); // Check null array refs
7792         if (a == b)
7793             return -1;
7794 
7795         int i = ArraysSupport.mismatch(a, b, length);
7796         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
7797     }
7798 
7799     /**
7800      * Finds and returns the relative index of the first mismatch between two
7801      * {@code byte} arrays over the specified ranges, otherwise return -1 if no
7802      * mismatch is found.  The index will be in the range of 0 (inclusive) up to
7803      * the length (inclusive) of the smaller range.
7804      *
7805      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7806      * then the returned relative index is the length of the common prefix and
7807      * it follows that there is a mismatch between the two elements at that
7808      * relative index within the respective arrays.
7809      * If one array is a proper prefix of the other, over the specified ranges,
7810      * then the returned relative index is the length of the smaller range and
7811      * it follows that the relative index is only valid for the array with the
7812      * larger range.
7813      * Otherwise, there is no mismatch.
7814      *
7815      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7816      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7817      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7818      * prefix of length {@code pl} if the following expression is true:
7819      * &lt;pre&gt;{@code
7820      *     pl &gt;= 0 &amp;&amp;
7821      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7822      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7823      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7824      * }&lt;/pre&gt;
7825      * Note that a common prefix length of {@code 0} indicates that the first
7826      * elements from each array mismatch.
7827      *
7828      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7829      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7830      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
7831      * if the following expression is true:
7832      * &lt;pre&gt;{@code
7833      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7834      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7835      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7836      * }&lt;/pre&gt;
7837      *
7838      * @param a the first array to be tested for a mismatch
7839      * @param aFromIndex the index (inclusive) of the first element in the
7840      *                   first array to be tested
7841      * @param aToIndex the index (exclusive) of the last element in the
7842      *                 first array to be tested
7843      * @param b the second array to be tested for a mismatch
7844      * @param bFromIndex the index (inclusive) of the first element in the
7845      *                   second array to be tested
7846      * @param bToIndex the index (exclusive) of the last element in the
7847      *                 second array to be tested
7848      * @return the relative index of the first mismatch between the two arrays
7849      *         over the specified ranges, otherwise {@code -1}.
7850      * @throws IllegalArgumentException
7851      *         if {@code aFromIndex &gt; aToIndex} or
7852      *         if {@code bFromIndex &gt; bToIndex}
7853      * @throws ArrayIndexOutOfBoundsException
7854      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7855      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7856      * @throws NullPointerException
7857      *         if either array is {@code null}
7858      * @since 9
7859      */
7860     public static int mismatch(byte[] a, int aFromIndex, int aToIndex,
7861                                byte[] b, int bFromIndex, int bToIndex) {
7862         rangeCheck(a.length, aFromIndex, aToIndex);
7863         rangeCheck(b.length, bFromIndex, bToIndex);
7864 
7865         int aLength = aToIndex - aFromIndex;
7866         int bLength = bToIndex - bFromIndex;
7867         int length = Math.min(aLength, bLength);
7868         int i = ArraysSupport.mismatch(a, aFromIndex,
7869                                        b, bFromIndex,
7870                                        length);
7871         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
7872     }
7873 
7874     // Mismatch char
7875 
7876     /**
7877      * Finds and returns the index of the first mismatch between two {@code char}
7878      * arrays, otherwise return -1 if no mismatch is found.  The index will be
7879      * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
7880      * array.
7881      *
7882      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
7883      * length of the common prefix and it follows that there is a mismatch
7884      * between the two elements at that index within the respective arrays.
7885      * If one array is a proper prefix of the other then the returned index is
7886      * the length of the smaller array and it follows that the index is only
7887      * valid for the larger array.
7888      * Otherwise, there is no mismatch.
7889      *
7890      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
7891      * prefix of length {@code pl} if the following expression is true:
7892      * &lt;pre&gt;{@code
7893      *     pl &gt;= 0 &amp;&amp;
7894      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
7895      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
7896      *     a[pl] != b[pl]
7897      * }&lt;/pre&gt;
7898      * Note that a common prefix length of {@code 0} indicates that the first
7899      * elements from each array mismatch.
7900      *
7901      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
7902      * prefix if the following expression is true:
7903      * &lt;pre&gt;{@code
7904      *     a.length != b.length &amp;&amp;
7905      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
7906      *                   b, 0, Math.min(a.length, b.length))
7907      * }&lt;/pre&gt;
7908      *
7909      * @param a the first array to be tested for a mismatch
7910      * @param b the second array to be tested for a mismatch
7911      * @return the index of the first mismatch between the two arrays,
7912      *         otherwise {@code -1}.
7913      * @throws NullPointerException
7914      *         if either array is {@code null}
7915      * @since 9
7916      */
7917     public static int mismatch(char[] a, char[] b) {
7918         int length = Math.min(a.length, b.length); // Check null array refs
7919         if (a == b)
7920             return -1;
7921 
7922         int i = ArraysSupport.mismatch(a, b, length);
7923         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
7924     }
7925 
7926     /**
7927      * Finds and returns the relative index of the first mismatch between two
7928      * {@code char} arrays over the specified ranges, otherwise return -1 if no
7929      * mismatch is found.  The index will be in the range of 0 (inclusive) up to
7930      * the length (inclusive) of the smaller range.
7931      *
7932      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
7933      * then the returned relative index is the length of the common prefix and
7934      * it follows that there is a mismatch between the two elements at that
7935      * relative index within the respective arrays.
7936      * If one array is a proper prefix of the other, over the specified ranges,
7937      * then the returned relative index is the length of the smaller range and
7938      * it follows that the relative index is only valid for the array with the
7939      * larger range.
7940      * Otherwise, there is no mismatch.
7941      *
7942      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7943      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7944      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7945      * prefix of length {@code pl} if the following expression is true:
7946      * &lt;pre&gt;{@code
7947      *     pl &gt;= 0 &amp;&amp;
7948      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7949      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7950      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7951      * }&lt;/pre&gt;
7952      * Note that a common prefix length of {@code 0} indicates that the first
7953      * elements from each array mismatch.
7954      *
7955      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7956      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7957      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
7958      * if the following expression is true:
7959      * &lt;pre&gt;{@code
7960      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7961      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7962      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7963      * }&lt;/pre&gt;
7964      *
7965      * @param a the first array to be tested for a mismatch
7966      * @param aFromIndex the index (inclusive) of the first element in the
7967      *                   first array to be tested
7968      * @param aToIndex the index (exclusive) of the last element in the
7969      *                 first array to be tested
7970      * @param b the second array to be tested for a mismatch
7971      * @param bFromIndex the index (inclusive) of the first element in the
7972      *                   second array to be tested
7973      * @param bToIndex the index (exclusive) of the last element in the
7974      *                 second array to be tested
7975      * @return the relative index of the first mismatch between the two arrays
7976      *         over the specified ranges, otherwise {@code -1}.
7977      * @throws IllegalArgumentException
7978      *         if {@code aFromIndex &gt; aToIndex} or
7979      *         if {@code bFromIndex &gt; bToIndex}
7980      * @throws ArrayIndexOutOfBoundsException
7981      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
7982      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
7983      * @throws NullPointerException
7984      *         if either array is {@code null}
7985      * @since 9
7986      */
7987     public static int mismatch(char[] a, int aFromIndex, int aToIndex,
7988                                char[] b, int bFromIndex, int bToIndex) {
7989         rangeCheck(a.length, aFromIndex, aToIndex);
7990         rangeCheck(b.length, bFromIndex, bToIndex);
7991 
7992         int aLength = aToIndex - aFromIndex;
7993         int bLength = bToIndex - bFromIndex;
7994         int length = Math.min(aLength, bLength);
7995         int i = ArraysSupport.mismatch(a, aFromIndex,
7996                                        b, bFromIndex,
7997                                        length);
7998         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
7999     }
8000 
8001     // Mismatch short
8002 
8003     /**
8004      * Finds and returns the index of the first mismatch between two {@code short}
8005      * arrays, otherwise return -1 if no mismatch is found.  The index will be
8006      * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
8007      * array.
8008      *
8009      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8010      * length of the common prefix and it follows that there is a mismatch
8011      * between the two elements at that index within the respective arrays.
8012      * If one array is a proper prefix of the other then the returned index is
8013      * the length of the smaller array and it follows that the index is only
8014      * valid for the larger array.
8015      * Otherwise, there is no mismatch.
8016      *
8017      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8018      * prefix of length {@code pl} if the following expression is true:
8019      * &lt;pre&gt;{@code
8020      *     pl &gt;= 0 &amp;&amp;
8021      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8022      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
8023      *     a[pl] != b[pl]
8024      * }&lt;/pre&gt;
8025      * Note that a common prefix length of {@code 0} indicates that the first
8026      * elements from each array mismatch.
8027      *
8028      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8029      * prefix if the following expression is true:
8030      * &lt;pre&gt;{@code
8031      *     a.length != b.length &amp;&amp;
8032      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8033      *                   b, 0, Math.min(a.length, b.length))
8034      * }&lt;/pre&gt;
8035      *
8036      * @param a the first array to be tested for a mismatch
8037      * @param b the second array to be tested for a mismatch
8038      * @return the index of the first mismatch between the two arrays,
8039      *         otherwise {@code -1}.
8040      * @throws NullPointerException
8041      *         if either array is {@code null}
8042      * @since 9
8043      */
8044     public static int mismatch(short[] a, short[] b) {
8045         int length = Math.min(a.length, b.length); // Check null array refs
8046         if (a == b)
8047             return -1;
8048 
8049         int i = ArraysSupport.mismatch(a, b, length);
8050         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
8051     }
8052 
8053     /**
8054      * Finds and returns the relative index of the first mismatch between two
8055      * {@code short} arrays over the specified ranges, otherwise return -1 if no
8056      * mismatch is found.  The index will be in the range of 0 (inclusive) up to
8057      * the length (inclusive) of the smaller range.
8058      *
8059      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8060      * then the returned relative index is the length of the common prefix and
8061      * it follows that there is a mismatch between the two elements at that
8062      * relative index within the respective arrays.
8063      * If one array is a proper prefix of the other, over the specified ranges,
8064      * then the returned relative index is the length of the smaller range and
8065      * it follows that the relative index is only valid for the array with the
8066      * larger range.
8067      * Otherwise, there is no mismatch.
8068      *
8069      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8070      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8071      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8072      * prefix of length {@code pl} if the following expression is true:
8073      * &lt;pre&gt;{@code
8074      *     pl &gt;= 0 &amp;&amp;
8075      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8076      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8077      *     a[aFromIndex + pl] != b[bFromIndex + pl]
8078      * }&lt;/pre&gt;
8079      * Note that a common prefix length of {@code 0} indicates that the first
8080      * elements from each array mismatch.
8081      *
8082      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8083      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8084      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8085      * if the following expression is true:
8086      * &lt;pre&gt;{@code
8087      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8088      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8089      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8090      * }&lt;/pre&gt;
8091      *
8092      * @param a the first array to be tested for a mismatch
8093      * @param aFromIndex the index (inclusive) of the first element in the
8094      *                   first array to be tested
8095      * @param aToIndex the index (exclusive) of the last element in the
8096      *                 first array to be tested
8097      * @param b the second array to be tested for a mismatch
8098      * @param bFromIndex the index (inclusive) of the first element in the
8099      *                   second array to be tested
8100      * @param bToIndex the index (exclusive) of the last element in the
8101      *                 second array to be tested
8102      * @return the relative index of the first mismatch between the two arrays
8103      *         over the specified ranges, otherwise {@code -1}.
8104      * @throws IllegalArgumentException
8105      *         if {@code aFromIndex &gt; aToIndex} or
8106      *         if {@code bFromIndex &gt; bToIndex}
8107      * @throws ArrayIndexOutOfBoundsException
8108      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8109      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8110      * @throws NullPointerException
8111      *         if either array is {@code null}
8112      * @since 9
8113      */
8114     public static int mismatch(short[] a, int aFromIndex, int aToIndex,
8115                                short[] b, int bFromIndex, int bToIndex) {
8116         rangeCheck(a.length, aFromIndex, aToIndex);
8117         rangeCheck(b.length, bFromIndex, bToIndex);
8118 
8119         int aLength = aToIndex - aFromIndex;
8120         int bLength = bToIndex - bFromIndex;
8121         int length = Math.min(aLength, bLength);
8122         int i = ArraysSupport.mismatch(a, aFromIndex,
8123                                        b, bFromIndex,
8124                                        length);
8125         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
8126     }
8127 
8128     // Mismatch int
8129 
8130     /**
8131      * Finds and returns the index of the first mismatch between two {@code int}
8132      * arrays, otherwise return -1 if no mismatch is found.  The index will be
8133      * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
8134      * array.
8135      *
8136      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8137      * length of the common prefix and it follows that there is a mismatch
8138      * between the two elements at that index within the respective arrays.
8139      * If one array is a proper prefix of the other then the returned index is
8140      * the length of the smaller array and it follows that the index is only
8141      * valid for the larger array.
8142      * Otherwise, there is no mismatch.
8143      *
8144      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8145      * prefix of length {@code pl} if the following expression is true:
8146      * &lt;pre&gt;{@code
8147      *     pl &gt;= 0 &amp;&amp;
8148      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8149      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
8150      *     a[pl] != b[pl]
8151      * }&lt;/pre&gt;
8152      * Note that a common prefix length of {@code 0} indicates that the first
8153      * elements from each array mismatch.
8154      *
8155      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8156      * prefix if the following expression is true:
8157      * &lt;pre&gt;{@code
8158      *     a.length != b.length &amp;&amp;
8159      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8160      *                   b, 0, Math.min(a.length, b.length))
8161      * }&lt;/pre&gt;
8162      *
8163      * @param a the first array to be tested for a mismatch
8164      * @param b the second array to be tested for a mismatch
8165      * @return the index of the first mismatch between the two arrays,
8166      *         otherwise {@code -1}.
8167      * @throws NullPointerException
8168      *         if either array is {@code null}
8169      * @since 9
8170      */
8171     public static int mismatch(int[] a, int[] b) {
8172         int length = Math.min(a.length, b.length); // Check null array refs
8173         if (a == b)
8174             return -1;
8175 
8176         int i = ArraysSupport.mismatch(a, b, length);
8177         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
8178     }
8179 
8180     /**
8181      * Finds and returns the relative index of the first mismatch between two
8182      * {@code int} arrays over the specified ranges, otherwise return -1 if no
8183      * mismatch is found.  The index will be in the range of 0 (inclusive) up to
8184      * the length (inclusive) of the smaller range.
8185      *
8186      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8187      * then the returned relative index is the length of the common prefix and
8188      * it follows that there is a mismatch between the two elements at that
8189      * relative index within the respective arrays.
8190      * If one array is a proper prefix of the other, over the specified ranges,
8191      * then the returned relative index is the length of the smaller range and
8192      * it follows that the relative index is only valid for the array with the
8193      * larger range.
8194      * Otherwise, there is no mismatch.
8195      *
8196      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8197      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8198      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8199      * prefix of length {@code pl} if the following expression is true:
8200      * &lt;pre&gt;{@code
8201      *     pl &gt;= 0 &amp;&amp;
8202      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8203      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8204      *     a[aFromIndex + pl] != b[bFromIndex + pl]
8205      * }&lt;/pre&gt;
8206      * Note that a common prefix length of {@code 0} indicates that the first
8207      * elements from each array mismatch.
8208      *
8209      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8210      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8211      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8212      * if the following expression is true:
8213      * &lt;pre&gt;{@code
8214      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8215      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8216      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8217      * }&lt;/pre&gt;
8218      *
8219      * @param a the first array to be tested for a mismatch
8220      * @param aFromIndex the index (inclusive) of the first element in the
8221      *                   first array to be tested
8222      * @param aToIndex the index (exclusive) of the last element in the
8223      *                 first array to be tested
8224      * @param b the second array to be tested for a mismatch
8225      * @param bFromIndex the index (inclusive) of the first element in the
8226      *                   second array to be tested
8227      * @param bToIndex the index (exclusive) of the last element in the
8228      *                 second array to be tested
8229      * @return the relative index of the first mismatch between the two arrays
8230      *         over the specified ranges, otherwise {@code -1}.
8231      * @throws IllegalArgumentException
8232      *         if {@code aFromIndex &gt; aToIndex} or
8233      *         if {@code bFromIndex &gt; bToIndex}
8234      * @throws ArrayIndexOutOfBoundsException
8235      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8236      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8237      * @throws NullPointerException
8238      *         if either array is {@code null}
8239      * @since 9
8240      */
8241     public static int mismatch(int[] a, int aFromIndex, int aToIndex,
8242                                int[] b, int bFromIndex, int bToIndex) {
8243         rangeCheck(a.length, aFromIndex, aToIndex);
8244         rangeCheck(b.length, bFromIndex, bToIndex);
8245 
8246         int aLength = aToIndex - aFromIndex;
8247         int bLength = bToIndex - bFromIndex;
8248         int length = Math.min(aLength, bLength);
8249         int i = ArraysSupport.mismatch(a, aFromIndex,
8250                                        b, bFromIndex,
8251                                        length);
8252         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
8253     }
8254 
8255     // Mismatch long
8256 
8257     /**
8258      * Finds and returns the index of the first mismatch between two {@code long}
8259      * arrays, otherwise return -1 if no mismatch is found.  The index will be
8260      * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
8261      * array.
8262      *
8263      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8264      * length of the common prefix and it follows that there is a mismatch
8265      * between the two elements at that index within the respective arrays.
8266      * If one array is a proper prefix of the other then the returned index is
8267      * the length of the smaller array and it follows that the index is only
8268      * valid for the larger array.
8269      * Otherwise, there is no mismatch.
8270      *
8271      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8272      * prefix of length {@code pl} if the following expression is true:
8273      * &lt;pre&gt;{@code
8274      *     pl &gt;= 0 &amp;&amp;
8275      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8276      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
8277      *     a[pl] != b[pl]
8278      * }&lt;/pre&gt;
8279      * Note that a common prefix length of {@code 0} indicates that the first
8280      * elements from each array mismatch.
8281      *
8282      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8283      * prefix if the following expression is true:
8284      * &lt;pre&gt;{@code
8285      *     a.length != b.length &amp;&amp;
8286      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8287      *                   b, 0, Math.min(a.length, b.length))
8288      * }&lt;/pre&gt;
8289      *
8290      * @param a the first array to be tested for a mismatch
8291      * @param b the second array to be tested for a mismatch
8292      * @return the index of the first mismatch between the two arrays,
8293      *         otherwise {@code -1}.
8294      * @throws NullPointerException
8295      *         if either array is {@code null}
8296      * @since 9
8297      */
8298     public static int mismatch(long[] a, long[] b) {
8299         int length = Math.min(a.length, b.length); // Check null array refs
8300         if (a == b)
8301             return -1;
8302 
8303         int i = ArraysSupport.mismatch(a, b, length);
8304         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
8305     }
8306 
8307     /**
8308      * Finds and returns the relative index of the first mismatch between two
8309      * {@code long} arrays over the specified ranges, otherwise return -1 if no
8310      * mismatch is found.  The index will be in the range of 0 (inclusive) up to
8311      * the length (inclusive) of the smaller range.
8312      *
8313      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8314      * then the returned relative index is the length of the common prefix and
8315      * it follows that there is a mismatch between the two elements at that
8316      * relative index within the respective arrays.
8317      * If one array is a proper prefix of the other, over the specified ranges,
8318      * then the returned relative index is the length of the smaller range and
8319      * it follows that the relative index is only valid for the array with the
8320      * larger range.
8321      * Otherwise, there is no mismatch.
8322      *
8323      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8324      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8325      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8326      * prefix of length {@code pl} if the following expression is true:
8327      * &lt;pre&gt;{@code
8328      *     pl &gt;= 0 &amp;&amp;
8329      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8330      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8331      *     a[aFromIndex + pl] != b[bFromIndex + pl]
8332      * }&lt;/pre&gt;
8333      * Note that a common prefix length of {@code 0} indicates that the first
8334      * elements from each array mismatch.
8335      *
8336      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8337      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8338      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8339      * if the following expression is true:
8340      * &lt;pre&gt;{@code
8341      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8342      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8343      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8344      * }&lt;/pre&gt;
8345      *
8346      * @param a the first array to be tested for a mismatch
8347      * @param aFromIndex the index (inclusive) of the first element in the
8348      *                   first array to be tested
8349      * @param aToIndex the index (exclusive) of the last element in the
8350      *                 first array to be tested
8351      * @param b the second array to be tested for a mismatch
8352      * @param bFromIndex the index (inclusive) of the first element in the
8353      *                   second array to be tested
8354      * @param bToIndex the index (exclusive) of the last element in the
8355      *                 second array to be tested
8356      * @return the relative index of the first mismatch between the two arrays
8357      *         over the specified ranges, otherwise {@code -1}.
8358      * @throws IllegalArgumentException
8359      *         if {@code aFromIndex &gt; aToIndex} or
8360      *         if {@code bFromIndex &gt; bToIndex}
8361      * @throws ArrayIndexOutOfBoundsException
8362      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8363      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8364      * @throws NullPointerException
8365      *         if either array is {@code null}
8366      * @since 9
8367      */
8368     public static int mismatch(long[] a, int aFromIndex, int aToIndex,
8369                                long[] b, int bFromIndex, int bToIndex) {
8370         rangeCheck(a.length, aFromIndex, aToIndex);
8371         rangeCheck(b.length, bFromIndex, bToIndex);
8372 
8373         int aLength = aToIndex - aFromIndex;
8374         int bLength = bToIndex - bFromIndex;
8375         int length = Math.min(aLength, bLength);
8376         int i = ArraysSupport.mismatch(a, aFromIndex,
8377                                        b, bFromIndex,
8378                                        length);
8379         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
8380     }
8381 
8382     // Mismatch float
8383 
8384     /**
8385      * Finds and returns the index of the first mismatch between two {@code float}
8386      * arrays, otherwise return -1 if no mismatch is found.  The index will be
8387      * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
8388      * array.
8389      *
8390      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8391      * length of the common prefix and it follows that there is a mismatch
8392      * between the two elements at that index within the respective arrays.
8393      * If one array is a proper prefix of the other then the returned index is
8394      * the length of the smaller array and it follows that the index is only
8395      * valid for the larger array.
8396      * Otherwise, there is no mismatch.
8397      *
8398      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8399      * prefix of length {@code pl} if the following expression is true:
8400      * &lt;pre&gt;{@code
8401      *     pl &gt;= 0 &amp;&amp;
8402      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8403      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
8404      *     Float.compare(a[pl], b[pl]) != 0
8405      * }&lt;/pre&gt;
8406      * Note that a common prefix length of {@code 0} indicates that the first
8407      * elements from each array mismatch.
8408      *
8409      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8410      * prefix if the following expression is true:
8411      * &lt;pre&gt;{@code
8412      *     a.length != b.length &amp;&amp;
8413      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8414      *                   b, 0, Math.min(a.length, b.length))
8415      * }&lt;/pre&gt;
8416      *
8417      * @param a the first array to be tested for a mismatch
8418      * @param b the second array to be tested for a mismatch
8419      * @return the index of the first mismatch between the two arrays,
8420      *         otherwise {@code -1}.
8421      * @throws NullPointerException
8422      *         if either array is {@code null}
8423      * @since 9
8424      */
8425     public static int mismatch(float[] a, float[] b) {
8426         int length = Math.min(a.length, b.length); // Check null array refs
8427         if (a == b)
8428             return -1;
8429 
8430         int i = ArraysSupport.mismatch(a, b, length);
8431         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
8432     }
8433 
8434     /**
8435      * Finds and returns the relative index of the first mismatch between two
8436      * {@code float} arrays over the specified ranges, otherwise return -1 if no
8437      * mismatch is found.  The index will be in the range of 0 (inclusive) up to
8438      * the length (inclusive) of the smaller range.
8439      *
8440      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8441      * then the returned relative index is the length of the common prefix and
8442      * it follows that there is a mismatch between the two elements at that
8443      * relative index within the respective arrays.
8444      * If one array is a proper prefix of the other, over the specified ranges,
8445      * then the returned relative index is the length of the smaller range and
8446      * it follows that the relative index is only valid for the array with the
8447      * larger range.
8448      * Otherwise, there is no mismatch.
8449      *
8450      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8451      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8452      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8453      * prefix of length {@code pl} if the following expression is true:
8454      * &lt;pre&gt;{@code
8455      *     pl &gt;= 0 &amp;&amp;
8456      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8457      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8458      *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8459      * }&lt;/pre&gt;
8460      * Note that a common prefix length of {@code 0} indicates that the first
8461      * elements from each array mismatch.
8462      *
8463      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8464      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8465      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8466      * if the following expression is true:
8467      * &lt;pre&gt;{@code
8468      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8469      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8470      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8471      * }&lt;/pre&gt;
8472      *
8473      * @param a the first array to be tested for a mismatch
8474      * @param aFromIndex the index (inclusive) of the first element in the
8475      *                   first array to be tested
8476      * @param aToIndex the index (exclusive) of the last element in the
8477      *                 first array to be tested
8478      * @param b the second array to be tested for a mismatch
8479      * @param bFromIndex the index (inclusive) of the first element in the
8480      *                   second array to be tested
8481      * @param bToIndex the index (exclusive) of the last element in the
8482      *                 second array to be tested
8483      * @return the relative index of the first mismatch between the two arrays
8484      *         over the specified ranges, otherwise {@code -1}.
8485      * @throws IllegalArgumentException
8486      *         if {@code aFromIndex &gt; aToIndex} or
8487      *         if {@code bFromIndex &gt; bToIndex}
8488      * @throws ArrayIndexOutOfBoundsException
8489      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8490      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8491      * @throws NullPointerException
8492      *         if either array is {@code null}
8493      * @since 9
8494      */
8495     public static int mismatch(float[] a, int aFromIndex, int aToIndex,
8496                                float[] b, int bFromIndex, int bToIndex) {
8497         rangeCheck(a.length, aFromIndex, aToIndex);
8498         rangeCheck(b.length, bFromIndex, bToIndex);
8499 
8500         int aLength = aToIndex - aFromIndex;
8501         int bLength = bToIndex - bFromIndex;
8502         int length = Math.min(aLength, bLength);
8503         int i = ArraysSupport.mismatch(a, aFromIndex,
8504                                        b, bFromIndex,
8505                                        length);
8506         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
8507     }
8508 
8509     // Mismatch double
8510 
8511     /**
8512      * Finds and returns the index of the first mismatch between two
8513      * {@code double} arrays, otherwise return -1 if no mismatch is found.  The
8514      * index will be in the range of 0 (inclusive) up to the length (inclusive)
8515      * of the smaller array.
8516      *
8517      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8518      * length of the common prefix and it follows that there is a mismatch
8519      * between the two elements at that index within the respective arrays.
8520      * If one array is a proper prefix of the other then the returned index is
8521      * the length of the smaller array and it follows that the index is only
8522      * valid for the larger array.
8523      * Otherwise, there is no mismatch.
8524      *
8525      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8526      * prefix of length {@code pl} if the following expression is true:
8527      * &lt;pre&gt;{@code
8528      *     pl &gt;= 0 &amp;&amp;
8529      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8530      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
8531      *     Double.compare(a[pl], b[pl]) != 0
8532      * }&lt;/pre&gt;
8533      * Note that a common prefix length of {@code 0} indicates that the first
8534      * elements from each array mismatch.
8535      *
8536      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8537      * prefix if the following expression is true:
8538      * &lt;pre&gt;{@code
8539      *     a.length != b.length &amp;&amp;
8540      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8541      *                   b, 0, Math.min(a.length, b.length))
8542      * }&lt;/pre&gt;
8543      *
8544      * @param a the first array to be tested for a mismatch
8545      * @param b the second array to be tested for a mismatch
8546      * @return the index of the first mismatch between the two arrays,
8547      *         otherwise {@code -1}.
8548      * @throws NullPointerException
8549      *         if either array is {@code null}
8550      * @since 9
8551      */
8552     public static int mismatch(double[] a, double[] b) {
8553         int length = Math.min(a.length, b.length); // Check null array refs
8554         if (a == b)
8555             return -1;
8556 
8557         int i = ArraysSupport.mismatch(a, b, length);
8558         return (i &lt; 0 &amp;&amp; a.length != b.length) ? length : i;
8559     }
8560 
8561     /**
8562      * Finds and returns the relative index of the first mismatch between two
8563      * {@code double} arrays over the specified ranges, otherwise return -1 if
8564      * no mismatch is found.  The index will be in the range of 0 (inclusive) up
8565      * to the length (inclusive) of the smaller range.
8566      *
8567      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8568      * then the returned relative index is the length of the common prefix and
8569      * it follows that there is a mismatch between the two elements at that
8570      * relative index within the respective arrays.
8571      * If one array is a proper prefix of the other, over the specified ranges,
8572      * then the returned relative index is the length of the smaller range and
8573      * it follows that the relative index is only valid for the array with the
8574      * larger range.
8575      * Otherwise, there is no mismatch.
8576      *
8577      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8578      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8579      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8580      * prefix of length {@code pl} if the following expression is true:
8581      * &lt;pre&gt;{@code
8582      *     pl &gt;= 0 &amp;&amp;
8583      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8584      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8585      *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8586      * }&lt;/pre&gt;
8587      * Note that a common prefix length of {@code 0} indicates that the first
8588      * elements from each array mismatch.
8589      *
8590      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8591      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8592      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8593      * if the following expression is true:
8594      * &lt;pre&gt;{@code
8595      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8596      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8597      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8598      * }&lt;/pre&gt;
8599      *
8600      * @param a the first array to be tested for a mismatch
8601      * @param aFromIndex the index (inclusive) of the first element in the
8602      *                   first array to be tested
8603      * @param aToIndex the index (exclusive) of the last element in the
8604      *                 first array to be tested
8605      * @param b the second array to be tested for a mismatch
8606      * @param bFromIndex the index (inclusive) of the first element in the
8607      *                   second array to be tested
8608      * @param bToIndex the index (exclusive) of the last element in the
8609      *                 second array to be tested
8610      * @return the relative index of the first mismatch between the two arrays
8611      *         over the specified ranges, otherwise {@code -1}.
8612      * @throws IllegalArgumentException
8613      *         if {@code aFromIndex &gt; aToIndex} or
8614      *         if {@code bFromIndex &gt; bToIndex}
8615      * @throws ArrayIndexOutOfBoundsException
8616      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8617      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8618      * @throws NullPointerException
8619      *         if either array is {@code null}
8620      * @since 9
8621      */
8622     public static int mismatch(double[] a, int aFromIndex, int aToIndex,
8623                                double[] b, int bFromIndex, int bToIndex) {
8624         rangeCheck(a.length, aFromIndex, aToIndex);
8625         rangeCheck(b.length, bFromIndex, bToIndex);
8626 
8627         int aLength = aToIndex - aFromIndex;
8628         int bLength = bToIndex - bFromIndex;
8629         int length = Math.min(aLength, bLength);
8630         int i = ArraysSupport.mismatch(a, aFromIndex,
8631                                        b, bFromIndex,
8632                                        length);
8633         return (i &lt; 0 &amp;&amp; aLength != bLength) ? length : i;
8634     }
8635 
8636     // Mismatch objects
8637 
8638     /**
8639      * Finds and returns the index of the first mismatch between two
8640      * {@code Object} arrays, otherwise return -1 if no mismatch is found.  The
8641      * index will be in the range of 0 (inclusive) up to the length (inclusive)
8642      * of the smaller array.
8643      *
8644      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8645      * length of the common prefix and it follows that there is a mismatch
8646      * between the two elements at that index within the respective arrays.
8647      * If one array is a proper prefix of the other then the returned index is
8648      * the length of the smaller array and it follows that the index is only
8649      * valid for the larger array.
8650      * Otherwise, there is no mismatch.
8651      *
8652      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8653      * prefix of length {@code pl} if the following expression is true:
8654      * &lt;pre&gt;{@code
8655      *     pl &gt;= 0 &amp;&amp;
8656      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8657      *     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
8658      *     !Objects.equals(a[pl], b[pl])
8659      * }&lt;/pre&gt;
8660      * Note that a common prefix length of {@code 0} indicates that the first
8661      * elements from each array mismatch.
8662      *
8663      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8664      * prefix if the following expression is true:
8665      * &lt;pre&gt;{@code
8666      *     a.length != b.length &amp;&amp;
8667      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8668      *                   b, 0, Math.min(a.length, b.length))
8669      * }&lt;/pre&gt;
8670      *
8671      * @param a the first array to be tested for a mismatch
8672      * @param b the second array to be tested for a mismatch
8673      * @return the index of the first mismatch between the two arrays,
8674      *         otherwise {@code -1}.
8675      * @throws NullPointerException
8676      *         if either array is {@code null}
8677      * @since 9
8678      */
8679     public static int mismatch(Object[] a, Object[] b) {
8680         int length = Math.min(a.length, b.length); // Check null array refs
8681         if (a == b)
8682             return -1;
8683 
8684         for (int i = 0; i &lt; length; i++) {
8685             if (!Objects.equals(a[i], b[i]))
8686                 return i;
8687         }
8688 
8689         return a.length != b.length ? length : -1;
8690     }
8691 
8692     /**
8693      * Finds and returns the relative index of the first mismatch between two
8694      * {@code Object} arrays over the specified ranges, otherwise return -1 if
8695      * no mismatch is found.  The index will be in the range of 0 (inclusive) up
8696      * to the length (inclusive) of the smaller range.
8697      *
8698      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8699      * then the returned relative index is the length of the common prefix and
8700      * it follows that there is a mismatch between the two elements at that
8701      * relative index within the respective arrays.
8702      * If one array is a proper prefix of the other, over the specified ranges,
8703      * then the returned relative index is the length of the smaller range and
8704      * it follows that the relative index is only valid for the array with the
8705      * larger range.
8706      * Otherwise, there is no mismatch.
8707      *
8708      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8709      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8710      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8711      * prefix of length {@code pl} if the following expression is true:
8712      * &lt;pre&gt;{@code
8713      *     pl &gt;= 0 &amp;&amp;
8714      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8715      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8716      *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])
8717      * }&lt;/pre&gt;
8718      * Note that a common prefix length of {@code 0} indicates that the first
8719      * elements from each array mismatch.
8720      *
8721      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8722      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8723      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8724      * if the following expression is true:
8725      * &lt;pre&gt;{@code
8726      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8727      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8728      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8729      * }&lt;/pre&gt;
8730      *
8731      * @param a the first array to be tested for a mismatch
8732      * @param aFromIndex the index (inclusive) of the first element in the
8733      *                   first array to be tested
8734      * @param aToIndex the index (exclusive) of the last element in the
8735      *                 first array to be tested
8736      * @param b the second array to be tested for a mismatch
8737      * @param bFromIndex the index (inclusive) of the first element in the
8738      *                   second array to be tested
8739      * @param bToIndex the index (exclusive) of the last element in the
8740      *                 second array to be tested
8741      * @return the relative index of the first mismatch between the two arrays
8742      *         over the specified ranges, otherwise {@code -1}.
8743      * @throws IllegalArgumentException
8744      *         if {@code aFromIndex &gt; aToIndex} or
8745      *         if {@code bFromIndex &gt; bToIndex}
8746      * @throws ArrayIndexOutOfBoundsException
8747      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8748      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8749      * @throws NullPointerException
8750      *         if either array is {@code null}
8751      * @since 9
8752      */
8753     public static int mismatch(
8754             Object[] a, int aFromIndex, int aToIndex,
8755             Object[] b, int bFromIndex, int bToIndex) {
8756         rangeCheck(a.length, aFromIndex, aToIndex);
8757         rangeCheck(b.length, bFromIndex, bToIndex);
8758 
8759         int aLength = aToIndex - aFromIndex;
8760         int bLength = bToIndex - bFromIndex;
8761         int length = Math.min(aLength, bLength);
8762         for (int i = 0; i &lt; length; i++) {
8763             if (!Objects.equals(a[aFromIndex++], b[bFromIndex++]))
8764                 return i;
8765         }
8766 
8767         return aLength != bLength ? length : -1;
8768     }
8769 
8770     /**
8771      * Finds and returns the index of the first mismatch between two
8772      * {@code Object} arrays, otherwise return -1 if no mismatch is found.
8773      * The index will be in the range of 0 (inclusive) up to the length
8774      * (inclusive) of the smaller array.
8775      *
8776      * &lt;p&gt;The specified comparator is used to determine if two array elements
8777      * from the each array are not equal.
8778      *
8779      * &lt;p&gt;If the two arrays share a common prefix then the returned index is the
8780      * length of the common prefix and it follows that there is a mismatch
8781      * between the two elements at that index within the respective arrays.
8782      * If one array is a proper prefix of the other then the returned index is
8783      * the length of the smaller array and it follows that the index is only
8784      * valid for the larger array.
8785      * Otherwise, there is no mismatch.
8786      *
8787      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a common
8788      * prefix of length {@code pl} if the following expression is true:
8789      * &lt;pre&gt;{@code
8790      *     pl &gt;= 0 &amp;&amp;
8791      *     pl &lt; Math.min(a.length, b.length) &amp;&amp;
8792      *     Arrays.equals(a, 0, pl, b, 0, pl, cmp)
8793      *     cmp.compare(a[pl], b[pl]) != 0
8794      * }&lt;/pre&gt;
8795      * Note that a common prefix length of {@code 0} indicates that the first
8796      * elements from each array mismatch.
8797      *
8798      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
8799      * prefix if the following expression is true:
8800      * &lt;pre&gt;{@code
8801      *     a.length != b.length &amp;&amp;
8802      *     Arrays.equals(a, 0, Math.min(a.length, b.length),
8803      *                   b, 0, Math.min(a.length, b.length),
8804      *                   cmp)
8805      * }&lt;/pre&gt;
8806      *
8807      * @param a the first array to be tested for a mismatch
8808      * @param b the second array to be tested for a mismatch
8809      * @param cmp the comparator to compare array elements
8810      * @param &lt;T&gt; the type of array elements
8811      * @return the index of the first mismatch between the two arrays,
8812      *         otherwise {@code -1}.
8813      * @throws NullPointerException
8814      *         if either array or the comparator is {@code null}
8815      * @since 9
8816      */
8817     public static &lt;T&gt; int mismatch(T[] a, T[] b, Comparator&lt;? super T&gt; cmp) {
8818         Objects.requireNonNull(cmp);
8819         int length = Math.min(a.length, b.length); // Check null array refs
8820         if (a == b)
8821             return -1;
8822 
8823         for (int i = 0; i &lt; length; i++) {
8824             T oa = a[i];
8825             T ob = b[i];
8826             if (oa != ob) {
8827                 // Null-value comparison is deferred to the comparator
8828                 int v = cmp.compare(oa, ob);
8829                 if (v != 0) {
8830                     return i;
8831                 }
8832             }
8833         }
8834 
8835         return a.length != b.length ? length : -1;
8836     }
8837 
8838     /**
8839      * Finds and returns the relative index of the first mismatch between two
8840      * {@code Object} arrays over the specified ranges, otherwise return -1 if
8841      * no mismatch is found.  The index will be in the range of 0 (inclusive) up
8842      * to the length (inclusive) of the smaller range.
8843      *
8844      * &lt;p&gt;If the two arrays, over the specified ranges, share a common prefix
8845      * then the returned relative index is the length of the common prefix and
8846      * it follows that there is a mismatch between the two elements at that
8847      * relative index within the respective arrays.
8848      * If one array is a proper prefix of the other, over the specified ranges,
8849      * then the returned relative index is the length of the smaller range and
8850      * it follows that the relative index is only valid for the array with the
8851      * larger range.
8852      * Otherwise, there is no mismatch.
8853      *
8854      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8855      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8856      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8857      * prefix of length {@code pl} if the following expression is true:
8858      * &lt;pre&gt;{@code
8859      *     pl &gt;= 0 &amp;&amp;
8860      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8861      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &amp;&amp;
8862      *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8863      * }&lt;/pre&gt;
8864      * Note that a common prefix length of {@code 0} indicates that the first
8865      * elements from each array mismatch.
8866      *
8867      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8868      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8869      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
8870      * if the following expression is true:
8871      * &lt;pre&gt;{@code
8872      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8873      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8874      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8875      *                   cmp)
8876      * }&lt;/pre&gt;
8877      *
8878      * @param a the first array to be tested for a mismatch
8879      * @param aFromIndex the index (inclusive) of the first element in the
8880      *                   first array to be tested
8881      * @param aToIndex the index (exclusive) of the last element in the
8882      *                 first array to be tested
8883      * @param b the second array to be tested for a mismatch
8884      * @param bFromIndex the index (inclusive) of the first element in the
8885      *                   second array to be tested
8886      * @param bToIndex the index (exclusive) of the last element in the
8887      *                 second array to be tested
8888      * @param cmp the comparator to compare array elements
8889      * @param &lt;T&gt; the type of array elements
8890      * @return the relative index of the first mismatch between the two arrays
8891      *         over the specified ranges, otherwise {@code -1}.
8892      * @throws IllegalArgumentException
8893      *         if {@code aFromIndex &gt; aToIndex} or
8894      *         if {@code bFromIndex &gt; bToIndex}
8895      * @throws ArrayIndexOutOfBoundsException
8896      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
8897      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
8898      * @throws NullPointerException
8899      *         if either array or the comparator is {@code null}
8900      * @since 9
8901      */
8902     public static &lt;T&gt; int mismatch(
8903             T[] a, int aFromIndex, int aToIndex,
8904             T[] b, int bFromIndex, int bToIndex,
8905             Comparator&lt;? super T&gt; cmp) {
8906         Objects.requireNonNull(cmp);
8907         rangeCheck(a.length, aFromIndex, aToIndex);
8908         rangeCheck(b.length, bFromIndex, bToIndex);
8909 
8910         int aLength = aToIndex - aFromIndex;
8911         int bLength = bToIndex - bFromIndex;
8912         int length = Math.min(aLength, bLength);
8913         for (int i = 0; i &lt; length; i++) {
8914             T oa = a[aFromIndex++];
8915             T ob = b[bFromIndex++];
8916             if (oa != ob) {
8917                 // Null-value comparison is deferred to the comparator
8918                 int v = cmp.compare(oa, ob);
8919                 if (v != 0) {
8920                     return i;
8921                 }
8922             }
8923         }
8924 
8925         return aLength != bLength ? length : -1;
8926     }
8927 }
    </pre>
  </body>
</html>
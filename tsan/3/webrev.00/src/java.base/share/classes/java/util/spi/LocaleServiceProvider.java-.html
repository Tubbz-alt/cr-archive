<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/spi/LocaleServiceProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.spi;
 27 
 28 import java.util.Locale;
 29 
 30 /**
 31  * &lt;p&gt;
 32  * This is the super class of all the locale sensitive service provider
 33  * interfaces (SPIs).
 34  * &lt;p&gt;
 35  * Locale sensitive  service provider interfaces are interfaces that
 36  * correspond to locale sensitive classes in the &lt;code&gt;java.text&lt;/code&gt;
 37  * and &lt;code&gt;java.util&lt;/code&gt; packages. The interfaces enable the
 38  * construction of locale sensitive objects and the retrieval of
 39  * localized names for these packages. Locale sensitive factory methods
 40  * and methods for name retrieval in the &lt;code&gt;java.text&lt;/code&gt; and
 41  * &lt;code&gt;java.util&lt;/code&gt; packages use implementations of the provider
 42  * interfaces to offer support for locales beyond the set of locales
 43  * supported by the Java runtime environment itself.
 44  *
 45  * &lt;h3&gt;Packaging of Locale Sensitive Service Provider Implementations&lt;/h3&gt;
 46  * Implementations of these locale sensitive services can be made available
 47  * by adding them to the application&#39;s class path. A provider identifies itself with a
 48  * provider-configuration file in the resource directory META-INF/services,
 49  * using the fully qualified provider interface class name as the file name.
 50  * The file should contain a list of fully-qualified concrete provider class names,
 51  * one per line. A line is terminated by any one of a line feed (&#39;\n&#39;), a carriage
 52  * return (&#39;\r&#39;), or a carriage return followed immediately by a line feed. Space
 53  * and tab characters surrounding each name, as well as blank lines, are ignored.
 54  * The comment character is &#39;#&#39; (&#39;\u0023&#39;); on each line all characters following
 55  * the first comment character are ignored. The file must be encoded in UTF-8.
 56  * &lt;p&gt;
 57  * If a particular concrete provider class is named in more than one configuration
 58  * file, or is named in the same configuration file more than once, then the
 59  * duplicates will be ignored. The configuration file naming a particular provider
 60  * need not be in the same jar file or other distribution unit as the provider itself.
 61  * The provider must be accessible from the same class loader that was initially
 62  * queried to locate the configuration file; this is not necessarily the class loader
 63  * that loaded the file.
 64  * &lt;p&gt;
 65  * For example, an implementation of the
 66  * {@link java.text.spi.DateFormatProvider DateFormatProvider} class should
 67  * take the form of a jar file which contains the file:
 68  * &lt;pre&gt;
 69  * META-INF/services/java.text.spi.DateFormatProvider
 70  * &lt;/pre&gt;
 71  * And the file &lt;code&gt;java.text.spi.DateFormatProvider&lt;/code&gt; should have
 72  * a line such as:
 73  * &lt;pre&gt;
 74  * &lt;code&gt;com.foo.DateFormatProviderImpl&lt;/code&gt;
 75  * &lt;/pre&gt;
 76  * which is the fully qualified class name of the class implementing
 77  * &lt;code&gt;DateFormatProvider&lt;/code&gt;.
 78  * &lt;h4&gt;Invocation of Locale Sensitive Services&lt;/h4&gt;
 79  * &lt;p&gt;
 80  * Locale sensitive factory methods and methods for name retrieval in the
 81  * &lt;code&gt;java.text&lt;/code&gt; and &lt;code&gt;java.util&lt;/code&gt; packages invoke
 82  * service provider methods when needed to support the requested locale.
 83  * The methods first check whether the Java runtime environment itself
 84  * supports the requested locale, and use its support if available.
 85  * Otherwise, they call the {@link #isSupportedLocale(Locale) isSupportedLocale}
 86  * methods of installed providers for the appropriate interface to find one that
 87  * supports the requested locale. If such a provider is found, its other
 88  * methods are called to obtain the requested object or name.  When checking
 89  * whether a locale is supported, the &lt;a href=&quot;../Locale.html#def_extensions&quot;&gt;
 90  * locale&#39;s extensions&lt;/a&gt; are ignored by default. (If locale&#39;s extensions should
 91  * also be checked, the {@code isSupportedLocale} method must be overridden.)
 92  * If neither the Java runtime environment itself nor an installed provider
 93  * supports the requested locale, the methods go through a list of candidate
 94  * locales and repeat the availability check for each until a match is found.
 95  * The algorithm used for creating a list of candidate locales is same as
 96  * the one used by &lt;code&gt;ResourceBundle&lt;/code&gt; by default (see
 97  * {@link java.util.ResourceBundle.Control#getCandidateLocales getCandidateLocales}
 98  * for the details).  Even if a locale is resolved from the candidate list,
 99  * methods that return requested objects or names are invoked with the original
100  * requested locale including {@code Locale} extensions. The Java runtime
101  * environment must support the root locale for all locale sensitive services in
102  * order to guarantee that this process terminates.
103  * &lt;p&gt;
104  * Providers of names (but not providers of other objects) are allowed to
105  * return null for some name requests even for locales that they claim to
106  * support by including them in their return value for
107  * &lt;code&gt;getAvailableLocales&lt;/code&gt;. Similarly, the Java runtime
108  * environment itself may not have all names for all locales that it
109  * supports. This is because the sets of objects for which names are
110  * requested can be large and vary over time, so that it&#39;s not always
111  * feasible to cover them completely. If the Java runtime environment or a
112  * provider returns null instead of a name, the lookup will proceed as
113  * described above as if the locale was not supported.
114  * &lt;p&gt;
115  * The search order of locale sensitive services can
116  * be configured by using the {@systemProperty java.locale.providers} system property.
117  * This system property declares the user&#39;s preferred order for looking up
118  * the locale sensitive services separated by a comma. It is only read at
119  * the Java runtime startup, so the later call to System.setProperty() won&#39;t
120  * affect the order.
121  * &lt;p&gt;
122  * Java Runtime Environment provides the following four locale providers:
123  * &lt;ul&gt;
124  * &lt;li&gt; &quot;CLDR&quot;: A provider based on Unicode Consortium&#39;s
125  * &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;CLDR Project&lt;/a&gt;.
126  * &lt;li&gt; &quot;COMPAT&quot;: represents the locale sensitive services that is compatible
127  * with the prior JDK releases up to JDK8 (same as JDK8&#39;s &quot;JRE&quot;).
128  * &lt;li&gt; &quot;SPI&quot;: represents the locale sensitive services implementing the subclasses of
129  * this {@code LocaleServiceProvider} class.
130  * &lt;li&gt; &quot;HOST&quot;: A provider that reflects the user&#39;s custom settings in the
131  * underlying operating system. This provider may not be available, depending
132  * on the Java Runtime Environment implementation.
133  * &lt;li&gt; &quot;JRE&quot;: represents a synonym to &quot;COMPAT&quot;. This name
134  * is deprecated and will be removed in the future release of JDK.
135  * &lt;/ul&gt;
136  * &lt;p&gt;
137  * For example, if the following is specified in the property:
138  * &lt;pre&gt;
139  * java.locale.providers=SPI,CLDR,COMPAT
140  * &lt;/pre&gt;
141  * the locale sensitive services in the SPI providers are looked up first. If the
142  * desired locale sensitive service is not available, then the runtime looks for CLDR,
143  * COMPAT in that order.
144  * &lt;p&gt;
145  * The default order for looking up the preferred locale providers is &quot;CLDR,COMPAT&quot;,
146  * so specifying &quot;CLDR,COMPAT&quot; is identical to the default behavior. Applications which
147  * require implementations of the locale sensitive services must explicitly specify
148  * &quot;SPI&quot; in order for the Java runtime to load them from the classpath.
149  *
150  * @since        1.6
151  */
152 public abstract class LocaleServiceProvider {
153 
154     private static Void checkPermission() {
155         SecurityManager sm = System.getSecurityManager();
156         if (sm != null) {
157             sm.checkPermission(new RuntimePermission(&quot;localeServiceProvider&quot;));
158         }
159         return null;
160     }
161     private LocaleServiceProvider(Void ignore) { }
162 
163     /**
164      * Initializes a new locale service provider.
165      *
166      * @throws  SecurityException
167      *          If a security manager has been installed and it denies
168      *          {@link RuntimePermission RuntimePermission(&quot;localeServiceProvider&quot;)}
169      */
170     protected LocaleServiceProvider() {
171         this(checkPermission());
172     }
173 
174     /**
175      * Returns an array of all locales for which this locale service provider
176      * can provide localized objects or names. This information is used to
177      * compose {@code getAvailableLocales()} values of the locale-dependent
178      * services, such as {@code DateFormat.getAvailableLocales()}.
179      *
180      * &lt;p&gt;The array returned by this method should not include two or more
181      * {@code Locale} objects only differing in their extensions.
182      *
183      * @return An array of all locales for which this locale service provider
184      * can provide localized objects or names.
185      */
186     public abstract Locale[] getAvailableLocales();
187 
188     /**
189      * Returns {@code true} if the given {@code locale} is supported by
190      * this locale service provider. The given {@code locale} may contain
191      * &lt;a href=&quot;../Locale.html#def_extensions&quot;&gt;extensions&lt;/a&gt; that should be
192      * taken into account for the support determination.
193      *
194      * &lt;p&gt;The default implementation returns {@code true} if the given {@code locale}
195      * is equal to any of the available {@code Locale}s returned by
196      * {@link #getAvailableLocales()} with ignoring any extensions in both the
197      * given {@code locale} and the available locales. Concrete locale service
198      * provider implementations should override this method if those
199      * implementations are {@code Locale} extensions-aware. For example,
200      * {@code DecimalFormatSymbolsProvider} implementations will need to check
201      * extensions in the given {@code locale} to see if any numbering system is
202      * specified and can be supported. However, {@code CollatorProvider}
203      * implementations may not be affected by any particular numbering systems,
204      * and in that case, extensions for numbering systems should be ignored.
205      *
206      * @param locale a {@code Locale} to be tested
207      * @return {@code true} if the given {@code locale} is supported by this
208      *         provider; {@code false} otherwise.
209      * @throws NullPointerException
210      *         if the given {@code locale} is {@code null}
211      * @see Locale#hasExtensions()
212      * @see Locale#stripExtensions()
213      * @since 1.8
214      */
215     public boolean isSupportedLocale(Locale locale) {
216         locale = locale.stripExtensions(); // throws NPE if locale == null
217         for (Locale available : getAvailableLocales()) {
218             if (locale.equals(available.stripExtensions())) {
219                 return true;
220 }
221         }
222         return false;
223     }
224 }
    </pre>
  </body>
</html>
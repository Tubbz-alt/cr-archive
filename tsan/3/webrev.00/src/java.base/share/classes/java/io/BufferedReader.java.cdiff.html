<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/BufferedReader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="BufferedOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BufferedWriter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/BufferedReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
       * the specified size.
       *
       * @param  in   A Reader
       * @param  sz   Input-buffer size
       *
<span class="line-modified">!      * @exception  IllegalArgumentException  If {@code sz &lt;= 0}</span>
       */
      public BufferedReader(Reader in, int sz) {
          super(in);
          if (sz &lt;= 0)
              throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
<span class="line-new-header">--- 93,11 ---</span>
       * the specified size.
       *
       * @param  in   A Reader
       * @param  sz   Input-buffer size
       *
<span class="line-modified">!      * @throws IllegalArgumentException  If {@code sz &lt;= 0}</span>
       */
      public BufferedReader(Reader in, int sz) {
          super(in);
          if (sz &lt;= 0)
              throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,11 ***</span>
       * Reads a single character.
       *
       * @return The character read, as an integer in the range
       *         0 to 65535 ({@code 0x00-0xffff}), or -1 if the
       *         end of the stream has been reached
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       */
      public int read() throws IOException {
          synchronized (lock) {
              ensureOpen();
              for (;;) {
<span class="line-new-header">--- 170,11 ---</span>
       * Reads a single character.
       *
       * @return The character read, as an integer in the range
       *         0 to 65535 ({@code 0x00-0xffff}), or -1 if the
       *         end of the stream has been reached
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       */
      public int read() throws IOException {
          synchronized (lock) {
              ensureOpen();
              for (;;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,48 ***</span>
       *
       * &lt;p&gt; This method implements the general contract of the corresponding
       * &lt;code&gt;{@link Reader#read(char[], int, int) read}&lt;/code&gt; method of the
       * &lt;code&gt;{@link Reader}&lt;/code&gt; class.  As an additional convenience, it
       * attempts to read as many characters as possible by repeatedly invoking
<span class="line-modified">!      * the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This iterated</span>
<span class="line-modified">!      * &lt;code&gt;read&lt;/code&gt; continues until one of the following conditions becomes</span>
       * true: &lt;ul&gt;
       *
       *   &lt;li&gt; The specified number of characters have been read,
       *
<span class="line-modified">!      *   &lt;li&gt; The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns</span>
<span class="line-modified">!      *   &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or</span>
       *
<span class="line-modified">!      *   &lt;li&gt; The &lt;code&gt;ready&lt;/code&gt; method of the underlying stream</span>
<span class="line-modified">!      *   returns &lt;code&gt;false&lt;/code&gt;, indicating that further input requests</span>
       *   would block.
       *
<span class="line-modified">!      * &lt;/ul&gt; If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns</span>
<span class="line-modified">!      * &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns</span>
<span class="line-modified">!      * &lt;code&gt;-1&lt;/code&gt;.  Otherwise this method returns the number of characters</span>
       * actually read.
       *
       * &lt;p&gt; Subclasses of this class are encouraged, but not required, to
       * attempt to read as many characters as possible in the same fashion.
       *
       * &lt;p&gt; Ordinarily this method takes characters from this stream&#39;s character
       * buffer, filling it from the underlying stream as necessary.  If,
       * however, the buffer is empty, the mark is not valid, and the requested
       * length is at least as large as the buffer, then this method will read
       * characters directly from the underlying stream into the given array.
<span class="line-modified">!      * Thus redundant &lt;code&gt;BufferedReader&lt;/code&gt;s will not copy data</span>
       * unnecessarily.
       *
       * @param      cbuf  Destination buffer
       * @param      off   Offset at which to start storing characters
       * @param      len   Maximum number of characters to read
       *
       * @return     The number of characters read, or -1 if the end of the
       *             stream has been reached
       *
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException {@inheritDoc}</span>
       */
      public int read(char cbuf[], int off, int len) throws IOException {
          synchronized (lock) {
              ensureOpen();
              if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||
<span class="line-new-header">--- 233,48 ---</span>
       *
       * &lt;p&gt; This method implements the general contract of the corresponding
       * &lt;code&gt;{@link Reader#read(char[], int, int) read}&lt;/code&gt; method of the
       * &lt;code&gt;{@link Reader}&lt;/code&gt; class.  As an additional convenience, it
       * attempts to read as many characters as possible by repeatedly invoking
<span class="line-modified">!      * the {@code read} method of the underlying stream.  This iterated</span>
<span class="line-modified">!      * {@code read} continues until one of the following conditions becomes</span>
       * true: &lt;ul&gt;
       *
       *   &lt;li&gt; The specified number of characters have been read,
       *
<span class="line-modified">!      *   &lt;li&gt; The {@code read} method of the underlying stream returns</span>
<span class="line-modified">!      *   {@code -1}, indicating end-of-file, or</span>
       *
<span class="line-modified">!      *   &lt;li&gt; The {@code ready} method of the underlying stream</span>
<span class="line-modified">!      *   returns {@code false}, indicating that further input requests</span>
       *   would block.
       *
<span class="line-modified">!      * &lt;/ul&gt; If the first {@code read} on the underlying stream returns</span>
<span class="line-modified">!      * {@code -1} to indicate end-of-file then this method returns</span>
<span class="line-modified">!      * {@code -1}.  Otherwise this method returns the number of characters</span>
       * actually read.
       *
       * &lt;p&gt; Subclasses of this class are encouraged, but not required, to
       * attempt to read as many characters as possible in the same fashion.
       *
       * &lt;p&gt; Ordinarily this method takes characters from this stream&#39;s character
       * buffer, filling it from the underlying stream as necessary.  If,
       * however, the buffer is empty, the mark is not valid, and the requested
       * length is at least as large as the buffer, then this method will read
       * characters directly from the underlying stream into the given array.
<span class="line-modified">!      * Thus redundant {@code BufferedReader}s will not copy data</span>
       * unnecessarily.
       *
       * @param      cbuf  Destination buffer
       * @param      off   Offset at which to start storing characters
       * @param      len   Maximum number of characters to read
       *
       * @return     The number of characters read, or -1 if the end of the
       *             stream has been reached
       *
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException {@inheritDoc}</span>
       */
      public int read(char cbuf[], int off, int len) throws IOException {
          synchronized (lock) {
              ensureOpen();
              if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,14 ***</span>
       *             any line-termination characters, or null if the end of the
       *             stream has been reached without reading any characters
       *
       * @see        java.io.LineNumberReader#readLine()
       *
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       */
      String readLine(boolean ignoreLF) throws IOException {
<span class="line-modified">!         StringBuffer s = null;</span>
          int startChar;
  
          synchronized (lock) {
              ensureOpen();
              boolean omitLF = ignoreLF || skipLF;
<span class="line-new-header">--- 307,14 ---</span>
       *             any line-termination characters, or null if the end of the
       *             stream has been reached without reading any characters
       *
       * @see        java.io.LineNumberReader#readLine()
       *
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       */
      String readLine(boolean ignoreLF) throws IOException {
<span class="line-modified">!         StringBuilder s = null;</span>
          int startChar;
  
          synchronized (lock) {
              ensureOpen();
              boolean omitLF = ignoreLF || skipLF;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,11 ***</span>
                      }
                      return str;
                  }
  
                  if (s == null)
<span class="line-modified">!                     s = new StringBuffer(defaultExpectedLineLength);</span>
                  s.append(cb, startChar, i - startChar);
              }
          }
      }
  
<span class="line-new-header">--- 366,11 ---</span>
                      }
                      return str;
                  }
  
                  if (s == null)
<span class="line-modified">!                     s = new StringBuilder(defaultExpectedLineLength);</span>
                  s.append(cb, startChar, i - startChar);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,11 ***</span>
       *
       * @return     A String containing the contents of the line, not including
       *             any line-termination characters, or null if the end of the
       *             stream has been reached without reading any characters
       *
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       *
       * @see java.nio.file.Files#readAllLines
       */
      public String readLine() throws IOException {
          return readLine(false);
<span class="line-new-header">--- 382,11 ---</span>
       *
       * @return     A String containing the contents of the line, not including
       *             any line-termination characters, or null if the end of the
       *             stream has been reached without reading any characters
       *
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       *
       * @see java.nio.file.Files#readAllLines
       */
      public String readLine() throws IOException {
          return readLine(false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,12 ***</span>
       *
       * @param  n  The number of characters to skip
       *
       * @return    The number of characters actually skipped
       *
<span class="line-modified">!      * @exception  IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</span>
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       */
      public long skip(long n) throws IOException {
          if (n &lt; 0L) {
              throw new IllegalArgumentException(&quot;skip value is negative&quot;);
          }
<span class="line-new-header">--- 397,12 ---</span>
       *
       * @param  n  The number of characters to skip
       *
       * @return    The number of characters actually skipped
       *
<span class="line-modified">!      * @throws     IllegalArgumentException  If {@code n} is negative.</span>
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       */
      public long skip(long n) throws IOException {
          if (n &lt; 0L) {
              throw new IllegalArgumentException(&quot;skip value is negative&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,11 ***</span>
      /**
       * Tells whether this stream is ready to be read.  A buffered character
       * stream is ready if the buffer is not empty, or if the underlying
       * character stream is ready.
       *
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       */
      public boolean ready() throws IOException {
          synchronized (lock) {
              ensureOpen();
  
<span class="line-new-header">--- 438,11 ---</span>
      /**
       * Tells whether this stream is ready to be read.  A buffered character
       * stream is ready if the buffer is not empty, or if the underlying
       * character stream is ready.
       *
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       */
      public boolean ready() throws IOException {
          synchronized (lock) {
              ensureOpen();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,12 ***</span>
       *                         A limit value larger than the size of the input
       *                         buffer will cause a new buffer to be allocated
       *                         whose size is no smaller than limit.
       *                         Therefore large values should be used with care.
       *
<span class="line-modified">!      * @exception  IllegalArgumentException  If {@code readAheadLimit &lt; 0}</span>
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       */
      public void mark(int readAheadLimit) throws IOException {
          if (readAheadLimit &lt; 0) {
              throw new IllegalArgumentException(&quot;Read-ahead limit &lt; 0&quot;);
          }
<span class="line-new-header">--- 485,12 ---</span>
       *                         A limit value larger than the size of the input
       *                         buffer will cause a new buffer to be allocated
       *                         whose size is no smaller than limit.
       *                         Therefore large values should be used with care.
       *
<span class="line-modified">!      * @throws     IllegalArgumentException  If {@code readAheadLimit &lt; 0}</span>
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       */
      public void mark(int readAheadLimit) throws IOException {
          if (readAheadLimit &lt; 0) {
              throw new IllegalArgumentException(&quot;Read-ahead limit &lt; 0&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,11 ***</span>
      }
  
      /**
       * Resets the stream to the most recent mark.
       *
<span class="line-modified">!      * @exception  IOException  If the stream has never been marked,</span>
       *                          or if the mark has been invalidated
       */
      public void reset() throws IOException {
          synchronized (lock) {
              ensureOpen();
<span class="line-new-header">--- 503,11 ---</span>
      }
  
      /**
       * Resets the stream to the most recent mark.
       *
<span class="line-modified">!      * @throws     IOException  If the stream has never been marked,</span>
       *                          or if the mark has been invalidated
       */
      public void reset() throws IOException {
          synchronized (lock) {
              ensureOpen();
</pre>
<center><a href="BufferedOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BufferedWriter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
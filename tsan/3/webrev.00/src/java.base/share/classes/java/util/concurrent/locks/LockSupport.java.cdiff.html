<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Lock.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantLock.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 138,12 ***</span>
   */
  public class LockSupport {
      private LockSupport() {} // Cannot be instantiated.
  
      private static void setBlocker(Thread t, Object arg) {
<span class="line-modified">!         // Even though volatile, hotspot doesn&#39;t need a write barrier here.</span>
<span class="line-modified">!         U.putReference(t, PARKBLOCKER, arg);</span>
      }
  
      /**
       * Makes available the permit for the given thread, if it
       * was not already available.  If the thread was blocked on
<span class="line-new-header">--- 138,29 ---</span>
   */
  public class LockSupport {
      private LockSupport() {} // Cannot be instantiated.
  
      private static void setBlocker(Thread t, Object arg) {
<span class="line-modified">!         U.putReferenceOpaque(t, PARKBLOCKER, arg);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Sets the object to be returned by invocations of {@link</span>
<span class="line-added">+      * #getBlocker getBlocker} for the current thread. This method may</span>
<span class="line-added">+      * be used before invoking the no-argument version of {@link</span>
<span class="line-added">+      * LockSupport#park() park()} from non-public objects, allowing</span>
<span class="line-added">+      * more helpful diagnostics, or retaining compatibility with</span>
<span class="line-added">+      * previous implementations of blocking methods.  Previous values</span>
<span class="line-added">+      * of the blocker are not automatically restored after blocking.</span>
<span class="line-added">+      * To obtain the effects of {@code park(b}}, use {@code</span>
<span class="line-added">+      * setCurrentBlocker(b); park(); setCurrentBlocker(null);}</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param blocker the blocker object</span>
<span class="line-added">+      * @since 14</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static void setCurrentBlocker(Object blocker) {</span>
<span class="line-added">+         U.putReferenceOpaque(Thread.currentThread(), PARKBLOCKER, blocker);</span>
      }
  
      /**
       * Makes available the permit for the given thread, if it
       * was not already available.  If the thread was blocked on
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,11 ***</span>
       * @since 1.6
       */
      public static Object getBlocker(Thread t) {
          if (t == null)
              throw new NullPointerException();
<span class="line-modified">!         return U.getReferenceVolatile(t, PARKBLOCKER);</span>
      }
  
      /**
       * Disables the current thread for thread scheduling purposes unless the
       * permit is available.
<span class="line-new-header">--- 307,11 ---</span>
       * @since 1.6
       */
      public static Object getBlocker(Thread t) {
          if (t == null)
              throw new NullPointerException();
<span class="line-modified">!         return U.getReferenceOpaque(t, PARKBLOCKER);</span>
      }
  
      /**
       * Disables the current thread for thread scheduling purposes unless the
       * permit is available.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,28 ***</span>
       */
      public static void parkUntil(long deadline) {
          U.park(true, deadline);
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Returns the pseudo-randomly initialized or updated secondary seed.</span>
<span class="line-removed">-      * Copied from ThreadLocalRandom due to package access restrictions.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     static final int nextSecondarySeed() {</span>
<span class="line-removed">-         int r;</span>
<span class="line-removed">-         Thread t = Thread.currentThread();</span>
<span class="line-removed">-         if ((r = U.getInt(t, SECONDARY)) != 0) {</span>
<span class="line-removed">-             r ^= r &lt;&lt; 13;   // xorshift</span>
<span class="line-removed">-             r ^= r &gt;&gt;&gt; 17;</span>
<span class="line-removed">-             r ^= r &lt;&lt; 5;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else if ((r = java.util.concurrent.ThreadLocalRandom.current().nextInt()) == 0)</span>
<span class="line-removed">-             r = 1; // avoid zero</span>
<span class="line-removed">-         U.putInt(t, SECONDARY, r);</span>
<span class="line-removed">-         return r;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Returns the thread id for the given thread.  We must access
       * this directly rather than via method Thread.getId() because
       * getId() has been known to be overridden in ways that do not
       * preserve unique mappings.
<span class="line-new-header">--- 408,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,13 ***</span>
          return U.getLong(thread, TID);
      }
  
      // Hotspot implementation via intrinsics API
      private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">!     private static final long PARKBLOCKER = U.objectFieldOffset</span>
<span class="line-modified">!             (Thread.class, &quot;parkBlocker&quot;);</span>
<span class="line-modified">!     private static final long SECONDARY = U.objectFieldOffset</span>
<span class="line-modified">!             (Thread.class, &quot;threadLocalRandomSecondarySeed&quot;);</span>
<span class="line-removed">-     private static final long TID = U.objectFieldOffset</span>
<span class="line-removed">-             (Thread.class, &quot;tid&quot;);</span>
  
  }
<span class="line-new-header">--- 420,11 ---</span>
          return U.getLong(thread, TID);
      }
  
      // Hotspot implementation via intrinsics API
      private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">!     private static final long PARKBLOCKER</span>
<span class="line-modified">!         = U.objectFieldOffset(Thread.class, &quot;parkBlocker&quot;);</span>
<span class="line-modified">!     private static final long TID</span>
<span class="line-modified">!         = U.objectFieldOffset(Thread.class, &quot;tid&quot;);</span>
  
  }
</pre>
<center><a href="Lock.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantLock.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
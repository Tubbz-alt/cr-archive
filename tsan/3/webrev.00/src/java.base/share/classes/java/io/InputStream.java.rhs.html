<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/InputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.List;
 31 import java.util.Objects;
 32 
 33 /**
 34  * This abstract class is the superclass of all classes representing
 35  * an input stream of bytes.
 36  *
<a name="2" id="anc2"></a><span class="line-modified"> 37  * &lt;p&gt; Applications that need to define a subclass of {@code InputStream}</span>
 38  * must always provide a method that returns the next byte of input.
 39  *
 40  * @author  Arthur van Hoff
 41  * @see     java.io.BufferedInputStream
 42  * @see     java.io.ByteArrayInputStream
 43  * @see     java.io.DataInputStream
 44  * @see     java.io.FilterInputStream
 45  * @see     java.io.InputStream#read()
 46  * @see     java.io.OutputStream
 47  * @see     java.io.PushbackInputStream
 48  * @since   1.0
 49  */
 50 public abstract class InputStream implements Closeable {
 51 
 52     // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to
 53     // use when skipping.
 54     private static final int MAX_SKIP_BUFFER_SIZE = 2048;
 55 
 56     private static final int DEFAULT_BUFFER_SIZE = 8192;
 57 
<a name="3" id="anc3"></a><span class="line-added"> 58     /**</span>
<span class="line-added"> 59      * Constructor for subclasses to call.</span>
<span class="line-added"> 60      */</span>
<span class="line-added"> 61     public InputStream() {}</span>
<span class="line-added"> 62 </span>
 63     /**
 64      * Returns a new {@code InputStream} that reads no bytes. The returned
 65      * stream is initially open.  The stream is closed by calling the
 66      * {@code close()} method.  Subsequent calls to {@code close()} have no
 67      * effect.
 68      *
 69      * &lt;p&gt; While the stream is open, the {@code available()}, {@code read()},
 70      * {@code read(byte[])}, {@code read(byte[], int, int)},
 71      * {@code readAllBytes()}, {@code readNBytes(byte[], int, int)},
 72      * {@code readNBytes(int)}, {@code skip(long)}, {@code skipNBytes(long)},
 73      * and {@code transferTo()} methods all behave as if end of stream has been
 74      * reached.  After the stream has been closed, these methods all throw
 75      * {@code IOException}.
 76      *
 77      * &lt;p&gt; The {@code markSupported()} method returns {@code false}.  The
 78      * {@code mark()} method does nothing, and the {@code reset()} method
 79      * throws {@code IOException}.
 80      *
 81      * @return an {@code InputStream} which contains no bytes
 82      *
 83      * @since 11
 84      */
 85     public static InputStream nullInputStream() {
 86         return new InputStream() {
 87             private volatile boolean closed;
 88 
 89             private void ensureOpen() throws IOException {
 90                 if (closed) {
 91                     throw new IOException(&quot;Stream closed&quot;);
 92                 }
 93             }
 94 
 95             @Override
 96             public int available () throws IOException {
 97                 ensureOpen();
 98                 return 0;
 99             }
100 
101             @Override
102             public int read() throws IOException {
103                 ensureOpen();
104                 return -1;
105             }
106 
107             @Override
108             public int read(byte[] b, int off, int len) throws IOException {
109                 Objects.checkFromIndexSize(off, len, b.length);
110                 if (len == 0) {
111                     return 0;
112                 }
113                 ensureOpen();
114                 return -1;
115             }
116 
117             @Override
118             public byte[] readAllBytes() throws IOException {
119                 ensureOpen();
120                 return new byte[0];
121             }
122 
123             @Override
124             public int readNBytes(byte[] b, int off, int len)
125                 throws IOException {
126                 Objects.checkFromIndexSize(off, len, b.length);
127                 ensureOpen();
128                 return 0;
129             }
130 
131             @Override
132             public byte[] readNBytes(int len) throws IOException {
133                 if (len &lt; 0) {
134                     throw new IllegalArgumentException(&quot;len &lt; 0&quot;);
135                 }
136                 ensureOpen();
137                 return new byte[0];
138             }
139 
140             @Override
141             public long skip(long n) throws IOException {
142                 ensureOpen();
143                 return 0L;
144             }
145 
146             @Override
147             public void skipNBytes(long n) throws IOException {
148                 ensureOpen();
149                 if (n &gt; 0) {
150                     throw new EOFException();
151                 }
152             }
153 
154             @Override
155             public long transferTo(OutputStream out) throws IOException {
156                 Objects.requireNonNull(out);
157                 ensureOpen();
158                 return 0L;
159             }
160 
161             @Override
162             public void close() throws IOException {
163                 closed = true;
164             }
165         };
166     }
167 
168     /**
169      * Reads the next byte of data from the input stream. The value byte is
<a name="4" id="anc4"></a><span class="line-modified">170      * returned as an {@code int} in the range {@code 0} to</span>
<span class="line-modified">171      * {@code 255}. If no byte is available because the end of the stream</span>
<span class="line-modified">172      * has been reached, the value {@code -1} is returned. This method</span>
173      * blocks until input data is available, the end of the stream is detected,
174      * or an exception is thrown.
175      *
176      * &lt;p&gt; A subclass must provide an implementation of this method.
177      *
<a name="5" id="anc5"></a><span class="line-modified">178      * @return     the next byte of data, or {@code -1} if the end of the</span>
179      *             stream is reached.
<a name="6" id="anc6"></a><span class="line-modified">180      * @throws     IOException  if an I/O error occurs.</span>
181      */
182     public abstract int read() throws IOException;
183 
184     /**
185      * Reads some number of bytes from the input stream and stores them into
<a name="7" id="anc7"></a><span class="line-modified">186      * the buffer array {@code b}. The number of bytes actually read is</span>
187      * returned as an integer.  This method blocks until input data is
188      * available, end of file is detected, or an exception is thrown.
189      *
<a name="8" id="anc8"></a><span class="line-modified">190      * &lt;p&gt; If the length of {@code b} is zero, then no bytes are read and</span>
<span class="line-modified">191      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
192      * least one byte. If no byte is available because the stream is at the
<a name="9" id="anc9"></a><span class="line-modified">193      * end of the file, the value {@code -1} is returned; otherwise, at</span>
<span class="line-modified">194      * least one byte is read and stored into {@code b}.</span>
195      *
<a name="10" id="anc10"></a><span class="line-modified">196      * &lt;p&gt; The first byte read is stored into element {@code b[0]}, the</span>
<span class="line-modified">197      * next one into {@code b[1]}, and so on. The number of bytes read is,</span>
<span class="line-modified">198      * at most, equal to the length of {@code b}. Let &lt;i&gt;k&lt;/i&gt; be the</span>
199      * number of bytes actually read; these bytes will be stored in elements
<a name="11" id="anc11"></a><span class="line-modified">200      * {@code b[0]} through {@code b[}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">201      * leaving elements {@code b[}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">202      * {@code b[b.length-1]} unaffected.</span>
203      *
<a name="12" id="anc12"></a><span class="line-modified">204      * &lt;p&gt; The {@code read(b)} method for class {@code InputStream}</span>
<span class="line-modified">205      * has the same effect as: &lt;pre&gt;{@code  read(b, 0, b.length) }&lt;/pre&gt;</span>
206      *
207      * @param      b   the buffer into which the data is read.
208      * @return     the total number of bytes read into the buffer, or
<a name="13" id="anc13"></a><span class="line-modified">209      *             {@code -1} if there is no more data because the end of</span>
210      *             the stream has been reached.
<a name="14" id="anc14"></a><span class="line-modified">211      * @throws     IOException  If the first byte cannot be read for any reason</span>
<span class="line-modified">212      *             other than the end of the file, if the input stream has been</span>
<span class="line-modified">213      *             closed, or if some other I/O error occurs.</span>
<span class="line-modified">214      * @throws     NullPointerException  if {@code b} is {@code null}.</span>
215      * @see        java.io.InputStream#read(byte[], int, int)
216      */
217     public int read(byte b[]) throws IOException {
218         return read(b, 0, b.length);
219     }
220 
221     /**
<a name="15" id="anc15"></a><span class="line-modified">222      * Reads up to {@code len} bytes of data from the input stream into</span>
223      * an array of bytes.  An attempt is made to read as many as
<a name="16" id="anc16"></a><span class="line-modified">224      * {@code len} bytes, but a smaller number may be read.</span>
225      * The number of bytes actually read is returned as an integer.
226      *
227      * &lt;p&gt; This method blocks until input data is available, end of file is
228      * detected, or an exception is thrown.
229      *
<a name="17" id="anc17"></a><span class="line-modified">230      * &lt;p&gt; If {@code len} is zero, then no bytes are read and</span>
<span class="line-modified">231      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
232      * least one byte. If no byte is available because the stream is at end of
<a name="18" id="anc18"></a><span class="line-modified">233      * file, the value {@code -1} is returned; otherwise, at least one</span>
<span class="line-modified">234      * byte is read and stored into {@code b}.</span>
235      *
<a name="19" id="anc19"></a><span class="line-modified">236      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the</span>
<span class="line-modified">237      * next one into {@code b[off+1]}, and so on. The number of bytes read</span>
<span class="line-modified">238      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
239      * bytes actually read; these bytes will be stored in elements
<a name="20" id="anc20"></a><span class="line-modified">240      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">241      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">242      * {@code b[off+len-1]} unaffected.</span>
<span class="line-modified">243      *</span>
<span class="line-modified">244      * &lt;p&gt; In every case, elements {@code b[0]} through</span>
<span class="line-modified">245      * {@code b[off-1]} and elements {@code b[off+len]} through</span>
<span class="line-modified">246      * {@code b[b.length-1]} are unaffected.</span>
<span class="line-modified">247      *</span>
<span class="line-modified">248      * &lt;p&gt; The {@code read(b, off, len)} method</span>
<span class="line-modified">249      * for class {@code InputStream} simply calls the method</span>
<span class="line-modified">250      * {@code read()} repeatedly. If the first such call results in an</span>
<span class="line-modified">251      * {@code IOException}, that exception is returned from the call to</span>
<span class="line-modified">252      * the {@code read(b,} {@code off,} {@code len)} method.  If</span>
<span class="line-modified">253      * any subsequent call to {@code read()} results in a</span>
<span class="line-modified">254      * {@code IOException}, the exception is caught and treated as if it</span>
255      * were end of file; the bytes read up to that point are stored into
<a name="21" id="anc21"></a><span class="line-modified">256      * {@code b} and the number of bytes read before the exception</span>
257      * occurred is returned. The default implementation of this method blocks
<a name="22" id="anc22"></a><span class="line-modified">258      * until the requested amount of input data {@code len} has been read,</span>
259      * end of file is detected, or an exception is thrown. Subclasses are
260      * encouraged to provide a more efficient implementation of this method.
261      *
262      * @param      b     the buffer into which the data is read.
<a name="23" id="anc23"></a><span class="line-modified">263      * @param      off   the start offset in array {@code b}</span>
264      *                   at which the data is written.
265      * @param      len   the maximum number of bytes to read.
266      * @return     the total number of bytes read into the buffer, or
<a name="24" id="anc24"></a><span class="line-modified">267      *             {@code -1} if there is no more data because the end of</span>
268      *             the stream has been reached.
<a name="25" id="anc25"></a><span class="line-modified">269      * @throws     IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">270      *             other than end of file, or if the input stream has been closed,</span>
<span class="line-modified">271      *             or if some other I/O error occurs.</span>
<span class="line-modified">272      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">273      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">274      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">275      *             {@code b.length - off}</span>
276      * @see        java.io.InputStream#read()
277      */
278     public int read(byte b[], int off, int len) throws IOException {
279         Objects.checkFromIndexSize(off, len, b.length);
280         if (len == 0) {
281             return 0;
282         }
283 
284         int c = read();
285         if (c == -1) {
286             return -1;
287         }
288         b[off] = (byte)c;
289 
290         int i = 1;
291         try {
292             for (; i &lt; len ; i++) {
293                 c = read();
294                 if (c == -1) {
295                     break;
296                 }
297                 b[off + i] = (byte)c;
298             }
299         } catch (IOException ee) {
300         }
301         return i;
302     }
303 
304     /**
305      * The maximum size of array to allocate.
306      * Some VMs reserve some header words in an array.
307      * Attempts to allocate larger arrays may result in
308      * OutOfMemoryError: Requested array size exceeds VM limit
309      */
310     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
311 
312     /**
313      * Reads all remaining bytes from the input stream. This method blocks until
314      * all remaining bytes have been read and end of stream is detected, or an
315      * exception is thrown. This method does not close the input stream.
316      *
317      * &lt;p&gt; When this stream reaches end of stream, further invocations of this
318      * method will return an empty byte array.
319      *
320      * &lt;p&gt; Note that this method is intended for simple cases where it is
321      * convenient to read all bytes into a byte array. It is not intended for
322      * reading input streams with large amounts of data.
323      *
324      * &lt;p&gt; The behavior for the case where the input stream is &lt;i&gt;asynchronously
325      * closed&lt;/i&gt;, or the thread interrupted during the read, is highly input
326      * stream specific, and therefore not specified.
327      *
328      * &lt;p&gt; If an I/O error occurs reading from the input stream, then it may do
329      * so after some, but not all, bytes have been read. Consequently the input
330      * stream may not be at end of stream and may be in an inconsistent state.
331      * It is strongly recommended that the stream be promptly closed if an I/O
332      * error occurs.
333      *
334      * @implSpec
335      * This method invokes {@link #readNBytes(int)} with a length of
336      * {@link Integer#MAX_VALUE}.
337      *
338      * @return a byte array containing the bytes read from this input stream
339      * @throws IOException if an I/O error occurs
340      * @throws OutOfMemoryError if an array of the required size cannot be
341      *         allocated.
342      *
343      * @since 9
344      */
345     public byte[] readAllBytes() throws IOException {
346         return readNBytes(Integer.MAX_VALUE);
347     }
348 
349     /**
350      * Reads up to a specified number of bytes from the input stream. This
351      * method blocks until the requested number of bytes have been read, end
352      * of stream is detected, or an exception is thrown. This method does not
353      * close the input stream.
354      *
355      * &lt;p&gt; The length of the returned array equals the number of bytes read
356      * from the stream. If {@code len} is zero, then no bytes are read and
357      * an empty byte array is returned. Otherwise, up to {@code len} bytes
358      * are read from the stream. Fewer than {@code len} bytes may be read if
359      * end of stream is encountered.
360      *
361      * &lt;p&gt; When this stream reaches end of stream, further invocations of this
362      * method will return an empty byte array.
363      *
364      * &lt;p&gt; Note that this method is intended for simple cases where it is
365      * convenient to read the specified number of bytes into a byte array. The
366      * total amount of memory allocated by this method is proportional to the
367      * number of bytes read from the stream which is bounded by {@code len}.
368      * Therefore, the method may be safely called with very large values of
369      * {@code len} provided sufficient memory is available.
370      *
371      * &lt;p&gt; The behavior for the case where the input stream is &lt;i&gt;asynchronously
372      * closed&lt;/i&gt;, or the thread interrupted during the read, is highly input
373      * stream specific, and therefore not specified.
374      *
375      * &lt;p&gt; If an I/O error occurs reading from the input stream, then it may do
376      * so after some, but not all, bytes have been read. Consequently the input
377      * stream may not be at end of stream and may be in an inconsistent state.
378      * It is strongly recommended that the stream be promptly closed if an I/O
379      * error occurs.
380      *
381      * @implNote
382      * The number of bytes allocated to read data from this stream and return
383      * the result is bounded by {@code 2*(long)len}, inclusive.
384      *
385      * @param len the maximum number of bytes to read
386      * @return a byte array containing the bytes read from this input stream
387      * @throws IllegalArgumentException if {@code length} is negative
388      * @throws IOException if an I/O error occurs
389      * @throws OutOfMemoryError if an array of the required size cannot be
390      *         allocated.
391      *
392      * @since 11
393      */
394     public byte[] readNBytes(int len) throws IOException {
395         if (len &lt; 0) {
396             throw new IllegalArgumentException(&quot;len &lt; 0&quot;);
397         }
398 
399         List&lt;byte[]&gt; bufs = null;
400         byte[] result = null;
401         int total = 0;
402         int remaining = len;
403         int n;
404         do {
405             byte[] buf = new byte[Math.min(remaining, DEFAULT_BUFFER_SIZE)];
406             int nread = 0;
407 
408             // read to EOF which may read more or less than buffer size
409             while ((n = read(buf, nread,
410                     Math.min(buf.length - nread, remaining))) &gt; 0) {
411                 nread += n;
412                 remaining -= n;
413             }
414 
415             if (nread &gt; 0) {
416                 if (MAX_BUFFER_SIZE - total &lt; nread) {
417                     throw new OutOfMemoryError(&quot;Required array size too large&quot;);
418                 }
419                 total += nread;
420                 if (result == null) {
421                     result = buf;
422                 } else {
423                     if (bufs == null) {
424                         bufs = new ArrayList&lt;&gt;();
425                         bufs.add(result);
426                     }
427                     bufs.add(buf);
428                 }
429             }
430             // if the last call to read returned -1 or the number of bytes
431             // requested have been read then break
432         } while (n &gt;= 0 &amp;&amp; remaining &gt; 0);
433 
434         if (bufs == null) {
435             if (result == null) {
436                 return new byte[0];
437             }
438             return result.length == total ?
439                 result : Arrays.copyOf(result, total);
440         }
441 
442         result = new byte[total];
443         int offset = 0;
444         remaining = total;
445         for (byte[] b : bufs) {
446             int count = Math.min(b.length, remaining);
447             System.arraycopy(b, 0, result, offset, count);
448             offset += count;
449             remaining -= count;
450         }
451 
452         return result;
453     }
454 
455     /**
456      * Reads the requested number of bytes from the input stream into the given
457      * byte array. This method blocks until {@code len} bytes of input data have
458      * been read, end of stream is detected, or an exception is thrown. The
459      * number of bytes actually read, possibly zero, is returned. This method
460      * does not close the input stream.
461      *
462      * &lt;p&gt; In the case where end of stream is reached before {@code len} bytes
463      * have been read, then the actual number of bytes read will be returned.
464      * When this stream reaches end of stream, further invocations of this
465      * method will return zero.
466      *
467      * &lt;p&gt; If {@code len} is zero, then no bytes are read and {@code 0} is
468      * returned; otherwise, there is an attempt to read up to {@code len} bytes.
469      *
470      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the next
471      * one in to {@code b[off+1]}, and so on. The number of bytes read is, at
472      * most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of bytes actually
473      * read; these bytes will be stored in elements {@code b[off]} through
474      * {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]}, leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;
475      * {@code ]} through {@code b[off+len-1]} unaffected.
476      *
477      * &lt;p&gt; The behavior for the case where the input stream is &lt;i&gt;asynchronously
478      * closed&lt;/i&gt;, or the thread interrupted during the read, is highly input
479      * stream specific, and therefore not specified.
480      *
481      * &lt;p&gt; If an I/O error occurs reading from the input stream, then it may do
482      * so after some, but not all, bytes of {@code b} have been updated with
483      * data from the input stream. Consequently the input stream and {@code b}
484      * may be in an inconsistent state. It is strongly recommended that the
485      * stream be promptly closed if an I/O error occurs.
486      *
487      * @param  b the byte array into which the data is read
488      * @param  off the start offset in {@code b} at which the data is written
489      * @param  len the maximum number of bytes to read
490      * @return the actual number of bytes read into the buffer
491      * @throws IOException if an I/O error occurs
492      * @throws NullPointerException if {@code b} is {@code null}
493      * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}
494      *         is negative, or {@code len} is greater than {@code b.length - off}
495      *
496      * @since 9
497      */
498     public int readNBytes(byte[] b, int off, int len) throws IOException {
499         Objects.checkFromIndexSize(off, len, b.length);
500 
501         int n = 0;
502         while (n &lt; len) {
503             int count = read(b, off + n, len - n);
504             if (count &lt; 0)
505                 break;
506             n += count;
507         }
508         return n;
509     }
510 
511     /**
<a name="26" id="anc26"></a><span class="line-modified">512      * Skips over and discards {@code n} bytes of data from this input</span>
<span class="line-modified">513      * stream. The {@code skip} method may, for a variety of reasons, end</span>
<span class="line-modified">514      * up skipping over some smaller number of bytes, possibly {@code 0}.</span>
515      * This may result from any of a number of conditions; reaching end of file
<a name="27" id="anc27"></a><span class="line-modified">516      * before {@code n} bytes have been skipped is only one possibility.</span>
517      * The actual number of bytes skipped is returned. If {@code n} is
518      * negative, the {@code skip} method for class {@code InputStream} always
519      * returns 0, and no bytes are skipped. Subclasses may handle the negative
520      * value differently.
521      *
<a name="28" id="anc28"></a><span class="line-modified">522      * &lt;p&gt; The {@code skip} method implementation of this class creates a</span>
<span class="line-modified">523      * byte array and then repeatedly reads into it until {@code n} bytes</span>
524      * have been read or the end of the stream has been reached. Subclasses are
525      * encouraged to provide a more efficient implementation of this method.
526      * For instance, the implementation may depend on the ability to seek.
527      *
528      * @param      n   the number of bytes to be skipped.
529      * @return     the actual number of bytes skipped which might be zero.
530      * @throws     IOException  if an I/O error occurs.
531      * @see        java.io.InputStream#skipNBytes(long)
532      */
533     public long skip(long n) throws IOException {
534         long remaining = n;
535         int nr;
536 
537         if (n &lt;= 0) {
538             return 0;
539         }
540 
541         int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
542         byte[] skipBuffer = new byte[size];
543         while (remaining &gt; 0) {
544             nr = read(skipBuffer, 0, (int)Math.min(size, remaining));
545             if (nr &lt; 0) {
546                 break;
547             }
548             remaining -= nr;
549         }
550 
551         return n - remaining;
552     }
553 
554     /**
555      * Skips over and discards exactly {@code n} bytes of data from this input
556      * stream.  If {@code n} is zero, then no bytes are skipped.
557      * If {@code n} is negative, then no bytes are skipped.
558      * Subclasses may handle the negative value differently.
559      *
560      * &lt;p&gt; This method blocks until the requested number of bytes have been
561      * skipped, end of file is reached, or an exception is thrown.
562      *
563      * &lt;p&gt; If end of stream is reached before the stream is at the desired
564      * position, then an {@code EOFException} is thrown.
565      *
566      * &lt;p&gt; If an I/O error occurs, then the input stream may be
567      * in an inconsistent state. It is strongly recommended that the
568      * stream be promptly closed if an I/O error occurs.
569      *
570      * @implNote
571      * Subclasses are encouraged to provide a more efficient implementation
572      * of this method.
573      *
574      * @implSpec
575      * If {@code n} is zero or negative, then no bytes are skipped.
576      * If {@code n} is positive, the default implementation of this method
577      * invokes {@link #skip(long) skip()} with parameter {@code n}.  If the
578      * return value of {@code skip(n)} is non-negative and less than {@code n},
579      * then {@link #read()} is invoked repeatedly until the stream is {@code n}
580      * bytes beyond its position when this method was invoked or end of stream
581      * is reached.  If the return value of {@code skip(n)} is negative or
582      * greater than {@code n}, then an {@code IOException} is thrown.  Any
583      * exception thrown by {@code skip()} or {@code read()} will be propagated.
584      *
585      * @param      n   the number of bytes to be skipped.
586      * @throws     EOFException if end of stream is encountered before the
587      *             stream can be positioned {@code n} bytes beyond its position
588      *             when this method was invoked.
589      * @throws     IOException  if the stream cannot be positioned properly or
590      *             if an I/O error occurs.
591      * @see        java.io.InputStream#skip(long)
592      */
593     public void skipNBytes(long n) throws IOException {
594         if (n &gt; 0) {
595             long ns = skip(n);
596             if (ns &gt;= 0 &amp;&amp; ns &lt; n) { // skipped too few bytes
597                 // adjust number to skip
598                 n -= ns;
599                 // read until requested number skipped or EOS reached
600                 while (n &gt; 0 &amp;&amp; read() != -1) {
601                     n--;
602                 }
603                 // if not enough skipped, then EOFE
604                 if (n != 0) {
605                     throw new EOFException();
606                 }
607             } else if (ns != n) { // skipped negative or too many bytes
608                 throw new IOException(&quot;Unable to skip exactly&quot;);
609             }
610         }
611     }
612 
613     /**
614      * Returns an estimate of the number of bytes that can be read (or skipped
615      * over) from this input stream without blocking, which may be 0, or 0 when
616      * end of stream is detected.  The read might be on the same thread or
617      * another thread.  A single read or skip of this many bytes will not block,
618      * but may read or skip fewer bytes.
619      *
620      * &lt;p&gt; Note that while some implementations of {@code InputStream} will
621      * return the total number of bytes in the stream, many will not.  It is
622      * never correct to use the return value of this method to allocate
623      * a buffer intended to hold all data in this stream.
624      *
625      * &lt;p&gt; A subclass&#39;s implementation of this method may choose to throw an
626      * {@link IOException} if this input stream has been closed by invoking the
627      * {@link #close()} method.
628      *
629      * &lt;p&gt; The {@code available} method of {@code InputStream} always returns
630      * {@code 0}.
631      *
632      * &lt;p&gt; This method should be overridden by subclasses.
633      *
634      * @return     an estimate of the number of bytes that can be read (or
635      *             skipped over) from this input stream without blocking or
636      *             {@code 0} when it reaches the end of the input stream.
<a name="29" id="anc29"></a><span class="line-modified">637      * @throws     IOException if an I/O error occurs.</span>
638      */
639     public int available() throws IOException {
640         return 0;
641     }
642 
643     /**
644      * Closes this input stream and releases any system resources associated
645      * with the stream.
646      *
<a name="30" id="anc30"></a><span class="line-modified">647      * &lt;p&gt; The {@code close} method of {@code InputStream} does</span>
648      * nothing.
649      *
<a name="31" id="anc31"></a><span class="line-modified">650      * @throws     IOException  if an I/O error occurs.</span>
651      */
652     public void close() throws IOException {}
653 
654     /**
655      * Marks the current position in this input stream. A subsequent call to
<a name="32" id="anc32"></a><span class="line-modified">656      * the {@code reset} method repositions this stream at the last marked</span>
657      * position so that subsequent reads re-read the same bytes.
658      *
<a name="33" id="anc33"></a><span class="line-modified">659      * &lt;p&gt; The {@code readlimit} arguments tells this input stream to</span>
660      * allow that many bytes to be read before the mark position gets
661      * invalidated.
662      *
<a name="34" id="anc34"></a><span class="line-modified">663      * &lt;p&gt; The general contract of {@code mark} is that, if the method</span>
<span class="line-modified">664      * {@code markSupported} returns {@code true}, the stream somehow</span>
<span class="line-modified">665      * remembers all the bytes read after the call to {@code mark} and</span>
666      * stands ready to supply those same bytes again if and whenever the method
<a name="35" id="anc35"></a><span class="line-modified">667      * {@code reset} is called.  However, the stream is not required to</span>
<span class="line-modified">668      * remember any data at all if more than {@code readlimit} bytes are</span>
<span class="line-modified">669      * read from the stream before {@code reset} is called.</span>
670      *
671      * &lt;p&gt; Marking a closed stream should not have any effect on the stream.
672      *
<a name="36" id="anc36"></a><span class="line-modified">673      * &lt;p&gt; The {@code mark} method of {@code InputStream} does</span>
674      * nothing.
675      *
676      * @param   readlimit   the maximum limit of bytes that can be read before
677      *                      the mark position becomes invalid.
678      * @see     java.io.InputStream#reset()
679      */
680     public synchronized void mark(int readlimit) {}
681 
682     /**
683      * Repositions this stream to the position at the time the
<a name="37" id="anc37"></a><span class="line-modified">684      * {@code mark} method was last called on this input stream.</span>
685      *
<a name="38" id="anc38"></a><span class="line-modified">686      * &lt;p&gt; The general contract of {@code reset} is:</span>
687      *
688      * &lt;ul&gt;
<a name="39" id="anc39"></a><span class="line-modified">689      * &lt;li&gt; If the method {@code markSupported} returns</span>
<span class="line-modified">690      * {@code true}, then:</span>
691      *
<a name="40" id="anc40"></a><span class="line-modified">692      *     &lt;ul&gt;&lt;li&gt; If the method {@code mark} has not been called since</span>
693      *     the stream was created, or the number of bytes read from the stream
<a name="41" id="anc41"></a><span class="line-modified">694      *     since {@code mark} was last called is larger than the argument</span>
<span class="line-modified">695      *     to {@code mark} at that last call, then an</span>
<span class="line-modified">696      *     {@code IOException} might be thrown.</span>
697      *
<a name="42" id="anc42"></a><span class="line-modified">698      *     &lt;li&gt; If such an {@code IOException} is not thrown, then the</span>
699      *     stream is reset to a state such that all the bytes read since the
<a name="43" id="anc43"></a><span class="line-modified">700      *     most recent call to {@code mark} (or since the start of the</span>
<span class="line-modified">701      *     file, if {@code mark} has not been called) will be resupplied</span>
<span class="line-modified">702      *     to subsequent callers of the {@code read} method, followed by</span>
703      *     any bytes that otherwise would have been the next input data as of
<a name="44" id="anc44"></a><span class="line-modified">704      *     the time of the call to {@code reset}. &lt;/ul&gt;</span>
705      *
<a name="45" id="anc45"></a><span class="line-modified">706      * &lt;li&gt; If the method {@code markSupported} returns</span>
<span class="line-modified">707      * {@code false}, then:</span>
708      *
<a name="46" id="anc46"></a><span class="line-modified">709      *     &lt;ul&gt;&lt;li&gt; The call to {@code reset} may throw an</span>
<span class="line-modified">710      *     {@code IOException}.</span>
711      *
<a name="47" id="anc47"></a><span class="line-modified">712      *     &lt;li&gt; If an {@code IOException} is not thrown, then the stream</span>
713      *     is reset to a fixed state that depends on the particular type of the
714      *     input stream and how it was created. The bytes that will be supplied
<a name="48" id="anc48"></a><span class="line-modified">715      *     to subsequent callers of the {@code read} method depend on the</span>
716      *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;
717      *
<a name="49" id="anc49"></a><span class="line-modified">718      * &lt;p&gt;The method {@code reset} for class {@code InputStream}</span>
<span class="line-modified">719      * does nothing except throw an {@code IOException}.</span>
720      *
<a name="50" id="anc50"></a><span class="line-modified">721      * @throws  IOException  if this stream has not been marked or if the</span>
<span class="line-modified">722      *          mark has been invalidated.</span>
723      * @see     java.io.InputStream#mark(int)
724      * @see     java.io.IOException
725      */
726     public synchronized void reset() throws IOException {
727         throw new IOException(&quot;mark/reset not supported&quot;);
728     }
729 
730     /**
<a name="51" id="anc51"></a><span class="line-modified">731      * Tests if this input stream supports the {@code mark} and</span>
<span class="line-modified">732      * {@code reset} methods. Whether or not {@code mark} and</span>
<span class="line-modified">733      * {@code reset} are supported is an invariant property of a</span>
<span class="line-modified">734      * particular input stream instance. The {@code markSupported} method</span>
<span class="line-modified">735      * of {@code InputStream} returns {@code false}.</span>
<span class="line-modified">736      *</span>
<span class="line-modified">737      * @return  {@code true} if this stream instance supports the mark</span>
<span class="line-modified">738      *          and reset methods; {@code false} otherwise.</span>
739      * @see     java.io.InputStream#mark(int)
740      * @see     java.io.InputStream#reset()
741      */
742     public boolean markSupported() {
743         return false;
744     }
745 
746     /**
747      * Reads all bytes from this input stream and writes the bytes to the
748      * given output stream in the order that they are read. On return, this
749      * input stream will be at end of stream. This method does not close either
750      * stream.
751      * &lt;p&gt;
752      * This method may block indefinitely reading from the input stream, or
753      * writing to the output stream. The behavior for the case where the input
754      * and/or output stream is &lt;i&gt;asynchronously closed&lt;/i&gt;, or the thread
755      * interrupted during the transfer, is highly input and output stream
756      * specific, and therefore not specified.
757      * &lt;p&gt;
758      * If an I/O error occurs reading from the input stream or writing to the
759      * output stream, then it may do so after some bytes have been read or
760      * written. Consequently the input stream may not be at end of stream and
761      * one, or both, streams may be in an inconsistent state. It is strongly
762      * recommended that both streams be promptly closed if an I/O error occurs.
763      *
764      * @param  out the output stream, non-null
765      * @return the number of bytes transferred
766      * @throws IOException if an I/O error occurs when reading or writing
767      * @throws NullPointerException if {@code out} is {@code null}
768      *
769      * @since 9
770      */
771     public long transferTo(OutputStream out) throws IOException {
772         Objects.requireNonNull(out, &quot;out&quot;);
773         long transferred = 0;
774         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
775         int read;
776         while ((read = this.read(buffer, 0, DEFAULT_BUFFER_SIZE)) &gt;= 0) {
777             out.write(buffer, 0, read);
778             transferred += read;
779         }
780         return transferred;
781     }
782 }
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>
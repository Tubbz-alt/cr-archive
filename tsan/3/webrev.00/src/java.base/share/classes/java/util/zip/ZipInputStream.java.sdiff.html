<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.io.EOFException;
 31 import java.io.PushbackInputStream;
 32 import java.nio.charset.Charset;
<span class="line-modified"> 33 import java.nio.charset.StandardCharsets;</span>


 34 import static java.util.zip.ZipConstants64.*;
 35 import static java.util.zip.ZipUtils.*;
 36 
 37 /**
 38  * This class implements an input stream filter for reading files in the
 39  * ZIP file format. Includes support for both compressed and uncompressed
 40  * entries.
 41  *
 42  * @author      David Connelly
 43  * @since 1.1
 44  */
<span class="line-modified"> 45 public</span>
<span class="line-removed"> 46 class ZipInputStream extends InflaterInputStream implements ZipConstants {</span>
 47     private ZipEntry entry;
 48     private int flag;
 49     private CRC32 crc = new CRC32();
 50     private long remaining;
 51     private byte[] tmpbuf = new byte[512];
 52 
 53     private static final int STORED = ZipEntry.STORED;
 54     private static final int DEFLATED = ZipEntry.DEFLATED;
 55 
 56     private boolean closed = false;
 57     // this flag is set to true after EOF has reached for
 58     // one entry
 59     private boolean entryEOF = false;
 60 
 61     private ZipCoder zc;
 62 
 63     /**
 64      * Check to make sure that this stream has not been closed
 65      */
 66     private void ensureOpen() throws IOException {
 67         if (closed) {
 68             throw new IOException(&quot;Stream closed&quot;);
 69         }
 70     }
 71 
 72     /**
 73      * Creates a new ZIP input stream.
 74      *
 75      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 76      * decode the entry names.
 77      *
 78      * @param in the actual input stream
 79      */
 80     public ZipInputStream(InputStream in) {
<span class="line-modified"> 81         this(in, StandardCharsets.UTF_8);</span>
 82     }
 83 
 84     /**
 85      * Creates a new ZIP input stream.
 86      *
 87      * @param in the actual input stream
 88      *
 89      * @param charset
 90      *        The {@linkplain java.nio.charset.Charset charset} to be
 91      *        used to decode the ZIP entry name (ignored if the
 92      *        &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 93      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 94      *        flag is set).
 95      *
 96      * @since 1.7
 97      */
 98     public ZipInputStream(InputStream in, Charset charset) {
 99         super(new PushbackInputStream(in, 512), new Inflater(true), 512);
100         usesDefaultInflater = true;
101         if (in == null) {
102             throw new NullPointerException(&quot;in is null&quot;);
103         }
104         if (charset == null)
105             throw new NullPointerException(&quot;charset is null&quot;);
106         this.zc = ZipCoder.get(charset);
107     }
108 
109     /**
110      * Reads the next ZIP file entry and positions the stream at the
111      * beginning of the entry data.
112      * @return the next ZIP file entry, or null if there are no more entries
<span class="line-modified">113      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">114      * @exception IOException if an I/O error has occurred</span>
115      */
116     public ZipEntry getNextEntry() throws IOException {
117         ensureOpen();
118         if (entry != null) {
119             closeEntry();
120         }
121         crc.reset();
122         inf.reset();
123         if ((entry = readLOC()) == null) {
124             return null;
125         }
126         if (entry.method == STORED) {
127             remaining = entry.size;
128         }
129         entryEOF = false;
130         return entry;
131     }
132 
133     /**
134      * Closes the current ZIP entry and positions the stream for reading the
135      * next entry.
<span class="line-modified">136      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">137      * @exception IOException if an I/O error has occurred</span>
138      */
139     public void closeEntry() throws IOException {
140         ensureOpen();
141         while (read(tmpbuf, 0, tmpbuf.length) != -1) ;
142         entryEOF = true;
143     }
144 
145     /**
146      * Returns 0 after EOF has reached for the current entry data,
147      * otherwise always return 1.
148      * &lt;p&gt;
149      * Programs should not count on this method to return the actual number
150      * of bytes that could be read without blocking.
151      *
152      * @return     1 before EOF and 0 after EOF has reached for current entry.
<span class="line-modified">153      * @exception  IOException  if an I/O error occurs.</span>
154      *
155      */
156     public int available() throws IOException {
157         ensureOpen();
158         if (entryEOF) {
159             return 0;
160         } else {
161             return 1;
162         }
163     }
164 
165     /**
166      * Reads from the current ZIP entry into an array of bytes.
<span class="line-modified">167      * If &lt;code&gt;len&lt;/code&gt; is not zero, the method</span>
168      * blocks until some input is available; otherwise, no
<span class="line-modified">169      * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
170      * @param b the buffer into which the data is read
<span class="line-modified">171      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
172      * @param len the maximum number of bytes read
173      * @return the actual number of bytes read, or -1 if the end of the
174      *         entry is reached
<span class="line-modified">175      * @exception  NullPointerException if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">176      * @exception  IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">177      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">178      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">179      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">180      * @exception IOException if an I/O error has occurred</span>
181      */
182     public int read(byte[] b, int off, int len) throws IOException {
183         ensureOpen();
184         if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {
185             throw new IndexOutOfBoundsException();
186         } else if (len == 0) {
187             return 0;
188         }
189 
190         if (entry == null) {
191             return -1;
192         }
193         switch (entry.method) {
194         case DEFLATED:
195             len = super.read(b, off, len);
196             if (len == -1) {
197                 readEnd(entry);
198                 entryEOF = true;
199                 entry = null;
200             } else {
</pre>
<hr />
<pre>
214             if (len == -1) {
215                 throw new ZipException(&quot;unexpected EOF&quot;);
216             }
217             crc.update(b, off, len);
218             remaining -= len;
219             if (remaining == 0 &amp;&amp; entry.crc != crc.getValue()) {
220                 throw new ZipException(
221                     &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(entry.crc) +
222                     &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);
223             }
224             return len;
225         default:
226             throw new ZipException(&quot;invalid compression method&quot;);
227         }
228     }
229 
230     /**
231      * Skips specified number of bytes in the current ZIP entry.
232      * @param n the number of bytes to skip
233      * @return the actual number of bytes skipped
<span class="line-modified">234      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">235      * @exception IOException if an I/O error has occurred</span>
<span class="line-modified">236      * @exception IllegalArgumentException if {@code n &lt; 0}</span>
237      */
238     public long skip(long n) throws IOException {
239         if (n &lt; 0) {
240             throw new IllegalArgumentException(&quot;negative skip length&quot;);
241         }
242         ensureOpen();
243         int max = (int)Math.min(n, Integer.MAX_VALUE);
244         int total = 0;
245         while (total &lt; max) {
246             int len = max - total;
247             if (len &gt; tmpbuf.length) {
248                 len = tmpbuf.length;
249             }
250             len = read(tmpbuf, 0, len);
251             if (len == -1) {
252                 entryEOF = true;
253                 break;
254             }
255             total += len;
256         }
257         return total;
258     }
259 
260     /**
261      * Closes this input stream and releases any system resources associated
262      * with the stream.
<span class="line-modified">263      * @exception IOException if an I/O error has occurred</span>
264      */
265     public void close() throws IOException {
266         if (!closed) {
267             super.close();
268             closed = true;
269         }
270     }
271 
272     private byte[] b = new byte[256];
273 
274     /*
275      * Reads local file (LOC) header for next entry.
276      */
277     private ZipEntry readLOC() throws IOException {
278         try {
279             readFully(tmpbuf, 0, LOCHDR);
280         } catch (EOFException e) {
281             return null;
282         }
283         if (get32(tmpbuf, 0) != LOCSIG) {
</pre>
<hr />
<pre>
304             throw new ZipException(&quot;encrypted ZIP entry not supported&quot;);
305         }
306         e.method = get16(tmpbuf, LOCHOW);
307         e.xdostime = get32(tmpbuf, LOCTIM);
308         if ((flag &amp; 8) == 8) {
309             /* &quot;Data Descriptor&quot; present */
310             if (e.method != DEFLATED) {
311                 throw new ZipException(
312                         &quot;only DEFLATED entries can have EXT descriptor&quot;);
313             }
314         } else {
315             e.crc = get32(tmpbuf, LOCCRC);
316             e.csize = get32(tmpbuf, LOCSIZ);
317             e.size = get32(tmpbuf, LOCLEN);
318         }
319         len = get16(tmpbuf, LOCEXT);
320         if (len &gt; 0) {
321             byte[] extra = new byte[len];
322             readFully(extra, 0, len);
323             e.setExtra0(extra,
<span class="line-modified">324                         e.csize == ZIP64_MAGICVAL || e.size == ZIP64_MAGICVAL);</span>
325         }
326         return e;
327     }
328 
329     /**
<span class="line-modified">330      * Creates a new &lt;code&gt;ZipEntry&lt;/code&gt; object for the specified</span>
331      * entry name.
332      *
333      * @param name the ZIP file entry name
334      * @return the ZipEntry just created
335      */
336     protected ZipEntry createZipEntry(String name) {
337         return new ZipEntry(name);
338     }
339 
340     /**
341      * Reads end of deflated entry as well as EXT descriptor if present.
342      *
343      * Local headers for DEFLATED entries may optionally be followed by a
344      * data descriptor, and that data descriptor may optionally contain a
345      * leading signature (EXTSIG).
346      *
347      * From the zip spec http://www.pkware.com/documents/casestudies/APPNOTE.TXT
348      *
349      * &quot;&quot;&quot;Although not originally assigned a signature, the value 0x08074b50
350      * has commonly been adopted as a signature value for the data descriptor
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.io.EOFException;
 31 import java.io.PushbackInputStream;
 32 import java.nio.charset.Charset;
<span class="line-modified"> 33 </span>
<span class="line-added"> 34 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 35 </span>
 36 import static java.util.zip.ZipConstants64.*;
 37 import static java.util.zip.ZipUtils.*;
 38 
 39 /**
 40  * This class implements an input stream filter for reading files in the
 41  * ZIP file format. Includes support for both compressed and uncompressed
 42  * entries.
 43  *
 44  * @author      David Connelly
 45  * @since 1.1
 46  */
<span class="line-modified"> 47 public class ZipInputStream extends InflaterInputStream implements ZipConstants {</span>

 48     private ZipEntry entry;
 49     private int flag;
 50     private CRC32 crc = new CRC32();
 51     private long remaining;
 52     private byte[] tmpbuf = new byte[512];
 53 
 54     private static final int STORED = ZipEntry.STORED;
 55     private static final int DEFLATED = ZipEntry.DEFLATED;
 56 
 57     private boolean closed = false;
 58     // this flag is set to true after EOF has reached for
 59     // one entry
 60     private boolean entryEOF = false;
 61 
 62     private ZipCoder zc;
 63 
 64     /**
 65      * Check to make sure that this stream has not been closed
 66      */
 67     private void ensureOpen() throws IOException {
 68         if (closed) {
 69             throw new IOException(&quot;Stream closed&quot;);
 70         }
 71     }
 72 
 73     /**
 74      * Creates a new ZIP input stream.
 75      *
 76      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 77      * decode the entry names.
 78      *
 79      * @param in the actual input stream
 80      */
 81     public ZipInputStream(InputStream in) {
<span class="line-modified"> 82         this(in, UTF_8.INSTANCE);</span>
 83     }
 84 
 85     /**
 86      * Creates a new ZIP input stream.
 87      *
 88      * @param in the actual input stream
 89      *
 90      * @param charset
 91      *        The {@linkplain java.nio.charset.Charset charset} to be
 92      *        used to decode the ZIP entry name (ignored if the
 93      *        &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 94      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 95      *        flag is set).
 96      *
 97      * @since 1.7
 98      */
 99     public ZipInputStream(InputStream in, Charset charset) {
100         super(new PushbackInputStream(in, 512), new Inflater(true), 512);
101         usesDefaultInflater = true;
102         if (in == null) {
103             throw new NullPointerException(&quot;in is null&quot;);
104         }
105         if (charset == null)
106             throw new NullPointerException(&quot;charset is null&quot;);
107         this.zc = ZipCoder.get(charset);
108     }
109 
110     /**
111      * Reads the next ZIP file entry and positions the stream at the
112      * beginning of the entry data.
113      * @return the next ZIP file entry, or null if there are no more entries
<span class="line-modified">114      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">115      * @throws    IOException if an I/O error has occurred</span>
116      */
117     public ZipEntry getNextEntry() throws IOException {
118         ensureOpen();
119         if (entry != null) {
120             closeEntry();
121         }
122         crc.reset();
123         inf.reset();
124         if ((entry = readLOC()) == null) {
125             return null;
126         }
127         if (entry.method == STORED) {
128             remaining = entry.size;
129         }
130         entryEOF = false;
131         return entry;
132     }
133 
134     /**
135      * Closes the current ZIP entry and positions the stream for reading the
136      * next entry.
<span class="line-modified">137      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">138      * @throws    IOException if an I/O error has occurred</span>
139      */
140     public void closeEntry() throws IOException {
141         ensureOpen();
142         while (read(tmpbuf, 0, tmpbuf.length) != -1) ;
143         entryEOF = true;
144     }
145 
146     /**
147      * Returns 0 after EOF has reached for the current entry data,
148      * otherwise always return 1.
149      * &lt;p&gt;
150      * Programs should not count on this method to return the actual number
151      * of bytes that could be read without blocking.
152      *
153      * @return     1 before EOF and 0 after EOF has reached for current entry.
<span class="line-modified">154      * @throws     IOException  if an I/O error occurs.</span>
155      *
156      */
157     public int available() throws IOException {
158         ensureOpen();
159         if (entryEOF) {
160             return 0;
161         } else {
162             return 1;
163         }
164     }
165 
166     /**
167      * Reads from the current ZIP entry into an array of bytes.
<span class="line-modified">168      * If {@code len} is not zero, the method</span>
169      * blocks until some input is available; otherwise, no
<span class="line-modified">170      * bytes are read and {@code 0} is returned.</span>
171      * @param b the buffer into which the data is read
<span class="line-modified">172      * @param off the start offset in the destination array {@code b}</span>
173      * @param len the maximum number of bytes read
174      * @return the actual number of bytes read, or -1 if the end of the
175      *         entry is reached
<span class="line-modified">176      * @throws     NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">177      * @throws     IndexOutOfBoundsException if {@code off} is negative,</span>
<span class="line-modified">178      * {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">179      * {@code b.length - off}</span>
<span class="line-modified">180      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">181      * @throws    IOException if an I/O error has occurred</span>
182      */
183     public int read(byte[] b, int off, int len) throws IOException {
184         ensureOpen();
185         if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {
186             throw new IndexOutOfBoundsException();
187         } else if (len == 0) {
188             return 0;
189         }
190 
191         if (entry == null) {
192             return -1;
193         }
194         switch (entry.method) {
195         case DEFLATED:
196             len = super.read(b, off, len);
197             if (len == -1) {
198                 readEnd(entry);
199                 entryEOF = true;
200                 entry = null;
201             } else {
</pre>
<hr />
<pre>
215             if (len == -1) {
216                 throw new ZipException(&quot;unexpected EOF&quot;);
217             }
218             crc.update(b, off, len);
219             remaining -= len;
220             if (remaining == 0 &amp;&amp; entry.crc != crc.getValue()) {
221                 throw new ZipException(
222                     &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(entry.crc) +
223                     &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);
224             }
225             return len;
226         default:
227             throw new ZipException(&quot;invalid compression method&quot;);
228         }
229     }
230 
231     /**
232      * Skips specified number of bytes in the current ZIP entry.
233      * @param n the number of bytes to skip
234      * @return the actual number of bytes skipped
<span class="line-modified">235      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">236      * @throws    IOException if an I/O error has occurred</span>
<span class="line-modified">237      * @throws    IllegalArgumentException if {@code n &lt; 0}</span>
238      */
239     public long skip(long n) throws IOException {
240         if (n &lt; 0) {
241             throw new IllegalArgumentException(&quot;negative skip length&quot;);
242         }
243         ensureOpen();
244         int max = (int)Math.min(n, Integer.MAX_VALUE);
245         int total = 0;
246         while (total &lt; max) {
247             int len = max - total;
248             if (len &gt; tmpbuf.length) {
249                 len = tmpbuf.length;
250             }
251             len = read(tmpbuf, 0, len);
252             if (len == -1) {
253                 entryEOF = true;
254                 break;
255             }
256             total += len;
257         }
258         return total;
259     }
260 
261     /**
262      * Closes this input stream and releases any system resources associated
263      * with the stream.
<span class="line-modified">264      * @throws    IOException if an I/O error has occurred</span>
265      */
266     public void close() throws IOException {
267         if (!closed) {
268             super.close();
269             closed = true;
270         }
271     }
272 
273     private byte[] b = new byte[256];
274 
275     /*
276      * Reads local file (LOC) header for next entry.
277      */
278     private ZipEntry readLOC() throws IOException {
279         try {
280             readFully(tmpbuf, 0, LOCHDR);
281         } catch (EOFException e) {
282             return null;
283         }
284         if (get32(tmpbuf, 0) != LOCSIG) {
</pre>
<hr />
<pre>
305             throw new ZipException(&quot;encrypted ZIP entry not supported&quot;);
306         }
307         e.method = get16(tmpbuf, LOCHOW);
308         e.xdostime = get32(tmpbuf, LOCTIM);
309         if ((flag &amp; 8) == 8) {
310             /* &quot;Data Descriptor&quot; present */
311             if (e.method != DEFLATED) {
312                 throw new ZipException(
313                         &quot;only DEFLATED entries can have EXT descriptor&quot;);
314             }
315         } else {
316             e.crc = get32(tmpbuf, LOCCRC);
317             e.csize = get32(tmpbuf, LOCSIZ);
318             e.size = get32(tmpbuf, LOCLEN);
319         }
320         len = get16(tmpbuf, LOCEXT);
321         if (len &gt; 0) {
322             byte[] extra = new byte[len];
323             readFully(extra, 0, len);
324             e.setExtra0(extra,
<span class="line-modified">325                         e.csize == ZIP64_MAGICVAL || e.size == ZIP64_MAGICVAL, true);</span>
326         }
327         return e;
328     }
329 
330     /**
<span class="line-modified">331      * Creates a new {@code ZipEntry} object for the specified</span>
332      * entry name.
333      *
334      * @param name the ZIP file entry name
335      * @return the ZipEntry just created
336      */
337     protected ZipEntry createZipEntry(String name) {
338         return new ZipEntry(name);
339     }
340 
341     /**
342      * Reads end of deflated entry as well as EXT descriptor if present.
343      *
344      * Local headers for DEFLATED entries may optionally be followed by a
345      * data descriptor, and that data descriptor may optionally contain a
346      * leading signature (EXTSIG).
347      *
348      * From the zip spec http://www.pkware.com/documents/casestudies/APPNOTE.TXT
349      *
350      * &quot;&quot;&quot;Although not originally assigned a signature, the value 0x08074b50
351      * has commonly been adopted as a signature value for the data descriptor
</pre>
</td>
</tr>
</table>
<center><a href="ZipFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
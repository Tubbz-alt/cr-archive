<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/InetSocketAddress.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InetAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InterfaceAddress.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/InetSocketAddress.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 84         }
 85 
 86         private String getHostString() {
 87             if (hostname != null)
 88                 return hostname;
 89             if (addr != null) {
 90                 if (addr.holder().getHostName() != null)
 91                     return addr.holder().getHostName();
 92                 else
 93                     return addr.getHostAddress();
 94             }
 95             return null;
 96         }
 97 
 98         private boolean isUnresolved() {
 99             return addr == null;
100         }
101 
102         @Override
103         public String toString() {



104             if (isUnresolved()) {
<span class="line-modified">105                 return hostname + &quot;:&quot; + port;</span>
106             } else {
<span class="line-modified">107                 return addr.toString() + &quot;:&quot; + port;</span>





108             }

109         }
110 
111         @Override
112         public final boolean equals(Object obj) {
113             if (obj == null || !(obj instanceof InetSocketAddressHolder))
114                 return false;
115             InetSocketAddressHolder that = (InetSocketAddressHolder)obj;
116             boolean sameIP;
117             if (addr != null)
118                 sameIP = addr.equals(that.addr);
119             else if (hostname != null)
120                 sameIP = (that.addr == null) &amp;&amp;
121                     hostname.equalsIgnoreCase(that.hostname);
122             else
123                 sameIP = (that.addr == null) &amp;&amp; (that.hostname == null);
124             return sameIP &amp;&amp; (port == that.port);
125         }
126 
127         @Override
128         public final int hashCode() {
129             if (addr != null)
130                 return addr.hashCode() + port;
131             if (hostname != null)
132                 return hostname.toLowerCase().hashCode() + port;
133             return port;
134         }
135     }
136 
137     private final transient InetSocketAddressHolder holder;
138 

139     private static final long serialVersionUID = 5076001401234631237L;
140 
141     private static int checkPort(int port) {
142         if (port &lt; 0 || port &gt; 0xFFFF)
143             throw new IllegalArgumentException(&quot;port out of range:&quot; + port);
144         return port;
145     }
146 
147     private static String checkHost(String hostname) {
148         if (hostname == null)
149             throw new IllegalArgumentException(&quot;hostname can&#39;t be null&quot;);
150         return hostname;
151     }
152 
153     /**
154      * Creates a socket address where the IP address is the wildcard address
155      * and the port number a specified value.
156      * &lt;p&gt;
157      * A valid port value is between 0 and 65535.
158      * A port number of {@code zero} will let the system pick up an
</pre>
<hr />
<pre>
242      *
243      * @param   host    the Host name
244      * @param   port    The port number
245      * @throws IllegalArgumentException if the port parameter is outside
246      *                  the range of valid port values, or if the hostname
247      *                  parameter is {@code null}.
248      * @see     #isUnresolved()
249      * @return  an {@code InetSocketAddress} representing the unresolved
250      *          socket address
251      * @since 1.5
252      */
253     public static InetSocketAddress createUnresolved(String host, int port) {
254         return new InetSocketAddress(checkPort(port), checkHost(host));
255     }
256 
257     /**
258      * @serialField hostname String
259      * @serialField addr InetAddress
260      * @serialField port int
261      */

262     private static final ObjectStreamField[] serialPersistentFields = {
263          new ObjectStreamField(&quot;hostname&quot;, String.class),
264          new ObjectStreamField(&quot;addr&quot;, InetAddress.class),
265          new ObjectStreamField(&quot;port&quot;, int.class)};
266 

267     private void writeObject(ObjectOutputStream out)
268         throws IOException
269     {
270         // Don&#39;t call defaultWriteObject()
271          ObjectOutputStream.PutField pfields = out.putFields();
272          pfields.put(&quot;hostname&quot;, holder.hostname);
273          pfields.put(&quot;addr&quot;, holder.addr);
274          pfields.put(&quot;port&quot;, holder.port);
275          out.writeFields();
276      }
277 

278     private void readObject(ObjectInputStream in)
279         throws IOException, ClassNotFoundException
280     {
281         // Don&#39;t call defaultReadObject()
282         ObjectInputStream.GetField oisFields = in.readFields();
283         final String oisHostname = (String)oisFields.get(&quot;hostname&quot;, null);
284         final InetAddress oisAddr = (InetAddress)oisFields.get(&quot;addr&quot;, null);
285         final int oisPort = oisFields.get(&quot;port&quot;, -1);
286 
287         // Check that our invariants are satisfied
288         checkPort(oisPort);
289         if (oisHostname == null &amp;&amp; oisAddr == null)
290             throw new InvalidObjectException(&quot;hostname and addr &quot; +
291                                              &quot;can&#39;t both be null&quot;);
292 
293         InetSocketAddressHolder h = new InetSocketAddressHolder(oisHostname,
294                                                                 oisAddr,
295                                                                 oisPort);
296         UNSAFE.putReference(this, FIELDS_OFFSET, h);
297     }
298 

299     private void readObjectNoData()
300         throws ObjectStreamException
301     {
302         throw new InvalidObjectException(&quot;Stream data required&quot;);
303     }
304 
305     private static final jdk.internal.misc.Unsafe UNSAFE
306             = jdk.internal.misc.Unsafe.getUnsafe();
307     private static final long FIELDS_OFFSET
308             = UNSAFE.objectFieldOffset(InetSocketAddress.class, &quot;holder&quot;);
309 
310     /**
311      * Gets the port number.
312      *
313      * @return the port number.
314      */
315     public final int getPort() {
316         return holder.getPort();
317     }
318 
</pre>
<hr />
<pre>
345      * @since 1.7
346      */
347     public final String getHostString() {
348         return holder.getHostString();
349     }
350 
351     /**
352      * Checks whether the address has been resolved or not.
353      *
354      * @return {@code true} if the hostname couldn&#39;t be resolved into
355      *          an {@code InetAddress}.
356      */
357     public final boolean isUnresolved() {
358         return holder.isUnresolved();
359     }
360 
361     /**
362      * Constructs a string representation of this InetSocketAddress.
363      * This String is constructed by calling toString() on the InetAddress
364      * and concatenating the port number (with a colon). If the address
<span class="line-modified">365      * is unresolved then the part before the colon will only contain the hostname.</span>


366      *
367      * @return  a string representation of this object.
368      */
369     @Override
370     public String toString() {
371         return holder.toString();
372     }
373 
374     /**
375      * Compares this object against the specified object.
376      * The result is {@code true} if and only if the argument is
377      * not {@code null} and it represents the same address as
378      * this object.
379      * &lt;p&gt;
380      * Two instances of {@code InetSocketAddress} represent the same
381      * address if both the InetAddresses (or hostnames if it is unresolved) and port
382      * numbers are equal.
383      * If both addresses are unresolved, then the hostname and the port number
384      * are compared.
385      *
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 84         }
 85 
 86         private String getHostString() {
 87             if (hostname != null)
 88                 return hostname;
 89             if (addr != null) {
 90                 if (addr.holder().getHostName() != null)
 91                     return addr.holder().getHostName();
 92                 else
 93                     return addr.getHostAddress();
 94             }
 95             return null;
 96         }
 97 
 98         private boolean isUnresolved() {
 99             return addr == null;
100         }
101 
102         @Override
103         public String toString() {
<span class="line-added">104 </span>
<span class="line-added">105             String formatted;</span>
<span class="line-added">106 </span>
107             if (isUnresolved()) {
<span class="line-modified">108                 formatted = hostname + &quot;/&lt;unresolved&gt;&quot;;</span>
109             } else {
<span class="line-modified">110                 formatted = addr.toString();</span>
<span class="line-added">111                 if (addr instanceof Inet6Address) {</span>
<span class="line-added">112                     int i = formatted.lastIndexOf(&quot;/&quot;);</span>
<span class="line-added">113                     formatted = formatted.substring(0, i + 1)</span>
<span class="line-added">114                             + &quot;[&quot; + formatted.substring(i + 1) + &quot;]&quot;;</span>
<span class="line-added">115                 }</span>
116             }
<span class="line-added">117             return formatted + &quot;:&quot; + port;</span>
118         }
119 
120         @Override
121         public final boolean equals(Object obj) {
122             if (obj == null || !(obj instanceof InetSocketAddressHolder))
123                 return false;
124             InetSocketAddressHolder that = (InetSocketAddressHolder)obj;
125             boolean sameIP;
126             if (addr != null)
127                 sameIP = addr.equals(that.addr);
128             else if (hostname != null)
129                 sameIP = (that.addr == null) &amp;&amp;
130                     hostname.equalsIgnoreCase(that.hostname);
131             else
132                 sameIP = (that.addr == null) &amp;&amp; (that.hostname == null);
133             return sameIP &amp;&amp; (port == that.port);
134         }
135 
136         @Override
137         public final int hashCode() {
138             if (addr != null)
139                 return addr.hashCode() + port;
140             if (hostname != null)
141                 return hostname.toLowerCase().hashCode() + port;
142             return port;
143         }
144     }
145 
146     private final transient InetSocketAddressHolder holder;
147 
<span class="line-added">148     @java.io.Serial</span>
149     private static final long serialVersionUID = 5076001401234631237L;
150 
151     private static int checkPort(int port) {
152         if (port &lt; 0 || port &gt; 0xFFFF)
153             throw new IllegalArgumentException(&quot;port out of range:&quot; + port);
154         return port;
155     }
156 
157     private static String checkHost(String hostname) {
158         if (hostname == null)
159             throw new IllegalArgumentException(&quot;hostname can&#39;t be null&quot;);
160         return hostname;
161     }
162 
163     /**
164      * Creates a socket address where the IP address is the wildcard address
165      * and the port number a specified value.
166      * &lt;p&gt;
167      * A valid port value is between 0 and 65535.
168      * A port number of {@code zero} will let the system pick up an
</pre>
<hr />
<pre>
252      *
253      * @param   host    the Host name
254      * @param   port    The port number
255      * @throws IllegalArgumentException if the port parameter is outside
256      *                  the range of valid port values, or if the hostname
257      *                  parameter is {@code null}.
258      * @see     #isUnresolved()
259      * @return  an {@code InetSocketAddress} representing the unresolved
260      *          socket address
261      * @since 1.5
262      */
263     public static InetSocketAddress createUnresolved(String host, int port) {
264         return new InetSocketAddress(checkPort(port), checkHost(host));
265     }
266 
267     /**
268      * @serialField hostname String
269      * @serialField addr InetAddress
270      * @serialField port int
271      */
<span class="line-added">272     @java.io.Serial</span>
273     private static final ObjectStreamField[] serialPersistentFields = {
274          new ObjectStreamField(&quot;hostname&quot;, String.class),
275          new ObjectStreamField(&quot;addr&quot;, InetAddress.class),
276          new ObjectStreamField(&quot;port&quot;, int.class)};
277 
<span class="line-added">278     @java.io.Serial</span>
279     private void writeObject(ObjectOutputStream out)
280         throws IOException
281     {
282         // Don&#39;t call defaultWriteObject()
283          ObjectOutputStream.PutField pfields = out.putFields();
284          pfields.put(&quot;hostname&quot;, holder.hostname);
285          pfields.put(&quot;addr&quot;, holder.addr);
286          pfields.put(&quot;port&quot;, holder.port);
287          out.writeFields();
288      }
289 
<span class="line-added">290     @java.io.Serial</span>
291     private void readObject(ObjectInputStream in)
292         throws IOException, ClassNotFoundException
293     {
294         // Don&#39;t call defaultReadObject()
295         ObjectInputStream.GetField oisFields = in.readFields();
296         final String oisHostname = (String)oisFields.get(&quot;hostname&quot;, null);
297         final InetAddress oisAddr = (InetAddress)oisFields.get(&quot;addr&quot;, null);
298         final int oisPort = oisFields.get(&quot;port&quot;, -1);
299 
300         // Check that our invariants are satisfied
301         checkPort(oisPort);
302         if (oisHostname == null &amp;&amp; oisAddr == null)
303             throw new InvalidObjectException(&quot;hostname and addr &quot; +
304                                              &quot;can&#39;t both be null&quot;);
305 
306         InetSocketAddressHolder h = new InetSocketAddressHolder(oisHostname,
307                                                                 oisAddr,
308                                                                 oisPort);
309         UNSAFE.putReference(this, FIELDS_OFFSET, h);
310     }
311 
<span class="line-added">312     @java.io.Serial</span>
313     private void readObjectNoData()
314         throws ObjectStreamException
315     {
316         throw new InvalidObjectException(&quot;Stream data required&quot;);
317     }
318 
319     private static final jdk.internal.misc.Unsafe UNSAFE
320             = jdk.internal.misc.Unsafe.getUnsafe();
321     private static final long FIELDS_OFFSET
322             = UNSAFE.objectFieldOffset(InetSocketAddress.class, &quot;holder&quot;);
323 
324     /**
325      * Gets the port number.
326      *
327      * @return the port number.
328      */
329     public final int getPort() {
330         return holder.getPort();
331     }
332 
</pre>
<hr />
<pre>
359      * @since 1.7
360      */
361     public final String getHostString() {
362         return holder.getHostString();
363     }
364 
365     /**
366      * Checks whether the address has been resolved or not.
367      *
368      * @return {@code true} if the hostname couldn&#39;t be resolved into
369      *          an {@code InetAddress}.
370      */
371     public final boolean isUnresolved() {
372         return holder.isUnresolved();
373     }
374 
375     /**
376      * Constructs a string representation of this InetSocketAddress.
377      * This String is constructed by calling toString() on the InetAddress
378      * and concatenating the port number (with a colon). If the address
<span class="line-modified">379      * is an IPv6 address, the IPv6 literal is enclosed in square brackets.</span>
<span class="line-added">380      * If the address is {@linkplain #isUnresolved() unresolved},</span>
<span class="line-added">381      * {@code &lt;unresolved&gt;} is displayed in place of the address literal.</span>
382      *
383      * @return  a string representation of this object.
384      */
385     @Override
386     public String toString() {
387         return holder.toString();
388     }
389 
390     /**
391      * Compares this object against the specified object.
392      * The result is {@code true} if and only if the argument is
393      * not {@code null} and it represents the same address as
394      * this object.
395      * &lt;p&gt;
396      * Two instances of {@code InetSocketAddress} represent the same
397      * address if both the InetAddresses (or hostnames if it is unresolved) and port
398      * numbers are equal.
399      * If both addresses are unresolved, then the hostname and the port number
400      * are compared.
401      *
</pre>
</td>
</tr>
</table>
<center><a href="InetAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InterfaceAddress.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
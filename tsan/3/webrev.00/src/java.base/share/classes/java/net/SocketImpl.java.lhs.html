<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/SocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
<a name="2" id="anc2"></a>
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
<a name="3" id="anc3"></a><span class="line-modified"> 31 import java.io.FileDescriptor;</span>


 32 import java.util.Set;
 33 
<a name="4" id="anc4"></a>



 34 /**
 35  * The abstract class {@code SocketImpl} is a common superclass
 36  * of all classes that actually implement sockets. It is used to
 37  * create both client and server sockets.
<a name="5" id="anc5"></a><span class="line-modified"> 38  * &lt;p&gt;</span>
<span class="line-modified"> 39  * A &quot;plain&quot; socket implements these methods exactly as</span>
<span class="line-modified"> 40  * described, without attempting to go through a firewall or proxy.</span>














 41  *
 42  * @author  unascribed
 43  * @since   1.0
 44  */
 45 public abstract class SocketImpl implements SocketOptions {
<a name="6" id="anc6"></a>







 46     /**
<a name="7" id="anc7"></a><span class="line-modified"> 47      * The actual Socket object.</span>
 48      */
<a name="8" id="anc8"></a><span class="line-modified"> 49     Socket socket = null;</span>
<span class="line-modified"> 50     ServerSocket serverSocket = null;</span>






 51 
 52     /**
 53      * The file descriptor object for this socket.
 54      */
 55     protected FileDescriptor fd;
 56 
 57     /**
 58      * The IP address of the remote end of this socket.
 59      */
 60     protected InetAddress address;
 61 
 62     /**
 63      * The port number on the remote host to which this socket is connected.
 64      */
 65     protected int port;
 66 
 67     /**
 68      * The local port number to which this socket is connected.
 69      */
 70     protected int localport;
 71 
<a name="9" id="anc9"></a>




 72     /**
 73      * Creates either a stream or a datagram socket.
 74      *
 75      * @param      stream   if {@code true}, create a stream socket;
 76      *                      otherwise, create a datagram socket.
<a name="10" id="anc10"></a><span class="line-modified"> 77      * @exception  IOException  if an I/O error occurs while creating the</span>
 78      *               socket.
 79      */
 80     protected abstract void create(boolean stream) throws IOException;
 81 
 82     /**
 83      * Connects this socket to the specified port on the named host.
 84      *
 85      * @param      host   the name of the remote host.
 86      * @param      port   the port number.
<a name="11" id="anc11"></a><span class="line-modified"> 87      * @exception  IOException  if an I/O error occurs when connecting to the</span>
 88      *               remote host.
 89      */
 90     protected abstract void connect(String host, int port) throws IOException;
 91 
 92     /**
 93      * Connects this socket to the specified port number on the specified host.
 94      *
 95      * @param      address   the IP address of the remote host.
 96      * @param      port      the port number.
<a name="12" id="anc12"></a><span class="line-modified"> 97      * @exception  IOException  if an I/O error occurs when attempting a</span>
 98      *               connection.
 99      */
100     protected abstract void connect(InetAddress address, int port) throws IOException;
101 
102     /**
103      * Connects this socket to the specified port number on the specified host.
104      * A timeout of zero is interpreted as an infinite timeout. The connection
105      * will then block until established or an error occurs.
106      *
107      * @param      address   the Socket address of the remote host.
108      * @param     timeout  the timeout value, in milliseconds, or zero for no timeout.
<a name="13" id="anc13"></a><span class="line-modified">109      * @exception  IOException  if an I/O error occurs when attempting a</span>
110      *               connection.
111      * @since 1.4
112      */
113     protected abstract void connect(SocketAddress address, int timeout) throws IOException;
114 
115     /**
116      * Binds this socket to the specified local IP address and port number.
117      *
118      * @param      host   an IP address that belongs to a local interface.
119      * @param      port   the port number.
<a name="14" id="anc14"></a><span class="line-modified">120      * @exception  IOException  if an I/O error occurs when binding this socket.</span>
121      */
122     protected abstract void bind(InetAddress host, int port) throws IOException;
123 
124     /**
125      * Sets the maximum queue length for incoming connection indications
126      * (a request to connect) to the {@code count} argument. If a
127      * connection indication arrives when the queue is full, the
128      * connection is refused.
129      *
130      * @param      backlog   the maximum length of the queue.
<a name="15" id="anc15"></a><span class="line-modified">131      * @exception  IOException  if an I/O error occurs when creating the queue.</span>
132      */
133     protected abstract void listen(int backlog) throws IOException;
134 
135     /**
136      * Accepts a connection.
137      *
138      * @param      s   the accepted connection.
<a name="16" id="anc16"></a><span class="line-modified">139      * @exception  IOException  if an I/O error occurs when accepting the</span>
140      *               connection.
141      */
142     protected abstract void accept(SocketImpl s) throws IOException;
143 
144     /**
145      * Returns an input stream for this socket.
146      *
147      * @return     a stream for reading from this socket.
<a name="17" id="anc17"></a><span class="line-modified">148      * @exception  IOException  if an I/O error occurs when creating the</span>
149      *               input stream.
150     */
151     protected abstract InputStream getInputStream() throws IOException;
152 
153     /**
154      * Returns an output stream for this socket.
155      *
156      * @return     an output stream for writing to this socket.
<a name="18" id="anc18"></a><span class="line-modified">157      * @exception  IOException  if an I/O error occurs when creating the</span>
158      *               output stream.
159      */
160     protected abstract OutputStream getOutputStream() throws IOException;
161 
162     /**
163      * Returns the number of bytes that can be read from this socket
164      * without blocking.
165      *
166      * @return     the number of bytes that can be read from this socket
167      *             without blocking.
<a name="19" id="anc19"></a><span class="line-modified">168      * @exception  IOException  if an I/O error occurs when determining the</span>
169      *               number of bytes available.
170      */
171     protected abstract int available() throws IOException;
172 
173     /**
174      * Closes this socket.
175      *
<a name="20" id="anc20"></a><span class="line-modified">176      * @exception  IOException  if an I/O error occurs when closing this socket.</span>
177      */
178     protected abstract void close() throws IOException;
179 
<a name="21" id="anc21"></a>








180     /**
181      * Places the input stream for this socket at &quot;end of stream&quot;.
182      * Any data sent to this socket is acknowledged and then
183      * silently discarded.
184      *
185      * If you read from a socket input stream after invoking this method on the
186      * socket, the stream&#39;s {@code available} method will return 0, and its
187      * {@code read} methods will return {@code -1} (end of stream).
188      *
<a name="22" id="anc22"></a><span class="line-modified">189      * @exception IOException if an I/O error occurs when shutting down this</span>
190      * socket.
191      * @see java.net.Socket#shutdownOutput()
192      * @see java.net.Socket#close()
193      * @see java.net.Socket#setSoLinger(boolean, int)
194      * @since 1.3
195      */
196     protected void shutdownInput() throws IOException {
197       throw new IOException(&quot;Method not implemented!&quot;);
198     }
199 
200     /**
201      * Disables the output stream for this socket.
202      * For a TCP socket, any previously written data will be sent
203      * followed by TCP&#39;s normal connection termination sequence.
204      *
205      * If you write to a socket output stream after invoking
206      * shutdownOutput() on the socket, the stream will throw
207      * an IOException.
208      *
<a name="23" id="anc23"></a><span class="line-modified">209      * @exception IOException if an I/O error occurs when shutting down this</span>
210      * socket.
211      * @see java.net.Socket#shutdownInput()
212      * @see java.net.Socket#close()
213      * @see java.net.Socket#setSoLinger(boolean, int)
214      * @since 1.3
215      */
216     protected void shutdownOutput() throws IOException {
217       throw new IOException(&quot;Method not implemented!&quot;);
218     }
219 
220     /**
221      * Returns the value of this socket&#39;s {@code fd} field.
222      *
223      * @return  the value of this socket&#39;s {@code fd} field.
224      * @see     java.net.SocketImpl#fd
225      */
226     protected FileDescriptor getFileDescriptor() {
227         return fd;
228     }
229 
230     /**
231      * Returns the value of this socket&#39;s {@code address} field.
232      *
233      * @return  the value of this socket&#39;s {@code address} field.
234      * @see     java.net.SocketImpl#address
235      */
236     protected InetAddress getInetAddress() {
237         return address;
238     }
239 
240     /**
241      * Returns the value of this socket&#39;s {@code port} field.
242      *
243      * @return  the value of this socket&#39;s {@code port} field.
244      * @see     java.net.SocketImpl#port
245      */
246     protected int getPort() {
247         return port;
248     }
249 
250     /**
251      * Returns whether or not this SocketImpl supports sending
252      * urgent data. By default, false is returned
253      * unless the method is overridden in a sub-class
254      *
255      * @return  true if urgent data supported
256      * @see     java.net.SocketImpl#address
257      * @since 1.4
258      */
259     protected boolean supportsUrgentData () {
260         return false; // must be overridden in sub-class
261     }
262 
263     /**
264      * Send one byte of urgent data on the socket.
265      * The byte to be sent is the low eight bits of the parameter
266      * @param data The byte of data to send
<a name="24" id="anc24"></a><span class="line-modified">267      * @exception IOException if there is an error</span>
268      *  sending the data.
269      * @since 1.4
270      */
271     protected abstract void sendUrgentData (int data) throws IOException;
272 
273     /**
274      * Returns the value of this socket&#39;s {@code localport} field.
275      *
276      * @return  the value of this socket&#39;s {@code localport} field.
277      * @see     java.net.SocketImpl#localport
278      */
279     protected int getLocalPort() {
280         return localport;
281     }
282 
<a name="25" id="anc25"></a><span class="line-removed">283     void setSocket(Socket soc) {</span>
<span class="line-removed">284         this.socket = soc;</span>
<span class="line-removed">285     }</span>
<span class="line-removed">286 </span>
<span class="line-removed">287     Socket getSocket() {</span>
<span class="line-removed">288         return socket;</span>
<span class="line-removed">289     }</span>
<span class="line-removed">290 </span>
<span class="line-removed">291     void setServerSocket(ServerSocket soc) {</span>
<span class="line-removed">292         this.serverSocket = soc;</span>
<span class="line-removed">293     }</span>
<span class="line-removed">294 </span>
<span class="line-removed">295     ServerSocket getServerSocket() {</span>
<span class="line-removed">296         return serverSocket;</span>
<span class="line-removed">297     }</span>
<span class="line-removed">298 </span>
299     /**
300      * Returns the address and port of this socket as a {@code String}.
301      *
302      * @return  a string representation of this socket.
303      */
304     public String toString() {
305         return &quot;Socket[addr=&quot; + getInetAddress() +
306             &quot;,port=&quot; + getPort() + &quot;,localport=&quot; + getLocalPort()  + &quot;]&quot;;
307     }
308 
<a name="26" id="anc26"></a><span class="line-modified">309     void reset() throws IOException {</span>

310         address = null;
311         port = 0;
312         localport = 0;
313     }
314 
315     /**
316      * Sets performance preferences for this socket.
317      *
318      * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
319      * may offer alternative protocols which have different performance
320      * characteristics than TCP/IP.  This method allows the application to
321      * express its own preferences as to how these tradeoffs should be made
322      * when the implementation chooses from the available protocols.
323      *
324      * &lt;p&gt; Performance preferences are described by three integers
325      * whose values indicate the relative importance of short connection time,
326      * low latency, and high bandwidth.  The absolute values of the integers
327      * are irrelevant; in order to choose a protocol the values are simply
328      * compared, with larger values indicating stronger preferences. Negative
329      * values represent a lower priority than positive values. If the
330      * application prefers short connection time over both low latency and high
331      * bandwidth, for example, then it could invoke this method with the values
332      * {@code (1, 0, 0)}.  If the application prefers high bandwidth above low
333      * latency, and low latency above short connection time, then it could
334      * invoke this method with the values {@code (0, 1, 2)}.
335      *
336      * By default, this method does nothing, unless it is overridden in
337      * a sub-class.
338      *
339      * @param  connectionTime
340      *         An {@code int} expressing the relative importance of a short
341      *         connection time
342      *
343      * @param  latency
344      *         An {@code int} expressing the relative importance of low
345      *         latency
346      *
347      * @param  bandwidth
348      *         An {@code int} expressing the relative importance of high
349      *         bandwidth
350      *
351      * @since 1.5
352      */
353     protected void setPerformancePreferences(int connectionTime,
354                                           int latency,
355                                           int bandwidth)
356     {
357         /* Not implemented yet */
358     }
359 
360     /**
361      * Called to set a socket option.
362      *
<a name="27" id="anc27"></a>





363      * @param &lt;T&gt; The type of the socket option value
364      * @param name The socket option
<a name="28" id="anc28"></a><span class="line-removed">365      *</span>
366      * @param value The value of the socket option. A value of {@code null}
367      *              may be valid for some options.
368      *
369      * @throws UnsupportedOperationException if the SocketImpl does not
370      *         support the option
<a name="29" id="anc29"></a><span class="line-modified">371      *</span>
<span class="line-modified">372      * @throws IOException if an I/O error occurs, or if the socket is closed.</span>


373      *
374      * @since 9
375      */
376     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<a name="30" id="anc30"></a><span class="line-modified">377         if (name == StandardSocketOptions.SO_KEEPALIVE &amp;&amp;</span>
<span class="line-modified">378                 (getSocket() != null)) {</span>
<span class="line-removed">379             setOption(SocketOptions.SO_KEEPALIVE, value);</span>
<span class="line-removed">380         } else if (name == StandardSocketOptions.SO_SNDBUF &amp;&amp;</span>
<span class="line-removed">381                 (getSocket() != null)) {</span>
<span class="line-removed">382             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-removed">383         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-removed">384             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-removed">385         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-removed">386             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-removed">387         } else if (name == StandardSocketOptions.SO_REUSEPORT &amp;&amp;</span>
<span class="line-removed">388             supportedOptions().contains(name)) {</span>
<span class="line-removed">389             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-removed">390         } else if (name == StandardSocketOptions.SO_LINGER &amp;&amp;</span>
<span class="line-removed">391                 (getSocket() != null)) {</span>
<span class="line-removed">392             setOption(SocketOptions.SO_LINGER, value);</span>
<span class="line-removed">393         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-removed">394             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-removed">395         } else if (name == StandardSocketOptions.TCP_NODELAY &amp;&amp;</span>
<span class="line-removed">396                 (getSocket() != null)) {</span>
<span class="line-removed">397             setOption(SocketOptions.TCP_NODELAY, value);</span>
<span class="line-removed">398         } else {</span>
<span class="line-removed">399             throw new UnsupportedOperationException(&quot;unsupported option&quot;);</span>
<span class="line-removed">400         }</span>
401     }
402 
403     /**
404      * Called to get a socket option.
405      *
<a name="31" id="anc31"></a>





406      * @param &lt;T&gt; The type of the socket option value
407      * @param name The socket option
<a name="32" id="anc32"></a><span class="line-removed">408      *</span>
409      * @return the value of the named option
410      *
411      * @throws UnsupportedOperationException if the SocketImpl does not
<a name="33" id="anc33"></a><span class="line-modified">412      *         support the option.</span>
<span class="line-modified">413      *</span>
<span class="line-modified">414      * @throws IOException if an I/O error occurs, or if the socket is closed.</span>
415      *
416      * @since 9
417      */
<a name="34" id="anc34"></a><span class="line-removed">418     @SuppressWarnings(&quot;unchecked&quot;)</span>
419     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<a name="35" id="anc35"></a><span class="line-modified">420         if (name == StandardSocketOptions.SO_KEEPALIVE &amp;&amp;</span>
<span class="line-modified">421                 (getSocket() != null)) {</span>
<span class="line-removed">422             return (T)getOption(SocketOptions.SO_KEEPALIVE);</span>
<span class="line-removed">423         } else if (name == StandardSocketOptions.SO_SNDBUF &amp;&amp;</span>
<span class="line-removed">424                 (getSocket() != null)) {</span>
<span class="line-removed">425             return (T)getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-removed">426         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-removed">427             return (T)getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-removed">428         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-removed">429             return (T)getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-removed">430         } else if (name == StandardSocketOptions.SO_REUSEPORT &amp;&amp;</span>
<span class="line-removed">431             supportedOptions().contains(name)) {</span>
<span class="line-removed">432             return (T)getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-removed">433         } else if (name == StandardSocketOptions.SO_LINGER &amp;&amp;</span>
<span class="line-removed">434                 (getSocket() != null)) {</span>
<span class="line-removed">435             return (T)getOption(SocketOptions.SO_LINGER);</span>
<span class="line-removed">436         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-removed">437             return (T)getOption(SocketOptions.IP_TOS);</span>
<span class="line-removed">438         } else if (name == StandardSocketOptions.TCP_NODELAY &amp;&amp;</span>
<span class="line-removed">439                 (getSocket() != null)) {</span>
<span class="line-removed">440             return (T)getOption(SocketOptions.TCP_NODELAY);</span>
<span class="line-removed">441         } else {</span>
<span class="line-removed">442             throw new UnsupportedOperationException(&quot;unsupported option&quot;);</span>
<span class="line-removed">443         }</span>
444     }
445 
<a name="36" id="anc36"></a><span class="line-modified">446     private static final Set&lt;SocketOption&lt;?&gt;&gt; socketOptions;</span>
<span class="line-modified">447 </span>
<span class="line-modified">448     private static final Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions;</span>
<span class="line-modified">449 </span>
<span class="line-modified">450     static {</span>
<span class="line-modified">451         socketOptions = Set.of(StandardSocketOptions.SO_KEEPALIVE,</span>
<span class="line-modified">452                                StandardSocketOptions.SO_SNDBUF,</span>
<span class="line-modified">453                                StandardSocketOptions.SO_RCVBUF,</span>
<span class="line-modified">454                                StandardSocketOptions.SO_REUSEADDR,</span>
<span class="line-modified">455                                StandardSocketOptions.SO_LINGER,</span>
<span class="line-modified">456                                StandardSocketOptions.IP_TOS,</span>
<span class="line-removed">457                                StandardSocketOptions.TCP_NODELAY);</span>
<span class="line-removed">458 </span>
<span class="line-removed">459         serverSocketOptions = Set.of(StandardSocketOptions.SO_RCVBUF,</span>
<span class="line-removed">460                                      StandardSocketOptions.SO_REUSEADDR,</span>
<span class="line-removed">461                                      StandardSocketOptions.IP_TOS);</span>
462     }
463 
464     /**
465      * Returns a set of SocketOptions supported by this impl
466      * and by this impl&#39;s socket (Socket or ServerSocket)
467      *
<a name="37" id="anc37"></a>



468      * @return a Set of SocketOptions
469      *
470      * @since 9
471      */
472     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<a name="38" id="anc38"></a><span class="line-modified">473         if (getSocket() != null) {</span>
<span class="line-removed">474             return socketOptions;</span>
<span class="line-removed">475         } else {</span>
<span class="line-removed">476             return serverSocketOptions;</span>
<span class="line-removed">477         }</span>
478     }
479 }
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
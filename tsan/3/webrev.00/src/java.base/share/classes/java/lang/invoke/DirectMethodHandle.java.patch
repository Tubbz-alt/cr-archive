diff a/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java b/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java
@@ -304,25 +304,27 @@
             lform.compileToBytecode();
     }
 
     /** Static wrapper for DirectMethodHandle.internalMemberName. */
     @ForceInline
-    /*non-public*/ static Object internalMemberName(Object mh) {
+    /*non-public*/
+    static Object internalMemberName(Object mh) {
         return ((DirectMethodHandle)mh).member;
     }
 
     /** Static wrapper for DirectMethodHandle.internalMemberName.
      * This one also forces initialization.
      */
-    /*non-public*/ static Object internalMemberNameEnsureInit(Object mh) {
+    /*non-public*/
+    static Object internalMemberNameEnsureInit(Object mh) {
         DirectMethodHandle dmh = (DirectMethodHandle)mh;
         dmh.ensureInitialized();
         return dmh.member;
     }
 
-    /*non-public*/ static
-    boolean shouldBeInitialized(MemberName member) {
+    /*non-public*/
+    static boolean shouldBeInitialized(MemberName member) {
         switch (member.getReferenceKind()) {
         case REF_invokeStatic:
         case REF_getStatic:
         case REF_putStatic:
         case REF_newInvokeSpecial:
@@ -394,11 +396,12 @@
         // put it into the final state
         EnsureInitialized.INSTANCE.remove(defc);
         return true;
     }
 
-    /*non-public*/ static void ensureInitialized(Object mh) {
+    /*non-public*/
+    static void ensureInitialized(Object mh) {
         ((DirectMethodHandle)mh).ensureInitialized();
     }
 
     /** This subclass represents invokespecial instructions. */
     static class Special extends DirectMethodHandle {
@@ -470,16 +473,18 @@
         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
             return new Constructor(mt, lf, member, initMethod, instanceClass);
         }
     }
 
-    /*non-public*/ static Object constructorMethod(Object mh) {
+    /*non-public*/
+    static Object constructorMethod(Object mh) {
         Constructor dmh = (Constructor)mh;
         return dmh.initMethod;
     }
 
-    /*non-public*/ static Object allocateInstance(Object mh) throws InstantiationException {
+    /*non-public*/
+    static Object allocateInstance(Object mh) throws InstantiationException {
         Constructor dmh = (Constructor)mh;
         return UNSAFE.allocateInstance(dmh.instanceClass);
     }
 
     /** This subclass handles non-static field references. */
@@ -501,18 +506,20 @@
             return new Accessor(mt, lf, member, fieldOffset);
         }
     }
 
     @ForceInline
-    /*non-public*/ static long fieldOffset(Object accessorObj) {
+    /*non-public*/
+    static long fieldOffset(Object accessorObj) {
         // Note: We return a long because that is what Unsafe.getObject likes.
         // We store a plain int because it is more compact.
         return ((Accessor)accessorObj).fieldOffset;
     }
 
     @ForceInline
-    /*non-public*/ static Object checkBase(Object obj) {
+    /*non-public*/
+    static Object checkBase(Object obj) {
         // Note that the object's class has already been verified,
         // since the parameter type of the Accessor method handle
         // is either member.getDeclaringClass or a subclass.
         // This was verified in DirectMethodHandle.make.
         // Therefore, the only remaining check is for null.
@@ -543,26 +550,30 @@
             return new StaticAccessor(mt, lf, member, staticBase, staticOffset);
         }
     }
 
     @ForceInline
-    /*non-public*/ static Object nullCheck(Object obj) {
+    /*non-public*/
+    static Object nullCheck(Object obj) {
         return Objects.requireNonNull(obj);
     }
 
     @ForceInline
-    /*non-public*/ static Object staticBase(Object accessorObj) {
+    /*non-public*/
+    static Object staticBase(Object accessorObj) {
         return ((StaticAccessor)accessorObj).staticBase;
     }
 
     @ForceInline
-    /*non-public*/ static long staticOffset(Object accessorObj) {
+    /*non-public*/
+    static long staticOffset(Object accessorObj) {
         return ((StaticAccessor)accessorObj).staticOffset;
     }
 
     @ForceInline
-    /*non-public*/ static Object checkCast(Object mh, Object obj) {
+    /*non-public*/
+    static Object checkCast(Object mh, Object obj) {
         return ((DirectMethodHandle) mh).checkCast(obj);
     }
 
     Object checkCast(Object obj) {
         return member.getReturnType().cast(obj);

diff a/src/java.base/share/classes/java/lang/ref/Reference.java b/src/java.base/share/classes/java/lang/ref/Reference.java
--- a/src/java.base/share/classes/java/lang/ref/Reference.java
+++ b/src/java.base/share/classes/java/lang/ref/Reference.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -321,14 +321,14 @@
     /* -- Referent accessor and setters -- */
 
     /**
      * Returns this reference object's referent.  If this reference object has
      * been cleared, either by the program or by the garbage collector, then
-     * this method returns <code>null</code>.
+     * this method returns {@code null}.
      *
      * @return   The object to which this reference refers, or
-     *           <code>null</code> if this reference object has been cleared
+     *           {@code null} if this reference object has been cleared
      */
     @HotSpotIntrinsicCandidate
     public T get() {
         return this.referent;
     }
@@ -348,13 +348,13 @@
 
     /**
      * Tells whether or not this reference object has been enqueued, either by
      * the program or by the garbage collector.  If this reference object was
      * not registered with a queue when it was created, then this method will
-     * always return <code>false</code>.
+     * always return {@code false}.
      *
-     * @return   <code>true</code> if and only if this reference object has
+     * @return   {@code true} if and only if this reference object has
      *           been enqueued
      */
     public boolean isEnqueued() {
         return (this.queue == ReferenceQueue.ENQUEUED);
     }
@@ -364,12 +364,12 @@
      * it is registered, if any.
      *
      * <p> This method is invoked only by Java code; when the garbage collector
      * enqueues references it does so directly, without invoking this method.
      *
-     * @return   <code>true</code> if this reference object was successfully
-     *           enqueued; <code>false</code> if it was already enqueued or if
+     * @return   {@code true} if this reference object was successfully
+     *           enqueued; {@code false} if it was already enqueued or if
      *           it was not registered with a queue when it was created
      */
     public boolean enqueue() {
         this.referent = null;
         return this.queue.enqueue(this);
@@ -416,14 +416,14 @@
      * triggering garbage collection.  This method is designed for use in
      * uncommon situations of premature finalization where using
      * {@code synchronized} blocks or methods, or using other synchronization
      * facilities are not possible or do not provide the desired control.  This
      * method is applicable only when reclamation may have visible effects,
-     * which is possible for objects with finalizers (See
-     * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6">
-     * Section 12.6 17 of <cite>The Java&trade; Language Specification</cite></a>)
-     * that are implemented in ways that rely on ordering control for correctness.
+     * which is possible for objects with finalizers (See Section 12.6
+     * of <cite>The Java&trade; Language Specification</cite>) that
+     * are implemented in ways that rely on ordering control for
+     * correctness.
      *
      * @apiNote
      * Finalization may occur whenever the virtual machine detects that no
      * reference to an object will ever be stored in the heap: The garbage
      * collector may reclaim an object even if the fields of that object are
@@ -506,10 +506,11 @@
      * remains a better option in cases where this approach is not as efficient,
      * desirable, or possible; for example because it would encounter deadlock.
      *
      * @param ref the reference. If {@code null}, this method has no effect.
      * @since 9
+     * @jls 12.6 Finalization of Class Instances
      */
     @ForceInline
     public static void reachabilityFence(Object ref) {
         // Does nothing. This method is annotated with @ForceInline to eliminate
         // most of the overhead that using @DontInline would cause with the

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/ArrayBlockingQueue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Vector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CompletableFuture.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/ArrayBlockingQueue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  83  * @author Doug Lea
  84  * @param &lt;E&gt; the type of elements held in this queue
  85  */
  86 public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
  87         implements BlockingQueue&lt;E&gt;, java.io.Serializable {
  88 
  89     /*
  90      * Much of the implementation mechanics, especially the unusual
  91      * nested loops, are shared and co-maintained with ArrayDeque.
  92      */
  93 
  94     /**
  95      * Serialization ID. This class relies on default serialization
  96      * even for the items array, which is default-serialized, even if
  97      * it is empty. Otherwise it could not be declared final, which is
  98      * necessary here.
  99      */
 100     private static final long serialVersionUID = -817911632652898426L;
 101 
 102     /** The queued items */

 103     final Object[] items;
 104 
 105     /** items index for next take, poll, peek or remove */
 106     int takeIndex;
 107 
 108     /** items index for next put, offer, or add */
 109     int putIndex;
 110 
 111     /** Number of elements in the queue */
 112     int count;
 113 
 114     /*
 115      * Concurrency control uses the classic two-condition algorithm
 116      * found in any textbook.
 117      */
 118 
 119     /** Main lock guarding all access */
 120     final ReentrantLock lock;
 121 
 122     /** Condition for waiting takes */

 123     private final Condition notEmpty;
 124 
 125     /** Condition for waiting puts */

 126     private final Condition notFull;
 127 
 128     /**
 129      * Shared state for currently active iterators, or null if there
 130      * are known not to be any.  Allows queue operations to update
 131      * iterator state.
 132      */
 133     transient Itrs itrs;
 134 
 135     // Internal helper methods
 136 
 137     /**
 138      * Increments i, mod modulus.
 139      * Precondition and postcondition: 0 &lt;= i &lt; modulus.
 140      */
 141     static final int inc(int i, int modulus) {
 142         if (++i &gt;= modulus) i = 0;
 143         return i;
 144     }
 145 
</pre>
</td>
<td>
<hr />
<pre>
  83  * @author Doug Lea
  84  * @param &lt;E&gt; the type of elements held in this queue
  85  */
  86 public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
  87         implements BlockingQueue&lt;E&gt;, java.io.Serializable {
  88 
  89     /*
  90      * Much of the implementation mechanics, especially the unusual
  91      * nested loops, are shared and co-maintained with ArrayDeque.
  92      */
  93 
  94     /**
  95      * Serialization ID. This class relies on default serialization
  96      * even for the items array, which is default-serialized, even if
  97      * it is empty. Otherwise it could not be declared final, which is
  98      * necessary here.
  99      */
 100     private static final long serialVersionUID = -817911632652898426L;
 101 
 102     /** The queued items */
<span class="line-added"> 103     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
 104     final Object[] items;
 105 
 106     /** items index for next take, poll, peek or remove */
 107     int takeIndex;
 108 
 109     /** items index for next put, offer, or add */
 110     int putIndex;
 111 
 112     /** Number of elements in the queue */
 113     int count;
 114 
 115     /*
 116      * Concurrency control uses the classic two-condition algorithm
 117      * found in any textbook.
 118      */
 119 
 120     /** Main lock guarding all access */
 121     final ReentrantLock lock;
 122 
 123     /** Condition for waiting takes */
<span class="line-added"> 124     @SuppressWarnings(&quot;serial&quot;)  // Classes implementing Condition may be serializable.</span>
 125     private final Condition notEmpty;
 126 
 127     /** Condition for waiting puts */
<span class="line-added"> 128     @SuppressWarnings(&quot;serial&quot;)  // Classes implementing Condition may be serializable.</span>
 129     private final Condition notFull;
 130 
 131     /**
 132      * Shared state for currently active iterators, or null if there
 133      * are known not to be any.  Allows queue operations to update
 134      * iterator state.
 135      */
 136     transient Itrs itrs;
 137 
 138     // Internal helper methods
 139 
 140     /**
 141      * Increments i, mod modulus.
 142      * Precondition and postcondition: 0 &lt;= i &lt; modulus.
 143      */
 144     static final int inc(int i, int modulus) {
 145         if (++i &gt;= modulus) i = 0;
 146         return i;
 147     }
 148 
</pre>
</td>
</tr>
</table>
<center><a href="../Vector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CompletableFuture.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
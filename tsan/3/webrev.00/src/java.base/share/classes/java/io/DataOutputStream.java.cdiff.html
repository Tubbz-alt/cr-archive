<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/DataOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DataOutput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EOFException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/DataOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,12 ***</span>
   *
   * @author  unascribed
   * @see     java.io.DataInputStream
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class DataOutputStream extends FilterOutputStream implements DataOutput {</span>
      /**
       * The number of bytes written to the data output stream so far.
       * If this counter overflows, it will be wrapped to Integer.MAX_VALUE.
       */
      protected int written;
<span class="line-new-header">--- 32,11 ---</span>
   *
   * @author  unascribed
   * @see     java.io.DataInputStream
   * @since   1.0
   */
<span class="line-modified">! public class DataOutputStream extends FilterOutputStream implements DataOutput {</span>
      /**
       * The number of bytes written to the data output stream so far.
       * If this counter overflows, it will be wrapped to Integer.MAX_VALUE.
       */
      protected int written;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 47,11 ***</span>
       */
      private byte[] bytearr = null;
  
      /**
       * Creates a new data output stream to write data to the specified
<span class="line-modified">!      * underlying output stream. The counter &lt;code&gt;written&lt;/code&gt; is</span>
       * set to zero.
       *
       * @param   out   the underlying output stream, to be saved for later
       *                use.
       * @see     java.io.FilterOutputStream#out
<span class="line-new-header">--- 46,11 ---</span>
       */
      private byte[] bytearr = null;
  
      /**
       * Creates a new data output stream to write data to the specified
<span class="line-modified">!      * underlying output stream. The counter {@code written} is</span>
       * set to zero.
       *
       * @param   out   the underlying output stream, to be saved for later
       *                use.
       * @see     java.io.FilterOutputStream#out
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,35 ***</span>
          written = temp;
      }
  
      /**
       * Writes the specified byte (the low eight bits of the argument
<span class="line-modified">!      * &lt;code&gt;b&lt;/code&gt;) to the underlying output stream. If no exception</span>
<span class="line-modified">!      * is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by</span>
<span class="line-modified">!      * &lt;code&gt;1&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      b   the &lt;code&gt;byte&lt;/code&gt; to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public synchronized void write(int b) throws IOException {
          out.write(b);
          incCount(1);
      }
  
      /**
<span class="line-modified">!      * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array</span>
<span class="line-modified">!      * starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream.</span>
<span class="line-modified">!      * If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is</span>
<span class="line-modified">!      * incremented by &lt;code&gt;len&lt;/code&gt;.</span>
       *
       * @param      b     the data.
       * @param      off   the start offset in the data.
       * @param      len   the number of bytes to write.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public synchronized void write(byte b[], int off, int len)
          throws IOException
      {
<span class="line-new-header">--- 71,35 ---</span>
          written = temp;
      }
  
      /**
       * Writes the specified byte (the low eight bits of the argument
<span class="line-modified">!      * {@code b}) to the underlying output stream. If no exception</span>
<span class="line-modified">!      * is thrown, the counter {@code written} is incremented by</span>
<span class="line-modified">!      * {@code 1}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * Implements the {@code write} method of {@code OutputStream}.</span>
       *
<span class="line-modified">!      * @param      b   the {@code byte} to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public synchronized void write(int b) throws IOException {
          out.write(b);
          incCount(1);
      }
  
      /**
<span class="line-modified">!      * Writes {@code len} bytes from the specified byte array</span>
<span class="line-modified">!      * starting at offset {@code off} to the underlying output stream.</span>
<span class="line-modified">!      * If no exception is thrown, the counter {@code written} is</span>
<span class="line-modified">!      * incremented by {@code len}.</span>
       *
       * @param      b     the data.
       * @param      off   the start offset in the data.
       * @param      len   the number of bytes to write.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public synchronized void write(byte b[], int off, int len)
          throws IOException
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,89 ***</span>
  
      /**
       * Flushes this data output stream. This forces any buffered output
       * bytes to be written out to the stream.
       * &lt;p&gt;
<span class="line-modified">!      * The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;DataOutputStream&lt;/code&gt;</span>
<span class="line-modified">!      * calls the &lt;code&gt;flush&lt;/code&gt; method of its underlying output stream.</span>
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       * @see        java.io.OutputStream#flush()
       */
      public void flush() throws IOException {
          out.flush();
      }
  
      /**
<span class="line-modified">!      * Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as</span>
<span class="line-modified">!      * a 1-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the</span>
<span class="line-modified">!      * value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is</span>
<span class="line-modified">!      * written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. If no exception is</span>
<span class="line-modified">!      * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by</span>
<span class="line-modified">!      * &lt;code&gt;1&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;boolean&lt;/code&gt; value to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeBoolean(boolean v) throws IOException {
          out.write(v ? 1 : 0);
          incCount(1);
      }
  
      /**
<span class="line-modified">!      * Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as</span>
       * a 1-byte value. If no exception is thrown, the counter
<span class="line-modified">!      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;byte&lt;/code&gt; value to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeByte(int v) throws IOException {
          out.write(v);
          incCount(1);
      }
  
      /**
<span class="line-modified">!      * Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two</span>
       * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">!      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;short&lt;/code&gt; to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeShort(int v) throws IOException {
          out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          incCount(2);
      }
  
      /**
<span class="line-modified">!      * Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a</span>
       * 2-byte value, high byte first. If no exception is thrown, the
<span class="line-modified">!      * counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;char&lt;/code&gt; value to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeChar(int v) throws IOException {
          out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          incCount(2);
      }
  
      /**
<span class="line-modified">!      * Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four</span>
       * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">!      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;4&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   an &lt;code&gt;int&lt;/code&gt; to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeInt(int v) throws IOException {
          out.write((v &gt;&gt;&gt; 24) &amp; 0xFF);
          out.write((v &gt;&gt;&gt; 16) &amp; 0xFF);
<span class="line-new-header">--- 109,89 ---</span>
  
      /**
       * Flushes this data output stream. This forces any buffered output
       * bytes to be written out to the stream.
       * &lt;p&gt;
<span class="line-modified">!      * The {@code flush} method of {@code DataOutputStream}</span>
<span class="line-modified">!      * calls the {@code flush} method of its underlying output stream.</span>
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       * @see        java.io.OutputStream#flush()
       */
      public void flush() throws IOException {
          out.flush();
      }
  
      /**
<span class="line-modified">!      * Writes a {@code boolean} to the underlying output stream as</span>
<span class="line-modified">!      * a 1-byte value. The value {@code true} is written out as the</span>
<span class="line-modified">!      * value {@code (byte)1}; the value {@code false} is</span>
<span class="line-modified">!      * written out as the value {@code (byte)0}. If no exception is</span>
<span class="line-modified">!      * thrown, the counter {@code written} is incremented by</span>
<span class="line-modified">!      * {@code 1}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code boolean} value to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeBoolean(boolean v) throws IOException {
          out.write(v ? 1 : 0);
          incCount(1);
      }
  
      /**
<span class="line-modified">!      * Writes out a {@code byte} to the underlying output stream as</span>
       * a 1-byte value. If no exception is thrown, the counter
<span class="line-modified">!      * {@code written} is incremented by {@code 1}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code byte} value to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeByte(int v) throws IOException {
          out.write(v);
          incCount(1);
      }
  
      /**
<span class="line-modified">!      * Writes a {@code short} to the underlying output stream as two</span>
       * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">!      * {@code written} is incremented by {@code 2}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code short} to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeShort(int v) throws IOException {
          out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          incCount(2);
      }
  
      /**
<span class="line-modified">!      * Writes a {@code char} to the underlying output stream as a</span>
       * 2-byte value, high byte first. If no exception is thrown, the
<span class="line-modified">!      * counter {@code written} is incremented by {@code 2}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code char} value to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeChar(int v) throws IOException {
          out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          incCount(2);
      }
  
      /**
<span class="line-modified">!      * Writes an {@code int} to the underlying output stream as four</span>
       * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">!      * {@code written} is incremented by {@code 4}.</span>
       *
<span class="line-modified">!      * @param      v   an {@code int} to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeInt(int v) throws IOException {
          out.write((v &gt;&gt;&gt; 24) &amp; 0xFF);
          out.write((v &gt;&gt;&gt; 16) &amp; 0xFF);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,16 ***</span>
      }
  
      private byte writeBuffer[] = new byte[8];
  
      /**
<span class="line-modified">!      * Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight</span>
       * bytes, high byte first. In no exception is thrown, the counter
<span class="line-modified">!      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;8&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;long&lt;/code&gt; to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeLong(long v) throws IOException {
          writeBuffer[0] = (byte)(v &gt;&gt;&gt; 56);
          writeBuffer[1] = (byte)(v &gt;&gt;&gt; 48);
<span class="line-new-header">--- 201,16 ---</span>
      }
  
      private byte writeBuffer[] = new byte[8];
  
      /**
<span class="line-modified">!      * Writes a {@code long} to the underlying output stream as eight</span>
       * bytes, high byte first. In no exception is thrown, the counter
<span class="line-modified">!      * {@code written} is incremented by {@code 8}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code long} to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeLong(long v) throws IOException {
          writeBuffer[0] = (byte)(v &gt;&gt;&gt; 56);
          writeBuffer[1] = (byte)(v &gt;&gt;&gt; 48);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,36 ***</span>
          out.write(writeBuffer, 0, 8);
          incCount(8);
      }
  
      /**
<span class="line-modified">!      * Converts the float argument to an &lt;code&gt;int&lt;/code&gt; using the</span>
<span class="line-modified">!      * &lt;code&gt;floatToIntBits&lt;/code&gt; method in class &lt;code&gt;Float&lt;/code&gt;,</span>
<span class="line-modified">!      * and then writes that &lt;code&gt;int&lt;/code&gt; value to the underlying</span>
       * output stream as a 4-byte quantity, high byte first. If no
<span class="line-modified">!      * exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is</span>
<span class="line-modified">!      * incremented by &lt;code&gt;4&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;float&lt;/code&gt; value to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       * @see        java.lang.Float#floatToIntBits(float)
       */
      public final void writeFloat(float v) throws IOException {
          writeInt(Float.floatToIntBits(v));
      }
  
      /**
<span class="line-modified">!      * Converts the double argument to a &lt;code&gt;long&lt;/code&gt; using the</span>
<span class="line-modified">!      * &lt;code&gt;doubleToLongBits&lt;/code&gt; method in class &lt;code&gt;Double&lt;/code&gt;,</span>
<span class="line-modified">!      * and then writes that &lt;code&gt;long&lt;/code&gt; value to the underlying</span>
       * output stream as an 8-byte quantity, high byte first. If no
<span class="line-modified">!      * exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is</span>
<span class="line-modified">!      * incremented by &lt;code&gt;8&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      v   a &lt;code&gt;double&lt;/code&gt; value to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       * @see        java.lang.Double#doubleToLongBits(double)
       */
      public final void writeDouble(double v) throws IOException {
          writeLong(Double.doubleToLongBits(v));
<span class="line-new-header">--- 223,36 ---</span>
          out.write(writeBuffer, 0, 8);
          incCount(8);
      }
  
      /**
<span class="line-modified">!      * Converts the float argument to an {@code int} using the</span>
<span class="line-modified">!      * {@code floatToIntBits} method in class {@code Float},</span>
<span class="line-modified">!      * and then writes that {@code int} value to the underlying</span>
       * output stream as a 4-byte quantity, high byte first. If no
<span class="line-modified">!      * exception is thrown, the counter {@code written} is</span>
<span class="line-modified">!      * incremented by {@code 4}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code float} value to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       * @see        java.lang.Float#floatToIntBits(float)
       */
      public final void writeFloat(float v) throws IOException {
          writeInt(Float.floatToIntBits(v));
      }
  
      /**
<span class="line-modified">!      * Converts the double argument to a {@code long} using the</span>
<span class="line-modified">!      * {@code doubleToLongBits} method in class {@code Double},</span>
<span class="line-modified">!      * and then writes that {@code long} value to the underlying</span>
       * output stream as an 8-byte quantity, high byte first. If no
<span class="line-modified">!      * exception is thrown, the counter {@code written} is</span>
<span class="line-modified">!      * incremented by {@code 8}.</span>
       *
<span class="line-modified">!      * @param      v   a {@code double} value to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       * @see        java.lang.Double#doubleToLongBits(double)
       */
      public final void writeDouble(double v) throws IOException {
          writeLong(Double.doubleToLongBits(v));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,15 ***</span>
  
      /**
       * Writes out the string to the underlying output stream as a
       * sequence of bytes. Each character in the string is written out, in
       * sequence, by discarding its high eight bits. If no exception is
<span class="line-modified">!      * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by the</span>
<span class="line-modified">!      * length of &lt;code&gt;s&lt;/code&gt;.</span>
       *
       * @param      s   a string of bytes to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeBytes(String s) throws IOException {
          int len = s.length();
          for (int i = 0 ; i &lt; len ; i++) {
<span class="line-new-header">--- 260,15 ---</span>
  
      /**
       * Writes out the string to the underlying output stream as a
       * sequence of bytes. Each character in the string is written out, in
       * sequence, by discarding its high eight bits. If no exception is
<span class="line-modified">!      * thrown, the counter {@code written} is incremented by the</span>
<span class="line-modified">!      * length of {@code s}.</span>
       *
       * @param      s   a string of bytes to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeBytes(String s) throws IOException {
          int len = s.length();
          for (int i = 0 ; i &lt; len ; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,16 ***</span>
      }
  
      /**
       * Writes a string to the underlying output stream as a sequence of
       * characters. Each character is written to the data output stream as
<span class="line-modified">!      * if by the &lt;code&gt;writeChar&lt;/code&gt; method. If no exception is</span>
<span class="line-modified">!      * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by twice</span>
<span class="line-modified">!      * the length of &lt;code&gt;s&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @param      s   a &lt;code&gt;String&lt;/code&gt; value to be written.</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.DataOutputStream#writeChar(int)
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeChars(String s) throws IOException {
          int len = s.length();
<span class="line-new-header">--- 278,16 ---</span>
      }
  
      /**
       * Writes a string to the underlying output stream as a sequence of
       * characters. Each character is written to the data output stream as
<span class="line-modified">!      * if by the {@code writeChar} method. If no exception is</span>
<span class="line-modified">!      * thrown, the counter {@code written} is incremented by twice</span>
<span class="line-modified">!      * the length of {@code s}.</span>
       *
<span class="line-modified">!      * @param      s   a {@code String} value to be written.</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.DataOutputStream#writeChar(int)
       * @see        java.io.FilterOutputStream#out
       */
      public final void writeChars(String s) throws IOException {
          int len = s.length();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,112 ***</span>
       * Writes a string to the underlying output stream using
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
       * encoding in a machine-independent manner.
       * &lt;p&gt;
       * First, two bytes are written to the output stream as if by the
<span class="line-modified">!      * &lt;code&gt;writeShort&lt;/code&gt; method giving the number of bytes to</span>
       * follow. This value is the number of bytes actually written out,
       * not the length of the string. Following the length, each character
       * of the string is output, in sequence, using the modified UTF-8 encoding
       * for the character. If no exception is thrown, the counter
<span class="line-modified">!      * &lt;code&gt;written&lt;/code&gt; is incremented by the total number of</span>
       * bytes written to the output stream. This will be at least two
<span class="line-modified">!      * plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus</span>
<span class="line-modified">!      * thrice the length of &lt;code&gt;str&lt;/code&gt;.</span>
       *
       * @param      str   a string to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeUTF(String str) throws IOException {
          writeUTF(str, this);
      }
  
      /**
       * Writes a string to the specified DataOutput using
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
       * encoding in a machine-independent manner.
       * &lt;p&gt;
<span class="line-modified">!      * First, two bytes are written to out as if by the &lt;code&gt;writeShort&lt;/code&gt;</span>
       * method giving the number of bytes to follow. This value is the number of
       * bytes actually written out, not the length of the string. Following the
       * length, each character of the string is output, in sequence, using the
       * modified UTF-8 encoding for the character. If no exception is thrown, the
<span class="line-modified">!      * counter &lt;code&gt;written&lt;/code&gt; is incremented by the total number of</span>
       * bytes written to the output stream. This will be at least two
<span class="line-modified">!      * plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus</span>
<span class="line-modified">!      * thrice the length of &lt;code&gt;str&lt;/code&gt;.</span>
       *
       * @param      str   a string to be written.
       * @param      out   destination to write to
       * @return     The number of bytes written out.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      static int writeUTF(String str, DataOutput out) throws IOException {
<span class="line-modified">!         int strlen = str.length();</span>
<span class="line-modified">!         int utflen = 0;</span>
<span class="line-removed">-         int c, count = 0;</span>
  
<span class="line-removed">-         /* use charAt instead of copying String to char array */</span>
          for (int i = 0; i &lt; strlen; i++) {
<span class="line-modified">!             c = str.charAt(i);</span>
<span class="line-modified">!             if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) {</span>
<span class="line-modified">!                 utflen++;</span>
<span class="line-removed">-             } else if (c &gt; 0x07FF) {</span>
<span class="line-removed">-                 utflen += 3;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 utflen += 2;</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         if (utflen &gt; 65535)</span>
<span class="line-modified">!             throw new UTFDataFormatException(</span>
<span class="line-removed">-                 &quot;encoded string too long: &quot; + utflen + &quot; bytes&quot;);</span>
  
<span class="line-modified">!         byte[] bytearr = null;</span>
          if (out instanceof DataOutputStream) {
              DataOutputStream dos = (DataOutputStream)out;
<span class="line-modified">!             if(dos.bytearr == null || (dos.bytearr.length &lt; (utflen+2)))</span>
                  dos.bytearr = new byte[(utflen*2) + 2];
              bytearr = dos.bytearr;
          } else {
<span class="line-modified">!             bytearr = new byte[utflen+2];</span>
          }
  
          bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 8) &amp; 0xFF);
          bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 0) &amp; 0xFF);
  
<span class="line-modified">!         int i=0;</span>
<span class="line-modified">!         for (i=0; i&lt;strlen; i++) {</span>
<span class="line-modified">!            c = str.charAt(i);</span>
<span class="line-modified">!            if (!((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F))) break;</span>
<span class="line-modified">!            bytearr[count++] = (byte) c;</span>
          }
  
<span class="line-modified">!         for (;i &lt; strlen; i++){</span>
<span class="line-modified">!             c = str.charAt(i);</span>
<span class="line-modified">!             if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) {</span>
                  bytearr[count++] = (byte) c;
<span class="line-modified">! </span>
<span class="line-removed">-             } else if (c &gt; 0x07FF) {</span>
                  bytearr[count++] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
                  bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  6) &amp; 0x3F));
                  bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
              } else {
                  bytearr[count++] = (byte) (0xC0 | ((c &gt;&gt;  6) &amp; 0x1F));
                  bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
              }
          }
<span class="line-modified">!         out.write(bytearr, 0, utflen+2);</span>
          return utflen + 2;
      }
  
      /**
<span class="line-modified">!      * Returns the current value of the counter &lt;code&gt;written&lt;/code&gt;,</span>
       * the number of bytes written to this data output stream so far.
       * If the counter overflows, it will be wrapped to Integer.MAX_VALUE.
       *
<span class="line-modified">!      * @return  the value of the &lt;code&gt;written&lt;/code&gt; field.</span>
       * @see     java.io.DataOutputStream#written
       */
      public final int size() {
          return written;
      }
<span class="line-new-header">--- 303,119 ---</span>
       * Writes a string to the underlying output stream using
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
       * encoding in a machine-independent manner.
       * &lt;p&gt;
       * First, two bytes are written to the output stream as if by the
<span class="line-modified">!      * {@code writeShort} method giving the number of bytes to</span>
       * follow. This value is the number of bytes actually written out,
       * not the length of the string. Following the length, each character
       * of the string is output, in sequence, using the modified UTF-8 encoding
       * for the character. If no exception is thrown, the counter
<span class="line-modified">!      * {@code written} is incremented by the total number of</span>
       * bytes written to the output stream. This will be at least two
<span class="line-modified">!      * plus the length of {@code str}, and at most two plus</span>
<span class="line-modified">!      * thrice the length of {@code str}.</span>
       *
       * @param      str   a string to be written.
<span class="line-modified">!      * @throws     UTFDataFormatException  if the modified UTF-8 encoding of</span>
<span class="line-added">+      *             {@code str} would exceed 65535 bytes in length</span>
<span class="line-added">+      * @throws     IOException  if some other I/O error occurs.</span>
<span class="line-added">+      * @see        #writeChars(String)</span>
       */
      public final void writeUTF(String str) throws IOException {
          writeUTF(str, this);
      }
  
      /**
       * Writes a string to the specified DataOutput using
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
       * encoding in a machine-independent manner.
       * &lt;p&gt;
<span class="line-modified">!      * First, two bytes are written to out as if by the {@code writeShort}</span>
       * method giving the number of bytes to follow. This value is the number of
       * bytes actually written out, not the length of the string. Following the
       * length, each character of the string is output, in sequence, using the
       * modified UTF-8 encoding for the character. If no exception is thrown, the
<span class="line-modified">!      * counter {@code written} is incremented by the total number of</span>
       * bytes written to the output stream. This will be at least two
<span class="line-modified">!      * plus the length of {@code str}, and at most two plus</span>
<span class="line-modified">!      * thrice the length of {@code str}.</span>
       *
       * @param      str   a string to be written.
       * @param      out   destination to write to
       * @return     The number of bytes written out.
<span class="line-modified">!      * @throws     UTFDataFormatException  if the modified UTF-8 encoding of</span>
<span class="line-added">+      *             {@code str} would exceed 65535 bytes in length</span>
<span class="line-added">+      * @throws     IOException  if some other I/O error occurs.</span>
       */
      static int writeUTF(String str, DataOutput out) throws IOException {
<span class="line-modified">!         final int strlen = str.length();</span>
<span class="line-modified">!         int utflen = strlen; // optimized for ASCII</span>
  
          for (int i = 0; i &lt; strlen; i++) {
<span class="line-modified">!             int c = str.charAt(i);</span>
<span class="line-modified">!             if (c &gt;= 0x80 || c == 0)</span>
<span class="line-modified">!                 utflen += (c &gt;= 0x800) ? 2 : 1;</span>
          }
  
<span class="line-modified">!         if (utflen &gt; 65535 || /* overflow */ utflen &lt; strlen)</span>
<span class="line-modified">!             throw new UTFDataFormatException(tooLongMsg(str, utflen));</span>
  
<span class="line-modified">!         final byte[] bytearr;</span>
          if (out instanceof DataOutputStream) {
              DataOutputStream dos = (DataOutputStream)out;
<span class="line-modified">!             if (dos.bytearr == null || (dos.bytearr.length &lt; (utflen + 2)))</span>
                  dos.bytearr = new byte[(utflen*2) + 2];
              bytearr = dos.bytearr;
          } else {
<span class="line-modified">!             bytearr = new byte[utflen + 2];</span>
          }
  
<span class="line-added">+         int count = 0;</span>
          bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 8) &amp; 0xFF);
          bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 0) &amp; 0xFF);
  
<span class="line-modified">!         int i = 0;</span>
<span class="line-modified">!         for (i = 0; i &lt; strlen; i++) { // optimized for initial run of ASCII</span>
<span class="line-modified">!             int c = str.charAt(i);</span>
<span class="line-modified">!             if (c &gt;= 0x80 || c == 0) break;</span>
<span class="line-modified">!             bytearr[count++] = (byte) c;</span>
          }
  
<span class="line-modified">!         for (; i &lt; strlen; i++) {</span>
<span class="line-modified">!             int c = str.charAt(i);</span>
<span class="line-modified">!             if (c &lt; 0x80 &amp;&amp; c != 0) {</span>
                  bytearr[count++] = (byte) c;
<span class="line-modified">!             } else if (c &gt;= 0x800) {</span>
                  bytearr[count++] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
                  bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  6) &amp; 0x3F));
                  bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
              } else {
                  bytearr[count++] = (byte) (0xC0 | ((c &gt;&gt;  6) &amp; 0x1F));
                  bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
              }
          }
<span class="line-modified">!         out.write(bytearr, 0, utflen + 2);</span>
          return utflen + 2;
      }
  
<span class="line-added">+     private static String tooLongMsg(String s, int bits32) {</span>
<span class="line-added">+         int slen = s.length();</span>
<span class="line-added">+         String head = s.substring(0, 8);</span>
<span class="line-added">+         String tail = s.substring(slen - 8, slen);</span>
<span class="line-added">+         // handle int overflow with max 3x expansion</span>
<span class="line-added">+         long actualLength = (long)slen + Integer.toUnsignedLong(bits32 - slen);</span>
<span class="line-added">+         return &quot;encoded string (&quot; + head + &quot;...&quot; + tail + &quot;) too long: &quot;</span>
<span class="line-added">+             + actualLength + &quot; bytes&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Returns the current value of the counter {@code written},</span>
       * the number of bytes written to this data output stream so far.
       * If the counter overflows, it will be wrapped to Integer.MAX_VALUE.
       *
<span class="line-modified">!      * @return  the value of the {@code written} field.</span>
       * @see     java.io.DataOutputStream#written
       */
      public final int size() {
          return written;
      }
</pre>
<center><a href="DataOutput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EOFException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
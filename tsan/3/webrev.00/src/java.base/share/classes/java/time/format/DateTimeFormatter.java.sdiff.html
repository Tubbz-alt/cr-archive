<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/time/format/DateTimeFormatter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../chrono/ThaiBuddhistDate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DateTimeFormatterBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/time/format/DateTimeFormatter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 133  * formatter that uses the locale specific date format.
 134  * &lt;p&gt;
 135  * The {@link #withChronology withChronology} method returns a new formatter
 136  * that overrides the chronology. If overridden, the date-time value is
 137  * converted to the chronology before formatting. During parsing the date-time
 138  * value is converted to the chronology before it is returned.
 139  * &lt;p&gt;
 140  * The {@link #withZone withZone} method returns a new formatter that overrides
 141  * the zone. If overridden, the date-time value is converted to a ZonedDateTime
 142  * with the requested ZoneId before formatting. During parsing the ZoneId is
 143  * applied before the value is returned.
 144  * &lt;p&gt;
 145  * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that
 146  * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for
 147  * formatting and parsing.
 148  * &lt;p&gt;
 149  * Some applications may need to use the older {@link Format java.text.Format}
 150  * class for formatting. The {@link #toFormat()} method returns an
 151  * implementation of {@code java.text.Format}.
 152  *
<span class="line-modified"> 153  * &lt;h3 id=&quot;predefined&quot;&gt;Predefined Formatters&lt;/h3&gt;</span>
 154  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 155  * &lt;caption&gt;Predefined Formatters&lt;/caption&gt;
 156  * &lt;thead&gt;
 157  * &lt;tr&gt;
 158  * &lt;th scope=&quot;col&quot;&gt;Formatter&lt;/th&gt;
 159  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 160  * &lt;th scope=&quot;col&quot;&gt;Example&lt;/th&gt;
 161  * &lt;/tr&gt;
 162  * &lt;/thead&gt;
 163  * &lt;tbody&gt;
 164  * &lt;tr&gt;
 165  * &lt;th scope=&quot;row&quot;&gt;{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} &lt;/th&gt;
 166  * &lt;td&gt; Formatter with date style from the locale &lt;/td&gt;
 167  * &lt;td&gt; &#39;2011-12-03&#39;&lt;/td&gt;
 168  * &lt;/tr&gt;
 169  * &lt;tr&gt;
 170  * &lt;th scope=&quot;row&quot;&gt; {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} &lt;/th&gt;
 171  * &lt;td&gt; Formatter with time style from the locale &lt;/td&gt;
 172  * &lt;td&gt; &#39;10:15:30&#39;&lt;/td&gt;
 173  * &lt;/tr&gt;
</pre>
<hr />
<pre>
 241  * &lt;td&gt; Year and day of year &lt;/td&gt;
 242  * &lt;td&gt;&#39;2012-337&#39;&lt;/td&gt;
 243  * &lt;/tr&gt;
 244  * &lt;tr&gt;
 245  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_WEEK_DATE}&lt;/th&gt;
 246  * &lt;td&gt; Year and Week &lt;/td&gt;
 247  * &lt;td&gt;&#39;2012-W48-6&#39;&lt;/td&gt;&lt;/tr&gt;
 248  * &lt;tr&gt;
 249  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_INSTANT}&lt;/th&gt;
 250  * &lt;td&gt; Date and Time of an Instant &lt;/td&gt;
 251  * &lt;td&gt;&#39;2011-12-03T10:15:30Z&#39; &lt;/td&gt;
 252  * &lt;/tr&gt;
 253  * &lt;tr&gt;
 254  * &lt;th scope=&quot;row&quot;&gt; {@link #RFC_1123_DATE_TIME}&lt;/th&gt;
 255  * &lt;td&gt; RFC 1123 / RFC 822 &lt;/td&gt;
 256  * &lt;td&gt;&#39;Tue, 3 Jun 2008 11:05:30 GMT&#39;&lt;/td&gt;
 257  * &lt;/tr&gt;
 258  * &lt;/tbody&gt;
 259  * &lt;/table&gt;
 260  *
<span class="line-modified"> 261  * &lt;h3 id=&quot;patterns&quot;&gt;Patterns for Formatting and Parsing&lt;/h3&gt;</span>
 262  * Patterns are based on a simple sequence of letters and symbols.
 263  * A pattern is used to create a Formatter using the
 264  * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.
 265  * For example,
 266  * {@code &quot;d MMM uuuu&quot;} will format 2011-12-03 as &#39;3&amp;nbsp;Dec&amp;nbsp;2011&#39;.
 267  * A formatter created from a pattern can be used as many times as necessary,
 268  * it is immutable and is thread-safe.
 269  * &lt;p&gt;
 270  * For example:
 271  * &lt;blockquote&gt;&lt;pre&gt;
 272  *  LocalDate date = LocalDate.now();
 273  *  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);
 274  *  String text = date.format(formatter);
 275  *  LocalDate parsedDate = LocalDate.parse(text, formatter);
 276  * &lt;/pre&gt;&lt;/blockquote&gt;
 277  * &lt;p&gt;
 278  * All letters &#39;A&#39; to &#39;Z&#39; and &#39;a&#39; to &#39;z&#39; are reserved as pattern letters. The
 279  * following pattern letters are defined:
 280  * &lt;table class=&quot;striped&quot;&gt;
 281  * &lt;caption&gt;Pattern Letters and Symbols&lt;/caption&gt;
</pre>
<hr />
<pre>
 379  * If the count of letters is four, then the full name is output.
 380  * Five or more letters throws {@code IllegalArgumentException}.
 381  * &lt;p&gt;
 382  * If the pattern letter is &#39;v&#39; the output provides the zone name ignoring
 383  * daylight savings time. If the count of letters is one, then the short name is output.
 384  * If the count of letters is four, then the full name is output.
 385  * Two, three and five or more letters throw {@code IllegalArgumentException}.
 386  * &lt;p&gt;
 387  * &lt;b&gt;Offset X and x&lt;/b&gt;: This formats the offset based on the number of pattern
 388  * letters. One letter outputs just the hour, such as &#39;+01&#39;, unless the minute
 389  * is non-zero in which case the minute is also output, such as &#39;+0130&#39;. Two
 390  * letters outputs the hour and minute, without a colon, such as &#39;+0130&#39;. Three
 391  * letters outputs the hour and minute, with a colon, such as &#39;+01:30&#39;. Four
 392  * letters outputs the hour and minute and optional second, without a colon,
 393  * such as &#39;+013015&#39;. Five letters outputs the hour and minute and optional
 394  * second, with a colon, such as &#39;+01:30:15&#39;. Six or more letters throws
 395  * {@code IllegalArgumentException}. Pattern letter &#39;X&#39; (upper case) will output
 396  * &#39;Z&#39; when the offset to be output would be zero, whereas pattern letter &#39;x&#39;
 397  * (lower case) will output &#39;+00&#39;, &#39;+0000&#39;, or &#39;+00:00&#39;.
 398  * &lt;p&gt;
<span class="line-modified"> 399  * &lt;b&gt;Offset O&lt;/b&gt;: This formats the localized offset based on the number of</span>
<span class="line-modified"> 400  * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}</span>
<span class="line-modified"> 401  * form of the localized offset, which is localized offset text, such as &#39;GMT&#39;,</span>
<span class="line-modified"> 402  * with hour without leading zero, optional 2-digit minute and second if</span>
<span class="line-modified"> 403  * non-zero, and colon, for example &#39;GMT+8&#39;. Four letters outputs the</span>
<span class="line-modified"> 404  * {@linkplain TextStyle#FULL full} form, which is localized offset text,</span>
<span class="line-modified"> 405  * such as &#39;GMT, with 2-digit hour and minute field, optional second field</span>
<span class="line-modified"> 406  * if non-zero, and colon, for example &#39;GMT+08:00&#39;. Any other count of letters</span>
<span class="line-modified"> 407  * throws {@code IllegalArgumentException}.</span>

 408  * &lt;p&gt;
 409  * &lt;b&gt;Offset Z&lt;/b&gt;: This formats the offset based on the number of pattern
 410  * letters. One, two or three letters outputs the hour and minute, without a
 411  * colon, such as &#39;+0130&#39;. The output will be &#39;+0000&#39; when the offset is zero.
 412  * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized
 413  * offset, equivalent to four letters of Offset-O. The output will be the
 414  * corresponding localized offset text if the offset is zero. Five
 415  * letters outputs the hour, minute, with optional second if non-zero, with
 416  * colon. It outputs &#39;Z&#39; if the offset is zero.
 417  * Six or more letters throws {@code IllegalArgumentException}.
 418  * &lt;p&gt;
 419  * &lt;b&gt;Optional section&lt;/b&gt;: The optional section markers work exactly like
 420  * calling {@link DateTimeFormatterBuilder#optionalStart()} and
 421  * {@link DateTimeFormatterBuilder#optionalEnd()}.
 422  * &lt;p&gt;
 423  * &lt;b&gt;Pad modifier&lt;/b&gt;: Modifies the pattern that immediately follows to be
 424  * padded with spaces. The pad width is determined by the number of pattern
 425  * letters. This is the same as calling
 426  * {@link DateTimeFormatterBuilder#padNext(int)}.
 427  * &lt;p&gt;
 428  * For example, &#39;ppH&#39; outputs the hour-of-day padded on the left with spaces to
 429  * a width of 2.
 430  * &lt;p&gt;
 431  * Any unrecognized letter is an error. Any non-letter character, other than
 432  * &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;#&#39; and the single quote will be output directly.
 433  * Despite this, it is recommended to use single quotes around all characters
 434  * that you want to output directly to ensure that future changes do not break
 435  * your application.
 436  *
<span class="line-modified"> 437  * &lt;h3 id=&quot;resolving&quot;&gt;Resolving&lt;/h3&gt;</span>
 438  * Parsing is implemented as a two-phase operation.
 439  * First, the text is parsed using the layout defined by the formatter, producing
 440  * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
 441  * Second, the parsed data is &lt;em&gt;resolved&lt;/em&gt;, by validating, combining and
 442  * simplifying the various fields into more useful ones.
 443  * &lt;p&gt;
 444  * Five parsing methods are supplied by this class.
 445  * Four of these perform both the parse and resolve phases.
 446  * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},
 447  * only performs the first phase, leaving the result unresolved.
 448  * As such, it is essentially a low-level operation.
 449  * &lt;p&gt;
 450  * The resolve phase is controlled by two parameters, set on this class.
 451  * &lt;p&gt;
 452  * The {@link ResolverStyle} is an enum that offers three different approaches,
 453  * strict, smart and lenient. The smart option is the default.
 454  * It can be set using {@link #withResolverStyle(ResolverStyle)}.
 455  * &lt;p&gt;
 456  * The {@link #withResolverFields(TemporalField...)} parameter allows the
 457  * set of fields that will be resolved to be filtered before resolving starts.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 133  * formatter that uses the locale specific date format.
 134  * &lt;p&gt;
 135  * The {@link #withChronology withChronology} method returns a new formatter
 136  * that overrides the chronology. If overridden, the date-time value is
 137  * converted to the chronology before formatting. During parsing the date-time
 138  * value is converted to the chronology before it is returned.
 139  * &lt;p&gt;
 140  * The {@link #withZone withZone} method returns a new formatter that overrides
 141  * the zone. If overridden, the date-time value is converted to a ZonedDateTime
 142  * with the requested ZoneId before formatting. During parsing the ZoneId is
 143  * applied before the value is returned.
 144  * &lt;p&gt;
 145  * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that
 146  * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for
 147  * formatting and parsing.
 148  * &lt;p&gt;
 149  * Some applications may need to use the older {@link Format java.text.Format}
 150  * class for formatting. The {@link #toFormat()} method returns an
 151  * implementation of {@code java.text.Format}.
 152  *
<span class="line-modified"> 153  * &lt;h2 id=&quot;predefined&quot;&gt;Predefined Formatters&lt;/h2&gt;</span>
 154  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 155  * &lt;caption&gt;Predefined Formatters&lt;/caption&gt;
 156  * &lt;thead&gt;
 157  * &lt;tr&gt;
 158  * &lt;th scope=&quot;col&quot;&gt;Formatter&lt;/th&gt;
 159  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 160  * &lt;th scope=&quot;col&quot;&gt;Example&lt;/th&gt;
 161  * &lt;/tr&gt;
 162  * &lt;/thead&gt;
 163  * &lt;tbody&gt;
 164  * &lt;tr&gt;
 165  * &lt;th scope=&quot;row&quot;&gt;{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} &lt;/th&gt;
 166  * &lt;td&gt; Formatter with date style from the locale &lt;/td&gt;
 167  * &lt;td&gt; &#39;2011-12-03&#39;&lt;/td&gt;
 168  * &lt;/tr&gt;
 169  * &lt;tr&gt;
 170  * &lt;th scope=&quot;row&quot;&gt; {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} &lt;/th&gt;
 171  * &lt;td&gt; Formatter with time style from the locale &lt;/td&gt;
 172  * &lt;td&gt; &#39;10:15:30&#39;&lt;/td&gt;
 173  * &lt;/tr&gt;
</pre>
<hr />
<pre>
 241  * &lt;td&gt; Year and day of year &lt;/td&gt;
 242  * &lt;td&gt;&#39;2012-337&#39;&lt;/td&gt;
 243  * &lt;/tr&gt;
 244  * &lt;tr&gt;
 245  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_WEEK_DATE}&lt;/th&gt;
 246  * &lt;td&gt; Year and Week &lt;/td&gt;
 247  * &lt;td&gt;&#39;2012-W48-6&#39;&lt;/td&gt;&lt;/tr&gt;
 248  * &lt;tr&gt;
 249  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_INSTANT}&lt;/th&gt;
 250  * &lt;td&gt; Date and Time of an Instant &lt;/td&gt;
 251  * &lt;td&gt;&#39;2011-12-03T10:15:30Z&#39; &lt;/td&gt;
 252  * &lt;/tr&gt;
 253  * &lt;tr&gt;
 254  * &lt;th scope=&quot;row&quot;&gt; {@link #RFC_1123_DATE_TIME}&lt;/th&gt;
 255  * &lt;td&gt; RFC 1123 / RFC 822 &lt;/td&gt;
 256  * &lt;td&gt;&#39;Tue, 3 Jun 2008 11:05:30 GMT&#39;&lt;/td&gt;
 257  * &lt;/tr&gt;
 258  * &lt;/tbody&gt;
 259  * &lt;/table&gt;
 260  *
<span class="line-modified"> 261  * &lt;h2 id=&quot;patterns&quot;&gt;Patterns for Formatting and Parsing&lt;/h2&gt;</span>
 262  * Patterns are based on a simple sequence of letters and symbols.
 263  * A pattern is used to create a Formatter using the
 264  * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.
 265  * For example,
 266  * {@code &quot;d MMM uuuu&quot;} will format 2011-12-03 as &#39;3&amp;nbsp;Dec&amp;nbsp;2011&#39;.
 267  * A formatter created from a pattern can be used as many times as necessary,
 268  * it is immutable and is thread-safe.
 269  * &lt;p&gt;
 270  * For example:
 271  * &lt;blockquote&gt;&lt;pre&gt;
 272  *  LocalDate date = LocalDate.now();
 273  *  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);
 274  *  String text = date.format(formatter);
 275  *  LocalDate parsedDate = LocalDate.parse(text, formatter);
 276  * &lt;/pre&gt;&lt;/blockquote&gt;
 277  * &lt;p&gt;
 278  * All letters &#39;A&#39; to &#39;Z&#39; and &#39;a&#39; to &#39;z&#39; are reserved as pattern letters. The
 279  * following pattern letters are defined:
 280  * &lt;table class=&quot;striped&quot;&gt;
 281  * &lt;caption&gt;Pattern Letters and Symbols&lt;/caption&gt;
</pre>
<hr />
<pre>
 379  * If the count of letters is four, then the full name is output.
 380  * Five or more letters throws {@code IllegalArgumentException}.
 381  * &lt;p&gt;
 382  * If the pattern letter is &#39;v&#39; the output provides the zone name ignoring
 383  * daylight savings time. If the count of letters is one, then the short name is output.
 384  * If the count of letters is four, then the full name is output.
 385  * Two, three and five or more letters throw {@code IllegalArgumentException}.
 386  * &lt;p&gt;
 387  * &lt;b&gt;Offset X and x&lt;/b&gt;: This formats the offset based on the number of pattern
 388  * letters. One letter outputs just the hour, such as &#39;+01&#39;, unless the minute
 389  * is non-zero in which case the minute is also output, such as &#39;+0130&#39;. Two
 390  * letters outputs the hour and minute, without a colon, such as &#39;+0130&#39;. Three
 391  * letters outputs the hour and minute, with a colon, such as &#39;+01:30&#39;. Four
 392  * letters outputs the hour and minute and optional second, without a colon,
 393  * such as &#39;+013015&#39;. Five letters outputs the hour and minute and optional
 394  * second, with a colon, such as &#39;+01:30:15&#39;. Six or more letters throws
 395  * {@code IllegalArgumentException}. Pattern letter &#39;X&#39; (upper case) will output
 396  * &#39;Z&#39; when the offset to be output would be zero, whereas pattern letter &#39;x&#39;
 397  * (lower case) will output &#39;+00&#39;, &#39;+0000&#39;, or &#39;+00:00&#39;.
 398  * &lt;p&gt;
<span class="line-modified"> 399  * &lt;b&gt;Offset O&lt;/b&gt;: With a non-zero offset, this formats the localized offset</span>
<span class="line-modified"> 400  * based on the number of pattern letters. One letter outputs the</span>
<span class="line-modified"> 401  * {@linkplain TextStyle#SHORT short} form of the localized offset, which is</span>
<span class="line-modified"> 402  * localized offset text, such as &#39;GMT&#39;, with hour without leading zero, optional</span>
<span class="line-modified"> 403  * 2-digit minute and second if non-zero, and colon, for example &#39;GMT+8&#39;. Four</span>
<span class="line-modified"> 404  * letters outputs the {@linkplain TextStyle#FULL full} form, which is localized</span>
<span class="line-modified"> 405  * offset text, such as &#39;GMT, with 2-digit hour and minute field, optional second</span>
<span class="line-modified"> 406  * field if non-zero, and colon, for example &#39;GMT+08:00&#39;. If the offset is zero,</span>
<span class="line-modified"> 407  * only localized text is output. Any other count of letters throws</span>
<span class="line-added"> 408  * {@code IllegalArgumentException}.</span>
 409  * &lt;p&gt;
 410  * &lt;b&gt;Offset Z&lt;/b&gt;: This formats the offset based on the number of pattern
 411  * letters. One, two or three letters outputs the hour and minute, without a
 412  * colon, such as &#39;+0130&#39;. The output will be &#39;+0000&#39; when the offset is zero.
 413  * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized
 414  * offset, equivalent to four letters of Offset-O. The output will be the
 415  * corresponding localized offset text if the offset is zero. Five
 416  * letters outputs the hour, minute, with optional second if non-zero, with
 417  * colon. It outputs &#39;Z&#39; if the offset is zero.
 418  * Six or more letters throws {@code IllegalArgumentException}.
 419  * &lt;p&gt;
 420  * &lt;b&gt;Optional section&lt;/b&gt;: The optional section markers work exactly like
 421  * calling {@link DateTimeFormatterBuilder#optionalStart()} and
 422  * {@link DateTimeFormatterBuilder#optionalEnd()}.
 423  * &lt;p&gt;
 424  * &lt;b&gt;Pad modifier&lt;/b&gt;: Modifies the pattern that immediately follows to be
 425  * padded with spaces. The pad width is determined by the number of pattern
 426  * letters. This is the same as calling
 427  * {@link DateTimeFormatterBuilder#padNext(int)}.
 428  * &lt;p&gt;
 429  * For example, &#39;ppH&#39; outputs the hour-of-day padded on the left with spaces to
 430  * a width of 2.
 431  * &lt;p&gt;
 432  * Any unrecognized letter is an error. Any non-letter character, other than
 433  * &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;#&#39; and the single quote will be output directly.
 434  * Despite this, it is recommended to use single quotes around all characters
 435  * that you want to output directly to ensure that future changes do not break
 436  * your application.
 437  *
<span class="line-modified"> 438  * &lt;h2 id=&quot;resolving&quot;&gt;Resolving&lt;/h2&gt;</span>
 439  * Parsing is implemented as a two-phase operation.
 440  * First, the text is parsed using the layout defined by the formatter, producing
 441  * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
 442  * Second, the parsed data is &lt;em&gt;resolved&lt;/em&gt;, by validating, combining and
 443  * simplifying the various fields into more useful ones.
 444  * &lt;p&gt;
 445  * Five parsing methods are supplied by this class.
 446  * Four of these perform both the parse and resolve phases.
 447  * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},
 448  * only performs the first phase, leaving the result unresolved.
 449  * As such, it is essentially a low-level operation.
 450  * &lt;p&gt;
 451  * The resolve phase is controlled by two parameters, set on this class.
 452  * &lt;p&gt;
 453  * The {@link ResolverStyle} is an enum that offers three different approaches,
 454  * strict, smart and lenient. The smart option is the default.
 455  * It can be set using {@link #withResolverStyle(ResolverStyle)}.
 456  * &lt;p&gt;
 457  * The {@link #withResolverFields(TemporalField...)} parameter allows the
 458  * set of fields that will be resolved to be filtered before resolving starts.
</pre>
</td>
</tr>
</table>
<center><a href="../chrono/ThaiBuddhistDate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DateTimeFormatterBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
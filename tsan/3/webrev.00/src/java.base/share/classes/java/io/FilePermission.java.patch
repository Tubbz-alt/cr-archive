diff a/src/java.base/share/classes/java/io/FilePermission.java b/src/java.base/share/classes/java/io/FilePermission.java
--- a/src/java.base/share/classes/java/io/FilePermission.java
+++ b/src/java.base/share/classes/java/io/FilePermission.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -44,11 +44,11 @@
  * This class represents access to a file or directory.  A FilePermission consists
  * of a pathname and a set of actions valid for that pathname.
  * <P>
  * Pathname is the pathname of the file or directory granted the specified
  * actions. A pathname that ends in "/*" (where "/" is
- * the file separator character, <code>File.separatorChar</code>) indicates
+ * the file separator character, {@code File.separatorChar}) indicates
  * all the files and directories contained in that directory. A pathname
  * that ends with "/-" indicates (recursively) all files
  * and subdirectories contained in that directory. Such a pathname is called
  * a wildcard pathname. Otherwise, it's a simple pathname.
  * <P>
@@ -68,15 +68,15 @@
  *
  * <DL>
  *    <DT> read <DD> read permission
  *    <DT> write <DD> write permission
  *    <DT> execute
- *    <DD> execute permission. Allows <code>Runtime.exec</code> to
- *         be called. Corresponds to <code>SecurityManager.checkExec</code>.
+ *    <DD> execute permission. Allows {@code Runtime.exec} to
+ *         be called. Corresponds to {@code SecurityManager.checkExec}.
  *    <DT> delete
- *    <DD> delete permission. Allows <code>File.delete</code> to
- *         be called. Corresponds to <code>SecurityManager.checkDelete</code>.
+ *    <DD> delete permission. Allows {@code File.delete} to
+ *         be called. Corresponds to {@code SecurityManager.checkDelete}.
  *    <DT> readlink
  *    <DD> read link permission. Allows the target of a
  *         <a href="../nio/file/package-summary.html#links">symbolic link</a>
  *         to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
  *         readSymbolicLink } method.
@@ -193,10 +193,11 @@
 //        }
 //        sb.append("***\n");
 //        return sb.toString();
 //    }
 
+    @java.io.Serial
     private static final long serialVersionUID = 7930732926638008763L;
 
     /**
      * Use the platform's default file system to avoid recursive initialization
      * issues when the VM is configured to use a custom file system provider.
@@ -364,16 +365,26 @@
                 throw new NullPointerException("name can't be null");
 
             this.mask = mask;
 
             if (cpath.equals("<<ALL FILES>>")) {
+                allFiles = true;
                 directory = true;
                 recursive = true;
                 cpath = "";
                 return;
             }
 
+            // Validate path by platform's default file system
+            try {
+                String name = cpath.endsWith("*") ? cpath.substring(0, cpath.length() - 1) + "-" : cpath;
+                builtInFS.getPath(new File(name).getPath());
+            } catch (InvalidPathException ipe) {
+                invalid = true;
+                return;
+            }
+
             // store only the canonical cpath if possible
             cpath = AccessController.doPrivileged(new PrivilegedAction<>() {
                 public String run() {
                     try {
                         String path = cpath;
@@ -423,11 +434,11 @@
      * contains a comma-separated list of the desired actions granted on the
      * file or directory. Possible actions are
      * "read", "write", "execute", "delete", and "readlink".
      *
      * <p>A pathname that ends in "/*" (where "/" is
-     * the file separator character, <code>File.separatorChar</code>)
+     * the file separator character, {@code File.separatorChar})
      * indicates all the files and directories contained in that directory.
      * A pathname that ends with "/-" indicates (recursively) all files and
      * subdirectories contained in that directory. The special pathname
      * {@literal "<<ALL FILES>>"} matches any file.
      *
@@ -438,12 +449,12 @@
      * directory.
      *
      * <p>A pathname containing an empty string represents an empty path.
      *
      * @implNote In this implementation, the
-     * {@code jdk.io.permissionsUseCanonicalPath} system property dictates how
-     * the {@code path} argument is processed and stored.
+     * {@systemProperty jdk.io.permissionsUseCanonicalPath} system property
+     * dictates how the {@code path} argument is processed and stored.
      * <P>
      * If the value of the system property is set to {@code true}, {@code path}
      * is canonicalized and stored as a String object named {@code cpath}.
      * This means a relative path is converted to an absolute path, a Windows
      * DOS-style 8.3 path is expanded to a long path, and a symbolic link is
@@ -460,17 +471,20 @@
      * {@code path} is removed before canonicalization or normalization.
      * It is stored in a separate wildcard flag field.
      * <P>
      * The default value of the {@code jdk.io.permissionsUseCanonicalPath}
      * system property is {@code false} in this implementation.
+     * <p>
+     * The value can also be set with a security property using the same name,
+     * but setting a system property will override the security property value.
      *
      * @param path the pathname of the file/directory.
      * @param actions the action string.
      *
-     * @throws IllegalArgumentException
-     *          If actions is <code>null</code>, empty or contains an action
-     *          other than the specified possible actions.
+     * @throws IllegalArgumentException if actions is {@code null}, empty,
+     *         malformed or contains an action other than the specified
+     *         possible actions
      */
     public FilePermission(String path, String actions) {
         super(path);
         init(getMask(actions));
     }
@@ -478,11 +492,11 @@
     /**
      * Creates a new FilePermission object using an action mask.
      * More efficient than the FilePermission(String, String) constructor.
      * Can be used from within
      * code that needs to create a FilePermission object to pass into the
-     * <code>implies</code> method.
+     * {@code implies} method.
      *
      * @param path the pathname of the file/directory.
      * @param mask the action mask to use.
      */
     // package private for use by the FilePermissionCollection add method
@@ -544,13 +558,13 @@
      * invalid {@code FilePermission}. Even if two {@code FilePermission}
      * are created with the same invalid path, one does not imply the other.
      *
      * @param p the permission to check against.
      *
-     * @return <code>true</code> if the specified permission is not
-     *                  <code>null</code> and is implied by this object,
-     *                  <code>false</code> otherwise.
+     * @return {@code true} if the specified permission is not
+     *                  {@code null} and is implied by this object,
+     *                  {@code false} otherwise.
      */
     @Override
     public boolean implies(Permission p) {
         if (!(p instanceof FilePermission))
             return false;
@@ -570,23 +584,23 @@
      *
      * @param that the FilePermission to check against.
      * @return the effective mask
      */
     boolean impliesIgnoreMask(FilePermission that) {
+        if (this == that) {
+            return true;
+        }
+        if (allFiles) {
+            return true;
+        }
+        if (this.invalid || that.invalid) {
+            return false;
+        }
+        if (that.allFiles) {
+            return false;
+        }
         if (FilePermCompat.nb) {
-            if (this == that) {
-                return true;
-            }
-            if (allFiles) {
-                return true;
-            }
-            if (this.invalid || that.invalid) {
-                return false;
-            }
-            if (that.allFiles) {
-                return false;
-            }
             // Left at least same level of wildness as right
             if ((this.recursive && that.recursive) != that.recursive
                     || (this.directory && that.directory) != that.directory) {
                 return false;
             }
@@ -766,13 +780,13 @@
      * When {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, an
      * invalid {@code FilePermission} does not equal to any object except
      * for itself, even if they are created using the same invalid path.
      *
      * @param obj the object we are testing for equality with this object.
-     * @return <code>true</code> if obj is a FilePermission, and has the same
+     * @return {@code true} if obj is a FilePermission, and has the same
      *          pathname and actions as this FilePermission object,
-     *          <code>false</code> otherwise.
+     *          {@code false} otherwise.
      */
     @Override
     public boolean equals(Object obj) {
         if (obj == this)
             return true;
@@ -780,22 +794,23 @@
         if (! (obj instanceof FilePermission))
             return false;
 
         FilePermission that = (FilePermission) obj;
 
+        if (this.invalid || that.invalid) {
+            return false;
+        }
         if (FilePermCompat.nb) {
-            if (this.invalid || that.invalid) {
-                return false;
-            }
             return (this.mask == that.mask) &&
                     (this.allFiles == that.allFiles) &&
                     this.npath.equals(that.npath) &&
                     Objects.equals(npath2, that.npath2) &&
                     (this.directory == that.directory) &&
                     (this.recursive == that.recursive);
         } else {
             return (this.mask == that.mask) &&
+                    (this.allFiles == that.allFiles) &&
                     this.cpath.equals(that.cpath) &&
                     (this.directory == that.directory) &&
                     (this.recursive == that.recursive);
         }
     }
@@ -918,21 +933,22 @@
                 throw new IllegalArgumentException(
                         "invalid permission: " + actions);
             }
 
             // make sure we didn't just match the tail of a word
-            // like "ackbarfaccept".  Also, skip to the comma.
+            // like "ackbarfdelete".  Also, skip to the comma.
             boolean seencomma = false;
             while (i >= matchlen && !seencomma) {
-                switch(a[i-matchlen]) {
-                case ',':
-                    seencomma = true;
-                    break;
+                switch (c = a[i-matchlen]) {
                 case ' ': case '\r': case '\n':
                 case '\f': case '\t':
                     break;
                 default:
+                    if (c == ',' && i > matchlen) {
+                        seencomma = true;
+                        break;
+                    }
                     throw new IllegalArgumentException(
                             "invalid permission: " + actions);
                 }
                 i--;
             }
@@ -984,11 +1000,11 @@
 
     /**
      * Returns the "canonical string representation" of the actions.
      * That is, this method always returns present actions in the following order:
      * read, write, execute, delete, readlink. For example, if this FilePermission
-     * object allows both write and read actions, a call to <code>getActions</code>
+     * object allows both write and read actions, a call to {@code getActions}
      * will return the string "read,write".
      *
      * @return the canonical string representation of the actions.
      */
     @Override
@@ -1003,31 +1019,31 @@
      * Returns a new PermissionCollection object for storing FilePermission
      * objects.
      * <p>
      * FilePermission objects must be stored in a manner that allows them
      * to be inserted into the collection in any order, but that also enables the
-     * PermissionCollection <code>implies</code>
+     * PermissionCollection {@code implies}
      * method to be implemented in an efficient (and consistent) manner.
      *
      * <p>For example, if you have two FilePermissions:
      * <OL>
-     * <LI>  <code>"/tmp/-", "read"</code>
-     * <LI>  <code>"/tmp/scratch/foo", "write"</code>
+     * <LI>  {@code "/tmp/-", "read"}
+     * <LI>  {@code "/tmp/scratch/foo", "write"}
      * </OL>
      *
-     * <p>and you are calling the <code>implies</code> method with the FilePermission:
+     * <p>and you are calling the {@code implies} method with the FilePermission:
      *
      * <pre>
      *   "/tmp/scratch/foo", "read,write",
      * </pre>
      *
-     * then the <code>implies</code> function must
+     * then the {@code implies} function must
      * take into account both the "/tmp/-" and "/tmp/scratch/foo"
      * permissions, so the effective permission is "read,write",
-     * and <code>implies</code> returns true. The "implies" semantics for
+     * and {@code implies} returns true. The "implies" semantics for
      * FilePermissions are handled properly by the PermissionCollection object
-     * returned by this <code>newPermissionCollection</code> method.
+     * returned by this {@code newPermissionCollection} method.
      *
      * @return a new PermissionCollection object suitable for storing
      * FilePermissions.
      */
     @Override
@@ -1038,10 +1054,11 @@
     /**
      * WriteObject is called to save the state of the FilePermission
      * to a stream. The actions are serialized, and the superclass
      * takes care of the name.
      */
+    @java.io.Serial
     private void writeObject(ObjectOutputStream s)
         throws IOException
     {
         // Write out the actions. The superclass takes care of the name
         // call getActions to make sure actions field is initialized
@@ -1052,10 +1069,11 @@
 
     /**
      * readObject is called to restore the state of the FilePermission from
      * a stream.
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream s)
          throws IOException, ClassNotFoundException
     {
         // Read in the actions, then restore everything else by calling init.
         s.defaultReadObject();
@@ -1122,14 +1140,14 @@
      * Adds a permission to the FilePermissionCollection. The key for the hash is
      * permission.path.
      *
      * @param permission the Permission object to add.
      *
-     * @exception IllegalArgumentException - if the permission is not a
+     * @throws    IllegalArgumentException   if the permission is not a
      *                                       FilePermission
      *
-     * @exception SecurityException - if this FilePermissionCollection object
+     * @throws    SecurityException   if this FilePermissionCollection object
      *                                has been marked readonly
      */
     @Override
     public void add(Permission permission) {
         if (! (permission instanceof FilePermission))
@@ -1191,11 +1209,11 @@
             if (((needed & fp.getMask()) != 0) && fp.impliesIgnoreMask(fperm)) {
                 effective |= fp.getMask();
                 if ((effective & desired) == desired) {
                     return true;
                 }
-                needed = (desired ^ effective);
+                needed = (desired & ~effective);
             }
         }
         return false;
     }
 
@@ -1208,20 +1226,22 @@
     @Override
     public Enumeration<Permission> elements() {
         return perms.elements();
     }
 
+    @java.io.Serial
     private static final long serialVersionUID = 2202956749081564585L;
 
     // Need to maintain serialization interoperability with earlier releases,
     // which had the serializable field:
     //    private Vector permissions;
 
     /**
      * @serialField permissions java.util.Vector
      *     A list of FilePermission objects.
      */
+    @java.io.Serial
     private static final ObjectStreamField[] serialPersistentFields = {
         new ObjectStreamField("permissions", Vector.class),
     };
 
     /**
@@ -1229,10 +1249,11 @@
      */
     /*
      * Writes the contents of the perms field out as a Vector for
      * serialization compatibility with earlier releases.
      */
+    @java.io.Serial
     private void writeObject(ObjectOutputStream out) throws IOException {
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
         Vector<Permission> permissions = new Vector<>(perms.values());
@@ -1243,10 +1264,11 @@
     }
 
     /*
      * Reads in a Vector of FilePermissions and saves them in the perms field.
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream in)
         throws IOException, ClassNotFoundException
     {
         // Don't call defaultReadObject()
 

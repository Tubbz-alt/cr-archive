<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="WrongMethodTypeException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 


 27 import jdk.internal.misc.Unsafe;
 28 import jdk.internal.util.Preconditions;
 29 import jdk.internal.vm.annotation.ForceInline;
 30 
 31 import java.nio.ByteBuffer;
 32 import java.nio.ReadOnlyBufferException;
 33 import java.util.Objects;
 34 
 35 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 36 
 37 #warn
 38 
 39 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
 40 


 41     static final int ALIGN = $BoxType$.BYTES - 1;
 42 
 43 #if[floatingPoint]
 44     @ForceInline
 45     static $rawType$ convEndian(boolean big, $type$ v) {
 46         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 47         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 48     }
 49 
 50     @ForceInline
 51     static $type$ convEndian(boolean big, $rawType$ rv) {
 52         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 53         return $Type$.$rawType$BitsTo$Type$(rv);
 54     }
 55 #else[floatingPoint]
 56     @ForceInline
 57     static $type$ convEndian(boolean big, $type$ n) {
 58         return big == BE ? n : $BoxType$.reverseBytes(n);
 59     }
 60 #end[floatingPoint]
</pre>
<hr />
<pre>
512         }
513 #end[Bitwise]
514 
515         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
516     }
517 
518 
519     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
520 
521         ByteBufferHandle(boolean be) {
522             super(ByteBufferHandle.FORM, be);
523         }
524 
525         @Override
526         final MethodType accessModeTypeUncached(AccessMode accessMode) {
527             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
528         }
529 
530         @ForceInline
531         static int index(ByteBuffer bb, int index) {

532             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
533         }
534 
535         @ForceInline
536         static int indexRO(ByteBuffer bb, int index) {
537             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
538                 throw new ReadOnlyBufferException();
<span class="line-modified">539             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);</span>
540         }
541 
542         @ForceInline
543         static long address(ByteBuffer bb, int index) {
544             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
545             if ((address &amp; ALIGN) != 0)
546                 throw newIllegalStateExceptionForMisalignedAccess(index);
547             return address;
548         }
549 
550         @ForceInline
551         static $type$ get(ByteBufferHandle handle, Object obb, int index) {
552             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
553 #if[floatingPoint]
554             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
555                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
556                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
557                     handle.be);
558             return $Type$.$rawType$BitsTo$Type$(rawValue);
559 #else[floatingPoint]
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 
<span class="line-added"> 27 import jdk.internal.access.JavaNioAccess;</span>
<span class="line-added"> 28 import jdk.internal.access.SharedSecrets;</span>
 29 import jdk.internal.misc.Unsafe;
 30 import jdk.internal.util.Preconditions;
 31 import jdk.internal.vm.annotation.ForceInline;
 32 
 33 import java.nio.ByteBuffer;
 34 import java.nio.ReadOnlyBufferException;
 35 import java.util.Objects;
 36 
 37 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 38 
 39 #warn
 40 
 41 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
 42 
<span class="line-added"> 43     static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();</span>
<span class="line-added"> 44 </span>
 45     static final int ALIGN = $BoxType$.BYTES - 1;
 46 
 47 #if[floatingPoint]
 48     @ForceInline
 49     static $rawType$ convEndian(boolean big, $type$ v) {
 50         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 51         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 52     }
 53 
 54     @ForceInline
 55     static $type$ convEndian(boolean big, $rawType$ rv) {
 56         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 57         return $Type$.$rawType$BitsTo$Type$(rv);
 58     }
 59 #else[floatingPoint]
 60     @ForceInline
 61     static $type$ convEndian(boolean big, $type$ n) {
 62         return big == BE ? n : $BoxType$.reverseBytes(n);
 63     }
 64 #end[floatingPoint]
</pre>
<hr />
<pre>
516         }
517 #end[Bitwise]
518 
519         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
520     }
521 
522 
523     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
524 
525         ByteBufferHandle(boolean be) {
526             super(ByteBufferHandle.FORM, be);
527         }
528 
529         @Override
530         final MethodType accessModeTypeUncached(AccessMode accessMode) {
531             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
532         }
533 
534         @ForceInline
535         static int index(ByteBuffer bb, int index) {
<span class="line-added">536             nioAccess.checkSegment(bb);</span>
537             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
538         }
539 
540         @ForceInline
541         static int indexRO(ByteBuffer bb, int index) {
542             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
543                 throw new ReadOnlyBufferException();
<span class="line-modified">544             return index(bb, index);</span>
545         }
546 
547         @ForceInline
548         static long address(ByteBuffer bb, int index) {
549             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
550             if ((address &amp; ALIGN) != 0)
551                 throw newIllegalStateExceptionForMisalignedAccess(index);
552             return address;
553         }
554 
555         @ForceInline
556         static $type$ get(ByteBufferHandle handle, Object obb, int index) {
557             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
558 #if[floatingPoint]
559             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
560                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
561                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
562                     handle.be);
563             return $Type$.$rawType$BitsTo$Type$(rawValue);
564 #else[floatingPoint]
</pre>
</td>
</tr>
</table>
<center><a href="WrongMethodTypeException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
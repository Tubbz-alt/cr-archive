<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/time/temporal/JulianFields.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * This file is available under and governed by the GNU General Public
 28  * License version 2 only, as published by the Free Software Foundation.
 29  * However, the following notice accompanied the original version of this
 30  * file:
 31  *
 32  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 33  *
 34  * All rights reserved.
 35  *
 36  * Redistribution and use in source and binary forms, with or without
 37  * modification, are permitted provided that the following conditions are met:
 38  *
 39  *  * Redistributions of source code must retain the above copyright notice,
 40  *    this list of conditions and the following disclaimer.
 41  *
 42  *  * Redistributions in binary form must reproduce the above copyright notice,
 43  *    this list of conditions and the following disclaimer in the documentation
 44  *    and/or other materials provided with the distribution.
 45  *
 46  *  * Neither the name of JSR-310 nor the names of its contributors
 47  *    may be used to endorse or promote products derived from this software
 48  *    without specific prior written permission.
 49  *
 50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 61  */
 62 package java.time.temporal;
 63 
 64 import static java.time.temporal.ChronoField.EPOCH_DAY;
 65 import static java.time.temporal.ChronoUnit.DAYS;
 66 import static java.time.temporal.ChronoUnit.FOREVER;
 67 
 68 import java.time.DateTimeException;
 69 import java.time.chrono.ChronoLocalDate;
 70 import java.time.chrono.Chronology;
 71 import java.time.format.ResolverStyle;
 72 import java.util.Map;
 73 
 74 /**
 75  * A set of date fields that provide access to Julian Days.
 76  * &lt;p&gt;
 77  * The Julian Day is a standard way of expressing date and time commonly used in the scientific community.
 78  * It is expressed as a decimal number of whole days where days start at midday.
 79  * This class represents variations on Julian Days that count whole days from midnight.
 80  * &lt;p&gt;
 81  * The fields are implemented relative to {@link ChronoField#EPOCH_DAY EPOCH_DAY}.
 82  * The fields are supported, and can be queried and set if {@code EPOCH_DAY} is available.
 83  * The fields work with all chronologies.
 84  *
 85  * @implSpec
 86  * This is an immutable and thread-safe class.
 87  *
 88  * @since 1.8
 89  */
 90 public final class JulianFields {
 91 
 92     /**
 93      * The offset from Julian to EPOCH DAY.
 94      */
 95     private static final long JULIAN_DAY_OFFSET = 2440588L;
 96 
 97     /**
 98      * Julian Day field.
 99      * &lt;p&gt;
100      * This is an integer-based version of the Julian Day Number.
101      * Julian Day is a well-known system that represents the count of whole days since day 0,
102      * which is defined to be January 1, 4713 BCE in the Julian calendar, and -4713-11-24 Gregorian.
103      * The field  has &quot;JulianDay&quot; as &#39;name&#39;, and &#39;DAYS&#39; as &#39;baseUnit&#39;.
104      * The field always refers to the local date-time, ignoring the offset or zone.
105      * &lt;p&gt;
106      * For date-times, &#39;JULIAN_DAY.getFrom()&#39; assumes the same value from
107      * midnight until just before the next midnight.
108      * When &#39;JULIAN_DAY.adjustInto()&#39; is applied to a date-time, the time of day portion remains unaltered.
109      * &#39;JULIAN_DAY.adjustInto()&#39; and &#39;JULIAN_DAY.getFrom()&#39; only apply to {@code Temporal} objects that
110      * can be converted into {@link ChronoField#EPOCH_DAY}.
111      * An {@link UnsupportedTemporalTypeException} is thrown for any other type of object.
112      * &lt;p&gt;
113      * In the resolving phase of parsing, a date can be created from a Julian Day field.
114      * In {@linkplain ResolverStyle#STRICT strict mode} and {@linkplain ResolverStyle#SMART smart mode}
115      * the Julian Day value is validated against the range of valid values.
116      * In {@linkplain ResolverStyle#LENIENT lenient mode} no validation occurs.
117      *
118      * &lt;h3&gt;Astronomical and Scientific Notes&lt;/h3&gt;
119      * The standard astronomical definition uses a fraction to indicate the time-of-day,
120      * where each day is counted from midday to midday. For example,
121      * a fraction of 0 represents midday, a fraction of 0.25
122      * represents 18:00, a fraction of 0.5 represents midnight and a fraction
123      * of 0.75 represents 06:00.
124      * &lt;p&gt;
125      * By contrast, this implementation has no fractional part, and counts
126      * days from midnight to midnight.
127      * This implementation uses an integer and days starting at midnight.
128      * The integer value for the Julian Day Number is the astronomical Julian Day value at midday
129      * of the date in question.
130      * This amounts to the astronomical Julian Day, rounded to an integer {@code JDN = floor(JD + 0.5)}.
131      *
132      * &lt;pre&gt;
133      *  | ISO date          |  Julian Day Number | Astronomical Julian Day |
134      *  | 1970-01-01T00:00  |         2,440,588  |         2,440,587.5     |
135      *  | 1970-01-01T06:00  |         2,440,588  |         2,440,587.75    |
136      *  | 1970-01-01T12:00  |         2,440,588  |         2,440,588.0     |
137      *  | 1970-01-01T18:00  |         2,440,588  |         2,440,588.25    |
138      *  | 1970-01-02T00:00  |         2,440,589  |         2,440,588.5     |
139      *  | 1970-01-02T06:00  |         2,440,589  |         2,440,588.75    |
140      *  | 1970-01-02T12:00  |         2,440,589  |         2,440,589.0     |
141      * &lt;/pre&gt;
142      * &lt;p&gt;
143      * Julian Days are sometimes taken to imply Universal Time or UTC, but this
144      * implementation always uses the Julian Day number for the local date,
145      * regardless of the offset or time-zone.
146      */
147     public static final TemporalField JULIAN_DAY = Field.JULIAN_DAY;
148 
149     /**
150      * Modified Julian Day field.
151      * &lt;p&gt;
152      * This is an integer-based version of the Modified Julian Day Number.
153      * Modified Julian Day (MJD) is a well-known system that counts days continuously.
154      * It is defined relative to astronomical Julian Day as  {@code MJD = JD - 2400000.5}.
155      * Each Modified Julian Day runs from midnight to midnight.
156      * The field always refers to the local date-time, ignoring the offset or zone.
157      * &lt;p&gt;
158      * For date-times, &#39;MODIFIED_JULIAN_DAY.getFrom()&#39; assumes the same value from
159      * midnight until just before the next midnight.
160      * When &#39;MODIFIED_JULIAN_DAY.adjustInto()&#39; is applied to a date-time, the time of day portion remains unaltered.
161      * &#39;MODIFIED_JULIAN_DAY.adjustInto()&#39; and &#39;MODIFIED_JULIAN_DAY.getFrom()&#39; only apply to {@code Temporal} objects
162      * that can be converted into {@link ChronoField#EPOCH_DAY}.
163      * An {@link UnsupportedTemporalTypeException} is thrown for any other type of object.
164      * &lt;p&gt;
165      * This implementation is an integer version of MJD with the decimal part rounded to floor.
166      * &lt;p&gt;
167      * In the resolving phase of parsing, a date can be created from a Modified Julian Day field.
168      * In {@linkplain ResolverStyle#STRICT strict mode} and {@linkplain ResolverStyle#SMART smart mode}
169      * the Modified Julian Day value is validated against the range of valid values.
170      * In {@linkplain ResolverStyle#LENIENT lenient mode} no validation occurs.
171      *
172      * &lt;h3&gt;Astronomical and Scientific Notes&lt;/h3&gt;
173      * &lt;pre&gt;
174      *  | ISO date          | Modified Julian Day |      Decimal MJD |
175      *  | 1970-01-01T00:00  |             40,587  |       40,587.0   |
176      *  | 1970-01-01T06:00  |             40,587  |       40,587.25  |
177      *  | 1970-01-01T12:00  |             40,587  |       40,587.5   |
178      *  | 1970-01-01T18:00  |             40,587  |       40,587.75  |
179      *  | 1970-01-02T00:00  |             40,588  |       40,588.0   |
180      *  | 1970-01-02T06:00  |             40,588  |       40,588.25  |
181      *  | 1970-01-02T12:00  |             40,588  |       40,588.5   |
182      * &lt;/pre&gt;
183      *
184      * Modified Julian Days are sometimes taken to imply Universal Time or UTC, but this
185      * implementation always uses the Modified Julian Day for the local date,
186      * regardless of the offset or time-zone.
187      */
188     public static final TemporalField MODIFIED_JULIAN_DAY = Field.MODIFIED_JULIAN_DAY;
189 
190     /**
191      * Rata Die field.
192      * &lt;p&gt;
193      * Rata Die counts whole days continuously starting day 1 at midnight at the beginning of 0001-01-01 (ISO).
194      * The field always refers to the local date-time, ignoring the offset or zone.
195      * &lt;p&gt;
196      * For date-times, &#39;RATA_DIE.getFrom()&#39; assumes the same value from
197      * midnight until just before the next midnight.
198      * When &#39;RATA_DIE.adjustInto()&#39; is applied to a date-time, the time of day portion remains unaltered.
199      * &#39;RATA_DIE.adjustInto()&#39; and &#39;RATA_DIE.getFrom()&#39; only apply to {@code Temporal} objects
200      * that can be converted into {@link ChronoField#EPOCH_DAY}.
201      * An {@link UnsupportedTemporalTypeException} is thrown for any other type of object.
202      * &lt;p&gt;
203      * In the resolving phase of parsing, a date can be created from a Rata Die field.
204      * In {@linkplain ResolverStyle#STRICT strict mode} and {@linkplain ResolverStyle#SMART smart mode}
205      * the Rata Die value is validated against the range of valid values.
206      * In {@linkplain ResolverStyle#LENIENT lenient mode} no validation occurs.
207      */
208     public static final TemporalField RATA_DIE = Field.RATA_DIE;
209 
210     /**
211      * Restricted constructor.
212      */
213     private JulianFields() {
214         throw new AssertionError(&quot;Not instantiable&quot;);
215     }
216 
217     /**
218      * Implementation of JulianFields.  Each instance is a singleton.
219      */
220     private static enum Field implements TemporalField {
221         JULIAN_DAY(&quot;JulianDay&quot;, DAYS, FOREVER, JULIAN_DAY_OFFSET),
222         MODIFIED_JULIAN_DAY(&quot;ModifiedJulianDay&quot;, DAYS, FOREVER, 40587L),
223         RATA_DIE(&quot;RataDie&quot;, DAYS, FOREVER, 719163L);
224 
225         private final transient String name;
226         private final transient TemporalUnit baseUnit;
227         private final transient TemporalUnit rangeUnit;
228         private final transient ValueRange range;
229         private final transient long offset;
230 
231         private Field(String name, TemporalUnit baseUnit, TemporalUnit rangeUnit, long offset) {
232             this.name = name;
233             this.baseUnit = baseUnit;
234             this.rangeUnit = rangeUnit;
235             this.range = ValueRange.of(-365243219162L + offset, 365241780471L + offset);
236             this.offset = offset;
237         }
238 
239         //-----------------------------------------------------------------------
240         @Override
241         public TemporalUnit getBaseUnit() {
242             return baseUnit;
243         }
244 
245         @Override
246         public TemporalUnit getRangeUnit() {
247             return rangeUnit;
248         }
249 
250         @Override
251         public boolean isDateBased() {
252             return true;
253         }
254 
255         @Override
256         public boolean isTimeBased() {
257             return false;
258         }
259 
260         @Override
261         public ValueRange range() {
262             return range;
263         }
264 
265         //-----------------------------------------------------------------------
266         @Override
267         public boolean isSupportedBy(TemporalAccessor temporal) {
268             return temporal.isSupported(EPOCH_DAY);
269         }
270 
271         @Override
272         public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
273             if (isSupportedBy(temporal) == false) {
274                 throw new DateTimeException(&quot;Unsupported field: &quot; + this);
275             }
276             return range();
277         }
278 
279         @Override
280         public long getFrom(TemporalAccessor temporal) {
281             return temporal.getLong(EPOCH_DAY) + offset;
282         }
283 
284         @SuppressWarnings(&quot;unchecked&quot;)
285         @Override
286         public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
287             if (range().isValidValue(newValue) == false) {
288                 throw new DateTimeException(&quot;Invalid value: &quot; + name + &quot; &quot; + newValue);
289             }
290             return (R) temporal.with(EPOCH_DAY, Math.subtractExact(newValue, offset));
291         }
292 
293         //-----------------------------------------------------------------------
294         @Override
295         public ChronoLocalDate resolve(
296                 Map&lt;TemporalField, Long&gt; fieldValues, TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {
297             long value = fieldValues.remove(this);
298             Chronology chrono = Chronology.from(partialTemporal);
299             if (resolverStyle == ResolverStyle.LENIENT) {
300                 return chrono.dateEpochDay(Math.subtractExact(value, offset));
301             }
302             range().checkValidValue(value, this);
303             return chrono.dateEpochDay(value - offset);
304         }
305 
306         //-----------------------------------------------------------------------
307         @Override
308         public String toString() {
309             return name;
310         }
311     }
312 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Proxy.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Modifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ProxyGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Proxy.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  32 import java.util.Collections;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.IdentityHashMap;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Objects;
  39 import java.util.Set;
  40 import java.util.concurrent.atomic.AtomicInteger;
  41 import java.util.concurrent.atomic.AtomicLong;
  42 
  43 import jdk.internal.access.JavaLangAccess;
  44 import jdk.internal.access.SharedSecrets;
  45 import jdk.internal.loader.BootLoader;
  46 import jdk.internal.module.Modules;
  47 import jdk.internal.misc.VM;
  48 import jdk.internal.reflect.CallerSensitive;
  49 import jdk.internal.reflect.Reflection;
  50 import jdk.internal.loader.ClassLoaderValue;
  51 import sun.reflect.misc.ReflectUtil;

  52 import sun.security.action.GetPropertyAction;
  53 import sun.security.util.SecurityConstants;
  54 
  55 import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;
  56 
  57 
  58 /**
  59  *
  60  * {@code Proxy} provides static methods for creating objects that act like instances
  61  * of interfaces but allow for customized method invocation.
  62  * To create a proxy instance for some interface {@code Foo}:
  63  * &lt;pre&gt;{@code
  64  *     InvocationHandler handler = new MyInvocationHandler(...);
  65  *     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
  66  *                                          new Class&lt;?&gt;[] { Foo.class },
  67  *                                          handler);
  68  * }&lt;/pre&gt;
  69  *
  70  * &lt;p&gt;
  71  * A &lt;em&gt;proxy class&lt;/em&gt; is a class created at runtime that implements a specified
</pre>
<hr />
<pre>
  82  * containing the arguments.  The invocation handler processes the
  83  * encoded method invocation as appropriate and the result that it
  84  * returns will be returned as the result of the method invocation on
  85  * the proxy instance.
  86  *
  87  * &lt;p&gt;A proxy class has the following properties:
  88  *
  89  * &lt;ul&gt;
  90  * &lt;li&gt;The unqualified name of a proxy class is unspecified.  The space
  91  * of class names that begin with the string {@code &quot;$Proxy&quot;}
  92  * should be, however, reserved for proxy classes.
  93  *
  94  * &lt;li&gt;The package and module in which a proxy class is defined is specified
  95  * &lt;a href=&quot;#membership&quot;&gt;below&lt;/a&gt;.
  96  *
  97  * &lt;li&gt;A proxy class is &lt;em&gt;final and non-abstract&lt;/em&gt;.
  98  *
  99  * &lt;li&gt;A proxy class extends {@code java.lang.reflect.Proxy}.
 100  *
 101  * &lt;li&gt;A proxy class implements exactly the interfaces specified at its
<span class="line-modified"> 102  * creation, in the same order. Invoking {@link Class#getInterfaces getInterfaces}</span>
 103  * on its {@code Class} object will return an array containing the same
 104  * list of interfaces (in the order specified at its creation), invoking
 105  * {@link Class#getMethods getMethods} on its {@code Class} object will return
 106  * an array of {@code Method} objects that include all of the
 107  * methods in those interfaces, and invoking {@code getMethod} will
 108  * find methods in the proxy interfaces as would be expected.
 109  *
 110  * &lt;li&gt;The {@link java.security.ProtectionDomain} of a proxy class
 111  * is the same as that of system classes loaded by the bootstrap class
 112  * loader, such as {@code java.lang.Object}, because the code for a
 113  * proxy class is generated by trusted system code.  This protection
 114  * domain will typically be granted {@code java.security.AllPermission}.
 115  *
 116  * &lt;li&gt;The {@link Proxy#isProxyClass Proxy.isProxyClass} method can be used
 117  * to determine if a given class is a proxy class.
 118  * &lt;/ul&gt;
 119  *
 120  * &lt;p&gt;A proxy instance has the following properties:
 121  *
 122  * &lt;ul&gt;
</pre>
<hr />
<pre>
 139  * passed as its argument.
 140  *
 141  * &lt;li&gt;An interface method invocation on a proxy instance will be
 142  * encoded and dispatched to the invocation handler&#39;s {@link
 143  * InvocationHandler#invoke invoke} method as described in the
 144  * documentation for that method.
 145  *
 146  * &lt;li&gt;An invocation of the {@code hashCode},
 147  * {@code equals}, or {@code toString} methods declared in
 148  * {@code java.lang.Object} on a proxy instance will be encoded and
 149  * dispatched to the invocation handler&#39;s {@code invoke} method in
 150  * the same manner as interface method invocations are encoded and
 151  * dispatched, as described above.  The declaring class of the
 152  * {@code Method} object passed to {@code invoke} will be
 153  * {@code java.lang.Object}.  Other public methods of a proxy
 154  * instance inherited from {@code java.lang.Object} are not
 155  * overridden by a proxy class, so invocations of those methods behave
 156  * like they do for instances of {@code java.lang.Object}.
 157  * &lt;/ul&gt;
 158  *
<span class="line-modified"> 159  * &lt;h3&gt;&lt;a id=&quot;membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;&lt;/h3&gt;</span>
 160  *
 161  * The package and module to which a proxy class belongs are chosen such that
 162  * the accessibility of the proxy class is in line with the accessibility of
 163  * the proxy interfaces. Specifically, the package and the module membership
 164  * of a proxy class defined via the
 165  * {@link Proxy#getProxyClass(ClassLoader, Class[])} or
 166  * {@link Proxy#newProxyInstance(ClassLoader, Class[], InvocationHandler)}
 167  * methods is specified as follows:
 168  *
 169  * &lt;ol&gt;
 170  * &lt;li&gt;If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt;
 171  *     packages:
 172  * &lt;ol type=&quot;a&quot;&gt;
 173  * &lt;li&gt;if all the proxy interfaces are &lt;em&gt;public&lt;/em&gt;, then the proxy class is
 174  *     &lt;em&gt;public&lt;/em&gt; in a package exported by the
 175  *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified
 176  *     loader. The name of the package is unspecified.&lt;/li&gt;
 177  *
 178  * &lt;li&gt;if at least one of all the proxy interfaces is &lt;em&gt;non-public&lt;/em&gt;, then
 179  *     the proxy class is &lt;em&gt;non-public&lt;/em&gt; in the package and module of the
</pre>
<hr />
<pre>
 265  * checked exception types that are assignable to one of the exception
 266  * types in the {@code throws} clause of the method in &lt;i&gt;all&lt;/i&gt; of
 267  * the proxy interfaces that it can be invoked through.  If the
 268  * {@code invoke} method throws a checked exception that is not
 269  * assignable to any of the exception types declared by the method in one
 270  * of the proxy interfaces that it can be invoked through, then an
 271  * unchecked {@code UndeclaredThrowableException} will be thrown by
 272  * the invocation on the proxy instance.  This restriction means that not
 273  * all of the exception types returned by invoking
 274  * {@code getExceptionTypes} on the {@code Method} object
 275  * passed to the {@code invoke} method can necessarily be thrown
 276  * successfully by the {@code invoke} method.
 277  *
 278  * @author      Peter Jones
 279  * @see         InvocationHandler
 280  * @since       1.3
 281  * @revised 9
 282  * @spec JPMS
 283  */
 284 public class Proxy implements java.io.Serializable {

 285     private static final long serialVersionUID = -2222568056686623797L;
 286 
 287     /** parameter types of a proxy class constructor */
 288     private static final Class&lt;?&gt;[] constructorParams =
 289         { InvocationHandler.class };
 290 
 291     /**
 292      * a cache of proxy constructors with
 293      * {@link Constructor#setAccessible(boolean) accessible} flag already set
 294      */
 295     private static final ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache =
 296         new ClassLoaderValue&lt;&gt;();
 297 
 298     /**
 299      * the invocation handler for this proxy instance.
 300      * @serial
 301      */

 302     protected InvocationHandler h;
 303 
 304     /**
 305      * Prohibits instantiation.
 306      */
 307     private Proxy() {
 308     }
 309 
 310     /**
 311      * Constructs a new {@code Proxy} instance from a subclass
 312      * (typically, a dynamic proxy class) with the specified value
 313      * for its invocation handler.
 314      *
 315      * @param  h the invocation handler for this proxy instance
 316      *
 317      * @throws NullPointerException if the given invocation handler, {@code h},
 318      *         is {@code null}.
 319      */
 320     protected Proxy(InvocationHandler h) {
 321         Objects.requireNonNull(h);
</pre>
<hr />
<pre>
 514             if (m.isNamed()) {
 515                 if (!m.getDescriptor().packages().contains(proxyPkg)) {
 516                     throw new InternalError(proxyPkg + &quot; not exist in &quot; + m.getName());
 517                 }
 518             }
 519 
 520             /*
 521              * Choose a name for the proxy class to generate.
 522              */
 523             long num = nextUniqueNumber.getAndIncrement();
 524             String proxyName = proxyPkg.isEmpty()
 525                                     ? proxyClassNamePrefix + num
 526                                     : proxyPkg + &quot;.&quot; + proxyClassNamePrefix + num;
 527 
 528             ClassLoader loader = getLoader(m);
 529             trace(proxyName, m, loader, interfaces);
 530 
 531             /*
 532              * Generate the specified proxy class.
 533              */
<span class="line-modified"> 534             byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span>
<span class="line-removed"> 535                     proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span>
 536             try {
 537                 Class&lt;?&gt; pc = JLA.defineClass(loader, proxyName, proxyClassFile,
 538                                               null, &quot;__dynamic_proxy__&quot;);
 539                 reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);
 540                 return pc;
 541             } catch (ClassFormatError e) {
 542                 /*
 543                  * A ClassFormatError here means that (barring bugs in the
 544                  * proxy class generation code) there was some other
 545                  * invalid aspect of the arguments supplied to the proxy
 546                  * class creation (such as virtual machine limitations
 547                  * exceeded).
 548                  */
 549                 throw new IllegalArgumentException(e.toString());
 550             }
 551         }
 552 
 553         /**
 554          * Test if given class is a class defined by
 555          * {@link #defineProxyClass(Module, List)}
</pre>
<hr />
<pre>
1099          */
1100         if (!isProxyClass(proxy.getClass())) {
1101             throw new IllegalArgumentException(&quot;not a proxy instance&quot;);
1102         }
1103 
1104         final Proxy p = (Proxy) proxy;
1105         final InvocationHandler ih = p.h;
1106         if (System.getSecurityManager() != null) {
1107             Class&lt;?&gt; ihClass = ih.getClass();
1108             Class&lt;?&gt; caller = Reflection.getCallerClass();
1109             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),
1110                                                     ihClass.getClassLoader()))
1111             {
1112                 ReflectUtil.checkPackageAccess(ihClass);
1113             }
1114         }
1115 
1116         return ih;
1117     }
1118 
<span class="line-removed">1119     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</span>
1120     private static final String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;
1121 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  32 import java.util.Collections;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.IdentityHashMap;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Objects;
  39 import java.util.Set;
  40 import java.util.concurrent.atomic.AtomicInteger;
  41 import java.util.concurrent.atomic.AtomicLong;
  42 
  43 import jdk.internal.access.JavaLangAccess;
  44 import jdk.internal.access.SharedSecrets;
  45 import jdk.internal.loader.BootLoader;
  46 import jdk.internal.module.Modules;
  47 import jdk.internal.misc.VM;
  48 import jdk.internal.reflect.CallerSensitive;
  49 import jdk.internal.reflect.Reflection;
  50 import jdk.internal.loader.ClassLoaderValue;
  51 import sun.reflect.misc.ReflectUtil;
<span class="line-added">  52 import sun.security.action.GetBooleanAction;</span>
  53 import sun.security.action.GetPropertyAction;
  54 import sun.security.util.SecurityConstants;
  55 
  56 import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;
  57 
  58 
  59 /**
  60  *
  61  * {@code Proxy} provides static methods for creating objects that act like instances
  62  * of interfaces but allow for customized method invocation.
  63  * To create a proxy instance for some interface {@code Foo}:
  64  * &lt;pre&gt;{@code
  65  *     InvocationHandler handler = new MyInvocationHandler(...);
  66  *     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
  67  *                                          new Class&lt;?&gt;[] { Foo.class },
  68  *                                          handler);
  69  * }&lt;/pre&gt;
  70  *
  71  * &lt;p&gt;
  72  * A &lt;em&gt;proxy class&lt;/em&gt; is a class created at runtime that implements a specified
</pre>
<hr />
<pre>
  83  * containing the arguments.  The invocation handler processes the
  84  * encoded method invocation as appropriate and the result that it
  85  * returns will be returned as the result of the method invocation on
  86  * the proxy instance.
  87  *
  88  * &lt;p&gt;A proxy class has the following properties:
  89  *
  90  * &lt;ul&gt;
  91  * &lt;li&gt;The unqualified name of a proxy class is unspecified.  The space
  92  * of class names that begin with the string {@code &quot;$Proxy&quot;}
  93  * should be, however, reserved for proxy classes.
  94  *
  95  * &lt;li&gt;The package and module in which a proxy class is defined is specified
  96  * &lt;a href=&quot;#membership&quot;&gt;below&lt;/a&gt;.
  97  *
  98  * &lt;li&gt;A proxy class is &lt;em&gt;final and non-abstract&lt;/em&gt;.
  99  *
 100  * &lt;li&gt;A proxy class extends {@code java.lang.reflect.Proxy}.
 101  *
 102  * &lt;li&gt;A proxy class implements exactly the interfaces specified at its
<span class="line-modified"> 103  * creation, in the same order. Invoking {@link Class#getInterfaces() getInterfaces}</span>
 104  * on its {@code Class} object will return an array containing the same
 105  * list of interfaces (in the order specified at its creation), invoking
 106  * {@link Class#getMethods getMethods} on its {@code Class} object will return
 107  * an array of {@code Method} objects that include all of the
 108  * methods in those interfaces, and invoking {@code getMethod} will
 109  * find methods in the proxy interfaces as would be expected.
 110  *
 111  * &lt;li&gt;The {@link java.security.ProtectionDomain} of a proxy class
 112  * is the same as that of system classes loaded by the bootstrap class
 113  * loader, such as {@code java.lang.Object}, because the code for a
 114  * proxy class is generated by trusted system code.  This protection
 115  * domain will typically be granted {@code java.security.AllPermission}.
 116  *
 117  * &lt;li&gt;The {@link Proxy#isProxyClass Proxy.isProxyClass} method can be used
 118  * to determine if a given class is a proxy class.
 119  * &lt;/ul&gt;
 120  *
 121  * &lt;p&gt;A proxy instance has the following properties:
 122  *
 123  * &lt;ul&gt;
</pre>
<hr />
<pre>
 140  * passed as its argument.
 141  *
 142  * &lt;li&gt;An interface method invocation on a proxy instance will be
 143  * encoded and dispatched to the invocation handler&#39;s {@link
 144  * InvocationHandler#invoke invoke} method as described in the
 145  * documentation for that method.
 146  *
 147  * &lt;li&gt;An invocation of the {@code hashCode},
 148  * {@code equals}, or {@code toString} methods declared in
 149  * {@code java.lang.Object} on a proxy instance will be encoded and
 150  * dispatched to the invocation handler&#39;s {@code invoke} method in
 151  * the same manner as interface method invocations are encoded and
 152  * dispatched, as described above.  The declaring class of the
 153  * {@code Method} object passed to {@code invoke} will be
 154  * {@code java.lang.Object}.  Other public methods of a proxy
 155  * instance inherited from {@code java.lang.Object} are not
 156  * overridden by a proxy class, so invocations of those methods behave
 157  * like they do for instances of {@code java.lang.Object}.
 158  * &lt;/ul&gt;
 159  *
<span class="line-modified"> 160  * &lt;h2&gt;&lt;a id=&quot;membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;&lt;/h2&gt;</span>
 161  *
 162  * The package and module to which a proxy class belongs are chosen such that
 163  * the accessibility of the proxy class is in line with the accessibility of
 164  * the proxy interfaces. Specifically, the package and the module membership
 165  * of a proxy class defined via the
 166  * {@link Proxy#getProxyClass(ClassLoader, Class[])} or
 167  * {@link Proxy#newProxyInstance(ClassLoader, Class[], InvocationHandler)}
 168  * methods is specified as follows:
 169  *
 170  * &lt;ol&gt;
 171  * &lt;li&gt;If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt;
 172  *     packages:
 173  * &lt;ol type=&quot;a&quot;&gt;
 174  * &lt;li&gt;if all the proxy interfaces are &lt;em&gt;public&lt;/em&gt;, then the proxy class is
 175  *     &lt;em&gt;public&lt;/em&gt; in a package exported by the
 176  *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified
 177  *     loader. The name of the package is unspecified.&lt;/li&gt;
 178  *
 179  * &lt;li&gt;if at least one of all the proxy interfaces is &lt;em&gt;non-public&lt;/em&gt;, then
 180  *     the proxy class is &lt;em&gt;non-public&lt;/em&gt; in the package and module of the
</pre>
<hr />
<pre>
 266  * checked exception types that are assignable to one of the exception
 267  * types in the {@code throws} clause of the method in &lt;i&gt;all&lt;/i&gt; of
 268  * the proxy interfaces that it can be invoked through.  If the
 269  * {@code invoke} method throws a checked exception that is not
 270  * assignable to any of the exception types declared by the method in one
 271  * of the proxy interfaces that it can be invoked through, then an
 272  * unchecked {@code UndeclaredThrowableException} will be thrown by
 273  * the invocation on the proxy instance.  This restriction means that not
 274  * all of the exception types returned by invoking
 275  * {@code getExceptionTypes} on the {@code Method} object
 276  * passed to the {@code invoke} method can necessarily be thrown
 277  * successfully by the {@code invoke} method.
 278  *
 279  * @author      Peter Jones
 280  * @see         InvocationHandler
 281  * @since       1.3
 282  * @revised 9
 283  * @spec JPMS
 284  */
 285 public class Proxy implements java.io.Serializable {
<span class="line-added"> 286     @java.io.Serial</span>
 287     private static final long serialVersionUID = -2222568056686623797L;
 288 
 289     /** parameter types of a proxy class constructor */
 290     private static final Class&lt;?&gt;[] constructorParams =
 291         { InvocationHandler.class };
 292 
 293     /**
 294      * a cache of proxy constructors with
 295      * {@link Constructor#setAccessible(boolean) accessible} flag already set
 296      */
 297     private static final ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache =
 298         new ClassLoaderValue&lt;&gt;();
 299 
 300     /**
 301      * the invocation handler for this proxy instance.
 302      * @serial
 303      */
<span class="line-added"> 304     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 305     protected InvocationHandler h;
 306 
 307     /**
 308      * Prohibits instantiation.
 309      */
 310     private Proxy() {
 311     }
 312 
 313     /**
 314      * Constructs a new {@code Proxy} instance from a subclass
 315      * (typically, a dynamic proxy class) with the specified value
 316      * for its invocation handler.
 317      *
 318      * @param  h the invocation handler for this proxy instance
 319      *
 320      * @throws NullPointerException if the given invocation handler, {@code h},
 321      *         is {@code null}.
 322      */
 323     protected Proxy(InvocationHandler h) {
 324         Objects.requireNonNull(h);
</pre>
<hr />
<pre>
 517             if (m.isNamed()) {
 518                 if (!m.getDescriptor().packages().contains(proxyPkg)) {
 519                     throw new InternalError(proxyPkg + &quot; not exist in &quot; + m.getName());
 520                 }
 521             }
 522 
 523             /*
 524              * Choose a name for the proxy class to generate.
 525              */
 526             long num = nextUniqueNumber.getAndIncrement();
 527             String proxyName = proxyPkg.isEmpty()
 528                                     ? proxyClassNamePrefix + num
 529                                     : proxyPkg + &quot;.&quot; + proxyClassNamePrefix + num;
 530 
 531             ClassLoader loader = getLoader(m);
 532             trace(proxyName, m, loader, interfaces);
 533 
 534             /*
 535              * Generate the specified proxy class.
 536              */
<span class="line-modified"> 537             byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags);</span>

 538             try {
 539                 Class&lt;?&gt; pc = JLA.defineClass(loader, proxyName, proxyClassFile,
 540                                               null, &quot;__dynamic_proxy__&quot;);
 541                 reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);
 542                 return pc;
 543             } catch (ClassFormatError e) {
 544                 /*
 545                  * A ClassFormatError here means that (barring bugs in the
 546                  * proxy class generation code) there was some other
 547                  * invalid aspect of the arguments supplied to the proxy
 548                  * class creation (such as virtual machine limitations
 549                  * exceeded).
 550                  */
 551                 throw new IllegalArgumentException(e.toString());
 552             }
 553         }
 554 
 555         /**
 556          * Test if given class is a class defined by
 557          * {@link #defineProxyClass(Module, List)}
</pre>
<hr />
<pre>
1101          */
1102         if (!isProxyClass(proxy.getClass())) {
1103             throw new IllegalArgumentException(&quot;not a proxy instance&quot;);
1104         }
1105 
1106         final Proxy p = (Proxy) proxy;
1107         final InvocationHandler ih = p.h;
1108         if (System.getSecurityManager() != null) {
1109             Class&lt;?&gt; ihClass = ih.getClass();
1110             Class&lt;?&gt; caller = Reflection.getCallerClass();
1111             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),
1112                                                     ihClass.getClassLoader()))
1113             {
1114                 ReflectUtil.checkPackageAccess(ihClass);
1115             }
1116         }
1117 
1118         return ih;
1119     }
1120 

1121     private static final String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;
1122 }
</pre>
</td>
</tr>
</table>
<center><a href="Modifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ProxyGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
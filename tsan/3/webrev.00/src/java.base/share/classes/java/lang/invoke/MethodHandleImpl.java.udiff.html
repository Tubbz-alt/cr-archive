<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandle.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleInfo.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,10 +39,11 @@</span>
  import sun.invoke.util.ValueConversions;
  import sun.invoke.util.VerifyType;
  import sun.invoke.util.Wrapper;
  
  import java.lang.reflect.Array;
<span class="udiff-line-added">+ import java.nio.ByteOrder;</span>
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.HashMap;
  import java.util.Iterator;
  import java.util.List;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57,11 +58,12 @@</span>
  
  /**
   * Trusted implementation code for MethodHandle.
   * @author jrose
   */
<span class="udiff-line-modified-removed">- /*non-public*/ abstract class MethodHandleImpl {</span>
<span class="udiff-line-modified-added">+ /*non-public*/</span>
<span class="udiff-line-added">+ abstract class MethodHandleImpl {</span>
  
      /// Factory methods to create method handles:
  
      static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
          if (arrayClass == Object[].class) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -681,24 +683,22 @@</span>
          LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
          return SimpleMethodHandle.make(srcType, form);
      }
  
      @Hidden
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {</span>
<span class="udiff-line-modified-added">+     static MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {</span>
          if (testResult) {
              return target;
          } else {
              return fallback;
          }
      }
  
      // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
      @Hidden
      @jdk.internal.HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     boolean profileBoolean(boolean result, int[] counters) {</span>
<span class="udiff-line-modified-added">+     static boolean profileBoolean(boolean result, int[] counters) {</span>
          // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
          int idx = result ? 1 : 0;
          try {
              counters[idx] = Math.addExact(counters[idx], 1);
          } catch (ArithmeticException e) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -709,17 +709,15 @@</span>
      }
  
      // Intrinsified by C2. Returns true if obj is a compile-time constant.
      @Hidden
      @jdk.internal.HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     boolean isCompileConstant(Object obj) {</span>
<span class="udiff-line-modified-added">+     static boolean isCompileConstant(Object obj) {</span>
          return false;
      }
  
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle makeGuardWithTest(MethodHandle test,</span>
<span class="udiff-line-modified-added">+     static MethodHandle makeGuardWithTest(MethodHandle test,</span>
                                     MethodHandle target,
                                     MethodHandle fallback) {
          MethodType type = target.type();
          assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
          MethodType basicType = type.basicType();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -742,12 +740,11 @@</span>
          assert(mh.type() == type);
          return mh;
      }
  
  
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle profile(MethodHandle target) {</span>
<span class="udiff-line-modified-added">+     static MethodHandle profile(MethodHandle target) {</span>
          if (DONT_INLINE_THRESHOLD &gt;= 0) {
              return makeBlockInliningWrapper(target);
          } else {
              return target;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -755,12 +752,11 @@</span>
  
      /**
       * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
       * Corresponding LambdaForm has @DontInline when compiled into bytecode.
       */
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle makeBlockInliningWrapper(MethodHandle target) {</span>
<span class="udiff-line-modified-added">+     static MethodHandle makeBlockInliningWrapper(MethodHandle target) {</span>
          LambdaForm lform;
          if (DONT_INLINE_THRESHOLD &gt; 0) {
              lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
          } else {
              lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -893,12 +889,11 @@</span>
                  throw newInternalError(ex);
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     LambdaForm makeGuardWithTestForm(MethodType basicType) {</span>
<span class="udiff-line-modified-added">+     static LambdaForm makeGuardWithTestForm(MethodType basicType) {</span>
          LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
          if (lform != null)  return lform;
          final int THIS_MH      = 0;  // the BMH_LLL
          final int ARG_BASE     = 1;  // start of incoming arguments
          final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1024,12 +1019,11 @@</span>
          lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
  
          return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
      }
  
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle makeGuardWithCatch(MethodHandle target,</span>
<span class="udiff-line-modified-added">+     static MethodHandle makeGuardWithCatch(MethodHandle target,</span>
                                      Class&lt;? extends Throwable&gt; exType,
                                      MethodHandle catcher) {
          MethodType type = target.type();
          LambdaForm form = makeGuardWithCatchForm(type.basicType());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1076,12 +1070,11 @@</span>
          System.arraycopy(elems, 0, newArray, 0, nElems);
          System.arraycopy(array, 0, newArray, nElems, nArray);
          return newArray;
      }
  
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle throwException(MethodType type) {</span>
<span class="udiff-line-modified-added">+     static MethodHandle throwException(MethodType type) {</span>
          assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
          int arity = type.parameterCount();
          if (arity &gt; 1) {
              MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
              mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1135,22 +1128,20 @@</span>
       * as hostClass.
       * This is an expensive no-op unless the method which is called
       * is sensitive to its caller.  A small number of system methods
       * are in this category, including Class.forName and Method.invoke.
       */
<span class="udiff-line-modified-removed">-     static</span>
<span class="udiff-line-removed">-     MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>
<span class="udiff-line-modified-added">+     static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>
          return BindCaller.bindCaller(mh, hostClass);
      }
  
      // Put the whole mess into its own nested class.
      // That way we can lazily load the code and set up the constants.
      private static class BindCaller {
          private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
  
<span class="udiff-line-modified-removed">-         static</span>
<span class="udiff-line-removed">-         MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>
<span class="udiff-line-modified-added">+         static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</span>
              // Code in the boot layer should now be careful while creating method handles or
              // functional interface instances created from method references to @CallerSensitive  methods,
              // it needs to be ensured the handles or interface instances are kept safe and are not passed
              // from the boot layer to untrusted code.
              if (hostClass == null
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1663,11 +1654,12 @@</span>
          Class&lt;?&gt; elemType = arrayType.getComponentType();
          assert(elemType.isPrimitive());
          return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
      }
  
<span class="udiff-line-modified-removed">-     /*non-public*/ static void assertSame(Object mh1, Object mh2) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static void assertSame(Object mh1, Object mh2) {</span>
          if (mh1 != mh2) {
              String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
                      mh1, ((MethodHandle)mh1).form,
                      mh2, ((MethodHandle)mh2).form);
              throw newInternalError(msg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1797,10 +1789,48 @@</span>
                  return GenerateJLIClassesHelper
                          .generateInvokersHolderClassBytes(className,
                                  invokerMethodTypes, callSiteMethodTypes);
              }
  
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public VarHandle memoryAddressViewVarHandle(Class&lt;?&gt; carrier, long alignmentMask,</span>
<span class="udiff-line-added">+                                                         ByteOrder order, long offset, long[] strides) {</span>
<span class="udiff-line-added">+                 return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public Class&lt;?&gt; memoryAddressCarrier(VarHandle handle) {</span>
<span class="udiff-line-added">+                 return checkMemAccessHandle(handle).carrier();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public long memoryAddressAlignmentMask(VarHandle handle) {</span>
<span class="udiff-line-added">+                 return checkMemAccessHandle(handle).alignmentMask;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public ByteOrder memoryAddressByteOrder(VarHandle handle) {</span>
<span class="udiff-line-added">+                 return checkMemAccessHandle(handle).be ?</span>
<span class="udiff-line-added">+                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public long memoryAddressOffset(VarHandle handle) {</span>
<span class="udiff-line-added">+                 return checkMemAccessHandle(handle).offset;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public long[] memoryAddressStrides(VarHandle handle) {</span>
<span class="udiff-line-added">+                 return checkMemAccessHandle(handle).strides();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             private VarHandleMemoryAddressBase checkMemAccessHandle(VarHandle handle) {</span>
<span class="udiff-line-added">+                 if (!(handle instanceof VarHandleMemoryAddressBase)) {</span>
<span class="udiff-line-added">+                     throw new IllegalArgumentException(&quot;Not a memory access varhandle: &quot; + handle);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return (VarHandleMemoryAddressBase) handle;</span>
<span class="udiff-line-added">+             }</span>
          });
      }
  
      /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
      private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
</pre>
<center><a href="MethodHandle.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleInfo.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/math/BigInteger.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="BigDecimal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MathContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/math/BigInteger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  25 
  26 /*
  27  * Portions Copyright (c) 1995  Colin Plumb.  All rights reserved.
  28  */
  29 
  30 package java.math;
  31 
  32 import java.io.IOException;
  33 import java.io.ObjectInputStream;
  34 import java.io.ObjectOutputStream;
  35 import java.io.ObjectStreamField;
  36 import java.util.Arrays;
  37 import java.util.Objects;
  38 import java.util.Random;
  39 import java.util.concurrent.ThreadLocalRandom;
  40 
  41 import jdk.internal.math.DoubleConsts;
  42 import jdk.internal.math.FloatConsts;
  43 import jdk.internal.HotSpotIntrinsicCandidate;
  44 import jdk.internal.vm.annotation.Stable;

  45 
  46 /**
  47  * Immutable arbitrary-precision integers.  All operations behave as if
  48  * BigIntegers were represented in two&#39;s-complement notation (like Java&#39;s
  49  * primitive integer types).  BigInteger provides analogues to all of Java&#39;s
  50  * primitive integer operators, and all relevant methods from java.lang.Math.
  51  * Additionally, BigInteger provides operations for modular arithmetic, GCD
  52  * calculation, primality testing, prime generation, bit manipulation,
  53  * and a few other miscellaneous operations.
  54  *
  55  * &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java&#39;s integer
  56  * arithmetic operators, as defined in &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
  57  * For example, division by zero throws an {@code ArithmeticException}, and
  58  * division of a negative by a positive yields a negative (or zero) remainder.
  59  *
  60  * &lt;p&gt;Semantics of shift operations extend those of Java&#39;s shift operators
  61  * to allow for negative shift distances.  A right-shift with a negative
  62  * shift distance results in a left shift, and vice-versa.  The unsigned
  63  * right shift operator ({@code &gt;&gt;&gt;}) is omitted since this operation
  64  * only makes sense for a fixed sized word and not for a
</pre>
<hr />
<pre>
2604         if (n &lt;= (32-bitsInHighWord)) {
2605             primitiveLeftShift(a, len, nBits);
2606             return a;
2607         } else { // Array must be resized
2608             if (nBits &lt;= (32-bitsInHighWord)) {
2609                 int result[] = new int[nInts+len];
2610                 System.arraycopy(a, 0, result, 0, len);
2611                 primitiveLeftShift(result, result.length, nBits);
2612                 return result;
2613             } else {
2614                 int result[] = new int[nInts+len+1];
2615                 System.arraycopy(a, 0, result, 0, len);
2616                 primitiveRightShift(result, result.length, 32 - nBits);
2617                 return result;
2618             }
2619         }
2620     }
2621 
2622     // shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32
2623     static void primitiveRightShift(int[] a, int len, int n) {
<span class="line-modified">2624         int n2 = 32 - n;</span>
<span class="line-modified">2625         for (int i=len-1, c=a[i]; i &gt; 0; i--) {</span>
<span class="line-removed">2626             int b = c;</span>
<span class="line-removed">2627             c = a[i-1];</span>
<span class="line-removed">2628             a[i] = (c &lt;&lt; n2) | (b &gt;&gt;&gt; n);</span>
<span class="line-removed">2629         }</span>
2630         a[0] &gt;&gt;&gt;= n;
2631     }
2632 
2633     // shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32
2634     static void primitiveLeftShift(int[] a, int len, int n) {
2635         if (len == 0 || n == 0)
2636             return;
<span class="line-modified">2637 </span>
<span class="line-modified">2638         int n2 = 32 - n;</span>
<span class="line-removed">2639         for (int i=0, c=a[i], m=i+len-1; i &lt; m; i++) {</span>
<span class="line-removed">2640             int b = c;</span>
<span class="line-removed">2641             c = a[i+1];</span>
<span class="line-removed">2642             a[i] = (b &lt;&lt; n) | (c &gt;&gt;&gt; n2);</span>
<span class="line-removed">2643         }</span>
2644         a[len-1] &lt;&lt;= n;
2645     }
2646 
2647     /**
2648      * Calculate bitlength of contents of the first len elements an int array,
2649      * assuming there are no leading zero ints.
2650      */
2651     private static int bitLength(int[] val, int len) {
2652         if (len == 0)
2653             return 0;
2654         return ((len - 1) &lt;&lt; 5) + bitLengthForInt(val[0]);
2655     }
2656 
2657     /**
2658      * Returns a BigInteger whose value is the absolute value of this
2659      * BigInteger.
2660      *
2661      * @return {@code abs(this)}
2662      */
2663     public BigInteger abs() {
</pre>
<hr />
<pre>
3336      */
3337     private static int[] shiftLeft(int[] mag, int n) {
3338         int nInts = n &gt;&gt;&gt; 5;
3339         int nBits = n &amp; 0x1f;
3340         int magLen = mag.length;
3341         int newMag[] = null;
3342 
3343         if (nBits == 0) {
3344             newMag = new int[magLen + nInts];
3345             System.arraycopy(mag, 0, newMag, 0, magLen);
3346         } else {
3347             int i = 0;
3348             int nBits2 = 32 - nBits;
3349             int highBits = mag[0] &gt;&gt;&gt; nBits2;
3350             if (highBits != 0) {
3351                 newMag = new int[magLen + nInts + 1];
3352                 newMag[i++] = highBits;
3353             } else {
3354                 newMag = new int[magLen + nInts];
3355             }
<span class="line-modified">3356             int j=0;</span>
<span class="line-modified">3357             while (j &lt; magLen-1)</span>
<span class="line-modified">3358                 newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2;</span>
<span class="line-modified">3359             newMag[i] = mag[j] &lt;&lt; nBits;</span>

3360         }
3361         return newMag;
3362     }
3363 










3364     /**
3365      * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign
3366      * extension is performed.  The shift distance, {@code n}, may be
3367      * negative, in which case this method performs a left shift.
3368      * (Computes &lt;code&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;.)
3369      *
3370      * @param  n shift distance, in bits.
3371      * @return {@code this &gt;&gt; n}
3372      * @see #shiftLeft
3373      */
3374     public BigInteger shiftRight(int n) {
3375         if (signum == 0)
3376             return ZERO;
3377         if (n &gt; 0) {
3378             return shiftRightImpl(n);
3379         } else if (n == 0) {
3380             return this;
3381         } else {
3382             // Possible int overflow in {@code -n} is not a trouble,
3383             // because shiftLeft considers its argument unsigned
</pre>
<hr />
<pre>
3398         int nBits = n &amp; 0x1f;
3399         int magLen = mag.length;
3400         int newMag[] = null;
3401 
3402         // Special case: entire contents shifted off the end
3403         if (nInts &gt;= magLen)
3404             return (signum &gt;= 0 ? ZERO : negConst[1]);
3405 
3406         if (nBits == 0) {
3407             int newMagLen = magLen - nInts;
3408             newMag = Arrays.copyOf(mag, newMagLen);
3409         } else {
3410             int i = 0;
3411             int highBits = mag[0] &gt;&gt;&gt; nBits;
3412             if (highBits != 0) {
3413                 newMag = new int[magLen - nInts];
3414                 newMag[i++] = highBits;
3415             } else {
3416                 newMag = new int[magLen - nInts -1];
3417             }
<span class="line-modified">3418 </span>
<span class="line-modified">3419             int nBits2 = 32 - nBits;</span>
<span class="line-modified">3420             int j=0;</span>
<span class="line-modified">3421             while (j &lt; magLen - nInts - 1)</span>
<span class="line-removed">3422                 newMag[i++] = (mag[j++] &lt;&lt; nBits2) | (mag[j] &gt;&gt;&gt; nBits);</span>
3423         }
3424 
3425         if (signum &lt; 0) {
3426             // Find out whether any one-bits were shifted off the end.
3427             boolean onesLost = false;
3428             for (int i=magLen-1, j=magLen-nInts; i &gt;= j &amp;&amp; !onesLost; i--)
3429                 onesLost = (mag[i] != 0);
3430             if (!onesLost &amp;&amp; nBits != 0)
3431                 onesLost = (mag[magLen - nInts - 1] &lt;&lt; (32 - nBits) != 0);
3432 
3433             if (onesLost)
3434                 newMag = javaIncrement(newMag);
3435         }
3436 
3437         return new BigInteger(newMag, signum);
3438     }
3439 











3440     int[] javaIncrement(int[] val) {
3441         int lastSum = 0;
3442         for (int i=val.length-1;  i &gt;= 0 &amp;&amp; lastSum == 0; i--)
3443             lastSum = (val[i] += 1);
3444         if (lastSum == 0) {
3445             val = new int[val.length+1];
3446             val[0] = 1;
3447         }
3448         return val;
3449     }
3450 
3451     // Bitwise Operations
3452 
3453     /**
3454      * Returns a BigInteger whose value is {@code (this &amp; val)}.  (This
3455      * method returns a negative BigInteger if and only if this and val are
3456      * both negative.)
3457      *
3458      * @param val value to be AND&#39;ed with this BigInteger.
3459      * @return {@code this &amp; val}
</pre>
<hr />
<pre>
4587     * least significant). If the magnitude is zero, return value is undefined.
4588     *
4589     * &lt;p&gt;Note: never used for a BigInteger with a magnitude of zero.
4590     * @see #getInt.
4591     */
4592     private int firstNonzeroIntNum() {
4593         int fn = firstNonzeroIntNumPlusTwo - 2;
4594         if (fn == -2) { // firstNonzeroIntNum not initialized yet
4595             // Search for the first nonzero int
4596             int i;
4597             int mlen = mag.length;
4598             for (i = mlen - 1; i &gt;= 0 &amp;&amp; mag[i] == 0; i--)
4599                 ;
4600             fn = mlen - i - 1;
4601             firstNonzeroIntNumPlusTwo = fn + 2; // offset by two to initialize
4602         }
4603         return fn;
4604     }
4605 
4606     /** use serialVersionUID from JDK 1.1. for interoperability */

4607     private static final long serialVersionUID = -8287574255936472291L;
4608 
4609     /**
4610      * Serializable fields for BigInteger.
4611      *
4612      * @serialField signum  int
4613      *              signum of this BigInteger
4614      * @serialField magnitude byte[]
4615      *              magnitude array of this BigInteger
4616      * @serialField bitCount  int
4617      *              appears in the serialized form for backward compatibility
4618      * @serialField bitLength int
4619      *              appears in the serialized form for backward compatibility
4620      * @serialField firstNonzeroByteNum int
4621      *              appears in the serialized form for backward compatibility
4622      * @serialField lowestSetBit int
4623      *              appears in the serialized form for backward compatibility
4624      */

4625     private static final ObjectStreamField[] serialPersistentFields = {
4626         new ObjectStreamField(&quot;signum&quot;, Integer.TYPE),
4627         new ObjectStreamField(&quot;magnitude&quot;, byte[].class),
4628         new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE),
4629         new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE),
4630         new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE),
4631         new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)
4632         };
4633 
4634     /**
4635      * Reconstitute the {@code BigInteger} instance from a stream (that is,
4636      * deserialize it). The magnitude is read in as an array of bytes
4637      * for historical reasons, but it is converted to an array of ints
4638      * and the byte array is discarded.
4639      * Note:
4640      * The current convention is to initialize the cache fields, bitCountPlusOne,
4641      * bitLengthPlusOne and lowestSetBitPlusTwo, to 0 rather than some other
4642      * marker value. Therefore, no explicit action to set these fields needs to
4643      * be taken in readObject because those fields already have a 0 value by
4644      * default since defaultReadObject is not being used.
4645      */

4646     private void readObject(java.io.ObjectInputStream s)
4647         throws java.io.IOException, ClassNotFoundException {
4648         // prepare to read the alternate persistent fields
4649         ObjectInputStream.GetField fields = s.readFields();
4650 
4651         // Read the alternate persistent fields that we care about
4652         int sign = fields.get(&quot;signum&quot;, -2);
4653         byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, null);
4654 
4655         // Validate signum
4656         if (sign &lt; -1 || sign &gt; 1) {
4657             String message = &quot;BigInteger: Invalid signum value&quot;;
4658             if (fields.defaulted(&quot;signum&quot;))
4659                 message = &quot;BigInteger: Signum not present in stream&quot;;
4660             throw new java.io.StreamCorruptedException(message);
4661         }
4662         int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
4663         if ((mag.length == 0) != (sign == 0)) {
4664             String message = &quot;BigInteger: signum-magnitude mismatch&quot;;
4665             if (fields.defaulted(&quot;magnitude&quot;))
</pre>
<hr />
<pre>
4692 
4693         static void putSign(BigInteger bi, int sign) {
4694             unsafe.putInt(bi, signumOffset, sign);
4695         }
4696 
4697         static void putMag(BigInteger bi, int[] magnitude) {
4698             unsafe.putReference(bi, magOffset, magnitude);
4699         }
4700     }
4701 
4702     /**
4703      * Save the {@code BigInteger} instance to a stream.  The magnitude of a
4704      * {@code BigInteger} is serialized as a byte array for historical reasons.
4705      * To maintain compatibility with older implementations, the integers
4706      * -1, -1, -2, and -2 are written as the values of the obsolete fields
4707      * {@code bitCount}, {@code bitLength}, {@code lowestSetBit}, and
4708      * {@code firstNonzeroByteNum}, respectively.  These values are compatible
4709      * with older implementations, but will be ignored by current
4710      * implementations.
4711      */

4712     private void writeObject(ObjectOutputStream s) throws IOException {
4713         // set the values of the Serializable fields
4714         ObjectOutputStream.PutField fields = s.putFields();
4715         fields.put(&quot;signum&quot;, signum);
4716         fields.put(&quot;magnitude&quot;, magSerializedForm());
4717         // The values written for cached fields are compatible with older
4718         // versions, but are ignored in readObject so don&#39;t otherwise matter.
4719         fields.put(&quot;bitCount&quot;, -1);
4720         fields.put(&quot;bitLength&quot;, -1);
4721         fields.put(&quot;lowestSetBit&quot;, -2);
4722         fields.put(&quot;firstNonzeroByteNum&quot;, -2);
4723 
4724         // save them
4725         s.writeFields();
4726     }
4727 
4728     /**
4729      * Returns the mag array as an array of bytes.
4730      */
4731     private byte[] magSerializedForm() {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  25 
  26 /*
  27  * Portions Copyright (c) 1995  Colin Plumb.  All rights reserved.
  28  */
  29 
  30 package java.math;
  31 
  32 import java.io.IOException;
  33 import java.io.ObjectInputStream;
  34 import java.io.ObjectOutputStream;
  35 import java.io.ObjectStreamField;
  36 import java.util.Arrays;
  37 import java.util.Objects;
  38 import java.util.Random;
  39 import java.util.concurrent.ThreadLocalRandom;
  40 
  41 import jdk.internal.math.DoubleConsts;
  42 import jdk.internal.math.FloatConsts;
  43 import jdk.internal.HotSpotIntrinsicCandidate;
  44 import jdk.internal.vm.annotation.Stable;
<span class="line-added">  45 import jdk.internal.vm.annotation.ForceInline;</span>
  46 
  47 /**
  48  * Immutable arbitrary-precision integers.  All operations behave as if
  49  * BigIntegers were represented in two&#39;s-complement notation (like Java&#39;s
  50  * primitive integer types).  BigInteger provides analogues to all of Java&#39;s
  51  * primitive integer operators, and all relevant methods from java.lang.Math.
  52  * Additionally, BigInteger provides operations for modular arithmetic, GCD
  53  * calculation, primality testing, prime generation, bit manipulation,
  54  * and a few other miscellaneous operations.
  55  *
  56  * &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java&#39;s integer
  57  * arithmetic operators, as defined in &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
  58  * For example, division by zero throws an {@code ArithmeticException}, and
  59  * division of a negative by a positive yields a negative (or zero) remainder.
  60  *
  61  * &lt;p&gt;Semantics of shift operations extend those of Java&#39;s shift operators
  62  * to allow for negative shift distances.  A right-shift with a negative
  63  * shift distance results in a left shift, and vice-versa.  The unsigned
  64  * right shift operator ({@code &gt;&gt;&gt;}) is omitted since this operation
  65  * only makes sense for a fixed sized word and not for a
</pre>
<hr />
<pre>
2605         if (n &lt;= (32-bitsInHighWord)) {
2606             primitiveLeftShift(a, len, nBits);
2607             return a;
2608         } else { // Array must be resized
2609             if (nBits &lt;= (32-bitsInHighWord)) {
2610                 int result[] = new int[nInts+len];
2611                 System.arraycopy(a, 0, result, 0, len);
2612                 primitiveLeftShift(result, result.length, nBits);
2613                 return result;
2614             } else {
2615                 int result[] = new int[nInts+len+1];
2616                 System.arraycopy(a, 0, result, 0, len);
2617                 primitiveRightShift(result, result.length, 32 - nBits);
2618                 return result;
2619             }
2620         }
2621     }
2622 
2623     // shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32
2624     static void primitiveRightShift(int[] a, int len, int n) {
<span class="line-modified">2625         Objects.checkFromToIndex(0, len, a.length);</span>
<span class="line-modified">2626         shiftRightImplWorker(a, a, 1, n, len-1);</span>




2627         a[0] &gt;&gt;&gt;= n;
2628     }
2629 
2630     // shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32
2631     static void primitiveLeftShift(int[] a, int len, int n) {
2632         if (len == 0 || n == 0)
2633             return;
<span class="line-modified">2634         Objects.checkFromToIndex(0, len, a.length);</span>
<span class="line-modified">2635         shiftLeftImplWorker(a, a, 0, n, len-1);</span>





2636         a[len-1] &lt;&lt;= n;
2637     }
2638 
2639     /**
2640      * Calculate bitlength of contents of the first len elements an int array,
2641      * assuming there are no leading zero ints.
2642      */
2643     private static int bitLength(int[] val, int len) {
2644         if (len == 0)
2645             return 0;
2646         return ((len - 1) &lt;&lt; 5) + bitLengthForInt(val[0]);
2647     }
2648 
2649     /**
2650      * Returns a BigInteger whose value is the absolute value of this
2651      * BigInteger.
2652      *
2653      * @return {@code abs(this)}
2654      */
2655     public BigInteger abs() {
</pre>
<hr />
<pre>
3328      */
3329     private static int[] shiftLeft(int[] mag, int n) {
3330         int nInts = n &gt;&gt;&gt; 5;
3331         int nBits = n &amp; 0x1f;
3332         int magLen = mag.length;
3333         int newMag[] = null;
3334 
3335         if (nBits == 0) {
3336             newMag = new int[magLen + nInts];
3337             System.arraycopy(mag, 0, newMag, 0, magLen);
3338         } else {
3339             int i = 0;
3340             int nBits2 = 32 - nBits;
3341             int highBits = mag[0] &gt;&gt;&gt; nBits2;
3342             if (highBits != 0) {
3343                 newMag = new int[magLen + nInts + 1];
3344                 newMag[i++] = highBits;
3345             } else {
3346                 newMag = new int[magLen + nInts];
3347             }
<span class="line-modified">3348             int numIter = magLen - 1;</span>
<span class="line-modified">3349             Objects.checkFromToIndex(0, numIter + 1, mag.length);</span>
<span class="line-modified">3350             Objects.checkFromToIndex(i, numIter + i + 1, newMag.length);</span>
<span class="line-modified">3351             shiftLeftImplWorker(newMag, mag, i, nBits, numIter);</span>
<span class="line-added">3352             newMag[numIter + i] = mag[numIter] &lt;&lt; nBits;</span>
3353         }
3354         return newMag;
3355     }
3356 
<span class="line-added">3357     @ForceInline</span>
<span class="line-added">3358     @HotSpotIntrinsicCandidate</span>
<span class="line-added">3359     private static void shiftLeftImplWorker(int[] newArr, int[] oldArr, int newIdx, int shiftCount, int numIter) {</span>
<span class="line-added">3360         int shiftCountRight = 32 - shiftCount;</span>
<span class="line-added">3361         int oldIdx = 0;</span>
<span class="line-added">3362         while (oldIdx &lt; numIter) {</span>
<span class="line-added">3363             newArr[newIdx++] = (oldArr[oldIdx++] &lt;&lt; shiftCount) | (oldArr[oldIdx] &gt;&gt;&gt; shiftCountRight);</span>
<span class="line-added">3364         }</span>
<span class="line-added">3365     }</span>
<span class="line-added">3366 </span>
3367     /**
3368      * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign
3369      * extension is performed.  The shift distance, {@code n}, may be
3370      * negative, in which case this method performs a left shift.
3371      * (Computes &lt;code&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;.)
3372      *
3373      * @param  n shift distance, in bits.
3374      * @return {@code this &gt;&gt; n}
3375      * @see #shiftLeft
3376      */
3377     public BigInteger shiftRight(int n) {
3378         if (signum == 0)
3379             return ZERO;
3380         if (n &gt; 0) {
3381             return shiftRightImpl(n);
3382         } else if (n == 0) {
3383             return this;
3384         } else {
3385             // Possible int overflow in {@code -n} is not a trouble,
3386             // because shiftLeft considers its argument unsigned
</pre>
<hr />
<pre>
3401         int nBits = n &amp; 0x1f;
3402         int magLen = mag.length;
3403         int newMag[] = null;
3404 
3405         // Special case: entire contents shifted off the end
3406         if (nInts &gt;= magLen)
3407             return (signum &gt;= 0 ? ZERO : negConst[1]);
3408 
3409         if (nBits == 0) {
3410             int newMagLen = magLen - nInts;
3411             newMag = Arrays.copyOf(mag, newMagLen);
3412         } else {
3413             int i = 0;
3414             int highBits = mag[0] &gt;&gt;&gt; nBits;
3415             if (highBits != 0) {
3416                 newMag = new int[magLen - nInts];
3417                 newMag[i++] = highBits;
3418             } else {
3419                 newMag = new int[magLen - nInts -1];
3420             }
<span class="line-modified">3421             int numIter = magLen - nInts - 1;</span>
<span class="line-modified">3422             Objects.checkFromToIndex(0, numIter + 1, mag.length);</span>
<span class="line-modified">3423             Objects.checkFromToIndex(i, numIter + i, newMag.length);</span>
<span class="line-modified">3424             shiftRightImplWorker(newMag, mag, i, nBits, numIter);</span>

3425         }
3426 
3427         if (signum &lt; 0) {
3428             // Find out whether any one-bits were shifted off the end.
3429             boolean onesLost = false;
3430             for (int i=magLen-1, j=magLen-nInts; i &gt;= j &amp;&amp; !onesLost; i--)
3431                 onesLost = (mag[i] != 0);
3432             if (!onesLost &amp;&amp; nBits != 0)
3433                 onesLost = (mag[magLen - nInts - 1] &lt;&lt; (32 - nBits) != 0);
3434 
3435             if (onesLost)
3436                 newMag = javaIncrement(newMag);
3437         }
3438 
3439         return new BigInteger(newMag, signum);
3440     }
3441 
<span class="line-added">3442     @ForceInline</span>
<span class="line-added">3443     @HotSpotIntrinsicCandidate</span>
<span class="line-added">3444     private static void shiftRightImplWorker(int[] newArr, int[] oldArr, int newIdx, int shiftCount, int numIter) {</span>
<span class="line-added">3445         int shiftCountLeft = 32 - shiftCount;</span>
<span class="line-added">3446         int idx = numIter;</span>
<span class="line-added">3447         int nidx = (newIdx == 0) ? numIter - 1 : numIter;</span>
<span class="line-added">3448         while (nidx &gt;= newIdx) {</span>
<span class="line-added">3449             newArr[nidx--] = (oldArr[idx--] &gt;&gt;&gt; shiftCount) | (oldArr[idx] &lt;&lt; shiftCountLeft);</span>
<span class="line-added">3450         }</span>
<span class="line-added">3451     }</span>
<span class="line-added">3452 </span>
3453     int[] javaIncrement(int[] val) {
3454         int lastSum = 0;
3455         for (int i=val.length-1;  i &gt;= 0 &amp;&amp; lastSum == 0; i--)
3456             lastSum = (val[i] += 1);
3457         if (lastSum == 0) {
3458             val = new int[val.length+1];
3459             val[0] = 1;
3460         }
3461         return val;
3462     }
3463 
3464     // Bitwise Operations
3465 
3466     /**
3467      * Returns a BigInteger whose value is {@code (this &amp; val)}.  (This
3468      * method returns a negative BigInteger if and only if this and val are
3469      * both negative.)
3470      *
3471      * @param val value to be AND&#39;ed with this BigInteger.
3472      * @return {@code this &amp; val}
</pre>
<hr />
<pre>
4600     * least significant). If the magnitude is zero, return value is undefined.
4601     *
4602     * &lt;p&gt;Note: never used for a BigInteger with a magnitude of zero.
4603     * @see #getInt.
4604     */
4605     private int firstNonzeroIntNum() {
4606         int fn = firstNonzeroIntNumPlusTwo - 2;
4607         if (fn == -2) { // firstNonzeroIntNum not initialized yet
4608             // Search for the first nonzero int
4609             int i;
4610             int mlen = mag.length;
4611             for (i = mlen - 1; i &gt;= 0 &amp;&amp; mag[i] == 0; i--)
4612                 ;
4613             fn = mlen - i - 1;
4614             firstNonzeroIntNumPlusTwo = fn + 2; // offset by two to initialize
4615         }
4616         return fn;
4617     }
4618 
4619     /** use serialVersionUID from JDK 1.1. for interoperability */
<span class="line-added">4620     @java.io.Serial</span>
4621     private static final long serialVersionUID = -8287574255936472291L;
4622 
4623     /**
4624      * Serializable fields for BigInteger.
4625      *
4626      * @serialField signum  int
4627      *              signum of this BigInteger
4628      * @serialField magnitude byte[]
4629      *              magnitude array of this BigInteger
4630      * @serialField bitCount  int
4631      *              appears in the serialized form for backward compatibility
4632      * @serialField bitLength int
4633      *              appears in the serialized form for backward compatibility
4634      * @serialField firstNonzeroByteNum int
4635      *              appears in the serialized form for backward compatibility
4636      * @serialField lowestSetBit int
4637      *              appears in the serialized form for backward compatibility
4638      */
<span class="line-added">4639     @java.io.Serial</span>
4640     private static final ObjectStreamField[] serialPersistentFields = {
4641         new ObjectStreamField(&quot;signum&quot;, Integer.TYPE),
4642         new ObjectStreamField(&quot;magnitude&quot;, byte[].class),
4643         new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE),
4644         new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE),
4645         new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE),
4646         new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)
4647         };
4648 
4649     /**
4650      * Reconstitute the {@code BigInteger} instance from a stream (that is,
4651      * deserialize it). The magnitude is read in as an array of bytes
4652      * for historical reasons, but it is converted to an array of ints
4653      * and the byte array is discarded.
4654      * Note:
4655      * The current convention is to initialize the cache fields, bitCountPlusOne,
4656      * bitLengthPlusOne and lowestSetBitPlusTwo, to 0 rather than some other
4657      * marker value. Therefore, no explicit action to set these fields needs to
4658      * be taken in readObject because those fields already have a 0 value by
4659      * default since defaultReadObject is not being used.
4660      */
<span class="line-added">4661     @java.io.Serial</span>
4662     private void readObject(java.io.ObjectInputStream s)
4663         throws java.io.IOException, ClassNotFoundException {
4664         // prepare to read the alternate persistent fields
4665         ObjectInputStream.GetField fields = s.readFields();
4666 
4667         // Read the alternate persistent fields that we care about
4668         int sign = fields.get(&quot;signum&quot;, -2);
4669         byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, null);
4670 
4671         // Validate signum
4672         if (sign &lt; -1 || sign &gt; 1) {
4673             String message = &quot;BigInteger: Invalid signum value&quot;;
4674             if (fields.defaulted(&quot;signum&quot;))
4675                 message = &quot;BigInteger: Signum not present in stream&quot;;
4676             throw new java.io.StreamCorruptedException(message);
4677         }
4678         int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
4679         if ((mag.length == 0) != (sign == 0)) {
4680             String message = &quot;BigInteger: signum-magnitude mismatch&quot;;
4681             if (fields.defaulted(&quot;magnitude&quot;))
</pre>
<hr />
<pre>
4708 
4709         static void putSign(BigInteger bi, int sign) {
4710             unsafe.putInt(bi, signumOffset, sign);
4711         }
4712 
4713         static void putMag(BigInteger bi, int[] magnitude) {
4714             unsafe.putReference(bi, magOffset, magnitude);
4715         }
4716     }
4717 
4718     /**
4719      * Save the {@code BigInteger} instance to a stream.  The magnitude of a
4720      * {@code BigInteger} is serialized as a byte array for historical reasons.
4721      * To maintain compatibility with older implementations, the integers
4722      * -1, -1, -2, and -2 are written as the values of the obsolete fields
4723      * {@code bitCount}, {@code bitLength}, {@code lowestSetBit}, and
4724      * {@code firstNonzeroByteNum}, respectively.  These values are compatible
4725      * with older implementations, but will be ignored by current
4726      * implementations.
4727      */
<span class="line-added">4728     @java.io.Serial</span>
4729     private void writeObject(ObjectOutputStream s) throws IOException {
4730         // set the values of the Serializable fields
4731         ObjectOutputStream.PutField fields = s.putFields();
4732         fields.put(&quot;signum&quot;, signum);
4733         fields.put(&quot;magnitude&quot;, magSerializedForm());
4734         // The values written for cached fields are compatible with older
4735         // versions, but are ignored in readObject so don&#39;t otherwise matter.
4736         fields.put(&quot;bitCount&quot;, -1);
4737         fields.put(&quot;bitLength&quot;, -1);
4738         fields.put(&quot;lowestSetBit&quot;, -2);
4739         fields.put(&quot;firstNonzeroByteNum&quot;, -2);
4740 
4741         // save them
4742         s.writeFields();
4743     }
4744 
4745     /**
4746      * Returns the mag array as an array of bytes.
4747      */
4748     private byte[] magSerializedForm() {
</pre>
</td>
</tr>
</table>
<center><a href="BigDecimal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MathContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
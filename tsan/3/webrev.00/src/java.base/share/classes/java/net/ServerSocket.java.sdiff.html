<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/ServerSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxySelector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Socket.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/ServerSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
<span class="line-removed">  28 import jdk.internal.access.JavaNetSocketAccess;</span>
<span class="line-removed">  29 import jdk.internal.access.SharedSecrets;</span>
<span class="line-removed">  30 </span>
  31 import java.io.FileDescriptor;
  32 import java.io.IOException;
<span class="line-removed">  33 import java.lang.reflect.Constructor;</span>
<span class="line-removed">  34 import java.lang.reflect.InvocationTargetException;</span>
  35 import java.nio.channels.ServerSocketChannel;
<span class="line-modified">  36 import java.security.AccessController;</span>
<span class="line-removed">  37 import java.security.PrivilegedExceptionAction;</span>
  38 import java.util.Set;
  39 import java.util.Collections;
  40 



  41 /**
  42  * This class implements server sockets. A server socket waits for
  43  * requests to come in over the network. It performs some operation
  44  * based on that request, and then possibly returns a result to the requester.
  45  * &lt;p&gt;
  46  * The actual work of the server socket is performed by an instance
  47  * of the {@code SocketImpl} class. An application can
  48  * change the socket factory that creates the socket
  49  * implementation to configure itself to create sockets
  50  * appropriate to the local firewall.
  51  *





























  52  * @author  unascribed
  53  * @see     java.net.SocketImpl
  54  * @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
  55  * @see     java.nio.channels.ServerSocketChannel
  56  * @since   1.0
  57  */
<span class="line-modified">  58 public</span>
<span class="line-removed">  59 class ServerSocket implements java.io.Closeable {</span>
  60     /**
  61      * Various states of this socket.
  62      */
  63     private boolean created = false;
  64     private boolean bound = false;
  65     private boolean closed = false;
  66     private Object closeLock = new Object();
  67 
  68     /**
  69      * The implementation of this Socket.
  70      */
  71     private SocketImpl impl;
  72 
<span class="line-removed">  73     /**</span>
<span class="line-removed">  74      * Are we using an older SocketImpl?</span>
<span class="line-removed">  75      */</span>
<span class="line-removed">  76     private boolean oldImpl = false;</span>
<span class="line-removed">  77 </span>
  78     /**
  79      * Creates a server socket with a user-specified {@code SocketImpl}.
  80      *
  81      * @param      impl an instance of a SocketImpl to use on the ServerSocket.
  82      *
  83      * @throws     NullPointerException if impl is {@code null}.
  84      *



  85      * @since 12
  86      */
  87     protected ServerSocket(SocketImpl impl) {


  88         this.impl = impl;
<span class="line-modified">  89         impl.setServerSocket(this);</span>







  90     }
  91 
  92     /**
  93      * Creates an unbound server socket.
  94      *
<span class="line-modified">  95      * @exception IOException IO error when opening the socket.</span>
  96      * @revised 1.4
  97      */
  98     public ServerSocket() throws IOException {
  99         setImpl();
 100     }
 101 
 102     /**
 103      * Creates a server socket, bound to the specified port. A port number
 104      * of {@code 0} means that the port number is automatically
 105      * allocated, typically from an ephemeral port range. This port
 106      * number can then be retrieved by calling {@link #getLocalPort getLocalPort}.
 107      * &lt;p&gt;
 108      * The maximum queue length for incoming connection indications (a
 109      * request to connect) is set to {@code 50}. If a connection
 110      * indication arrives when the queue is full, the connection is refused.
 111      * &lt;p&gt;
<span class="line-modified"> 112      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 113      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 114      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 115      * &lt;p&gt;
 116      * If there is a security manager,
 117      * its {@code checkListen} method is called
 118      * with the {@code port} argument
 119      * as its argument to ensure the operation is allowed.
 120      * This could result in a SecurityException.
 121      *
 122      *
 123      * @param      port  the port number, or {@code 0} to use a port
 124      *                   number that is automatically allocated.
 125      *
<span class="line-modified"> 126      * @exception  IOException  if an I/O error occurs when opening the socket.</span>
<span class="line-modified"> 127      * @exception  SecurityException</span>
 128      * if a security manager exists and its {@code checkListen}
 129      * method doesn&#39;t allow the operation.
<span class="line-modified"> 130      * @exception  IllegalArgumentException if the port parameter is outside</span>
 131      *             the specified range of valid port values, which is between
 132      *             0 and 65535, inclusive.
 133      *
 134      * @see        java.net.SocketImpl
 135      * @see        java.net.SocketImplFactory#createSocketImpl()
 136      * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 137      * @see        SecurityManager#checkListen
 138      */
 139     public ServerSocket(int port) throws IOException {
 140         this(port, 50, null);
 141     }
 142 
 143     /**
 144      * Creates a server socket and binds it to the specified local port
 145      * number, with the specified backlog.
 146      * A port number of {@code 0} means that the port number is
 147      * automatically allocated, typically from an ephemeral port range.
 148      * This port number can then be retrieved by calling
 149      * {@link #getLocalPort getLocalPort}.
 150      * &lt;p&gt;
 151      * The maximum queue length for incoming connection indications (a
 152      * request to connect) is set to the {@code backlog} parameter. If
 153      * a connection indication arrives when the queue is full, the
 154      * connection is refused.
 155      * &lt;p&gt;
<span class="line-modified"> 156      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 157      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 158      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 159      * &lt;p&gt;
 160      * If there is a security manager,
 161      * its {@code checkListen} method is called
 162      * with the {@code port} argument
 163      * as its argument to ensure the operation is allowed.
 164      * This could result in a SecurityException.
 165      *
 166      * The {@code backlog} argument is the requested maximum number of
 167      * pending connections on the socket. Its exact semantics are implementation
 168      * specific. In particular, an implementation may impose a maximum length
 169      * or may choose to ignore the parameter altogether. The value provided
 170      * should be greater than {@code 0}. If it is less than or equal to
 171      * {@code 0}, then an implementation specific default will be used.
 172      *
 173      * @param      port     the port number, or {@code 0} to use a port
 174      *                      number that is automatically allocated.
 175      * @param      backlog  requested maximum length of the queue of incoming
 176      *                      connections.
 177      *
<span class="line-modified"> 178      * @exception  IOException  if an I/O error occurs when opening the socket.</span>
<span class="line-modified"> 179      * @exception  SecurityException</span>
 180      * if a security manager exists and its {@code checkListen}
 181      * method doesn&#39;t allow the operation.
<span class="line-modified"> 182      * @exception  IllegalArgumentException if the port parameter is outside</span>
 183      *             the specified range of valid port values, which is between
 184      *             0 and 65535, inclusive.
 185      *
 186      * @see        java.net.SocketImpl
 187      * @see        java.net.SocketImplFactory#createSocketImpl()
 188      * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 189      * @see        SecurityManager#checkListen
 190      */
 191     public ServerSocket(int port, int backlog) throws IOException {
 192         this(port, backlog, null);
 193     }
 194 
 195     /**
 196      * Create a server with the specified port, listen backlog, and
 197      * local IP address to bind to.  The &lt;i&gt;bindAddr&lt;/i&gt; argument
 198      * can be used on a multi-homed host for a ServerSocket that
 199      * will only accept connect requests to one of its addresses.
 200      * If &lt;i&gt;bindAddr&lt;/i&gt; is null, it will default accepting
 201      * connections on any/all local addresses.
 202      * The port must be between 0 and 65535, inclusive.
</pre>
<hr />
<pre>
 211      * as its argument to ensure the operation is allowed.
 212      * This could result in a SecurityException.
 213      *
 214      * The {@code backlog} argument is the requested maximum number of
 215      * pending connections on the socket. Its exact semantics are implementation
 216      * specific. In particular, an implementation may impose a maximum length
 217      * or may choose to ignore the parameter altogether. The value provided
 218      * should be greater than {@code 0}. If it is less than or equal to
 219      * {@code 0}, then an implementation specific default will be used.
 220      *
 221      * @param port  the port number, or {@code 0} to use a port
 222      *              number that is automatically allocated.
 223      * @param backlog requested maximum length of the queue of incoming
 224      *                connections.
 225      * @param bindAddr the local InetAddress the server will bind to
 226      *
 227      * @throws  SecurityException if a security manager exists and
 228      * its {@code checkListen} method doesn&#39;t allow the operation.
 229      *
 230      * @throws  IOException if an I/O error occurs when opening the socket.
<span class="line-modified"> 231      * @exception  IllegalArgumentException if the port parameter is outside</span>
 232      *             the specified range of valid port values, which is between
 233      *             0 and 65535, inclusive.
 234      *
 235      * @see SocketOptions
 236      * @see SocketImpl
 237      * @see SecurityManager#checkListen
 238      * @since   1.1
 239      */
 240     public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException {
 241         setImpl();
 242         if (port &lt; 0 || port &gt; 0xFFFF)
 243             throw new IllegalArgumentException(
 244                        &quot;Port value out of range: &quot; + port);
 245         if (backlog &lt; 1)
 246           backlog = 50;
 247         try {
 248             bind(new InetSocketAddress(bindAddr, port), backlog);
 249         } catch(SecurityException e) {
 250             close();
 251             throw e;
 252         } catch(IOException e) {
 253             close();
 254             throw e;
 255         }
 256     }
 257 
 258     /**
 259      * Get the {@code SocketImpl} attached to this socket, creating
 260      * it if necessary.
 261      *
 262      * @return  the {@code SocketImpl} attached to that ServerSocket.
 263      * @throws SocketException if creation fails.
 264      * @since 1.4
 265      */
 266     SocketImpl getImpl() throws SocketException {
 267         if (!created)
 268             createImpl();
 269         return impl;
 270     }
 271 
<span class="line-removed"> 272     private void checkOldImpl() {</span>
<span class="line-removed"> 273         if (impl == null)</span>
<span class="line-removed"> 274             return;</span>
<span class="line-removed"> 275         // SocketImpl.connect() is a protected method, therefore we need to use</span>
<span class="line-removed"> 276         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="line-removed"> 277         try {</span>
<span class="line-removed"> 278             AccessController.doPrivileged(</span>
<span class="line-removed"> 279                 new PrivilegedExceptionAction&lt;Void&gt;() {</span>
<span class="line-removed"> 280                     public Void run() throws NoSuchMethodException {</span>
<span class="line-removed"> 281                         impl.getClass().getDeclaredMethod(&quot;connect&quot;,</span>
<span class="line-removed"> 282                                                           SocketAddress.class,</span>
<span class="line-removed"> 283                                                           int.class);</span>
<span class="line-removed"> 284                         return null;</span>
<span class="line-removed"> 285                     }</span>
<span class="line-removed"> 286                 });</span>
<span class="line-removed"> 287         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed"> 288             oldImpl = true;</span>
<span class="line-removed"> 289         }</span>
<span class="line-removed"> 290     }</span>
<span class="line-removed"> 291 </span>
 292     private void setImpl() {

 293         if (factory != null) {
 294             impl = factory.createSocketImpl();
<span class="line-removed"> 295             checkOldImpl();</span>
 296         } else {
<span class="line-modified"> 297             // No need to do a checkOldImpl() here, we know it&#39;s an up to date</span>
<span class="line-removed"> 298             // SocketImpl!</span>
<span class="line-removed"> 299             impl = new SocksSocketImpl();</span>
 300         }
<span class="line-removed"> 301         if (impl != null)</span>
<span class="line-removed"> 302             impl.setServerSocket(this);</span>
 303     }
 304 
 305     /**
 306      * Creates the socket implementation.
 307      *
 308      * @throws IOException if creation fails
 309      * @since 1.4
 310      */
 311     void createImpl() throws SocketException {
 312         if (impl == null)
 313             setImpl();
 314         try {
 315             impl.create(true);
 316             created = true;
 317         } catch (IOException e) {
 318             throw new SocketException(e.getMessage());
 319         }
 320     }
 321 
 322     /**
</pre>
<hr />
<pre>
 351      * The {@code backlog} argument is the requested maximum number of
 352      * pending connections on the socket. Its exact semantics are implementation
 353      * specific. In particular, an implementation may impose a maximum length
 354      * or may choose to ignore the parameter altogether. The value provided
 355      * should be greater than {@code 0}. If it is less than or equal to
 356      * {@code 0}, then an implementation specific default will be used.
 357      * @param   endpoint        The IP address and port number to bind to.
 358      * @param   backlog         requested maximum length of the queue of
 359      *                          incoming connections.
 360      * @throws  IOException if the bind operation fails, or if the socket
 361      *                     is already bound.
 362      * @throws  SecurityException       if a {@code SecurityManager} is present and
 363      * its {@code checkListen} method doesn&#39;t allow the operation.
 364      * @throws  IllegalArgumentException if endpoint is a
 365      *          SocketAddress subclass not supported by this socket
 366      * @since 1.4
 367      */
 368     public void bind(SocketAddress endpoint, int backlog) throws IOException {
 369         if (isClosed())
 370             throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified"> 371         if (!oldImpl &amp;&amp; isBound())</span>
 372             throw new SocketException(&quot;Already bound&quot;);
 373         if (endpoint == null)
 374             endpoint = new InetSocketAddress(0);
 375         if (!(endpoint instanceof InetSocketAddress))
 376             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 377         InetSocketAddress epoint = (InetSocketAddress) endpoint;
 378         if (epoint.isUnresolved())
 379             throw new SocketException(&quot;Unresolved address&quot;);
 380         if (backlog &lt; 1)
 381           backlog = 50;
 382         try {
 383             SecurityManager security = System.getSecurityManager();
 384             if (security != null)
 385                 security.checkListen(epoint.getPort());
 386             getImpl().bind(epoint.getAddress(), epoint.getPort());
 387             getImpl().listen(backlog);
 388             bound = true;
 389         } catch(SecurityException e) {
 390             bound = false;
 391             throw e;
</pre>
<hr />
<pre>
 482      */
 483 
 484     public SocketAddress getLocalSocketAddress() {
 485         if (!isBound())
 486             return null;
 487         return new InetSocketAddress(getInetAddress(), getLocalPort());
 488     }
 489 
 490     /**
 491      * Listens for a connection to be made to this socket and accepts
 492      * it. The method blocks until a connection is made.
 493      *
 494      * &lt;p&gt;A new Socket {@code s} is created and, if there
 495      * is a security manager,
 496      * the security manager&#39;s {@code checkAccept} method is called
 497      * with {@code s.getInetAddress().getHostAddress()} and
 498      * {@code s.getPort()}
 499      * as its arguments to ensure the operation is allowed.
 500      * This could result in a SecurityException.
 501      *
<span class="line-modified"> 502      * @exception  IOException  if an I/O error occurs when waiting for a</span>






 503      *               connection.
<span class="line-modified"> 504      * @exception  SecurityException  if a security manager exists and its</span>
 505      *             {@code checkAccept} method doesn&#39;t allow the operation.
<span class="line-modified"> 506      * @exception  SocketTimeoutException if a timeout was previously set with setSoTimeout and</span>
 507      *             the timeout has been reached.
<span class="line-modified"> 508      * @exception  java.nio.channels.IllegalBlockingModeException</span>
 509      *             if this socket has an associated channel, the channel is in
 510      *             non-blocking mode, and there is no connection ready to be
 511      *             accepted
 512      *
 513      * @return the new Socket
 514      * @see SecurityManager#checkAccept
 515      * @revised 1.4
 516      * @spec JSR-51
 517      */
 518     public Socket accept() throws IOException {
 519         if (isClosed())
 520             throw new SocketException(&quot;Socket is closed&quot;);
 521         if (!isBound())
 522             throw new SocketException(&quot;Socket is not bound yet&quot;);
 523         Socket s = new Socket((SocketImpl) null);
 524         implAccept(s);
 525         return s;
 526     }
 527 
 528     /**
 529      * Subclasses of ServerSocket use this method to override accept()
 530      * to return their own subclass of socket.  So a FooServerSocket
<span class="line-modified"> 531      * will typically hand this method an &lt;i&gt;empty&lt;/i&gt; FooSocket.  On</span>
<span class="line-modified"> 532      * return from implAccept the FooSocket will be connected to a client.</span>
















 533      *
 534      * @param s the Socket
 535      * @throws java.nio.channels.IllegalBlockingModeException
 536      *         if this socket has an associated channel,
 537      *         and the channel is in non-blocking mode
 538      * @throws IOException if an I/O error occurs when waiting
<span class="line-modified"> 539      * for a connection.</span>


 540      * @since   1.1
 541      * @revised 1.4
 542      * @spec JSR-51
 543      */
 544     protected final void implAccept(Socket s) throws IOException {
<span class="line-modified"> 545         SocketImpl si = null;</span>
<span class="line-modified"> 546         try {</span>
<span class="line-modified"> 547             if (s.impl == null)</span>
<span class="line-modified"> 548               s.setImpl();</span>
<span class="line-modified"> 549             else {</span>
<span class="line-modified"> 550                 s.impl.reset();</span>






























 551             }
<span class="line-modified"> 552             si = s.impl;</span>
<span class="line-modified"> 553             s.impl = null;</span>
<span class="line-modified"> 554             si.address = new InetAddress();</span>
<span class="line-removed"> 555             si.fd = new FileDescriptor();</span>
<span class="line-removed"> 556             getImpl().accept(si);</span>
<span class="line-removed"> 557             SocketCleanable.register(si.fd);   // raw fd has been set</span>
 558 
<span class="line-modified"> 559             SecurityManager security = System.getSecurityManager();</span>
<span class="line-modified"> 560             if (security != null) {</span>
<span class="line-modified"> 561                 security.checkAccept(si.getInetAddress().getHostAddress(),</span>
<span class="line-modified"> 562                                      si.getPort());</span>










 563             }
<span class="line-modified"> 564         } catch (IOException e) {</span>
<span class="line-modified"> 565             if (si != null)</span>
<span class="line-modified"> 566                 si.reset();</span>
<span class="line-modified"> 567             s.impl = si;</span>
<span class="line-modified"> 568             throw e;</span>
<span class="line-modified"> 569         } catch (SecurityException e) {</span>
<span class="line-modified"> 570             if (si != null)</span>
<span class="line-modified"> 571                 si.reset();</span>
<span class="line-modified"> 572             s.impl = si;</span>

























 573             throw e;
 574         }
<span class="line-modified"> 575         s.impl = si;</span>
<span class="line-modified"> 576         s.postAccept();</span>


































 577     }
 578 
 579     /**
 580      * Closes this socket.
 581      *
 582      * Any thread currently blocked in {@link #accept()} will throw
 583      * a {@link SocketException}.
 584      *
 585      * &lt;p&gt; If this socket has an associated channel then the channel is closed
 586      * as well.
 587      *
<span class="line-modified"> 588      * @exception  IOException  if an I/O error occurs when closing the socket.</span>
 589      * @revised 1.4
 590      * @spec JSR-51
 591      */
 592     public void close() throws IOException {
 593         synchronized(closeLock) {
 594             if (isClosed())
 595                 return;
 596             if (created)
 597                 impl.close();
 598             closed = true;
 599         }
 600     }
 601 
 602     /**
 603      * Returns the unique {@link java.nio.channels.ServerSocketChannel} object
 604      * associated with this socket, if any.
 605      *
 606      * &lt;p&gt; A server socket will have a channel if, and only if, the channel
 607      * itself was created via the {@link
 608      * java.nio.channels.ServerSocketChannel#open ServerSocketChannel.open}
 609      * method.
 610      *
 611      * @return  the server-socket channel associated with this socket,
 612      *          or {@code null} if this socket was not created
 613      *          for a channel
 614      *
 615      * @since 1.4
 616      * @spec JSR-51
 617      */
 618     public ServerSocketChannel getChannel() {
 619         return null;
 620     }
 621 
 622     /**
 623      * Returns the binding state of the ServerSocket.




 624      *
 625      * @return true if the ServerSocket successfully bound to an address
 626      * @since 1.4
 627      */
 628     public boolean isBound() {
<span class="line-modified"> 629         // Before 1.3 ServerSockets were always bound during creation</span>
<span class="line-removed"> 630         return bound || oldImpl;</span>
 631     }
 632 
 633     /**
 634      * Returns the closed state of the ServerSocket.
 635      *
 636      * @return true if the socket has been closed
 637      * @since 1.4
 638      */
 639     public boolean isClosed() {
 640         synchronized(closeLock) {
 641             return closed;
 642         }
 643     }
 644 
 645     /**
 646      * Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} with the
<span class="line-modified"> 647      * specified timeout, in milliseconds.  With this option set to a non-zero</span>
<span class="line-modified"> 648      * timeout, a call to accept() for this ServerSocket</span>
 649      * will block for only this amount of time.  If the timeout expires,
 650      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="line-modified"> 651      * ServerSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled</span>
<span class="line-modified"> 652      * prior to entering the blocking operation to have effect.  The</span>
<span class="line-modified"> 653      * timeout must be {@code &gt; 0}.</span>
<span class="line-modified"> 654      * A timeout of zero is interpreted as an infinite timeout.</span>

 655      * @param timeout the specified timeout, in milliseconds
<span class="line-modified"> 656      * @exception SocketException if there is an error in</span>
<span class="line-modified"> 657      * the underlying protocol, such as a TCP error.</span>

 658      * @since   1.1
 659      * @see #getSoTimeout()
 660      */
 661     public synchronized void setSoTimeout(int timeout) throws SocketException {
 662         if (isClosed())
 663             throw new SocketException(&quot;Socket is closed&quot;);


 664         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
 665     }
 666 
 667     /**
 668      * Retrieve setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
 669      * 0 returns implies that the option is disabled (i.e., timeout of infinity).
 670      * @return the {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} value
<span class="line-modified"> 671      * @exception IOException if an I/O error occurs</span>
 672      * @since   1.1
 673      * @see #setSoTimeout(int)
 674      */
 675     public synchronized int getSoTimeout() throws IOException {
 676         if (isClosed())
 677             throw new SocketException(&quot;Socket is closed&quot;);
 678         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
 679         /* extra type safety */
 680         if (o instanceof Integer) {
 681             return ((Integer) o).intValue();
 682         } else {
 683             return 0;
 684         }
 685     }
 686 
 687     /**
 688      * Enable/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
 689      * socket option.
 690      * &lt;p&gt;
 691      * When a TCP connection is closed the connection may remain
</pre>
<hr />
<pre>
 694      * or {@code 2MSL} wait state).
 695      * For applications using a well known socket address or port
 696      * it may not be possible to bind a socket to the required
 697      * {@code SocketAddress} if there is a connection in the
 698      * timeout state involving the socket address or port.
 699      * &lt;p&gt;
 700      * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} prior to
 701      * binding the socket using {@link #bind(SocketAddress)} allows the socket
 702      * to be bound even though a previous connection is in a timeout state.
 703      * &lt;p&gt;
 704      * When a {@code ServerSocket} is created the initial setting
 705      * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is not defined.
 706      * Applications can use {@link #getReuseAddress()} to determine the initial
 707      * setting of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}.
 708      * &lt;p&gt;
 709      * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
 710      * enabled or disabled after a socket is bound (See {@link #isBound()})
 711      * is not defined.
 712      *
 713      * @param on  whether to enable or disable the socket option
<span class="line-modified"> 714      * @exception SocketException if an error occurs enabling or</span>
 715      *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
 716      *            socket option, or the socket is closed.
 717      * @since 1.4
 718      * @see #getReuseAddress()
 719      * @see #bind(SocketAddress)
 720      * @see #isBound()
 721      * @see #isClosed()
 722      */
 723     public void setReuseAddress(boolean on) throws SocketException {
 724         if (isClosed())
 725             throw new SocketException(&quot;Socket is closed&quot;);
 726         getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
 727     }
 728 
 729     /**
 730      * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
 731      *
 732      * @return a {@code boolean} indicating whether or not
 733      *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="line-modified"> 734      * @exception SocketException if there is an error</span>
 735      * in the underlying protocol, such as a TCP error.
 736      * @since   1.4
 737      * @see #setReuseAddress(boolean)
 738      */
 739     public boolean getReuseAddress() throws SocketException {
 740         if (isClosed())
 741             throw new SocketException(&quot;Socket is closed&quot;);
 742         return ((Boolean) (getImpl().getOption(SocketOptions.SO_REUSEADDR))).booleanValue();
 743     }
 744 
 745     /**
 746      * Returns the implementation address and implementation port of
 747      * this socket as a {@code String}.
 748      * &lt;p&gt;
<span class="line-modified"> 749      * If there is a security manager set, its {@code checkConnect} method is</span>

 750      * called with the local address and {@code -1} as its arguments to see
 751      * if the operation is allowed. If the operation is not allowed,
 752      * an {@code InetAddress} representing the
 753      * {@link InetAddress#getLoopbackAddress loopback} address is returned as
 754      * the implementation address.
 755      *
 756      * @return  a string representation of this socket.
 757      */
 758     public String toString() {
 759         if (!isBound())
 760             return &quot;ServerSocket[unbound]&quot;;
 761         InetAddress in;
 762         if (System.getSecurityManager() != null)
<span class="line-modified"> 763             in = InetAddress.getLoopbackAddress();</span>
 764         else
 765             in = impl.getInetAddress();
 766         return &quot;ServerSocket[addr=&quot; + in +
 767                 &quot;,localport=&quot; + impl.getLocalPort()  + &quot;]&quot;;
 768     }
 769 
<span class="line-removed"> 770     void setBound() {</span>
<span class="line-removed"> 771         bound = true;</span>
<span class="line-removed"> 772     }</span>
<span class="line-removed"> 773 </span>
<span class="line-removed"> 774     void setCreated() {</span>
<span class="line-removed"> 775         created = true;</span>
<span class="line-removed"> 776     }</span>
<span class="line-removed"> 777 </span>
 778     /**
 779      * The factory for all server sockets.
 780      */
<span class="line-modified"> 781     private static SocketImplFactory factory = null;</span>
 782 
 783     /**
 784      * Sets the server socket implementation factory for the
 785      * application. The factory can be specified only once.
 786      * &lt;p&gt;
 787      * When an application creates a new server socket, the socket
 788      * implementation factory&#39;s {@code createSocketImpl} method is
 789      * called to create the actual socket implementation.
 790      * &lt;p&gt;
 791      * Passing {@code null} to the method is a no-op unless the factory
 792      * was already set.
 793      * &lt;p&gt;
 794      * If there is a security manager, this method first calls
 795      * the security manager&#39;s {@code checkSetFactory} method
 796      * to ensure the operation is allowed.
 797      * This could result in a SecurityException.
 798      *
 799      * @param      fac   the desired factory.
<span class="line-modified"> 800      * @exception  IOException  if an I/O error occurs when setting the</span>
 801      *               socket factory.
<span class="line-modified"> 802      * @exception  SocketException  if the factory has already been defined.</span>
<span class="line-modified"> 803      * @exception  SecurityException  if a security manager exists and its</span>
 804      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
 805      * @see        java.net.SocketImplFactory#createSocketImpl()
 806      * @see        SecurityManager#checkSetFactory
 807      */
 808     public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException {
 809         if (factory != null) {
 810             throw new SocketException(&quot;factory already defined&quot;);
 811         }
 812         SecurityManager security = System.getSecurityManager();
 813         if (security != null) {
 814             security.checkSetFactory();
 815         }
 816         factory = fac;
 817     }
 818 
 819     /**
 820      * Sets a default proposed value for the
 821      * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option for sockets
 822      * accepted from this {@code ServerSocket}. The value actually set
 823      * in the accepted socket must be determined by calling
 824      * {@link Socket#getReceiveBufferSize()} after the socket
 825      * is returned by {@link #accept()}.
 826      * &lt;p&gt;
 827      * The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is used both to
 828      * set the size of the internal socket receive buffer, and to set the size
 829      * of the TCP receive window that is advertised to the remote peer.
 830      * &lt;p&gt;
 831      * It is possible to change the value subsequently, by calling
 832      * {@link Socket#setReceiveBufferSize(int)}. However, if the application
 833      * wishes to allow a receive window larger than 64K bytes, as defined by RFC1323
 834      * then the proposed value must be set in the ServerSocket &lt;B&gt;before&lt;/B&gt;
 835      * it is bound to a local address. This implies, that the ServerSocket must be
 836      * created with the no-argument constructor, then setReceiveBufferSize() must
 837      * be called and lastly the ServerSocket is bound to an address by calling bind().
 838      * &lt;p&gt;
 839      * Failure to do this will not cause an error, and the buffer size may be set to the
 840      * requested value but the TCP receive window in sockets accepted from
 841      * this ServerSocket will be no larger than 64K bytes.
 842      *
<span class="line-modified"> 843      * @exception SocketException if there is an error</span>
 844      * in the underlying protocol, such as a TCP error.
 845      *
 846      * @param size the size to which to set the receive buffer
 847      * size. This value must be greater than 0.
 848      *
<span class="line-modified"> 849      * @exception IllegalArgumentException if the</span>
 850      * value is 0 or is negative.
 851      *
 852      * @since 1.4
 853      * @see #getReceiveBufferSize
 854      */
 855      public synchronized void setReceiveBufferSize (int size) throws SocketException {
 856         if (!(size &gt; 0)) {
 857             throw new IllegalArgumentException(&quot;negative receive size&quot;);
 858         }
 859         if (isClosed())
 860             throw new SocketException(&quot;Socket is closed&quot;);
 861         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
 862     }
 863 
 864     /**
 865      * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option
 866      * for this {@code ServerSocket}, that is the proposed buffer size that
 867      * will be used for Sockets accepted from this {@code ServerSocket}.
 868      *
 869      * &lt;p&gt;Note, the value actually set in the accepted socket is determined by
 870      * calling {@link Socket#getReceiveBufferSize()}.
 871      * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
 872      *         option for this {@code Socket}.
<span class="line-modified"> 873      * @exception SocketException if there is an error</span>
 874      *            in the underlying protocol, such as a TCP error.
 875      * @see #setReceiveBufferSize(int)
 876      * @since 1.4
 877      */
 878     public synchronized int getReceiveBufferSize()
 879     throws SocketException{
 880         if (isClosed())
 881             throw new SocketException(&quot;Socket is closed&quot;);
 882         int result = 0;
 883         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
 884         if (o instanceof Integer) {
 885             result = ((Integer)o).intValue();
 886         }
 887         return result;
 888     }
 889 
 890     /**
 891      * Sets performance preferences for this ServerSocket.
 892      *
 893      * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
</pre>
<hr />
<pre>
 945      *         support the option.
 946      *
 947      * @throws IllegalArgumentException if the value is not valid for
 948      *         the option.
 949      *
 950      * @throws IOException if an I/O error occurs, or if the socket is closed.
 951      *
 952      * @throws NullPointerException if name is {@code null}
 953      *
 954      * @throws SecurityException if a security manager is set and if the socket
 955      *         option requires a security permission and if the caller does
 956      *         not have the required permission.
 957      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
 958      *         do not require any security permission.
 959      *
 960      * @since 9
 961      */
 962     public &lt;T&gt; ServerSocket setOption(SocketOption&lt;T&gt; name, T value)
 963         throws IOException
 964     {



 965         getImpl().setOption(name, value);
 966         return this;
 967     }
 968 
 969     /**
 970      * Returns the value of a socket option.
 971      *
 972      * @param &lt;T&gt; The type of the socket option value
 973      * @param name The socket option
 974      *
 975      * @return The value of the socket option.
 976      *
 977      * @throws UnsupportedOperationException if the server socket does not
 978      *         support the option.
 979      *
 980      * @throws IOException if an I/O error occurs, or if the socket is closed.
 981      *
 982      * @throws NullPointerException if name is {@code null}
 983      *
 984      * @throws SecurityException if a security manager is set and if the socket
 985      *         option requires a security permission and if the caller does
 986      *         not have the required permission.
 987      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
 988      *         do not require any security permission.
 989      *
 990      * @since 9
 991      */
 992     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {



 993         return getImpl().getOption(name);
 994     }
 995 
 996     // cache of unmodifiable impl options. Possibly set racy, in impl we trust
 997     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
 998 
 999     /**
1000      * Returns a set of the socket options supported by this server socket.
1001      *
1002      * This method will continue to return the set of options even after
1003      * the socket has been closed.
1004      *
1005      * @return A set of the socket options supported by this socket. This set
1006      *         may be empty if the socket&#39;s SocketImpl cannot be created.
1007      *
1008      * @since 9
1009      */
1010     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1011         Set&lt;SocketOption&lt;?&gt;&gt; so = options;
1012         if (so != null)
1013             return so;
1014 
1015         try {
1016             SocketImpl impl = getImpl();
1017             options = Collections.unmodifiableSet(impl.supportedOptions());
1018         } catch (IOException e) {
1019             options = Collections.emptySet();
1020         }
1021         return options;
1022     }
<span class="line-removed">1023 </span>
<span class="line-removed">1024     static {</span>
<span class="line-removed">1025         SharedSecrets.setJavaNetSocketAccess(</span>
<span class="line-removed">1026             new JavaNetSocketAccess() {</span>
<span class="line-removed">1027                 @Override</span>
<span class="line-removed">1028                 public ServerSocket newServerSocket(SocketImpl impl) {</span>
<span class="line-removed">1029                     return new ServerSocket(impl);</span>
<span class="line-removed">1030                 }</span>
<span class="line-removed">1031 </span>
<span class="line-removed">1032                 @Override</span>
<span class="line-removed">1033                 public SocketImpl newSocketImpl(Class&lt;? extends SocketImpl&gt; implClass) {</span>
<span class="line-removed">1034                     try {</span>
<span class="line-removed">1035                         Constructor&lt;? extends SocketImpl&gt; ctor =</span>
<span class="line-removed">1036                             implClass.getDeclaredConstructor();</span>
<span class="line-removed">1037                         return ctor.newInstance();</span>
<span class="line-removed">1038                     } catch (NoSuchMethodException | InstantiationException |</span>
<span class="line-removed">1039                              IllegalAccessException | InvocationTargetException e) {</span>
<span class="line-removed">1040                         throw new AssertionError(e);</span>
<span class="line-removed">1041                     }</span>
<span class="line-removed">1042                 }</span>
<span class="line-removed">1043             }</span>
<span class="line-removed">1044         );</span>
<span class="line-removed">1045     }</span>
1046 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 



  28 import java.io.FileDescriptor;
  29 import java.io.IOException;


  30 import java.nio.channels.ServerSocketChannel;
<span class="line-modified">  31 import java.util.Objects;</span>

  32 import java.util.Set;
  33 import java.util.Collections;
  34 
<span class="line-added">  35 import sun.security.util.SecurityConstants;</span>
<span class="line-added">  36 import sun.net.PlatformSocketImpl;</span>
<span class="line-added">  37 </span>
  38 /**
  39  * This class implements server sockets. A server socket waits for
  40  * requests to come in over the network. It performs some operation
  41  * based on that request, and then possibly returns a result to the requester.
  42  * &lt;p&gt;
  43  * The actual work of the server socket is performed by an instance
  44  * of the {@code SocketImpl} class. An application can
  45  * change the socket factory that creates the socket
  46  * implementation to configure itself to create sockets
  47  * appropriate to the local firewall.
  48  *
<span class="line-added">  49  * &lt;p&gt; The {@code ServerSocket} class defines convenience</span>
<span class="line-added">  50  * methods to set and get several socket options. This class also</span>
<span class="line-added">  51  * defines the {@link #setOption(SocketOption, Object) setOption}</span>
<span class="line-added">  52  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added">  53  * and query socket options.</span>
<span class="line-added">  54  * A {@code ServerSocket} supports the following options:</span>
<span class="line-added">  55  * &lt;blockquote&gt;</span>
<span class="line-added">  56  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">  57  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added">  58  * &lt;thead&gt;</span>
<span class="line-added">  59  *   &lt;tr&gt;</span>
<span class="line-added">  60  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">  61  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">  62  *   &lt;/tr&gt;</span>
<span class="line-added">  63  * &lt;/thead&gt;</span>
<span class="line-added">  64  * &lt;tbody&gt;</span>
<span class="line-added">  65  *   &lt;tr&gt;</span>
<span class="line-added">  66  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;</span>
<span class="line-added">  67  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;</span>
<span class="line-added">  68  *   &lt;/tr&gt;</span>
<span class="line-added">  69  *   &lt;tr&gt;</span>
<span class="line-added">  70  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;</span>
<span class="line-added">  71  *     &lt;td&gt; Re-use address &lt;/td&gt;</span>
<span class="line-added">  72  *   &lt;/tr&gt;</span>
<span class="line-added">  73  * &lt;/tbody&gt;</span>
<span class="line-added">  74  * &lt;/table&gt;</span>
<span class="line-added">  75  * &lt;/blockquote&gt;</span>
<span class="line-added">  76  * Additional (implementation specific) options may also be supported.</span>
<span class="line-added">  77  *</span>
  78  * @author  unascribed
  79  * @see     java.net.SocketImpl
  80  * @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
  81  * @see     java.nio.channels.ServerSocketChannel
  82  * @since   1.0
  83  */
<span class="line-modified">  84 public class ServerSocket implements java.io.Closeable {</span>

  85     /**
  86      * Various states of this socket.
  87      */
  88     private boolean created = false;
  89     private boolean bound = false;
  90     private boolean closed = false;
  91     private Object closeLock = new Object();
  92 
  93     /**
  94      * The implementation of this Socket.
  95      */
  96     private SocketImpl impl;
  97 





  98     /**
  99      * Creates a server socket with a user-specified {@code SocketImpl}.
 100      *
 101      * @param      impl an instance of a SocketImpl to use on the ServerSocket.
 102      *
 103      * @throws     NullPointerException if impl is {@code null}.
 104      *
<span class="line-added"> 105      * @throws     SecurityException if a security manager is set and</span>
<span class="line-added"> 106      *             its {@code checkPermission} method doesn&#39;t allow</span>
<span class="line-added"> 107      *             {@code NetPermission(&quot;setSocketImpl&quot;)}.</span>
 108      * @since 12
 109      */
 110     protected ServerSocket(SocketImpl impl) {
<span class="line-added"> 111         Objects.requireNonNull(impl);</span>
<span class="line-added"> 112         checkPermission();</span>
 113         this.impl = impl;
<span class="line-modified"> 114     }</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116     private static Void checkPermission() {</span>
<span class="line-added"> 117         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 118         if (sm != null) {</span>
<span class="line-added"> 119             sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);</span>
<span class="line-added"> 120         }</span>
<span class="line-added"> 121         return null;</span>
 122     }
 123 
 124     /**
 125      * Creates an unbound server socket.
 126      *
<span class="line-modified"> 127      * @throws    IOException IO error when opening the socket.</span>
 128      * @revised 1.4
 129      */
 130     public ServerSocket() throws IOException {
 131         setImpl();
 132     }
 133 
 134     /**
 135      * Creates a server socket, bound to the specified port. A port number
 136      * of {@code 0} means that the port number is automatically
 137      * allocated, typically from an ephemeral port range. This port
 138      * number can then be retrieved by calling {@link #getLocalPort getLocalPort}.
 139      * &lt;p&gt;
 140      * The maximum queue length for incoming connection indications (a
 141      * request to connect) is set to {@code 50}. If a connection
 142      * indication arrives when the queue is full, the connection is refused.
 143      * &lt;p&gt;
<span class="line-modified"> 144      * If the application has specified a server socket implementation</span>
<span class="line-modified"> 145      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified"> 146      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 147      * socket implementation is created.</span>
 148      * &lt;p&gt;
 149      * If there is a security manager,
 150      * its {@code checkListen} method is called
 151      * with the {@code port} argument
 152      * as its argument to ensure the operation is allowed.
 153      * This could result in a SecurityException.
 154      *
 155      *
 156      * @param      port  the port number, or {@code 0} to use a port
 157      *                   number that is automatically allocated.
 158      *
<span class="line-modified"> 159      * @throws     IOException  if an I/O error occurs when opening the socket.</span>
<span class="line-modified"> 160      * @throws     SecurityException</span>
 161      * if a security manager exists and its {@code checkListen}
 162      * method doesn&#39;t allow the operation.
<span class="line-modified"> 163      * @throws     IllegalArgumentException if the port parameter is outside</span>
 164      *             the specified range of valid port values, which is between
 165      *             0 and 65535, inclusive.
 166      *
 167      * @see        java.net.SocketImpl
 168      * @see        java.net.SocketImplFactory#createSocketImpl()
 169      * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 170      * @see        SecurityManager#checkListen
 171      */
 172     public ServerSocket(int port) throws IOException {
 173         this(port, 50, null);
 174     }
 175 
 176     /**
 177      * Creates a server socket and binds it to the specified local port
 178      * number, with the specified backlog.
 179      * A port number of {@code 0} means that the port number is
 180      * automatically allocated, typically from an ephemeral port range.
 181      * This port number can then be retrieved by calling
 182      * {@link #getLocalPort getLocalPort}.
 183      * &lt;p&gt;
 184      * The maximum queue length for incoming connection indications (a
 185      * request to connect) is set to the {@code backlog} parameter. If
 186      * a connection indication arrives when the queue is full, the
 187      * connection is refused.
 188      * &lt;p&gt;
<span class="line-modified"> 189      * If the application has specified a server socket implementation</span>
<span class="line-modified"> 190      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified"> 191      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 192      * socket implementation is created.</span>
 193      * &lt;p&gt;
 194      * If there is a security manager,
 195      * its {@code checkListen} method is called
 196      * with the {@code port} argument
 197      * as its argument to ensure the operation is allowed.
 198      * This could result in a SecurityException.
 199      *
 200      * The {@code backlog} argument is the requested maximum number of
 201      * pending connections on the socket. Its exact semantics are implementation
 202      * specific. In particular, an implementation may impose a maximum length
 203      * or may choose to ignore the parameter altogether. The value provided
 204      * should be greater than {@code 0}. If it is less than or equal to
 205      * {@code 0}, then an implementation specific default will be used.
 206      *
 207      * @param      port     the port number, or {@code 0} to use a port
 208      *                      number that is automatically allocated.
 209      * @param      backlog  requested maximum length of the queue of incoming
 210      *                      connections.
 211      *
<span class="line-modified"> 212      * @throws     IOException  if an I/O error occurs when opening the socket.</span>
<span class="line-modified"> 213      * @throws     SecurityException</span>
 214      * if a security manager exists and its {@code checkListen}
 215      * method doesn&#39;t allow the operation.
<span class="line-modified"> 216      * @throws     IllegalArgumentException if the port parameter is outside</span>
 217      *             the specified range of valid port values, which is between
 218      *             0 and 65535, inclusive.
 219      *
 220      * @see        java.net.SocketImpl
 221      * @see        java.net.SocketImplFactory#createSocketImpl()
 222      * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 223      * @see        SecurityManager#checkListen
 224      */
 225     public ServerSocket(int port, int backlog) throws IOException {
 226         this(port, backlog, null);
 227     }
 228 
 229     /**
 230      * Create a server with the specified port, listen backlog, and
 231      * local IP address to bind to.  The &lt;i&gt;bindAddr&lt;/i&gt; argument
 232      * can be used on a multi-homed host for a ServerSocket that
 233      * will only accept connect requests to one of its addresses.
 234      * If &lt;i&gt;bindAddr&lt;/i&gt; is null, it will default accepting
 235      * connections on any/all local addresses.
 236      * The port must be between 0 and 65535, inclusive.
</pre>
<hr />
<pre>
 245      * as its argument to ensure the operation is allowed.
 246      * This could result in a SecurityException.
 247      *
 248      * The {@code backlog} argument is the requested maximum number of
 249      * pending connections on the socket. Its exact semantics are implementation
 250      * specific. In particular, an implementation may impose a maximum length
 251      * or may choose to ignore the parameter altogether. The value provided
 252      * should be greater than {@code 0}. If it is less than or equal to
 253      * {@code 0}, then an implementation specific default will be used.
 254      *
 255      * @param port  the port number, or {@code 0} to use a port
 256      *              number that is automatically allocated.
 257      * @param backlog requested maximum length of the queue of incoming
 258      *                connections.
 259      * @param bindAddr the local InetAddress the server will bind to
 260      *
 261      * @throws  SecurityException if a security manager exists and
 262      * its {@code checkListen} method doesn&#39;t allow the operation.
 263      *
 264      * @throws  IOException if an I/O error occurs when opening the socket.
<span class="line-modified"> 265      * @throws     IllegalArgumentException if the port parameter is outside</span>
 266      *             the specified range of valid port values, which is between
 267      *             0 and 65535, inclusive.
 268      *
 269      * @see SocketOptions
 270      * @see SocketImpl
 271      * @see SecurityManager#checkListen
 272      * @since   1.1
 273      */
 274     public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException {
 275         setImpl();
 276         if (port &lt; 0 || port &gt; 0xFFFF)
 277             throw new IllegalArgumentException(
 278                        &quot;Port value out of range: &quot; + port);
 279         if (backlog &lt; 1)
 280           backlog = 50;
 281         try {
 282             bind(new InetSocketAddress(bindAddr, port), backlog);
 283         } catch(SecurityException e) {
 284             close();
 285             throw e;
 286         } catch(IOException e) {
 287             close();
 288             throw e;
 289         }
 290     }
 291 
 292     /**
 293      * Get the {@code SocketImpl} attached to this socket, creating
 294      * it if necessary.
 295      *
 296      * @return  the {@code SocketImpl} attached to that ServerSocket.
 297      * @throws SocketException if creation fails.
 298      * @since 1.4
 299      */
 300     SocketImpl getImpl() throws SocketException {
 301         if (!created)
 302             createImpl();
 303         return impl;
 304     }
 305 




















 306     private void setImpl() {
<span class="line-added"> 307         SocketImplFactory factory = ServerSocket.factory;</span>
 308         if (factory != null) {
 309             impl = factory.createSocketImpl();

 310         } else {
<span class="line-modified"> 311             impl = SocketImpl.createPlatformSocketImpl(true);</span>


 312         }


 313     }
 314 
 315     /**
 316      * Creates the socket implementation.
 317      *
 318      * @throws IOException if creation fails
 319      * @since 1.4
 320      */
 321     void createImpl() throws SocketException {
 322         if (impl == null)
 323             setImpl();
 324         try {
 325             impl.create(true);
 326             created = true;
 327         } catch (IOException e) {
 328             throw new SocketException(e.getMessage());
 329         }
 330     }
 331 
 332     /**
</pre>
<hr />
<pre>
 361      * The {@code backlog} argument is the requested maximum number of
 362      * pending connections on the socket. Its exact semantics are implementation
 363      * specific. In particular, an implementation may impose a maximum length
 364      * or may choose to ignore the parameter altogether. The value provided
 365      * should be greater than {@code 0}. If it is less than or equal to
 366      * {@code 0}, then an implementation specific default will be used.
 367      * @param   endpoint        The IP address and port number to bind to.
 368      * @param   backlog         requested maximum length of the queue of
 369      *                          incoming connections.
 370      * @throws  IOException if the bind operation fails, or if the socket
 371      *                     is already bound.
 372      * @throws  SecurityException       if a {@code SecurityManager} is present and
 373      * its {@code checkListen} method doesn&#39;t allow the operation.
 374      * @throws  IllegalArgumentException if endpoint is a
 375      *          SocketAddress subclass not supported by this socket
 376      * @since 1.4
 377      */
 378     public void bind(SocketAddress endpoint, int backlog) throws IOException {
 379         if (isClosed())
 380             throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified"> 381         if (isBound())</span>
 382             throw new SocketException(&quot;Already bound&quot;);
 383         if (endpoint == null)
 384             endpoint = new InetSocketAddress(0);
 385         if (!(endpoint instanceof InetSocketAddress))
 386             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 387         InetSocketAddress epoint = (InetSocketAddress) endpoint;
 388         if (epoint.isUnresolved())
 389             throw new SocketException(&quot;Unresolved address&quot;);
 390         if (backlog &lt; 1)
 391           backlog = 50;
 392         try {
 393             SecurityManager security = System.getSecurityManager();
 394             if (security != null)
 395                 security.checkListen(epoint.getPort());
 396             getImpl().bind(epoint.getAddress(), epoint.getPort());
 397             getImpl().listen(backlog);
 398             bound = true;
 399         } catch(SecurityException e) {
 400             bound = false;
 401             throw e;
</pre>
<hr />
<pre>
 492      */
 493 
 494     public SocketAddress getLocalSocketAddress() {
 495         if (!isBound())
 496             return null;
 497         return new InetSocketAddress(getInetAddress(), getLocalPort());
 498     }
 499 
 500     /**
 501      * Listens for a connection to be made to this socket and accepts
 502      * it. The method blocks until a connection is made.
 503      *
 504      * &lt;p&gt;A new Socket {@code s} is created and, if there
 505      * is a security manager,
 506      * the security manager&#39;s {@code checkAccept} method is called
 507      * with {@code s.getInetAddress().getHostAddress()} and
 508      * {@code s.getPort()}
 509      * as its arguments to ensure the operation is allowed.
 510      * This could result in a SecurityException.
 511      *
<span class="line-modified"> 512      * @implNote</span>
<span class="line-added"> 513      * An instance of this class using a system-default {@code SocketImpl}</span>
<span class="line-added"> 514      * accepts sockets with a {@code SocketImpl} of the same type, regardless</span>
<span class="line-added"> 515      * of the {@linkplain Socket#setSocketImplFactory(SocketImplFactory)</span>
<span class="line-added"> 516      * client socket implementation factory}, if one has been set.</span>
<span class="line-added"> 517      *</span>
<span class="line-added"> 518      * @throws     IOException  if an I/O error occurs when waiting for a</span>
 519      *               connection.
<span class="line-modified"> 520      * @throws     SecurityException  if a security manager exists and its</span>
 521      *             {@code checkAccept} method doesn&#39;t allow the operation.
<span class="line-modified"> 522      * @throws     SocketTimeoutException if a timeout was previously set with setSoTimeout and</span>
 523      *             the timeout has been reached.
<span class="line-modified"> 524      * @throws     java.nio.channels.IllegalBlockingModeException</span>
 525      *             if this socket has an associated channel, the channel is in
 526      *             non-blocking mode, and there is no connection ready to be
 527      *             accepted
 528      *
 529      * @return the new Socket
 530      * @see SecurityManager#checkAccept
 531      * @revised 1.4
 532      * @spec JSR-51
 533      */
 534     public Socket accept() throws IOException {
 535         if (isClosed())
 536             throw new SocketException(&quot;Socket is closed&quot;);
 537         if (!isBound())
 538             throw new SocketException(&quot;Socket is not bound yet&quot;);
 539         Socket s = new Socket((SocketImpl) null);
 540         implAccept(s);
 541         return s;
 542     }
 543 
 544     /**
 545      * Subclasses of ServerSocket use this method to override accept()
 546      * to return their own subclass of socket.  So a FooServerSocket
<span class="line-modified"> 547      * will typically hand this method a newly created, unbound, FooSocket.</span>
<span class="line-modified"> 548      * On return from implAccept the FooSocket will be connected to a client.</span>
<span class="line-added"> 549      *</span>
<span class="line-added"> 550      * &lt;p&gt; The behavior of this method is unspecified when invoked with a</span>
<span class="line-added"> 551      * socket that is not newly created and unbound. Any socket options set</span>
<span class="line-added"> 552      * on the given socket prior to invoking this method may or may not be</span>
<span class="line-added"> 553      * preserved when the connection is accepted. It may not be possible to</span>
<span class="line-added"> 554      * accept a connection when this socket has a {@code SocketImpl} of one</span>
<span class="line-added"> 555      * type and the given socket has a {@code SocketImpl} of a completely</span>
<span class="line-added"> 556      * different type.</span>
<span class="line-added"> 557      *</span>
<span class="line-added"> 558      * @implNote</span>
<span class="line-added"> 559      * An instance of this class using a system-default {@code SocketImpl}</span>
<span class="line-added"> 560      * can accept a connection with a Socket using a {@code SocketImpl} of</span>
<span class="line-added"> 561      * the same type: {@code IOException} is thrown if the Socket is using</span>
<span class="line-added"> 562      * a custom {@code SocketImpl}. An instance of this class using a</span>
<span class="line-added"> 563      * custom {@code SocketImpl} cannot accept a connection with a Socket</span>
<span class="line-added"> 564      * using a system-default {@code SocketImpl}.</span>
 565      *
 566      * @param s the Socket
 567      * @throws java.nio.channels.IllegalBlockingModeException
 568      *         if this socket has an associated channel,
 569      *         and the channel is in non-blocking mode
 570      * @throws IOException if an I/O error occurs when waiting
<span class="line-modified"> 571      *         for a connection, or if it is not possible for this socket</span>
<span class="line-added"> 572      *         to accept a connection with the given socket</span>
<span class="line-added"> 573      *</span>
 574      * @since   1.1
 575      * @revised 1.4
 576      * @spec JSR-51
 577      */
 578     protected final void implAccept(Socket s) throws IOException {
<span class="line-modified"> 579         SocketImpl si = s.impl;</span>
<span class="line-modified"> 580 </span>
<span class="line-modified"> 581         // Socket has no SocketImpl</span>
<span class="line-modified"> 582         if (si == null) {</span>
<span class="line-modified"> 583             si = implAccept();</span>
<span class="line-modified"> 584             s.setImpl(si);</span>
<span class="line-added"> 585             s.postAccept();</span>
<span class="line-added"> 586             return;</span>
<span class="line-added"> 587         }</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589         // Socket has a SOCKS or HTTP SocketImpl, need delegate</span>
<span class="line-added"> 590         if (si instanceof DelegatingSocketImpl) {</span>
<span class="line-added"> 591             si = ((DelegatingSocketImpl) si).delegate();</span>
<span class="line-added"> 592             assert si instanceof PlatformSocketImpl;</span>
<span class="line-added"> 593         }</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595         // Accept connection with a platform or custom SocketImpl.</span>
<span class="line-added"> 596         // For the platform SocketImpl case:</span>
<span class="line-added"> 597         // - the connection is accepted with a new SocketImpl</span>
<span class="line-added"> 598         // - the SO_TIMEOUT socket option is copied to the new SocketImpl</span>
<span class="line-added"> 599         // - the Socket is connected to the new SocketImpl</span>
<span class="line-added"> 600         // - the existing/old SocketImpl is closed</span>
<span class="line-added"> 601         // For the custom SocketImpl case, the connection is accepted with the</span>
<span class="line-added"> 602         // existing custom SocketImpl.</span>
<span class="line-added"> 603         ensureCompatible(si);</span>
<span class="line-added"> 604         if (impl instanceof PlatformSocketImpl) {</span>
<span class="line-added"> 605             SocketImpl psi = platformImplAccept();</span>
<span class="line-added"> 606             si.copyOptionsTo(psi);</span>
<span class="line-added"> 607             s.setImpl(psi);</span>
<span class="line-added"> 608             si.closeQuietly();</span>
<span class="line-added"> 609         } else {</span>
<span class="line-added"> 610             s.impl = null; // temporarily break connection to impl</span>
<span class="line-added"> 611             try {</span>
<span class="line-added"> 612                 customImplAccept(si);</span>
<span class="line-added"> 613             } finally {</span>
<span class="line-added"> 614                 s.impl = si;  // restore connection to impl</span>
 615             }
<span class="line-modified"> 616         }</span>
<span class="line-modified"> 617         s.postAccept();</span>
<span class="line-modified"> 618     }</span>



 619 
<span class="line-modified"> 620     /**</span>
<span class="line-modified"> 621      * Accepts a connection with a new SocketImpl.</span>
<span class="line-modified"> 622      * @return the new SocketImpl</span>
<span class="line-modified"> 623      */</span>
<span class="line-added"> 624     private SocketImpl implAccept() throws IOException {</span>
<span class="line-added"> 625         if (impl instanceof PlatformSocketImpl) {</span>
<span class="line-added"> 626             return platformImplAccept();</span>
<span class="line-added"> 627         } else {</span>
<span class="line-added"> 628             // custom server SocketImpl, client SocketImplFactory must be set</span>
<span class="line-added"> 629             SocketImplFactory factory = Socket.socketImplFactory();</span>
<span class="line-added"> 630             if (factory == null) {</span>
<span class="line-added"> 631                 throw new IOException(&quot;An instance of &quot; + impl.getClass() +</span>
<span class="line-added"> 632                     &quot; cannot accept connection with &#39;null&#39; SocketImpl:&quot; +</span>
<span class="line-added"> 633                     &quot; client socket implementation factory not set&quot;);</span>
 634             }
<span class="line-modified"> 635             SocketImpl si = factory.createSocketImpl();</span>
<span class="line-modified"> 636             customImplAccept(si);</span>
<span class="line-modified"> 637             return si;</span>
<span class="line-modified"> 638         }</span>
<span class="line-modified"> 639     }</span>
<span class="line-modified"> 640 </span>
<span class="line-modified"> 641     /**</span>
<span class="line-modified"> 642      * Accepts a connection with a new platform SocketImpl.</span>
<span class="line-modified"> 643      * @return the new platform SocketImpl</span>
<span class="line-added"> 644      */</span>
<span class="line-added"> 645     private SocketImpl platformImplAccept() throws IOException {</span>
<span class="line-added"> 646         assert impl instanceof PlatformSocketImpl;</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648         // create a new platform SocketImpl and accept the connection</span>
<span class="line-added"> 649         SocketImpl psi = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-added"> 650         implAccept(psi);</span>
<span class="line-added"> 651         return psi;</span>
<span class="line-added"> 652     }</span>
<span class="line-added"> 653 </span>
<span class="line-added"> 654     /**</span>
<span class="line-added"> 655      * Accepts a new connection with the given custom SocketImpl.</span>
<span class="line-added"> 656      */</span>
<span class="line-added"> 657     private void customImplAccept(SocketImpl si) throws IOException {</span>
<span class="line-added"> 658         assert !(impl instanceof PlatformSocketImpl)</span>
<span class="line-added"> 659                 &amp;&amp; !(si instanceof PlatformSocketImpl);</span>
<span class="line-added"> 660 </span>
<span class="line-added"> 661         si.reset();</span>
<span class="line-added"> 662         try {</span>
<span class="line-added"> 663             // custom SocketImpl may expect fd/address objects to be created</span>
<span class="line-added"> 664             si.fd = new FileDescriptor();</span>
<span class="line-added"> 665             si.address = new InetAddress();</span>
<span class="line-added"> 666             implAccept(si);</span>
<span class="line-added"> 667         } catch (Exception e) {</span>
<span class="line-added"> 668             si.reset();</span>
 669             throw e;
 670         }
<span class="line-modified"> 671     }</span>
<span class="line-modified"> 672 </span>
<span class="line-added"> 673     /**</span>
<span class="line-added"> 674      * Accepts a new connection so that the given SocketImpl is connected to</span>
<span class="line-added"> 675      * the peer. The SocketImpl and connection are closed if the connection is</span>
<span class="line-added"> 676      * denied by the security manager.</span>
<span class="line-added"> 677      * @throws IOException if an I/O error occurs</span>
<span class="line-added"> 678      * @throws SecurityException if the security manager&#39;s checkAccept method fails</span>
<span class="line-added"> 679      */</span>
<span class="line-added"> 680     private void implAccept(SocketImpl si) throws IOException {</span>
<span class="line-added"> 681         assert !(si instanceof DelegatingSocketImpl);</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683         // accept a connection</span>
<span class="line-added"> 684         impl.accept(si);</span>
<span class="line-added"> 685 </span>
<span class="line-added"> 686         // check permission, close SocketImpl/connection if denied</span>
<span class="line-added"> 687         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 688         if (sm != null) {</span>
<span class="line-added"> 689             try {</span>
<span class="line-added"> 690                 sm.checkAccept(si.getInetAddress().getHostAddress(), si.getPort());</span>
<span class="line-added"> 691             } catch (SecurityException se) {</span>
<span class="line-added"> 692                 si.close();</span>
<span class="line-added"> 693                 throw se;</span>
<span class="line-added"> 694             }</span>
<span class="line-added"> 695         }</span>
<span class="line-added"> 696     }</span>
<span class="line-added"> 697 </span>
<span class="line-added"> 698     /**</span>
<span class="line-added"> 699      * Throws IOException if the server SocketImpl and the given client</span>
<span class="line-added"> 700      * SocketImpl are not both platform or custom SocketImpls.</span>
<span class="line-added"> 701      */</span>
<span class="line-added"> 702     private void ensureCompatible(SocketImpl si) throws IOException {</span>
<span class="line-added"> 703         if ((impl instanceof PlatformSocketImpl) != (si instanceof PlatformSocketImpl)) {</span>
<span class="line-added"> 704             throw new IOException(&quot;An instance of &quot; + impl.getClass() +</span>
<span class="line-added"> 705                 &quot; cannot accept a connection with an instance of &quot; + si.getClass());</span>
<span class="line-added"> 706         }</span>
 707     }
 708 
 709     /**
 710      * Closes this socket.
 711      *
 712      * Any thread currently blocked in {@link #accept()} will throw
 713      * a {@link SocketException}.
 714      *
 715      * &lt;p&gt; If this socket has an associated channel then the channel is closed
 716      * as well.
 717      *
<span class="line-modified"> 718      * @throws     IOException  if an I/O error occurs when closing the socket.</span>
 719      * @revised 1.4
 720      * @spec JSR-51
 721      */
 722     public void close() throws IOException {
 723         synchronized(closeLock) {
 724             if (isClosed())
 725                 return;
 726             if (created)
 727                 impl.close();
 728             closed = true;
 729         }
 730     }
 731 
 732     /**
 733      * Returns the unique {@link java.nio.channels.ServerSocketChannel} object
 734      * associated with this socket, if any.
 735      *
 736      * &lt;p&gt; A server socket will have a channel if, and only if, the channel
 737      * itself was created via the {@link
 738      * java.nio.channels.ServerSocketChannel#open ServerSocketChannel.open}
 739      * method.
 740      *
 741      * @return  the server-socket channel associated with this socket,
 742      *          or {@code null} if this socket was not created
 743      *          for a channel
 744      *
 745      * @since 1.4
 746      * @spec JSR-51
 747      */
 748     public ServerSocketChannel getChannel() {
 749         return null;
 750     }
 751 
 752     /**
 753      * Returns the binding state of the ServerSocket.
<span class="line-added"> 754      * &lt;p&gt;</span>
<span class="line-added"> 755      * If the socket was bound prior to being {@linkplain #close closed},</span>
<span class="line-added"> 756      * then this method will continue to return {@code true}</span>
<span class="line-added"> 757      * after the socket is closed.</span>
 758      *
 759      * @return true if the ServerSocket successfully bound to an address
 760      * @since 1.4
 761      */
 762     public boolean isBound() {
<span class="line-modified"> 763         return bound;</span>

 764     }
 765 
 766     /**
 767      * Returns the closed state of the ServerSocket.
 768      *
 769      * @return true if the socket has been closed
 770      * @since 1.4
 771      */
 772     public boolean isClosed() {
 773         synchronized(closeLock) {
 774             return closed;
 775         }
 776     }
 777 
 778     /**
 779      * Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} with the
<span class="line-modified"> 780      * specified timeout, in milliseconds.  With this option set to a positive</span>
<span class="line-modified"> 781      * timeout value, a call to accept() for this ServerSocket</span>
 782      * will block for only this amount of time.  If the timeout expires,
 783      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="line-modified"> 784      * ServerSocket is still valid. A timeout of zero is interpreted as an</span>
<span class="line-modified"> 785      * infinite timeout.</span>
<span class="line-modified"> 786      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking</span>
<span class="line-modified"> 787      * operation to have effect.</span>
<span class="line-added"> 788      *</span>
 789      * @param timeout the specified timeout, in milliseconds
<span class="line-modified"> 790      * @throws  SocketException if there is an error in the underlying protocol,</span>
<span class="line-modified"> 791      *          such as a TCP error</span>
<span class="line-added"> 792      * @throws  IllegalArgumentException  if {@code timeout} is negative</span>
 793      * @since   1.1
 794      * @see #getSoTimeout()
 795      */
 796     public synchronized void setSoTimeout(int timeout) throws SocketException {
 797         if (isClosed())
 798             throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-added"> 799         if (timeout &lt; 0)</span>
<span class="line-added"> 800             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
 801         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
 802     }
 803 
 804     /**
 805      * Retrieve setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
 806      * 0 returns implies that the option is disabled (i.e., timeout of infinity).
 807      * @return the {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} value
<span class="line-modified"> 808      * @throws    IOException if an I/O error occurs</span>
 809      * @since   1.1
 810      * @see #setSoTimeout(int)
 811      */
 812     public synchronized int getSoTimeout() throws IOException {
 813         if (isClosed())
 814             throw new SocketException(&quot;Socket is closed&quot;);
 815         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
 816         /* extra type safety */
 817         if (o instanceof Integer) {
 818             return ((Integer) o).intValue();
 819         } else {
 820             return 0;
 821         }
 822     }
 823 
 824     /**
 825      * Enable/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
 826      * socket option.
 827      * &lt;p&gt;
 828      * When a TCP connection is closed the connection may remain
</pre>
<hr />
<pre>
 831      * or {@code 2MSL} wait state).
 832      * For applications using a well known socket address or port
 833      * it may not be possible to bind a socket to the required
 834      * {@code SocketAddress} if there is a connection in the
 835      * timeout state involving the socket address or port.
 836      * &lt;p&gt;
 837      * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} prior to
 838      * binding the socket using {@link #bind(SocketAddress)} allows the socket
 839      * to be bound even though a previous connection is in a timeout state.
 840      * &lt;p&gt;
 841      * When a {@code ServerSocket} is created the initial setting
 842      * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is not defined.
 843      * Applications can use {@link #getReuseAddress()} to determine the initial
 844      * setting of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}.
 845      * &lt;p&gt;
 846      * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
 847      * enabled or disabled after a socket is bound (See {@link #isBound()})
 848      * is not defined.
 849      *
 850      * @param on  whether to enable or disable the socket option
<span class="line-modified"> 851      * @throws    SocketException if an error occurs enabling or</span>
 852      *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
 853      *            socket option, or the socket is closed.
 854      * @since 1.4
 855      * @see #getReuseAddress()
 856      * @see #bind(SocketAddress)
 857      * @see #isBound()
 858      * @see #isClosed()
 859      */
 860     public void setReuseAddress(boolean on) throws SocketException {
 861         if (isClosed())
 862             throw new SocketException(&quot;Socket is closed&quot;);
 863         getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
 864     }
 865 
 866     /**
 867      * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
 868      *
 869      * @return a {@code boolean} indicating whether or not
 870      *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="line-modified"> 871      * @throws    SocketException if there is an error</span>
 872      * in the underlying protocol, such as a TCP error.
 873      * @since   1.4
 874      * @see #setReuseAddress(boolean)
 875      */
 876     public boolean getReuseAddress() throws SocketException {
 877         if (isClosed())
 878             throw new SocketException(&quot;Socket is closed&quot;);
 879         return ((Boolean) (getImpl().getOption(SocketOptions.SO_REUSEADDR))).booleanValue();
 880     }
 881 
 882     /**
 883      * Returns the implementation address and implementation port of
 884      * this socket as a {@code String}.
 885      * &lt;p&gt;
<span class="line-modified"> 886      * If there is a security manager set, and this socket is</span>
<span class="line-added"> 887      * {@linkplain #isBound bound}, its {@code checkConnect} method is</span>
 888      * called with the local address and {@code -1} as its arguments to see
 889      * if the operation is allowed. If the operation is not allowed,
 890      * an {@code InetAddress} representing the
 891      * {@link InetAddress#getLoopbackAddress loopback} address is returned as
 892      * the implementation address.
 893      *
 894      * @return  a string representation of this socket.
 895      */
 896     public String toString() {
 897         if (!isBound())
 898             return &quot;ServerSocket[unbound]&quot;;
 899         InetAddress in;
 900         if (System.getSecurityManager() != null)
<span class="line-modified"> 901             in = getInetAddress();</span>
 902         else
 903             in = impl.getInetAddress();
 904         return &quot;ServerSocket[addr=&quot; + in +
 905                 &quot;,localport=&quot; + impl.getLocalPort()  + &quot;]&quot;;
 906     }
 907 








 908     /**
 909      * The factory for all server sockets.
 910      */
<span class="line-modified"> 911     private static volatile SocketImplFactory factory;</span>
 912 
 913     /**
 914      * Sets the server socket implementation factory for the
 915      * application. The factory can be specified only once.
 916      * &lt;p&gt;
 917      * When an application creates a new server socket, the socket
 918      * implementation factory&#39;s {@code createSocketImpl} method is
 919      * called to create the actual socket implementation.
 920      * &lt;p&gt;
 921      * Passing {@code null} to the method is a no-op unless the factory
 922      * was already set.
 923      * &lt;p&gt;
 924      * If there is a security manager, this method first calls
 925      * the security manager&#39;s {@code checkSetFactory} method
 926      * to ensure the operation is allowed.
 927      * This could result in a SecurityException.
 928      *
 929      * @param      fac   the desired factory.
<span class="line-modified"> 930      * @throws     IOException  if an I/O error occurs when setting the</span>
 931      *               socket factory.
<span class="line-modified"> 932      * @throws     SocketException  if the factory has already been defined.</span>
<span class="line-modified"> 933      * @throws     SecurityException  if a security manager exists and its</span>
 934      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
 935      * @see        java.net.SocketImplFactory#createSocketImpl()
 936      * @see        SecurityManager#checkSetFactory
 937      */
 938     public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException {
 939         if (factory != null) {
 940             throw new SocketException(&quot;factory already defined&quot;);
 941         }
 942         SecurityManager security = System.getSecurityManager();
 943         if (security != null) {
 944             security.checkSetFactory();
 945         }
 946         factory = fac;
 947     }
 948 
 949     /**
 950      * Sets a default proposed value for the
 951      * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option for sockets
 952      * accepted from this {@code ServerSocket}. The value actually set
 953      * in the accepted socket must be determined by calling
 954      * {@link Socket#getReceiveBufferSize()} after the socket
 955      * is returned by {@link #accept()}.
 956      * &lt;p&gt;
 957      * The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is used both to
 958      * set the size of the internal socket receive buffer, and to set the size
 959      * of the TCP receive window that is advertised to the remote peer.
 960      * &lt;p&gt;
 961      * It is possible to change the value subsequently, by calling
 962      * {@link Socket#setReceiveBufferSize(int)}. However, if the application
 963      * wishes to allow a receive window larger than 64K bytes, as defined by RFC1323
 964      * then the proposed value must be set in the ServerSocket &lt;B&gt;before&lt;/B&gt;
 965      * it is bound to a local address. This implies, that the ServerSocket must be
 966      * created with the no-argument constructor, then setReceiveBufferSize() must
 967      * be called and lastly the ServerSocket is bound to an address by calling bind().
 968      * &lt;p&gt;
 969      * Failure to do this will not cause an error, and the buffer size may be set to the
 970      * requested value but the TCP receive window in sockets accepted from
 971      * this ServerSocket will be no larger than 64K bytes.
 972      *
<span class="line-modified"> 973      * @throws    SocketException if there is an error</span>
 974      * in the underlying protocol, such as a TCP error.
 975      *
 976      * @param size the size to which to set the receive buffer
 977      * size. This value must be greater than 0.
 978      *
<span class="line-modified"> 979      * @throws    IllegalArgumentException if the</span>
 980      * value is 0 or is negative.
 981      *
 982      * @since 1.4
 983      * @see #getReceiveBufferSize
 984      */
 985      public synchronized void setReceiveBufferSize (int size) throws SocketException {
 986         if (!(size &gt; 0)) {
 987             throw new IllegalArgumentException(&quot;negative receive size&quot;);
 988         }
 989         if (isClosed())
 990             throw new SocketException(&quot;Socket is closed&quot;);
 991         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
 992     }
 993 
 994     /**
 995      * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option
 996      * for this {@code ServerSocket}, that is the proposed buffer size that
 997      * will be used for Sockets accepted from this {@code ServerSocket}.
 998      *
 999      * &lt;p&gt;Note, the value actually set in the accepted socket is determined by
1000      * calling {@link Socket#getReceiveBufferSize()}.
1001      * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
1002      *         option for this {@code Socket}.
<span class="line-modified">1003      * @throws    SocketException if there is an error</span>
1004      *            in the underlying protocol, such as a TCP error.
1005      * @see #setReceiveBufferSize(int)
1006      * @since 1.4
1007      */
1008     public synchronized int getReceiveBufferSize()
1009     throws SocketException{
1010         if (isClosed())
1011             throw new SocketException(&quot;Socket is closed&quot;);
1012         int result = 0;
1013         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
1014         if (o instanceof Integer) {
1015             result = ((Integer)o).intValue();
1016         }
1017         return result;
1018     }
1019 
1020     /**
1021      * Sets performance preferences for this ServerSocket.
1022      *
1023      * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
</pre>
<hr />
<pre>
1075      *         support the option.
1076      *
1077      * @throws IllegalArgumentException if the value is not valid for
1078      *         the option.
1079      *
1080      * @throws IOException if an I/O error occurs, or if the socket is closed.
1081      *
1082      * @throws NullPointerException if name is {@code null}
1083      *
1084      * @throws SecurityException if a security manager is set and if the socket
1085      *         option requires a security permission and if the caller does
1086      *         not have the required permission.
1087      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1088      *         do not require any security permission.
1089      *
1090      * @since 9
1091      */
1092     public &lt;T&gt; ServerSocket setOption(SocketOption&lt;T&gt; name, T value)
1093         throws IOException
1094     {
<span class="line-added">1095         Objects.requireNonNull(name);</span>
<span class="line-added">1096         if (isClosed())</span>
<span class="line-added">1097             throw new SocketException(&quot;Socket is closed&quot;);</span>
1098         getImpl().setOption(name, value);
1099         return this;
1100     }
1101 
1102     /**
1103      * Returns the value of a socket option.
1104      *
1105      * @param &lt;T&gt; The type of the socket option value
1106      * @param name The socket option
1107      *
1108      * @return The value of the socket option.
1109      *
1110      * @throws UnsupportedOperationException if the server socket does not
1111      *         support the option.
1112      *
1113      * @throws IOException if an I/O error occurs, or if the socket is closed.
1114      *
1115      * @throws NullPointerException if name is {@code null}
1116      *
1117      * @throws SecurityException if a security manager is set and if the socket
1118      *         option requires a security permission and if the caller does
1119      *         not have the required permission.
1120      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1121      *         do not require any security permission.
1122      *
1123      * @since 9
1124      */
1125     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-added">1126         Objects.requireNonNull(name);</span>
<span class="line-added">1127         if (isClosed())</span>
<span class="line-added">1128             throw new SocketException(&quot;Socket is closed&quot;);</span>
1129         return getImpl().getOption(name);
1130     }
1131 
1132     // cache of unmodifiable impl options. Possibly set racy, in impl we trust
1133     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
1134 
1135     /**
1136      * Returns a set of the socket options supported by this server socket.
1137      *
1138      * This method will continue to return the set of options even after
1139      * the socket has been closed.
1140      *
1141      * @return A set of the socket options supported by this socket. This set
1142      *         may be empty if the socket&#39;s SocketImpl cannot be created.
1143      *
1144      * @since 9
1145      */
1146     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1147         Set&lt;SocketOption&lt;?&gt;&gt; so = options;
1148         if (so != null)
1149             return so;
1150 
1151         try {
1152             SocketImpl impl = getImpl();
1153             options = Collections.unmodifiableSet(impl.supportedOptions());
1154         } catch (IOException e) {
1155             options = Collections.emptySet();
1156         }
1157         return options;
1158     }























1159 }
</pre>
</td>
</tr>
</table>
<center><a href="ProxySelector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Socket.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
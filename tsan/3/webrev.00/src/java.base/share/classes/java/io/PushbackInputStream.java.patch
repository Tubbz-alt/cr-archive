diff a/src/java.base/share/classes/java/io/PushbackInputStream.java b/src/java.base/share/classes/java/io/PushbackInputStream.java
--- a/src/java.base/share/classes/java/io/PushbackInputStream.java
+++ b/src/java.base/share/classes/java/io/PushbackInputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,11 +24,11 @@
  */
 
 package java.io;
 
 /**
- * A <code>PushbackInputStream</code> adds
+ * A {@code PushbackInputStream} adds
  * functionality to another input stream, namely
  * the  ability to "push back" or "unread" bytes,
  * by storing pushed-back bytes in an internal buffer.
  * This is useful in situations where
  * it is convenient for a fragment of code
@@ -47,22 +47,21 @@
  *
  * @author  David Connelly
  * @author  Jonathan Payne
  * @since   1.0
  */
-public
-class PushbackInputStream extends FilterInputStream {
+public class PushbackInputStream extends FilterInputStream {
     /**
      * The pushback buffer.
      * @since   1.1
      */
     protected byte[] buf;
 
     /**
      * The position within the pushback buffer from which the next byte will
-     * be read.  When the buffer is empty, <code>pos</code> is equal to
-     * <code>buf.length</code>; when the buffer is full, <code>pos</code> is
+     * be read.  When the buffer is empty, {@code pos} is equal to
+     * {@code buf.length}; when the buffer is full, {@code pos} is
      * equal to zero.
      *
      * @since   1.1
      */
     protected int pos;
@@ -74,19 +73,19 @@
         if (in == null)
             throw new IOException("Stream closed");
     }
 
     /**
-     * Creates a <code>PushbackInputStream</code>
-     * with a pushback buffer of the specified <code>size</code>,
+     * Creates a {@code PushbackInputStream}
+     * with a pushback buffer of the specified {@code size},
      * and saves its argument, the input stream
-     * <code>in</code>, for later use. Initially,
+     * {@code in}, for later use. Initially,
      * the pushback buffer is empty.
      *
      * @param  in    the input stream from which bytes will be read.
      * @param  size  the size of the pushback buffer.
-     * @exception IllegalArgumentException if {@code size <= 0}
+     * @throws IllegalArgumentException if {@code size <= 0}
      * @since  1.1
      */
     public PushbackInputStream(InputStream in, int size) {
         super(in);
         if (size <= 0) {
@@ -95,37 +94,37 @@
         this.buf = new byte[size];
         this.pos = size;
     }
 
     /**
-     * Creates a <code>PushbackInputStream</code>
+     * Creates a {@code PushbackInputStream}
      * with a 1-byte pushback buffer, and saves its argument, the input stream
-     * <code>in</code>, for later use. Initially,
+     * {@code in}, for later use. Initially,
      * the pushback buffer is empty.
      *
      * @param   in   the input stream from which bytes will be read.
      */
     public PushbackInputStream(InputStream in) {
         this(in, 1);
     }
 
     /**
      * Reads the next byte of data from this input stream. The value
-     * byte is returned as an <code>int</code> in the range
-     * <code>0</code> to <code>255</code>. If no byte is available
+     * byte is returned as an {@code int} in the range
+     * {@code 0} to {@code 255}. If no byte is available
      * because the end of the stream has been reached, the value
-     * <code>-1</code> is returned. This method blocks until input data
+     * {@code -1} is returned. This method blocks until input data
      * is available, the end of the stream is detected, or an exception
      * is thrown.
      *
      * <p> This method returns the most recently pushed-back byte, if there is
-     * one, and otherwise calls the <code>read</code> method of its underlying
+     * one, and otherwise calls the {@code read} method of its underlying
      * input stream and returns whatever value that method returns.
      *
-     * @return     the next byte of data, or <code>-1</code> if the end of the
+     * @return     the next byte of data, or {@code -1} if the end of the
      *             stream has been reached.
-     * @exception  IOException  if this input stream has been closed by
+     * @throws     IOException  if this input stream has been closed by
      *             invoking its {@link #close()} method,
      *             or an I/O error occurs.
      * @see        java.io.InputStream#read()
      */
     public int read() throws IOException {
@@ -135,28 +134,28 @@
         }
         return super.read();
     }
 
     /**
-     * Reads up to <code>len</code> bytes of data from this input stream into
+     * Reads up to {@code len} bytes of data from this input stream into
      * an array of bytes.  This method first reads any pushed-back bytes; after
-     * that, if fewer than <code>len</code> bytes have been read then it
-     * reads from the underlying input stream. If <code>len</code> is not zero, the method
+     * that, if fewer than {@code len} bytes have been read then it
+     * reads from the underlying input stream. If {@code len} is not zero, the method
      * blocks until at least 1 byte of input is available; otherwise, no
-     * bytes are read and <code>0</code> is returned.
+     * bytes are read and {@code 0} is returned.
      *
      * @param      b     the buffer into which the data is read.
-     * @param      off   the start offset in the destination array <code>b</code>
+     * @param      off   the start offset in the destination array {@code b}
      * @param      len   the maximum number of bytes read.
      * @return     the total number of bytes read into the buffer, or
-     *             <code>-1</code> if there is no more data because the end of
+     *             {@code -1} if there is no more data because the end of
      *             the stream has been reached.
-     * @exception  NullPointerException If <code>b</code> is <code>null</code>.
-     * @exception  IndexOutOfBoundsException If <code>off</code> is negative,
-     * <code>len</code> is negative, or <code>len</code> is greater than
-     * <code>b.length - off</code>
-     * @exception  IOException  if this input stream has been closed by
+     * @throws     NullPointerException If {@code b} is {@code null}.
+     * @throws     IndexOutOfBoundsException If {@code off} is negative,
+     *             {@code len} is negative, or {@code len} is greater than
+     *             {@code b.length - off}
+     * @throws     IOException  if this input stream has been closed by
      *             invoking its {@link #close()} method,
      *             or an I/O error occurs.
      * @see        java.io.InputStream#read(byte[], int, int)
      */
     public int read(byte[] b, int off, int len) throws IOException {
@@ -190,15 +189,15 @@
     }
 
     /**
      * Pushes back a byte by copying it to the front of the pushback buffer.
      * After this method returns, the next byte to be read will have the value
-     * <code>(byte)b</code>.
+     * {@code (byte)b}.
      *
-     * @param      b   the <code>int</code> value whose low-order
+     * @param      b   the {@code int} value whose low-order
      *                  byte is to be pushed back.
-     * @exception IOException If there is not enough room in the pushback
+     * @throws    IOException If there is not enough room in the pushback
      *            buffer for the byte, or this input stream has been closed by
      *            invoking its {@link #close()} method.
      */
     public void unread(int b) throws IOException {
         ensureOpen();
@@ -209,17 +208,18 @@
     }
 
     /**
      * Pushes back a portion of an array of bytes by copying it to the front
      * of the pushback buffer.  After this method returns, the next byte to be
-     * read will have the value <code>b[off]</code>, the byte after that will
-     * have the value <code>b[off+1]</code>, and so forth.
+     * read will have the value {@code b[off]}, the byte after that will
+     * have the value {@code b[off+1]}, and so forth.
      *
-     * @param b the byte array to push back.
-     * @param off the start offset of the data.
-     * @param len the number of bytes to push back.
-     * @exception IOException If there is not enough room in the pushback
+     * @param     b the byte array to push back.
+     * @param     off the start offset of the data.
+     * @param     len the number of bytes to push back.
+     * @throws    NullPointerException If {@code b} is {@code null}.
+     * @throws    IOException If there is not enough room in the pushback
      *            buffer for the specified number of bytes,
      *            or this input stream has been closed by
      *            invoking its {@link #close()} method.
      * @since     1.1
      */
@@ -233,15 +233,16 @@
     }
 
     /**
      * Pushes back an array of bytes by copying it to the front of the
      * pushback buffer.  After this method returns, the next byte to be read
-     * will have the value <code>b[0]</code>, the byte after that will have the
-     * value <code>b[1]</code>, and so forth.
+     * will have the value {@code b[0]}, the byte after that will have the
+     * value {@code b[1]}, and so forth.
      *
-     * @param b the byte array to push back
-     * @exception IOException If there is not enough room in the pushback
+     * @param     b the byte array to push back
+     * @throws    NullPointerException If {@code b} is {@code null}.
+     * @throws    IOException If there is not enough room in the pushback
      *            buffer for the specified number of bytes,
      *            or this input stream has been closed by
      *            invoking its {@link #close()} method.
      * @since     1.1
      */
@@ -260,11 +261,11 @@
      * pushed back and the value returned by {@link
      * java.io.FilterInputStream#available available}.
      *
      * @return     the number of bytes that can be read (or skipped over) from
      *             the input stream without blocking.
-     * @exception  IOException  if this input stream has been closed by
+     * @throws     IOException  if this input stream has been closed by
      *             invoking its {@link #close()} method,
      *             or an I/O error occurs.
      * @see        java.io.FilterInputStream#in
      * @see        java.io.InputStream#available()
      */
@@ -276,18 +277,18 @@
                     ? Integer.MAX_VALUE
                     : n + avail;
     }
 
     /**
-     * Skips over and discards <code>n</code> bytes of data from this
-     * input stream. The <code>skip</code> method may, for a variety of
+     * Skips over and discards {@code n} bytes of data from this
+     * input stream. The {@code skip} method may, for a variety of
      * reasons, end up skipping over some smaller number of bytes,
-     * possibly zero.  If <code>n</code> is negative, no bytes are skipped.
+     * possibly zero.  If {@code n} is negative, no bytes are skipped.
      *
-     * <p> The <code>skip</code> method of <code>PushbackInputStream</code>
+     * <p> The {@code skip} method of {@code PushbackInputStream}
      * first skips over the bytes in the pushback buffer, if any.  It then
-     * calls the <code>skip</code> method of the underlying input stream if
+     * calls the {@code skip} method of the underlying input stream if
      * more bytes need to be skipped.  The actual number of bytes skipped
      * is returned.
      *
      * @param      n  {@inheritDoc}
      * @return     {@inheritDoc}
@@ -318,26 +319,26 @@
         }
         return pskip;
     }
 
     /**
-     * Tests if this input stream supports the <code>mark</code> and
-     * <code>reset</code> methods, which it does not.
+     * Tests if this input stream supports the {@code mark} and
+     * {@code reset} methods, which it does not.
      *
-     * @return   <code>false</code>, since this class does not support the
-     *           <code>mark</code> and <code>reset</code> methods.
-     * @see     java.io.InputStream#mark(int)
-     * @see     java.io.InputStream#reset()
+     * @return   {@code false}, since this class does not support the
+     *           {@code mark} and {@code reset} methods.
+     * @see      java.io.InputStream#mark(int)
+     * @see      java.io.InputStream#reset()
      */
     public boolean markSupported() {
         return false;
     }
 
     /**
      * Marks the current position in this input stream.
      *
-     * <p> The <code>mark</code> method of <code>PushbackInputStream</code>
+     * <p> The {@code mark} method of {@code PushbackInputStream}
      * does nothing.
      *
      * @param   readlimit   the maximum limit of bytes that can be read before
      *                      the mark position becomes invalid.
      * @see     java.io.InputStream#reset()
@@ -345,17 +346,17 @@
     public synchronized void mark(int readlimit) {
     }
 
     /**
      * Repositions this stream to the position at the time the
-     * <code>mark</code> method was last called on this input stream.
+     * {@code mark} method was last called on this input stream.
      *
-     * <p> The method <code>reset</code> for class
-     * <code>PushbackInputStream</code> does nothing except throw an
-     * <code>IOException</code>.
+     * <p> The method {@code reset} for class
+     * {@code PushbackInputStream} does nothing except throw an
+     * {@code IOException}.
      *
-     * @exception  IOException  if this method is invoked.
+     * @throws  IOException  if this method is invoked.
      * @see     java.io.InputStream#mark(int)
      * @see     java.io.IOException
      */
     public synchronized void reset() throws IOException {
         throw new IOException("mark/reset not supported");
@@ -366,11 +367,11 @@
      * associated with the stream.
      * Once the stream has been closed, further read(), unread(),
      * available(), reset(), or skip() invocations will throw an IOException.
      * Closing a previously closed stream has no effect.
      *
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public synchronized void close() throws IOException {
         if (in == null)
             return;
         in.close();

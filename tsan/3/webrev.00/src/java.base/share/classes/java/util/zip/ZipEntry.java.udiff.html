<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/zip/ZipEntry.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipCoder.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipError.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipEntry.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1995, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,12 +39,11 @@</span>
   * This class is used to represent a ZIP file entry.
   *
   * @author      David Connelly
   * @since 1.1
   */
<span class="udiff-line-modified-removed">- public</span>
<span class="udiff-line-removed">- class ZipEntry implements ZipConstants, Cloneable {</span>
<span class="udiff-line-modified-added">+ public class ZipEntry implements ZipConstants, Cloneable {</span>
  
      String name;        // entry name
      long xdostime = -1; // last modification time (in extended DOS time,
                          // where milliseconds lost in conversion might
                          // be encoded into the upper half)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -520,22 +519,25 @@</span>
       *         extra field data is greater than 0xFFFF bytes
       *
       * @see #getExtra()
       */
      public void setExtra(byte[] extra) {
<span class="udiff-line-modified-removed">-         setExtra0(extra, false);</span>
<span class="udiff-line-modified-added">+         setExtra0(extra, false, true);</span>
      }
  
      /**
       * Sets the optional extra field data for the entry.
       *
       * @param extra
       *        the extra field data bytes
       * @param doZIP64
       *        if true, set size and csize from ZIP64 fields if present
<span class="udiff-line-added">+      * @param isLOC</span>
<span class="udiff-line-added">+      *        true if setting the extra field for a LOC, false if for</span>
<span class="udiff-line-added">+      *        a CEN</span>
       */
<span class="udiff-line-modified-removed">-     void setExtra0(byte[] extra, boolean doZIP64) {</span>
<span class="udiff-line-modified-added">+     void setExtra0(byte[] extra, boolean doZIP64, boolean isLOC) {</span>
          if (extra != null) {
              if (extra.length &gt; 0xFFFF) {
                  throw new IllegalArgumentException(&quot;invalid extra field length&quot;);
              }
              // extra fields are in &quot;HeaderID(2)DataSize(2)Data... format
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -548,19 +550,33 @@</span>
                  if (off + sz &gt; len)         // invalid data
                      break;
                  switch (tag) {
                  case EXTID_ZIP64:
                      if (doZIP64) {
<span class="udiff-line-modified-removed">-                         // LOC extra zip64 entry MUST include BOTH original</span>
<span class="udiff-line-modified-removed">-                         // and compressed file size fields.</span>
<span class="udiff-line-modified-removed">-                         // If invalid zip64 extra fields, simply skip. Even</span>
<span class="udiff-line-modified-removed">-                         // it&#39;s rare, it&#39;s possible the entry size happens to</span>
<span class="udiff-line-modified-removed">-                         // be the magic value and it &quot;accidently&quot; has some</span>
<span class="udiff-line-modified-removed">-                         // bytes in extra match the id.</span>
<span class="udiff-line-modified-removed">-                         if (sz &gt;= 16) {</span>
<span class="udiff-line-modified-removed">-                             size = get64(extra, off);</span>
<span class="udiff-line-modified-removed">-                             csize = get64(extra, off + 8);</span>
<span class="udiff-line-modified-added">+                         if (isLOC) {</span>
<span class="udiff-line-modified-added">+                             // LOC extra zip64 entry MUST include BOTH original</span>
<span class="udiff-line-modified-added">+                             // and compressed file size fields.</span>
<span class="udiff-line-modified-added">+                             // If invalid zip64 extra fields, simply skip. Even</span>
<span class="udiff-line-modified-added">+                             // it&#39;s rare, it&#39;s possible the entry size happens to</span>
<span class="udiff-line-modified-added">+                             // be the magic value and it &quot;accidently&quot; has some</span>
<span class="udiff-line-modified-added">+                             // bytes in extra match the id.</span>
<span class="udiff-line-modified-added">+                             if (sz &gt;= 16) {</span>
<span class="udiff-line-modified-added">+                                 size = get64(extra, off);</span>
<span class="udiff-line-added">+                                 csize = get64(extra, off + 8);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         } else {</span>
<span class="udiff-line-added">+                             // CEN extra zip64</span>
<span class="udiff-line-added">+                             if (size == ZIP64_MAGICVAL) {</span>
<span class="udiff-line-added">+                                 if (off + 8 &gt; len)  // invalid zip64 extra</span>
<span class="udiff-line-added">+                                     break;          // fields, just skip</span>
<span class="udiff-line-added">+                                 size = get64(extra, off);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             if (csize == ZIP64_MAGICVAL) {</span>
<span class="udiff-line-added">+                                 if (off + 16 &gt; len)  // invalid zip64 extra</span>
<span class="udiff-line-added">+                                     break;           // fields, just skip</span>
<span class="udiff-line-added">+                                 csize = get64(extra, off + 8);</span>
<span class="udiff-line-added">+                             }</span>
                          }
                      }
                      break;
                  case EXTID_NTFS:
                      if (sz &lt; 32) // reserved  4 bytes + tag 2 bytes + size 2 bytes
</pre>
<center><a href="ZipCoder.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipError.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
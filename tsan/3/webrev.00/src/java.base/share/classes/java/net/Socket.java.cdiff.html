<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/Socket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketAddress.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/Socket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,17 ***</span>
   * questions.
   */
  
  package java.net;
  
  import java.io.InputStream;
  import java.io.OutputStream;
  import java.io.IOException;
  import java.nio.channels.SocketChannel;
  import java.security.AccessController;
<span class="line-removed">- import java.security.PrivilegedExceptionAction;</span>
  import java.security.PrivilegedAction;
  import java.util.Set;
  import java.util.Collections;
  
  /**
   * This class implements client sockets (also called just
<span class="line-new-header">--- 23,21 ---</span>
   * questions.
   */
  
  package java.net;
  
<span class="line-added">+ import sun.security.util.SecurityConstants;</span>
<span class="line-added">+ </span>
  import java.io.InputStream;
  import java.io.OutputStream;
  import java.io.IOException;
<span class="line-added">+ import java.lang.invoke.MethodHandles;</span>
<span class="line-added">+ import java.lang.invoke.VarHandle;</span>
  import java.nio.channels.SocketChannel;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
<span class="line-added">+ import java.util.Objects;</span>
  import java.util.Set;
  import java.util.Collections;
  
  /**
   * This class implements client sockets (also called just
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,18 ***</span>
   * {@code SocketImpl} class. An application, by changing
   * the socket factory that creates the socket implementation,
   * can configure itself to create sockets appropriate to the local
   * firewall.
   *
   * @author  unascribed
   * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
   * @see     java.net.SocketImpl
   * @see     java.nio.channels.SocketChannel
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class Socket implements java.io.Closeable {</span>
      /**
       * Various states of this socket.
       */
      private boolean created = false;
      private boolean bound = false;
<span class="line-new-header">--- 48,63 ---</span>
   * {@code SocketImpl} class. An application, by changing
   * the socket factory that creates the socket implementation,
   * can configure itself to create sockets appropriate to the local
   * firewall.
   *
<span class="line-added">+  * &lt;p&gt; The {@code Socket} class defines convenience</span>
<span class="line-added">+  * methods to set and get several socket options. This class also</span>
<span class="line-added">+  * defines the {@link #setOption(SocketOption, Object) setOption}</span>
<span class="line-added">+  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added">+  * and query socket options.</span>
<span class="line-added">+  * A {@code Socket} support the following options:</span>
<span class="line-added">+  * &lt;blockquote&gt;</span>
<span class="line-added">+  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">+  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added">+  * &lt;thead&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  * &lt;/thead&gt;</span>
<span class="line-added">+  * &lt;tbody&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Keep connection alive &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Re-use address &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_LINGER SO_LINGER} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Linger on close if data is present (when configured in blocking mode</span>
<span class="line-added">+  *          only) &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#TCP_NODELAY TCP_NODELAY} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Disable the Nagle algorithm &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  * &lt;/tbody&gt;</span>
<span class="line-added">+  * &lt;/table&gt;</span>
<span class="line-added">+  * &lt;/blockquote&gt;</span>
<span class="line-added">+  * Additional (implementation specific) options may also be supported.</span>
<span class="line-added">+  *</span>
   * @author  unascribed
   * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
   * @see     java.net.SocketImpl
   * @see     java.nio.channels.SocketChannel
   * @since   1.0
   */
<span class="line-modified">! public class Socket implements java.io.Closeable {</span>
      /**
       * Various states of this socket.
       */
      private boolean created = false;
      private boolean bound = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,17 ***</span>
       * The implementation of this Socket.
       */
      SocketImpl impl;
  
      /**
<span class="line-modified">!      * Are we using an older SocketImpl?</span>
       */
<span class="line-modified">!     private boolean oldImpl = false;</span>
  
      /**
<span class="line-modified">!      * Creates an unconnected socket, with the</span>
<span class="line-modified">!      * system-default type of SocketImpl.</span>
       *
       * @since   1.1
       * @revised 1.4
       */
      public Socket() {
<span class="line-new-header">--- 118,32 ---</span>
       * The implementation of this Socket.
       */
      SocketImpl impl;
  
      /**
<span class="line-modified">!      * Socket input/output streams</span>
       */
<span class="line-modified">!     private volatile InputStream in;</span>
<span class="line-added">+     private volatile OutputStream out;</span>
<span class="line-added">+     private static final VarHandle IN, OUT;</span>
<span class="line-added">+     static {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-added">+             IN = l.findVarHandle(Socket.class, &quot;in&quot;, InputStream.class);</span>
<span class="line-added">+             OUT = l.findVarHandle(Socket.class, &quot;out&quot;, OutputStream.class);</span>
<span class="line-added">+         } catch (Exception e) {</span>
<span class="line-added">+             throw new InternalError(e);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      /**
<span class="line-modified">!      * Creates an unconnected Socket.</span>
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-added">+      * If the application has specified a client socket implementation</span>
<span class="line-added">+      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-added">+      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added">+      * socket implementation is created.</span>
       *
       * @since   1.1
       * @revised 1.4
       */
      public Socket() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,20 ***</span>
                      security.checkConnect(epoint.getHostName(), epoint.getPort());
                  else
                      security.checkConnect(epoint.getAddress().getHostAddress(),
                                    epoint.getPort());
              }
<span class="line-modified">!             impl = type == Proxy.Type.SOCKS ? new SocksSocketImpl(p)</span>
<span class="line-modified">!                                             : new HttpConnectSocketImpl(p);</span>
<span class="line-modified">!             impl.setSocket(this);</span>
          } else {
              if (p == Proxy.NO_PROXY) {
                  if (factory == null) {
<span class="line-modified">!                     impl = new PlainSocketImpl();</span>
<span class="line-modified">!                     impl.setSocket(this);</span>
<span class="line-modified">!                 } else</span>
<span class="line-modified">!                     setImpl();</span>
              } else
                  throw new IllegalArgumentException(&quot;Invalid Proxy&quot;);
          }
      }
  
<span class="line-new-header">--- 199,24 ---</span>
                      security.checkConnect(epoint.getHostName(), epoint.getPort());
                  else
                      security.checkConnect(epoint.getAddress().getHostAddress(),
                                    epoint.getPort());
              }
<span class="line-modified">! </span>
<span class="line-modified">!             // create a SOCKS or HTTP SocketImpl that delegates to a platform SocketImpl</span>
<span class="line-modified">!             SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-added">+             impl = (type == Proxy.Type.SOCKS) ? new SocksSocketImpl(p, delegate)</span>
<span class="line-added">+                                               : new HttpConnectSocketImpl(p, delegate, this);</span>
          } else {
              if (p == Proxy.NO_PROXY) {
<span class="line-added">+                 // create a platform or custom SocketImpl for the DIRECT case</span>
<span class="line-added">+                 SocketImplFactory factory = Socket.factory;</span>
                  if (factory == null) {
<span class="line-modified">!                     impl = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     impl = factory.createSocketImpl();</span>
<span class="line-modified">!                 }</span>
              } else
                  throw new IllegalArgumentException(&quot;Invalid Proxy&quot;);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,20 ***</span>
       * SocketImpl.
       *
       * @param impl an instance of a &lt;B&gt;SocketImpl&lt;/B&gt;
       * the subclass wishes to use on the Socket.
       *
<span class="line-modified">!      * @exception SocketException if there is an error in the underlying protocol,</span>
       * such as a TCP error.
       * @since   1.1
       */
      protected Socket(SocketImpl impl) throws SocketException {
          this.impl = impl;
<span class="line-modified">!         if (impl != null) {</span>
<span class="line-modified">!             checkOldImpl();</span>
<span class="line-modified">!             this.impl.setSocket(this);</span>
          }
      }
  
      /**
       * Creates a stream socket and connects it to the specified port
       * number on the named host.
<span class="line-new-header">--- 225,32 ---</span>
       * SocketImpl.
       *
       * @param impl an instance of a &lt;B&gt;SocketImpl&lt;/B&gt;
       * the subclass wishes to use on the Socket.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error in the underlying protocol,</span>
       * such as a TCP error.
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws SecurityException if {@code impl} is non-null and a security manager is set</span>
<span class="line-added">+      * and its {@code checkPermission} method doesn&#39;t allow {@code NetPermission(&quot;setSocketImpl&quot;)}.</span>
<span class="line-added">+      *</span>
       * @since   1.1
       */
      protected Socket(SocketImpl impl) throws SocketException {
<span class="line-added">+         checkPermission(impl);</span>
          this.impl = impl;
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static Void checkPermission(SocketImpl impl) {</span>
<span class="line-added">+         if (impl == null) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+         if (sm != null) {</span>
<span class="line-added">+             sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);</span>
          }
<span class="line-added">+         return null;</span>
      }
  
      /**
       * Creates a stream socket and connects it to the specified port
       * number on the named host.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,29 ***</span>
       * specifying the address as
       * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
       * In other words, it is equivalent to specifying an address of the
       * loopback interface. &lt;/p&gt;
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a server socket factory, that</span>
<span class="line-modified">!      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified">!      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>
       * &lt;p&gt;
       * If there is a security manager, its
       * {@code checkConnect} method is called
       * with the host address and {@code port}
       * as its arguments. This could result in a SecurityException.
       *
       * @param      host   the host name, or {@code null} for the loopback address.
       * @param      port   the port number.
       *
<span class="line-modified">!      * @exception  UnknownHostException if the IP address of</span>
       * the host could not be determined.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @exception  IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
<span class="line-new-header">--- 259,30 ---</span>
       * specifying the address as
       * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
       * In other words, it is equivalent to specifying an address of the
       * loopback interface. &lt;/p&gt;
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a client socket implementation</span>
<span class="line-modified">!      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified">!      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added">+      * socket implementation is created.</span>
       * &lt;p&gt;
       * If there is a security manager, its
       * {@code checkConnect} method is called
       * with the host address and {@code port}
       * as its arguments. This could result in a SecurityException.
       *
       * @param      host   the host name, or {@code null} for the loopback address.
       * @param      port   the port number.
       *
<span class="line-modified">!      * @throws     UnknownHostException if the IP address of</span>
       * the host could not be determined.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,28 ***</span>
  
      /**
       * Creates a stream socket and connects it to the specified port
       * number at the specified IP address.
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a socket factory, that factory&#39;s</span>
<span class="line-modified">!      * {@code createSocketImpl} method is called to create the</span>
<span class="line-modified">!      * actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>
       * &lt;p&gt;
       * If there is a security manager, its
       * {@code checkConnect} method is called
       * with the host address and {@code port}
       * as its arguments. This could result in a SecurityException.
       *
       * @param      address   the IP address.
       * @param      port      the port number.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @exception  IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
<span class="line-modified">!      * @exception  NullPointerException if {@code address} is null.</span>
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkConnect
       */
<span class="line-new-header">--- 298,29 ---</span>
  
      /**
       * Creates a stream socket and connects it to the specified port
       * number at the specified IP address.
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a client socket implementation</span>
<span class="line-modified">!      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified">!      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added">+      * socket implementation is created.</span>
       * &lt;p&gt;
       * If there is a security manager, its
       * {@code checkConnect} method is called
       * with the host address and {@code port}
       * as its arguments. This could result in a SecurityException.
       *
       * @param      address   the IP address.
       * @param      port      the port number.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
<span class="line-modified">!      * @throws     NullPointerException if {@code address} is null.</span>
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkConnect
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,16 ***</span>
       * @param port the remote port
       * @param localAddr the local address the socket is bound to, or
       *        {@code null} for the {@code anyLocal} address.
       * @param localPort the local port the socket is bound to, or
       *        {@code zero} for a system selected free port.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the connection
       *             to the destination, or if its {@code checkListen} method
       *             doesn&#39;t allow the bind to the local port.
<span class="line-modified">!      * @exception  IllegalArgumentException if the port parameter or localPort</span>
       *             parameter is outside the specified range of valid port values,
       *             which is between 0 and 65535, inclusive.
       * @see        SecurityManager#checkConnect
       * @since   1.1
       */
<span class="line-new-header">--- 352,16 ---</span>
       * @param port the remote port
       * @param localAddr the local address the socket is bound to, or
       *        {@code null} for the {@code anyLocal} address.
       * @param localPort the local port the socket is bound to, or
       *        {@code zero} for a system selected free port.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the connection
       *             to the destination, or if its {@code checkListen} method
       *             doesn&#39;t allow the bind to the local port.
<span class="line-modified">!      * @throws     IllegalArgumentException if the port parameter or localPort</span>
       *             parameter is outside the specified range of valid port values,
       *             which is between 0 and 65535, inclusive.
       * @see        SecurityManager#checkConnect
       * @since   1.1
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,19 ***</span>
       * @param port the remote port
       * @param localAddr the local address the socket is bound to, or
       *        {@code null} for the {@code anyLocal} address.
       * @param localPort the local port the socket is bound to or
       *        {@code zero} for a system selected free port.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the connection
       *             to the destination, or if its {@code checkListen} method
       *             doesn&#39;t allow the bind to the local port.
<span class="line-modified">!      * @exception  IllegalArgumentException if the port parameter or localPort</span>
       *             parameter is outside the specified range of valid port values,
       *             which is between 0 and 65535, inclusive.
<span class="line-modified">!      * @exception  NullPointerException if {@code address} is null.</span>
       * @see        SecurityManager#checkConnect
       * @since   1.1
       */
      public Socket(InetAddress address, int port, InetAddress localAddr,
                    int localPort) throws IOException {
<span class="line-new-header">--- 393,19 ---</span>
       * @param port the remote port
       * @param localAddr the local address the socket is bound to, or
       *        {@code null} for the {@code anyLocal} address.
       * @param localPort the local port the socket is bound to or
       *        {@code zero} for a system selected free port.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the connection
       *             to the destination, or if its {@code checkListen} method
       *             doesn&#39;t allow the bind to the local port.
<span class="line-modified">!      * @throws     IllegalArgumentException if the port parameter or localPort</span>
       *             parameter is outside the specified range of valid port values,
       *             which is between 0 and 65535, inclusive.
<span class="line-modified">!      * @throws     NullPointerException if {@code address} is null.</span>
       * @see        SecurityManager#checkConnect
       * @since   1.1
       */
      public Socket(InetAddress address, int port, InetAddress localAddr,
                    int localPort) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,13 ***</span>
       * &lt;p&gt;
       * If the stream argument is {@code true}, this creates a
       * stream socket. If the stream argument is {@code false}, it
       * creates a datagram socket.
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a server socket factory, that</span>
<span class="line-modified">!      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified">!      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>
       * &lt;p&gt;
       * If there is a security manager, its
       * {@code checkConnect} method is called
       * with the host address and {@code port}
       * as its arguments. This could result in a SecurityException.
<span class="line-new-header">--- 425,14 ---</span>
       * &lt;p&gt;
       * If the stream argument is {@code true}, this creates a
       * stream socket. If the stream argument is {@code false}, it
       * creates a datagram socket.
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a client socket implementation</span>
<span class="line-modified">!      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified">!      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added">+      * socket implementation is created.</span>
       * &lt;p&gt;
       * If there is a security manager, its
       * {@code checkConnect} method is called
       * with the host address and {@code port}
       * as its arguments. This could result in a SecurityException.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,14 ***</span>
       *
       * @param      host     the host name, or {@code null} for the loopback address.
       * @param      port     the port number.
       * @param      stream   a {@code boolean} indicating whether this is
       *                      a stream socket or a datagram socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @exception  IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
<span class="line-new-header">--- 441,14 ---</span>
       *
       * @param      host     the host name, or {@code null} for the loopback address.
       * @param      port     the port number.
       * @param      stream   a {@code boolean} indicating whether this is
       *                      a stream socket or a datagram socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,13 ***</span>
       * &lt;p&gt;
       * If the stream argument is {@code true}, this creates a
       * stream socket. If the stream argument is {@code false}, it
       * creates a datagram socket.
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a server socket factory, that</span>
<span class="line-modified">!      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified">!      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>
       *
       * &lt;p&gt;If there is a security manager, its
       * {@code checkConnect} method is called
       * with {@code host.getHostAddress()} and {@code port}
       * as its arguments. This could result in a SecurityException.
<span class="line-new-header">--- 468,14 ---</span>
       * &lt;p&gt;
       * If the stream argument is {@code true}, this creates a
       * stream socket. If the stream argument is {@code false}, it
       * creates a datagram socket.
       * &lt;p&gt;
<span class="line-modified">!      * If the application has specified a client socket implementation</span>
<span class="line-modified">!      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified">!      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added">+      * socket implementation is created.</span>
       *
       * &lt;p&gt;If there is a security manager, its
       * {@code checkConnect} method is called
       * with {@code host.getHostAddress()} and {@code port}
       * as its arguments. This could result in a SecurityException.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 400,17 ***</span>
       *
       * @param      host     the IP address.
       * @param      port      the port number.
       * @param      stream    if {@code true}, create a stream socket;
       *                       otherwise, create a datagram socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @exception  IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
<span class="line-modified">!      * @exception  NullPointerException if {@code host} is null.</span>
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkConnect
       * @deprecated Use DatagramSocket instead for UDP transport.
<span class="line-new-header">--- 484,17 ---</span>
       *
       * @param      host     the IP address.
       * @param      port      the port number.
       * @param      stream    if {@code true}, create a stream socket;
       *                       otherwise, create a datagram socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified">!      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
<span class="line-modified">!      * @throws     NullPointerException if {@code host} is null.</span>
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkConnect
       * @deprecated Use DatagramSocket instead for UDP transport.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,56 ***</span>
          } catch (IOException e) {
              throw new SocketException(e.getMessage());
          }
      }
  
<span class="line-modified">!     private void checkOldImpl() {</span>
<span class="line-modified">!         if (impl == null)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         // SocketImpl.connect() is a protected method, therefore we need to use</span>
<span class="line-removed">-         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="line-removed">- </span>
<span class="line-removed">-         oldImpl = AccessController.doPrivileged</span>
<span class="line-removed">-                                 (new PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed">-             public Boolean run() {</span>
<span class="line-removed">-                 Class&lt;?&gt; clazz = impl.getClass();</span>
<span class="line-removed">-                 while (true) {</span>
<span class="line-removed">-                     try {</span>
<span class="line-removed">-                         clazz.getDeclaredMethod(&quot;connect&quot;, SocketAddress.class, int.class);</span>
<span class="line-removed">-                         return Boolean.FALSE;</span>
<span class="line-removed">-                     } catch (NoSuchMethodException e) {</span>
<span class="line-removed">-                         clazz = clazz.getSuperclass();</span>
<span class="line-removed">-                         // java.net.SocketImpl class will always have this abstract method.</span>
<span class="line-removed">-                         // If we have not found it by now in the hierarchy then it does not</span>
<span class="line-removed">-                         // exist, we are an old style impl.</span>
<span class="line-removed">-                         if (clazz.equals(java.net.SocketImpl.class)) {</span>
<span class="line-removed">-                             return Boolean.TRUE;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         });</span>
      }
  
      /**
       * Sets impl to the system-default type of SocketImpl.
       * @since 1.4
       */
      void setImpl() {
          if (factory != null) {
              impl = factory.createSocketImpl();
<span class="line-removed">-             checkOldImpl();</span>
          } else {
<span class="line-modified">!             // No need to do a checkOldImpl() here, we know it&#39;s an up to date</span>
<span class="line-modified">!             // SocketImpl!</span>
<span class="line-modified">!             impl = new SocksSocketImpl();</span>
          }
<span class="line-removed">-         if (impl != null)</span>
<span class="line-removed">-             impl.setSocket(this);</span>
      }
  
<span class="line-removed">- </span>
      /**
       * Get the {@code SocketImpl} attached to this socket, creating
       * it if necessary.
       *
       * @return  the {@code SocketImpl} attached to that ServerSocket.
<span class="line-new-header">--- 545,29 ---</span>
          } catch (IOException e) {
              throw new SocketException(e.getMessage());
          }
      }
  
<span class="line-modified">!     void setImpl(SocketImpl si) {</span>
<span class="line-modified">!          impl = si;</span>
      }
  
      /**
       * Sets impl to the system-default type of SocketImpl.
       * @since 1.4
       */
      void setImpl() {
<span class="line-added">+         SocketImplFactory factory = Socket.factory;</span>
          if (factory != null) {
              impl = factory.createSocketImpl();
          } else {
<span class="line-modified">!             // create a SOCKS SocketImpl that delegates to a platform SocketImpl</span>
<span class="line-modified">!             SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-modified">!             impl = new SocksSocketImpl(delegate);</span>
          }
      }
  
      /**
       * Get the {@code SocketImpl} attached to this socket, creating
       * it if necessary.
       *
       * @return  the {@code SocketImpl} attached to that ServerSocket.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,11 ***</span>
       * @throws  SocketTimeoutException if timeout expires before connecting
       * @throws  java.nio.channels.IllegalBlockingModeException
       *          if this socket has an associated channel,
       *          and the channel is in non-blocking mode
       * @throws  IllegalArgumentException if endpoint is null or is a
<span class="line-modified">!      *          SocketAddress subclass not supported by this socket</span>
       * @since 1.4
       * @spec JSR-51
       */
      public void connect(SocketAddress endpoint, int timeout) throws IOException {
          if (endpoint == null)
<span class="line-new-header">--- 608,12 ---</span>
       * @throws  SocketTimeoutException if timeout expires before connecting
       * @throws  java.nio.channels.IllegalBlockingModeException
       *          if this socket has an associated channel,
       *          and the channel is in non-blocking mode
       * @throws  IllegalArgumentException if endpoint is null or is a
<span class="line-modified">!      *          SocketAddress subclass not supported by this socket, or</span>
<span class="line-added">+      *          if {@code timeout} is negative</span>
       * @since 1.4
       * @spec JSR-51
       */
      public void connect(SocketAddress endpoint, int timeout) throws IOException {
          if (endpoint == null)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,11 ***</span>
            throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
  
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
  
<span class="line-modified">!         if (!oldImpl &amp;&amp; isConnected())</span>
              throw new SocketException(&quot;already connected&quot;);
  
          if (!(endpoint instanceof InetSocketAddress))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
  
<span class="line-new-header">--- 623,11 ---</span>
            throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
  
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
  
<span class="line-modified">!         if (isConnected())</span>
              throw new SocketException(&quot;already connected&quot;);
  
          if (!(endpoint instanceof InetSocketAddress))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,19 ***</span>
              else
                  security.checkConnect(addr.getHostAddress(), port);
          }
          if (!created)
              createImpl(true);
<span class="line-modified">!         if (!oldImpl)</span>
<span class="line-removed">-             impl.connect(epoint, timeout);</span>
<span class="line-removed">-         else if (timeout == 0) {</span>
<span class="line-removed">-             if (epoint.isUnresolved())</span>
<span class="line-removed">-                 impl.connect(addr.getHostName(), port);</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 impl.connect(addr, port);</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             throw new UnsupportedOperationException(&quot;SocketImpl.connect(addr, timeout)&quot;);</span>
          connected = true;
          /*
           * If the socket was not bound before the connect, it is now because
           * the kernel will have picked an ephemeral port &amp; a local address
           */
<span class="line-new-header">--- 643,11 ---</span>
              else
                  security.checkConnect(addr.getHostAddress(), port);
          }
          if (!created)
              createImpl(true);
<span class="line-modified">!         impl.connect(epoint, timeout);</span>
          connected = true;
          /*
           * If the socket was not bound before the connect, it is now because
           * the kernel will have picked an ephemeral port &amp; a local address
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,11 ***</span>
       * @see #isBound
       */
      public void bind(SocketAddress bindpoint) throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified">!         if (!oldImpl &amp;&amp; isBound())</span>
              throw new SocketException(&quot;Already bound&quot;);
  
          if (bindpoint != null &amp;&amp; (!(bindpoint instanceof InetSocketAddress)))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
          InetSocketAddress epoint = (InetSocketAddress) bindpoint;
<span class="line-new-header">--- 673,11 ---</span>
       * @see #isBound
       */
      public void bind(SocketAddress bindpoint) throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified">!         if (isBound())</span>
              throw new SocketException(&quot;Already bound&quot;);
  
          if (bindpoint != null &amp;&amp; (!(bindpoint instanceof InetSocketAddress)))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
          InetSocketAddress epoint = (InetSocketAddress) bindpoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 663,22 ***</span>
          connected = true;
          created = true;
          bound = true;
      }
  
<span class="line-removed">-     void setCreated() {</span>
<span class="line-removed">-         created = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setBound() {</span>
<span class="line-removed">-         bound = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setConnected() {</span>
<span class="line-removed">-         connected = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Returns the address to which the socket is connected.
       * &lt;p&gt;
       * If the socket was connected prior to being {@link #close closed},
       * then this method will continue to return the connected address
<span class="line-new-header">--- 713,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 890,11 ***</span>
       *
       * &lt;p&gt; Closing the returned {@link java.io.InputStream InputStream}
       * will close the associated socket.
       *
       * @return     an input stream for reading bytes from this socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the</span>
       *             input stream, the socket is closed, the socket is
       *             not connected, or the socket input has been shutdown
       *             using {@link #shutdownInput()}
       *
       * @revised 1.4
<span class="line-new-header">--- 928,11 ---</span>
       *
       * &lt;p&gt; Closing the returned {@link java.io.InputStream InputStream}
       * will close the associated socket.
       *
       * @return     an input stream for reading bytes from this socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the</span>
       *             input stream, the socket is closed, the socket is
       *             not connected, or the socket input has been shutdown
       *             using {@link #shutdownInput()}
       *
       * @revised 1.4
</pre>
<hr />
<pre>
<span class="line-old-header">*** 905,22 ***</span>
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (isInputShutdown())
              throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">!         InputStream is = null;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             is = AccessController.doPrivileged(</span>
<span class="line-modified">!                 new PrivilegedExceptionAction&lt;&gt;() {</span>
<span class="line-modified">!                     public InputStream run() throws IOException {</span>
<span class="line-modified">!                         return impl.getInputStream();</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 });</span>
<span class="line-modified">!         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified">!             throw (IOException) e.getException();</span>
          }
<span class="line-removed">-         return is;</span>
      }
  
      /**
       * Returns an output stream for this socket.
       *
<span class="line-new-header">--- 943,55 ---</span>
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (isInputShutdown())
              throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">!         InputStream in = this.in;</span>
<span class="line-modified">!         if (in == null) {</span>
<span class="line-modified">!             // wrap the input stream so that the close method closes this socket</span>
<span class="line-modified">!             in = new SocketInputStream(this, impl.getInputStream());</span>
<span class="line-modified">!             if (!IN.compareAndSet(this, null, in)) {</span>
<span class="line-modified">!                 in = this.in;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return in;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * An InputStream that delegates read/available operations to an underlying</span>
<span class="line-added">+      * input stream. The close method is overridden to close the Socket.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This class is instrumented by Java Flight Recorder (JFR) to get socket</span>
<span class="line-added">+      * I/O events.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class SocketInputStream extends InputStream {</span>
<span class="line-added">+         private final Socket parent;</span>
<span class="line-added">+         private final InputStream in;</span>
<span class="line-added">+ </span>
<span class="line-added">+         SocketInputStream(Socket parent, InputStream in) {</span>
<span class="line-added">+             this.parent = parent;</span>
<span class="line-added">+             this.in = in;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int read() throws IOException {</span>
<span class="line-added">+             byte[] a = new byte[1];</span>
<span class="line-added">+             int n = read(a, 0, 1);</span>
<span class="line-added">+             return (n &gt; 0) ? (a[0] &amp; 0xff) : -1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int read(byte b[], int off, int len) throws IOException {</span>
<span class="line-added">+             return in.read(b, off, len);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int available() throws IOException {</span>
<span class="line-added">+             return in.available();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void close() throws IOException {</span>
<span class="line-added">+             parent.close();</span>
          }
      }
  
      /**
       * Returns an output stream for this socket.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 932,11 ***</span>
       *
       * &lt;p&gt; Closing the returned {@link java.io.OutputStream OutputStream}
       * will close the associated socket.
       *
       * @return     an output stream for writing bytes to this socket.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when creating the</span>
       *               output stream or if the socket is not connected.
       * @revised 1.4
       * @spec JSR-51
       */
      public OutputStream getOutputStream() throws IOException {
<span class="line-new-header">--- 1003,11 ---</span>
       *
       * &lt;p&gt; Closing the returned {@link java.io.OutputStream OutputStream}
       * will close the associated socket.
       *
       * @return     an output stream for writing bytes to this socket.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when creating the</span>
       *               output stream or if the socket is not connected.
       * @revised 1.4
       * @spec JSR-51
       */
      public OutputStream getOutputStream() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 944,32 ***</span>
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (isOutputShutdown())
              throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">!         OutputStream os = null;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             os = AccessController.doPrivileged(</span>
<span class="line-modified">!                 new PrivilegedExceptionAction&lt;&gt;() {</span>
<span class="line-modified">!                     public OutputStream run() throws IOException {</span>
<span class="line-modified">!                         return impl.getOutputStream();</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 });</span>
<span class="line-modified">!         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified">!             throw (IOException) e.getException();</span>
          }
<span class="line-removed">-         return os;</span>
      }
  
      /**
       * Enable/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}
       * (disable/enable Nagle&#39;s algorithm).
       *
       * @param on {@code true} to enable TCP_NODELAY,
       * {@code false} to disable.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @since   1.1
       *
       * @see #getTcpNoDelay()
<span class="line-new-header">--- 1015,59 ---</span>
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (isOutputShutdown())
              throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">!         OutputStream out = this.out;</span>
<span class="line-modified">!         if (out == null) {</span>
<span class="line-modified">!             // wrap the output stream so that the close method closes this socket</span>
<span class="line-modified">!             out = new SocketOutputStream(this, impl.getOutputStream());</span>
<span class="line-modified">!             if (!OUT.compareAndSet(this, null, out)) {</span>
<span class="line-modified">!                 out = this.out;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return out;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * An OutputStream that delegates write operations to an underlying output</span>
<span class="line-added">+      * stream. The close method is overridden to close the Socket.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This class is instrumented by Java Flight Recorder (JFR) to get socket</span>
<span class="line-added">+      * I/O events.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class SocketOutputStream extends OutputStream {</span>
<span class="line-added">+         private final Socket parent;</span>
<span class="line-added">+         private final OutputStream out;</span>
<span class="line-added">+         SocketOutputStream(Socket parent, OutputStream out) {</span>
<span class="line-added">+             this.parent = parent;</span>
<span class="line-added">+             this.out = out;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void write(int b) throws IOException {</span>
<span class="line-added">+             byte[] a = new byte[] { (byte) b };</span>
<span class="line-added">+             write(a, 0, 1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void write(byte b[], int off, int len) throws IOException {</span>
<span class="line-added">+             out.write(b, off, len);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void close() throws IOException {</span>
<span class="line-added">+             parent.close();</span>
          }
      }
  
      /**
       * Enable/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}
       * (disable/enable Nagle&#39;s algorithm).
       *
       * @param on {@code true} to enable TCP_NODELAY,
       * {@code false} to disable.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @since   1.1
       *
       * @see #getTcpNoDelay()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,11 ***</span>
      /**
       * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.1
       * @see #setTcpNoDelay(boolean)
       */
      public boolean getTcpNoDelay() throws SocketException {
<span class="line-new-header">--- 1081,11 ---</span>
      /**
       * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.1
       * @see #setTcpNoDelay(boolean)
       */
      public boolean getTcpNoDelay() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1003,13 ***</span>
       *
       * The setting only affects socket close.
       *
       * @param on     whether or not to linger on.
       * @param linger how long to linger for, if on is true.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
<span class="line-modified">!      * @exception IllegalArgumentException if the linger value is negative.</span>
       * @since 1.1
       * @see #getSoLinger()
       */
      public void setSoLinger(boolean on, int linger) throws SocketException {
          if (isClosed())
<span class="line-new-header">--- 1101,13 ---</span>
       *
       * The setting only affects socket close.
       *
       * @param on     whether or not to linger on.
       * @param linger how long to linger for, if on is true.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
<span class="line-modified">!      * @throws    IllegalArgumentException if the linger value is negative.</span>
       * @since 1.1
       * @see #getSoLinger()
       */
      public void setSoLinger(boolean on, int linger) throws SocketException {
          if (isClosed())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1032,11 ***</span>
       * option is disabled.
       *
       * The setting only affects socket close.
       *
       * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.1
       * @see #setSoLinger(boolean, int)
       */
      public int getSoLinger() throws SocketException {
<span class="line-new-header">--- 1130,11 ---</span>
       * option is disabled.
       *
       * The setting only affects socket close.
       *
       * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.1
       * @see #setSoLinger(boolean, int)
       */
      public int getSoLinger() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1054,11 ***</span>
       * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight
       * bits of the data parameter. The urgent byte is
       * sent after any preceding writes to the socket OutputStream
       * and before any future writes to the OutputStream.
       * @param data The byte of data to send
<span class="line-modified">!      * @exception IOException if there is an error</span>
       *  sending the data.
       * @since 1.4
       */
      public void sendUrgentData (int data) throws IOException  {
          if (!getImpl().supportsUrgentData ()) {
<span class="line-new-header">--- 1152,11 ---</span>
       * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight
       * bits of the data parameter. The urgent byte is
       * sent after any preceding writes to the socket OutputStream
       * and before any future writes to the OutputStream.
       * @param data The byte of data to send
<span class="line-modified">!      * @throws    IOException if there is an error</span>
       *  sending the data.
       * @since 1.4
       */
      public void sendUrgentData (int data) throws IOException  {
          if (!getImpl().supportsUrgentData ()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1083,11 ***</span>
       *
       * @param on {@code true} to enable
       *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},
       *           {@code false} to disable.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @since   1.4
       *
       * @see #getOOBInline()
<span class="line-new-header">--- 1181,11 ---</span>
       *
       * @param on {@code true} to enable
       *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},
       *           {@code false} to disable.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @since   1.4
       *
       * @see #getOOBInline()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1102,11 ***</span>
       * Tests if {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.4
       * @see #setOOBInline(boolean)
       */
      public boolean getOOBInline() throws SocketException {
<span class="line-new-header">--- 1200,11 ---</span>
       * Tests if {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.4
       * @see #setOOBInline(boolean)
       */
      public boolean getOOBInline() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1116,21 ***</span>
      }
  
      /**
       *  Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
       *  with the specified timeout, in milliseconds. With this option set
<span class="line-modified">!      *  to a non-zero timeout, a read() call on the InputStream associated with</span>
       *  this Socket will block for only this amount of time.  If the timeout
       *  expires, a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="line-modified">!      *  Socket is still valid. The option &lt;B&gt;must&lt;/B&gt; be enabled</span>
<span class="line-modified">!      *  prior to entering the blocking operation to have effect. The</span>
<span class="line-modified">!      *  timeout must be {@code &gt; 0}.</span>
<span class="line-removed">-      *  A timeout of zero is interpreted as an infinite timeout.</span>
       *
       * @param timeout the specified timeout, in milliseconds.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
<span class="line-modified">!      * in the underlying protocol, such as a TCP error.</span>
       * @since   1.1
       * @see #getSoTimeout()
       */
      public synchronized void setSoTimeout(int timeout) throws SocketException {
          if (isClosed())
<span class="line-new-header">--- 1214,21 ---</span>
      }
  
      /**
       *  Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
       *  with the specified timeout, in milliseconds. With this option set
<span class="line-modified">!      *  to a positive timeout value, a read() call on the InputStream associated with</span>
       *  this Socket will block for only this amount of time.  If the timeout
       *  expires, a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="line-modified">!      *  Socket is still valid. A timeout of zero is interpreted as an infinite timeout.</span>
<span class="line-modified">!      *  The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking operation</span>
<span class="line-modified">!      *  to have effect.</span>
       *
       * @param timeout the specified timeout, in milliseconds.
<span class="line-modified">!      * @throws  SocketException if there is an error in the underlying protocol,</span>
<span class="line-modified">!      *          such as a TCP error</span>
<span class="line-added">+      * @throws  IllegalArgumentException if {@code timeout} is negative</span>
       * @since   1.1
       * @see #getSoTimeout()
       */
      public synchronized void setSoTimeout(int timeout) throws SocketException {
          if (isClosed())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1144,11 ***</span>
      /**
       * Returns setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
       * 0 returns implies that the option is disabled (i.e., timeout of infinity).
       *
       * @return the setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @since   1.1
       * @see #setSoTimeout(int)
       */
<span class="line-new-header">--- 1242,11 ---</span>
      /**
       * Returns setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
       * 0 returns implies that the option is disabled (i.e., timeout of infinity).
       *
       * @return the setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @since   1.1
       * @see #setSoTimeout(int)
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,17 ***</span>
       *
       * &lt;p&gt;Because {@link SocketOptions#SO_SNDBUF SO_SNDBUF} is a hint,
       * applications that want to verify what size the buffers were set to
       * should call {@link #getSendBufferSize()}.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @param size the size to which to set the send buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @exception IllegalArgumentException if the</span>
       * value is 0 or is negative.
       *
       * @see #getSendBufferSize()
       * @since 1.2
       */
<span class="line-new-header">--- 1271,17 ---</span>
       *
       * &lt;p&gt;Because {@link SocketOptions#SO_SNDBUF SO_SNDBUF} is a hint,
       * applications that want to verify what size the buffers were set to
       * should call {@link #getSendBufferSize()}.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @param size the size to which to set the send buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @throws    IllegalArgumentException if the</span>
       * value is 0 or is negative.
       *
       * @see #getSendBufferSize()
       * @since 1.2
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1202,11 ***</span>
       * for this {@code Socket}, that is the buffer size used by the platform
       * for output on this {@code Socket}.
       * @return the value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF}
       *         option for this {@code Socket}.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @see #setSendBufferSize(int)
       * @since 1.2
       */
<span class="line-new-header">--- 1300,11 ---</span>
       * for this {@code Socket}, that is the buffer size used by the platform
       * for output on this {@code Socket}.
       * @return the value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF}
       *         option for this {@code Socket}.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @see #setSendBufferSize(int)
       * @since 1.2
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,14 ***</span>
       * &lt;li&gt;For client sockets, setReceiveBufferSize() must be called before
       * connecting the socket to its remote peer.&lt;/li&gt;&lt;/ol&gt;
       * @param size the size to which to set the receive buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @exception IllegalArgumentException if the value is 0 or is</span>
       * negative.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @see #getReceiveBufferSize()
       * @see ServerSocket#setReceiveBufferSize(int)
       * @since 1.2
<span class="line-new-header">--- 1347,14 ---</span>
       * &lt;li&gt;For client sockets, setReceiveBufferSize() must be called before
       * connecting the socket to its remote peer.&lt;/li&gt;&lt;/ol&gt;
       * @param size the size to which to set the receive buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @throws    IllegalArgumentException if the value is 0 or is</span>
       * negative.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @see #getReceiveBufferSize()
       * @see ServerSocket#setReceiveBufferSize(int)
       * @since 1.2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1276,11 ***</span>
       * for this {@code Socket}, that is the buffer size used by the platform
       * for input on this {@code Socket}.
       *
       * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
       *         option for this {@code Socket}.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @see #setReceiveBufferSize(int)
       * @since 1.2
       */
      public synchronized int getReceiveBufferSize()
<span class="line-new-header">--- 1374,11 ---</span>
       * for this {@code Socket}, that is the buffer size used by the platform
       * for input on this {@code Socket}.
       *
       * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
       *         option for this {@code Socket}.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @see #setReceiveBufferSize(int)
       * @since 1.2
       */
      public synchronized int getReceiveBufferSize()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1297,11 ***</span>
  
      /**
       * Enable/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.
       *
       * @param on  whether or not to have socket keep alive turned on.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since 1.3
       * @see #getKeepAlive()
       */
      public void setKeepAlive(boolean on) throws SocketException {
<span class="line-new-header">--- 1395,11 ---</span>
  
      /**
       * Enable/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.
       *
       * @param on  whether or not to have socket keep alive turned on.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since 1.3
       * @see #getKeepAlive()
       */
      public void setKeepAlive(boolean on) throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1313,11 ***</span>
      /**
       * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.3
       * @see #setKeepAlive(boolean)
       */
      public boolean getKeepAlive() throws SocketException {
<span class="line-new-header">--- 1411,11 ---</span>
      /**
       * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.3
       * @see #setKeepAlive(boolean)
       */
      public boolean getKeepAlive() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1432,11 ***</span>
       * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
       * enabled or disabled after a socket is bound (See {@link #isBound()})
       * is not defined.
       *
       * @param on  whether to enable or disable the socket option
<span class="line-modified">!      * @exception SocketException if an error occurs enabling or</span>
       *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
       *            socket option, or the socket is closed.
       * @since 1.4
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
<span class="line-new-header">--- 1530,11 ---</span>
       * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
       * enabled or disabled after a socket is bound (See {@link #isBound()})
       * is not defined.
       *
       * @param on  whether to enable or disable the socket option
<span class="line-modified">!      * @throws    SocketException if an error occurs enabling or</span>
       *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
       *            socket option, or the socket is closed.
       * @since 1.4
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1452,11 ***</span>
      /**
       * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
      public boolean getReuseAddress() throws SocketException {
<span class="line-new-header">--- 1550,11 ---</span>
      /**
       * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
      public boolean getReuseAddress() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1480,11 ***</span>
       * {@link java.io.OutputStream OutputStream}.
       *
       * &lt;p&gt; If this socket has an associated channel then the channel is closed
       * as well.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when closing this socket.</span>
       * @revised 1.4
       * @spec JSR-51
       * @see #isClosed
       */
      public synchronized void close() throws IOException {
<span class="line-new-header">--- 1578,11 ---</span>
       * {@link java.io.OutputStream OutputStream}.
       *
       * &lt;p&gt; If this socket has an associated channel then the channel is closed
       * as well.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when closing this socket.</span>
       * @revised 1.4
       * @spec JSR-51
       * @see #isClosed
       */
      public synchronized void close() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1504,11 ***</span>
       * &lt;p&gt;
       * If you read from a socket input stream after invoking this method on the
       * socket, the stream&#39;s {@code available} method will return 0, and its
       * {@code read} methods will return {@code -1} (end of stream).
       *
<span class="line-modified">!      * @exception IOException if an I/O error occurs when shutting down this</span>
       * socket.
       *
       * @since 1.3
       * @see java.net.Socket#shutdownOutput()
       * @see java.net.Socket#close()
<span class="line-new-header">--- 1602,11 ---</span>
       * &lt;p&gt;
       * If you read from a socket input stream after invoking this method on the
       * socket, the stream&#39;s {@code available} method will return 0, and its
       * {@code read} methods will return {@code -1} (end of stream).
       *
<span class="line-modified">!      * @throws    IOException if an I/O error occurs when shutting down this</span>
       * socket.
       *
       * @since 1.3
       * @see java.net.Socket#shutdownOutput()
       * @see java.net.Socket#close()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1534,11 ***</span>
       *
       * If you write to a socket output stream after invoking
       * shutdownOutput() on the socket, the stream will throw
       * an IOException.
       *
<span class="line-modified">!      * @exception IOException if an I/O error occurs when shutting down this</span>
       * socket.
       *
       * @since 1.3
       * @see java.net.Socket#shutdownInput()
       * @see java.net.Socket#close()
<span class="line-new-header">--- 1632,11 ---</span>
       *
       * If you write to a socket output stream after invoking
       * shutdownOutput() on the socket, the stream will throw
       * an IOException.
       *
<span class="line-modified">!      * @throws    IOException if an I/O error occurs when shutting down this</span>
       * socket.
       *
       * @since 1.3
       * @see java.net.Socket#shutdownInput()
       * @see java.net.Socket#close()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1583,12 ***</span>
       *
       * @return true if the socket was successfully connected to a server
       * @since 1.4
       */
      public boolean isConnected() {
<span class="line-modified">!         // Before 1.3 Sockets were always connected during creation</span>
<span class="line-removed">-         return connected || oldImpl;</span>
      }
  
      /**
       * Returns the binding state of the socket.
       * &lt;p&gt;
<span class="line-new-header">--- 1681,11 ---</span>
       *
       * @return true if the socket was successfully connected to a server
       * @since 1.4
       */
      public boolean isConnected() {
<span class="line-modified">!         return connected;</span>
      }
  
      /**
       * Returns the binding state of the socket.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1600,12 ***</span>
       * @return true if the socket was successfully bound to an address
       * @since 1.4
       * @see #bind
       */
      public boolean isBound() {
<span class="line-modified">!         // Before 1.3 Sockets were always bound during creation</span>
<span class="line-removed">-         return bound || oldImpl;</span>
      }
  
      /**
       * Returns the closed state of the socket.
       *
<span class="line-new-header">--- 1697,11 ---</span>
       * @return true if the socket was successfully bound to an address
       * @since 1.4
       * @see #bind
       */
      public boolean isBound() {
<span class="line-modified">!         return bound;</span>
      }
  
      /**
       * Returns the closed state of the socket.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1642,11 ***</span>
      }
  
      /**
       * The factory for all client sockets.
       */
<span class="line-modified">!     private static SocketImplFactory factory = null;</span>
  
      /**
       * Sets the client socket implementation factory for the
       * application. The factory can be specified only once.
       * &lt;p&gt;
<span class="line-new-header">--- 1738,15 ---</span>
      }
  
      /**
       * The factory for all client sockets.
       */
<span class="line-modified">!     private static volatile SocketImplFactory factory;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static SocketImplFactory socketImplFactory() {</span>
<span class="line-added">+         return factory;</span>
<span class="line-added">+     }</span>
  
      /**
       * Sets the client socket implementation factory for the
       * application. The factory can be specified only once.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1660,14 ***</span>
       * the security manager&#39;s {@code checkSetFactory} method
       * to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      fac   the desired factory.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when setting the</span>
       *               socket factory.
<span class="line-modified">!      * @exception  SocketException  if the factory is already defined.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkSetFactory} method doesn&#39;t allow the operation.
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkSetFactory
       */
      public static synchronized void setSocketImplFactory(SocketImplFactory fac)
<span class="line-new-header">--- 1760,14 ---</span>
       * the security manager&#39;s {@code checkSetFactory} method
       * to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      fac   the desired factory.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when setting the</span>
       *               socket factory.
<span class="line-modified">!      * @throws     SocketException  if the factory is already defined.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkSetFactory} method doesn&#39;t allow the operation.
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkSetFactory
       */
      public static synchronized void setSocketImplFactory(SocketImplFactory fac)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1755,10 ***</span>
<span class="line-new-header">--- 1855,13 ---</span>
       *         do not require any security permission.
       *
       * @since 9
       */
      public &lt;T&gt; Socket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="line-added">+         Objects.requireNonNull(name);</span>
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          getImpl().setOption(name, value);
          return this;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1784,10 ***</span>
<span class="line-new-header">--- 1887,13 ---</span>
       *
       * @since 9
       */
      @SuppressWarnings(&quot;unchecked&quot;)
      public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-added">+         Objects.requireNonNull(name);</span>
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          return getImpl().getOption(name);
      }
  
      // cache of unmodifiable impl options. Possibly set racy, in impl we trust
      private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
</pre>
<center><a href="ServerSocket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketAddress.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
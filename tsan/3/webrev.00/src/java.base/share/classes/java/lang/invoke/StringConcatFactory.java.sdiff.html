<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringConcatException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarForm.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.misc.Unsafe;

  29 import jdk.internal.org.objectweb.asm.ClassWriter;
  30 import jdk.internal.org.objectweb.asm.Label;
  31 import jdk.internal.org.objectweb.asm.MethodVisitor;
  32 import jdk.internal.org.objectweb.asm.Opcodes;
<span class="line-removed">  33 import jdk.internal.vm.annotation.ForceInline;</span>
  34 import sun.invoke.util.Wrapper;
<span class="line-removed">  35 import sun.security.action.GetPropertyAction;</span>
  36 
  37 import java.lang.invoke.MethodHandles.Lookup;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.List;
  41 import java.util.Objects;
<span class="line-removed">  42 import java.util.Properties;</span>
  43 import java.util.concurrent.ConcurrentHashMap;
  44 import java.util.concurrent.ConcurrentMap;
  45 import java.util.function.Function;
  46 
  47 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  48 
  49 /**
  50  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  51  * can be used to efficiently concatenate a known number of arguments of known
  52  * types, possibly after type adaptation and partial evaluation of arguments.
  53  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  54  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  55  * feature of the Java Programming Language.
  56  *
  57  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  58  * MethodHandle} proceeds in order through two phases:
  59  *
  60  * &lt;ol&gt;
  61  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  62  * They take as arguments a method type describing the concatenated arguments
</pre>
<hr />
<pre>
 174 
 175     /**
 176      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 177      * checks, etc.
 178      */
 179     private static final boolean DEBUG;
 180 
 181     /**
 182      * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated
 183      * code, at the expense of contaminating the profiles.
 184      */
 185     private static final boolean CACHE_ENABLE;
 186 
 187     private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;
 188 
 189     /**
 190      * Dump generated classes to disk, for debugging purposes.
 191      */
 192     private static final ProxyClassesDumper DUMPER;
 193 


 194     static {
 195         // In case we need to double-back onto the StringConcatFactory during this
 196         // static initialization, make sure we have the reasonable defaults to complete
 197         // the static initialization properly. After that, actual users would use
 198         // the proper values we have read from the properties.
 199         STRATEGY = DEFAULT_STRATEGY;
 200         // CACHE_ENABLE = false; // implied
 201         // CACHE = null;         // implied
 202         // DEBUG = false;        // implied
 203         // DUMPER = null;        // implied
 204 
<span class="line-modified"> 205         Properties props = GetPropertyAction.privilegedGetProperties();</span>





 206         final String strategy =
<span class="line-modified"> 207                 props.getProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
 208         CACHE_ENABLE = Boolean.parseBoolean(
<span class="line-modified"> 209                 props.getProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
 210         DEBUG = Boolean.parseBoolean(
<span class="line-modified"> 211                 props.getProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
 212         final String dumpPath =
<span class="line-modified"> 213                 props.getProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
 214 
 215         STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);
 216         CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;
 217         DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);
 218     }
 219 
 220     /**
 221      * Cache key is a composite of:
 222      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 223      *   - method type, describing the dynamic arguments for concatenation
 224      *   - concat recipe, describing the constants and concat shape
 225      */
 226     private static final class Key {
 227         final String className;
 228         final MethodType mt;
 229         final Recipe recipe;
 230 
 231         public Key(String className, MethodType mt, Recipe recipe) {
 232             this.className = className;
 233             this.mt = mt;
</pre>
<hr />
<pre>
 418      *     and combined from left to right.&lt;/li&gt;
 419      * &lt;/ul&gt;
 420      *
 421      * &lt;p&gt;Assume the linkage arguments are as follows:
 422      *
 423      * &lt;ul&gt;
 424      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 425      * &lt;/ul&gt;
 426      *
 427      * &lt;p&gt;Then the following linkage invariants must hold:
 428      *
 429      * &lt;ul&gt;
 430      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
 431      *         less than or equal to 200&lt;/li&gt;
 432      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
 433      * &lt;/ul&gt;
 434      *
 435      * @param lookup   Represents a lookup context with the accessibility
 436      *                 privileges of the caller. Specifically, the lookup
 437      *                 context must have
<span class="line-modified"> 438      *                 &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;</span>
<span class="line-modified"> 439      *                 privileges.</span>
 440      *                 When used with {@code invokedynamic}, this is stacked
 441      *                 automatically by the VM.
 442      * @param name     The name of the method to implement. This name is
 443      *                 arbitrary, and has no meaning for this linkage method.
 444      *                 When used with {@code invokedynamic}, this is provided by
 445      *                 the {@code NameAndType} of the {@code InvokeDynamic}
 446      *                 structure and is stacked automatically by the VM.
 447      * @param concatType The expected signature of the {@code CallSite}.  The
 448      *                   parameter types represent the types of concatenation
 449      *                   arguments; the return type is always assignable from {@link
 450      *                   java.lang.String}.  When used with {@code invokedynamic},
 451      *                   this is provided by the {@code NameAndType} of the {@code
 452      *                   InvokeDynamic} structure and is stacked automatically by
 453      *                   the VM.
 454      * @return a CallSite whose target can be used to perform String
 455      * concatenation, with dynamic concatenation arguments described by the given
 456      * {@code concatType}.
 457      * @throws StringConcatException If any of the linkage invariants described
 458      *                               here are violated, or the lookup context
 459      *                               does not have private access privileges.
</pre>
<hr />
<pre>
 528      * &lt;p&gt;Then the following linkage invariants must hold:
 529      *
 530      * &lt;ul&gt;
 531      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
 532      *       or equal to 200&lt;/li&gt;
 533      *
 534      *   &lt;li&gt;The parameter count in {@code concatType} equals to number of \1 tags
 535      *   in {@code recipe}&lt;/li&gt;
 536      *
 537      *   &lt;li&gt;The return type in {@code concatType} is assignable
 538      *   from {@link java.lang.String}, and matches the return type of the
 539      *   returned {@link MethodHandle}&lt;/li&gt;
 540      *
 541      *   &lt;li&gt;The number of elements in {@code constants} equals to number of \2
 542      *   tags in {@code recipe}&lt;/li&gt;
 543      * &lt;/ul&gt;
 544      *
 545      * @param lookup    Represents a lookup context with the accessibility
 546      *                  privileges of the caller. Specifically, the lookup
 547      *                  context must have
<span class="line-modified"> 548      *                  &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;</span>
<span class="line-modified"> 549      *                  privileges.</span>
 550      *                  When used with {@code invokedynamic}, this is stacked
 551      *                  automatically by the VM.
 552      * @param name      The name of the method to implement. This name is
 553      *                  arbitrary, and has no meaning for this linkage method.
 554      *                  When used with {@code invokedynamic}, this is provided
 555      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
 556      *                  structure and is stacked automatically by the VM.
 557      * @param concatType The expected signature of the {@code CallSite}.  The
 558      *                  parameter types represent the types of dynamic concatenation
 559      *                  arguments; the return type is always assignable from {@link
 560      *                  java.lang.String}.  When used with {@code
 561      *                  invokedynamic}, this is provided by the {@code
 562      *                  NameAndType} of the {@code InvokeDynamic} structure and
 563      *                  is stacked automatically by the VM.
 564      * @param recipe    Concatenation recipe, described above.
 565      * @param constants A vararg parameter representing the constants passed to
 566      *                  the linkage method.
 567      * @return a CallSite whose target can be used to perform String
 568      * concatenation, with dynamic concatenation arguments described by the given
 569      * {@code concatType}.
</pre>
<hr />
<pre>
1502      *
1503      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
1504      * byte[] array on its own and passes that byte[] array to String
1505      * constructor. This strategy requires access to some private APIs in JDK,
1506      * most notably, the read-only Integer/Long.stringSize methods that measure
1507      * the character length of the integers, and the private String constructor
1508      * that accepts byte[] arrays without copying. While this strategy assumes a
1509      * particular implementation details for String, this opens the door for
1510      * building a very optimal concatenation sequence. This is the only strategy
1511      * that requires porting if there are private JDK changes occur.
1512      */
1513     private static final class MethodHandleInlineCopyStrategy {
1514         static final Unsafe UNSAFE = Unsafe.getUnsafe();
1515 
1516         private MethodHandleInlineCopyStrategy() {
1517             // no instantiation
1518         }
1519 
1520         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1521 

































1522             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1523             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
1524             // The filtered argument type list is used all over in the combinators below.
1525             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1526             MethodHandle[] filters = null;
1527             for (int i = 0; i &lt; ptypes.length; i++) {
1528                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1529                 if (filter != null) {
1530                     if (filters == null) {
1531                         filters = new MethodHandle[ptypes.length];
1532                     }
1533                     filters[i] = filter;
1534                     ptypes[i] = filter.type().returnType();
1535                 }
1536             }
1537 
1538             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1539             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1540             // assembled bottom-up, which makes the code arguably hard to read.
1541 
1542             // Drop all remaining parameter types, leave only helper arguments:
1543             MethodHandle mh;
1544 
1545             mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);
1546 


1547             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1548             // known from the combinators below. We are assembling the string backwards, so the index coded
1549             // into indexCoder is the *ending* index.






1550             for (RecipeElement el : recipe.getElements()) {
1551                 // Do the prepend, and put &quot;new&quot; index at index 1
1552                 switch (el.getTag()) {
1553                     case TAG_CONST: {
<span class="line-modified">1554                         MethodHandle prepender = MethodHandles.insertArguments(prepender(String.class), 2, el.getValue());</span>
<span class="line-modified">1555                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,</span>
<span class="line-modified">1556                                 1, 0 // indexCoder, storage</span>
<span class="line-modified">1557                         );</span>








1558                         break;
1559                     }
1560                     case TAG_ARG: {
<span class="line-modified">1561                         int pos = el.getArgPos();</span>
<span class="line-modified">1562                         MethodHandle prepender = prepender(ptypes[pos]);</span>
<span class="line-modified">1563                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,</span>



1564                                 1, 0, // indexCoder, storage
1565                                 2 + pos  // selected argument
<span class="line-modified">1566                         );</span>




1567                         break;
1568                     }
1569                     default:
1570                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1571                 }
1572             }
1573 


















1574             // Fold in byte[] instantiation at argument 0
1575             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,
1576                     1 // index
1577             );
1578 
1579             // Start combining length and coder mixers.
1580             //
1581             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1582             // shapes have been either converted to Strings, or explicit methods for getting the
1583             // string length out of primitives are provided.
1584             //
1585             // Coders are more interesting. Only Object, String and char arguments (and constants)
1586             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1587             // and deduce the coder from there. Arguments would be either converted to Strings
1588             // during the initial filtering, or handled by specializations in MIXERS.
1589             //
<span class="line-modified">1590             // The method handle shape before and after all mixers are combined in is:</span>
1591             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
<span class="line-modified">1592             long initialLengthCoder = INITIAL_CODER;</span>







1593             for (RecipeElement el : recipe.getElements()) {
1594                 switch (el.getTag()) {
1595                     case TAG_CONST:
<span class="line-modified">1596                         String constant = el.getValue();</span>
<span class="line-removed">1597                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constant);</span>
1598                         break;
1599                     case TAG_ARG:
<span class="line-modified">1600                         int ac = el.getArgPos();</span>






1601 

1602                         Class&lt;?&gt; argClass = ptypes[ac];
<span class="line-modified">1603                         MethodHandle mix = mixer(argClass);</span>
<span class="line-removed">1604 </span>
<span class="line-removed">1605                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-removed">1606                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-removed">1607                                 0, // old-index</span>
<span class="line-removed">1608                                 1 + ac // selected argument</span>
<span class="line-removed">1609                         );</span>
1610 
1611                         break;
1612                     default:
1613                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1614                 }
1615             }
1616 
<span class="line-modified">1617             // Insert initial length and coder value here.</span>











1618             // The method handle shape here is (&lt;args&gt;).
<span class="line-removed">1619             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
1620 
1621             // Apply filters, converting the arguments:
1622             if (filters != null) {
1623                 mh = MethodHandles.filterArguments(mh, 0, filters);
1624             }
1625 
1626             return mh;
1627         }
1628 
<span class="line-modified">1629         @ForceInline</span>
<span class="line-modified">1630         private static byte[] newArray(long indexCoder) {</span>
<span class="line-modified">1631             byte coder = (byte)(indexCoder &gt;&gt; 32);</span>
<span class="line-modified">1632             int index = (int)indexCoder;</span>
<span class="line-removed">1633             return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, index &lt;&lt; coder);</span>
<span class="line-removed">1634         }</span>
<span class="line-removed">1635 </span>
<span class="line-removed">1636         private static MethodHandle prepender(Class&lt;?&gt; cl) {</span>
<span class="line-removed">1637             return PREPENDERS.computeIfAbsent(cl, PREPEND);</span>
1638         }
1639 
1640         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1641             return MIXERS.computeIfAbsent(cl, MIX);
1642         }
1643 
1644         // This one is deliberately non-lambdified to optimize startup time:
<span class="line-modified">1645         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;Class&lt;?&gt;, MethodHandle&gt;() {</span>
1646             @Override
1647             public MethodHandle apply(Class&lt;?&gt; c) {
1648                 return lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;prepend&quot;, long.class, long.class, byte[].class,
<span class="line-modified">1649                         Wrapper.asPrimitiveType(c));</span>
1650             }
1651         };
1652 
1653         // This one is deliberately non-lambdified to optimize startup time:
<span class="line-modified">1654         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;Class&lt;?&gt;, MethodHandle&gt;() {</span>
1655             @Override
1656             public MethodHandle apply(Class&lt;?&gt; c) {
1657                 return lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;mix&quot;, long.class, long.class,
1658                         Wrapper.asPrimitiveType(c));
1659             }
1660         };
1661 

1662         private static final MethodHandle NEW_STRING;
1663         private static final MethodHandle NEW_ARRAY;
1664         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1665         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1666         private static final long INITIAL_CODER;
<span class="line-removed">1667         static final Class&lt;?&gt; STRING_HELPER;</span>
1668 
1669         static {
1670             try {
<span class="line-removed">1671                 STRING_HELPER = Class.forName(&quot;java.lang.StringConcatHelper&quot;);</span>
1672                 MethodHandle initCoder = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;initialCoder&quot;, long.class);
1673                 INITIAL_CODER = (long) initCoder.invoke();
1674             } catch (Throwable e) {
1675                 throw new AssertionError(e);
1676             }
1677 
1678             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1679             MIXERS = new ConcurrentHashMap&lt;&gt;();
1680 

1681             NEW_STRING = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;newString&quot;, String.class, byte[].class, long.class);
<span class="line-modified">1682             NEW_ARRAY  = lookupStatic(Lookup.IMPL_LOOKUP, MethodHandleInlineCopyStrategy.class, &quot;newArray&quot;, byte[].class, long.class);</span>
1683         }
1684     }
1685 
1686     /**
1687      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1688      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1689      */
1690     private static final class Stringifiers {
1691         private Stringifiers() {
1692             // no instantiation
1693         }
1694 
<span class="line-modified">1695         private static class ObjectStringifier {</span>
<span class="line-modified">1696 </span>
<span class="line-removed">1697             // We need some additional conversion for Objects in general, because String.valueOf(Object)</span>
<span class="line-removed">1698             // may return null. String conversion rules in Java state we need to produce &quot;null&quot; String</span>
<span class="line-removed">1699             // in this case, so we provide a customized version that deals with this problematic corner case.</span>
<span class="line-removed">1700             private static String valueOf(Object value) {</span>
<span class="line-removed">1701                 String s;</span>
<span class="line-removed">1702                 return (value == null || (s = value.toString()) == null) ? &quot;null&quot; : s;</span>
<span class="line-removed">1703             }</span>
<span class="line-removed">1704 </span>
<span class="line-removed">1705             // Could have used MethodHandles.lookup() instead of Lookup.IMPL_LOOKUP, if not for the fact</span>
<span class="line-removed">1706             // java.lang.invoke Lookups are explicitly forbidden to be retrieved using that API.</span>
<span class="line-removed">1707             private static final MethodHandle INSTANCE =</span>
<span class="line-removed">1708                     lookupStatic(Lookup.IMPL_LOOKUP, ObjectStringifier.class, &quot;valueOf&quot;, String.class, Object.class);</span>
<span class="line-removed">1709 </span>
<span class="line-removed">1710         }</span>
1711 
1712         private static class FloatStringifiers {
1713             private static final MethodHandle FLOAT_INSTANCE =
1714                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1715 
1716             private static final MethodHandle DOUBLE_INSTANCE =
1717                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
1718         }
1719 
1720         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {
1721 
1722             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();
1723 
1724             @Override
1725             protected MethodHandle computeValue(Class&lt;?&gt; cl) {
1726                 if (cl == byte.class || cl == short.class || cl == int.class) {
1727                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);
1728                 } else if (cl == boolean.class) {
1729                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);
1730                 } else if (cl == char.class) {
</pre>
<hr />
<pre>
1734                 } else {
1735                     MethodHandle mh = forMost(cl);
1736                     if (mh != null) {
1737                         return mh;
1738                     } else {
1739                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);
1740                     }
1741                 }
1742             }
1743         }
1744 
1745         /**
1746          * Returns a stringifier for references and floats/doubles only.
1747          * Always returns null for other primitives.
1748          *
1749          * @param t class to stringify
1750          * @return stringifier; null, if not available
1751          */
1752         static MethodHandle forMost(Class&lt;?&gt; t) {
1753             if (!t.isPrimitive()) {
<span class="line-modified">1754                 return ObjectStringifier.INSTANCE;</span>
1755             } else if (t == float.class) {
1756                 return FloatStringifiers.FLOAT_INSTANCE;
1757             } else if (t == double.class) {
1758                 return FloatStringifiers.DOUBLE_INSTANCE;
1759             }
1760             return null;
1761         }
1762 
1763         /**
1764          * Returns a stringifier for any type. Never returns null.
1765          *
1766          * @param t class to stringify
1767          * @return stringifier
1768          */
1769         static MethodHandle forAny(Class&lt;?&gt; t) {
1770             return StringifierAny.INSTANCE.get(t);
1771         }
1772     }
1773 
1774     /* ------------------------------- Common utilities ------------------------------------ */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.misc.Unsafe;
<span class="line-added">  29 import jdk.internal.misc.VM;</span>
  30 import jdk.internal.org.objectweb.asm.ClassWriter;
  31 import jdk.internal.org.objectweb.asm.Label;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.org.objectweb.asm.Opcodes;

  34 import sun.invoke.util.Wrapper;

  35 
  36 import java.lang.invoke.MethodHandles.Lookup;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.List;
  40 import java.util.Objects;

  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.function.Function;
  44 
  45 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  46 
  47 /**
  48  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  49  * can be used to efficiently concatenate a known number of arguments of known
  50  * types, possibly after type adaptation and partial evaluation of arguments.
  51  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  52  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  53  * feature of the Java Programming Language.
  54  *
  55  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  56  * MethodHandle} proceeds in order through two phases:
  57  *
  58  * &lt;ol&gt;
  59  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  60  * They take as arguments a method type describing the concatenated arguments
</pre>
<hr />
<pre>
 172 
 173     /**
 174      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 175      * checks, etc.
 176      */
 177     private static final boolean DEBUG;
 178 
 179     /**
 180      * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated
 181      * code, at the expense of contaminating the profiles.
 182      */
 183     private static final boolean CACHE_ENABLE;
 184 
 185     private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;
 186 
 187     /**
 188      * Dump generated classes to disk, for debugging purposes.
 189      */
 190     private static final ProxyClassesDumper DUMPER;
 191 
<span class="line-added"> 192     private static final Class&lt;?&gt; STRING_HELPER;</span>
<span class="line-added"> 193 </span>
 194     static {
 195         // In case we need to double-back onto the StringConcatFactory during this
 196         // static initialization, make sure we have the reasonable defaults to complete
 197         // the static initialization properly. After that, actual users would use
 198         // the proper values we have read from the properties.
 199         STRATEGY = DEFAULT_STRATEGY;
 200         // CACHE_ENABLE = false; // implied
 201         // CACHE = null;         // implied
 202         // DEBUG = false;        // implied
 203         // DUMPER = null;        // implied
 204 
<span class="line-modified"> 205         try {</span>
<span class="line-added"> 206             STRING_HELPER = Class.forName(&quot;java.lang.StringConcatHelper&quot;);</span>
<span class="line-added"> 207         } catch (Throwable e) {</span>
<span class="line-added"> 208             throw new AssertionError(e);</span>
<span class="line-added"> 209         }</span>
<span class="line-added"> 210 </span>
 211         final String strategy =
<span class="line-modified"> 212                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
 213         CACHE_ENABLE = Boolean.parseBoolean(
<span class="line-modified"> 214                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
 215         DEBUG = Boolean.parseBoolean(
<span class="line-modified"> 216                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
 217         final String dumpPath =
<span class="line-modified"> 218                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
 219 
 220         STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);
 221         CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;
 222         DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);
 223     }
 224 
 225     /**
 226      * Cache key is a composite of:
 227      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 228      *   - method type, describing the dynamic arguments for concatenation
 229      *   - concat recipe, describing the constants and concat shape
 230      */
 231     private static final class Key {
 232         final String className;
 233         final MethodType mt;
 234         final Recipe recipe;
 235 
 236         public Key(String className, MethodType mt, Recipe recipe) {
 237             this.className = className;
 238             this.mt = mt;
</pre>
<hr />
<pre>
 423      *     and combined from left to right.&lt;/li&gt;
 424      * &lt;/ul&gt;
 425      *
 426      * &lt;p&gt;Assume the linkage arguments are as follows:
 427      *
 428      * &lt;ul&gt;
 429      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 430      * &lt;/ul&gt;
 431      *
 432      * &lt;p&gt;Then the following linkage invariants must hold:
 433      *
 434      * &lt;ul&gt;
 435      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
 436      *         less than or equal to 200&lt;/li&gt;
 437      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
 438      * &lt;/ul&gt;
 439      *
 440      * @param lookup   Represents a lookup context with the accessibility
 441      *                 privileges of the caller. Specifically, the lookup
 442      *                 context must have
<span class="line-modified"> 443      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()</span>
<span class="line-modified"> 444      *                 full privilege access}.</span>
 445      *                 When used with {@code invokedynamic}, this is stacked
 446      *                 automatically by the VM.
 447      * @param name     The name of the method to implement. This name is
 448      *                 arbitrary, and has no meaning for this linkage method.
 449      *                 When used with {@code invokedynamic}, this is provided by
 450      *                 the {@code NameAndType} of the {@code InvokeDynamic}
 451      *                 structure and is stacked automatically by the VM.
 452      * @param concatType The expected signature of the {@code CallSite}.  The
 453      *                   parameter types represent the types of concatenation
 454      *                   arguments; the return type is always assignable from {@link
 455      *                   java.lang.String}.  When used with {@code invokedynamic},
 456      *                   this is provided by the {@code NameAndType} of the {@code
 457      *                   InvokeDynamic} structure and is stacked automatically by
 458      *                   the VM.
 459      * @return a CallSite whose target can be used to perform String
 460      * concatenation, with dynamic concatenation arguments described by the given
 461      * {@code concatType}.
 462      * @throws StringConcatException If any of the linkage invariants described
 463      *                               here are violated, or the lookup context
 464      *                               does not have private access privileges.
</pre>
<hr />
<pre>
 533      * &lt;p&gt;Then the following linkage invariants must hold:
 534      *
 535      * &lt;ul&gt;
 536      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
 537      *       or equal to 200&lt;/li&gt;
 538      *
 539      *   &lt;li&gt;The parameter count in {@code concatType} equals to number of \1 tags
 540      *   in {@code recipe}&lt;/li&gt;
 541      *
 542      *   &lt;li&gt;The return type in {@code concatType} is assignable
 543      *   from {@link java.lang.String}, and matches the return type of the
 544      *   returned {@link MethodHandle}&lt;/li&gt;
 545      *
 546      *   &lt;li&gt;The number of elements in {@code constants} equals to number of \2
 547      *   tags in {@code recipe}&lt;/li&gt;
 548      * &lt;/ul&gt;
 549      *
 550      * @param lookup    Represents a lookup context with the accessibility
 551      *                  privileges of the caller. Specifically, the lookup
 552      *                  context must have
<span class="line-modified"> 553      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()</span>
<span class="line-modified"> 554      *                  full privilege access}.</span>
 555      *                  When used with {@code invokedynamic}, this is stacked
 556      *                  automatically by the VM.
 557      * @param name      The name of the method to implement. This name is
 558      *                  arbitrary, and has no meaning for this linkage method.
 559      *                  When used with {@code invokedynamic}, this is provided
 560      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
 561      *                  structure and is stacked automatically by the VM.
 562      * @param concatType The expected signature of the {@code CallSite}.  The
 563      *                  parameter types represent the types of dynamic concatenation
 564      *                  arguments; the return type is always assignable from {@link
 565      *                  java.lang.String}.  When used with {@code
 566      *                  invokedynamic}, this is provided by the {@code
 567      *                  NameAndType} of the {@code InvokeDynamic} structure and
 568      *                  is stacked automatically by the VM.
 569      * @param recipe    Concatenation recipe, described above.
 570      * @param constants A vararg parameter representing the constants passed to
 571      *                  the linkage method.
 572      * @return a CallSite whose target can be used to perform String
 573      * concatenation, with dynamic concatenation arguments described by the given
 574      * {@code concatType}.
</pre>
<hr />
<pre>
1507      *
1508      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
1509      * byte[] array on its own and passes that byte[] array to String
1510      * constructor. This strategy requires access to some private APIs in JDK,
1511      * most notably, the read-only Integer/Long.stringSize methods that measure
1512      * the character length of the integers, and the private String constructor
1513      * that accepts byte[] arrays without copying. While this strategy assumes a
1514      * particular implementation details for String, this opens the door for
1515      * building a very optimal concatenation sequence. This is the only strategy
1516      * that requires porting if there are private JDK changes occur.
1517      */
1518     private static final class MethodHandleInlineCopyStrategy {
1519         static final Unsafe UNSAFE = Unsafe.getUnsafe();
1520 
1521         private MethodHandleInlineCopyStrategy() {
1522             // no instantiation
1523         }
1524 
1525         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1526 
<span class="line-added">1527             // Fast-path two-argument Object + Object concatenations</span>
<span class="line-added">1528             if (recipe.getElements().size() == 2) {</span>
<span class="line-added">1529                 // Two object arguments</span>
<span class="line-added">1530                 if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-added">1531                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-added">1532                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-added">1533                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-added">1534                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-added">1535 </span>
<span class="line-added">1536                     return SIMPLE;</span>
<span class="line-added">1537 </span>
<span class="line-added">1538                 } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-added">1539                            !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-added">1540                     // One Object argument, one constant</span>
<span class="line-added">1541                     MethodHandle mh = SIMPLE;</span>
<span class="line-added">1542 </span>
<span class="line-added">1543                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-added">1544                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-added">1545                         // First recipe element is a constant</span>
<span class="line-added">1546                         return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-added">1547                                 recipe.getElements().get(0).getValue());</span>
<span class="line-added">1548 </span>
<span class="line-added">1549                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-added">1550                                recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-added">1551                         // Second recipe element is a constant</span>
<span class="line-added">1552                         return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-added">1553                                 recipe.getElements().get(1).getValue());</span>
<span class="line-added">1554 </span>
<span class="line-added">1555                     }</span>
<span class="line-added">1556                 }</span>
<span class="line-added">1557                 // else... fall-through to slow-path</span>
<span class="line-added">1558             }</span>
<span class="line-added">1559 </span>
1560             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1561             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
1562             // The filtered argument type list is used all over in the combinators below.
1563             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1564             MethodHandle[] filters = null;
1565             for (int i = 0; i &lt; ptypes.length; i++) {
1566                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1567                 if (filter != null) {
1568                     if (filters == null) {
1569                         filters = new MethodHandle[ptypes.length];
1570                     }
1571                     filters[i] = filter;
1572                     ptypes[i] = filter.type().returnType();
1573                 }
1574             }
1575 
1576             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1577             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1578             // assembled bottom-up, which makes the code arguably hard to read.
1579 
1580             // Drop all remaining parameter types, leave only helper arguments:
1581             MethodHandle mh;
1582 
1583             mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);
1584 
<span class="line-added">1585             long initialLengthCoder = INITIAL_CODER;</span>
<span class="line-added">1586 </span>
1587             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1588             // known from the combinators below. We are assembling the string backwards, so the index coded
1589             // into indexCoder is the *ending* index.
<span class="line-added">1590 </span>
<span class="line-added">1591             // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-added">1592             // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-added">1593             // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-added">1594             String prefixConstant = null, suffixConstant = null;</span>
<span class="line-added">1595             int pos = -1;</span>
1596             for (RecipeElement el : recipe.getElements()) {
1597                 // Do the prepend, and put &quot;new&quot; index at index 1
1598                 switch (el.getTag()) {
1599                     case TAG_CONST: {
<span class="line-modified">1600                         String constantValue = el.getValue();</span>
<span class="line-modified">1601 </span>
<span class="line-modified">1602                         // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">1603                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);</span>
<span class="line-added">1604 </span>
<span class="line-added">1605                         if (pos &lt; 0) {</span>
<span class="line-added">1606                             // Collecting into prefixConstant</span>
<span class="line-added">1607                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-added">1608                         } else {</span>
<span class="line-added">1609                             // Collecting into suffixConstant</span>
<span class="line-added">1610                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
<span class="line-added">1611                         }</span>
1612                         break;
1613                     }
1614                     case TAG_ARG: {
<span class="line-modified">1615 </span>
<span class="line-modified">1616                         if (pos &gt;= 0) {</span>
<span class="line-modified">1617                             // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-added">1618                             mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-added">1619                                 mh, 1,</span>
<span class="line-added">1620                                 prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
1621                                 1, 0, // indexCoder, storage
1622                                 2 + pos  // selected argument
<span class="line-modified">1623                             );</span>
<span class="line-added">1624                             prefixConstant = suffixConstant = null;</span>
<span class="line-added">1625                         }</span>
<span class="line-added">1626                         // Mark the pos of next non-constant arg</span>
<span class="line-added">1627                         pos = el.getArgPos();</span>
1628                         break;
1629                     }
1630                     default:
1631                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1632                 }
1633             }
1634 
<span class="line-added">1635             // Insert any trailing args, constants</span>
<span class="line-added">1636             if (pos &gt;= 0) {</span>
<span class="line-added">1637                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-added">1638                     mh, 1,</span>
<span class="line-added">1639                     prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
<span class="line-added">1640                     1, 0, // indexCoder, storage</span>
<span class="line-added">1641                     2 + pos  // selected argument</span>
<span class="line-added">1642                 );</span>
<span class="line-added">1643             } else if (prefixConstant != null) {</span>
<span class="line-added">1644                 assert (suffixConstant == null);</span>
<span class="line-added">1645                 // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-added">1646                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-added">1647                     mh, 1,</span>
<span class="line-added">1648                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),</span>
<span class="line-added">1649                     1, 0 // indexCoder, storage</span>
<span class="line-added">1650                 );</span>
<span class="line-added">1651             }</span>
<span class="line-added">1652 </span>
1653             // Fold in byte[] instantiation at argument 0
1654             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,
1655                     1 // index
1656             );
1657 
1658             // Start combining length and coder mixers.
1659             //
1660             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1661             // shapes have been either converted to Strings, or explicit methods for getting the
1662             // string length out of primitives are provided.
1663             //
1664             // Coders are more interesting. Only Object, String and char arguments (and constants)
1665             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1666             // and deduce the coder from there. Arguments would be either converted to Strings
1667             // during the initial filtering, or handled by specializations in MIXERS.
1668             //
<span class="line-modified">1669             // The method handle shape before all mixers are combined in is:</span>
1670             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
<span class="line-modified">1671             //</span>
<span class="line-added">1672             // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-added">1673             // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-added">1674             // combined in as:</span>
<span class="line-added">1675             //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-added">1676 </span>
<span class="line-added">1677             int ac = -1;</span>
<span class="line-added">1678             MethodHandle mix = null;</span>
1679             for (RecipeElement el : recipe.getElements()) {
1680                 switch (el.getTag()) {
1681                     case TAG_CONST:
<span class="line-modified">1682                         // Constants already handled in the code above</span>

1683                         break;
1684                     case TAG_ARG:
<span class="line-modified">1685                         if (ac &gt;= 0) {</span>
<span class="line-added">1686                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-added">1687                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-added">1688                                     0, // old-index</span>
<span class="line-added">1689                                     1 + ac // selected argument</span>
<span class="line-added">1690                             );</span>
<span class="line-added">1691                         }</span>
1692 
<span class="line-added">1693                         ac = el.getArgPos();</span>
1694                         Class&lt;?&gt; argClass = ptypes[ac];
<span class="line-modified">1695                         mix = mixer(argClass);</span>






1696 
1697                         break;
1698                     default:
1699                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1700                 }
1701             }
1702 
<span class="line-modified">1703             // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-added">1704             // fold that into the base method handle</span>
<span class="line-added">1705             if (ac &gt;= 0) {</span>
<span class="line-added">1706                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-added">1707                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-added">1708                         1 + ac // selected argument</span>
<span class="line-added">1709                 );</span>
<span class="line-added">1710             } else {</span>
<span class="line-added">1711                 // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-added">1712                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="line-added">1713             }</span>
<span class="line-added">1714 </span>
1715             // The method handle shape here is (&lt;args&gt;).

1716 
1717             // Apply filters, converting the arguments:
1718             if (filters != null) {
1719                 mh = MethodHandles.filterArguments(mh, 0, filters);
1720             }
1721 
1722             return mh;
1723         }
1724 
<span class="line-modified">1725         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="line-modified">1726             return MethodHandles.insertArguments(</span>
<span class="line-modified">1727                     MethodHandles.insertArguments(</span>
<span class="line-modified">1728                         PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);</span>





1729         }
1730 
1731         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1732             return MIXERS.computeIfAbsent(cl, MIX);
1733         }
1734 
1735         // This one is deliberately non-lambdified to optimize startup time:
<span class="line-modified">1736         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
1737             @Override
1738             public MethodHandle apply(Class&lt;?&gt; c) {
1739                 return lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;prepend&quot;, long.class, long.class, byte[].class,
<span class="line-modified">1740                         String.class, Wrapper.asPrimitiveType(c), String.class);</span>
1741             }
1742         };
1743 
1744         // This one is deliberately non-lambdified to optimize startup time:
<span class="line-modified">1745         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
1746             @Override
1747             public MethodHandle apply(Class&lt;?&gt; c) {
1748                 return lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;mix&quot;, long.class, long.class,
1749                         Wrapper.asPrimitiveType(c));
1750             }
1751         };
1752 
<span class="line-added">1753         private static final MethodHandle SIMPLE;</span>
1754         private static final MethodHandle NEW_STRING;
1755         private static final MethodHandle NEW_ARRAY;
1756         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1757         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1758         private static final long INITIAL_CODER;

1759 
1760         static {
1761             try {

1762                 MethodHandle initCoder = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;initialCoder&quot;, long.class);
1763                 INITIAL_CODER = (long) initCoder.invoke();
1764             } catch (Throwable e) {
1765                 throw new AssertionError(e);
1766             }
1767 
1768             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1769             MIXERS = new ConcurrentHashMap&lt;&gt;();
1770 
<span class="line-added">1771             SIMPLE     = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;simpleConcat&quot;, String.class, Object.class, Object.class);</span>
1772             NEW_STRING = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;newString&quot;, String.class, byte[].class, long.class);
<span class="line-modified">1773             NEW_ARRAY  = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;newArray&quot;, byte[].class, long.class);</span>
1774         }
1775     }
1776 
1777     /**
1778      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1779      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1780      */
1781     private static final class Stringifiers {
1782         private Stringifiers() {
1783             // no instantiation
1784         }
1785 
<span class="line-modified">1786         private static final MethodHandle OBJECT_INSTANCE =</span>
<span class="line-modified">1787             lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;stringOf&quot;, String.class, Object.class);</span>














1788 
1789         private static class FloatStringifiers {
1790             private static final MethodHandle FLOAT_INSTANCE =
1791                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1792 
1793             private static final MethodHandle DOUBLE_INSTANCE =
1794                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
1795         }
1796 
1797         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {
1798 
1799             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();
1800 
1801             @Override
1802             protected MethodHandle computeValue(Class&lt;?&gt; cl) {
1803                 if (cl == byte.class || cl == short.class || cl == int.class) {
1804                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);
1805                 } else if (cl == boolean.class) {
1806                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);
1807                 } else if (cl == char.class) {
</pre>
<hr />
<pre>
1811                 } else {
1812                     MethodHandle mh = forMost(cl);
1813                     if (mh != null) {
1814                         return mh;
1815                     } else {
1816                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);
1817                     }
1818                 }
1819             }
1820         }
1821 
1822         /**
1823          * Returns a stringifier for references and floats/doubles only.
1824          * Always returns null for other primitives.
1825          *
1826          * @param t class to stringify
1827          * @return stringifier; null, if not available
1828          */
1829         static MethodHandle forMost(Class&lt;?&gt; t) {
1830             if (!t.isPrimitive()) {
<span class="line-modified">1831                 return OBJECT_INSTANCE;</span>
1832             } else if (t == float.class) {
1833                 return FloatStringifiers.FLOAT_INSTANCE;
1834             } else if (t == double.class) {
1835                 return FloatStringifiers.DOUBLE_INSTANCE;
1836             }
1837             return null;
1838         }
1839 
1840         /**
1841          * Returns a stringifier for any type. Never returns null.
1842          *
1843          * @param t class to stringify
1844          * @return stringifier
1845          */
1846         static MethodHandle forAny(Class&lt;?&gt; t) {
1847             return StringifierAny.INSTANCE.get(t);
1848         }
1849     }
1850 
1851     /* ------------------------------- Common utilities ------------------------------------ */
</pre>
</td>
</tr>
</table>
<center><a href="StringConcatException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarForm.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
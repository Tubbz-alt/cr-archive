<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/LineNumberInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InvalidObjectException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LineNumberReader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/LineNumberInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,12 ***</span>
   *             characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
   *             character streams is via the new character-stream classes, which
   *             include a class for counting line numbers.
   */
  @Deprecated
<span class="line-modified">! public</span>
<span class="line-removed">- class LineNumberInputStream extends FilterInputStream {</span>
      int pushBack = -1;
      int lineNumber;
      int markLineNumber;
      int markPushBack = -1;
  
<span class="line-new-header">--- 45,11 ---</span>
   *             characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
   *             character streams is via the new character-stream classes, which
   *             include a class for counting line numbers.
   */
  @Deprecated
<span class="line-modified">! public class LineNumberInputStream extends FilterInputStream {</span>
      int pushBack = -1;
      int lineNumber;
      int markLineNumber;
      int markPushBack = -1;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,11 ***</span>
       * a carriage return followed by a newline character are both
       * converted into a single newline character.
       *
       * @return     the next byte of data, or {@code -1} if the end of this
       *             stream is reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.LineNumberInputStream#getLineNumber()
       */
      @SuppressWarnings(&quot;fallthrough&quot;)
      public int read() throws IOException {
<span class="line-new-header">--- 80,11 ---</span>
       * a carriage return followed by a newline character are both
       * converted into a single newline character.
       *
       * @return     the next byte of data, or {@code -1} if the end of this
       *             stream is reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.LineNumberInputStream#getLineNumber()
       */
      @SuppressWarnings(&quot;fallthrough&quot;)
      public int read() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,11 ***</span>
       * @param      off   the start offset of the data.
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
       *             {@code -1} if there is no more data because the end of
       *             this stream has been reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.LineNumberInputStream#read()
       */
      public int read(byte b[], int off, int len) throws IOException {
          if (b == null) {
              throw new NullPointerException();
<span class="line-new-header">--- 121,11 ---</span>
       * @param      off   the start offset of the data.
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
       *             {@code -1} if there is no more data because the end of
       *             this stream has been reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.LineNumberInputStream#read()
       */
      public int read(byte b[], int off, int len) throws IOException {
          if (b == null) {
              throw new NullPointerException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,11 ***</span>
       * {@code n} bytes have been read or the end of the stream has
       * been reached.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public long skip(long n) throws IOException {
          int chunk = 2048;
          long remaining = n;
<span class="line-new-header">--- 170,11 ---</span>
       * {@code n} bytes have been read or the end of the stream has
       * been reached.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public long skip(long n) throws IOException {
          int chunk = 2048;
          long remaining = n;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,11 ***</span>
       * {@code &#39;\u005Cn&#39;}, which are converted to just
       * &lt;i&gt;k&lt;/i&gt;/2 {@code &#39;\u005Cn&#39;} characters.
       *
       * @return     the number of bytes that can be read from this input stream
       *             without blocking.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public int available() throws IOException {
          return (pushBack == -1) ? super.available()/2 : super.available()/2 + 1;
      }
<span class="line-new-header">--- 231,11 ---</span>
       * {@code &#39;\u005Cn&#39;}, which are converted to just
       * &lt;i&gt;k&lt;/i&gt;/2 {@code &#39;\u005Cn&#39;} characters.
       *
       * @return     the number of bytes that can be read from this input stream
       *             without blocking.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public int available() throws IOException {
          return (pushBack == -1) ? super.available()/2 : super.available()/2 + 1;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,11 ***</span>
       * parser, it just chugs along happily. If the stream is not of
       * that type, the parser should toss an exception when it fails,
       * which, if it happens within readlimit bytes, allows the outer
       * code to reset the stream and try another parser.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.LineNumberInputStream#mark(int)
       */
      public void reset() throws IOException {
          lineNumber = markLineNumber;
<span class="line-new-header">--- 278,11 ---</span>
       * parser, it just chugs along happily. If the stream is not of
       * that type, the parser should toss an exception when it fails,
       * which, if it happens within readlimit bytes, allows the outer
       * code to reset the stream and try another parser.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.LineNumberInputStream#mark(int)
       */
      public void reset() throws IOException {
          lineNumber = markLineNumber;
</pre>
<center><a href="InvalidObjectException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LineNumberReader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
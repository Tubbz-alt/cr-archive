<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/zip/InflaterInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.FilterInputStream;
 29 import java.io.InputStream;
 30 import java.io.IOException;
 31 import java.io.EOFException;
 32 
 33 /**
 34  * This class implements a stream filter for uncompressing data in the
 35  * &quot;deflate&quot; compression format. It is also used as the basis for other
 36  * decompression filters, such as GZIPInputStream.
 37  *
 38  * @see         Inflater
 39  * @author      David Connelly
 40  * @since 1.1
 41  */
 42 public class InflaterInputStream extends FilterInputStream {
 43     /**
 44      * Decompressor for this stream.
 45      */
 46     protected Inflater inf;
 47 
 48     /**
 49      * Input buffer for decompression.
 50      */
 51     protected byte[] buf;
 52 
 53     /**
 54      * Length of input buffer.
 55      */
 56     protected int len;
 57 
 58     private boolean closed = false;
 59     // this flag is set to true after EOF has reached
 60     private boolean reachEOF = false;
 61 
 62     /**
 63      * Check to make sure that this stream has not been closed
 64      */
 65     private void ensureOpen() throws IOException {
 66         if (closed) {
 67             throw new IOException(&quot;Stream closed&quot;);
 68         }
 69     }
 70 
 71 
 72     /**
 73      * Creates a new input stream with the specified decompressor and
 74      * buffer size.
 75      * @param in the input stream
 76      * @param inf the decompressor (&quot;inflater&quot;)
 77      * @param size the input buffer size
 78      * @throws    IllegalArgumentException if {@code size &lt;= 0}
 79      */
 80     public InflaterInputStream(InputStream in, Inflater inf, int size) {
 81         super(in);
 82         if (in == null || inf == null) {
 83             throw new NullPointerException();
 84         } else if (size &lt;= 0) {
 85             throw new IllegalArgumentException(&quot;buffer size &lt;= 0&quot;);
 86         }
 87         this.inf = inf;
 88         buf = new byte[size];
 89     }
 90 
 91     /**
 92      * Creates a new input stream with the specified decompressor and a
 93      * default buffer size.
 94      * @param in the input stream
 95      * @param inf the decompressor (&quot;inflater&quot;)
 96      */
 97     public InflaterInputStream(InputStream in, Inflater inf) {
 98         this(in, inf, 512);
 99     }
100 
101     boolean usesDefaultInflater = false;
102 
103     /**
104      * Creates a new input stream with a default decompressor and buffer size.
105      * @param in the input stream
106      */
107     public InflaterInputStream(InputStream in) {
108         this(in, new Inflater());
109         usesDefaultInflater = true;
110     }
111 
112     private byte[] singleByteBuf = new byte[1];
113 
114     /**
115      * Reads a byte of uncompressed data. This method will block until
116      * enough input is available for decompression.
117      * @return the byte read, or -1 if end of compressed input is reached
118      * @throws    IOException if an I/O error has occurred
119      */
120     public int read() throws IOException {
121         ensureOpen();
122         return read(singleByteBuf, 0, 1) == -1 ? -1 : Byte.toUnsignedInt(singleByteBuf[0]);
123     }
124 
125     /**
126      * Reads uncompressed data into an array of bytes. If {@code len} is not
127      * zero, the method will block until some input can be decompressed; otherwise,
128      * no bytes are read and {@code 0} is returned.
129      * @param b the buffer into which the data is read
130      * @param off the start offset in the destination array {@code b}
131      * @param len the maximum number of bytes read
132      * @return the actual number of bytes read, or -1 if the end of the
133      *         compressed input is reached or a preset dictionary is needed
134      * @throws     NullPointerException If {@code b} is {@code null}.
135      * @throws     IndexOutOfBoundsException If {@code off} is negative,
136      * {@code len} is negative, or {@code len} is greater than
137      * {@code b.length - off}
138      * @throws    ZipException if a ZIP format error has occurred
139      * @throws    IOException if an I/O error has occurred
140      */
141     public int read(byte[] b, int off, int len) throws IOException {
142         ensureOpen();
143         if (b == null) {
144             throw new NullPointerException();
145         } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
146             throw new IndexOutOfBoundsException();
147         } else if (len == 0) {
148             return 0;
149         }
150         try {
151             int n;
152             while ((n = inf.inflate(b, off, len)) == 0) {
153                 if (inf.finished() || inf.needsDictionary()) {
154                     reachEOF = true;
155                     return -1;
156                 }
157                 if (inf.needsInput()) {
158                     fill();
159                 }
160             }
161             return n;
162         } catch (DataFormatException e) {
163             String s = e.getMessage();
164             throw new ZipException(s != null ? s : &quot;Invalid ZLIB data format&quot;);
165         }
166     }
167 
168     /**
169      * Returns 0 after EOF has been reached, otherwise always return 1.
170      * &lt;p&gt;
171      * Programs should not count on this method to return the actual number
172      * of bytes that could be read without blocking.
173      *
174      * @return     1 before EOF and 0 after EOF.
175      * @throws     IOException  if an I/O error occurs.
176      *
177      */
178     public int available() throws IOException {
179         ensureOpen();
180         if (reachEOF) {
181             return 0;
182         } else if (inf.finished()) {
183             // the end of the compressed data stream has been reached
184             reachEOF = true;
185             return 0;
186         } else {
187             return 1;
188         }
189     }
190 
191     private byte[] b = new byte[512];
192 
193     /**
194      * Skips specified number of bytes of uncompressed data.
195      * @param n the number of bytes to skip
196      * @return the actual number of bytes skipped.
197      * @throws    IOException if an I/O error has occurred
198      * @throws    IllegalArgumentException if {@code n &lt; 0}
199      */
200     public long skip(long n) throws IOException {
201         if (n &lt; 0) {
202             throw new IllegalArgumentException(&quot;negative skip length&quot;);
203         }
204         ensureOpen();
205         int max = (int)Math.min(n, Integer.MAX_VALUE);
206         int total = 0;
207         while (total &lt; max) {
208             int len = max - total;
209             if (len &gt; b.length) {
210                 len = b.length;
211             }
212             len = read(b, 0, len);
213             if (len == -1) {
214                 reachEOF = true;
215                 break;
216             }
217             total += len;
218         }
219         return total;
220     }
221 
222     /**
223      * Closes this input stream and releases any system resources associated
224      * with the stream.
225      * @throws    IOException if an I/O error has occurred
226      */
227     public void close() throws IOException {
228         if (!closed) {
229             if (usesDefaultInflater)
230                 inf.end();
231             in.close();
232             closed = true;
233         }
234     }
235 
236     /**
237      * Fills input buffer with more data to decompress.
238      * @throws    IOException if an I/O error has occurred
239      */
240     protected void fill() throws IOException {
241         ensureOpen();
242         len = in.read(buf, 0, buf.length);
243         if (len == -1) {
244             throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
245         }
246         inf.setInput(buf, 0, len);
247     }
248 
249     /**
250      * Tests if this input stream supports the {@code mark} and
251      * {@code reset} methods. The {@code markSupported}
252      * method of {@code InflaterInputStream} returns
253      * {@code false}.
254      *
255      * @return  a {@code boolean} indicating if this stream type supports
256      *          the {@code mark} and {@code reset} methods.
257      * @see     java.io.InputStream#mark(int)
258      * @see     java.io.InputStream#reset()
259      */
260     public boolean markSupported() {
261         return false;
262     }
263 
264     /**
265      * Marks the current position in this input stream.
266      *
267      * &lt;p&gt; The {@code mark} method of {@code InflaterInputStream}
268      * does nothing.
269      *
270      * @param   readlimit   the maximum limit of bytes that can be read before
271      *                      the mark position becomes invalid.
272      * @see     java.io.InputStream#reset()
273      */
274     public synchronized void mark(int readlimit) {
275     }
276 
277     /**
278      * Repositions this stream to the position at the time the
279      * {@code mark} method was last called on this input stream.
280      *
281      * &lt;p&gt; The method {@code reset} for class
282      * {@code InflaterInputStream} does nothing except throw an
283      * {@code IOException}.
284      *
285      * @throws     IOException  if this method is invoked.
286      * @see     java.io.InputStream#mark(int)
287      * @see     java.io.IOException
288      */
289     public synchronized void reset() throws IOException {
290         throw new IOException(&quot;mark/reset not supported&quot;);
291     }
292 }
    </pre>
  </body>
</html>
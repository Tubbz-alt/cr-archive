<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/ObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectInputFilter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectInputValidation.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,11 ***</span>
<span class="line-new-header">--- 24,13 ---</span>
   */
  
  package java.io;
  
  import java.io.ObjectStreamClass.WeakClassKey;
<span class="line-added">+ import java.io.ObjectStreamClass.RecordSupport;</span>
  import java.lang.System.Logger;
<span class="line-added">+ import java.lang.invoke.MethodHandle;</span>
  import java.lang.ref.ReferenceQueue;
  import java.lang.reflect.Array;
  import java.lang.reflect.Modifier;
  import java.lang.reflect.Proxy;
  import java.security.AccessControlContext;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,11 ***</span>
   * Machine.  Classes are loaded as required using the standard mechanisms.
   *
   * &lt;p&gt;Only objects that support the java.io.Serializable or
   * java.io.Externalizable interface can be read from streams.
   *
<span class="line-modified">!  * &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the</span>
   * stream.  Java&#39;s safe casting should be used to get the desired type.  In
   * Java, strings and arrays are objects and are treated as objects during
   * serialization. When read they need to be cast to the expected type.
   *
   * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
<span class="line-new-header">--- 74,11 ---</span>
   * Machine.  Classes are loaded as required using the standard mechanisms.
   *
   * &lt;p&gt;Only objects that support the java.io.Serializable or
   * java.io.Externalizable interface can be read from streams.
   *
<span class="line-modified">!  * &lt;p&gt;The method {@code readObject} is used to read an object from the</span>
   * stream.  Java&#39;s safe casting should be used to get the desired type.  In
   * Java, strings and arrays are objects and are treated as objects during
   * serialization. When read they need to be cast to the expected type.
   *
   * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,11 ***</span>
   * behave in the same manner--if the stream is already positioned at the end of
   * data written by the corresponding writeExternal method, object reads will
   * throw OptionalDataExceptions with eof set to true, bytewise reads will
   * return -1, and primitive reads will throw EOFExceptions.  Note that this
   * behavior does not hold for streams written with the old
<span class="line-modified">!  * &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the</span>
   * end of data written by writeExternal methods is not demarcated, and hence
   * cannot be detected.
   *
   * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
   * the object for its particular class in the event that the serialization
<span class="line-new-header">--- 157,11 ---</span>
   * behave in the same manner--if the stream is already positioned at the end of
   * data written by the corresponding writeExternal method, object reads will
   * throw OptionalDataExceptions with eof set to true, bytewise reads will
   * return -1, and primitive reads will throw EOFExceptions.  Note that this
   * behavior does not hold for streams written with the old
<span class="line-modified">!  * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the</span>
   * end of data written by writeExternal methods is not demarcated, and hence
   * cannot be detected.
   *
   * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
   * the object for its particular class in the event that the serialization
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,20 ***</span>
   * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
   * externalizable objects.  The serialized form of an enum constant consists
   * solely of its name; field values of the constant are not transmitted.  To
   * deserialize an enum constant, ObjectInputStream reads the constant name from
   * the stream; the deserialized constant is then obtained by calling the static
<span class="line-modified">!  * method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant&#39;s</span>
   * base type and the received constant name as arguments.  Like other
   * serializable or externalizable objects, enum constants can function as the
   * targets of back references appearing subsequently in the serialization
   * stream.  The process by which enum constants are deserialized cannot be
   * customized: any class-specific readObject, readObjectNoData, and readResolve
   * methods defined by enum types are ignored during deserialization.
   * Similarly, any serialPersistentFields or serialVersionUID field declarations
   * are also ignored--all enum types have a fixed serialVersionUID of 0L.
   *
   * @author      Mike Warres
   * @author      Roger Riggs
   * @see java.io.DataInput
   * @see java.io.ObjectOutputStream
   * @see java.io.Serializable
<span class="line-new-header">--- 208,53 ---</span>
   * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
   * externalizable objects.  The serialized form of an enum constant consists
   * solely of its name; field values of the constant are not transmitted.  To
   * deserialize an enum constant, ObjectInputStream reads the constant name from
   * the stream; the deserialized constant is then obtained by calling the static
<span class="line-modified">!  * method {@code Enum.valueOf(Class, String)} with the enum constant&#39;s</span>
   * base type and the received constant name as arguments.  Like other
   * serializable or externalizable objects, enum constants can function as the
   * targets of back references appearing subsequently in the serialization
   * stream.  The process by which enum constants are deserialized cannot be
   * customized: any class-specific readObject, readObjectNoData, and readResolve
   * methods defined by enum types are ignored during deserialization.
   * Similarly, any serialPersistentFields or serialVersionUID field declarations
   * are also ignored--all enum types have a fixed serialVersionUID of 0L.
   *
<span class="line-added">+  * @implSpec</span>
<span class="line-added">+  * &lt;a id=&quot;record-serialization&quot;&gt;&lt;/a&gt;</span>
<span class="line-added">+  * Records are serialized differently than ordinary serializable or externalizable</span>
<span class="line-added">+  * objects. The serialized form of a record object is a sequence of values derived</span>
<span class="line-added">+  * from the record components. The stream format of a record object is the same as</span>
<span class="line-added">+  * that of an ordinary object in the stream. During deserialization, if the local</span>
<span class="line-added">+  * class equivalent of the specified stream class descriptor is a record class,</span>
<span class="line-added">+  * then first the stream fields are read and reconstructed to serve as the record&#39;s</span>
<span class="line-added">+  * component values; and second, a record object is created by invoking the</span>
<span class="line-added">+  * record&#39;s &lt;i&gt;canonical&lt;/i&gt; constructor with the component values as arguments (or the</span>
<span class="line-added">+  * default value for component&#39;s type if a component value is absent from the</span>
<span class="line-added">+  * stream).</span>
<span class="line-added">+  * Like other serializable or externalizable objects, record objects can function</span>
<span class="line-added">+  * as the target of back references appearing subsequently in the serialization</span>
<span class="line-added">+  * stream. However, a cycle in the graph where the record object is referred to,</span>
<span class="line-added">+  * either directly or transitively, by one of its components, is not preserved.</span>
<span class="line-added">+  * The record components are deserialized prior to the invocation of the record</span>
<span class="line-added">+  * constructor, hence this limitation (see</span>
<span class="line-added">+  * &lt;a href=&quot;{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references&quot;&gt;</span>
<span class="line-added">+  * [Section 1.14, &quot;Circular References&quot;&lt;/a&gt; for additional information).</span>
<span class="line-added">+  * The process by which record objects are serialized or externalized cannot be</span>
<span class="line-added">+  * customized; any class-specific writeObject, readObject, readObjectNoData,</span>
<span class="line-added">+  * writeExternal, and readExternal methods defined by record classes are</span>
<span class="line-added">+  * ignored during serialization and deserialization. However, a substitute object</span>
<span class="line-added">+  * to be serialized or a designate replacement may be specified, by the</span>
<span class="line-added">+  * writeReplace and readResolve methods, respectively.  Any</span>
<span class="line-added">+  * serialPersistentFields field declaration is ignored. Documenting serializable</span>
<span class="line-added">+  * fields and data for record classes is unnecessary, since there is no variation</span>
<span class="line-added">+  * in the serial form, other than whether a substitute or replacement object is</span>
<span class="line-added">+  * used. The serialVersionUID of a record class is 0L unless explicitly</span>
<span class="line-added">+  * declared. The requirement for matching serialVersionUID values is waived for</span>
<span class="line-added">+  * record classes.</span>
<span class="line-added">+  *</span>
   * @author      Mike Warres
   * @author      Roger Riggs
   * @see java.io.DataInput
   * @see java.io.ObjectOutputStream
   * @see java.io.Serializable
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,11 ***</span>
       * @param   in input stream to read from
       * @throws  StreamCorruptedException if the stream header is incorrect
       * @throws  IOException if an I/O error occurs while reading stream header
       * @throws  SecurityException if untrusted subclass illegally overrides
       *          security-sensitive methods
<span class="line-modified">!      * @throws  NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @see     ObjectInputStream#ObjectInputStream()
       * @see     ObjectInputStream#readFields()
       * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
       */
      public ObjectInputStream(InputStream in) throws IOException {
<span class="line-new-header">--- 368,11 ---</span>
       * @param   in input stream to read from
       * @throws  StreamCorruptedException if the stream header is incorrect
       * @throws  IOException if an I/O error occurs while reading stream header
       * @throws  SecurityException if untrusted subclass illegally overrides
       *          security-sensitive methods
<span class="line-modified">!      * @throws  NullPointerException if {@code in} is {@code null}</span>
       * @see     ObjectInputStream#ObjectInputStream()
       * @see     ObjectInputStream#readFields()
       * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
       */
      public ObjectInputStream(InputStream in) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,16 ***</span>
       *
       * &lt;p&gt;The serialization filter is initialized to the value of
       * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
       *
       * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified">!      * security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method with the</span>
<span class="line-modified">!      * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;</span>
       * permission to ensure it&#39;s ok to enable subclassing.
       *
       * @throws  SecurityException if a security manager exists and its
<span class="line-modified">!      *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling</span>
       *          subclassing.
       * @throws  IOException if an I/O error occurs while creating this stream
       * @see SecurityManager#checkPermission
       * @see java.io.SerializablePermission
       */
<span class="line-new-header">--- 393,16 ---</span>
       *
       * &lt;p&gt;The serialization filter is initialized to the value of
       * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
       *
       * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified">!      * security manager&#39;s {@code checkPermission} method with the</span>
<span class="line-modified">!      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}</span>
       * permission to ensure it&#39;s ok to enable subclassing.
       *
       * @throws  SecurityException if a security manager exists and its
<span class="line-modified">!      *          {@code checkPermission} method denies enabling</span>
       *          subclassing.
       * @throws  IOException if an I/O error occurs while creating this stream
       * @see SecurityManager#checkPermission
       * @see java.io.SerializablePermission
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 416,20 ***</span>
       * @throws  OptionalDataException Primitive data was found in the
       *          stream instead of objects.
       * @throws  IOException Any of the usual Input/Output related exceptions.
       */
      public final Object readObject()
          throws IOException, ClassNotFoundException
      {
          if (enableOverride) {
              return readObjectOverride();
          }
  
          // if nested read, passHandle contains handle of enclosing object
          int outerHandle = passHandle;
          try {
<span class="line-modified">!             Object obj = readObject0(false);</span>
              handles.markDependency(outerHandle, passHandle);
              ClassNotFoundException ex = handles.lookupException(passHandle);
              if (ex != null) {
                  throw ex;
              }
<span class="line-new-header">--- 451,54 ---</span>
       * @throws  OptionalDataException Primitive data was found in the
       *          stream instead of objects.
       * @throws  IOException Any of the usual Input/Output related exceptions.
       */
      public final Object readObject()
<span class="line-added">+         throws IOException, ClassNotFoundException {</span>
<span class="line-added">+         return readObject(Object.class);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads a String and only a string.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return  the String read</span>
<span class="line-added">+      * @throws  EOFException If end of file is reached.</span>
<span class="line-added">+      * @throws  IOException If other I/O error has occurred.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String readString() throws IOException {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return (String) readObject(String.class);</span>
<span class="line-added">+         } catch (ClassNotFoundException cnf) {</span>
<span class="line-added">+             throw new IllegalStateException(cnf);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Internal method to read an object from the ObjectInputStream of the expected type.</span>
<span class="line-added">+      * Called only from {@code readObject()} and {@code readString()}.</span>
<span class="line-added">+      * Only {@code Object.class} and {@code String.class} are supported.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param type the type expected; either Object.class or String.class</span>
<span class="line-added">+      * @return an object of the type</span>
<span class="line-added">+      * @throws  IOException Any of the usual Input/Output related exceptions.</span>
<span class="line-added">+      * @throws  ClassNotFoundException Class of a serialized object cannot be</span>
<span class="line-added">+      *          found.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final Object readObject(Class&lt;?&gt; type)</span>
          throws IOException, ClassNotFoundException
      {
          if (enableOverride) {
              return readObjectOverride();
          }
  
<span class="line-added">+         if (! (type == Object.class || type == String.class))</span>
<span class="line-added">+             throw new AssertionError(&quot;internal error&quot;);</span>
<span class="line-added">+ </span>
          // if nested read, passHandle contains handle of enclosing object
          int outerHandle = passHandle;
          try {
<span class="line-modified">!             Object obj = readObject0(type, false);</span>
              handles.markDependency(outerHandle, passHandle);
              ClassNotFoundException ex = handles.lookupException(passHandle);
              if (ex != null) {
                  throw ex;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,12 ***</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * This method is called by trusted subclasses of ObjectOutputStream that</span>
<span class="line-modified">!      * constructed ObjectOutputStream using the protected no-arg constructor.</span>
       * The subclass is expected to provide an override method with the modifier
       * &quot;final&quot;.
       *
       * @return  the Object read from the stream.
       * @throws  ClassNotFoundException Class definition of a serialized object
<span class="line-new-header">--- 514,12 ---</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * This method is called by trusted subclasses of ObjectInputStream that</span>
<span class="line-modified">!      + constructed ObjectInputStream using the protected no-arg constructor.</span>
       * The subclass is expected to provide an override method with the modifier
       * &quot;final&quot;.
       *
       * @return  the Object read from the stream.
       * @throws  ClassNotFoundException Class definition of a serialized object
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,11 ***</span>
       */
      public Object readUnshared() throws IOException, ClassNotFoundException {
          // if nested read, passHandle contains handle of enclosing object
          int outerHandle = passHandle;
          try {
<span class="line-modified">!             Object obj = readObject0(true);</span>
              handles.markDependency(outerHandle, passHandle);
              ClassNotFoundException ex = handles.lookupException(passHandle);
              if (ex != null) {
                  throw ex;
              }
<span class="line-new-header">--- 589,11 ---</span>
       */
      public Object readUnshared() throws IOException, ClassNotFoundException {
          // if nested read, passHandle contains handle of enclosing object
          int outerHandle = passHandle;
          try {
<span class="line-modified">!             Object obj = readObject0(Object.class, true);</span>
              handles.markDependency(outerHandle, passHandle);
              ClassNotFoundException ex = handles.lookupException(passHandle);
              if (ex != null) {
                  throw ex;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
  
      /**
       * Reads the persistent fields from the stream and makes them available by
       * name.
       *
<span class="line-modified">!      * @return  the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent</span>
       *          fields of the object being deserialized
       * @throws  ClassNotFoundException if the class of a serialized object
       *          could not be found.
       * @throws  IOException if an I/O error occurs.
       * @throws  NotActiveException if the stream is not currently reading
<span class="line-new-header">--- 654,11 ---</span>
  
      /**
       * Reads the persistent fields from the stream and makes them available by
       * name.
       *
<span class="line-modified">!      * @return  the {@code GetField} object representing the persistent</span>
       *          fields of the object being deserialized
       * @throws  ClassNotFoundException if the class of a serialized object
       *          could not be found.
       * @throws  IOException if an I/O error occurs.
       * @throws  NotActiveException if the stream is not currently reading
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,40 ***</span>
      /**
       * Load the local class equivalent of the specified stream class
       * description.  Subclasses may implement this method to allow classes to
       * be fetched from an alternate source.
       *
<span class="line-modified">!      * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is</span>
<span class="line-modified">!      * &lt;code&gt;annotateClass&lt;/code&gt;.  This method will be invoked only once for</span>
       * each unique class in the stream.  This method can be implemented by
       * subclasses to use an alternate loading mechanism but must return a
<span class="line-modified">!      * &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array</span>
       * class, its serialVersionUID is compared to the serialVersionUID of the
       * serialized class, and if there is a mismatch, the deserialization fails
       * and an {@link InvalidClassException} is thrown.
       *
       * &lt;p&gt;The default implementation of this method in
<span class="line-modified">!      * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling</span>
       * &lt;pre&gt;
       *     Class.forName(desc.getName(), false, loader)
       * &lt;/pre&gt;
<span class="line-modified">!      * where &lt;code&gt;loader&lt;/code&gt; is the first class loader on the current</span>
       * thread&#39;s stack (starting from the currently executing method) that is
       * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified">!      * class loader} nor its ancestor; otherwise, &lt;code&gt;loader&lt;/code&gt; is the</span>
       * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
<span class="line-modified">!      * &lt;code&gt;ClassNotFoundException&lt;/code&gt; and the name of the passed</span>
<span class="line-modified">!      * &lt;code&gt;ObjectStreamClass&lt;/code&gt; instance is the Java language keyword</span>
<span class="line-modified">!      * for a primitive type or void, then the &lt;code&gt;Class&lt;/code&gt; object</span>
       * representing that primitive type or void will be returned
<span class="line-modified">!      * (e.g., an &lt;code&gt;ObjectStreamClass&lt;/code&gt; with the name</span>
<span class="line-modified">!      * &lt;code&gt;&quot;int&quot;&lt;/code&gt; will be resolved to &lt;code&gt;Integer.TYPE&lt;/code&gt;).</span>
<span class="line-modified">!      * Otherwise, the &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown to</span>
       * the caller of this method.
       *
<span class="line-modified">!      * @param   desc an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;</span>
<span class="line-modified">!      * @return  a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;</span>
       * @throws  IOException any of the usual Input/Output exceptions.
       * @throws  ClassNotFoundException if class of a serialized object cannot
       *          be found.
       */
      protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
<span class="line-new-header">--- 718,40 ---</span>
      /**
       * Load the local class equivalent of the specified stream class
       * description.  Subclasses may implement this method to allow classes to
       * be fetched from an alternate source.
       *
<span class="line-modified">!      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is</span>
<span class="line-modified">!      * {@code annotateClass}.  This method will be invoked only once for</span>
       * each unique class in the stream.  This method can be implemented by
       * subclasses to use an alternate loading mechanism but must return a
<span class="line-modified">!      * {@code Class} object. Once returned, if the class is not an array</span>
       * class, its serialVersionUID is compared to the serialVersionUID of the
       * serialized class, and if there is a mismatch, the deserialization fails
       * and an {@link InvalidClassException} is thrown.
       *
       * &lt;p&gt;The default implementation of this method in
<span class="line-modified">!      * {@code ObjectInputStream} returns the result of calling</span>
       * &lt;pre&gt;
       *     Class.forName(desc.getName(), false, loader)
       * &lt;/pre&gt;
<span class="line-modified">!      * where {@code loader} is the first class loader on the current</span>
       * thread&#39;s stack (starting from the currently executing method) that is
       * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified">!      * class loader} nor its ancestor; otherwise, {@code loader} is the</span>
       * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
<span class="line-modified">!      * {@code ClassNotFoundException} and the name of the passed</span>
<span class="line-modified">!      * {@code ObjectStreamClass} instance is the Java language keyword</span>
<span class="line-modified">!      * for a primitive type or void, then the {@code Class} object</span>
       * representing that primitive type or void will be returned
<span class="line-modified">!      * (e.g., an {@code ObjectStreamClass} with the name</span>
<span class="line-modified">!      * {@code &quot;int&quot;} will be resolved to {@code Integer.TYPE}).</span>
<span class="line-modified">!      * Otherwise, the {@code ClassNotFoundException} will be thrown to</span>
       * the caller of this method.
       *
<span class="line-modified">!      * @param   desc an instance of class {@code ObjectStreamClass}</span>
<span class="line-modified">!      * @return  a {@code Class} object corresponding to {@code desc}</span>
       * @throws  IOException any of the usual Input/Output exceptions.
       * @throws  ClassNotFoundException if class of a serialized object cannot
       *          be found.
       */
      protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 709,47 ***</span>
       * interfaces and the proxy class.
       *
       * &lt;p&gt;This method is called exactly once for each unique proxy class
       * descriptor in the stream.
       *
<span class="line-modified">!      * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is</span>
<span class="line-modified">!      * &lt;code&gt;annotateProxyClass&lt;/code&gt;.  For a given subclass of</span>
<span class="line-modified">!      * &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the</span>
<span class="line-modified">!      * &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of</span>
<span class="line-modified">!      * &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by</span>
       * this method.
       *
       * &lt;p&gt;The default implementation of this method in
<span class="line-modified">!      * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling</span>
<span class="line-modified">!      * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt;</span>
<span class="line-modified">!      * objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt;</span>
<span class="line-modified">!      * parameter.  The &lt;code&gt;Class&lt;/code&gt; object for each interface name</span>
<span class="line-modified">!      * &lt;code&gt;i&lt;/code&gt; is the value returned by calling</span>
       * &lt;pre&gt;
       *     Class.forName(i, false, loader)
       * &lt;/pre&gt;
<span class="line-modified">!      * where &lt;code&gt;loader&lt;/code&gt; is the first class loader on the current</span>
       * thread&#39;s stack (starting from the currently executing method) that is
       * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified">!      * class loader} nor its ancestor; otherwise, &lt;code&gt;loader&lt;/code&gt; is the</span>
       * &lt;em&gt;platform class loader&lt;/em&gt;.
       * Unless any of the resolved interfaces are non-public, this same value
<span class="line-modified">!      * of &lt;code&gt;loader&lt;/code&gt; is also the class loader passed to</span>
<span class="line-modified">!      * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;; if non-public interfaces are present,</span>
       * their class loader is passed instead (if more than one non-public
       * interface class loader is encountered, an
<span class="line-modified">!      * &lt;code&gt;IllegalAccessError&lt;/code&gt; is thrown).</span>
<span class="line-modified">!      * If &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; throws an</span>
<span class="line-modified">!      * &lt;code&gt;IllegalArgumentException&lt;/code&gt;, &lt;code&gt;resolveProxyClass&lt;/code&gt;</span>
<span class="line-modified">!      * will throw a &lt;code&gt;ClassNotFoundException&lt;/code&gt; containing the</span>
<span class="line-modified">!      * &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</span>
       *
       * @param interfaces the list of interface names that were
       *                deserialized in the proxy class descriptor
       * @return  a proxy class for the specified interfaces
       * @throws        IOException any exception thrown by the underlying
<span class="line-modified">!      *                &lt;code&gt;InputStream&lt;/code&gt;</span>
       * @throws        ClassNotFoundException if the proxy class or any of the
       *                named interfaces could not be found
       * @see ObjectOutputStream#annotateProxyClass(Class)
       * @since 1.3
       */
<span class="line-new-header">--- 778,47 ---</span>
       * interfaces and the proxy class.
       *
       * &lt;p&gt;This method is called exactly once for each unique proxy class
       * descriptor in the stream.
       *
<span class="line-modified">!      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is</span>
<span class="line-modified">!      * {@code annotateProxyClass}.  For a given subclass of</span>
<span class="line-modified">!      * {@code ObjectInputStream} that overrides this method, the</span>
<span class="line-modified">!      * {@code annotateProxyClass} method in the corresponding subclass of</span>
<span class="line-modified">!      * {@code ObjectOutputStream} must write any data or objects read by</span>
       * this method.
       *
       * &lt;p&gt;The default implementation of this method in
<span class="line-modified">!      * {@code ObjectInputStream} returns the result of calling</span>
<span class="line-modified">!      * {@code Proxy.getProxyClass} with the list of {@code Class}</span>
<span class="line-modified">!      * objects for the interfaces that are named in the {@code interfaces}</span>
<span class="line-modified">!      * parameter.  The {@code Class} object for each interface name</span>
<span class="line-modified">!      * {@code i} is the value returned by calling</span>
       * &lt;pre&gt;
       *     Class.forName(i, false, loader)
       * &lt;/pre&gt;
<span class="line-modified">!      * where {@code loader} is the first class loader on the current</span>
       * thread&#39;s stack (starting from the currently executing method) that is
       * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified">!      * class loader} nor its ancestor; otherwise, {@code loader} is the</span>
       * &lt;em&gt;platform class loader&lt;/em&gt;.
       * Unless any of the resolved interfaces are non-public, this same value
<span class="line-modified">!      * of {@code loader} is also the class loader passed to</span>
<span class="line-modified">!      * {@code Proxy.getProxyClass}; if non-public interfaces are present,</span>
       * their class loader is passed instead (if more than one non-public
       * interface class loader is encountered, an
<span class="line-modified">!      * {@code IllegalAccessError} is thrown).</span>
<span class="line-modified">!      * If {@code Proxy.getProxyClass} throws an</span>
<span class="line-modified">!      * {@code IllegalArgumentException}, {@code resolveProxyClass}</span>
<span class="line-modified">!      * will throw a {@code ClassNotFoundException} containing the</span>
<span class="line-modified">!      * {@code IllegalArgumentException}.</span>
       *
       * @param interfaces the list of interface names that were
       *                deserialized in the proxy class descriptor
       * @return  a proxy class for the specified interfaces
       * @throws        IOException any exception thrown by the underlying
<span class="line-modified">!      *                {@code InputStream}</span>
       * @throws        ClassNotFoundException if the proxy class or any of the
       *                named interfaces could not be found
       * @see ObjectOutputStream#annotateProxyClass(Class)
       * @since 1.3
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,11 ***</span>
       * The readStreamHeader method is provided to allow subclasses to read and
       * verify their own stream headers. It reads and verifies the magic number
       * and version number.
       *
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
       * @throws  StreamCorruptedException if control information in the stream
       *          is inconsistent
       */
      protected void readStreamHeader()
          throws IOException, StreamCorruptedException
<span class="line-new-header">--- 930,11 ---</span>
       * The readStreamHeader method is provided to allow subclasses to read and
       * verify their own stream headers. It reads and verifies the magic number
       * and version number.
       *
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying {@code InputStream}</span>
       * @throws  StreamCorruptedException if control information in the stream
       *          is inconsistent
       */
      protected void readStreamHeader()
          throws IOException, StreamCorruptedException
</pre>
<hr />
<pre>
<span class="line-old-header">*** 882,11 ***</span>
       * Read a class descriptor from the serialization stream.  This method is
       * called when the ObjectInputStream expects a class descriptor as the next
       * item in the serialization stream.  Subclasses of ObjectInputStream may
       * override this method to read in class descriptors that have been written
       * in non-standard formats (by subclasses of ObjectOutputStream which have
<span class="line-modified">!      * overridden the &lt;code&gt;writeClassDescriptor&lt;/code&gt; method).  By default,</span>
       * this method reads class descriptors according to the format defined in
       * the Object Serialization specification.
       *
       * @return  the class descriptor read
       * @throws  IOException If an I/O error has occurred.
<span class="line-new-header">--- 951,11 ---</span>
       * Read a class descriptor from the serialization stream.  This method is
       * called when the ObjectInputStream expects a class descriptor as the next
       * item in the serialization stream.  Subclasses of ObjectInputStream may
       * override this method to read in class descriptors that have been written
       * in non-standard formats (by subclasses of ObjectOutputStream which have
<span class="line-modified">!      * overridden the {@code writeClassDescriptor} method).  By default,</span>
       * this method reads class descriptors according to the format defined in
       * the Object Serialization specification.
       *
       * @return  the class descriptor read
       * @throws  IOException If an I/O error has occurred.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 944,11 ***</span>
      /**
       * Returns the number of bytes that can be read without blocking.
       *
       * @return  the number of available bytes.
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
       */
      public int available() throws IOException {
          return bin.available();
      }
  
<span class="line-new-header">--- 1013,11 ---</span>
      /**
       * Returns the number of bytes that can be read without blocking.
       *
       * @return  the number of available bytes.
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying {@code InputStream}</span>
       */
      public int available() throws IOException {
          return bin.available();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1127,11 ***</span>
      /**
       * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
       *
       * @return  a String copy of the line.
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
       * @deprecated This method does not properly convert bytes to characters.
       *          see DataInputStream for the details and alternatives.
       */
      @Deprecated
      public String readLine() throws IOException {
<span class="line-new-header">--- 1196,11 ---</span>
      /**
       * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
       *
       * @return  a String copy of the line.
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying {@code InputStream}</span>
       * @deprecated This method does not properly convert bytes to characters.
       *          see DataInputStream for the details and alternatives.
       */
      @Deprecated
      public String readLine() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1143,11 ***</span>
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
       * format.
       *
       * @return  the String.
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
       * @throws  UTFDataFormatException if read bytes do not represent a valid
       *          modified UTF-8 encoding of a string
       */
      public String readUTF() throws IOException {
          return bin.readUTF();
<span class="line-new-header">--- 1212,11 ---</span>
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
       * format.
       *
       * @return  the String.
       * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">!      *          underlying {@code InputStream}</span>
       * @throws  UTFDataFormatException if read bytes do not represent a valid
       *          modified UTF-8 encoding of a string
       */
      public String readUTF() throws IOException {
          return bin.readUTF();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1319,10 ***</span>
<span class="line-new-header">--- 1388,14 ---</span>
  
      /**
       * Provide access to the persistent fields read from the input stream.
       */
      public abstract static class GetField {
<span class="line-added">+         /**</span>
<span class="line-added">+          * Constructor for subclasses to call.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public GetField() {}</span>
  
          /**
           * Get the ObjectStreamClass that describes the fields in the stream.
           *
           * @return  the descriptor class that describes the serializable fields
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1334,139 ***</span>
           * stream.
           *
           * @param  name the name of the field
           * @return true, if and only if the named field is defaulted
           * @throws IOException if there are I/O errors while reading from
<span class="line-modified">!          *         the underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         correspond to a serializable field
           */
          public abstract boolean defaulted(String name) throws IOException;
  
          /**
           * Get the value of the named boolean field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;boolean&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract boolean get(String name, boolean val)
              throws IOException;
  
          /**
           * Get the value of the named byte field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;byte&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract byte get(String name, byte val) throws IOException;
  
          /**
           * Get the value of the named char field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;char&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract char get(String name, char val) throws IOException;
  
          /**
           * Get the value of the named short field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;short&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract short get(String name, short val) throws IOException;
  
          /**
           * Get the value of the named int field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;int&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract int get(String name, int val) throws IOException;
  
          /**
           * Get the value of the named long field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;long&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract long get(String name, long val) throws IOException;
  
          /**
           * Get the value of the named float field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;float&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract float get(String name, float val) throws IOException;
  
          /**
           * Get the value of the named double field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;double&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract double get(String name, double val) throws IOException;
  
          /**
           * Get the value of the named Object field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named &lt;code&gt;Object&lt;/code&gt; field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract Object get(String name, Object val) throws IOException;
      }
  
<span class="line-new-header">--- 1407,139 ---</span>
           * stream.
           *
           * @param  name the name of the field
           * @return true, if and only if the named field is defaulted
           * @throws IOException if there are I/O errors while reading from
<span class="line-modified">!          *         the underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           *         correspond to a serializable field
           */
          public abstract boolean defaulted(String name) throws IOException;
  
          /**
           * Get the value of the named boolean field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code boolean} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract boolean get(String name, boolean val)
              throws IOException;
  
          /**
           * Get the value of the named byte field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code byte} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract byte get(String name, byte val) throws IOException;
  
          /**
           * Get the value of the named char field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code char} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract char get(String name, char val) throws IOException;
  
          /**
           * Get the value of the named short field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code short} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract short get(String name, short val) throws IOException;
  
          /**
           * Get the value of the named int field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code int} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract int get(String name, int val) throws IOException;
  
          /**
           * Get the value of the named long field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code long} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract long get(String name, long val) throws IOException;
  
          /**
           * Get the value of the named float field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code float} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract float get(String name, float val) throws IOException;
  
          /**
           * Get the value of the named double field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code double} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract double get(String name, double val) throws IOException;
  
          /**
           * Get the value of the named Object field from the persistent field.
           *
           * @param  name the name of the field
<span class="line-modified">!          * @param  val the default value to use if {@code name} does not</span>
           *         have a value
<span class="line-modified">!          * @return the value of the named {@code Object} field</span>
           * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">!          *         underlying {@code InputStream}</span>
<span class="line-modified">!          * @throws IllegalArgumentException if type of {@code name} is</span>
           *         not serializable or if the field type is incorrect
           */
          public abstract Object get(String name, Object val) throws IOException;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1536,12 ***</span>
          vlist.clear();
      }
  
      /**
       * Underlying readObject implementation.
       */
<span class="line-modified">!     private Object readObject0(boolean unshared) throws IOException {</span>
          boolean oldMode = bin.getBlockDataMode();
          if (oldMode) {
              int remain = bin.currentBlockRemaining();
              if (remain &gt; 0) {
                  throw new OptionalDataException(remain);
<span class="line-new-header">--- 1609,14 ---</span>
          vlist.clear();
      }
  
      /**
       * Underlying readObject implementation.
<span class="line-added">+      * @param type a type expected to be deserialized; non-null</span>
<span class="line-added">+      * @param unshared true if the object can not be a reference to a shared object, otherwise false</span>
       */
<span class="line-modified">!     private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException {</span>
          boolean oldMode = bin.getBlockDataMode();
          if (oldMode) {
              int remain = bin.currentBlockRemaining();
              if (remain &gt; 0) {
                  throw new OptionalDataException(remain);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1569,33 ***</span>
              switch (tc) {
                  case TC_NULL:
                      return readNull();
  
                  case TC_REFERENCE:
<span class="line-modified">!                     return readHandle(unshared);</span>
  
                  case TC_CLASS:
                      return readClass(unshared);
  
                  case TC_CLASSDESC:
                  case TC_PROXYCLASSDESC:
                      return readClassDesc(unshared);
  
                  case TC_STRING:
                  case TC_LONGSTRING:
                      return checkResolve(readString(unshared));
  
                  case TC_ARRAY:
                      return checkResolve(readArray(unshared));
  
                  case TC_ENUM:
                      return checkResolve(readEnum(unshared));
  
                  case TC_OBJECT:
                      return checkResolve(readOrdinaryObject(unshared));
  
                  case TC_EXCEPTION:
                      IOException ex = readFatalException();
                      throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
  
                  case TC_BLOCKDATA:
                  case TC_BLOCKDATALONG:
<span class="line-new-header">--- 1644,52 ---</span>
              switch (tc) {
                  case TC_NULL:
                      return readNull();
  
                  case TC_REFERENCE:
<span class="line-modified">!                     // check the type of the existing object</span>
<span class="line-added">+                     return type.cast(readHandle(unshared));</span>
  
                  case TC_CLASS:
<span class="line-added">+                     if (type == String.class) {</span>
<span class="line-added">+                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);</span>
<span class="line-added">+                     }</span>
                      return readClass(unshared);
  
                  case TC_CLASSDESC:
                  case TC_PROXYCLASSDESC:
<span class="line-added">+                     if (type == String.class) {</span>
<span class="line-added">+                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);</span>
<span class="line-added">+                     }</span>
                      return readClassDesc(unshared);
  
                  case TC_STRING:
                  case TC_LONGSTRING:
                      return checkResolve(readString(unshared));
  
                  case TC_ARRAY:
<span class="line-added">+                     if (type == String.class) {</span>
<span class="line-added">+                         throw new ClassCastException(&quot;Cannot cast an array to java.lang.String&quot;);</span>
<span class="line-added">+                     }</span>
                      return checkResolve(readArray(unshared));
  
                  case TC_ENUM:
<span class="line-added">+                     if (type == String.class) {</span>
<span class="line-added">+                         throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;);</span>
<span class="line-added">+                     }</span>
                      return checkResolve(readEnum(unshared));
  
                  case TC_OBJECT:
<span class="line-added">+                     if (type == String.class) {</span>
<span class="line-added">+                         throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);</span>
<span class="line-added">+                     }</span>
                      return checkResolve(readOrdinaryObject(unshared));
  
                  case TC_EXCEPTION:
<span class="line-added">+                     if (type == String.class) {</span>
<span class="line-added">+                         throw new ClassCastException(&quot;Cannot cast an exception to java.lang.String&quot;);</span>
<span class="line-added">+                     }</span>
                      IOException ex = readFatalException();
                      throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
  
                  case TC_BLOCKDATA:
                  case TC_BLOCKDATALONG:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1963,11 ***</span>
              handles.markException(arrayHandle, resolveEx);
          }
  
          if (ccl == null) {
              for (int i = 0; i &lt; len; i++) {
<span class="line-modified">!                 readObject0(false);</span>
              }
          } else if (ccl.isPrimitive()) {
              if (ccl == Integer.TYPE) {
                  bin.readInts((int[]) array, 0, len);
              } else if (ccl == Byte.TYPE) {
<span class="line-new-header">--- 2057,11 ---</span>
              handles.markException(arrayHandle, resolveEx);
          }
  
          if (ccl == null) {
              for (int i = 0; i &lt; len; i++) {
<span class="line-modified">!                 readObject0(Object.class, false);</span>
              }
          } else if (ccl.isPrimitive()) {
              if (ccl == Integer.TYPE) {
                  bin.readInts((int[]) array, 0, len);
              } else if (ccl == Byte.TYPE) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1988,11 ***</span>
                  throw new InternalError();
              }
          } else {
              Object[] oa = (Object[]) array;
              for (int i = 0; i &lt; len; i++) {
<span class="line-modified">!                 oa[i] = readObject0(false);</span>
                  handles.markDependency(arrayHandle, passHandle);
              }
          }
  
          handles.finish(arrayHandle);
<span class="line-new-header">--- 2082,11 ---</span>
                  throw new InternalError();
              }
          } else {
              Object[] oa = (Object[]) array;
              for (int i = 0; i &lt; len; i++) {
<span class="line-modified">!                 oa[i] = readObject0(Object.class, false);</span>
                  handles.markDependency(arrayHandle, passHandle);
              }
          }
  
          handles.finish(arrayHandle);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2041,10 ***</span>
<span class="line-new-header">--- 2135,15 ---</span>
          handles.finish(enumHandle);
          passHandle = enumHandle;
          return result;
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private static boolean isRecord(Class&lt;?&gt; cls) {</span>
<span class="line-added">+         return cls.isRecord();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
       * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
       * class is unresolvable (in which case a ClassNotFoundException will be
       * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2079,11 ***</span>
          ClassNotFoundException resolveEx = desc.getResolveException();
          if (resolveEx != null) {
              handles.markException(passHandle, resolveEx);
          }
  
<span class="line-modified">!         if (desc.isExternalizable()) {</span>
              readExternalData((Externalizable) obj, desc);
          } else {
              readSerialData(obj, desc);
          }
  
<span class="line-new-header">--- 2178,16 ---</span>
          ClassNotFoundException resolveEx = desc.getResolveException();
          if (resolveEx != null) {
              handles.markException(passHandle, resolveEx);
          }
  
<span class="line-modified">!         final boolean isRecord = cl != null &amp;&amp; isRecord(cl) ? true : false;</span>
<span class="line-added">+         if (isRecord) {</span>
<span class="line-added">+             assert obj == null;</span>
<span class="line-added">+             obj = readRecord(desc);</span>
<span class="line-added">+             handles.setObject(passHandle, obj);</span>
<span class="line-added">+         } else if (desc.isExternalizable()) {</span>
              readExternalData((Externalizable) obj, desc);
          } else {
              readSerialData(obj, desc);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2165,10 ***</span>
<span class="line-new-header">--- 2269,47 ---</span>
           * externalizable data remains in the stream, a subsequent read will
           * most likely throw a StreamCorruptedException.
           */
      }
  
<span class="line-added">+     /** Reads a record. */</span>
<span class="line-added">+     private Object readRecord(ObjectStreamClass desc) throws IOException {</span>
<span class="line-added">+         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="line-added">+         if (slots.length != 1) {</span>
<span class="line-added">+             // skip any superclass stream field values</span>
<span class="line-added">+             for (int i = 0; i &lt; slots.length-1; i++) {</span>
<span class="line-added">+                 ObjectStreamClass slotDesc = slots[i].desc;</span>
<span class="line-added">+                 if (slots[i].hasData) {</span>
<span class="line-added">+                     defaultReadFields(null, slotDesc);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         FieldValues fieldValues = defaultReadFields(null, desc);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // retrieve the canonical constructor</span>
<span class="line-added">+         MethodHandle ctrMH = desc.getRecordConstructor();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // bind the stream field values</span>
<span class="line-added">+         ctrMH = RecordSupport.bindCtrValues(ctrMH, desc, fieldValues);</span>
<span class="line-added">+ </span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return ctrMH.invoke();</span>
<span class="line-added">+         } catch (Exception e) {</span>
<span class="line-added">+             InvalidObjectException ioe = new InvalidObjectException(e.getMessage());</span>
<span class="line-added">+             ioe.initCause(e);</span>
<span class="line-added">+             throw ioe;</span>
<span class="line-added">+         } catch (Error e) {</span>
<span class="line-added">+             throw e;</span>
<span class="line-added">+         } catch (Throwable t) {</span>
<span class="line-added">+             ObjectStreamException ose = new InvalidObjectException(</span>
<span class="line-added">+                     &quot;ReflectiveOperationException during deserialization&quot;);</span>
<span class="line-added">+             ose.initCause(t);</span>
<span class="line-added">+             throw ose;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Reads (or attempts to skip, if obj is null or is tagged with a
       * ClassNotFoundException) instance data for each serializable class of
       * object in stream, from superclass to subclass.  Expects that passHandle
       * is set to obj&#39;s handle before this method is called.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2305,17 ***</span>
                      bin.readByte();
                      passHandle = oldHandle;
                      return;
  
                  default:
<span class="line-modified">!                     readObject0(false);</span>
                      break;
              }
          }
      }
  
<span class="line-modified">!     private class FieldValues {</span>
          final byte[] primValues;
          final Object[] objValues;
  
          FieldValues(byte[] primValues, Object[] objValues) {
              this.primValues = primValues;
<span class="line-new-header">--- 2446,17 ---</span>
                      bin.readByte();
                      passHandle = oldHandle;
                      return;
  
                  default:
<span class="line-modified">!                     readObject0(Object.class, false);</span>
                      break;
              }
          }
      }
  
<span class="line-modified">!     /*package-private*/ class FieldValues {</span>
          final byte[] primValues;
          final Object[] objValues;
  
          FieldValues(byte[] primValues, Object[] objValues) {
              this.primValues = primValues;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2350,11 ***</span>
              ObjectStreamField[] fields = desc.getFields(false);
              objVals = new Object[numObjFields];
              int numPrimFields = fields.length - objVals.length;
              for (int i = 0; i &lt; objVals.length; i++) {
                  ObjectStreamField f = fields[numPrimFields + i];
<span class="line-modified">!                 objVals[i] = readObject0(f.isUnshared());</span>
                  if (f.getField() != null) {
                      handles.markDependency(objHandle, passHandle);
                  }
              }
              passHandle = objHandle;
<span class="line-new-header">--- 2491,11 ---</span>
              ObjectStreamField[] fields = desc.getFields(false);
              objVals = new Object[numObjFields];
              int numPrimFields = fields.length - objVals.length;
              for (int i = 0; i &lt; objVals.length; i++) {
                  ObjectStreamField f = fields[numPrimFields + i];
<span class="line-modified">!                 objVals[i] = readObject0(Object.class, f.isUnshared());</span>
                  if (f.getField() != null) {
                      handles.markDependency(objHandle, passHandle);
                  }
              }
              passHandle = objHandle;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2391,11 ***</span>
      private IOException readFatalException() throws IOException {
          if (bin.readByte() != TC_EXCEPTION) {
              throw new InternalError();
          }
          clear();
<span class="line-modified">!         return (IOException) readObject0(false);</span>
      }
  
      /**
       * If recursion depth is 0, clears internal data structures; otherwise,
       * throws a StreamCorruptedException.  This method is called when a
<span class="line-new-header">--- 2532,11 ---</span>
      private IOException readFatalException() throws IOException {
          if (bin.readByte() != TC_EXCEPTION) {
              throw new InternalError();
          }
          clear();
<span class="line-modified">!         return (IOException) readObject0(Object.class, false);</span>
      }
  
      /**
       * If recursion depth is 0, clears internal data structures; otherwise,
       * throws a StreamCorruptedException.  This method is called when a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2407,26 ***</span>
                  &quot;unexpected reset; recursion depth: &quot; + depth);
          }
          clear();
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Converts specified span of bytes into float values.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     // REMIND: remove once hotspot inlines Float.intBitsToFloat</span>
<span class="line-removed">-     private static native void bytesToFloats(byte[] src, int srcpos,</span>
<span class="line-removed">-                                              float[] dst, int dstpos,</span>
<span class="line-removed">-                                              int nfloats);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Converts specified span of bytes into double values.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     // REMIND: remove once hotspot inlines Double.longBitsToDouble</span>
<span class="line-removed">-     private static native void bytesToDoubles(byte[] src, int srcpos,</span>
<span class="line-removed">-                                               double[] dst, int dstpos,</span>
<span class="line-removed">-                                               int ndoubles);</span>
<span class="line-removed">- </span>
      /**
       * Returns the first non-null and non-platform class loader (not counting
       * class loaders of generated reflection implementation classes) up the
       * execution stack, or the platform class loader if only code from the
       * bootstrap and platform class loader is on the stack.
<span class="line-new-header">--- 2548,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2529,11 ***</span>
              int oldHandle = passHandle;
              ObjectStreamField[] fields = desc.getFields(false);
              int numPrimFields = fields.length - objVals.length;
              for (int i = 0; i &lt; objVals.length; i++) {
                  objVals[i] =
<span class="line-modified">!                     readObject0(fields[numPrimFields + i].isUnshared());</span>
                  objHandles[i] = passHandle;
              }
              passHandle = oldHandle;
          }
  
<span class="line-new-header">--- 2654,11 ---</span>
              int oldHandle = passHandle;
              ObjectStreamField[] fields = desc.getFields(false);
              int numPrimFields = fields.length - objVals.length;
              for (int i = 0; i &lt; objVals.length; i++) {
                  objVals[i] =
<span class="line-modified">!                     readObject0(Object.class, fields[numPrimFields + i].isUnshared());</span>
                  objHandles[i] = passHandle;
              }
              passHandle = oldHandle;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3427,26 ***</span>
                  }
              }
          }
  
          void readFloats(float[] v, int off, int len) throws IOException {
<span class="line-modified">!             int span, endoff = off + len;</span>
              while (off &lt; endoff) {
                  if (!blkmode) {
<span class="line-modified">!                     span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</span>
                      in.readFully(buf, 0, span &lt;&lt; 2);
                      pos = 0;
                  } else if (end - pos &lt; 4) {
                      v[off++] = din.readFloat();
                      continue;
                  } else {
<span class="line-modified">!                     span = Math.min(endoff - off, ((end - pos) &gt;&gt; 2));</span>
                  }
  
<span class="line-modified">!                 bytesToFloats(buf, pos, v, off, span);</span>
<span class="line-modified">!                 off += span;</span>
<span class="line-modified">!                 pos += span &lt;&lt; 2;</span>
              }
          }
  
          void readLongs(long[] v, int off, int len) throws IOException {
              int stop, endoff = off + len;
<span class="line-new-header">--- 3552,28 ---</span>
                  }
              }
          }
  
          void readFloats(float[] v, int off, int len) throws IOException {
<span class="line-modified">!             int stop, endoff = off + len;</span>
              while (off &lt; endoff) {
                  if (!blkmode) {
<span class="line-modified">!                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</span>
                      in.readFully(buf, 0, span &lt;&lt; 2);
<span class="line-added">+                     stop = off + span;</span>
                      pos = 0;
                  } else if (end - pos &lt; 4) {
                      v[off++] = din.readFloat();
                      continue;
                  } else {
<span class="line-modified">!                     stop = Math.min(endoff, ((end - pos) &gt;&gt; 2));</span>
                  }
  
<span class="line-modified">!                 while (off &lt; stop) {</span>
<span class="line-modified">!                     v[off++] = Bits.getFloat(buf, pos);</span>
<span class="line-modified">!                     pos += 4;</span>
<span class="line-added">+                 }</span>
              }
          }
  
          void readLongs(long[] v, int off, int len) throws IOException {
              int stop, endoff = off + len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3469,26 ***</span>
                  }
              }
          }
  
          void readDoubles(double[] v, int off, int len) throws IOException {
<span class="line-modified">!             int span, endoff = off + len;</span>
              while (off &lt; endoff) {
                  if (!blkmode) {
<span class="line-modified">!                     span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);</span>
                      in.readFully(buf, 0, span &lt;&lt; 3);
                      pos = 0;
                  } else if (end - pos &lt; 8) {
                      v[off++] = din.readDouble();
                      continue;
                  } else {
<span class="line-modified">!                     span = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));</span>
                  }
  
<span class="line-modified">!                 bytesToDoubles(buf, pos, v, off, span);</span>
<span class="line-modified">!                 off += span;</span>
<span class="line-modified">!                 pos += span &lt;&lt; 3;</span>
              }
          }
  
          /**
           * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
<span class="line-new-header">--- 3596,28 ---</span>
                  }
              }
          }
  
          void readDoubles(double[] v, int off, int len) throws IOException {
<span class="line-modified">!             int stop, endoff = off + len;</span>
              while (off &lt; endoff) {
                  if (!blkmode) {
<span class="line-modified">!                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);</span>
                      in.readFully(buf, 0, span &lt;&lt; 3);
<span class="line-added">+                     stop = off + span;</span>
                      pos = 0;
                  } else if (end - pos &lt; 8) {
                      v[off++] = din.readDouble();
                      continue;
                  } else {
<span class="line-modified">!                     stop = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));</span>
                  }
  
<span class="line-modified">!                 while (off &lt; stop) {</span>
<span class="line-modified">!                     v[off++] = Bits.getDouble(buf, pos);</span>
<span class="line-modified">!                     pos += 8;</span>
<span class="line-added">+                 }</span>
              }
          }
  
          /**
           * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4014,8 ***</span>
<span class="line-new-header">--- 4143,9 ---</span>
          }
      }
  
      static {
          SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
<span class="line-added">+         SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);</span>
      }
  
  }
</pre>
<center><a href="ObjectInputFilter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectInputValidation.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
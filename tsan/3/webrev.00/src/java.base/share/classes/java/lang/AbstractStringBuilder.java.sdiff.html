<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/AbstractStringBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractMethodError.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArithmeticException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/AbstractStringBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import jdk.internal.math.FloatingDecimal;

  29 import java.util.Arrays;
  30 import java.util.Spliterator;
  31 import java.util.stream.IntStream;
  32 import java.util.stream.StreamSupport;
  33 
  34 import static java.lang.String.COMPACT_STRINGS;
  35 import static java.lang.String.UTF16;
  36 import static java.lang.String.LATIN1;
  37 import static java.lang.String.checkIndex;
  38 import static java.lang.String.checkOffset;
  39 
  40 /**
  41  * A mutable sequence of characters.
  42  * &lt;p&gt;
  43  * Implements a modifiable string. At any point in time it contains some
  44  * particular sequence of characters, but the length and content of the
  45  * sequence can be changed through certain method calls.
  46  *
  47  * &lt;p&gt;Unless otherwise noted, passing a {@code null} argument to a constructor
  48  * or method in this class will cause a {@link NullPointerException} to be
</pre>
<hr />
<pre>
  75      * This no-arg constructor is necessary for serialization of subclasses.
  76      */
  77     AbstractStringBuilder() {
  78         value = EMPTYVALUE;
  79     }
  80 
  81     /**
  82      * Creates an AbstractStringBuilder of the specified capacity.
  83      */
  84     AbstractStringBuilder(int capacity) {
  85         if (COMPACT_STRINGS) {
  86             value = new byte[capacity];
  87             coder = LATIN1;
  88         } else {
  89             value = StringUTF16.newBytesFor(capacity);
  90             coder = UTF16;
  91         }
  92     }
  93 
  94     /**
<span class="line-modified">  95      * Creates an AbstractStringBuilder with the specified coder and with</span>
<span class="line-modified">  96      * the initial capacity equal to the smaller of (length + addition)</span>
<span class="line-modified">  97      * and Integer.MAX_VALUE.</span>






















  98      */
<span class="line-modified">  99     AbstractStringBuilder(byte coder, int length, int addition) {</span>

 100         if (length &lt; 0) {
 101             throw new NegativeArraySizeException(&quot;Negative length: &quot; + length);
 102         }
<span class="line-modified"> 103         this.coder = coder;</span>
<span class="line-modified"> 104         int capacity = (length &lt; Integer.MAX_VALUE - addition)</span>
<span class="line-modified"> 105                 ? length + addition : Integer.MAX_VALUE;</span>
<span class="line-modified"> 106         value = (coder == LATIN1)</span>














 107                 ? new byte[capacity] : StringUTF16.newBytesFor(capacity);

 108     }
 109 
 110     /**
 111      * Compares the objects of two AbstractStringBuilder implementations lexicographically.
 112      *
 113      * @since 11
 114      */
 115     int compareTo(AbstractStringBuilder another) {
 116         if (this == another) {
 117             return 0;
 118         }
 119 
 120         byte val1[] = value;
 121         byte val2[] = another.value;
 122         int count1 = this.count;
 123         int count2 = another.count;
 124 
 125         if (coder == another.coder) {
 126             return isLatin1() ? StringLatin1.compareTo(val1, val2, count1, count2)
 127                               : StringUTF16.compareTo(val1, val2, count1, count2);
 128         }
 129         return isLatin1() ? StringLatin1.compareToUTF16(val1, val2, count1, count2)
 130                           : StringUTF16.compareToLatin1(val1, val2, count1, count2);
 131     }
 132 
 133     /**
 134      * Returns the length (character count).
 135      *
 136      * @return  the length of the sequence of characters currently
 137      *          represented by this object
 138      */
 139     @Override
 140     public int length() {
 141         return count;
 142     }
 143 
 144     /**
<span class="line-modified"> 145      * Returns the current capacity. The capacity is the amount of storage</span>
<span class="line-modified"> 146      * available for newly inserted characters, beyond which an allocation</span>
<span class="line-modified"> 147      * will occur.</span>
 148      *
 149      * @return  the current capacity
 150      */
 151     public int capacity() {
 152         return value.length &gt;&gt; coder;
 153     }
 154 
 155     /**
 156      * Ensures that the capacity is at least equal to the specified minimum.
 157      * If the current capacity is less than the argument, then a new internal
 158      * array is allocated with greater capacity. The new capacity is the
 159      * larger of:
 160      * &lt;ul&gt;
 161      * &lt;li&gt;The {@code minimumCapacity} argument.
 162      * &lt;li&gt;Twice the old capacity, plus {@code 2}.
 163      * &lt;/ul&gt;
 164      * If the {@code minimumCapacity} argument is nonpositive, this
 165      * method takes no action and simply returns.
 166      * Note that subsequent operations on this object can reduce the
 167      * actual capacity below that requested here.
</pre>
<hr />
<pre>
 630      * characters as if the s parameter was a sequence containing the four
 631      * characters {@code &quot;null&quot;}.
 632      *
 633      * @param   s the sequence to append.
 634      * @param   start   the starting index of the subsequence to be appended.
 635      * @param   end     the end index of the subsequence to be appended.
 636      * @return  a reference to this object.
 637      * @throws     IndexOutOfBoundsException if
 638      *             {@code start} is negative, or
 639      *             {@code start} is greater than {@code end} or
 640      *             {@code end} is greater than {@code s.length()}
 641      */
 642     @Override
 643     public AbstractStringBuilder append(CharSequence s, int start, int end) {
 644         if (s == null) {
 645             s = &quot;null&quot;;
 646         }
 647         checkRange(start, end, s.length());
 648         int len = end - start;
 649         ensureCapacityInternal(count + len);
<span class="line-modified"> 650         appendChars(s, start, end);</span>




 651         return this;
 652     }
 653 

 654     /**
 655      * Appends the string representation of the {@code char} array
 656      * argument to this sequence.
 657      * &lt;p&gt;
 658      * The characters of the array argument are appended, in order, to
 659      * the contents of this sequence. The length of this sequence
 660      * increases by the length of the argument.
 661      * &lt;p&gt;
 662      * The overall effect is exactly as if the argument were converted
 663      * to a string by the method {@link String#valueOf(char[])},
 664      * and the characters of that string were then
 665      * {@link #append(String) appended} to this character sequence.
 666      *
 667      * @param   str   the characters to be appended.
 668      * @return  a reference to this object.
 669      */
 670     public AbstractStringBuilder append(char[] str) {
 671         int len = str.length;
 672         ensureCapacityInternal(count + len);
 673         appendChars(str, 0, len);
</pre>
<hr />
<pre>
1688         if (isLatin1()) {
1689             byte[] val = this.value;
1690             for (int i = off, j = count; i &lt; end; i++) {
1691                 char c = s[i];
1692                 if (StringLatin1.canEncode(c)) {
1693                     val[j++] = (byte)c;
1694                 } else {
1695                     this.count = count = j;
1696                     inflate();
1697                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1698                     this.count = count + end - i;
1699                     return;
1700                 }
1701             }
1702         } else {
1703             StringUTF16.putCharsSB(this.value, count, s, off, end);
1704         }
1705         this.count = count + end - off;
1706     }
1707 





























1708     private final void appendChars(CharSequence s, int off, int end) {
1709         if (isLatin1()) {
1710             byte[] val = this.value;
1711             for (int i = off, j = count; i &lt; end; i++) {
1712                 char c = s.charAt(i);
1713                 if (StringLatin1.canEncode(c)) {
1714                     val[j++] = (byte)c;
1715                 } else {
1716                     count = j;
1717                     inflate();
1718                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1719                     count += end - i;
1720                     return;
1721                 }
1722             }
1723         } else {
1724             StringUTF16.putCharsSB(this.value, count, s, off, end);
1725         }
1726         count += end - off;
1727     }
</pre>
</td>
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import jdk.internal.math.FloatingDecimal;
<span class="line-added">  29 </span>
  30 import java.util.Arrays;
  31 import java.util.Spliterator;
  32 import java.util.stream.IntStream;
  33 import java.util.stream.StreamSupport;
  34 
  35 import static java.lang.String.COMPACT_STRINGS;
  36 import static java.lang.String.UTF16;
  37 import static java.lang.String.LATIN1;
  38 import static java.lang.String.checkIndex;
  39 import static java.lang.String.checkOffset;
  40 
  41 /**
  42  * A mutable sequence of characters.
  43  * &lt;p&gt;
  44  * Implements a modifiable string. At any point in time it contains some
  45  * particular sequence of characters, but the length and content of the
  46  * sequence can be changed through certain method calls.
  47  *
  48  * &lt;p&gt;Unless otherwise noted, passing a {@code null} argument to a constructor
  49  * or method in this class will cause a {@link NullPointerException} to be
</pre>
<hr />
<pre>
  76      * This no-arg constructor is necessary for serialization of subclasses.
  77      */
  78     AbstractStringBuilder() {
  79         value = EMPTYVALUE;
  80     }
  81 
  82     /**
  83      * Creates an AbstractStringBuilder of the specified capacity.
  84      */
  85     AbstractStringBuilder(int capacity) {
  86         if (COMPACT_STRINGS) {
  87             value = new byte[capacity];
  88             coder = LATIN1;
  89         } else {
  90             value = StringUTF16.newBytesFor(capacity);
  91             coder = UTF16;
  92         }
  93     }
  94 
  95     /**
<span class="line-modified">  96      * Constructs an AbstractStringBuilder that contains the same characters</span>
<span class="line-modified">  97      * as the specified {@code String}. The initial capacity of</span>
<span class="line-modified">  98      * the string builder is {@code 16} plus the length of the</span>
<span class="line-added">  99      * {@code String} argument.</span>
<span class="line-added"> 100      *</span>
<span class="line-added"> 101      * @param      str   the string to copy.</span>
<span class="line-added"> 102      */</span>
<span class="line-added"> 103     AbstractStringBuilder(String str) {</span>
<span class="line-added"> 104         int length = str.length();</span>
<span class="line-added"> 105         int capacity = (length &lt; Integer.MAX_VALUE - 16)</span>
<span class="line-added"> 106                 ? length + 16 : Integer.MAX_VALUE;</span>
<span class="line-added"> 107         final byte initCoder = str.coder();</span>
<span class="line-added"> 108         coder = initCoder;</span>
<span class="line-added"> 109         value = (initCoder == LATIN1)</span>
<span class="line-added"> 110                 ? new byte[capacity] : StringUTF16.newBytesFor(capacity);</span>
<span class="line-added"> 111         append(str);</span>
<span class="line-added"> 112     }</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114     /**</span>
<span class="line-added"> 115      * Constructs an AbstractStringBuilder that contains the same characters</span>
<span class="line-added"> 116      * as the specified {@code CharSequence}. The initial capacity of</span>
<span class="line-added"> 117      * the string builder is {@code 16} plus the length of the</span>
<span class="line-added"> 118      * {@code CharSequence} argument.</span>
<span class="line-added"> 119      *</span>
<span class="line-added"> 120      * @param      seq   the sequence to copy.</span>
 121      */
<span class="line-modified"> 122     AbstractStringBuilder(CharSequence seq) {</span>
<span class="line-added"> 123         int length = seq.length();</span>
 124         if (length &lt; 0) {
 125             throw new NegativeArraySizeException(&quot;Negative length: &quot; + length);
 126         }
<span class="line-modified"> 127         int capacity = (length &lt; Integer.MAX_VALUE - 16)</span>
<span class="line-modified"> 128                 ? length + 16 : Integer.MAX_VALUE;</span>
<span class="line-modified"> 129 </span>
<span class="line-modified"> 130         final byte initCoder;</span>
<span class="line-added"> 131         if (COMPACT_STRINGS) {</span>
<span class="line-added"> 132             if (seq instanceof AbstractStringBuilder) {</span>
<span class="line-added"> 133                 initCoder = ((AbstractStringBuilder)seq).getCoder();</span>
<span class="line-added"> 134             } else if (seq instanceof String) {</span>
<span class="line-added"> 135                 initCoder = ((String)seq).coder();</span>
<span class="line-added"> 136             } else {</span>
<span class="line-added"> 137                 initCoder = LATIN1;</span>
<span class="line-added"> 138             }</span>
<span class="line-added"> 139         } else {</span>
<span class="line-added"> 140             initCoder = UTF16;</span>
<span class="line-added"> 141         }</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143         coder = initCoder;</span>
<span class="line-added"> 144         value = (initCoder == LATIN1)</span>
 145                 ? new byte[capacity] : StringUTF16.newBytesFor(capacity);
<span class="line-added"> 146         append(seq);</span>
 147     }
 148 
 149     /**
 150      * Compares the objects of two AbstractStringBuilder implementations lexicographically.
 151      *
 152      * @since 11
 153      */
 154     int compareTo(AbstractStringBuilder another) {
 155         if (this == another) {
 156             return 0;
 157         }
 158 
 159         byte val1[] = value;
 160         byte val2[] = another.value;
 161         int count1 = this.count;
 162         int count2 = another.count;
 163 
 164         if (coder == another.coder) {
 165             return isLatin1() ? StringLatin1.compareTo(val1, val2, count1, count2)
 166                               : StringUTF16.compareTo(val1, val2, count1, count2);
 167         }
 168         return isLatin1() ? StringLatin1.compareToUTF16(val1, val2, count1, count2)
 169                           : StringUTF16.compareToLatin1(val1, val2, count1, count2);
 170     }
 171 
 172     /**
 173      * Returns the length (character count).
 174      *
 175      * @return  the length of the sequence of characters currently
 176      *          represented by this object
 177      */
 178     @Override
 179     public int length() {
 180         return count;
 181     }
 182 
 183     /**
<span class="line-modified"> 184      * Returns the current capacity. The capacity is the number of characters</span>
<span class="line-modified"> 185      * that can be stored (including already written characters), beyond which</span>
<span class="line-modified"> 186      * an allocation will occur.</span>
 187      *
 188      * @return  the current capacity
 189      */
 190     public int capacity() {
 191         return value.length &gt;&gt; coder;
 192     }
 193 
 194     /**
 195      * Ensures that the capacity is at least equal to the specified minimum.
 196      * If the current capacity is less than the argument, then a new internal
 197      * array is allocated with greater capacity. The new capacity is the
 198      * larger of:
 199      * &lt;ul&gt;
 200      * &lt;li&gt;The {@code minimumCapacity} argument.
 201      * &lt;li&gt;Twice the old capacity, plus {@code 2}.
 202      * &lt;/ul&gt;
 203      * If the {@code minimumCapacity} argument is nonpositive, this
 204      * method takes no action and simply returns.
 205      * Note that subsequent operations on this object can reduce the
 206      * actual capacity below that requested here.
</pre>
<hr />
<pre>
 669      * characters as if the s parameter was a sequence containing the four
 670      * characters {@code &quot;null&quot;}.
 671      *
 672      * @param   s the sequence to append.
 673      * @param   start   the starting index of the subsequence to be appended.
 674      * @param   end     the end index of the subsequence to be appended.
 675      * @return  a reference to this object.
 676      * @throws     IndexOutOfBoundsException if
 677      *             {@code start} is negative, or
 678      *             {@code start} is greater than {@code end} or
 679      *             {@code end} is greater than {@code s.length()}
 680      */
 681     @Override
 682     public AbstractStringBuilder append(CharSequence s, int start, int end) {
 683         if (s == null) {
 684             s = &quot;null&quot;;
 685         }
 686         checkRange(start, end, s.length());
 687         int len = end - start;
 688         ensureCapacityInternal(count + len);
<span class="line-modified"> 689         if (s instanceof String) {</span>
<span class="line-added"> 690             appendChars((String)s, start, end);</span>
<span class="line-added"> 691         } else {</span>
<span class="line-added"> 692             appendChars(s, start, end);</span>
<span class="line-added"> 693         }</span>
 694         return this;
 695     }
 696 
<span class="line-added"> 697 </span>
 698     /**
 699      * Appends the string representation of the {@code char} array
 700      * argument to this sequence.
 701      * &lt;p&gt;
 702      * The characters of the array argument are appended, in order, to
 703      * the contents of this sequence. The length of this sequence
 704      * increases by the length of the argument.
 705      * &lt;p&gt;
 706      * The overall effect is exactly as if the argument were converted
 707      * to a string by the method {@link String#valueOf(char[])},
 708      * and the characters of that string were then
 709      * {@link #append(String) appended} to this character sequence.
 710      *
 711      * @param   str   the characters to be appended.
 712      * @return  a reference to this object.
 713      */
 714     public AbstractStringBuilder append(char[] str) {
 715         int len = str.length;
 716         ensureCapacityInternal(count + len);
 717         appendChars(str, 0, len);
</pre>
<hr />
<pre>
1732         if (isLatin1()) {
1733             byte[] val = this.value;
1734             for (int i = off, j = count; i &lt; end; i++) {
1735                 char c = s[i];
1736                 if (StringLatin1.canEncode(c)) {
1737                     val[j++] = (byte)c;
1738                 } else {
1739                     this.count = count = j;
1740                     inflate();
1741                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1742                     this.count = count + end - i;
1743                     return;
1744                 }
1745             }
1746         } else {
1747             StringUTF16.putCharsSB(this.value, count, s, off, end);
1748         }
1749         this.count = count + end - off;
1750     }
1751 
<span class="line-added">1752     private final void appendChars(String s, int off, int end) {</span>
<span class="line-added">1753         if (isLatin1()) {</span>
<span class="line-added">1754             if (s.isLatin1()) {</span>
<span class="line-added">1755                 System.arraycopy(s.value(), off, this.value, this.count, end - off);</span>
<span class="line-added">1756             } else {</span>
<span class="line-added">1757                 // We might need to inflate, but do it as late as possible since</span>
<span class="line-added">1758                 // the range of characters we&#39;re copying might all be latin1</span>
<span class="line-added">1759                 byte[] val = this.value;</span>
<span class="line-added">1760                 for (int i = off, j = count; i &lt; end; i++) {</span>
<span class="line-added">1761                     char c = s.charAt(i);</span>
<span class="line-added">1762                     if (StringLatin1.canEncode(c)) {</span>
<span class="line-added">1763                         val[j++] = (byte) c;</span>
<span class="line-added">1764                     } else {</span>
<span class="line-added">1765                         count = j;</span>
<span class="line-added">1766                         inflate();</span>
<span class="line-added">1767                         System.arraycopy(s.value(), i &lt;&lt; UTF16, this.value, j &lt;&lt; UTF16, (end - i) &lt;&lt; UTF16);</span>
<span class="line-added">1768                         count += end - i;</span>
<span class="line-added">1769                         return;</span>
<span class="line-added">1770                     }</span>
<span class="line-added">1771                 }</span>
<span class="line-added">1772             }</span>
<span class="line-added">1773         } else if (s.isLatin1()) {</span>
<span class="line-added">1774             StringUTF16.putCharsSB(this.value, this.count, s, off, end);</span>
<span class="line-added">1775         } else { // both UTF16</span>
<span class="line-added">1776             System.arraycopy(s.value(), off &lt;&lt; UTF16, this.value, this.count &lt;&lt; UTF16, (end - off) &lt;&lt; UTF16);</span>
<span class="line-added">1777         }</span>
<span class="line-added">1778         count += end - off;</span>
<span class="line-added">1779     }</span>
<span class="line-added">1780 </span>
1781     private final void appendChars(CharSequence s, int off, int end) {
1782         if (isLatin1()) {
1783             byte[] val = this.value;
1784             for (int i = off, j = count; i &lt; end; i++) {
1785                 char c = s.charAt(i);
1786                 if (StringLatin1.canEncode(c)) {
1787                     val[j++] = (byte)c;
1788                 } else {
1789                     count = j;
1790                     inflate();
1791                     StringUTF16.putCharsSB(this.value, j, s, i, end);
1792                     count += end - i;
1793                     return;
1794                 }
1795             }
1796         } else {
1797             StringUTF16.putCharsSB(this.value, count, s, off, end);
1798         }
1799         count += end - off;
1800     }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractMethodError.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArithmeticException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/TreeMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TooManyListenersException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TreeSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/TreeMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 101  * @author  Josh Bloch and Doug Lea
 102  * @see Map
 103  * @see HashMap
 104  * @see Hashtable
 105  * @see Comparable
 106  * @see Comparator
 107  * @see Collection
 108  * @since 1.2
 109  */
 110 
 111 public class TreeMap&lt;K,V&gt;
 112     extends AbstractMap&lt;K,V&gt;
 113     implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
 114 {
 115     /**
 116      * The comparator used to maintain order in this tree map, or
 117      * null if it uses the natural ordering of its keys.
 118      *
 119      * @serial
 120      */

 121     private final Comparator&lt;? super K&gt; comparator;
 122 
 123     private transient Entry&lt;K,V&gt; root;
 124 
 125     /**
 126      * The number of entries in the tree
 127      */
 128     private transient int size = 0;
 129 
 130     /**
 131      * The number of structural modifications to the tree.
 132      */
 133     private transient int modCount = 0;
 134 
 135     /**
 136      * Constructs a new, empty tree map, using the natural ordering of its
 137      * keys.  All keys inserted into the map must implement the {@link
 138      * Comparable} interface.  Furthermore, all such keys must be
 139      * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
 140      * a {@code ClassCastException} for any keys {@code k1} and
</pre>
<hr />
<pre>
 294      */
 295     public K lastKey() {
 296         return key(getLastEntry());
 297     }
 298 
 299     /**
 300      * Copies all of the mappings from the specified map to this map.
 301      * These mappings replace any mappings that this map had for any
 302      * of the keys currently in the specified map.
 303      *
 304      * @param  map mappings to be stored in this map
 305      * @throws ClassCastException if the class of a key or value in
 306      *         the specified map prevents it from being stored in this map
 307      * @throws NullPointerException if the specified map is null or
 308      *         the specified map contains a null key and this map does not
 309      *         permit null keys
 310      */
 311     public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
 312         int mapSize = map.size();
 313         if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {
<span class="line-modified"> 314             Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</span>
<span class="line-removed"> 315             if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) {</span>
 316                 ++modCount;
 317                 try {
 318                     buildFromSorted(mapSize, map.entrySet().iterator(),
 319                                     null, null);
 320                 } catch (java.io.IOException | ClassNotFoundException cannotHappen) {
 321                 }
 322                 return;
 323             }
 324         }
 325         super.putAll(map);
 326     }
 327 
 328     /**
 329      * Returns this map&#39;s entry for the given key, or {@code null} if the map
 330      * does not contain an entry for the key.
 331      *
 332      * @return this map&#39;s entry for the given key, or {@code null} if the map
 333      *         does not contain an entry for the key
 334      * @throws ClassCastException if the specified key cannot be compared
 335      *         with the keys currently in the map
</pre>
<hr />
<pre>
1322     static &lt;K&gt; K key(Entry&lt;K,?&gt; e) {
1323         if (e==null)
1324             throw new NoSuchElementException();
1325         return e.key;
1326     }
1327 
1328 
1329     // SubMaps
1330 
1331     /**
1332      * Dummy value serving as unmatchable fence key for unbounded
1333      * SubMapIterators
1334      */
1335     private static final Object UNBOUNDED = new Object();
1336 
1337     /**
1338      * @serial include
1339      */
1340     abstract static class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
1341         implements NavigableMap&lt;K,V&gt;, java.io.Serializable {

1342         private static final long serialVersionUID = -2102997345730753016L;
1343         /**
1344          * The backing map.
1345          */
1346         final TreeMap&lt;K,V&gt; m;
1347 
1348         /**
1349          * Endpoints are represented as triples (fromStart, lo,
1350          * loInclusive) and (toEnd, hi, hiInclusive). If fromStart is
1351          * true, then the low (absolute) bound is the start of the
1352          * backing map, and the other values are ignored. Otherwise,
1353          * if loInclusive is true, lo is the inclusive bound, else lo
1354          * is the exclusive bound. Similarly for the upper bound.
1355          */
<span class="line-modified">1356         final K lo, hi;</span>



1357         final boolean fromStart, toEnd;
1358         final boolean loInclusive, hiInclusive;
1359 
1360         NavigableSubMap(TreeMap&lt;K,V&gt; m,
1361                         boolean fromStart, K lo, boolean loInclusive,
1362                         boolean toEnd,     K hi, boolean hiInclusive) {
1363             if (!fromStart &amp;&amp; !toEnd) {
1364                 if (m.compare(lo, hi) &gt; 0)
1365                     throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);
1366             } else {
1367                 if (!fromStart) // type check
1368                     m.compare(lo, lo);
1369                 if (!toEnd)
1370                     m.compare(hi, hi);
1371             }
1372 
1373             this.m = m;
1374             this.fromStart = fromStart;
1375             this.lo = lo;
1376             this.loInclusive = loInclusive;
</pre>
<hr />
<pre>
1827             public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
1828                 if (hasNext()) {
1829                     action.accept(next());
1830                     return true;
1831                 }
1832                 return false;
1833             }
1834             public long estimateSize() {
1835                 return Long.MAX_VALUE;
1836             }
1837             public int characteristics() {
1838                 return Spliterator.DISTINCT | Spliterator.ORDERED;
1839             }
1840         }
1841     }
1842 
1843     /**
1844      * @serial include
1845      */
1846     static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; {

1847         private static final long serialVersionUID = 912986545866124060L;
1848 
1849         AscendingSubMap(TreeMap&lt;K,V&gt; m,
1850                         boolean fromStart, K lo, boolean loInclusive,
1851                         boolean toEnd,     K hi, boolean hiInclusive) {
1852             super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
1853         }
1854 
1855         public Comparator&lt;? super K&gt; comparator() {
1856             return m.comparator();
1857         }
1858 
1859         public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
1860                                         K toKey,   boolean toInclusive) {
1861             if (!inRange(fromKey, fromInclusive))
1862                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
1863             if (!inRange(toKey, toInclusive))
1864                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
1865             return new AscendingSubMap&lt;&gt;(m,
1866                                          false, fromKey, fromInclusive,
</pre>
<hr />
<pre>
1910             }
1911         }
1912 
1913         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1914             EntrySetView es = entrySetView;
1915             return (es != null) ? es : (entrySetView = new AscendingEntrySetView());
1916         }
1917 
1918         TreeMap.Entry&lt;K,V&gt; subLowest()       { return absLowest(); }
1919         TreeMap.Entry&lt;K,V&gt; subHighest()      { return absHighest(); }
1920         TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); }
1921         TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absHigher(key); }
1922         TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absFloor(key); }
1923         TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absLower(key); }
1924     }
1925 
1926     /**
1927      * @serial include
1928      */
1929     static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {

1930         private static final long serialVersionUID = 912986545866120460L;
1931         DescendingSubMap(TreeMap&lt;K,V&gt; m,
1932                         boolean fromStart, K lo, boolean loInclusive,
1933                         boolean toEnd,     K hi, boolean hiInclusive) {
1934             super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
1935         }
1936 

1937         private final Comparator&lt;? super K&gt; reverseComparator =
1938             Collections.reverseOrder(m.comparator);
1939 
1940         public Comparator&lt;? super K&gt; comparator() {
1941             return reverseComparator;
1942         }
1943 
1944         public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
1945                                         K toKey,   boolean toInclusive) {
1946             if (!inRange(fromKey, fromInclusive))
1947                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
1948             if (!inRange(toKey, toInclusive))
1949                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
1950             return new DescendingSubMap&lt;&gt;(m,
1951                                           false, toKey,   toInclusive,
1952                                           false, fromKey, fromInclusive);
1953         }
1954 
1955         public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
1956             if (!inRange(toKey, inclusive))
</pre>
<hr />
<pre>
2002 
2003         TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }
2004         TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }
2005         TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }
2006         TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }
2007         TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }
2008         TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }
2009     }
2010 
2011     /**
2012      * This class exists solely for the sake of serialization
2013      * compatibility with previous releases of TreeMap that did not
2014      * support NavigableMap.  It translates an old-version SubMap into
2015      * a new-version AscendingSubMap. This class is never otherwise
2016      * used.
2017      *
2018      * @serial include
2019      */
2020     private class SubMap extends AbstractMap&lt;K,V&gt;
2021         implements SortedMap&lt;K,V&gt;, java.io.Serializable {

2022         private static final long serialVersionUID = -6520786458950516097L;
2023         private boolean fromStart = false, toEnd = false;
<span class="line-modified">2024         private K fromKey, toKey;</span>




2025         private Object readResolve() {
2026             return new AscendingSubMap&lt;&gt;(TreeMap.this,
2027                                          fromStart, fromKey, true,
2028                                          toEnd, toKey, false);
2029         }
2030         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); }
2031         public K lastKey() { throw new InternalError(); }
2032         public K firstKey() { throw new InternalError(); }
2033         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); }
2034         public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); }
2035         public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); }
2036         public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); }
2037     }
2038 
2039 
2040     // Red-black mechanics
2041 
2042     private static final boolean RED   = false;
2043     private static final boolean BLACK = true;
2044 
</pre>
<hr />
<pre>
2389                     x = parentOf(x);
2390                 } else {
2391                     if (colorOf(leftOf(sib)) == BLACK) {
2392                         setColor(rightOf(sib), BLACK);
2393                         setColor(sib, RED);
2394                         rotateLeft(sib);
2395                         sib = leftOf(parentOf(x));
2396                     }
2397                     setColor(sib, colorOf(parentOf(x)));
2398                     setColor(parentOf(x), BLACK);
2399                     setColor(leftOf(sib), BLACK);
2400                     rotateRight(parentOf(x));
2401                     x = root;
2402                 }
2403             }
2404         }
2405 
2406         setColor(x, BLACK);
2407     }
2408 

2409     private static final long serialVersionUID = 919286545866124006L;
2410 
2411     /**
2412      * Save the state of the {@code TreeMap} instance to a stream (i.e.,
2413      * serialize it).
2414      *
2415      * @serialData The &lt;em&gt;size&lt;/em&gt; of the TreeMap (the number of key-value
2416      *             mappings) is emitted (int), followed by the key (Object)
2417      *             and value (Object) for each key-value mapping represented
2418      *             by the TreeMap. The key-value mappings are emitted in
2419      *             key-order (as determined by the TreeMap&#39;s Comparator,
2420      *             or by the keys&#39; natural ordering if the TreeMap has no
2421      *             Comparator).
2422      */

2423     private void writeObject(java.io.ObjectOutputStream s)
2424         throws java.io.IOException {
2425         // Write out the Comparator and any hidden stuff
2426         s.defaultWriteObject();
2427 
2428         // Write out size (number of Mappings)
2429         s.writeInt(size);
2430 
2431         // Write out keys and values (alternating)
2432         for (Map.Entry&lt;K, V&gt; e : entrySet()) {
2433             s.writeObject(e.getKey());
2434             s.writeObject(e.getValue());
2435         }
2436     }
2437 
2438     /**
2439      * Reconstitute the {@code TreeMap} instance from a stream (i.e.,
2440      * deserialize it).
2441      */

2442     private void readObject(final java.io.ObjectInputStream s)
2443         throws java.io.IOException, ClassNotFoundException {
2444         // Read in the Comparator and any hidden stuff
2445         s.defaultReadObject();
2446 
2447         // Read in size
2448         int size = s.readInt();
2449 
2450         buildFromSorted(size, null, s, null);
2451     }
2452 
2453     /** Intended to be called only from TreeSet.readObject */
2454     void readTreeSet(int size, java.io.ObjectInputStream s, V defaultVal)
2455         throws java.io.IOException, ClassNotFoundException {
2456         buildFromSorted(size, null, s, defaultVal);
2457     }
2458 
2459     /** Intended to be called only from TreeSet.addAll */
2460     void addAllForTreeSet(SortedSet&lt;? extends K&gt; set, V defaultVal) {
2461         try {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 101  * @author  Josh Bloch and Doug Lea
 102  * @see Map
 103  * @see HashMap
 104  * @see Hashtable
 105  * @see Comparable
 106  * @see Comparator
 107  * @see Collection
 108  * @since 1.2
 109  */
 110 
 111 public class TreeMap&lt;K,V&gt;
 112     extends AbstractMap&lt;K,V&gt;
 113     implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
 114 {
 115     /**
 116      * The comparator used to maintain order in this tree map, or
 117      * null if it uses the natural ordering of its keys.
 118      *
 119      * @serial
 120      */
<span class="line-added"> 121     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
 122     private final Comparator&lt;? super K&gt; comparator;
 123 
 124     private transient Entry&lt;K,V&gt; root;
 125 
 126     /**
 127      * The number of entries in the tree
 128      */
 129     private transient int size = 0;
 130 
 131     /**
 132      * The number of structural modifications to the tree.
 133      */
 134     private transient int modCount = 0;
 135 
 136     /**
 137      * Constructs a new, empty tree map, using the natural ordering of its
 138      * keys.  All keys inserted into the map must implement the {@link
 139      * Comparable} interface.  Furthermore, all such keys must be
 140      * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
 141      * a {@code ClassCastException} for any keys {@code k1} and
</pre>
<hr />
<pre>
 295      */
 296     public K lastKey() {
 297         return key(getLastEntry());
 298     }
 299 
 300     /**
 301      * Copies all of the mappings from the specified map to this map.
 302      * These mappings replace any mappings that this map had for any
 303      * of the keys currently in the specified map.
 304      *
 305      * @param  map mappings to be stored in this map
 306      * @throws ClassCastException if the class of a key or value in
 307      *         the specified map prevents it from being stored in this map
 308      * @throws NullPointerException if the specified map is null or
 309      *         the specified map contains a null key and this map does not
 310      *         permit null keys
 311      */
 312     public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
 313         int mapSize = map.size();
 314         if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {
<span class="line-modified"> 315             if (Objects.equals(comparator, ((SortedMap&lt;?,?&gt;)map).comparator())) {</span>

 316                 ++modCount;
 317                 try {
 318                     buildFromSorted(mapSize, map.entrySet().iterator(),
 319                                     null, null);
 320                 } catch (java.io.IOException | ClassNotFoundException cannotHappen) {
 321                 }
 322                 return;
 323             }
 324         }
 325         super.putAll(map);
 326     }
 327 
 328     /**
 329      * Returns this map&#39;s entry for the given key, or {@code null} if the map
 330      * does not contain an entry for the key.
 331      *
 332      * @return this map&#39;s entry for the given key, or {@code null} if the map
 333      *         does not contain an entry for the key
 334      * @throws ClassCastException if the specified key cannot be compared
 335      *         with the keys currently in the map
</pre>
<hr />
<pre>
1322     static &lt;K&gt; K key(Entry&lt;K,?&gt; e) {
1323         if (e==null)
1324             throw new NoSuchElementException();
1325         return e.key;
1326     }
1327 
1328 
1329     // SubMaps
1330 
1331     /**
1332      * Dummy value serving as unmatchable fence key for unbounded
1333      * SubMapIterators
1334      */
1335     private static final Object UNBOUNDED = new Object();
1336 
1337     /**
1338      * @serial include
1339      */
1340     abstract static class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
1341         implements NavigableMap&lt;K,V&gt;, java.io.Serializable {
<span class="line-added">1342         @java.io.Serial</span>
1343         private static final long serialVersionUID = -2102997345730753016L;
1344         /**
1345          * The backing map.
1346          */
1347         final TreeMap&lt;K,V&gt; m;
1348 
1349         /**
1350          * Endpoints are represented as triples (fromStart, lo,
1351          * loInclusive) and (toEnd, hi, hiInclusive). If fromStart is
1352          * true, then the low (absolute) bound is the start of the
1353          * backing map, and the other values are ignored. Otherwise,
1354          * if loInclusive is true, lo is the inclusive bound, else lo
1355          * is the exclusive bound. Similarly for the upper bound.
1356          */
<span class="line-modified">1357         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
<span class="line-added">1358         final K lo;</span>
<span class="line-added">1359         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
<span class="line-added">1360         final K hi;</span>
1361         final boolean fromStart, toEnd;
1362         final boolean loInclusive, hiInclusive;
1363 
1364         NavigableSubMap(TreeMap&lt;K,V&gt; m,
1365                         boolean fromStart, K lo, boolean loInclusive,
1366                         boolean toEnd,     K hi, boolean hiInclusive) {
1367             if (!fromStart &amp;&amp; !toEnd) {
1368                 if (m.compare(lo, hi) &gt; 0)
1369                     throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);
1370             } else {
1371                 if (!fromStart) // type check
1372                     m.compare(lo, lo);
1373                 if (!toEnd)
1374                     m.compare(hi, hi);
1375             }
1376 
1377             this.m = m;
1378             this.fromStart = fromStart;
1379             this.lo = lo;
1380             this.loInclusive = loInclusive;
</pre>
<hr />
<pre>
1831             public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
1832                 if (hasNext()) {
1833                     action.accept(next());
1834                     return true;
1835                 }
1836                 return false;
1837             }
1838             public long estimateSize() {
1839                 return Long.MAX_VALUE;
1840             }
1841             public int characteristics() {
1842                 return Spliterator.DISTINCT | Spliterator.ORDERED;
1843             }
1844         }
1845     }
1846 
1847     /**
1848      * @serial include
1849      */
1850     static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; {
<span class="line-added">1851         @java.io.Serial</span>
1852         private static final long serialVersionUID = 912986545866124060L;
1853 
1854         AscendingSubMap(TreeMap&lt;K,V&gt; m,
1855                         boolean fromStart, K lo, boolean loInclusive,
1856                         boolean toEnd,     K hi, boolean hiInclusive) {
1857             super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
1858         }
1859 
1860         public Comparator&lt;? super K&gt; comparator() {
1861             return m.comparator();
1862         }
1863 
1864         public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
1865                                         K toKey,   boolean toInclusive) {
1866             if (!inRange(fromKey, fromInclusive))
1867                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
1868             if (!inRange(toKey, toInclusive))
1869                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
1870             return new AscendingSubMap&lt;&gt;(m,
1871                                          false, fromKey, fromInclusive,
</pre>
<hr />
<pre>
1915             }
1916         }
1917 
1918         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1919             EntrySetView es = entrySetView;
1920             return (es != null) ? es : (entrySetView = new AscendingEntrySetView());
1921         }
1922 
1923         TreeMap.Entry&lt;K,V&gt; subLowest()       { return absLowest(); }
1924         TreeMap.Entry&lt;K,V&gt; subHighest()      { return absHighest(); }
1925         TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); }
1926         TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absHigher(key); }
1927         TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absFloor(key); }
1928         TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absLower(key); }
1929     }
1930 
1931     /**
1932      * @serial include
1933      */
1934     static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {
<span class="line-added">1935         @java.io.Serial</span>
1936         private static final long serialVersionUID = 912986545866120460L;
1937         DescendingSubMap(TreeMap&lt;K,V&gt; m,
1938                         boolean fromStart, K lo, boolean loInclusive,
1939                         boolean toEnd,     K hi, boolean hiInclusive) {
1940             super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
1941         }
1942 
<span class="line-added">1943         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1944         private final Comparator&lt;? super K&gt; reverseComparator =
1945             Collections.reverseOrder(m.comparator);
1946 
1947         public Comparator&lt;? super K&gt; comparator() {
1948             return reverseComparator;
1949         }
1950 
1951         public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
1952                                         K toKey,   boolean toInclusive) {
1953             if (!inRange(fromKey, fromInclusive))
1954                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
1955             if (!inRange(toKey, toInclusive))
1956                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
1957             return new DescendingSubMap&lt;&gt;(m,
1958                                           false, toKey,   toInclusive,
1959                                           false, fromKey, fromInclusive);
1960         }
1961 
1962         public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
1963             if (!inRange(toKey, inclusive))
</pre>
<hr />
<pre>
2009 
2010         TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }
2011         TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }
2012         TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }
2013         TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }
2014         TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }
2015         TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }
2016     }
2017 
2018     /**
2019      * This class exists solely for the sake of serialization
2020      * compatibility with previous releases of TreeMap that did not
2021      * support NavigableMap.  It translates an old-version SubMap into
2022      * a new-version AscendingSubMap. This class is never otherwise
2023      * used.
2024      *
2025      * @serial include
2026      */
2027     private class SubMap extends AbstractMap&lt;K,V&gt;
2028         implements SortedMap&lt;K,V&gt;, java.io.Serializable {
<span class="line-added">2029         @java.io.Serial</span>
2030         private static final long serialVersionUID = -6520786458950516097L;
2031         private boolean fromStart = false, toEnd = false;
<span class="line-modified">2032         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
<span class="line-added">2033         private K fromKey;</span>
<span class="line-added">2034         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
<span class="line-added">2035         private K toKey;</span>
<span class="line-added">2036         @java.io.Serial</span>
2037         private Object readResolve() {
2038             return new AscendingSubMap&lt;&gt;(TreeMap.this,
2039                                          fromStart, fromKey, true,
2040                                          toEnd, toKey, false);
2041         }
2042         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); }
2043         public K lastKey() { throw new InternalError(); }
2044         public K firstKey() { throw new InternalError(); }
2045         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); }
2046         public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); }
2047         public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); }
2048         public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); }
2049     }
2050 
2051 
2052     // Red-black mechanics
2053 
2054     private static final boolean RED   = false;
2055     private static final boolean BLACK = true;
2056 
</pre>
<hr />
<pre>
2401                     x = parentOf(x);
2402                 } else {
2403                     if (colorOf(leftOf(sib)) == BLACK) {
2404                         setColor(rightOf(sib), BLACK);
2405                         setColor(sib, RED);
2406                         rotateLeft(sib);
2407                         sib = leftOf(parentOf(x));
2408                     }
2409                     setColor(sib, colorOf(parentOf(x)));
2410                     setColor(parentOf(x), BLACK);
2411                     setColor(leftOf(sib), BLACK);
2412                     rotateRight(parentOf(x));
2413                     x = root;
2414                 }
2415             }
2416         }
2417 
2418         setColor(x, BLACK);
2419     }
2420 
<span class="line-added">2421     @java.io.Serial</span>
2422     private static final long serialVersionUID = 919286545866124006L;
2423 
2424     /**
2425      * Save the state of the {@code TreeMap} instance to a stream (i.e.,
2426      * serialize it).
2427      *
2428      * @serialData The &lt;em&gt;size&lt;/em&gt; of the TreeMap (the number of key-value
2429      *             mappings) is emitted (int), followed by the key (Object)
2430      *             and value (Object) for each key-value mapping represented
2431      *             by the TreeMap. The key-value mappings are emitted in
2432      *             key-order (as determined by the TreeMap&#39;s Comparator,
2433      *             or by the keys&#39; natural ordering if the TreeMap has no
2434      *             Comparator).
2435      */
<span class="line-added">2436     @java.io.Serial</span>
2437     private void writeObject(java.io.ObjectOutputStream s)
2438         throws java.io.IOException {
2439         // Write out the Comparator and any hidden stuff
2440         s.defaultWriteObject();
2441 
2442         // Write out size (number of Mappings)
2443         s.writeInt(size);
2444 
2445         // Write out keys and values (alternating)
2446         for (Map.Entry&lt;K, V&gt; e : entrySet()) {
2447             s.writeObject(e.getKey());
2448             s.writeObject(e.getValue());
2449         }
2450     }
2451 
2452     /**
2453      * Reconstitute the {@code TreeMap} instance from a stream (i.e.,
2454      * deserialize it).
2455      */
<span class="line-added">2456     @java.io.Serial</span>
2457     private void readObject(final java.io.ObjectInputStream s)
2458         throws java.io.IOException, ClassNotFoundException {
2459         // Read in the Comparator and any hidden stuff
2460         s.defaultReadObject();
2461 
2462         // Read in size
2463         int size = s.readInt();
2464 
2465         buildFromSorted(size, null, s, null);
2466     }
2467 
2468     /** Intended to be called only from TreeSet.readObject */
2469     void readTreeSet(int size, java.io.ObjectInputStream s, V defaultVal)
2470         throws java.io.IOException, ClassNotFoundException {
2471         buildFromSorted(size, null, s, defaultVal);
2472     }
2473 
2474     /** Intended to be called only from TreeSet.addAll */
2475     void addAllForTreeSet(SortedSet&lt;? extends K&gt; set, V defaultVal) {
2476         try {
</pre>
</td>
</tr>
</table>
<center><a href="TooManyListenersException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TreeSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/security/Identity.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 
 28 import java.io.Serializable;
 29 import java.util.*;
 30 
 31 /**
 32  * &lt;p&gt;This class represents identities: real-world objects such as people,
 33  * companies or organizations whose identities can be authenticated using
 34  * their public keys. Identities may also be more abstract (or concrete)
 35  * constructs, such as daemon threads or smart cards.
 36  *
 37  * &lt;p&gt;All Identity objects have a name and a public key. Names are
 38  * immutable. Identities may also be scoped. That is, if an Identity is
 39  * specified to have a particular scope, then the name and public
 40  * key of the Identity are unique within that scope.
 41  *
 42  * &lt;p&gt;An Identity also has a set of certificates (all certifying its own
 43  * public key). The Principal names specified in these certificates need
 44  * not be the same, only the key.
 45  *
 46  * &lt;p&gt;An Identity can be subclassed, to include postal and email addresses,
 47  * telephone numbers, images of faces and logos, and so on.
 48  *
 49  * @see IdentityScope
 50  * @see Signer
 51  * @see Principal
 52  *
 53  * @author Benjamin Renaud
 54  * @since 1.1
 55  * @deprecated This class is deprecated and subject to removal in a future
 56  *     version of Java SE. It has been replaced by
 57  *     {@code java.security.KeyStore}, the {@code java.security.cert} package,
 58  *     and {@code java.security.Principal}.
 59  */
 60 @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
 61 @SuppressWarnings(&quot;removal&quot;)
 62 public abstract class Identity implements Principal, Serializable {
 63 
 64     /** use serialVersionUID from JDK 1.1.x for interoperability */
 65     private static final long serialVersionUID = 3609922007826600659L;
 66 
 67     /**
 68      * The name for this identity.
 69      *
 70      * @serial
 71      */
 72     private String name;
 73 
 74     /**
 75      * The public key for this identity.
 76      *
 77      * @serial
 78      */
 79     private PublicKey publicKey;
 80 
 81     /**
 82      * Generic, descriptive information about the identity.
 83      *
 84      * @serial
 85      */
 86     String info = &quot;No further information available.&quot;;
 87 
 88     /**
 89      * The scope of the identity.
 90      *
 91      * @serial
 92      */
 93     IdentityScope scope;
 94 
 95     /**
 96      * The certificates for this identity.
 97      *
 98      * @serial
 99      */
100     Vector&lt;Certificate&gt; certificates;
101 
102     /**
103      * Constructor for serialization only.
104      */
105     protected Identity() {
106         this(&quot;restoring...&quot;);
107     }
108 
109     /**
110      * Constructs an identity with the specified name and scope.
111      *
112      * @param name the identity name.
113      * @param scope the scope of the identity.
114      *
115      * @exception KeyManagementException if there is already an identity
116      * with the same name in the scope.
117      */
118     public Identity(String name, IdentityScope scope) throws
119     KeyManagementException {
120         this(name);
121         if (scope != null) {
122             scope.addIdentity(this);
123         }
124         this.scope = scope;
125     }
126 
127     /**
128      * Constructs an identity with the specified name and no scope.
129      *
130      * @param name the identity name.
131      */
132     public Identity(String name) {
133         this.name = name;
134     }
135 
136     /**
137      * Returns this identity&#39;s name.
138      *
139      * @return the name of this identity.
140      */
141     public final String getName() {
142         return name;
143     }
144 
145     /**
146      * Returns this identity&#39;s scope.
147      *
148      * @return the scope of this identity.
149      */
150     public final IdentityScope getScope() {
151         return scope;
152     }
153 
154     /**
155      * Returns this identity&#39;s public key.
156      *
157      * @return the public key for this identity.
158      *
159      * @see #setPublicKey
160      */
161     public PublicKey getPublicKey() {
162         return publicKey;
163     }
164 
165     /**
166      * Sets this identity&#39;s public key. The old key and all of this
167      * identity&#39;s certificates are removed by this operation.
168      *
169      * &lt;p&gt;First, if there is a security manager, its {@code checkSecurityAccess}
170      * method is called with {@code &quot;setIdentityPublicKey&quot;}
171      * as its argument to see if it&#39;s ok to set the public key.
172      *
173      * @param key the public key for this identity.
174      *
175      * @exception KeyManagementException if another identity in the
176      * identity&#39;s scope has the same public key, or if another exception occurs.
177      *
178      * @exception  SecurityException  if a security manager exists and its
179      * {@code checkSecurityAccess} method doesn&#39;t allow
180      * setting the public key.
181      *
182      * @see #getPublicKey
183      * @see SecurityManager#checkSecurityAccess
184      */
185     /* Should we throw an exception if this is already set? */
186     public void setPublicKey(PublicKey key) throws KeyManagementException {
187 
188         check(&quot;setIdentityPublicKey&quot;);
189         this.publicKey = key;
190         certificates = new Vector&lt;&gt;();
191     }
192 
193     /**
194      * Specifies a general information string for this identity.
195      *
196      * &lt;p&gt;First, if there is a security manager, its {@code checkSecurityAccess}
197      * method is called with {@code &quot;setIdentityInfo&quot;}
198      * as its argument to see if it&#39;s ok to specify the information string.
199      *
200      * @param info the information string.
201      *
202      * @exception  SecurityException  if a security manager exists and its
203      * {@code checkSecurityAccess} method doesn&#39;t allow
204      * setting the information string.
205      *
206      * @see #getInfo
207      * @see SecurityManager#checkSecurityAccess
208      */
209     public void setInfo(String info) {
210         check(&quot;setIdentityInfo&quot;);
211         this.info = info;
212     }
213 
214     /**
215      * Returns general information previously specified for this identity.
216      *
217      * @return general information about this identity.
218      *
219      * @see #setInfo
220      */
221     public String getInfo() {
222         return info;
223     }
224 
225     /**
226      * Adds a certificate for this identity. If the identity has a public
227      * key, the public key in the certificate must be the same, and if
228      * the identity does not have a public key, the identity&#39;s
229      * public key is set to be that specified in the certificate.
230      *
231      * &lt;p&gt;First, if there is a security manager, its {@code checkSecurityAccess}
232      * method is called with {@code &quot;addIdentityCertificate&quot;}
233      * as its argument to see if it&#39;s ok to add a certificate.
234      *
235      * @param certificate the certificate to be added.
236      *
237      * @exception KeyManagementException if the certificate is not valid,
238      * if the public key in the certificate being added conflicts with
239      * this identity&#39;s public key, or if another exception occurs.
240      *
241      * @exception  SecurityException  if a security manager exists and its
242      * {@code checkSecurityAccess} method doesn&#39;t allow
243      * adding a certificate.
244      *
245      * @see SecurityManager#checkSecurityAccess
246      */
247     public void addCertificate(Certificate certificate)
248     throws KeyManagementException {
249 
250         check(&quot;addIdentityCertificate&quot;);
251 
252         if (certificates == null) {
253             certificates = new Vector&lt;&gt;();
254         }
255         if (publicKey != null) {
256             if (!keyEquals(publicKey, certificate.getPublicKey())) {
257                 throw new KeyManagementException(
258                     &quot;public key different from cert public key&quot;);
259             }
260         } else {
261             publicKey = certificate.getPublicKey();
262         }
263         certificates.addElement(certificate);
264     }
265 
266     private boolean keyEquals(PublicKey aKey, PublicKey anotherKey) {
267         String aKeyFormat = aKey.getFormat();
268         String anotherKeyFormat = anotherKey.getFormat();
269         if ((aKeyFormat == null) ^ (anotherKeyFormat == null))
270             return false;
271         if (aKeyFormat != null &amp;&amp; anotherKeyFormat != null)
272             if (!aKeyFormat.equalsIgnoreCase(anotherKeyFormat))
273                 return false;
274         return java.util.Arrays.equals(aKey.getEncoded(),
275                                      anotherKey.getEncoded());
276     }
277 
278 
279     /**
280      * Removes a certificate from this identity.
281      *
282      * &lt;p&gt;First, if there is a security manager, its {@code checkSecurityAccess}
283      * method is called with {@code &quot;removeIdentityCertificate&quot;}
284      * as its argument to see if it&#39;s ok to remove a certificate.
285      *
286      * @param certificate the certificate to be removed.
287      *
288      * @exception KeyManagementException if the certificate is
289      * missing, or if another exception occurs.
290      *
291      * @exception  SecurityException  if a security manager exists and its
292      * {@code checkSecurityAccess} method doesn&#39;t allow
293      * removing a certificate.
294      *
295      * @see SecurityManager#checkSecurityAccess
296      */
297     public void removeCertificate(Certificate certificate)
298     throws KeyManagementException {
299         check(&quot;removeIdentityCertificate&quot;);
300         if (certificates != null) {
301             certificates.removeElement(certificate);
302         }
303     }
304 
305     /**
306      * Returns a copy of all the certificates for this identity.
307      *
308      * @return a copy of all the certificates for this identity.
309      */
310     public Certificate[] certificates() {
311         if (certificates == null) {
312             return new Certificate[0];
313         }
314         int len = certificates.size();
315         Certificate[] certs = new Certificate[len];
316         certificates.copyInto(certs);
317         return certs;
318     }
319 
320     /**
321      * Tests for equality between the specified object and this identity.
322      * This first tests to see if the entities actually refer to the same
323      * object, in which case it returns true. Next, it checks to see if
324      * the entities have the same name and the same scope. If they do,
325      * the method returns true. Otherwise, it calls
326      * {@link #identityEquals(Identity) identityEquals}, which subclasses should
327      * override.
328      *
329      * @param identity the object to test for equality with this identity.
330      *
331      * @return true if the objects are considered equal, false otherwise.
332      *
333      * @see #identityEquals
334      */
335     public final boolean equals(Object identity) {
336 
337         if (identity == this) {
338             return true;
339         }
340 
341         if (identity instanceof Identity) {
342             Identity i = (Identity)identity;
343             if (this.fullName().equals(i.fullName())) {
344                 return true;
345             } else {
346                 return identityEquals(i);
347             }
348         }
349         return false;
350     }
351 
352     /**
353      * Tests for equality between the specified identity and this identity.
354      * This method should be overridden by subclasses to test for equality.
355      * The default behavior is to return true if the names and public keys
356      * are equal.
357      *
358      * @param identity the identity to test for equality with this identity.
359      *
360      * @return true if the identities are considered equal, false
361      * otherwise.
362      *
363      * @see #equals
364      */
365     protected boolean identityEquals(Identity identity) {
366         if (!name.equalsIgnoreCase(identity.name))
367             return false;
368 
369         if ((publicKey == null) ^ (identity.publicKey == null))
370             return false;
371 
372         if (publicKey != null &amp;&amp; identity.publicKey != null)
373             if (!publicKey.equals(identity.publicKey))
374                 return false;
375 
376         return true;
377 
378     }
379 
380     /**
381      * Returns a parsable name for identity: identityName.scopeName
382      */
383     String fullName() {
384         String parsable = name;
385         if (scope != null) {
386             parsable += &quot;.&quot; + scope.getName();
387         }
388         return parsable;
389     }
390 
391     /**
392      * Returns a short string describing this identity, telling its
393      * name and its scope (if any).
394      *
395      * &lt;p&gt;First, if there is a security manager, its {@code checkSecurityAccess}
396      * method is called with {@code &quot;printIdentity&quot;}
397      * as its argument to see if it&#39;s ok to return the string.
398      *
399      * @return information about this identity, such as its name and the
400      * name of its scope (if any).
401      *
402      * @exception  SecurityException  if a security manager exists and its
403      * {@code checkSecurityAccess} method doesn&#39;t allow
404      * returning a string describing this identity.
405      *
406      * @see SecurityManager#checkSecurityAccess
407      */
408     public String toString() {
409         check(&quot;printIdentity&quot;);
410         String printable = name;
411         if (scope != null) {
412             printable += &quot;[&quot; + scope.getName() + &quot;]&quot;;
413         }
414         return printable;
415     }
416 
417     /**
418      * Returns a string representation of this identity, with
419      * optionally more details than that provided by the
420      * {@code toString} method without any arguments.
421      *
422      * &lt;p&gt;First, if there is a security manager, its {@code checkSecurityAccess}
423      * method is called with {@code &quot;printIdentity&quot;}
424      * as its argument to see if it&#39;s ok to return the string.
425      *
426      * @param detailed whether or not to provide detailed information.
427      *
428      * @return information about this identity. If {@code detailed}
429      * is true, then this method returns more information than that
430      * provided by the {@code toString} method without any arguments.
431      *
432      * @exception  SecurityException  if a security manager exists and its
433      * {@code checkSecurityAccess} method doesn&#39;t allow
434      * returning a string describing this identity.
435      *
436      * @see #toString
437      * @see SecurityManager#checkSecurityAccess
438      */
439     public String toString(boolean detailed) {
440         String out = toString();
441         if (detailed) {
442             out += &quot;\n&quot;;
443             out += printKeys();
444             out += &quot;\n&quot; + printCertificates();
445             if (info != null) {
446                 out += &quot;\n\t&quot; + info;
447             } else {
448                 out += &quot;\n\tno additional information available.&quot;;
449             }
450         }
451         return out;
452     }
453 
454     String printKeys() {
455         String key = &quot;&quot;;
456         if (publicKey != null) {
457             key = &quot;\tpublic key initialized&quot;;
458         } else {
459             key = &quot;\tno public key&quot;;
460         }
461         return key;
462     }
463 
464     String printCertificates() {
465         String out = &quot;&quot;;
466         if (certificates == null) {
467             return &quot;\tno certificates&quot;;
468         } else {
469             out += &quot;\tcertificates: \n&quot;;
470 
471             int i = 1;
472             for (Certificate cert : certificates) {
473                 out += &quot;\tcertificate &quot; + i++ +
474                     &quot;\tfor  : &quot; + cert.getPrincipal() + &quot;\n&quot;;
475                 out += &quot;\t\t\tfrom : &quot; +
476                     cert.getGuarantor() + &quot;\n&quot;;
477             }
478         }
479         return out;
480     }
481 
482     /**
483      * Returns a hashcode for this identity.
484      *
485      * @return a hashcode for this identity.
486      */
487     public int hashCode() {
488         return name.hashCode();
489     }
490 
491     private static void check(String directive) {
492         SecurityManager security = System.getSecurityManager();
493         if (security != null) {
494             security.checkSecurityAccess(directive);
495         }
496     }
497 }
    </pre>
  </body>
</html>
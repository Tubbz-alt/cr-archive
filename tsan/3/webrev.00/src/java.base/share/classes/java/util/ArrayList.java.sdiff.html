<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/ArrayList.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayDeque.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayPrefixHelpers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ArrayList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.util.function.Consumer;
  29 import java.util.function.Predicate;
  30 import java.util.function.UnaryOperator;
  31 import jdk.internal.access.SharedSecrets;

  32 
  33 /**
  34  * Resizable-array implementation of the {@code List} interface.  Implements
  35  * all optional list operations, and permits all elements, including
  36  * {@code null}.  In addition to implementing the {@code List} interface,
  37  * this class provides methods to manipulate the size of the array that is
  38  * used internally to store the list.  (This class is roughly equivalent to
  39  * {@code Vector}, except that it is unsynchronized.)
  40  *
  41  * &lt;p&gt;The {@code size}, {@code isEmpty}, {@code get}, {@code set},
  42  * {@code iterator}, and {@code listIterator} operations run in constant
  43  * time.  The {@code add} operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,
  44  * that is, adding n elements requires O(n) time.  All of the other operations
  45  * run in linear time (roughly speaking).  The constant factor is low compared
  46  * to that for the {@code LinkedList} implementation.
  47  *
  48  * &lt;p&gt;Each {@code ArrayList} instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is
  49  * the size of the array used to store the elements in the list.  It is always
  50  * at least as large as the list size.  As elements are added to an ArrayList,
  51  * its capacity grows automatically.  The details of the growth policy are not
</pre>
<hr />
<pre>
  91  * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
  92  * should be used only to detect bugs.&lt;/i&gt;
  93  *
  94  * &lt;p&gt;This class is a member of the
  95  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
  96  * Java Collections Framework&lt;/a&gt;.
  97  *
  98  * @param &lt;E&gt; the type of elements in this list
  99  *
 100  * @author  Josh Bloch
 101  * @author  Neal Gafter
 102  * @see     Collection
 103  * @see     List
 104  * @see     LinkedList
 105  * @see     Vector
 106  * @since   1.2
 107  */
 108 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
 109         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
 110 {

 111     private static final long serialVersionUID = 8683452581122892189L;
 112 
 113     /**
 114      * Default initial capacity.
 115      */
 116     private static final int DEFAULT_CAPACITY = 10;
 117 
 118     /**
 119      * Shared empty array instance used for empty instances.
 120      */
 121     private static final Object[] EMPTY_ELEMENTDATA = {};
 122 
 123     /**
 124      * Shared empty array instance used for default sized empty instances. We
 125      * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
 126      * first element is added.
 127      */
 128     private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
 129 
 130     /**
</pre>
<hr />
<pre>
 201               : Arrays.copyOf(elementData, size);
 202         }
 203     }
 204 
 205     /**
 206      * Increases the capacity of this {@code ArrayList} instance, if
 207      * necessary, to ensure that it can hold at least the number of elements
 208      * specified by the minimum capacity argument.
 209      *
 210      * @param minCapacity the desired minimum capacity
 211      */
 212     public void ensureCapacity(int minCapacity) {
 213         if (minCapacity &gt; elementData.length
 214             &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 215                  &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
 216             modCount++;
 217             grow(minCapacity);
 218         }
 219     }
 220 
<span class="line-removed"> 221     /**</span>
<span class="line-removed"> 222      * The maximum size of array to allocate (unless necessary).</span>
<span class="line-removed"> 223      * Some VMs reserve some header words in an array.</span>
<span class="line-removed"> 224      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed"> 225      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed"> 226      */</span>
<span class="line-removed"> 227     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed"> 228 </span>
 229     /**
 230      * Increases the capacity to ensure that it can hold at least the
 231      * number of elements specified by the minimum capacity argument.
 232      *
 233      * @param minCapacity the desired minimum capacity
 234      * @throws OutOfMemoryError if minCapacity is less than zero
 235      */
 236     private Object[] grow(int minCapacity) {
<span class="line-removed"> 237         return elementData = Arrays.copyOf(elementData,</span>
<span class="line-removed"> 238                                            newCapacity(minCapacity));</span>
<span class="line-removed"> 239     }</span>
<span class="line-removed"> 240 </span>
<span class="line-removed"> 241     private Object[] grow() {</span>
<span class="line-removed"> 242         return grow(size + 1);</span>
<span class="line-removed"> 243     }</span>
<span class="line-removed"> 244 </span>
<span class="line-removed"> 245     /**</span>
<span class="line-removed"> 246      * Returns a capacity at least as large as the given minimum capacity.</span>
<span class="line-removed"> 247      * Returns the current capacity increased by 50% if that suffices.</span>
<span class="line-removed"> 248      * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span>
<span class="line-removed"> 249      * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span>
<span class="line-removed"> 250      *</span>
<span class="line-removed"> 251      * @param minCapacity the desired minimum capacity</span>
<span class="line-removed"> 252      * @throws OutOfMemoryError if minCapacity is less than zero</span>
<span class="line-removed"> 253      */</span>
<span class="line-removed"> 254     private int newCapacity(int minCapacity) {</span>
<span class="line-removed"> 255         // overflow-conscious code</span>
 256         int oldCapacity = elementData.length;
<span class="line-modified"> 257         int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span>
<span class="line-modified"> 258         if (newCapacity - minCapacity &lt;= 0) {</span>
<span class="line-modified"> 259             if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span>
<span class="line-modified"> 260                 return Math.max(DEFAULT_CAPACITY, minCapacity);</span>
<span class="line-modified"> 261             if (minCapacity &lt; 0) // overflow</span>
<span class="line-modified"> 262                 throw new OutOfMemoryError();</span>
<span class="line-modified"> 263             return minCapacity;</span>
 264         }
<span class="line-removed"> 265         return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)</span>
<span class="line-removed"> 266             ? newCapacity</span>
<span class="line-removed"> 267             : hugeCapacity(minCapacity);</span>
 268     }
 269 
<span class="line-modified"> 270     private static int hugeCapacity(int minCapacity) {</span>
<span class="line-modified"> 271         if (minCapacity &lt; 0) // overflow</span>
<span class="line-removed"> 272             throw new OutOfMemoryError();</span>
<span class="line-removed"> 273         return (minCapacity &gt; MAX_ARRAY_SIZE)</span>
<span class="line-removed"> 274             ? Integer.MAX_VALUE</span>
<span class="line-removed"> 275             : MAX_ARRAY_SIZE;</span>
 276     }
 277 
 278     /**
 279      * Returns the number of elements in this list.
 280      *
 281      * @return the number of elements in this list
 282      */
 283     public int size() {
 284         return size;
 285     }
 286 
 287     /**
 288      * Returns {@code true} if this list contains no elements.
 289      *
 290      * @return {@code true} if this list contains no elements
 291      */
 292     public boolean isEmpty() {
 293         return size == 0;
 294     }
 295 
</pre>
<hr />
<pre>
 865             System.arraycopy(es, r, es, w, end - r);
 866             w += end - r;
 867             throw ex;
 868         } finally {
 869             modCount += end - w;
 870             shiftTailOverGap(es, w, end);
 871         }
 872         return true;
 873     }
 874 
 875     /**
 876      * Saves the state of the {@code ArrayList} instance to a stream
 877      * (that is, serializes it).
 878      *
 879      * @param s the stream
 880      * @throws java.io.IOException if an I/O error occurs
 881      * @serialData The length of the array backing the {@code ArrayList}
 882      *             instance is emitted (int), followed by all of its elements
 883      *             (each an {@code Object}) in the proper order.
 884      */

 885     private void writeObject(java.io.ObjectOutputStream s)
 886         throws java.io.IOException {
 887         // Write out element count, and any hidden stuff
 888         int expectedModCount = modCount;
 889         s.defaultWriteObject();
 890 
 891         // Write out size as capacity for behavioral compatibility with clone()
 892         s.writeInt(size);
 893 
 894         // Write out all elements in the proper order.
 895         for (int i=0; i&lt;size; i++) {
 896             s.writeObject(elementData[i]);
 897         }
 898 
 899         if (modCount != expectedModCount) {
 900             throw new ConcurrentModificationException();
 901         }
 902     }
 903 
 904     /**
 905      * Reconstitutes the {@code ArrayList} instance from a stream (that is,
 906      * deserializes it).
 907      * @param s the stream
 908      * @throws ClassNotFoundException if the class of a serialized object
 909      *         could not be found
 910      * @throws java.io.IOException if an I/O error occurs
 911      */

 912     private void readObject(java.io.ObjectInputStream s)
 913         throws java.io.IOException, ClassNotFoundException {
 914 
 915         // Read in size, and any hidden stuff
 916         s.defaultReadObject();
 917 
 918         // Read in capacity
 919         s.readInt(); // ignored
 920 
 921         if (size &gt; 0) {
 922             // like clone(), allocate array based upon size not capacity
 923             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
 924             Object[] elements = new Object[size];
 925 
 926             // Read in all elements in the proper order.
 927             for (int i = 0; i &lt; size; i++) {
 928                 elements[i] = s.readObject();
 929             }
 930 
 931             elementData = elements;
</pre>
<hr />
<pre>
1146 
1147         /**
1148          * Constructs a sublist of an arbitrary ArrayList.
1149          */
1150         public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) {
1151             this.root = root;
1152             this.parent = null;
1153             this.offset = fromIndex;
1154             this.size = toIndex - fromIndex;
1155             this.modCount = root.modCount;
1156         }
1157 
1158         /**
1159          * Constructs a sublist of another SubList.
1160          */
1161         private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
1162             this.root = parent.root;
1163             this.parent = parent;
1164             this.offset = parent.offset + fromIndex;
1165             this.size = toIndex - fromIndex;
<span class="line-modified">1166             this.modCount = root.modCount;</span>
1167         }
1168 
1169         public E set(int index, E element) {
1170             Objects.checkIndex(index, size);
1171             checkForComodification();
1172             E oldValue = root.elementData(offset + index);
1173             root.elementData[offset + index] = element;
1174             return oldValue;
1175         }
1176 
1177         public E get(int index) {
1178             Objects.checkIndex(index, size);
1179             checkForComodification();
1180             return root.elementData(offset + index);
1181         }
1182 
1183         public int size() {
1184             checkForComodification();
1185             return size;
1186         }
</pre>
<hr />
<pre>
1299             int index = root.lastIndexOfRange(o, offset, offset + size);
1300             checkForComodification();
1301             return index &gt;= 0 ? index - offset : -1;
1302         }
1303 
1304         public boolean contains(Object o) {
1305             return indexOf(o) &gt;= 0;
1306         }
1307 
1308         public Iterator&lt;E&gt; iterator() {
1309             return listIterator();
1310         }
1311 
1312         public ListIterator&lt;E&gt; listIterator(int index) {
1313             checkForComodification();
1314             rangeCheckForAdd(index);
1315 
1316             return new ListIterator&lt;E&gt;() {
1317                 int cursor = index;
1318                 int lastRet = -1;
<span class="line-modified">1319                 int expectedModCount = root.modCount;</span>
1320 
1321                 public boolean hasNext() {
1322                     return cursor != SubList.this.size;
1323                 }
1324 
1325                 @SuppressWarnings(&quot;unchecked&quot;)
1326                 public E next() {
1327                     checkForComodification();
1328                     int i = cursor;
1329                     if (i &gt;= SubList.this.size)
1330                         throw new NoSuchElementException();
1331                     Object[] elementData = root.elementData;
1332                     if (offset + i &gt;= elementData.length)
1333                         throw new ConcurrentModificationException();
1334                     cursor = i + 1;
1335                     return (E) elementData[offset + (lastRet = i)];
1336                 }
1337 
1338                 public boolean hasPrevious() {
1339                     return cursor != 0;
</pre>
<hr />
<pre>
1343                 public E previous() {
1344                     checkForComodification();
1345                     int i = cursor - 1;
1346                     if (i &lt; 0)
1347                         throw new NoSuchElementException();
1348                     Object[] elementData = root.elementData;
1349                     if (offset + i &gt;= elementData.length)
1350                         throw new ConcurrentModificationException();
1351                     cursor = i;
1352                     return (E) elementData[offset + (lastRet = i)];
1353                 }
1354 
1355                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1356                     Objects.requireNonNull(action);
1357                     final int size = SubList.this.size;
1358                     int i = cursor;
1359                     if (i &lt; size) {
1360                         final Object[] es = root.elementData;
1361                         if (offset + i &gt;= es.length)
1362                             throw new ConcurrentModificationException();
<span class="line-modified">1363                         for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)</span>
1364                             action.accept(elementAt(es, offset + i));
1365                         // update once at end to reduce heap write traffic
1366                         cursor = i;
1367                         lastRet = i - 1;
1368                         checkForComodification();
1369                     }
1370                 }
1371 
1372                 public int nextIndex() {
1373                     return cursor;
1374                 }
1375 
1376                 public int previousIndex() {
1377                     return cursor - 1;
1378                 }
1379 
1380                 public void remove() {
1381                     if (lastRet &lt; 0)
1382                         throw new IllegalStateException();
1383                     checkForComodification();
1384 
1385                     try {
1386                         SubList.this.remove(lastRet);
1387                         cursor = lastRet;
1388                         lastRet = -1;
<span class="line-modified">1389                         expectedModCount = root.modCount;</span>
1390                     } catch (IndexOutOfBoundsException ex) {
1391                         throw new ConcurrentModificationException();
1392                     }
1393                 }
1394 
1395                 public void set(E e) {
1396                     if (lastRet &lt; 0)
1397                         throw new IllegalStateException();
1398                     checkForComodification();
1399 
1400                     try {
1401                         root.set(offset + lastRet, e);
1402                     } catch (IndexOutOfBoundsException ex) {
1403                         throw new ConcurrentModificationException();
1404                     }
1405                 }
1406 
1407                 public void add(E e) {
1408                     checkForComodification();
1409 
1410                     try {
1411                         int i = cursor;
1412                         SubList.this.add(i, e);
1413                         cursor = i + 1;
1414                         lastRet = -1;
<span class="line-modified">1415                         expectedModCount = root.modCount;</span>
1416                     } catch (IndexOutOfBoundsException ex) {
1417                         throw new ConcurrentModificationException();
1418                     }
1419                 }
1420 
1421                 final void checkForComodification() {
1422                     if (root.modCount != expectedModCount)
1423                         throw new ConcurrentModificationException();
1424                 }
1425             };
1426         }
1427 
1428         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1429             subListRangeCheck(fromIndex, toIndex, size);
1430             return new SubList&lt;&gt;(this, fromIndex, toIndex);
1431         }
1432 
1433         private void rangeCheckForAdd(int index) {
1434             if (index &lt; 0 || index &gt; this.size)
1435                 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
</pre>
<hr />
<pre>
1712                     setBit(deathRow, i - beg);
1713             if (modCount != expectedModCount)
1714                 throw new ConcurrentModificationException();
1715             modCount++;
1716             int w = beg;
1717             for (i = beg; i &lt; end; i++)
1718                 if (isClear(deathRow, i - beg))
1719                     es[w++] = es[i];
1720             shiftTailOverGap(es, w, end);
1721             return true;
1722         } else {
1723             if (modCount != expectedModCount)
1724                 throw new ConcurrentModificationException();
1725             return false;
1726         }
1727     }
1728 
1729     @Override
1730     public void replaceAll(UnaryOperator&lt;E&gt; operator) {
1731         replaceAllRange(operator, 0, size);

1732         modCount++;
1733     }
1734 
1735     private void replaceAllRange(UnaryOperator&lt;E&gt; operator, int i, int end) {
1736         Objects.requireNonNull(operator);
1737         final int expectedModCount = modCount;
1738         final Object[] es = elementData;
1739         for (; modCount == expectedModCount &amp;&amp; i &lt; end; i++)
1740             es[i] = operator.apply(elementAt(es, i));
1741         if (modCount != expectedModCount)
1742             throw new ConcurrentModificationException();
1743     }
1744 
1745     @Override
1746     @SuppressWarnings(&quot;unchecked&quot;)
1747     public void sort(Comparator&lt;? super E&gt; c) {
1748         final int expectedModCount = modCount;
1749         Arrays.sort((E[]) elementData, 0, size, c);
1750         if (modCount != expectedModCount)
1751             throw new ConcurrentModificationException();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.util.function.Consumer;
  29 import java.util.function.Predicate;
  30 import java.util.function.UnaryOperator;
  31 import jdk.internal.access.SharedSecrets;
<span class="line-added">  32 import jdk.internal.util.ArraysSupport;</span>
  33 
  34 /**
  35  * Resizable-array implementation of the {@code List} interface.  Implements
  36  * all optional list operations, and permits all elements, including
  37  * {@code null}.  In addition to implementing the {@code List} interface,
  38  * this class provides methods to manipulate the size of the array that is
  39  * used internally to store the list.  (This class is roughly equivalent to
  40  * {@code Vector}, except that it is unsynchronized.)
  41  *
  42  * &lt;p&gt;The {@code size}, {@code isEmpty}, {@code get}, {@code set},
  43  * {@code iterator}, and {@code listIterator} operations run in constant
  44  * time.  The {@code add} operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,
  45  * that is, adding n elements requires O(n) time.  All of the other operations
  46  * run in linear time (roughly speaking).  The constant factor is low compared
  47  * to that for the {@code LinkedList} implementation.
  48  *
  49  * &lt;p&gt;Each {@code ArrayList} instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is
  50  * the size of the array used to store the elements in the list.  It is always
  51  * at least as large as the list size.  As elements are added to an ArrayList,
  52  * its capacity grows automatically.  The details of the growth policy are not
</pre>
<hr />
<pre>
  92  * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
  93  * should be used only to detect bugs.&lt;/i&gt;
  94  *
  95  * &lt;p&gt;This class is a member of the
  96  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
  97  * Java Collections Framework&lt;/a&gt;.
  98  *
  99  * @param &lt;E&gt; the type of elements in this list
 100  *
 101  * @author  Josh Bloch
 102  * @author  Neal Gafter
 103  * @see     Collection
 104  * @see     List
 105  * @see     LinkedList
 106  * @see     Vector
 107  * @since   1.2
 108  */
 109 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
 110         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
 111 {
<span class="line-added"> 112     @java.io.Serial</span>
 113     private static final long serialVersionUID = 8683452581122892189L;
 114 
 115     /**
 116      * Default initial capacity.
 117      */
 118     private static final int DEFAULT_CAPACITY = 10;
 119 
 120     /**
 121      * Shared empty array instance used for empty instances.
 122      */
 123     private static final Object[] EMPTY_ELEMENTDATA = {};
 124 
 125     /**
 126      * Shared empty array instance used for default sized empty instances. We
 127      * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
 128      * first element is added.
 129      */
 130     private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
 131 
 132     /**
</pre>
<hr />
<pre>
 203               : Arrays.copyOf(elementData, size);
 204         }
 205     }
 206 
 207     /**
 208      * Increases the capacity of this {@code ArrayList} instance, if
 209      * necessary, to ensure that it can hold at least the number of elements
 210      * specified by the minimum capacity argument.
 211      *
 212      * @param minCapacity the desired minimum capacity
 213      */
 214     public void ensureCapacity(int minCapacity) {
 215         if (minCapacity &gt; elementData.length
 216             &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 217                  &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
 218             modCount++;
 219             grow(minCapacity);
 220         }
 221     }
 222 








 223     /**
 224      * Increases the capacity to ensure that it can hold at least the
 225      * number of elements specified by the minimum capacity argument.
 226      *
 227      * @param minCapacity the desired minimum capacity
 228      * @throws OutOfMemoryError if minCapacity is less than zero
 229      */
 230     private Object[] grow(int minCapacity) {



















 231         int oldCapacity = elementData.length;
<span class="line-modified"> 232         if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span>
<span class="line-modified"> 233             int newCapacity = ArraysSupport.newLength(oldCapacity,</span>
<span class="line-modified"> 234                     minCapacity - oldCapacity, /* minimum growth */</span>
<span class="line-modified"> 235                     oldCapacity &gt;&gt; 1           /* preferred growth */);</span>
<span class="line-modified"> 236             return elementData = Arrays.copyOf(elementData, newCapacity);</span>
<span class="line-modified"> 237         } else {</span>
<span class="line-modified"> 238             return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span>
 239         }



 240     }
 241 
<span class="line-modified"> 242     private Object[] grow() {</span>
<span class="line-modified"> 243         return grow(size + 1);</span>




 244     }
 245 
 246     /**
 247      * Returns the number of elements in this list.
 248      *
 249      * @return the number of elements in this list
 250      */
 251     public int size() {
 252         return size;
 253     }
 254 
 255     /**
 256      * Returns {@code true} if this list contains no elements.
 257      *
 258      * @return {@code true} if this list contains no elements
 259      */
 260     public boolean isEmpty() {
 261         return size == 0;
 262     }
 263 
</pre>
<hr />
<pre>
 833             System.arraycopy(es, r, es, w, end - r);
 834             w += end - r;
 835             throw ex;
 836         } finally {
 837             modCount += end - w;
 838             shiftTailOverGap(es, w, end);
 839         }
 840         return true;
 841     }
 842 
 843     /**
 844      * Saves the state of the {@code ArrayList} instance to a stream
 845      * (that is, serializes it).
 846      *
 847      * @param s the stream
 848      * @throws java.io.IOException if an I/O error occurs
 849      * @serialData The length of the array backing the {@code ArrayList}
 850      *             instance is emitted (int), followed by all of its elements
 851      *             (each an {@code Object}) in the proper order.
 852      */
<span class="line-added"> 853     @java.io.Serial</span>
 854     private void writeObject(java.io.ObjectOutputStream s)
 855         throws java.io.IOException {
 856         // Write out element count, and any hidden stuff
 857         int expectedModCount = modCount;
 858         s.defaultWriteObject();
 859 
 860         // Write out size as capacity for behavioral compatibility with clone()
 861         s.writeInt(size);
 862 
 863         // Write out all elements in the proper order.
 864         for (int i=0; i&lt;size; i++) {
 865             s.writeObject(elementData[i]);
 866         }
 867 
 868         if (modCount != expectedModCount) {
 869             throw new ConcurrentModificationException();
 870         }
 871     }
 872 
 873     /**
 874      * Reconstitutes the {@code ArrayList} instance from a stream (that is,
 875      * deserializes it).
 876      * @param s the stream
 877      * @throws ClassNotFoundException if the class of a serialized object
 878      *         could not be found
 879      * @throws java.io.IOException if an I/O error occurs
 880      */
<span class="line-added"> 881     @java.io.Serial</span>
 882     private void readObject(java.io.ObjectInputStream s)
 883         throws java.io.IOException, ClassNotFoundException {
 884 
 885         // Read in size, and any hidden stuff
 886         s.defaultReadObject();
 887 
 888         // Read in capacity
 889         s.readInt(); // ignored
 890 
 891         if (size &gt; 0) {
 892             // like clone(), allocate array based upon size not capacity
 893             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
 894             Object[] elements = new Object[size];
 895 
 896             // Read in all elements in the proper order.
 897             for (int i = 0; i &lt; size; i++) {
 898                 elements[i] = s.readObject();
 899             }
 900 
 901             elementData = elements;
</pre>
<hr />
<pre>
1116 
1117         /**
1118          * Constructs a sublist of an arbitrary ArrayList.
1119          */
1120         public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) {
1121             this.root = root;
1122             this.parent = null;
1123             this.offset = fromIndex;
1124             this.size = toIndex - fromIndex;
1125             this.modCount = root.modCount;
1126         }
1127 
1128         /**
1129          * Constructs a sublist of another SubList.
1130          */
1131         private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
1132             this.root = parent.root;
1133             this.parent = parent;
1134             this.offset = parent.offset + fromIndex;
1135             this.size = toIndex - fromIndex;
<span class="line-modified">1136             this.modCount = parent.modCount;</span>
1137         }
1138 
1139         public E set(int index, E element) {
1140             Objects.checkIndex(index, size);
1141             checkForComodification();
1142             E oldValue = root.elementData(offset + index);
1143             root.elementData[offset + index] = element;
1144             return oldValue;
1145         }
1146 
1147         public E get(int index) {
1148             Objects.checkIndex(index, size);
1149             checkForComodification();
1150             return root.elementData(offset + index);
1151         }
1152 
1153         public int size() {
1154             checkForComodification();
1155             return size;
1156         }
</pre>
<hr />
<pre>
1269             int index = root.lastIndexOfRange(o, offset, offset + size);
1270             checkForComodification();
1271             return index &gt;= 0 ? index - offset : -1;
1272         }
1273 
1274         public boolean contains(Object o) {
1275             return indexOf(o) &gt;= 0;
1276         }
1277 
1278         public Iterator&lt;E&gt; iterator() {
1279             return listIterator();
1280         }
1281 
1282         public ListIterator&lt;E&gt; listIterator(int index) {
1283             checkForComodification();
1284             rangeCheckForAdd(index);
1285 
1286             return new ListIterator&lt;E&gt;() {
1287                 int cursor = index;
1288                 int lastRet = -1;
<span class="line-modified">1289                 int expectedModCount = SubList.this.modCount;</span>
1290 
1291                 public boolean hasNext() {
1292                     return cursor != SubList.this.size;
1293                 }
1294 
1295                 @SuppressWarnings(&quot;unchecked&quot;)
1296                 public E next() {
1297                     checkForComodification();
1298                     int i = cursor;
1299                     if (i &gt;= SubList.this.size)
1300                         throw new NoSuchElementException();
1301                     Object[] elementData = root.elementData;
1302                     if (offset + i &gt;= elementData.length)
1303                         throw new ConcurrentModificationException();
1304                     cursor = i + 1;
1305                     return (E) elementData[offset + (lastRet = i)];
1306                 }
1307 
1308                 public boolean hasPrevious() {
1309                     return cursor != 0;
</pre>
<hr />
<pre>
1313                 public E previous() {
1314                     checkForComodification();
1315                     int i = cursor - 1;
1316                     if (i &lt; 0)
1317                         throw new NoSuchElementException();
1318                     Object[] elementData = root.elementData;
1319                     if (offset + i &gt;= elementData.length)
1320                         throw new ConcurrentModificationException();
1321                     cursor = i;
1322                     return (E) elementData[offset + (lastRet = i)];
1323                 }
1324 
1325                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1326                     Objects.requireNonNull(action);
1327                     final int size = SubList.this.size;
1328                     int i = cursor;
1329                     if (i &lt; size) {
1330                         final Object[] es = root.elementData;
1331                         if (offset + i &gt;= es.length)
1332                             throw new ConcurrentModificationException();
<span class="line-modified">1333                         for (; i &lt; size &amp;&amp; root.modCount == expectedModCount; i++)</span>
1334                             action.accept(elementAt(es, offset + i));
1335                         // update once at end to reduce heap write traffic
1336                         cursor = i;
1337                         lastRet = i - 1;
1338                         checkForComodification();
1339                     }
1340                 }
1341 
1342                 public int nextIndex() {
1343                     return cursor;
1344                 }
1345 
1346                 public int previousIndex() {
1347                     return cursor - 1;
1348                 }
1349 
1350                 public void remove() {
1351                     if (lastRet &lt; 0)
1352                         throw new IllegalStateException();
1353                     checkForComodification();
1354 
1355                     try {
1356                         SubList.this.remove(lastRet);
1357                         cursor = lastRet;
1358                         lastRet = -1;
<span class="line-modified">1359                         expectedModCount = SubList.this.modCount;</span>
1360                     } catch (IndexOutOfBoundsException ex) {
1361                         throw new ConcurrentModificationException();
1362                     }
1363                 }
1364 
1365                 public void set(E e) {
1366                     if (lastRet &lt; 0)
1367                         throw new IllegalStateException();
1368                     checkForComodification();
1369 
1370                     try {
1371                         root.set(offset + lastRet, e);
1372                     } catch (IndexOutOfBoundsException ex) {
1373                         throw new ConcurrentModificationException();
1374                     }
1375                 }
1376 
1377                 public void add(E e) {
1378                     checkForComodification();
1379 
1380                     try {
1381                         int i = cursor;
1382                         SubList.this.add(i, e);
1383                         cursor = i + 1;
1384                         lastRet = -1;
<span class="line-modified">1385                         expectedModCount = SubList.this.modCount;</span>
1386                     } catch (IndexOutOfBoundsException ex) {
1387                         throw new ConcurrentModificationException();
1388                     }
1389                 }
1390 
1391                 final void checkForComodification() {
1392                     if (root.modCount != expectedModCount)
1393                         throw new ConcurrentModificationException();
1394                 }
1395             };
1396         }
1397 
1398         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1399             subListRangeCheck(fromIndex, toIndex, size);
1400             return new SubList&lt;&gt;(this, fromIndex, toIndex);
1401         }
1402 
1403         private void rangeCheckForAdd(int index) {
1404             if (index &lt; 0 || index &gt; this.size)
1405                 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
</pre>
<hr />
<pre>
1682                     setBit(deathRow, i - beg);
1683             if (modCount != expectedModCount)
1684                 throw new ConcurrentModificationException();
1685             modCount++;
1686             int w = beg;
1687             for (i = beg; i &lt; end; i++)
1688                 if (isClear(deathRow, i - beg))
1689                     es[w++] = es[i];
1690             shiftTailOverGap(es, w, end);
1691             return true;
1692         } else {
1693             if (modCount != expectedModCount)
1694                 throw new ConcurrentModificationException();
1695             return false;
1696         }
1697     }
1698 
1699     @Override
1700     public void replaceAll(UnaryOperator&lt;E&gt; operator) {
1701         replaceAllRange(operator, 0, size);
<span class="line-added">1702         // TODO(8203662): remove increment of modCount from ...</span>
1703         modCount++;
1704     }
1705 
1706     private void replaceAllRange(UnaryOperator&lt;E&gt; operator, int i, int end) {
1707         Objects.requireNonNull(operator);
1708         final int expectedModCount = modCount;
1709         final Object[] es = elementData;
1710         for (; modCount == expectedModCount &amp;&amp; i &lt; end; i++)
1711             es[i] = operator.apply(elementAt(es, i));
1712         if (modCount != expectedModCount)
1713             throw new ConcurrentModificationException();
1714     }
1715 
1716     @Override
1717     @SuppressWarnings(&quot;unchecked&quot;)
1718     public void sort(Comparator&lt;? super E&gt; c) {
1719         final int expectedModCount = modCount;
1720         Arrays.sort((E[]) elementData, 0, size, c);
1721         if (modCount != expectedModCount)
1722             throw new ConcurrentModificationException();
</pre>
</td>
</tr>
</table>
<center><a href="ArrayDeque.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayPrefixHelpers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
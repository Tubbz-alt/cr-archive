<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/LineNumberInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InvalidObjectException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LineNumberReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/LineNumberInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 30  * functionality of keeping track of the current line number.
 31  * &lt;p&gt;
 32  * A line is a sequence of bytes ending with a carriage return
 33  * character ({@code &#39;\u005Cr&#39;}), a newline character
 34  * ({@code &#39;\u005Cn&#39;}), or a carriage return character followed
 35  * immediately by a linefeed character. In all three cases, the line
 36  * terminating character(s) are returned as a single newline character.
 37  * &lt;p&gt;
 38  * The line number begins at {@code 0}, and is incremented by
 39  * {@code 1} when a {@code read} returns a newline character.
 40  *
 41  * @author     Arthur van Hoff
 42  * @see        java.io.LineNumberReader
 43  * @since      1.0
 44  * @deprecated This class incorrectly assumes that bytes adequately represent
 45  *             characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
 46  *             character streams is via the new character-stream classes, which
 47  *             include a class for counting line numbers.
 48  */
 49 @Deprecated
<span class="line-modified"> 50 public</span>
<span class="line-removed"> 51 class LineNumberInputStream extends FilterInputStream {</span>
 52     int pushBack = -1;
 53     int lineNumber;
 54     int markLineNumber;
 55     int markPushBack = -1;
 56 
 57     /**
 58      * Constructs a newline number input stream that reads its input
 59      * from the specified input stream.
 60      *
 61      * @param      in   the underlying input stream.
 62      */
 63     public LineNumberInputStream(InputStream in) {
 64         super(in);
 65     }
 66 
 67     /**
 68      * Reads the next byte of data from this input stream. The value
 69      * byte is returned as an {@code int} in the range
 70      * {@code 0} to {@code 255}. If no byte is available
 71      * because the end of the stream has been reached, the value
 72      * {@code -1} is returned. This method blocks until input data
 73      * is available, the end of the stream is detected, or an exception
 74      * is thrown.
 75      * &lt;p&gt;
 76      * The {@code read} method of
 77      * {@code LineNumberInputStream} calls the {@code read}
 78      * method of the underlying input stream. It checks for carriage
 79      * returns and newline characters in the input, and modifies the
 80      * current line number as appropriate. A carriage-return character or
 81      * a carriage return followed by a newline character are both
 82      * converted into a single newline character.
 83      *
 84      * @return     the next byte of data, or {@code -1} if the end of this
 85      *             stream is reached.
<span class="line-modified"> 86      * @exception  IOException  if an I/O error occurs.</span>
 87      * @see        java.io.FilterInputStream#in
 88      * @see        java.io.LineNumberInputStream#getLineNumber()
 89      */
 90     @SuppressWarnings(&quot;fallthrough&quot;)
 91     public int read() throws IOException {
 92         int c = pushBack;
 93 
 94         if (c != -1) {
 95             pushBack = -1;
 96         } else {
 97             c = in.read();
 98         }
 99 
100         switch (c) {
101           case &#39;\r&#39;:
102             pushBack = in.read();
103             if (pushBack == &#39;\n&#39;) {
104                 pushBack = -1;
105             }
106           case &#39;\n&#39;:
107             lineNumber++;
108             return &#39;\n&#39;;
109         }
110         return c;
111     }
112 
113     /**
114      * Reads up to {@code len} bytes of data from this input stream
115      * into an array of bytes. This method blocks until some input is available.
116      * &lt;p&gt;
117      * The {@code read} method of
118      * {@code LineNumberInputStream} repeatedly calls the
119      * {@code read} method of zero arguments to fill in the byte array.
120      *
121      * @param      b     the buffer into which the data is read.
122      * @param      off   the start offset of the data.
123      * @param      len   the maximum number of bytes read.
124      * @return     the total number of bytes read into the buffer, or
125      *             {@code -1} if there is no more data because the end of
126      *             this stream has been reached.
<span class="line-modified">127      * @exception  IOException  if an I/O error occurs.</span>
128      * @see        java.io.LineNumberInputStream#read()
129      */
130     public int read(byte b[], int off, int len) throws IOException {
131         if (b == null) {
132             throw new NullPointerException();
133         } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||
134                    ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
135             throw new IndexOutOfBoundsException();
136         } else if (len == 0) {
137             return 0;
138         }
139 
140         int c = read();
141         if (c == -1) {
142             return -1;
143         }
144         b[off] = (byte)c;
145 
146         int i = 1;
147         try {
</pre>
<hr />
<pre>
156             }
157         } catch (IOException ee) {
158         }
159         return i;
160     }
161 
162     /**
163      * Skips over and discards {@code n} bytes of data from this
164      * input stream. The {@code skip} method may, for a variety of
165      * reasons, end up skipping over some smaller number of bytes,
166      * possibly {@code 0}. The actual number of bytes skipped is
167      * returned.  If {@code n} is negative, no bytes are skipped.
168      * &lt;p&gt;
169      * The {@code skip} method of {@code LineNumberInputStream} creates
170      * a byte array and then repeatedly reads into it until
171      * {@code n} bytes have been read or the end of the stream has
172      * been reached.
173      *
174      * @param      n   the number of bytes to be skipped.
175      * @return     the actual number of bytes skipped.
<span class="line-modified">176      * @exception  IOException  if an I/O error occurs.</span>
177      * @see        java.io.FilterInputStream#in
178      */
179     public long skip(long n) throws IOException {
180         int chunk = 2048;
181         long remaining = n;
182         byte data[];
183         int nr;
184 
185         if (n &lt;= 0) {
186             return 0;
187         }
188 
189         data = new byte[chunk];
190         while (remaining &gt; 0) {
191             nr = read(data, 0, (int) Math.min(chunk, remaining));
192             if (nr &lt; 0) {
193                 break;
194             }
195             remaining -= nr;
196         }
</pre>
<hr />
<pre>
217     public int getLineNumber() {
218         return lineNumber;
219     }
220 
221 
222     /**
223      * Returns the number of bytes that can be read from this input
224      * stream without blocking.
225      * &lt;p&gt;
226      * Note that if the underlying input stream is able to supply
227      * &lt;i&gt;k&lt;/i&gt; input characters without blocking, the
228      * {@code LineNumberInputStream} can guarantee only to provide
229      * &lt;i&gt;k&lt;/i&gt;/2 characters without blocking, because the
230      * &lt;i&gt;k&lt;/i&gt; characters from the underlying input stream might
231      * consist of &lt;i&gt;k&lt;/i&gt;/2 pairs of {@code &#39;\u005Cr&#39;} and
232      * {@code &#39;\u005Cn&#39;}, which are converted to just
233      * &lt;i&gt;k&lt;/i&gt;/2 {@code &#39;\u005Cn&#39;} characters.
234      *
235      * @return     the number of bytes that can be read from this input stream
236      *             without blocking.
<span class="line-modified">237      * @exception  IOException  if an I/O error occurs.</span>
238      * @see        java.io.FilterInputStream#in
239      */
240     public int available() throws IOException {
241         return (pushBack == -1) ? super.available()/2 : super.available()/2 + 1;
242     }
243 
244     /**
245      * Marks the current position in this input stream. A subsequent
246      * call to the {@code reset} method repositions this stream at
247      * the last marked position so that subsequent reads re-read the same bytes.
248      * &lt;p&gt;
249      * The {@code mark} method of
250      * {@code LineNumberInputStream} remembers the current line
251      * number in a private variable, and then calls the {@code mark}
252      * method of the underlying input stream.
253      *
254      * @param   readlimit   the maximum limit of bytes that can be read before
255      *                      the mark position becomes invalid.
256      * @see     java.io.FilterInputStream#in
257      * @see     java.io.LineNumberInputStream#reset()
</pre>
<hr />
<pre>
264 
265     /**
266      * Repositions this stream to the position at the time the
267      * {@code mark} method was last called on this input stream.
268      * &lt;p&gt;
269      * The {@code reset} method of
270      * {@code LineNumberInputStream} resets the line number to be
271      * the line number at the time the {@code mark} method was
272      * called, and then calls the {@code reset} method of the
273      * underlying input stream.
274      * &lt;p&gt;
275      * Stream marks are intended to be used in
276      * situations where you need to read ahead a little to see what&#39;s in
277      * the stream. Often this is most easily done by invoking some
278      * general parser. If the stream is of the type handled by the
279      * parser, it just chugs along happily. If the stream is not of
280      * that type, the parser should toss an exception when it fails,
281      * which, if it happens within readlimit bytes, allows the outer
282      * code to reset the stream and try another parser.
283      *
<span class="line-modified">284      * @exception  IOException  if an I/O error occurs.</span>
285      * @see        java.io.FilterInputStream#in
286      * @see        java.io.LineNumberInputStream#mark(int)
287      */
288     public void reset() throws IOException {
289         lineNumber = markLineNumber;
290         pushBack   = markPushBack;
291         in.reset();
292     }
293 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 30  * functionality of keeping track of the current line number.
 31  * &lt;p&gt;
 32  * A line is a sequence of bytes ending with a carriage return
 33  * character ({@code &#39;\u005Cr&#39;}), a newline character
 34  * ({@code &#39;\u005Cn&#39;}), or a carriage return character followed
 35  * immediately by a linefeed character. In all three cases, the line
 36  * terminating character(s) are returned as a single newline character.
 37  * &lt;p&gt;
 38  * The line number begins at {@code 0}, and is incremented by
 39  * {@code 1} when a {@code read} returns a newline character.
 40  *
 41  * @author     Arthur van Hoff
 42  * @see        java.io.LineNumberReader
 43  * @since      1.0
 44  * @deprecated This class incorrectly assumes that bytes adequately represent
 45  *             characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
 46  *             character streams is via the new character-stream classes, which
 47  *             include a class for counting line numbers.
 48  */
 49 @Deprecated
<span class="line-modified"> 50 public class LineNumberInputStream extends FilterInputStream {</span>

 51     int pushBack = -1;
 52     int lineNumber;
 53     int markLineNumber;
 54     int markPushBack = -1;
 55 
 56     /**
 57      * Constructs a newline number input stream that reads its input
 58      * from the specified input stream.
 59      *
 60      * @param      in   the underlying input stream.
 61      */
 62     public LineNumberInputStream(InputStream in) {
 63         super(in);
 64     }
 65 
 66     /**
 67      * Reads the next byte of data from this input stream. The value
 68      * byte is returned as an {@code int} in the range
 69      * {@code 0} to {@code 255}. If no byte is available
 70      * because the end of the stream has been reached, the value
 71      * {@code -1} is returned. This method blocks until input data
 72      * is available, the end of the stream is detected, or an exception
 73      * is thrown.
 74      * &lt;p&gt;
 75      * The {@code read} method of
 76      * {@code LineNumberInputStream} calls the {@code read}
 77      * method of the underlying input stream. It checks for carriage
 78      * returns and newline characters in the input, and modifies the
 79      * current line number as appropriate. A carriage-return character or
 80      * a carriage return followed by a newline character are both
 81      * converted into a single newline character.
 82      *
 83      * @return     the next byte of data, or {@code -1} if the end of this
 84      *             stream is reached.
<span class="line-modified"> 85      * @throws     IOException  if an I/O error occurs.</span>
 86      * @see        java.io.FilterInputStream#in
 87      * @see        java.io.LineNumberInputStream#getLineNumber()
 88      */
 89     @SuppressWarnings(&quot;fallthrough&quot;)
 90     public int read() throws IOException {
 91         int c = pushBack;
 92 
 93         if (c != -1) {
 94             pushBack = -1;
 95         } else {
 96             c = in.read();
 97         }
 98 
 99         switch (c) {
100           case &#39;\r&#39;:
101             pushBack = in.read();
102             if (pushBack == &#39;\n&#39;) {
103                 pushBack = -1;
104             }
105           case &#39;\n&#39;:
106             lineNumber++;
107             return &#39;\n&#39;;
108         }
109         return c;
110     }
111 
112     /**
113      * Reads up to {@code len} bytes of data from this input stream
114      * into an array of bytes. This method blocks until some input is available.
115      * &lt;p&gt;
116      * The {@code read} method of
117      * {@code LineNumberInputStream} repeatedly calls the
118      * {@code read} method of zero arguments to fill in the byte array.
119      *
120      * @param      b     the buffer into which the data is read.
121      * @param      off   the start offset of the data.
122      * @param      len   the maximum number of bytes read.
123      * @return     the total number of bytes read into the buffer, or
124      *             {@code -1} if there is no more data because the end of
125      *             this stream has been reached.
<span class="line-modified">126      * @throws     IOException  if an I/O error occurs.</span>
127      * @see        java.io.LineNumberInputStream#read()
128      */
129     public int read(byte b[], int off, int len) throws IOException {
130         if (b == null) {
131             throw new NullPointerException();
132         } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||
133                    ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
134             throw new IndexOutOfBoundsException();
135         } else if (len == 0) {
136             return 0;
137         }
138 
139         int c = read();
140         if (c == -1) {
141             return -1;
142         }
143         b[off] = (byte)c;
144 
145         int i = 1;
146         try {
</pre>
<hr />
<pre>
155             }
156         } catch (IOException ee) {
157         }
158         return i;
159     }
160 
161     /**
162      * Skips over and discards {@code n} bytes of data from this
163      * input stream. The {@code skip} method may, for a variety of
164      * reasons, end up skipping over some smaller number of bytes,
165      * possibly {@code 0}. The actual number of bytes skipped is
166      * returned.  If {@code n} is negative, no bytes are skipped.
167      * &lt;p&gt;
168      * The {@code skip} method of {@code LineNumberInputStream} creates
169      * a byte array and then repeatedly reads into it until
170      * {@code n} bytes have been read or the end of the stream has
171      * been reached.
172      *
173      * @param      n   the number of bytes to be skipped.
174      * @return     the actual number of bytes skipped.
<span class="line-modified">175      * @throws     IOException  if an I/O error occurs.</span>
176      * @see        java.io.FilterInputStream#in
177      */
178     public long skip(long n) throws IOException {
179         int chunk = 2048;
180         long remaining = n;
181         byte data[];
182         int nr;
183 
184         if (n &lt;= 0) {
185             return 0;
186         }
187 
188         data = new byte[chunk];
189         while (remaining &gt; 0) {
190             nr = read(data, 0, (int) Math.min(chunk, remaining));
191             if (nr &lt; 0) {
192                 break;
193             }
194             remaining -= nr;
195         }
</pre>
<hr />
<pre>
216     public int getLineNumber() {
217         return lineNumber;
218     }
219 
220 
221     /**
222      * Returns the number of bytes that can be read from this input
223      * stream without blocking.
224      * &lt;p&gt;
225      * Note that if the underlying input stream is able to supply
226      * &lt;i&gt;k&lt;/i&gt; input characters without blocking, the
227      * {@code LineNumberInputStream} can guarantee only to provide
228      * &lt;i&gt;k&lt;/i&gt;/2 characters without blocking, because the
229      * &lt;i&gt;k&lt;/i&gt; characters from the underlying input stream might
230      * consist of &lt;i&gt;k&lt;/i&gt;/2 pairs of {@code &#39;\u005Cr&#39;} and
231      * {@code &#39;\u005Cn&#39;}, which are converted to just
232      * &lt;i&gt;k&lt;/i&gt;/2 {@code &#39;\u005Cn&#39;} characters.
233      *
234      * @return     the number of bytes that can be read from this input stream
235      *             without blocking.
<span class="line-modified">236      * @throws     IOException  if an I/O error occurs.</span>
237      * @see        java.io.FilterInputStream#in
238      */
239     public int available() throws IOException {
240         return (pushBack == -1) ? super.available()/2 : super.available()/2 + 1;
241     }
242 
243     /**
244      * Marks the current position in this input stream. A subsequent
245      * call to the {@code reset} method repositions this stream at
246      * the last marked position so that subsequent reads re-read the same bytes.
247      * &lt;p&gt;
248      * The {@code mark} method of
249      * {@code LineNumberInputStream} remembers the current line
250      * number in a private variable, and then calls the {@code mark}
251      * method of the underlying input stream.
252      *
253      * @param   readlimit   the maximum limit of bytes that can be read before
254      *                      the mark position becomes invalid.
255      * @see     java.io.FilterInputStream#in
256      * @see     java.io.LineNumberInputStream#reset()
</pre>
<hr />
<pre>
263 
264     /**
265      * Repositions this stream to the position at the time the
266      * {@code mark} method was last called on this input stream.
267      * &lt;p&gt;
268      * The {@code reset} method of
269      * {@code LineNumberInputStream} resets the line number to be
270      * the line number at the time the {@code mark} method was
271      * called, and then calls the {@code reset} method of the
272      * underlying input stream.
273      * &lt;p&gt;
274      * Stream marks are intended to be used in
275      * situations where you need to read ahead a little to see what&#39;s in
276      * the stream. Often this is most easily done by invoking some
277      * general parser. If the stream is of the type handled by the
278      * parser, it just chugs along happily. If the stream is not of
279      * that type, the parser should toss an exception when it fails,
280      * which, if it happens within readlimit bytes, allows the outer
281      * code to reset the stream and try another parser.
282      *
<span class="line-modified">283      * @throws     IOException  if an I/O error occurs.</span>
284      * @see        java.io.FilterInputStream#in
285      * @see        java.io.LineNumberInputStream#mark(int)
286      */
287     public void reset() throws IOException {
288         lineNumber = markLineNumber;
289         pushBack   = markPushBack;
290         in.reset();
291     }
292 }
</pre>
</td>
</tr>
</table>
<center><a href="InvalidObjectException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LineNumberReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
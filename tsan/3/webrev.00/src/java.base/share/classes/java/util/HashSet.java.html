<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/HashSet.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import java.io.InvalidObjectException;
 29 import jdk.internal.access.SharedSecrets;
 30 
 31 /**
 32  * This class implements the {@code Set} interface, backed by a hash table
 33  * (actually a {@code HashMap} instance).  It makes no guarantees as to the
 34  * iteration order of the set; in particular, it does not guarantee that the
 35  * order will remain constant over time.  This class permits the {@code null}
 36  * element.
 37  *
 38  * &lt;p&gt;This class offers constant time performance for the basic operations
 39  * ({@code add}, {@code remove}, {@code contains} and {@code size}),
 40  * assuming the hash function disperses the elements properly among the
 41  * buckets.  Iterating over this set requires time proportional to the sum of
 42  * the {@code HashSet} instance&#39;s size (the number of elements) plus the
 43  * &quot;capacity&quot; of the backing {@code HashMap} instance (the number of
 44  * buckets).  Thus, it&#39;s very important not to set the initial capacity too
 45  * high (or the load factor too low) if iteration performance is important.
 46  *
 47  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 48  * If multiple threads access a hash set concurrently, and at least one of
 49  * the threads modifies the set, it &lt;i&gt;must&lt;/i&gt; be synchronized externally.
 50  * This is typically accomplished by synchronizing on some object that
 51  * naturally encapsulates the set.
 52  *
 53  * If no such object exists, the set should be &quot;wrapped&quot; using the
 54  * {@link Collections#synchronizedSet Collections.synchronizedSet}
 55  * method.  This is best done at creation time, to prevent accidental
 56  * unsynchronized access to the set:&lt;pre&gt;
 57  *   Set s = Collections.synchronizedSet(new HashSet(...));&lt;/pre&gt;
 58  *
 59  * &lt;p&gt;The iterators returned by this class&#39;s {@code iterator} method are
 60  * &lt;i&gt;fail-fast&lt;/i&gt;: if the set is modified at any time after the iterator is
 61  * created, in any way except through the iterator&#39;s own {@code remove}
 62  * method, the Iterator throws a {@link ConcurrentModificationException}.
 63  * Thus, in the face of concurrent modification, the iterator fails quickly
 64  * and cleanly, rather than risking arbitrary, non-deterministic behavior at
 65  * an undetermined time in the future.
 66  *
 67  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 68  * as it is, generally speaking, impossible to make any hard guarantees in the
 69  * presence of unsynchronized concurrent modification.  Fail-fast iterators
 70  * throw {@code ConcurrentModificationException} on a best-effort basis.
 71  * Therefore, it would be wrong to write a program that depended on this
 72  * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
 73  * should be used only to detect bugs.&lt;/i&gt;
 74  *
 75  * &lt;p&gt;This class is a member of the
 76  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 77  * Java Collections Framework&lt;/a&gt;.
 78  *
 79  * @param &lt;E&gt; the type of elements maintained by this set
 80  *
 81  * @author  Josh Bloch
 82  * @author  Neal Gafter
 83  * @see     Collection
 84  * @see     Set
 85  * @see     TreeSet
 86  * @see     HashMap
 87  * @since   1.2
 88  */
 89 
 90 public class HashSet&lt;E&gt;
 91     extends AbstractSet&lt;E&gt;
 92     implements Set&lt;E&gt;, Cloneable, java.io.Serializable
 93 {
 94     @java.io.Serial
 95     static final long serialVersionUID = -5024744406713321676L;
 96 
 97     private transient HashMap&lt;E,Object&gt; map;
 98 
 99     // Dummy value to associate with an Object in the backing Map
100     private static final Object PRESENT = new Object();
101 
102     /**
103      * Constructs a new, empty set; the backing {@code HashMap} instance has
104      * default initial capacity (16) and load factor (0.75).
105      */
106     public HashSet() {
107         map = new HashMap&lt;&gt;();
108     }
109 
110     /**
111      * Constructs a new set containing the elements in the specified
112      * collection.  The {@code HashMap} is created with default load factor
113      * (0.75) and an initial capacity sufficient to contain the elements in
114      * the specified collection.
115      *
116      * @param c the collection whose elements are to be placed into this set
117      * @throws NullPointerException if the specified collection is null
118      */
119     public HashSet(Collection&lt;? extends E&gt; c) {
120         map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
121         addAll(c);
122     }
123 
124     /**
125      * Constructs a new, empty set; the backing {@code HashMap} instance has
126      * the specified initial capacity and the specified load factor.
127      *
128      * @param      initialCapacity   the initial capacity of the hash map
129      * @param      loadFactor        the load factor of the hash map
130      * @throws     IllegalArgumentException if the initial capacity is less
131      *             than zero, or if the load factor is nonpositive
132      */
133     public HashSet(int initialCapacity, float loadFactor) {
134         map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
135     }
136 
137     /**
138      * Constructs a new, empty set; the backing {@code HashMap} instance has
139      * the specified initial capacity and default load factor (0.75).
140      *
141      * @param      initialCapacity   the initial capacity of the hash table
142      * @throws     IllegalArgumentException if the initial capacity is less
143      *             than zero
144      */
145     public HashSet(int initialCapacity) {
146         map = new HashMap&lt;&gt;(initialCapacity);
147     }
148 
149     /**
150      * Constructs a new, empty linked hash set.  (This package private
151      * constructor is only used by LinkedHashSet.) The backing
152      * HashMap instance is a LinkedHashMap with the specified initial
153      * capacity and the specified load factor.
154      *
155      * @param      initialCapacity   the initial capacity of the hash map
156      * @param      loadFactor        the load factor of the hash map
157      * @param      dummy             ignored (distinguishes this
158      *             constructor from other int, float constructor.)
159      * @throws     IllegalArgumentException if the initial capacity is less
160      *             than zero, or if the load factor is nonpositive
161      */
162     HashSet(int initialCapacity, float loadFactor, boolean dummy) {
163         map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
164     }
165 
166     /**
167      * Returns an iterator over the elements in this set.  The elements
168      * are returned in no particular order.
169      *
170      * @return an Iterator over the elements in this set
171      * @see ConcurrentModificationException
172      */
173     public Iterator&lt;E&gt; iterator() {
174         return map.keySet().iterator();
175     }
176 
177     /**
178      * Returns the number of elements in this set (its cardinality).
179      *
180      * @return the number of elements in this set (its cardinality)
181      */
182     public int size() {
183         return map.size();
184     }
185 
186     /**
187      * Returns {@code true} if this set contains no elements.
188      *
189      * @return {@code true} if this set contains no elements
190      */
191     public boolean isEmpty() {
192         return map.isEmpty();
193     }
194 
195     /**
196      * Returns {@code true} if this set contains the specified element.
197      * More formally, returns {@code true} if and only if this set
198      * contains an element {@code e} such that
199      * {@code Objects.equals(o, e)}.
200      *
201      * @param o element whose presence in this set is to be tested
202      * @return {@code true} if this set contains the specified element
203      */
204     public boolean contains(Object o) {
205         return map.containsKey(o);
206     }
207 
208     /**
209      * Adds the specified element to this set if it is not already present.
210      * More formally, adds the specified element {@code e} to this set if
211      * this set contains no element {@code e2} such that
212      * {@code Objects.equals(e, e2)}.
213      * If this set already contains the element, the call leaves the set
214      * unchanged and returns {@code false}.
215      *
216      * @param e element to be added to this set
217      * @return {@code true} if this set did not already contain the specified
218      * element
219      */
220     public boolean add(E e) {
221         return map.put(e, PRESENT)==null;
222     }
223 
224     /**
225      * Removes the specified element from this set if it is present.
226      * More formally, removes an element {@code e} such that
227      * {@code Objects.equals(o, e)},
228      * if this set contains such an element.  Returns {@code true} if
229      * this set contained the element (or equivalently, if this set
230      * changed as a result of the call).  (This set will not contain the
231      * element once the call returns.)
232      *
233      * @param o object to be removed from this set, if present
234      * @return {@code true} if the set contained the specified element
235      */
236     public boolean remove(Object o) {
237         return map.remove(o)==PRESENT;
238     }
239 
240     /**
241      * Removes all of the elements from this set.
242      * The set will be empty after this call returns.
243      */
244     public void clear() {
245         map.clear();
246     }
247 
248     /**
249      * Returns a shallow copy of this {@code HashSet} instance: the elements
250      * themselves are not cloned.
251      *
252      * @return a shallow copy of this set
253      */
254     @SuppressWarnings(&quot;unchecked&quot;)
255     public Object clone() {
256         try {
257             HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();
258             newSet.map = (HashMap&lt;E, Object&gt;) map.clone();
259             return newSet;
260         } catch (CloneNotSupportedException e) {
261             throw new InternalError(e);
262         }
263     }
264 
265     /**
266      * Save the state of this {@code HashSet} instance to a stream (that is,
267      * serialize it).
268      *
269      * @serialData The capacity of the backing {@code HashMap} instance
270      *             (int), and its load factor (float) are emitted, followed by
271      *             the size of the set (the number of elements it contains)
272      *             (int), followed by all of its elements (each an Object) in
273      *             no particular order.
274      */
275     @java.io.Serial
276     private void writeObject(java.io.ObjectOutputStream s)
277         throws java.io.IOException {
278         // Write out any hidden serialization magic
279         s.defaultWriteObject();
280 
281         // Write out HashMap capacity and load factor
282         s.writeInt(map.capacity());
283         s.writeFloat(map.loadFactor());
284 
285         // Write out size
286         s.writeInt(map.size());
287 
288         // Write out all elements in the proper order.
289         for (E e : map.keySet())
290             s.writeObject(e);
291     }
292 
293     /**
294      * Reconstitute the {@code HashSet} instance from a stream (that is,
295      * deserialize it).
296      */
297     @java.io.Serial
298     private void readObject(java.io.ObjectInputStream s)
299         throws java.io.IOException, ClassNotFoundException {
300         // Read in any hidden serialization magic
301         s.defaultReadObject();
302 
303         // Read capacity and verify non-negative.
304         int capacity = s.readInt();
305         if (capacity &lt; 0) {
306             throw new InvalidObjectException(&quot;Illegal capacity: &quot; +
307                                              capacity);
308         }
309 
310         // Read load factor and verify positive and non NaN.
311         float loadFactor = s.readFloat();
312         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) {
313             throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
314                                              loadFactor);
315         }
316 
317         // Read size and verify non-negative.
318         int size = s.readInt();
319         if (size &lt; 0) {
320             throw new InvalidObjectException(&quot;Illegal size: &quot; +
321                                              size);
322         }
323 
324         // Set the capacity according to the size and load factor ensuring that
325         // the HashMap is at least 25% full but clamping to maximum capacity.
326         capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f),
327                 HashMap.MAXIMUM_CAPACITY);
328 
329         // Constructing the backing map will lazily create an array when the first element is
330         // added, so check it before construction. Call HashMap.tableSizeFor to compute the
331         // actual allocation size. Check Map.Entry[].class since it&#39;s the nearest public type to
332         // what is actually created.
333         SharedSecrets.getJavaObjectInputStreamAccess()
334                      .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));
335 
336         // Create backing HashMap
337         map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?
338                new LinkedHashMap&lt;&gt;(capacity, loadFactor) :
339                new HashMap&lt;&gt;(capacity, loadFactor));
340 
341         // Read in all elements in the proper order.
342         for (int i=0; i&lt;size; i++) {
343             @SuppressWarnings(&quot;unchecked&quot;)
344                 E e = (E) s.readObject();
345             map.put(e, PRESENT);
346         }
347     }
348 
349     /**
350      * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
351      * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
352      * set.
353      *
354      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and
355      * {@link Spliterator#DISTINCT}.  Overriding implementations should document
356      * the reporting of additional characteristic values.
357      *
358      * @return a {@code Spliterator} over the elements in this set
359      * @since 1.8
360      */
361     public Spliterator&lt;E&gt; spliterator() {
362         return new HashMap.KeySpliterator&lt;&gt;(map, 0, -1, 0, 0);
363     }
364 
365     @Override
366     public Object[] toArray() {
367         return map.keysToArray(new Object[map.size()]);
368     }
369 
370     @Override
371     public &lt;T&gt; T[] toArray(T[] a) {
372         return map.keysToArray(map.prepareArray(a));
373     }
374 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/net/ServerSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxySelector.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Socket.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/ServerSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,23 +23,20 @@</span>
   * questions.
   */
  
  package java.net;
  
<span class="udiff-line-removed">- import jdk.internal.access.JavaNetSocketAccess;</span>
<span class="udiff-line-removed">- import jdk.internal.access.SharedSecrets;</span>
<span class="udiff-line-removed">- </span>
  import java.io.FileDescriptor;
  import java.io.IOException;
<span class="udiff-line-removed">- import java.lang.reflect.Constructor;</span>
<span class="udiff-line-removed">- import java.lang.reflect.InvocationTargetException;</span>
  import java.nio.channels.ServerSocketChannel;
<span class="udiff-line-modified-removed">- import java.security.AccessController;</span>
<span class="udiff-line-removed">- import java.security.PrivilegedExceptionAction;</span>
<span class="udiff-line-modified-added">+ import java.util.Objects;</span>
  import java.util.Set;
  import java.util.Collections;
  
<span class="udiff-line-added">+ import sun.security.util.SecurityConstants;</span>
<span class="udiff-line-added">+ import sun.net.PlatformSocketImpl;</span>
<span class="udiff-line-added">+ </span>
  /**
   * This class implements server sockets. A server socket waits for
   * requests to come in over the network. It performs some operation
   * based on that request, and then possibly returns a result to the requester.
   * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,18 +44,46 @@</span>
   * of the {@code SocketImpl} class. An application can
   * change the socket factory that creates the socket
   * implementation to configure itself to create sockets
   * appropriate to the local firewall.
   *
<span class="udiff-line-added">+  * &lt;p&gt; The {@code ServerSocket} class defines convenience</span>
<span class="udiff-line-added">+  * methods to set and get several socket options. This class also</span>
<span class="udiff-line-added">+  * defines the {@link #setOption(SocketOption, Object) setOption}</span>
<span class="udiff-line-added">+  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="udiff-line-added">+  * and query socket options.</span>
<span class="udiff-line-added">+  * A {@code ServerSocket} supports the following options:</span>
<span class="udiff-line-added">+  * &lt;blockquote&gt;</span>
<span class="udiff-line-added">+  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="udiff-line-added">+  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="udiff-line-added">+  * &lt;thead&gt;</span>
<span class="udiff-line-added">+  *   &lt;tr&gt;</span>
<span class="udiff-line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="udiff-line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="udiff-line-added">+  *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+  * &lt;/thead&gt;</span>
<span class="udiff-line-added">+  * &lt;tbody&gt;</span>
<span class="udiff-line-added">+  *   &lt;tr&gt;</span>
<span class="udiff-line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;</span>
<span class="udiff-line-added">+  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;</span>
<span class="udiff-line-added">+  *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+  *   &lt;tr&gt;</span>
<span class="udiff-line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;</span>
<span class="udiff-line-added">+  *     &lt;td&gt; Re-use address &lt;/td&gt;</span>
<span class="udiff-line-added">+  *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+  * &lt;/tbody&gt;</span>
<span class="udiff-line-added">+  * &lt;/table&gt;</span>
<span class="udiff-line-added">+  * &lt;/blockquote&gt;</span>
<span class="udiff-line-added">+  * Additional (implementation specific) options may also be supported.</span>
<span class="udiff-line-added">+  *</span>
   * @author  unascribed
   * @see     java.net.SocketImpl
   * @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
   * @see     java.nio.channels.ServerSocketChannel
   * @since   1.0
   */
<span class="udiff-line-modified-removed">- public</span>
<span class="udiff-line-removed">- class ServerSocket implements java.io.Closeable {</span>
<span class="udiff-line-modified-added">+ public class ServerSocket implements java.io.Closeable {</span>
      /**
       * Various states of this socket.
       */
      private boolean created = false;
      private boolean bound = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,33 +93,40 @@</span>
      /**
       * The implementation of this Socket.
       */
      private SocketImpl impl;
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Are we using an older SocketImpl?</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private boolean oldImpl = false;</span>
<span class="udiff-line-removed">- </span>
      /**
       * Creates a server socket with a user-specified {@code SocketImpl}.
       *
       * @param      impl an instance of a SocketImpl to use on the ServerSocket.
       *
       * @throws     NullPointerException if impl is {@code null}.
       *
<span class="udiff-line-added">+      * @throws     SecurityException if a security manager is set and</span>
<span class="udiff-line-added">+      *             its {@code checkPermission} method doesn&#39;t allow</span>
<span class="udiff-line-added">+      *             {@code NetPermission(&quot;setSocketImpl&quot;)}.</span>
       * @since 12
       */
      protected ServerSocket(SocketImpl impl) {
<span class="udiff-line-added">+         Objects.requireNonNull(impl);</span>
<span class="udiff-line-added">+         checkPermission();</span>
          this.impl = impl;
<span class="udiff-line-modified-removed">-         impl.setServerSocket(this);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static Void checkPermission() {</span>
<span class="udiff-line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="udiff-line-added">+         if (sm != null) {</span>
<span class="udiff-line-added">+             sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return null;</span>
      }
  
      /**
       * Creates an unbound server socket.
       *
<span class="udiff-line-modified-removed">-      * @exception IOException IO error when opening the socket.</span>
<span class="udiff-line-modified-added">+      * @throws    IOException IO error when opening the socket.</span>
       * @revised 1.4
       */
      public ServerSocket() throws IOException {
          setImpl();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107,13 +139,14 @@</span>
       * &lt;p&gt;
       * The maximum queue length for incoming connection indications (a
       * request to connect) is set to {@code 50}. If a connection
       * indication arrives when the queue is full, the connection is refused.
       * &lt;p&gt;
<span class="udiff-line-modified-removed">-      * If the application has specified a server socket factory, that</span>
<span class="udiff-line-modified-removed">-      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="udiff-line-modified-removed">-      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>
<span class="udiff-line-modified-added">+      * If the application has specified a server socket implementation</span>
<span class="udiff-line-modified-added">+      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="udiff-line-modified-added">+      * create the actual socket implementation. Otherwise a system-default</span>
<span class="udiff-line-added">+      * socket implementation is created.</span>
       * &lt;p&gt;
       * If there is a security manager,
       * its {@code checkListen} method is called
       * with the {@code port} argument
       * as its argument to ensure the operation is allowed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,15 +154,15 @@</span>
       *
       *
       * @param      port  the port number, or {@code 0} to use a port
       *                   number that is automatically allocated.
       *
<span class="udiff-line-modified-removed">-      * @exception  IOException  if an I/O error occurs when opening the socket.</span>
<span class="udiff-line-modified-removed">-      * @exception  SecurityException</span>
<span class="udiff-line-modified-added">+      * @throws     IOException  if an I/O error occurs when opening the socket.</span>
<span class="udiff-line-modified-added">+      * @throws     SecurityException</span>
       * if a security manager exists and its {@code checkListen}
       * method doesn&#39;t allow the operation.
<span class="udiff-line-modified-removed">-      * @exception  IllegalArgumentException if the port parameter is outside</span>
<span class="udiff-line-modified-added">+      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       *
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151,13 +184,14 @@</span>
       * The maximum queue length for incoming connection indications (a
       * request to connect) is set to the {@code backlog} parameter. If
       * a connection indication arrives when the queue is full, the
       * connection is refused.
       * &lt;p&gt;
<span class="udiff-line-modified-removed">-      * If the application has specified a server socket factory, that</span>
<span class="udiff-line-modified-removed">-      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="udiff-line-modified-removed">-      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>
<span class="udiff-line-modified-added">+      * If the application has specified a server socket implementation</span>
<span class="udiff-line-modified-added">+      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="udiff-line-modified-added">+      * create the actual socket implementation. Otherwise a system-default</span>
<span class="udiff-line-added">+      * socket implementation is created.</span>
       * &lt;p&gt;
       * If there is a security manager,
       * its {@code checkListen} method is called
       * with the {@code port} argument
       * as its argument to ensure the operation is allowed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -173,15 +207,15 @@</span>
       * @param      port     the port number, or {@code 0} to use a port
       *                      number that is automatically allocated.
       * @param      backlog  requested maximum length of the queue of incoming
       *                      connections.
       *
<span class="udiff-line-modified-removed">-      * @exception  IOException  if an I/O error occurs when opening the socket.</span>
<span class="udiff-line-modified-removed">-      * @exception  SecurityException</span>
<span class="udiff-line-modified-added">+      * @throws     IOException  if an I/O error occurs when opening the socket.</span>
<span class="udiff-line-modified-added">+      * @throws     SecurityException</span>
       * if a security manager exists and its {@code checkListen}
       * method doesn&#39;t allow the operation.
<span class="udiff-line-modified-removed">-      * @exception  IllegalArgumentException if the port parameter is outside</span>
<span class="udiff-line-modified-added">+      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       *
       * @see        java.net.SocketImpl
       * @see        java.net.SocketImplFactory#createSocketImpl()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -226,11 +260,11 @@</span>
       *
       * @throws  SecurityException if a security manager exists and
       * its {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @throws  IOException if an I/O error occurs when opening the socket.
<span class="udiff-line-modified-removed">-      * @exception  IllegalArgumentException if the port parameter is outside</span>
<span class="udiff-line-modified-added">+      * @throws     IllegalArgumentException if the port parameter is outside</span>
       *             the specified range of valid port values, which is between
       *             0 and 65535, inclusive.
       *
       * @see SocketOptions
       * @see SocketImpl
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -267,41 +301,17 @@</span>
          if (!created)
              createImpl();
          return impl;
      }
  
<span class="udiff-line-removed">-     private void checkOldImpl() {</span>
<span class="udiff-line-removed">-         if (impl == null)</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         // SocketImpl.connect() is a protected method, therefore we need to use</span>
<span class="udiff-line-removed">-         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="udiff-line-removed">-         try {</span>
<span class="udiff-line-removed">-             AccessController.doPrivileged(</span>
<span class="udiff-line-removed">-                 new PrivilegedExceptionAction&lt;Void&gt;() {</span>
<span class="udiff-line-removed">-                     public Void run() throws NoSuchMethodException {</span>
<span class="udiff-line-removed">-                         impl.getClass().getDeclaredMethod(&quot;connect&quot;,</span>
<span class="udiff-line-removed">-                                                           SocketAddress.class,</span>
<span class="udiff-line-removed">-                                                           int.class);</span>
<span class="udiff-line-removed">-                         return null;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 });</span>
<span class="udiff-line-removed">-         } catch (java.security.PrivilegedActionException e) {</span>
<span class="udiff-line-removed">-             oldImpl = true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      private void setImpl() {
<span class="udiff-line-added">+         SocketImplFactory factory = ServerSocket.factory;</span>
          if (factory != null) {
              impl = factory.createSocketImpl();
<span class="udiff-line-removed">-             checkOldImpl();</span>
          } else {
<span class="udiff-line-modified-removed">-             // No need to do a checkOldImpl() here, we know it&#39;s an up to date</span>
<span class="udiff-line-removed">-             // SocketImpl!</span>
<span class="udiff-line-removed">-             impl = new SocksSocketImpl();</span>
<span class="udiff-line-modified-added">+             impl = SocketImpl.createPlatformSocketImpl(true);</span>
          }
<span class="udiff-line-removed">-         if (impl != null)</span>
<span class="udiff-line-removed">-             impl.setServerSocket(this);</span>
      }
  
      /**
       * Creates the socket implementation.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -366,11 +376,11 @@</span>
       * @since 1.4
       */
      public void bind(SocketAddress endpoint, int backlog) throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="udiff-line-modified-removed">-         if (!oldImpl &amp;&amp; isBound())</span>
<span class="udiff-line-modified-added">+         if (isBound())</span>
              throw new SocketException(&quot;Already bound&quot;);
          if (endpoint == null)
              endpoint = new InetSocketAddress(0);
          if (!(endpoint instanceof InetSocketAddress))
              throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -497,17 +507,23 @@</span>
       * with {@code s.getInetAddress().getHostAddress()} and
       * {@code s.getPort()}
       * as its arguments to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
<span class="udiff-line-modified-removed">-      * @exception  IOException  if an I/O error occurs when waiting for a</span>
<span class="udiff-line-modified-added">+      * @implNote</span>
<span class="udiff-line-added">+      * An instance of this class using a system-default {@code SocketImpl}</span>
<span class="udiff-line-added">+      * accepts sockets with a {@code SocketImpl} of the same type, regardless</span>
<span class="udiff-line-added">+      * of the {@linkplain Socket#setSocketImplFactory(SocketImplFactory)</span>
<span class="udiff-line-added">+      * client socket implementation factory}, if one has been set.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @throws     IOException  if an I/O error occurs when waiting for a</span>
       *               connection.
<span class="udiff-line-modified-removed">-      * @exception  SecurityException  if a security manager exists and its</span>
<span class="udiff-line-modified-added">+      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkAccept} method doesn&#39;t allow the operation.
<span class="udiff-line-modified-removed">-      * @exception  SocketTimeoutException if a timeout was previously set with setSoTimeout and</span>
<span class="udiff-line-modified-added">+      * @throws     SocketTimeoutException if a timeout was previously set with setSoTimeout and</span>
       *             the timeout has been reached.
<span class="udiff-line-modified-removed">-      * @exception  java.nio.channels.IllegalBlockingModeException</span>
<span class="udiff-line-modified-added">+      * @throws     java.nio.channels.IllegalBlockingModeException</span>
       *             if this socket has an associated channel, the channel is in
       *             non-blocking mode, and there is no connection ready to be
       *             accepted
       *
       * @return the new Socket
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -526,56 +542,170 @@</span>
      }
  
      /**
       * Subclasses of ServerSocket use this method to override accept()
       * to return their own subclass of socket.  So a FooServerSocket
<span class="udiff-line-modified-removed">-      * will typically hand this method an &lt;i&gt;empty&lt;/i&gt; FooSocket.  On</span>
<span class="udiff-line-modified-removed">-      * return from implAccept the FooSocket will be connected to a client.</span>
<span class="udiff-line-modified-added">+      * will typically hand this method a newly created, unbound, FooSocket.</span>
<span class="udiff-line-modified-added">+      * On return from implAccept the FooSocket will be connected to a client.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt; The behavior of this method is unspecified when invoked with a</span>
<span class="udiff-line-added">+      * socket that is not newly created and unbound. Any socket options set</span>
<span class="udiff-line-added">+      * on the given socket prior to invoking this method may or may not be</span>
<span class="udiff-line-added">+      * preserved when the connection is accepted. It may not be possible to</span>
<span class="udiff-line-added">+      * accept a connection when this socket has a {@code SocketImpl} of one</span>
<span class="udiff-line-added">+      * type and the given socket has a {@code SocketImpl} of a completely</span>
<span class="udiff-line-added">+      * different type.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @implNote</span>
<span class="udiff-line-added">+      * An instance of this class using a system-default {@code SocketImpl}</span>
<span class="udiff-line-added">+      * can accept a connection with a Socket using a {@code SocketImpl} of</span>
<span class="udiff-line-added">+      * the same type: {@code IOException} is thrown if the Socket is using</span>
<span class="udiff-line-added">+      * a custom {@code SocketImpl}. An instance of this class using a</span>
<span class="udiff-line-added">+      * custom {@code SocketImpl} cannot accept a connection with a Socket</span>
<span class="udiff-line-added">+      * using a system-default {@code SocketImpl}.</span>
       *
       * @param s the Socket
       * @throws java.nio.channels.IllegalBlockingModeException
       *         if this socket has an associated channel,
       *         and the channel is in non-blocking mode
       * @throws IOException if an I/O error occurs when waiting
<span class="udiff-line-modified-removed">-      * for a connection.</span>
<span class="udiff-line-modified-added">+      *         for a connection, or if it is not possible for this socket</span>
<span class="udiff-line-added">+      *         to accept a connection with the given socket</span>
<span class="udiff-line-added">+      *</span>
       * @since   1.1
       * @revised 1.4
       * @spec JSR-51
       */
      protected final void implAccept(Socket s) throws IOException {
<span class="udiff-line-modified-removed">-         SocketImpl si = null;</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             if (s.impl == null)</span>
<span class="udiff-line-modified-removed">-               s.setImpl();</span>
<span class="udiff-line-modified-removed">-             else {</span>
<span class="udiff-line-modified-removed">-                 s.impl.reset();</span>
<span class="udiff-line-modified-added">+         SocketImpl si = s.impl;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // Socket has no SocketImpl</span>
<span class="udiff-line-modified-added">+         if (si == null) {</span>
<span class="udiff-line-modified-added">+             si = implAccept();</span>
<span class="udiff-line-modified-added">+             s.setImpl(si);</span>
<span class="udiff-line-added">+             s.postAccept();</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Socket has a SOCKS or HTTP SocketImpl, need delegate</span>
<span class="udiff-line-added">+         if (si instanceof DelegatingSocketImpl) {</span>
<span class="udiff-line-added">+             si = ((DelegatingSocketImpl) si).delegate();</span>
<span class="udiff-line-added">+             assert si instanceof PlatformSocketImpl;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Accept connection with a platform or custom SocketImpl.</span>
<span class="udiff-line-added">+         // For the platform SocketImpl case:</span>
<span class="udiff-line-added">+         // - the connection is accepted with a new SocketImpl</span>
<span class="udiff-line-added">+         // - the SO_TIMEOUT socket option is copied to the new SocketImpl</span>
<span class="udiff-line-added">+         // - the Socket is connected to the new SocketImpl</span>
<span class="udiff-line-added">+         // - the existing/old SocketImpl is closed</span>
<span class="udiff-line-added">+         // For the custom SocketImpl case, the connection is accepted with the</span>
<span class="udiff-line-added">+         // existing custom SocketImpl.</span>
<span class="udiff-line-added">+         ensureCompatible(si);</span>
<span class="udiff-line-added">+         if (impl instanceof PlatformSocketImpl) {</span>
<span class="udiff-line-added">+             SocketImpl psi = platformImplAccept();</span>
<span class="udiff-line-added">+             si.copyOptionsTo(psi);</span>
<span class="udiff-line-added">+             s.setImpl(psi);</span>
<span class="udiff-line-added">+             si.closeQuietly();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             s.impl = null; // temporarily break connection to impl</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 customImplAccept(si);</span>
<span class="udiff-line-added">+             } finally {</span>
<span class="udiff-line-added">+                 s.impl = si;  // restore connection to impl</span>
              }
<span class="udiff-line-modified-removed">-             si = s.impl;</span>
<span class="udiff-line-modified-removed">-             s.impl = null;</span>
<span class="udiff-line-modified-removed">-             si.address = new InetAddress();</span>
<span class="udiff-line-removed">-             si.fd = new FileDescriptor();</span>
<span class="udiff-line-removed">-             getImpl().accept(si);</span>
<span class="udiff-line-removed">-             SocketCleanable.register(si.fd);   // raw fd has been set</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         s.postAccept();</span>
<span class="udiff-line-modified-added">+     }</span>
  
<span class="udiff-line-modified-removed">-             SecurityManager security = System.getSecurityManager();</span>
<span class="udiff-line-modified-removed">-             if (security != null) {</span>
<span class="udiff-line-modified-removed">-                 security.checkAccept(si.getInetAddress().getHostAddress(),</span>
<span class="udiff-line-modified-removed">-                                      si.getPort());</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Accepts a connection with a new SocketImpl.</span>
<span class="udiff-line-modified-added">+      * @return the new SocketImpl</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-added">+     private SocketImpl implAccept() throws IOException {</span>
<span class="udiff-line-added">+         if (impl instanceof PlatformSocketImpl) {</span>
<span class="udiff-line-added">+             return platformImplAccept();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // custom server SocketImpl, client SocketImplFactory must be set</span>
<span class="udiff-line-added">+             SocketImplFactory factory = Socket.socketImplFactory();</span>
<span class="udiff-line-added">+             if (factory == null) {</span>
<span class="udiff-line-added">+                 throw new IOException(&quot;An instance of &quot; + impl.getClass() +</span>
<span class="udiff-line-added">+                     &quot; cannot accept connection with &#39;null&#39; SocketImpl:&quot; +</span>
<span class="udiff-line-added">+                     &quot; client socket implementation factory not set&quot;);</span>
              }
<span class="udiff-line-modified-removed">-         } catch (IOException e) {</span>
<span class="udiff-line-modified-removed">-             if (si != null)</span>
<span class="udiff-line-modified-removed">-                 si.reset();</span>
<span class="udiff-line-modified-removed">-             s.impl = si;</span>
<span class="udiff-line-modified-removed">-             throw e;</span>
<span class="udiff-line-modified-removed">-         } catch (SecurityException e) {</span>
<span class="udiff-line-modified-removed">-             if (si != null)</span>
<span class="udiff-line-modified-removed">-                 si.reset();</span>
<span class="udiff-line-modified-removed">-             s.impl = si;</span>
<span class="udiff-line-modified-added">+             SocketImpl si = factory.createSocketImpl();</span>
<span class="udiff-line-modified-added">+             customImplAccept(si);</span>
<span class="udiff-line-modified-added">+             return si;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Accepts a connection with a new platform SocketImpl.</span>
<span class="udiff-line-modified-added">+      * @return the new platform SocketImpl</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private SocketImpl platformImplAccept() throws IOException {</span>
<span class="udiff-line-added">+         assert impl instanceof PlatformSocketImpl;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // create a new platform SocketImpl and accept the connection</span>
<span class="udiff-line-added">+         SocketImpl psi = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="udiff-line-added">+         implAccept(psi);</span>
<span class="udiff-line-added">+         return psi;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Accepts a new connection with the given custom SocketImpl.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void customImplAccept(SocketImpl si) throws IOException {</span>
<span class="udiff-line-added">+         assert !(impl instanceof PlatformSocketImpl)</span>
<span class="udiff-line-added">+                 &amp;&amp; !(si instanceof PlatformSocketImpl);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         si.reset();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             // custom SocketImpl may expect fd/address objects to be created</span>
<span class="udiff-line-added">+             si.fd = new FileDescriptor();</span>
<span class="udiff-line-added">+             si.address = new InetAddress();</span>
<span class="udiff-line-added">+             implAccept(si);</span>
<span class="udiff-line-added">+         } catch (Exception e) {</span>
<span class="udiff-line-added">+             si.reset();</span>
              throw e;
          }
<span class="udiff-line-modified-removed">-         s.impl = si;</span>
<span class="udiff-line-modified-removed">-         s.postAccept();</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Accepts a new connection so that the given SocketImpl is connected to</span>
<span class="udiff-line-added">+      * the peer. The SocketImpl and connection are closed if the connection is</span>
<span class="udiff-line-added">+      * denied by the security manager.</span>
<span class="udiff-line-added">+      * @throws IOException if an I/O error occurs</span>
<span class="udiff-line-added">+      * @throws SecurityException if the security manager&#39;s checkAccept method fails</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void implAccept(SocketImpl si) throws IOException {</span>
<span class="udiff-line-added">+         assert !(si instanceof DelegatingSocketImpl);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // accept a connection</span>
<span class="udiff-line-added">+         impl.accept(si);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // check permission, close SocketImpl/connection if denied</span>
<span class="udiff-line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="udiff-line-added">+         if (sm != null) {</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 sm.checkAccept(si.getInetAddress().getHostAddress(), si.getPort());</span>
<span class="udiff-line-added">+             } catch (SecurityException se) {</span>
<span class="udiff-line-added">+                 si.close();</span>
<span class="udiff-line-added">+                 throw se;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Throws IOException if the server SocketImpl and the given client</span>
<span class="udiff-line-added">+      * SocketImpl are not both platform or custom SocketImpls.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void ensureCompatible(SocketImpl si) throws IOException {</span>
<span class="udiff-line-added">+         if ((impl instanceof PlatformSocketImpl) != (si instanceof PlatformSocketImpl)) {</span>
<span class="udiff-line-added">+             throw new IOException(&quot;An instance of &quot; + impl.getClass() +</span>
<span class="udiff-line-added">+                 &quot; cannot accept a connection with an instance of &quot; + si.getClass());</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Closes this socket.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -583,11 +713,11 @@</span>
       * a {@link SocketException}.
       *
       * &lt;p&gt; If this socket has an associated channel then the channel is closed
       * as well.
       *
<span class="udiff-line-modified-removed">-      * @exception  IOException  if an I/O error occurs when closing the socket.</span>
<span class="udiff-line-modified-added">+      * @throws     IOException  if an I/O error occurs when closing the socket.</span>
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() throws IOException {
          synchronized(closeLock) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -619,17 +749,20 @@</span>
          return null;
      }
  
      /**
       * Returns the binding state of the ServerSocket.
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * If the socket was bound prior to being {@linkplain #close closed},</span>
<span class="udiff-line-added">+      * then this method will continue to return {@code true}</span>
<span class="udiff-line-added">+      * after the socket is closed.</span>
       *
       * @return true if the ServerSocket successfully bound to an address
       * @since 1.4
       */
      public boolean isBound() {
<span class="udiff-line-modified-removed">-         // Before 1.3 ServerSockets were always bound during creation</span>
<span class="udiff-line-removed">-         return bound || oldImpl;</span>
<span class="udiff-line-modified-added">+         return bound;</span>
      }
  
      /**
       * Returns the closed state of the ServerSocket.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -642,35 +775,39 @@</span>
          }
      }
  
      /**
       * Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} with the
<span class="udiff-line-modified-removed">-      * specified timeout, in milliseconds.  With this option set to a non-zero</span>
<span class="udiff-line-modified-removed">-      * timeout, a call to accept() for this ServerSocket</span>
<span class="udiff-line-modified-added">+      * specified timeout, in milliseconds.  With this option set to a positive</span>
<span class="udiff-line-modified-added">+      * timeout value, a call to accept() for this ServerSocket</span>
       * will block for only this amount of time.  If the timeout expires,
       * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="udiff-line-modified-removed">-      * ServerSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled</span>
<span class="udiff-line-modified-removed">-      * prior to entering the blocking operation to have effect.  The</span>
<span class="udiff-line-modified-removed">-      * timeout must be {@code &gt; 0}.</span>
<span class="udiff-line-modified-removed">-      * A timeout of zero is interpreted as an infinite timeout.</span>
<span class="udiff-line-modified-added">+      * ServerSocket is still valid. A timeout of zero is interpreted as an</span>
<span class="udiff-line-modified-added">+      * infinite timeout.</span>
<span class="udiff-line-modified-added">+      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking</span>
<span class="udiff-line-modified-added">+      * operation to have effect.</span>
<span class="udiff-line-added">+      *</span>
       * @param timeout the specified timeout, in milliseconds
<span class="udiff-line-modified-removed">-      * @exception SocketException if there is an error in</span>
<span class="udiff-line-modified-removed">-      * the underlying protocol, such as a TCP error.</span>
<span class="udiff-line-modified-added">+      * @throws  SocketException if there is an error in the underlying protocol,</span>
<span class="udiff-line-modified-added">+      *          such as a TCP error</span>
<span class="udiff-line-added">+      * @throws  IllegalArgumentException  if {@code timeout} is negative</span>
       * @since   1.1
       * @see #getSoTimeout()
       */
      public synchronized void setSoTimeout(int timeout) throws SocketException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="udiff-line-added">+         if (timeout &lt; 0)</span>
<span class="udiff-line-added">+             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
          getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
      }
  
      /**
       * Retrieve setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
       * 0 returns implies that the option is disabled (i.e., timeout of infinity).
       * @return the {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} value
<span class="udiff-line-modified-removed">-      * @exception IOException if an I/O error occurs</span>
<span class="udiff-line-modified-added">+      * @throws    IOException if an I/O error occurs</span>
       * @since   1.1
       * @see #setSoTimeout(int)
       */
      public synchronized int getSoTimeout() throws IOException {
          if (isClosed())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -709,11 +846,11 @@</span>
       * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
       * enabled or disabled after a socket is bound (See {@link #isBound()})
       * is not defined.
       *
       * @param on  whether to enable or disable the socket option
<span class="udiff-line-modified-removed">-      * @exception SocketException if an error occurs enabling or</span>
<span class="udiff-line-modified-added">+      * @throws    SocketException if an error occurs enabling or</span>
       *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
       *            socket option, or the socket is closed.
       * @since 1.4
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -729,11 +866,11 @@</span>
      /**
       * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
       *
       * @return a {@code boolean} indicating whether or not
       *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="udiff-line-modified-removed">-      * @exception SocketException if there is an error</span>
<span class="udiff-line-modified-added">+      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
      public boolean getReuseAddress() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -744,11 +881,12 @@</span>
  
      /**
       * Returns the implementation address and implementation port of
       * this socket as a {@code String}.
       * &lt;p&gt;
<span class="udiff-line-modified-removed">-      * If there is a security manager set, its {@code checkConnect} method is</span>
<span class="udiff-line-modified-added">+      * If there is a security manager set, and this socket is</span>
<span class="udiff-line-added">+      * {@linkplain #isBound bound}, its {@code checkConnect} method is</span>
       * called with the local address and {@code -1} as its arguments to see
       * if the operation is allowed. If the operation is not allowed,
       * an {@code InetAddress} representing the
       * {@link InetAddress#getLoopbackAddress loopback} address is returned as
       * the implementation address.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -758,29 +896,21 @@</span>
      public String toString() {
          if (!isBound())
              return &quot;ServerSocket[unbound]&quot;;
          InetAddress in;
          if (System.getSecurityManager() != null)
<span class="udiff-line-modified-removed">-             in = InetAddress.getLoopbackAddress();</span>
<span class="udiff-line-modified-added">+             in = getInetAddress();</span>
          else
              in = impl.getInetAddress();
          return &quot;ServerSocket[addr=&quot; + in +
                  &quot;,localport=&quot; + impl.getLocalPort()  + &quot;]&quot;;
      }
  
<span class="udiff-line-removed">-     void setBound() {</span>
<span class="udiff-line-removed">-         bound = true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void setCreated() {</span>
<span class="udiff-line-removed">-         created = true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * The factory for all server sockets.
       */
<span class="udiff-line-modified-removed">-     private static SocketImplFactory factory = null;</span>
<span class="udiff-line-modified-added">+     private static volatile SocketImplFactory factory;</span>
  
      /**
       * Sets the server socket implementation factory for the
       * application. The factory can be specified only once.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -795,14 +925,14 @@</span>
       * the security manager&#39;s {@code checkSetFactory} method
       * to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      fac   the desired factory.
<span class="udiff-line-modified-removed">-      * @exception  IOException  if an I/O error occurs when setting the</span>
<span class="udiff-line-modified-added">+      * @throws     IOException  if an I/O error occurs when setting the</span>
       *               socket factory.
<span class="udiff-line-modified-removed">-      * @exception  SocketException  if the factory has already been defined.</span>
<span class="udiff-line-modified-removed">-      * @exception  SecurityException  if a security manager exists and its</span>
<span class="udiff-line-modified-added">+      * @throws     SocketException  if the factory has already been defined.</span>
<span class="udiff-line-modified-added">+      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkSetFactory} method doesn&#39;t allow the operation.
       * @see        java.net.SocketImplFactory#createSocketImpl()
       * @see        SecurityManager#checkSetFactory
       */
      public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -838,17 +968,17 @@</span>
       * &lt;p&gt;
       * Failure to do this will not cause an error, and the buffer size may be set to the
       * requested value but the TCP receive window in sockets accepted from
       * this ServerSocket will be no larger than 64K bytes.
       *
<span class="udiff-line-modified-removed">-      * @exception SocketException if there is an error</span>
<span class="udiff-line-modified-added">+      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as a TCP error.
       *
       * @param size the size to which to set the receive buffer
       * size. This value must be greater than 0.
       *
<span class="udiff-line-modified-removed">-      * @exception IllegalArgumentException if the</span>
<span class="udiff-line-modified-added">+      * @throws    IllegalArgumentException if the</span>
       * value is 0 or is negative.
       *
       * @since 1.4
       * @see #getReceiveBufferSize
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -868,11 +998,11 @@</span>
       *
       * &lt;p&gt;Note, the value actually set in the accepted socket is determined by
       * calling {@link Socket#getReceiveBufferSize()}.
       * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
       *         option for this {@code Socket}.
<span class="udiff-line-modified-removed">-      * @exception SocketException if there is an error</span>
<span class="udiff-line-modified-added">+      * @throws    SocketException if there is an error</span>
       *            in the underlying protocol, such as a TCP error.
       * @see #setReceiveBufferSize(int)
       * @since 1.4
       */
      public synchronized int getReceiveBufferSize()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -960,10 +1090,13 @@</span>
       * @since 9
       */
      public &lt;T&gt; ServerSocket setOption(SocketOption&lt;T&gt; name, T value)
          throws IOException
      {
<span class="udiff-line-added">+         Objects.requireNonNull(name);</span>
<span class="udiff-line-added">+         if (isClosed())</span>
<span class="udiff-line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          getImpl().setOption(name, value);
          return this;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -988,10 +1121,13 @@</span>
       *         do not require any security permission.
       *
       * @since 9
       */
      public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="udiff-line-added">+         Objects.requireNonNull(name);</span>
<span class="udiff-line-added">+         if (isClosed())</span>
<span class="udiff-line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          return getImpl().getOption(name);
      }
  
      // cache of unmodifiable impl options. Possibly set racy, in impl we trust
      private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1018,29 +1154,6 @@</span>
          } catch (IOException e) {
              options = Collections.emptySet();
          }
          return options;
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static {</span>
<span class="udiff-line-removed">-         SharedSecrets.setJavaNetSocketAccess(</span>
<span class="udiff-line-removed">-             new JavaNetSocketAccess() {</span>
<span class="udiff-line-removed">-                 @Override</span>
<span class="udiff-line-removed">-                 public ServerSocket newServerSocket(SocketImpl impl) {</span>
<span class="udiff-line-removed">-                     return new ServerSocket(impl);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 @Override</span>
<span class="udiff-line-removed">-                 public SocketImpl newSocketImpl(Class&lt;? extends SocketImpl&gt; implClass) {</span>
<span class="udiff-line-removed">-                     try {</span>
<span class="udiff-line-removed">-                         Constructor&lt;? extends SocketImpl&gt; ctor =</span>
<span class="udiff-line-removed">-                             implClass.getDeclaredConstructor();</span>
<span class="udiff-line-removed">-                         return ctor.newInstance();</span>
<span class="udiff-line-removed">-                     } catch (NoSuchMethodException | InstantiationException |</span>
<span class="udiff-line-removed">-                              IllegalAccessException | InvocationTargetException e) {</span>
<span class="udiff-line-removed">-                         throw new AssertionError(e);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         );</span>
<span class="udiff-line-removed">-     }</span>
  }
</pre>
<center><a href="ProxySelector.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Socket.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
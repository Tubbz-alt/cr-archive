<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StringCharBuffer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="channels/AsynchronousChannelGroup.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/X-Buffer.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #warn This file is preprocessed before being compiled
  27 
  28 package java.nio;
  29 
  30 #if[char]
  31 import java.io.IOException;
  32 #end[char]
  33 #if[streamableType]
  34 import java.util.Spliterator;
  35 import java.util.stream.StreamSupport;
  36 import java.util.stream.$Streamtype$Stream;
  37 #end[streamableType]
  38 
  39 import java.util.Objects;

  40 import jdk.internal.util.ArraysSupport;
  41 
  42 /**
  43  * $A$ $type$ buffer.
  44  *
  45  * &lt;p&gt; This class defines {#if[byte]?six:four} categories of operations upon
  46  * $type$ buffers:
  47  *
  48  * &lt;ul&gt;
  49  *
  50  *   &lt;li&gt;&lt;p&gt; Absolute and relative {@link #get() &lt;i&gt;get&lt;/i&gt;} and
  51  *   {@link #put($type$) &lt;i&gt;put&lt;/i&gt;} methods that read and write
  52  *   single $type$s; &lt;/p&gt;&lt;/li&gt;
  53  *
  54  *   &lt;li&gt;&lt;p&gt; Absolute and relative {@link #get($type$[]) &lt;i&gt;bulk get&lt;/i&gt;}
  55  *   methods that transfer contiguous sequences of $type$s from this buffer
  56  *   into an array; {#if[!byte]?and}&lt;/p&gt;&lt;/li&gt;
  57  *
  58  *   &lt;li&gt;&lt;p&gt; Absolute and relative {@link #put($type$[]) &lt;i&gt;bulk put&lt;/i&gt;}
  59  *   methods that transfer contiguous sequences of $type$s from $a$
</pre>
<hr />
<pre>
 262  * @since 1.4
 263  */
 264 
 265 public abstract class $Type$Buffer
 266     extends Buffer
 267     implements Comparable&lt;$Type$Buffer&gt;{#if[char]?, Appendable, CharSequence, Readable}
 268 {
 269 
 270     // These fields are declared here rather than in Heap-X-Buffer in order to
 271     // reduce the number of virtual method invocations needed to access these
 272     // values, which is especially costly when coding small buffers.
 273     //
 274     final $type$[] hb;                  // Non-null only for heap buffers
 275     final int offset;
 276     boolean isReadOnly;
 277 
 278     // Creates a new buffer with the given mark, position, limit, capacity,
 279     // backing array, and array offset
 280     //
 281     $Type$Buffer(int mark, int pos, int lim, int cap,   // package-private
<span class="line-modified"> 282                  $type$[] hb, int offset)</span>
 283     {
<span class="line-modified"> 284         super(mark, pos, lim, cap);</span>
 285         this.hb = hb;
 286         this.offset = offset;
 287     }
 288 
 289     // Creates a new buffer with the given mark, position, limit, and capacity
 290     //
<span class="line-modified"> 291     $Type$Buffer(int mark, int pos, int lim, int cap) { // package-private</span>
<span class="line-modified"> 292         this(mark, pos, lim, cap, null, 0);</span>








 293     }
 294 
 295     @Override
 296     Object base() {
 297         return hb;
 298     }
 299 
 300 #if[byte]
 301 
 302     /**
 303      * Allocates a new direct $type$ buffer.
 304      *
 305      * &lt;p&gt; The new buffer&#39;s position will be zero, its limit will be its
 306      * capacity, its mark will be undefined, each of its elements will be
 307      * initialized to zero, and its byte order will be
 308      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.  Whether or not it has a
 309      * {@link #hasArray backing array} is unspecified.
 310      *
 311      * @param  capacity
 312      *         The new buffer&#39;s capacity, in $type$s
</pre>
<hr />
<pre>
 331 #if[byte]
 332      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 333 #else[byte]
 334      * the {@link ByteOrder#nativeOrder native order} of the underlying
 335      * hardware.
 336 #end[byte]
 337      * It will have a {@link #array backing array}, and its
 338      * {@link #arrayOffset array offset} will be zero.
 339      *
 340      * @param  capacity
 341      *         The new buffer&#39;s capacity, in $type$s
 342      *
 343      * @return  The new $type$ buffer
 344      *
 345      * @throws  IllegalArgumentException
 346      *          If the {@code capacity} is a negative integer
 347      */
 348     public static $Type$Buffer allocate(int capacity) {
 349         if (capacity &lt; 0)
 350             throw createCapacityException(capacity);
<span class="line-modified"> 351         return new Heap$Type$Buffer(capacity, capacity);</span>
 352     }
 353 
 354     /**
 355      * Wraps $a$ $type$ array into a buffer.
 356      *
 357      * &lt;p&gt; The new buffer will be backed by the given $type$ array;
 358      * that is, modifications to the buffer will cause the array to be modified
 359      * and vice versa.  The new buffer&#39;s capacity will be
 360      * {@code array.length}, its position will be {@code offset}, its limit
 361      * will be {@code offset + length}, its mark will be undefined, and its
 362      * byte order will be
 363 #if[byte]
 364      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 365 #else[byte]
 366      * the {@link ByteOrder#nativeOrder native order} of the underlying
 367      * hardware.
 368 #end[byte]
 369      * Its {@link #array backing array} will be the given array, and
 370      * its {@link #arrayOffset array offset} will be zero.  &lt;/p&gt;
 371      *
</pre>
<hr />
<pre>
 376      *         The offset of the subarray to be used; must be non-negative and
 377      *         no larger than {@code array.length}.  The new buffer&#39;s position
 378      *         will be set to this value.
 379      *
 380      * @param  length
 381      *         The length of the subarray to be used;
 382      *         must be non-negative and no larger than
 383      *         {@code array.length - offset}.
 384      *         The new buffer&#39;s limit will be set to {@code offset + length}.
 385      *
 386      * @return  The new $type$ buffer
 387      *
 388      * @throws  IndexOutOfBoundsException
 389      *          If the preconditions on the {@code offset} and {@code length}
 390      *          parameters do not hold
 391      */
 392     public static $Type$Buffer wrap($type$[] array,
 393                                     int offset, int length)
 394     {
 395         try {
<span class="line-modified"> 396             return new Heap$Type$Buffer(array, offset, length);</span>
 397         } catch (IllegalArgumentException x) {
 398             throw new IndexOutOfBoundsException();
 399         }
 400     }
 401 
 402     /**
 403      * Wraps $a$ $type$ array into a buffer.
 404      *
 405      * &lt;p&gt; The new buffer will be backed by the given $type$ array;
 406      * that is, modifications to the buffer will cause the array to be modified
 407      * and vice versa.  The new buffer&#39;s capacity and limit will be
 408      * {@code array.length}, its position will be zero, its mark will be
 409      * undefined, and its byte order will be
 410 #if[byte]
 411      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 412 #else[byte]
 413      * the {@link ByteOrder#nativeOrder native order} of the underlying
 414      * hardware.
 415 #end[byte]
 416      * Its {@link #array backing array} will be the given array, and its
</pre>
<hr />
<pre>
 755      *         The offset within the array of the first $type$ to be
 756      *         written; must be non-negative and no larger than
 757      *         {@code dst.length}
 758      *
 759      * @param  length
 760      *         The maximum number of $type$s to be written to the given
 761      *         array; must be non-negative and no larger than
 762      *         {@code dst.length - offset}
 763      *
 764      * @return  This buffer
 765      *
 766      * @throws  BufferUnderflowException
 767      *          If there are fewer than {@code length} $type$s
 768      *          remaining in this buffer
 769      *
 770      * @throws  IndexOutOfBoundsException
 771      *          If the preconditions on the {@code offset} and {@code length}
 772      *          parameters do not hold
 773      */
 774     public $Type$Buffer get($type$[] dst, int offset, int length) {
<span class="line-modified"> 775         checkBounds(offset, length, dst.length);</span>
 776         if (length &gt; remaining())
 777             throw new BufferUnderflowException();
 778         int end = offset + length;
 779         for (int i = offset; i &lt; end; i++)
 780             dst[i] = get();
 781         return this;
 782     }
 783 
 784     /**
 785      * Relative bulk &lt;i&gt;get&lt;/i&gt; method.
 786      *
 787      * &lt;p&gt; This method transfers $type$s from this buffer into the given
 788      * destination array.  An invocation of this method of the form
 789      * {@code src.get(a)} behaves in exactly the same way as the invocation
 790      *
 791      * &lt;pre&gt;
 792      *     src.get(a, 0, a.length) &lt;/pre&gt;
 793      *
 794      * @param   dst
 795      *          The destination array
</pre>
<hr />
<pre>
 979      *         must be non-negative and no larger than {@code src.length}
 980      *
 981      * @param  length
 982      *         The number of $type$s to be read from the given array;
 983      *         must be non-negative and no larger than
 984      *         {@code src.length - offset}
 985      *
 986      * @return  This buffer
 987      *
 988      * @throws  BufferOverflowException
 989      *          If there is insufficient space in this buffer
 990      *
 991      * @throws  IndexOutOfBoundsException
 992      *          If the preconditions on the {@code offset} and {@code length}
 993      *          parameters do not hold
 994      *
 995      * @throws  ReadOnlyBufferException
 996      *          If this buffer is read-only
 997      */
 998     public $Type$Buffer put($type$[] src, int offset, int length) {
<span class="line-modified"> 999         checkBounds(offset, length, src.length);</span>
1000         if (length &gt; remaining())
1001             throw new BufferOverflowException();
1002         int end = offset + length;
1003         for (int i = offset; i &lt; end; i++)
1004             this.put(src[i]);
1005         return this;
1006     }
1007 
1008     /**
1009      * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
1010      *
1011      * &lt;p&gt; This method transfers the entire content of the given source
1012      * $type$ array into this buffer.  An invocation of this method of the
1013      * form {@code dst.put(a)} behaves in exactly the same way as the
1014      * invocation
1015      *
1016      * &lt;pre&gt;
1017      *     dst.put(a, 0, a.length) &lt;/pre&gt;
1018      *
1019      * @param   src
</pre>
<hr />
<pre>
1159      *         {@code string.length()}
1160      *
1161      * @param  end
1162      *         The offset within the string of the last $type$ to be read,
1163      *         plus one; must be non-negative and no larger than
1164      *         {@code string.length()}
1165      *
1166      * @return  This buffer
1167      *
1168      * @throws  BufferOverflowException
1169      *          If there is insufficient space in this buffer
1170      *
1171      * @throws  IndexOutOfBoundsException
1172      *          If the preconditions on the {@code start} and {@code end}
1173      *          parameters do not hold
1174      *
1175      * @throws  ReadOnlyBufferException
1176      *          If this buffer is read-only
1177      */
1178     public $Type$Buffer put(String src, int start, int end) {
<span class="line-modified">1179         checkBounds(start, end - start, src.length());</span>
1180         if (isReadOnly())
1181             throw new ReadOnlyBufferException();
1182         if (end - start &gt; remaining())
1183             throw new BufferOverflowException();
1184         for (int i = start; i &lt; end; i++)
1185             this.put(src.charAt(i));
1186         return this;
1187     }
1188 
1189     /**
1190      * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
1191      *
1192      * &lt;p&gt; This method transfers the entire content of the given source string
1193      * into this buffer.  An invocation of this method of the form
1194      * {@code dst.put(s)} behaves in exactly the same way as the invocation
1195      *
1196      * &lt;pre&gt;
1197      *     dst.put(s, 0, s.length()) &lt;/pre&gt;
1198      *
1199      * @param   src
</pre>
<hr />
<pre>
1843 
1844     /**
1845      * Modifies this buffer&#39;s byte order.
1846      *
1847      * @param  bo
1848      *         The new byte order,
1849      *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}
1850      *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}
1851      *
1852      * @return  This buffer
1853      */
1854     public final $Type$Buffer order(ByteOrder bo) {
1855         bigEndian = (bo == ByteOrder.BIG_ENDIAN);
1856         nativeByteOrder =
1857             (bigEndian == (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN));
1858         return this;
1859     }
1860 
1861     /**
1862      * Returns the memory address, pointing to the byte at the given index,
<span class="line-modified">1863      * modulus the given unit size.</span>
<span class="line-modified">1864      *</span>
<span class="line-modified">1865      * &lt;p&gt; A return value greater than zero indicates the address of the byte at</span>
<span class="line-modified">1866      * the index is misaligned for the unit size, and the value&#39;s quantity</span>
<span class="line-modified">1867      * indicates how much the index should be rounded up or down to locate a</span>
<span class="line-modified">1868      * byte at an aligned address.  Otherwise, a value of {@code 0} indicates</span>
<span class="line-modified">1869      * that the address of the byte at the index is aligned for the unit size.</span>
<span class="line-modified">1870      *</span>













1871      * @apiNote
1872      * This method may be utilized to determine if unit size bytes from an
1873      * index can be accessed atomically, if supported by the native platform.
1874      *
1875      * @implNote
1876      * This implementation throws {@code UnsupportedOperationException} for
1877      * non-direct buffers when the given unit size is greater then {@code 8}.
1878      *
1879      * @param  index
1880      *         The index to query for alignment offset, must be non-negative, no
1881      *         upper bounds check is performed
1882      *
1883      * @param  unitSize
1884      *         The unit size in bytes, must be a power of {@code 2}
1885      *
<span class="line-modified">1886      * @return  The indexed byte&#39;s memory address modulus the unit size</span>
1887      *
1888      * @throws IllegalArgumentException
1889      *         If the index is negative or the unit size is not a power of
1890      *         {@code 2}
1891      *
1892      * @throws UnsupportedOperationException
1893      *         If the native platform does not guarantee stable alignment offset
1894      *         values for the given unit size when managing the memory regions
1895      *         of buffers of the same kind as this buffer (direct or
1896      *         non-direct).  For example, if garbage collection would result
1897      *         in the moving of a memory region covered by a non-direct buffer
1898      *         from one location to another and both locations have different
1899      *         alignment characteristics.
1900      *
1901      * @see #alignedSlice(int)
1902      * @since 9
1903      */
1904     public final int alignmentOffset(int index, int unitSize) {
1905         if (index &lt; 0)
1906             throw new IllegalArgumentException(&quot;Index less than zero: &quot; + index);
1907         if (unitSize &lt; 1 || (unitSize &amp; (unitSize - 1)) != 0)
1908             throw new IllegalArgumentException(&quot;Unit size not a power of two: &quot; + unitSize);
1909         if (unitSize &gt; 8 &amp;&amp; !isDirect())
1910             throw new UnsupportedOperationException(&quot;Unit size unsupported for non-direct buffers: &quot; + unitSize);
1911 
<span class="line-modified">1912         return (int) ((address + index) % unitSize);</span>
1913     }
1914 
1915     /**
1916      * Creates a new byte buffer whose content is a shared and aligned
1917      * subsequence of this buffer&#39;s content.
1918      *
1919      * &lt;p&gt; The content of the new buffer will start at this buffer&#39;s current
1920      * position rounded up to the index of the nearest aligned byte for the
1921      * given unit size, and end at this buffer&#39;s limit rounded down to the index
1922      * of the nearest aligned byte for the given unit size.
1923      * If rounding results in out-of-bound values then the new buffer&#39;s capacity
1924      * and limit will be zero.  If rounding is within bounds the following
1925      * expressions will be true for a new buffer {@code nb} and unit size
1926      * {@code unitSize}:
1927      * &lt;pre&gt;{@code
1928      * nb.alignmentOffset(0, unitSize) == 0
1929      * nb.alignmentOffset(nb.limit(), unitSize) == 0
1930      * }&lt;/pre&gt;
1931      *
1932      * &lt;p&gt; Changes to this buffer&#39;s content will be visible in the new
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #warn This file is preprocessed before being compiled
  27 
  28 package java.nio;
  29 
  30 #if[char]
  31 import java.io.IOException;
  32 #end[char]
  33 #if[streamableType]
  34 import java.util.Spliterator;
  35 import java.util.stream.StreamSupport;
  36 import java.util.stream.$Streamtype$Stream;
  37 #end[streamableType]
  38 
  39 import java.util.Objects;
<span class="line-added">  40 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  41 import jdk.internal.util.ArraysSupport;
  42 
  43 /**
  44  * $A$ $type$ buffer.
  45  *
  46  * &lt;p&gt; This class defines {#if[byte]?six:four} categories of operations upon
  47  * $type$ buffers:
  48  *
  49  * &lt;ul&gt;
  50  *
  51  *   &lt;li&gt;&lt;p&gt; Absolute and relative {@link #get() &lt;i&gt;get&lt;/i&gt;} and
  52  *   {@link #put($type$) &lt;i&gt;put&lt;/i&gt;} methods that read and write
  53  *   single $type$s; &lt;/p&gt;&lt;/li&gt;
  54  *
  55  *   &lt;li&gt;&lt;p&gt; Absolute and relative {@link #get($type$[]) &lt;i&gt;bulk get&lt;/i&gt;}
  56  *   methods that transfer contiguous sequences of $type$s from this buffer
  57  *   into an array; {#if[!byte]?and}&lt;/p&gt;&lt;/li&gt;
  58  *
  59  *   &lt;li&gt;&lt;p&gt; Absolute and relative {@link #put($type$[]) &lt;i&gt;bulk put&lt;/i&gt;}
  60  *   methods that transfer contiguous sequences of $type$s from $a$
</pre>
<hr />
<pre>
 263  * @since 1.4
 264  */
 265 
 266 public abstract class $Type$Buffer
 267     extends Buffer
 268     implements Comparable&lt;$Type$Buffer&gt;{#if[char]?, Appendable, CharSequence, Readable}
 269 {
 270 
 271     // These fields are declared here rather than in Heap-X-Buffer in order to
 272     // reduce the number of virtual method invocations needed to access these
 273     // values, which is especially costly when coding small buffers.
 274     //
 275     final $type$[] hb;                  // Non-null only for heap buffers
 276     final int offset;
 277     boolean isReadOnly;
 278 
 279     // Creates a new buffer with the given mark, position, limit, capacity,
 280     // backing array, and array offset
 281     //
 282     $Type$Buffer(int mark, int pos, int lim, int cap,   // package-private
<span class="line-modified"> 283                  $type$[] hb, int offset, MemorySegmentProxy segment)</span>
 284     {
<span class="line-modified"> 285         super(mark, pos, lim, cap, segment);</span>
 286         this.hb = hb;
 287         this.offset = offset;
 288     }
 289 
 290     // Creates a new buffer with the given mark, position, limit, and capacity
 291     //
<span class="line-modified"> 292     $Type$Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) { // package-private</span>
<span class="line-modified"> 293         this(mark, pos, lim, cap, null, 0, segment);</span>
<span class="line-added"> 294     }</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296     // Creates a new buffer with given base, address and capacity</span>
<span class="line-added"> 297     //</span>
<span class="line-added"> 298     $Type$Buffer($type$[] hb, long addr, int cap, MemorySegmentProxy segment) { // package-private</span>
<span class="line-added"> 299         super(addr, cap, segment);</span>
<span class="line-added"> 300         this.hb = hb;</span>
<span class="line-added"> 301         this.offset = 0;</span>
 302     }
 303 
 304     @Override
 305     Object base() {
 306         return hb;
 307     }
 308 
 309 #if[byte]
 310 
 311     /**
 312      * Allocates a new direct $type$ buffer.
 313      *
 314      * &lt;p&gt; The new buffer&#39;s position will be zero, its limit will be its
 315      * capacity, its mark will be undefined, each of its elements will be
 316      * initialized to zero, and its byte order will be
 317      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.  Whether or not it has a
 318      * {@link #hasArray backing array} is unspecified.
 319      *
 320      * @param  capacity
 321      *         The new buffer&#39;s capacity, in $type$s
</pre>
<hr />
<pre>
 340 #if[byte]
 341      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 342 #else[byte]
 343      * the {@link ByteOrder#nativeOrder native order} of the underlying
 344      * hardware.
 345 #end[byte]
 346      * It will have a {@link #array backing array}, and its
 347      * {@link #arrayOffset array offset} will be zero.
 348      *
 349      * @param  capacity
 350      *         The new buffer&#39;s capacity, in $type$s
 351      *
 352      * @return  The new $type$ buffer
 353      *
 354      * @throws  IllegalArgumentException
 355      *          If the {@code capacity} is a negative integer
 356      */
 357     public static $Type$Buffer allocate(int capacity) {
 358         if (capacity &lt; 0)
 359             throw createCapacityException(capacity);
<span class="line-modified"> 360         return new Heap$Type$Buffer(capacity, capacity, null);</span>
 361     }
 362 
 363     /**
 364      * Wraps $a$ $type$ array into a buffer.
 365      *
 366      * &lt;p&gt; The new buffer will be backed by the given $type$ array;
 367      * that is, modifications to the buffer will cause the array to be modified
 368      * and vice versa.  The new buffer&#39;s capacity will be
 369      * {@code array.length}, its position will be {@code offset}, its limit
 370      * will be {@code offset + length}, its mark will be undefined, and its
 371      * byte order will be
 372 #if[byte]
 373      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 374 #else[byte]
 375      * the {@link ByteOrder#nativeOrder native order} of the underlying
 376      * hardware.
 377 #end[byte]
 378      * Its {@link #array backing array} will be the given array, and
 379      * its {@link #arrayOffset array offset} will be zero.  &lt;/p&gt;
 380      *
</pre>
<hr />
<pre>
 385      *         The offset of the subarray to be used; must be non-negative and
 386      *         no larger than {@code array.length}.  The new buffer&#39;s position
 387      *         will be set to this value.
 388      *
 389      * @param  length
 390      *         The length of the subarray to be used;
 391      *         must be non-negative and no larger than
 392      *         {@code array.length - offset}.
 393      *         The new buffer&#39;s limit will be set to {@code offset + length}.
 394      *
 395      * @return  The new $type$ buffer
 396      *
 397      * @throws  IndexOutOfBoundsException
 398      *          If the preconditions on the {@code offset} and {@code length}
 399      *          parameters do not hold
 400      */
 401     public static $Type$Buffer wrap($type$[] array,
 402                                     int offset, int length)
 403     {
 404         try {
<span class="line-modified"> 405             return new Heap$Type$Buffer(array, offset, length, null);</span>
 406         } catch (IllegalArgumentException x) {
 407             throw new IndexOutOfBoundsException();
 408         }
 409     }
 410 
 411     /**
 412      * Wraps $a$ $type$ array into a buffer.
 413      *
 414      * &lt;p&gt; The new buffer will be backed by the given $type$ array;
 415      * that is, modifications to the buffer will cause the array to be modified
 416      * and vice versa.  The new buffer&#39;s capacity and limit will be
 417      * {@code array.length}, its position will be zero, its mark will be
 418      * undefined, and its byte order will be
 419 #if[byte]
 420      * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 421 #else[byte]
 422      * the {@link ByteOrder#nativeOrder native order} of the underlying
 423      * hardware.
 424 #end[byte]
 425      * Its {@link #array backing array} will be the given array, and its
</pre>
<hr />
<pre>
 764      *         The offset within the array of the first $type$ to be
 765      *         written; must be non-negative and no larger than
 766      *         {@code dst.length}
 767      *
 768      * @param  length
 769      *         The maximum number of $type$s to be written to the given
 770      *         array; must be non-negative and no larger than
 771      *         {@code dst.length - offset}
 772      *
 773      * @return  This buffer
 774      *
 775      * @throws  BufferUnderflowException
 776      *          If there are fewer than {@code length} $type$s
 777      *          remaining in this buffer
 778      *
 779      * @throws  IndexOutOfBoundsException
 780      *          If the preconditions on the {@code offset} and {@code length}
 781      *          parameters do not hold
 782      */
 783     public $Type$Buffer get($type$[] dst, int offset, int length) {
<span class="line-modified"> 784         Objects.checkFromIndexSize(offset, length, dst.length);</span>
 785         if (length &gt; remaining())
 786             throw new BufferUnderflowException();
 787         int end = offset + length;
 788         for (int i = offset; i &lt; end; i++)
 789             dst[i] = get();
 790         return this;
 791     }
 792 
 793     /**
 794      * Relative bulk &lt;i&gt;get&lt;/i&gt; method.
 795      *
 796      * &lt;p&gt; This method transfers $type$s from this buffer into the given
 797      * destination array.  An invocation of this method of the form
 798      * {@code src.get(a)} behaves in exactly the same way as the invocation
 799      *
 800      * &lt;pre&gt;
 801      *     src.get(a, 0, a.length) &lt;/pre&gt;
 802      *
 803      * @param   dst
 804      *          The destination array
</pre>
<hr />
<pre>
 988      *         must be non-negative and no larger than {@code src.length}
 989      *
 990      * @param  length
 991      *         The number of $type$s to be read from the given array;
 992      *         must be non-negative and no larger than
 993      *         {@code src.length - offset}
 994      *
 995      * @return  This buffer
 996      *
 997      * @throws  BufferOverflowException
 998      *          If there is insufficient space in this buffer
 999      *
1000      * @throws  IndexOutOfBoundsException
1001      *          If the preconditions on the {@code offset} and {@code length}
1002      *          parameters do not hold
1003      *
1004      * @throws  ReadOnlyBufferException
1005      *          If this buffer is read-only
1006      */
1007     public $Type$Buffer put($type$[] src, int offset, int length) {
<span class="line-modified">1008         Objects.checkFromIndexSize(offset, length, src.length);</span>
1009         if (length &gt; remaining())
1010             throw new BufferOverflowException();
1011         int end = offset + length;
1012         for (int i = offset; i &lt; end; i++)
1013             this.put(src[i]);
1014         return this;
1015     }
1016 
1017     /**
1018      * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
1019      *
1020      * &lt;p&gt; This method transfers the entire content of the given source
1021      * $type$ array into this buffer.  An invocation of this method of the
1022      * form {@code dst.put(a)} behaves in exactly the same way as the
1023      * invocation
1024      *
1025      * &lt;pre&gt;
1026      *     dst.put(a, 0, a.length) &lt;/pre&gt;
1027      *
1028      * @param   src
</pre>
<hr />
<pre>
1168      *         {@code string.length()}
1169      *
1170      * @param  end
1171      *         The offset within the string of the last $type$ to be read,
1172      *         plus one; must be non-negative and no larger than
1173      *         {@code string.length()}
1174      *
1175      * @return  This buffer
1176      *
1177      * @throws  BufferOverflowException
1178      *          If there is insufficient space in this buffer
1179      *
1180      * @throws  IndexOutOfBoundsException
1181      *          If the preconditions on the {@code start} and {@code end}
1182      *          parameters do not hold
1183      *
1184      * @throws  ReadOnlyBufferException
1185      *          If this buffer is read-only
1186      */
1187     public $Type$Buffer put(String src, int start, int end) {
<span class="line-modified">1188         Objects.checkFromIndexSize(start, end - start, src.length());</span>
1189         if (isReadOnly())
1190             throw new ReadOnlyBufferException();
1191         if (end - start &gt; remaining())
1192             throw new BufferOverflowException();
1193         for (int i = start; i &lt; end; i++)
1194             this.put(src.charAt(i));
1195         return this;
1196     }
1197 
1198     /**
1199      * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
1200      *
1201      * &lt;p&gt; This method transfers the entire content of the given source string
1202      * into this buffer.  An invocation of this method of the form
1203      * {@code dst.put(s)} behaves in exactly the same way as the invocation
1204      *
1205      * &lt;pre&gt;
1206      *     dst.put(s, 0, s.length()) &lt;/pre&gt;
1207      *
1208      * @param   src
</pre>
<hr />
<pre>
1852 
1853     /**
1854      * Modifies this buffer&#39;s byte order.
1855      *
1856      * @param  bo
1857      *         The new byte order,
1858      *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}
1859      *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}
1860      *
1861      * @return  This buffer
1862      */
1863     public final $Type$Buffer order(ByteOrder bo) {
1864         bigEndian = (bo == ByteOrder.BIG_ENDIAN);
1865         nativeByteOrder =
1866             (bigEndian == (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN));
1867         return this;
1868     }
1869 
1870     /**
1871      * Returns the memory address, pointing to the byte at the given index,
<span class="line-modified">1872      * modulo the given unit size.</span>
<span class="line-modified">1873      *</span>
<span class="line-modified">1874      * &lt;p&gt; The return value is non-negative in the range of {@code 0}</span>
<span class="line-modified">1875      * (inclusive) up to {@code unitSize} (exclusive), with zero indicating</span>
<span class="line-modified">1876      * that the address of the byte at the index is aligned for the unit size,</span>
<span class="line-modified">1877      * and a positive value that the address is misaligned for the unit size.</span>
<span class="line-modified">1878      * If the address of the byte at the index is misaligned, the return value</span>
<span class="line-modified">1879      * represents how much the index should be adjusted to locate a byte at an</span>
<span class="line-added">1880      * aligned address.  Specifically, the index should either be decremented by</span>
<span class="line-added">1881      * the return value if the latter is not greater than {@code index}, or be</span>
<span class="line-added">1882      * incremented by the unit size minus the return value.  Therefore given</span>
<span class="line-added">1883      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">1884      * int value = alignmentOffset(index, unitSize)&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">1885      * then the identities</span>
<span class="line-added">1886      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">1887      * alignmentOffset(index - value, unitSize) == 0, value &amp;le; index&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">1888      * and</span>
<span class="line-added">1889      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">1890      * alignmentOffset(index + (unitSize - value), unitSize) == 0&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">1891      * must hold.</span>
<span class="line-added">1892      * </span>
1893      * @apiNote
1894      * This method may be utilized to determine if unit size bytes from an
1895      * index can be accessed atomically, if supported by the native platform.
1896      *
1897      * @implNote
1898      * This implementation throws {@code UnsupportedOperationException} for
1899      * non-direct buffers when the given unit size is greater then {@code 8}.
1900      *
1901      * @param  index
1902      *         The index to query for alignment offset, must be non-negative, no
1903      *         upper bounds check is performed
1904      *
1905      * @param  unitSize
1906      *         The unit size in bytes, must be a power of {@code 2}
1907      *
<span class="line-modified">1908      * @return  The indexed byte&#39;s memory address modulo the unit size</span>
1909      *
1910      * @throws IllegalArgumentException
1911      *         If the index is negative or the unit size is not a power of
1912      *         {@code 2}
1913      *
1914      * @throws UnsupportedOperationException
1915      *         If the native platform does not guarantee stable alignment offset
1916      *         values for the given unit size when managing the memory regions
1917      *         of buffers of the same kind as this buffer (direct or
1918      *         non-direct).  For example, if garbage collection would result
1919      *         in the moving of a memory region covered by a non-direct buffer
1920      *         from one location to another and both locations have different
1921      *         alignment characteristics.
1922      *
1923      * @see #alignedSlice(int)
1924      * @since 9
1925      */
1926     public final int alignmentOffset(int index, int unitSize) {
1927         if (index &lt; 0)
1928             throw new IllegalArgumentException(&quot;Index less than zero: &quot; + index);
1929         if (unitSize &lt; 1 || (unitSize &amp; (unitSize - 1)) != 0)
1930             throw new IllegalArgumentException(&quot;Unit size not a power of two: &quot; + unitSize);
1931         if (unitSize &gt; 8 &amp;&amp; !isDirect())
1932             throw new UnsupportedOperationException(&quot;Unit size unsupported for non-direct buffers: &quot; + unitSize);
1933 
<span class="line-modified">1934         return (int) ((address + index) &amp; (unitSize - 1));</span>
1935     }
1936 
1937     /**
1938      * Creates a new byte buffer whose content is a shared and aligned
1939      * subsequence of this buffer&#39;s content.
1940      *
1941      * &lt;p&gt; The content of the new buffer will start at this buffer&#39;s current
1942      * position rounded up to the index of the nearest aligned byte for the
1943      * given unit size, and end at this buffer&#39;s limit rounded down to the index
1944      * of the nearest aligned byte for the given unit size.
1945      * If rounding results in out-of-bound values then the new buffer&#39;s capacity
1946      * and limit will be zero.  If rounding is within bounds the following
1947      * expressions will be true for a new buffer {@code nb} and unit size
1948      * {@code unitSize}:
1949      * &lt;pre&gt;{@code
1950      * nb.alignmentOffset(0, unitSize) == 0
1951      * nb.alignmentOffset(nb.limit(), unitSize) == 0
1952      * }&lt;/pre&gt;
1953      *
1954      * &lt;p&gt; Changes to this buffer&#39;s content will be visible in the new
</pre>
</td>
</tr>
</table>
<center><a href="StringCharBuffer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="channels/AsynchronousChannelGroup.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
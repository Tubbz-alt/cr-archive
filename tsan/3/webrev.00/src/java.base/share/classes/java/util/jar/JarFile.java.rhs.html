<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/jar/JarFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.jar;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.access.JavaUtilZipFileAccess;
  30 import sun.security.action.GetPropertyAction;
  31 import sun.security.util.ManifestEntryVerifier;
  32 import sun.security.util.SignatureFileVerifier;
  33 
  34 import java.io.ByteArrayInputStream;
  35 import java.io.EOFException;
  36 import java.io.File;
  37 import java.io.IOException;
  38 import java.io.InputStream;
  39 import java.lang.ref.SoftReference;
  40 import java.net.URL;
  41 import java.security.CodeSigner;
  42 import java.security.CodeSource;
  43 import java.security.cert.Certificate;
  44 import java.util.ArrayList;
  45 import java.util.Collections;
  46 import java.util.Enumeration;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import java.util.NoSuchElementException;
  50 import java.util.Objects;
  51 import java.util.function.Function;
  52 import java.util.stream.Stream;
  53 import java.util.zip.ZipEntry;
  54 import java.util.zip.ZipException;
  55 import java.util.zip.ZipFile;
  56 
  57 /**
  58  * The {@code JarFile} class is used to read the contents of a jar file
  59  * from any file that can be opened with {@code java.io.RandomAccessFile}.
  60  * It extends the class {@code java.util.zip.ZipFile} with support
  61  * for reading an optional {@code Manifest} entry, and support for
  62  * processing multi-release jar files.  The {@code Manifest} can be used
  63  * to specify meta-information about the jar file and its entries.
  64  *
  65  * &lt;p&gt;&lt;a id=&quot;multirelease&quot;&gt;A multi-release jar file&lt;/a&gt; is a jar file that
  66  * contains a manifest with a main attribute named &quot;Multi-Release&quot;,
  67  * a set of &quot;base&quot; entries, some of which are public classes with public
  68  * or protected methods that comprise the public interface of the jar file,
  69  * and a set of &quot;versioned&quot; entries contained in subdirectories of the
  70  * &quot;META-INF/versions&quot; directory.  The versioned entries are partitioned by the
  71  * major version of the Java platform.  A versioned entry, with a version
  72  * {@code n}, {@code 8 &lt; n}, in the &quot;META-INF/versions/{n}&quot; directory overrides
  73  * the base entry as well as any entry with a version number {@code i} where
  74  * {@code 8 &lt; i &lt; n}.
  75  *
  76  * &lt;p&gt;By default, a {@code JarFile} for a multi-release jar file is configured
  77  * to process the multi-release jar file as if it were a plain (unversioned) jar
  78  * file, and as such an entry name is associated with at most one base entry.
  79  * The {@code JarFile} may be configured to process a multi-release jar file by
  80  * creating the {@code JarFile} with the
  81  * {@link JarFile#JarFile(File, boolean, int, Runtime.Version)} constructor.  The
  82  * {@code Runtime.Version} object sets a maximum version used when searching for
  83  * versioned entries.  When so configured, an entry name
  84  * can correspond with at most one base entry and zero or more versioned
  85  * entries. A search is required to associate the entry name with the latest
  86  * versioned entry whose version is less than or equal to the maximum version
  87  * (see {@link #getEntry(String)}).
  88  *
  89  * &lt;p&gt;Class loaders that utilize {@code JarFile} to load classes from the
  90  * contents of {@code JarFile} entries should construct the {@code JarFile}
  91  * by invoking the {@link JarFile#JarFile(File, boolean, int, Runtime.Version)}
  92  * constructor with the value {@code Runtime.version()} assigned to the last
  93  * argument.  This assures that classes compatible with the major
  94  * version of the running JVM are loaded from multi-release jar files.
  95  *
  96  * &lt;p&gt; If the {@code verify} flag is on when opening a signed jar file, the content
  97  * of the jar entry is verified against the signature embedded inside the manifest
  98  * that is associated with its {@link JarEntry#getRealName() path name}. For a
  99  * multi-release jar file, the content of a versioned entry is verfieid against
 100  * its own signature and {@link JarEntry#getCodeSigners()} returns its own signers.
 101  *
 102  * Please note that the verification process does not include validating the
 103  * signer&#39;s certificate. A caller should inspect the return value of
 104  * {@link JarEntry#getCodeSigners()} to further determine if the signature
 105  * can be trusted.
 106  *
 107  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
 108  * or method in this class will cause a {@link NullPointerException} to be
 109  * thrown.
 110  *
 111  * @implNote
 112  * &lt;div class=&quot;block&quot;&gt;
 113  * If the API can not be used to configure a {@code JarFile} (e.g. to override
 114  * the configuration of a compiled application or library), two {@code System}
 115  * properties are available.
 116  * &lt;ul&gt;
 117  * &lt;li&gt;
 118  * {@code jdk.util.jar.version} can be assigned a value that is the
 119  * {@code String} representation of a non-negative integer
 120  * {@code &lt;= Runtime.version().feature()}.  The value is used to set the effective
 121  * runtime version to something other than the default value obtained by
 122  * evaluating {@code Runtime.version().feature()}. The effective runtime version
 123  * is the version that the {@link JarFile#JarFile(File, boolean, int, Runtime.Version)}
 124  * constructor uses when the value of the last argument is
 125  * {@code JarFile.runtimeVersion()}.
 126  * &lt;/li&gt;
 127  * &lt;li&gt;
 128  * {@code jdk.util.jar.enableMultiRelease} can be assigned one of the three
 129  * {@code String} values &lt;em&gt;true&lt;/em&gt;, &lt;em&gt;false&lt;/em&gt;, or &lt;em&gt;force&lt;/em&gt;.  The
 130  * value &lt;em&gt;true&lt;/em&gt;, the default value, enables multi-release jar file
 131  * processing.  The value &lt;em&gt;false&lt;/em&gt; disables multi-release jar processing,
 132  * ignoring the &quot;Multi-Release&quot; manifest attribute, and the versioned
 133  * directories in a multi-release jar file if they exist.  Furthermore,
 134  * the method {@link JarFile#isMultiRelease()} returns &lt;em&gt;false&lt;/em&gt;. The value
 135  * &lt;em&gt;force&lt;/em&gt; causes the {@code JarFile} to be initialized to runtime
 136  * versioning after construction.  It effectively does the same as this code:
 137  * {@code (new JarFile(File, boolean, int, JarFile.runtimeVersion())}.
 138  * &lt;/li&gt;
 139  * &lt;/ul&gt;
 140  * &lt;/div&gt;
 141  *
 142  * @author  David Connelly
 143  * @see     Manifest
 144  * @see     java.util.zip.ZipFile
 145  * @see     java.util.jar.JarEntry
 146  * @since   1.2
 147  */
<a name="2" id="anc2"></a><span class="line-modified"> 148 public class JarFile extends ZipFile {</span>
<span class="line-modified"> 149     private static final Runtime.Version BASE_VERSION;</span>
<span class="line-modified"> 150     private static final int BASE_VERSION_FEATURE;</span>
<span class="line-modified"> 151     private static final Runtime.Version RUNTIME_VERSION;</span>
<span class="line-modified"> 152     private static final boolean MULTI_RELEASE_ENABLED;</span>
<span class="line-modified"> 153     private static final boolean MULTI_RELEASE_FORCED;</span>
<span class="line-modified"> 154     private static final ThreadLocal&lt;Boolean&gt; isInitializing = new ThreadLocal&lt;&gt;();</span>
<span class="line-added"> 155 </span>
 156     private SoftReference&lt;Manifest&gt; manRef;
 157     private JarEntry manEntry;
 158     private JarVerifier jv;
 159     private boolean jvInitialized;
 160     private boolean verify;
 161     private final Runtime.Version version;  // current version
<a name="3" id="anc3"></a><span class="line-modified"> 162     private final int versionFeature;       // version.feature()</span>
 163     private boolean isMultiRelease;         // is jar multi-release?
 164 
 165     // indicates if Class-Path attribute present
 166     private boolean hasClassPathAttribute;
 167     // true if manifest checked for special attributes
 168     private volatile boolean hasCheckedSpecialAttributes;
 169 
 170     private static final JavaUtilZipFileAccess JUZFA;
 171 
 172     static {
 173         // Set up JavaUtilJarAccess in SharedSecrets
 174         SharedSecrets.setJavaUtilJarAccess(new JavaUtilJarAccessImpl());
 175         // Get JavaUtilZipFileAccess from SharedSecrets
 176         JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
 177         // multi-release jar file versions &gt;= 9
 178         BASE_VERSION = Runtime.Version.parse(Integer.toString(8));
 179         BASE_VERSION_FEATURE = BASE_VERSION.feature();
 180         String jarVersion = GetPropertyAction.privilegedGetProperty(&quot;jdk.util.jar.version&quot;);
 181         int runtimeVersion = Runtime.version().feature();
 182         if (jarVersion != null) {
 183             int jarVer = Integer.parseInt(jarVersion);
 184             runtimeVersion = (jarVer &gt; runtimeVersion)
 185                     ? runtimeVersion
 186                     : Math.max(jarVer, BASE_VERSION_FEATURE);
 187         }
 188         RUNTIME_VERSION = Runtime.Version.parse(Integer.toString(runtimeVersion));
 189         String enableMultiRelease = GetPropertyAction
 190                 .privilegedGetProperty(&quot;jdk.util.jar.enableMultiRelease&quot;, &quot;true&quot;);
 191         switch (enableMultiRelease) {
 192             case &quot;true&quot;:
 193             default:
 194                 MULTI_RELEASE_ENABLED = true;
 195                 MULTI_RELEASE_FORCED = false;
 196                 break;
 197             case &quot;false&quot;:
 198                 MULTI_RELEASE_ENABLED = false;
 199                 MULTI_RELEASE_FORCED = false;
 200                 break;
 201             case &quot;force&quot;:
 202                 MULTI_RELEASE_ENABLED = true;
 203                 MULTI_RELEASE_FORCED = true;
 204                 break;
 205         }
 206     }
 207 
 208     private static final String META_INF = &quot;META-INF/&quot;;
 209 
 210     private static final String META_INF_VERSIONS = META_INF + &quot;versions/&quot;;
 211 
 212     /**
 213      * The JAR manifest file name.
 214      */
 215     public static final String MANIFEST_NAME = META_INF + &quot;MANIFEST.MF&quot;;
 216 
 217     /**
 218      * Returns the version that represents the unversioned configuration of a
 219      * multi-release jar file.
 220      *
 221      * @return the version that represents the unversioned configuration
 222      *
 223      * @since 9
 224      */
 225     public static Runtime.Version baseVersion() {
 226         return BASE_VERSION;
 227     }
 228 
 229     /**
 230      * Returns the version that represents the effective runtime versioned
 231      * configuration of a multi-release jar file.
 232      * &lt;p&gt;
 233      * By default the feature version number of the returned {@code Version} will
 234      * be equal to the feature version number of {@code Runtime.version()}.
 235      * However, if the {@code jdk.util.jar.version} property is set, the
 236      * returned {@code Version} is derived from that property and feature version
 237      * numbers may not be equal.
 238      *
 239      * @return the version that represents the runtime versioned configuration
 240      *
 241      * @since 9
 242      */
 243     public static Runtime.Version runtimeVersion() {
 244         return RUNTIME_VERSION;
 245     }
 246 
 247     /**
 248      * Creates a new {@code JarFile} to read from the specified
 249      * file {@code name}. The {@code JarFile} will be verified if
 250      * it is signed.
 251      * @param name the name of the jar file to be opened for reading
 252      * @throws IOException if an I/O error has occurred
 253      * @throws SecurityException if access to the file is denied
 254      *         by the SecurityManager
 255      */
 256     public JarFile(String name) throws IOException {
 257         this(new File(name), true, ZipFile.OPEN_READ);
 258     }
 259 
 260     /**
 261      * Creates a new {@code JarFile} to read from the specified
 262      * file {@code name}.
 263      * @param name the name of the jar file to be opened for reading
 264      * @param verify whether or not to verify the jar file if
 265      * it is signed.
 266      * @throws IOException if an I/O error has occurred
 267      * @throws SecurityException if access to the file is denied
 268      *         by the SecurityManager
 269      */
 270     public JarFile(String name, boolean verify) throws IOException {
 271         this(new File(name), verify, ZipFile.OPEN_READ);
 272     }
 273 
 274     /**
 275      * Creates a new {@code JarFile} to read from the specified
 276      * {@code File} object. The {@code JarFile} will be verified if
 277      * it is signed.
 278      * @param file the jar file to be opened for reading
 279      * @throws IOException if an I/O error has occurred
 280      * @throws SecurityException if access to the file is denied
 281      *         by the SecurityManager
 282      */
 283     public JarFile(File file) throws IOException {
 284         this(file, true, ZipFile.OPEN_READ);
 285     }
 286 
 287     /**
 288      * Creates a new {@code JarFile} to read from the specified
 289      * {@code File} object.
 290      * @param file the jar file to be opened for reading
 291      * @param verify whether or not to verify the jar file if
 292      * it is signed.
 293      * @throws IOException if an I/O error has occurred
 294      * @throws SecurityException if access to the file is denied
 295      *         by the SecurityManager.
 296      */
 297     public JarFile(File file, boolean verify) throws IOException {
 298         this(file, verify, ZipFile.OPEN_READ);
 299     }
 300 
 301     /**
 302      * Creates a new {@code JarFile} to read from the specified
 303      * {@code File} object in the specified mode.  The mode argument
 304      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 305      *
 306      * @param file the jar file to be opened for reading
 307      * @param verify whether or not to verify the jar file if
 308      * it is signed.
 309      * @param mode the mode in which the file is to be opened
 310      * @throws IOException if an I/O error has occurred
 311      * @throws IllegalArgumentException
 312      *         if the {@code mode} argument is invalid
 313      * @throws SecurityException if access to the file is denied
 314      *         by the SecurityManager
 315      * @since 1.3
 316      */
 317     public JarFile(File file, boolean verify, int mode) throws IOException {
 318         this(file, verify, mode, BASE_VERSION);
 319     }
 320 
 321     /**
 322      * Creates a new {@code JarFile} to read from the specified
 323      * {@code File} object in the specified mode.  The mode argument
 324      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 325      * The version argument, after being converted to a canonical form, is
 326      * used to configure the {@code JarFile} for processing
 327      * multi-release jar files.
 328      * &lt;p&gt;
 329      * The canonical form derived from the version parameter is
 330      * {@code Runtime.Version.parse(Integer.toString(n))} where {@code n} is
 331      * {@code Math.max(version.feature(), JarFile.baseVersion().feature())}.
 332      *
 333      * @param file the jar file to be opened for reading
 334      * @param verify whether or not to verify the jar file if
 335      * it is signed.
 336      * @param mode the mode in which the file is to be opened
 337      * @param version specifies the release version for a multi-release jar file
 338      * @throws IOException if an I/O error has occurred
 339      * @throws IllegalArgumentException
 340      *         if the {@code mode} argument is invalid
 341      * @throws SecurityException if access to the file is denied
 342      *         by the SecurityManager
 343      * @throws NullPointerException if {@code version} is {@code null}
 344      * @since 9
 345      */
 346     public JarFile(File file, boolean verify, int mode, Runtime.Version version) throws IOException {
 347         super(file, mode);
 348         this.verify = verify;
 349         Objects.requireNonNull(version);
 350         if (MULTI_RELEASE_FORCED || version.feature() == RUNTIME_VERSION.feature()) {
 351             // This deals with the common case where the value from JarFile.runtimeVersion() is passed
 352             this.version = RUNTIME_VERSION;
 353         } else if (version.feature() &lt;= BASE_VERSION_FEATURE) {
 354             // This also deals with the common case where the value from JarFile.baseVersion() is passed
 355             this.version = BASE_VERSION;
 356         } else {
 357             // Canonicalize
 358             this.version = Runtime.Version.parse(Integer.toString(version.feature()));
 359         }
 360         this.versionFeature = this.version.feature();
 361     }
 362 
 363     /**
 364      * Returns the maximum version used when searching for versioned entries.
 365      * &lt;p&gt;
 366      * If this {@code JarFile} is not a multi-release jar file or is not
 367      * configured to be processed as such, then the version returned will be the
 368      * same as that returned from {@link #baseVersion()}.
 369      *
 370      * @return the maximum version
 371      * @since 9
 372      */
 373     public final Runtime.Version getVersion() {
 374         return isMultiRelease() ? this.version : BASE_VERSION;
 375     }
 376 
 377     /**
 378      * Indicates whether or not this jar file is a multi-release jar file.
 379      *
 380      * @return true if this JarFile is a multi-release jar file
 381      * @since 9
 382      */
 383     public final boolean isMultiRelease() {
 384         if (isMultiRelease) {
 385             return true;
 386         }
 387         if (MULTI_RELEASE_ENABLED) {
 388             try {
 389                 checkForSpecialAttributes();
 390             } catch (IOException io) {
 391                 isMultiRelease = false;
 392             }
 393         }
 394         return isMultiRelease;
 395     }
 396 
 397     /**
 398      * Returns the jar file manifest, or {@code null} if none.
 399      *
 400      * @return the jar file manifest, or {@code null} if none
 401      *
 402      * @throws IllegalStateException
 403      *         may be thrown if the jar file has been closed
 404      * @throws IOException  if an I/O error has occurred
 405      */
 406     public Manifest getManifest() throws IOException {
 407         return getManifestFromReference();
 408     }
 409 
 410     private Manifest getManifestFromReference() throws IOException {
 411         Manifest man = manRef != null ? manRef.get() : null;
 412 
 413         if (man == null) {
 414 
 415             JarEntry manEntry = getManEntry();
 416 
 417             // If found then load the manifest
 418             if (manEntry != null) {
 419                 if (verify) {
 420                     byte[] b = getBytes(manEntry);
 421                     if (!jvInitialized) {
 422                         jv = new JarVerifier(b);
 423                     }
 424                     man = new Manifest(jv, new ByteArrayInputStream(b), getName());
 425                 } else {
 426                     man = new Manifest(super.getInputStream(manEntry), getName());
 427                 }
 428                 manRef = new SoftReference&lt;&gt;(man);
 429             }
 430         }
 431         return man;
 432     }
 433 
 434     private String[] getMetaInfEntryNames() {
 435         return JUZFA.getMetaInfEntryNames((ZipFile)this);
 436     }
 437 
 438     /**
 439      * Returns the {@code JarEntry} for the given base entry name or
 440      * {@code null} if not found.
 441      *
 442      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured
 443      * to be processed as such, then a search is performed to find and return
 444      * a {@code JarEntry} that is the latest versioned entry associated with the
 445      * given entry name.  The returned {@code JarEntry} is the versioned entry
 446      * corresponding to the given base entry name prefixed with the string
 447      * {@code &quot;META-INF/versions/{n}/&quot;}, for the largest value of {@code n} for
 448      * which an entry exists.  If such a versioned entry does not exist, then
 449      * the {@code JarEntry} for the base entry is returned, otherwise
 450      * {@code null} is returned if no entries are found.  The initial value for
 451      * the version {@code n} is the maximum version as returned by the method
 452      * {@link JarFile#getVersion()}.
 453      *
 454      * @param name the jar file entry name
 455      * @return the {@code JarEntry} for the given entry name, or
 456      *         the versioned entry name, or {@code null} if not found
 457      *
 458      * @throws IllegalStateException
 459      *         may be thrown if the jar file has been closed
 460      *
 461      * @see java.util.jar.JarEntry
 462      *
 463      * @implSpec
 464      * &lt;div class=&quot;block&quot;&gt;
 465      * This implementation invokes {@link JarFile#getEntry(String)}.
 466      * &lt;/div&gt;
 467      */
 468     public JarEntry getJarEntry(String name) {
 469         return (JarEntry)getEntry(name);
 470     }
 471 
 472     /**
 473      * Returns the {@code ZipEntry} for the given base entry name or
 474      * {@code null} if not found.
 475      *
 476      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured
 477      * to be processed as such, then a search is performed to find and return
 478      * a {@code ZipEntry} that is the latest versioned entry associated with the
 479      * given entry name.  The returned {@code ZipEntry} is the versioned entry
 480      * corresponding to the given base entry name prefixed with the string
 481      * {@code &quot;META-INF/versions/{n}/&quot;}, for the largest value of {@code n} for
 482      * which an entry exists.  If such a versioned entry does not exist, then
 483      * the {@code ZipEntry} for the base entry is returned, otherwise
 484      * {@code null} is returned if no entries are found.  The initial value for
 485      * the version {@code n} is the maximum version as returned by the method
 486      * {@link JarFile#getVersion()}.
 487      *
 488      * @param name the jar file entry name
 489      * @return the {@code ZipEntry} for the given entry name or
 490      *         the versioned entry name or {@code null} if not found
 491      *
 492      * @throws IllegalStateException
 493      *         may be thrown if the jar file has been closed
 494      *
 495      * @see java.util.zip.ZipEntry
 496      *
 497      * @implSpec
 498      * &lt;div class=&quot;block&quot;&gt;
 499      * This implementation may return a versioned entry for the requested name
 500      * even if there is not a corresponding base entry.  This can occur
 501      * if there is a private or package-private versioned entry that matches.
 502      * If a subclass overrides this method, assure that the override method
 503      * invokes {@code super.getEntry(name)} to obtain all versioned entries.
 504      * &lt;/div&gt;
 505      */
 506     public ZipEntry getEntry(String name) {
 507         JarFileEntry je = getEntry0(name);
 508         if (isMultiRelease()) {
 509             return getVersionedEntry(name, je);
 510         }
 511         return je;
 512     }
 513 
 514     /**
 515      * Returns an enumeration of the jar file entries.
 516      *
 517      * @return an enumeration of the jar file entries
 518      * @throws IllegalStateException
 519      *         may be thrown if the jar file has been closed
 520      */
 521     public Enumeration&lt;JarEntry&gt; entries() {
 522         return JUZFA.entries(this, JarFileEntry::new);
 523     }
 524 
 525     /**
 526      * Returns an ordered {@code Stream} over the jar file entries.
 527      * Entries appear in the {@code Stream} in the order they appear in
 528      * the central directory of the jar file.
 529      *
 530      * @return an ordered {@code Stream} of entries in this jar file
 531      * @throws IllegalStateException if the jar file has been closed
 532      * @since 1.8
 533      */
 534     public Stream&lt;JarEntry&gt; stream() {
 535         return JUZFA.stream(this, JarFileEntry::new);
 536     }
 537 
 538     /**
 539      * Returns a {@code Stream} of the versioned jar file entries.
 540      *
 541      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured to
 542      * be processed as such, then an entry in the stream is the latest versioned entry
 543      * associated with the corresponding base entry name. The maximum version of the
 544      * latest versioned entry is the version returned by {@link #getVersion()}.
 545      * The returned stream may include an entry that only exists as a versioned entry.
 546      *
 547      * If the jar file is not a multi-release jar file or the {@code JarFile} is not
 548      * configured for processing a multi-release jar file, this method returns the
 549      * same stream that {@link #stream()} returns.
 550      *
 551      * @return stream of versioned entries
 552      * @since 10
 553      */
 554     public Stream&lt;JarEntry&gt; versionedStream() {
 555 
 556         if (isMultiRelease()) {
 557             return JUZFA.entryNameStream(this).map(this::getBasename)
 558                                               .filter(Objects::nonNull)
 559                                               .distinct()
 560                                               .map(this::getJarEntry)
 561                                               .filter(Objects::nonNull);
 562         }
 563         return stream();
 564     }
 565 
 566     /*
 567      * Invokes {@ZipFile}&#39;s getEntry to Return a {@code JarFileEntry} for the
 568      * given entry name or {@code null} if not found.
 569      */
 570     private JarFileEntry getEntry0(String name) {
 571         // Not using a lambda/method reference here to optimize startup time
 572         Function&lt;String, JarEntry&gt; newJarFileEntryFn = new Function&lt;&gt;() {
 573             @Override
 574             public JarEntry apply(String name) {
 575                 return new JarFileEntry(name);
 576             }
 577         };
 578         return (JarFileEntry)JUZFA.getEntry(this, name, newJarFileEntryFn);
 579     }
 580 
 581     private String getBasename(String name) {
 582         if (name.startsWith(META_INF_VERSIONS)) {
 583             int off = META_INF_VERSIONS.length();
 584             int index = name.indexOf(&#39;/&#39;, off);
 585             try {
 586                 // filter out dir META-INF/versions/ and META-INF/versions/*/
 587                 // and any entry with version &gt; &#39;version&#39;
 588                 if (index == -1 || index == (name.length() - 1) ||
 589                     Integer.parseInt(name, off, index, 10) &gt; versionFeature) {
 590                     return null;
 591                 }
 592             } catch (NumberFormatException x) {
 593                 return null; // remove malformed entries silently
 594             }
 595             // map to its base name
 596             return name.substring(index + 1);
 597         }
 598         return name;
 599     }
 600 
 601     private JarEntry getVersionedEntry(String name, JarEntry je) {
 602         if (BASE_VERSION_FEATURE &lt; versionFeature) {
 603             if (!name.startsWith(META_INF)) {
 604                 // search for versioned entry
 605                 int v = versionFeature;
 606                 while (v &gt; BASE_VERSION_FEATURE) {
 607                     JarFileEntry vje = getEntry0(META_INF_VERSIONS + v + &quot;/&quot; + name);
 608                     if (vje != null) {
 609                         return vje.withBasename(name);
 610                     }
 611                     v--;
 612                 }
 613             }
 614         }
 615         return je;
 616     }
 617 
 618     // placeholder for now
 619     String getRealName(JarEntry entry) {
 620         return entry.getRealName();
 621     }
 622 
 623     private class JarFileEntry extends JarEntry {
 624         private String basename;
 625 
 626         JarFileEntry(String name) {
 627             super(name);
 628             this.basename = name;
 629         }
 630 
 631         JarFileEntry(String name, ZipEntry vze) {
 632             super(vze);
 633             this.basename = name;
 634         }
 635 
 636         @Override
 637         public Attributes getAttributes() throws IOException {
 638             Manifest man = JarFile.this.getManifest();
 639             if (man != null) {
 640                 return man.getAttributes(super.getName());
 641             } else {
 642                 return null;
 643             }
 644         }
 645 
 646         @Override
 647         public Certificate[] getCertificates() {
 648             try {
 649                 maybeInstantiateVerifier();
 650             } catch (IOException e) {
 651                 throw new RuntimeException(e);
 652             }
 653             if (certs == null &amp;&amp; jv != null) {
 654                 certs = jv.getCerts(JarFile.this, realEntry());
 655             }
 656             return certs == null ? null : certs.clone();
 657         }
 658 
 659         @Override
 660         public CodeSigner[] getCodeSigners() {
 661             try {
 662                 maybeInstantiateVerifier();
 663             } catch (IOException e) {
 664                 throw new RuntimeException(e);
 665             }
 666             if (signers == null &amp;&amp; jv != null) {
 667                 signers = jv.getCodeSigners(JarFile.this, realEntry());
 668             }
 669             return signers == null ? null : signers.clone();
 670         }
 671 
 672         @Override
 673         public String getRealName() {
 674             return super.getName();
 675         }
 676 
 677         @Override
 678         public String getName() {
 679             return basename;
 680         }
 681 
 682         JarFileEntry realEntry() {
 683             if (isMultiRelease() &amp;&amp; versionFeature != BASE_VERSION_FEATURE) {
 684                 String entryName = super.getName();
 685                 return entryName == basename || entryName.equals(basename) ?
 686                         this : new JarFileEntry(entryName, this);
 687             }
 688             return this;
 689         }
 690 
 691         // changes the basename, returns &quot;this&quot;
 692         JarFileEntry withBasename(String name) {
 693             basename = name;
 694             return this;
 695         }
 696     }
 697 
 698     /*
 699      * Ensures that the JarVerifier has been created if one is
 700      * necessary (i.e., the jar appears to be signed.) This is done as
 701      * a quick check to avoid processing of the manifest for unsigned
 702      * jars.
 703      */
 704     private void maybeInstantiateVerifier() throws IOException {
 705         if (jv != null) {
 706             return;
 707         }
 708 
 709         if (verify) {
 710             String[] names = getMetaInfEntryNames();
 711             if (names != null) {
 712                 for (String nameLower : names) {
 713                     String name = nameLower.toUpperCase(Locale.ENGLISH);
 714                     if (name.endsWith(&quot;.DSA&quot;) ||
 715                         name.endsWith(&quot;.RSA&quot;) ||
 716                         name.endsWith(&quot;.EC&quot;) ||
 717                         name.endsWith(&quot;.SF&quot;)) {
 718                         // Assume since we found a signature-related file
 719                         // that the jar is signed and that we therefore
 720                         // need a JarVerifier and Manifest
 721                         getManifest();
 722                         return;
 723                     }
 724                 }
 725             }
 726             // No signature-related files; don&#39;t instantiate a
 727             // verifier
 728             verify = false;
 729         }
 730     }
 731 
 732     /*
 733      * Initializes the verifier object by reading all the manifest
 734      * entries and passing them to the verifier.
 735      */
 736     private void initializeVerifier() {
 737         ManifestEntryVerifier mev = null;
 738 
 739         // Verify &quot;META-INF/&quot; entries...
 740         try {
 741             String[] names = getMetaInfEntryNames();
 742             if (names != null) {
 743                 for (String name : names) {
 744                     String uname = name.toUpperCase(Locale.ENGLISH);
 745                     if (MANIFEST_NAME.equals(uname)
 746                             || SignatureFileVerifier.isBlockOrSF(uname)) {
 747                         JarEntry e = getJarEntry(name);
 748                         if (e == null) {
 749                             throw new JarException(&quot;corrupted jar file&quot;);
 750                         }
 751                         if (mev == null) {
 752                             mev = new ManifestEntryVerifier
 753                                 (getManifestFromReference());
 754                         }
 755                         byte[] b = getBytes(e);
 756                         if (b != null &amp;&amp; b.length &gt; 0) {
 757                             jv.beginEntry(e, mev);
 758                             jv.update(b.length, b, 0, b.length, mev);
 759                             jv.update(-1, null, 0, 0, mev);
 760                         }
 761                     }
 762                 }
 763             }
 764         } catch (IOException ex) {
 765             // if we had an error parsing any blocks, just
 766             // treat the jar file as being unsigned
 767             jv = null;
 768             verify = false;
 769             if (JarVerifier.debug != null) {
 770                 JarVerifier.debug.println(&quot;jarfile parsing error!&quot;);
 771                 ex.printStackTrace();
 772             }
 773         }
 774 
 775         // if after initializing the verifier we have nothing
 776         // signed, we null it out.
 777 
 778         if (jv != null) {
 779 
 780             jv.doneWithMeta();
 781             if (JarVerifier.debug != null) {
 782                 JarVerifier.debug.println(&quot;done with meta!&quot;);
 783             }
 784 
 785             if (jv.nothingToVerify()) {
 786                 if (JarVerifier.debug != null) {
 787                     JarVerifier.debug.println(&quot;nothing to verify!&quot;);
 788                 }
 789                 jv = null;
 790                 verify = false;
 791             }
 792         }
 793     }
 794 
 795     /*
 796      * Reads all the bytes for a given entry. Used to process the
 797      * META-INF files.
 798      */
 799     private byte[] getBytes(ZipEntry ze) throws IOException {
 800         try (InputStream is = super.getInputStream(ze)) {
 801             int len = (int)ze.getSize();
 802             int bytesRead;
 803             byte[] b;
 804             // trust specified entry sizes when reasonably small
 805             if (len != -1 &amp;&amp; len &lt;= 65535) {
 806                 b = new byte[len];
 807                 bytesRead = is.readNBytes(b, 0, len);
 808             } else {
 809                 b = is.readAllBytes();
 810                 bytesRead = b.length;
 811             }
 812             if (len != -1 &amp;&amp; len != bytesRead) {
 813                 throw new EOFException(&quot;Expected:&quot; + len + &quot;, read:&quot; + bytesRead);
 814             }
 815             return b;
 816         }
 817     }
 818 
 819     /**
 820      * Returns an input stream for reading the contents of the specified
 821      * zip file entry.
 822      * @param ze the zip file entry
 823      * @return an input stream for reading the contents of the specified
 824      *         zip file entry
 825      * @throws ZipException if a zip file format error has occurred
 826      * @throws IOException if an I/O error has occurred
 827      * @throws SecurityException if any of the jar file entries
 828      *         are incorrectly signed.
 829      * @throws IllegalStateException
 830      *         may be thrown if the jar file has been closed
 831      */
 832     public synchronized InputStream getInputStream(ZipEntry ze)
 833         throws IOException
 834     {
 835         maybeInstantiateVerifier();
 836         if (jv == null) {
 837             return super.getInputStream(ze);
 838         }
 839         if (!jvInitialized) {
 840             initializeVerifier();
 841             jvInitialized = true;
 842             // could be set to null after a call to
 843             // initializeVerifier if we have nothing to
 844             // verify
 845             if (jv == null)
 846                 return super.getInputStream(ze);
 847         }
 848 
 849         // wrap a verifier stream around the real stream
 850         return new JarVerifier.VerifierStream(
 851             getManifestFromReference(),
 852             verifiableEntry(ze),
 853             super.getInputStream(ze),
 854             jv);
 855     }
 856 
 857     private JarEntry verifiableEntry(ZipEntry ze) {
 858         if (ze instanceof JarFileEntry) {
 859             // assure the name and entry match for verification
 860             return ((JarFileEntry)ze).realEntry();
 861         }
 862         ze = getJarEntry(ze.getName());
 863         if (ze instanceof JarFileEntry) {
 864             return ((JarFileEntry)ze).realEntry();
 865         }
 866         return (JarEntry)ze;
 867     }
 868 
 869     // Statics for hand-coded Boyer-Moore search
 870     private static final byte[] CLASSPATH_CHARS =
 871             {&#39;C&#39;,&#39;L&#39;,&#39;A&#39;,&#39;S&#39;,&#39;S&#39;,&#39;-&#39;,&#39;P&#39;,&#39;A&#39;,&#39;T&#39;,&#39;H&#39;, &#39;:&#39;, &#39; &#39;};
 872 
 873     // The bad character shift for &quot;class-path: &quot;
 874     private static final byte[] CLASSPATH_LASTOCC;
 875 
 876     // The good suffix shift for &quot;class-path: &quot;
 877     private static final byte[] CLASSPATH_OPTOSFT;
 878 
 879     private static final byte[] MULTIRELEASE_CHARS =
 880             {&#39;M&#39;,&#39;U&#39;,&#39;L&#39;,&#39;T&#39;,&#39;I&#39;,&#39;-&#39;,&#39;R&#39;,&#39;E&#39;,&#39;L&#39;,&#39;E&#39;, &#39;A&#39;, &#39;S&#39;, &#39;E&#39;, &#39;:&#39;,
 881                     &#39; &#39;, &#39;T&#39;, &#39;R&#39;, &#39;U&#39;, &#39;E&#39;};
 882 
 883     // The bad character shift for &quot;multi-release: true&quot;
 884     private static final byte[] MULTIRELEASE_LASTOCC;
 885 
 886     // The good suffix shift for &quot;multi-release: true&quot;
 887     private static final byte[] MULTIRELEASE_OPTOSFT;
 888 
 889     static {
 890         CLASSPATH_LASTOCC = new byte[65];
 891         CLASSPATH_OPTOSFT = new byte[12];
 892         CLASSPATH_LASTOCC[(int)&#39;C&#39; - 32] = 1;
 893         CLASSPATH_LASTOCC[(int)&#39;L&#39; - 32] = 2;
 894         CLASSPATH_LASTOCC[(int)&#39;S&#39; - 32] = 5;
 895         CLASSPATH_LASTOCC[(int)&#39;-&#39; - 32] = 6;
 896         CLASSPATH_LASTOCC[(int)&#39;P&#39; - 32] = 7;
 897         CLASSPATH_LASTOCC[(int)&#39;A&#39; - 32] = 8;
 898         CLASSPATH_LASTOCC[(int)&#39;T&#39; - 32] = 9;
 899         CLASSPATH_LASTOCC[(int)&#39;H&#39; - 32] = 10;
 900         CLASSPATH_LASTOCC[(int)&#39;:&#39; - 32] = 11;
 901         CLASSPATH_LASTOCC[(int)&#39; &#39; - 32] = 12;
 902         for (int i = 0; i &lt; 11; i++) {
 903             CLASSPATH_OPTOSFT[i] = 12;
 904         }
 905         CLASSPATH_OPTOSFT[11] = 1;
 906 
 907         MULTIRELEASE_LASTOCC = new byte[65];
 908         MULTIRELEASE_OPTOSFT = new byte[19];
 909         MULTIRELEASE_LASTOCC[(int)&#39;M&#39; - 32] = 1;
 910         MULTIRELEASE_LASTOCC[(int)&#39;I&#39; - 32] = 5;
 911         MULTIRELEASE_LASTOCC[(int)&#39;-&#39; - 32] = 6;
 912         MULTIRELEASE_LASTOCC[(int)&#39;L&#39; - 32] = 9;
 913         MULTIRELEASE_LASTOCC[(int)&#39;A&#39; - 32] = 11;
 914         MULTIRELEASE_LASTOCC[(int)&#39;S&#39; - 32] = 12;
 915         MULTIRELEASE_LASTOCC[(int)&#39;:&#39; - 32] = 14;
 916         MULTIRELEASE_LASTOCC[(int)&#39; &#39; - 32] = 15;
 917         MULTIRELEASE_LASTOCC[(int)&#39;T&#39; - 32] = 16;
 918         MULTIRELEASE_LASTOCC[(int)&#39;R&#39; - 32] = 17;
 919         MULTIRELEASE_LASTOCC[(int)&#39;U&#39; - 32] = 18;
 920         MULTIRELEASE_LASTOCC[(int)&#39;E&#39; - 32] = 19;
 921         for (int i = 0; i &lt; 17; i++) {
 922             MULTIRELEASE_OPTOSFT[i] = 19;
 923         }
 924         MULTIRELEASE_OPTOSFT[17] = 6;
 925         MULTIRELEASE_OPTOSFT[18] = 1;
 926     }
 927 
 928     private JarEntry getManEntry() {
 929         if (manEntry == null) {
 930             // First look up manifest entry using standard name
 931             JarEntry manEntry = getEntry0(MANIFEST_NAME);
 932             if (manEntry == null) {
 933                 // If not found, then iterate through all the &quot;META-INF/&quot;
 934                 // entries to find a match.
 935                 String[] names = getMetaInfEntryNames();
 936                 if (names != null) {
 937                     for (String name : names) {
 938                         if (MANIFEST_NAME.equals(name.toUpperCase(Locale.ENGLISH))) {
 939                             manEntry = getEntry0(name);
 940                             break;
 941                         }
 942                     }
 943                 }
 944             }
 945             this.manEntry = manEntry;
 946         }
 947         return manEntry;
 948     }
 949 
 950    /**
 951     * Returns {@code true} iff this JAR file has a manifest with the
 952     * Class-Path attribute
 953     */
 954     boolean hasClassPathAttribute() throws IOException {
 955         checkForSpecialAttributes();
 956         return hasClassPathAttribute;
 957     }
 958 
 959     /**
 960      * Returns true if the pattern {@code src} is found in {@code b}.
 961      * The {@code lastOcc} array is the precomputed bad character shifts.
 962      * Since there are no repeated substring in our search strings,
 963      * the good suffix shifts can be replaced with a comparison.
 964      */
 965     private int match(byte[] src, byte[] b, byte[] lastOcc, byte[] optoSft) {
 966         int len = src.length;
 967         int last = b.length - len;
 968         int i = 0;
 969         next:
 970         while (i &lt;= last) {
 971             for (int j = (len - 1); j &gt;= 0; j--) {
 972                 byte c = b[i + j];
 973                 if (c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;z&#39;) {
 974                     if (c &gt;= &#39;a&#39;) c -= 32; // Canonicalize
 975 
 976                     if (c != src[j]) {
 977                         // no match
 978                         int badShift = lastOcc[c - 32];
 979                         i += Math.max(j + 1 - badShift, optoSft[j]);
 980                         continue next;
 981                     }
 982                 } else {
 983                     // no match, character not valid for name
 984                     i += len;
 985                     continue next;
 986                 }
 987             }
 988             return i;
 989         }
 990         return -1;
 991     }
 992 
 993     /**
 994      * On first invocation, check if the JAR file has the Class-Path
 995      * and the Multi-Release attribute. A no-op on subsequent calls.
 996      */
 997     private void checkForSpecialAttributes() throws IOException {
 998         if (hasCheckedSpecialAttributes) {
 999             return;
1000         }
1001         synchronized (this) {
1002             if (hasCheckedSpecialAttributes) {
1003                 return;
1004             }
1005             JarEntry manEntry = getManEntry();
1006             if (manEntry != null) {
1007                 byte[] b = getBytes(manEntry);
1008                 hasClassPathAttribute = match(CLASSPATH_CHARS, b,
1009                         CLASSPATH_LASTOCC, CLASSPATH_OPTOSFT) != -1;
1010                 // is this a multi-release jar file
1011                 if (MULTI_RELEASE_ENABLED) {
1012                     int i = match(MULTIRELEASE_CHARS, b, MULTIRELEASE_LASTOCC,
1013                             MULTIRELEASE_OPTOSFT);
1014                     if (i != -1) {
1015                         // Read the main attributes of the manifest
1016                         byte[] lbuf = new byte[512];
1017                         Attributes attr = new Attributes();
1018                         attr.read(new Manifest.FastInputStream(
1019                             new ByteArrayInputStream(b)), lbuf);
1020                         isMultiRelease = Boolean.parseBoolean(
1021                             attr.getValue(Attributes.Name.MULTI_RELEASE));
1022                     }
1023                 }
1024             }
1025             hasCheckedSpecialAttributes = true;
1026         }
1027     }
1028 
1029     synchronized void ensureInitialization() {
1030         try {
1031             maybeInstantiateVerifier();
1032         } catch (IOException e) {
1033             throw new RuntimeException(e);
1034         }
1035         if (jv != null &amp;&amp; !jvInitialized) {
<a name="4" id="anc4"></a><span class="line-modified">1036             isInitializing.set(Boolean.TRUE);</span>
<span class="line-modified">1037             try {</span>
<span class="line-added">1038                 initializeVerifier();</span>
<span class="line-added">1039                 jvInitialized = true;</span>
<span class="line-added">1040             } finally {</span>
<span class="line-added">1041                 isInitializing.set(Boolean.FALSE);</span>
<span class="line-added">1042             }</span>
1043         }
1044     }
1045 
<a name="5" id="anc5"></a><span class="line-added">1046     static boolean isInitializing() {</span>
<span class="line-added">1047         Boolean value = isInitializing.get();</span>
<span class="line-added">1048         return (value == null) ? false : value;</span>
<span class="line-added">1049     }</span>
<span class="line-added">1050 </span>
1051     /*
1052      * Returns a versioned {@code JarFileEntry} for the given entry,
1053      * if there is one. Otherwise returns the original entry. This
1054      * is invoked by the {@code entries2} for verifier.
1055      */
1056     JarEntry newEntry(JarEntry je) {
1057         if (isMultiRelease()) {
1058             return getVersionedEntry(je.getName(), je);
1059         }
1060         return je;
1061     }
1062 
1063     /*
1064      * Returns a versioned {@code JarFileEntry} for the given entry
1065      * name, if there is one. Otherwise returns a {@code JarFileEntry}
1066      * with the given name. It is invoked from JarVerifier&#39;s entries2
1067      * for {@code singers}.
1068      */
1069     JarEntry newEntry(String name) {
1070         if (isMultiRelease()) {
1071             JarEntry vje = getVersionedEntry(name, (JarEntry)null);
1072             if (vje != null) {
1073                 return vje;
1074             }
1075         }
1076         return new JarFileEntry(name);
1077     }
1078 
1079     Enumeration&lt;String&gt; entryNames(CodeSource[] cs) {
1080         ensureInitialization();
1081         if (jv != null) {
1082             return jv.entryNames(this, cs);
1083         }
1084 
1085         /*
1086          * JAR file has no signed content. Is there a non-signing
1087          * code source?
1088          */
1089         boolean includeUnsigned = false;
1090         for (CodeSource c : cs) {
1091             if (c.getCodeSigners() == null) {
1092                 includeUnsigned = true;
1093                 break;
1094             }
1095         }
1096         if (includeUnsigned) {
1097             return unsignedEntryNames();
1098         } else {
1099             return Collections.emptyEnumeration();
1100         }
1101     }
1102 
1103     /**
1104      * Returns an enumeration of the zip file entries
1105      * excluding internal JAR mechanism entries and including
1106      * signed entries missing from the ZIP directory.
1107      */
1108     Enumeration&lt;JarEntry&gt; entries2() {
1109         ensureInitialization();
1110         if (jv != null) {
1111             return jv.entries2(this, JUZFA.entries(JarFile.this,
1112                                                    JarFileEntry::new));
1113         }
1114 
1115         // screen out entries which are never signed
1116         final var unfilteredEntries = JUZFA.entries(JarFile.this, JarFileEntry::new);
1117 
1118         return new Enumeration&lt;&gt;() {
1119 
1120             JarEntry entry;
1121 
1122             public boolean hasMoreElements() {
1123                 if (entry != null) {
1124                     return true;
1125                 }
1126                 while (unfilteredEntries.hasMoreElements()) {
1127                     JarEntry je = unfilteredEntries.nextElement();
1128                     if (JarVerifier.isSigningRelated(je.getName())) {
1129                         continue;
1130                     }
1131                     entry = je;
1132                     return true;
1133                 }
1134                 return false;
1135             }
1136 
1137             public JarEntry nextElement() {
1138                 if (hasMoreElements()) {
1139                     JarEntry je = entry;
1140                     entry = null;
1141                     return newEntry(je);
1142                 }
1143                 throw new NoSuchElementException();
1144             }
1145         };
1146     }
1147 
1148     CodeSource[] getCodeSources(URL url) {
1149         ensureInitialization();
1150         if (jv != null) {
1151             return jv.getCodeSources(this, url);
1152         }
1153 
1154         /*
1155          * JAR file has no signed content. Is there a non-signing
1156          * code source?
1157          */
1158         Enumeration&lt;String&gt; unsigned = unsignedEntryNames();
1159         if (unsigned.hasMoreElements()) {
1160             return new CodeSource[]{JarVerifier.getUnsignedCS(url)};
1161         } else {
1162             return null;
1163         }
1164     }
1165 
1166     private Enumeration&lt;String&gt; unsignedEntryNames() {
1167         final Enumeration&lt;JarEntry&gt; entries = entries();
1168         return new Enumeration&lt;&gt;() {
1169 
1170             String name;
1171 
1172             /*
1173              * Grab entries from ZIP directory but screen out
1174              * metadata.
1175              */
1176             public boolean hasMoreElements() {
1177                 if (name != null) {
1178                     return true;
1179                 }
1180                 while (entries.hasMoreElements()) {
1181                     String value;
1182                     ZipEntry e = entries.nextElement();
1183                     value = e.getName();
1184                     if (e.isDirectory() || JarVerifier.isSigningRelated(value)) {
1185                         continue;
1186                     }
1187                     name = value;
1188                     return true;
1189                 }
1190                 return false;
1191             }
1192 
1193             public String nextElement() {
1194                 if (hasMoreElements()) {
1195                     String value = name;
1196                     name = null;
1197                     return value;
1198                 }
1199                 throw new NoSuchElementException();
1200             }
1201         };
1202     }
1203 
1204     CodeSource getCodeSource(URL url, String name) {
1205         ensureInitialization();
1206         if (jv != null) {
1207             if (jv.eagerValidation) {
1208                 CodeSource cs = null;
1209                 JarEntry je = getJarEntry(name);
1210                 if (je != null) {
1211                     cs = jv.getCodeSource(url, this, je);
1212                 } else {
1213                     cs = jv.getCodeSource(url, name);
1214                 }
1215                 return cs;
1216             } else {
1217                 return jv.getCodeSource(url, name);
1218             }
1219         }
1220 
1221         return JarVerifier.getUnsignedCS(url);
1222     }
1223 
1224     void setEagerValidation(boolean eager) {
1225         try {
1226             maybeInstantiateVerifier();
1227         } catch (IOException e) {
1228             throw new RuntimeException(e);
1229         }
1230         if (jv != null) {
1231             jv.setEagerValidation(eager);
1232         }
1233     }
1234 
1235     List&lt;Object&gt; getManifestDigests() {
1236         ensureInitialization();
1237         if (jv != null) {
1238             return jv.getManifestDigests();
1239         }
1240         return new ArrayList&lt;&gt;();
1241     }
1242 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
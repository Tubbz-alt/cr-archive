<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Executable.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Constructor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Field.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Executable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
217      * @throws GenericSignatureFormatError if the generic
218      *     signature of this generic declaration does not conform to
219      *     the format specified in
220      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
221      */
222     public abstract TypeVariable&lt;?&gt;[] getTypeParameters();
223 
224     // returns shared array of parameter types - must never give it out
225     // to the untrusted code...
226     abstract Class&lt;?&gt;[] getSharedParameterTypes();
227 
228     // returns shared array of exception types - must never give it out
229     // to the untrusted code...
230     abstract Class&lt;?&gt;[] getSharedExceptionTypes();
231 
232     /**
233      * Returns an array of {@code Class} objects that represent the formal
234      * parameter types, in declaration order, of the executable
235      * represented by this object.  Returns an array of length
236      * 0 if the underlying executable takes no parameters.



237      *
238      * @return the parameter types for the executable this object
239      * represents
240      */
241     public abstract Class&lt;?&gt;[] getParameterTypes();
242 
243     /**
244      * Returns the number of formal parameters (whether explicitly
245      * declared or implicitly declared or neither) for the executable
246      * represented by this object.
247      *
248      * @return The number of formal parameters for the executable this
249      * object represents
250      */
251     public int getParameterCount() {
252         throw new AbstractMethodError();
253     }
254 
255     /**
256      * Returns an array of {@code Type} objects that represent the formal
257      * parameter types, in declaration order, of the executable represented by
258      * this object. Returns an array of length 0 if the
259      * underlying executable takes no parameters.



260      *
261      * &lt;p&gt;If a formal parameter type is a parameterized type,
262      * the {@code Type} object returned for it must accurately reflect
<span class="line-modified">263      * the actual type parameters used in the source code.</span>
264      *
265      * &lt;p&gt;If a formal parameter type is a type variable or a parameterized
266      * type, it is created. Otherwise, it is resolved.
267      *
268      * @return an array of {@code Type}s that represent the formal
269      *     parameter types of the underlying executable, in declaration order
270      * @throws GenericSignatureFormatError
271      *     if the generic method signature does not conform to the format
272      *     specified in
273      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
274      * @throws TypeNotPresentException if any of the parameter
275      *     types of the underlying executable refers to a non-existent type
276      *     declaration
277      * @throws MalformedParameterizedTypeException if any of
278      *     the underlying executable&#39;s parameter types refer to a parameterized
279      *     type that cannot be instantiated for any reason
280      */
281     public Type[] getGenericParameterTypes() {
282         if (hasGenericInformation())
283             return getGenericInfo().getParameterTypes();
</pre>
<hr />
<pre>
656      * Returns an {@code AnnotatedType} object that represents the use of a
657      * type to specify the receiver type of the method/constructor represented
658      * by this {@code Executable} object.
659      *
660      * The receiver type of a method/constructor is available only if the
661      * method/constructor has a receiver parameter (JLS 8.4.1). If this {@code
662      * Executable} object &lt;em&gt;represents an instance method or represents a
663      * constructor of an inner member class&lt;/em&gt;, and the
664      * method/constructor &lt;em&gt;either&lt;/em&gt; has no receiver parameter or has a
665      * receiver parameter with no annotations on its type, then the return
666      * value is an {@code AnnotatedType} object representing an element with no
667      * annotations.
668      *
669      * If this {@code Executable} object represents a static method or
670      * represents a constructor of a top level, static member, local, or
671      * anonymous class, then the return value is null.
672      *
673      * @return an object representing the receiver type of the method or
674      * constructor represented by this {@code Executable} or {@code null} if
675      * this {@code Executable} can not have a receiver parameter




676      */
677     public AnnotatedType getAnnotatedReceiverType() {
678         if (Modifier.isStatic(this.getModifiers()))
679             return null;
680         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
681                 SharedSecrets.getJavaLangAccess().
682                         getConstantPool(getDeclaringClass()),
683                 this,
684                 getDeclaringClass(),
685                 getDeclaringClass(),
686                 TypeAnnotation.TypeAnnotationTarget.METHOD_RECEIVER);
687     }
688 
689     /**
690      * Returns an array of {@code AnnotatedType} objects that represent the use
691      * of types to specify formal parameter types of the method/constructor
692      * represented by this Executable. The order of the objects in the array
693      * corresponds to the order of the formal parameter types in the
694      * declaration of the method/constructor.
695      *
696      * Returns an array of length 0 if the method/constructor declares no
697      * parameters.



698      *
699      * @return an array of objects representing the types of the
700      * formal parameters of the method or constructor represented by this
701      * {@code Executable}
702      */
703     public AnnotatedType[] getAnnotatedParameterTypes() {
704         return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),
705                 SharedSecrets.getJavaLangAccess().
706                         getConstantPool(getDeclaringClass()),
707                 this,
708                 getDeclaringClass(),
709                 getAllGenericParameterTypes(),
710                 TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER);
711     }
712 
713     /**
714      * Returns an array of {@code AnnotatedType} objects that represent the use
715      * of types to specify the declared exceptions of the method/constructor
716      * represented by this Executable. The order of the objects in the array
717      * corresponds to the order of the exception types in the declaration of
</pre>
</td>
<td>
<hr />
<pre>
217      * @throws GenericSignatureFormatError if the generic
218      *     signature of this generic declaration does not conform to
219      *     the format specified in
220      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
221      */
222     public abstract TypeVariable&lt;?&gt;[] getTypeParameters();
223 
224     // returns shared array of parameter types - must never give it out
225     // to the untrusted code...
226     abstract Class&lt;?&gt;[] getSharedParameterTypes();
227 
228     // returns shared array of exception types - must never give it out
229     // to the untrusted code...
230     abstract Class&lt;?&gt;[] getSharedExceptionTypes();
231 
232     /**
233      * Returns an array of {@code Class} objects that represent the formal
234      * parameter types, in declaration order, of the executable
235      * represented by this object.  Returns an array of length
236      * 0 if the underlying executable takes no parameters.
<span class="line-added">237      * Note that the constructors of some inner classes</span>
<span class="line-added">238      * may have an implicitly declared parameter in addition to</span>
<span class="line-added">239      * explicitly declared ones.</span>
240      *
241      * @return the parameter types for the executable this object
242      * represents
243      */
244     public abstract Class&lt;?&gt;[] getParameterTypes();
245 
246     /**
247      * Returns the number of formal parameters (whether explicitly
248      * declared or implicitly declared or neither) for the executable
249      * represented by this object.
250      *
251      * @return The number of formal parameters for the executable this
252      * object represents
253      */
254     public int getParameterCount() {
255         throw new AbstractMethodError();
256     }
257 
258     /**
259      * Returns an array of {@code Type} objects that represent the formal
260      * parameter types, in declaration order, of the executable represented by
261      * this object. Returns an array of length 0 if the
262      * underlying executable takes no parameters.
<span class="line-added">263      * Note that the constructors of some inner classes</span>
<span class="line-added">264      * may have an implicitly declared parameter in addition to</span>
<span class="line-added">265      * explicitly declared ones.</span>
266      *
267      * &lt;p&gt;If a formal parameter type is a parameterized type,
268      * the {@code Type} object returned for it must accurately reflect
<span class="line-modified">269      * the actual type arguments used in the source code.</span>
270      *
271      * &lt;p&gt;If a formal parameter type is a type variable or a parameterized
272      * type, it is created. Otherwise, it is resolved.
273      *
274      * @return an array of {@code Type}s that represent the formal
275      *     parameter types of the underlying executable, in declaration order
276      * @throws GenericSignatureFormatError
277      *     if the generic method signature does not conform to the format
278      *     specified in
279      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
280      * @throws TypeNotPresentException if any of the parameter
281      *     types of the underlying executable refers to a non-existent type
282      *     declaration
283      * @throws MalformedParameterizedTypeException if any of
284      *     the underlying executable&#39;s parameter types refer to a parameterized
285      *     type that cannot be instantiated for any reason
286      */
287     public Type[] getGenericParameterTypes() {
288         if (hasGenericInformation())
289             return getGenericInfo().getParameterTypes();
</pre>
<hr />
<pre>
662      * Returns an {@code AnnotatedType} object that represents the use of a
663      * type to specify the receiver type of the method/constructor represented
664      * by this {@code Executable} object.
665      *
666      * The receiver type of a method/constructor is available only if the
667      * method/constructor has a receiver parameter (JLS 8.4.1). If this {@code
668      * Executable} object &lt;em&gt;represents an instance method or represents a
669      * constructor of an inner member class&lt;/em&gt;, and the
670      * method/constructor &lt;em&gt;either&lt;/em&gt; has no receiver parameter or has a
671      * receiver parameter with no annotations on its type, then the return
672      * value is an {@code AnnotatedType} object representing an element with no
673      * annotations.
674      *
675      * If this {@code Executable} object represents a static method or
676      * represents a constructor of a top level, static member, local, or
677      * anonymous class, then the return value is null.
678      *
679      * @return an object representing the receiver type of the method or
680      * constructor represented by this {@code Executable} or {@code null} if
681      * this {@code Executable} can not have a receiver parameter
<span class="line-added">682      *</span>
<span class="line-added">683      * @jls 8.4 Method Declarations</span>
<span class="line-added">684      * @jls 8.4.1 Formal Parameters</span>
<span class="line-added">685      * @jls 8.8 Constructor Declarations</span>
686      */
687     public AnnotatedType getAnnotatedReceiverType() {
688         if (Modifier.isStatic(this.getModifiers()))
689             return null;
690         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
691                 SharedSecrets.getJavaLangAccess().
692                         getConstantPool(getDeclaringClass()),
693                 this,
694                 getDeclaringClass(),
695                 getDeclaringClass(),
696                 TypeAnnotation.TypeAnnotationTarget.METHOD_RECEIVER);
697     }
698 
699     /**
700      * Returns an array of {@code AnnotatedType} objects that represent the use
701      * of types to specify formal parameter types of the method/constructor
702      * represented by this Executable. The order of the objects in the array
703      * corresponds to the order of the formal parameter types in the
704      * declaration of the method/constructor.
705      *
706      * Returns an array of length 0 if the method/constructor declares no
707      * parameters.
<span class="line-added">708      * Note that the constructors of some inner classes</span>
<span class="line-added">709      * may have an implicitly declared parameter in addition to</span>
<span class="line-added">710      * explicitly declared ones.</span>
711      *
712      * @return an array of objects representing the types of the
713      * formal parameters of the method or constructor represented by this
714      * {@code Executable}
715      */
716     public AnnotatedType[] getAnnotatedParameterTypes() {
717         return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),
718                 SharedSecrets.getJavaLangAccess().
719                         getConstantPool(getDeclaringClass()),
720                 this,
721                 getDeclaringClass(),
722                 getAllGenericParameterTypes(),
723                 TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER);
724     }
725 
726     /**
727      * Returns an array of {@code AnnotatedType} objects that represent the use
728      * of types to specify the declared exceptions of the method/constructor
729      * represented by this Executable. The order of the objects in the array
730      * corresponds to the order of the exception types in the declaration of
</pre>
</td>
</tr>
</table>
<center><a href="Constructor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Field.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
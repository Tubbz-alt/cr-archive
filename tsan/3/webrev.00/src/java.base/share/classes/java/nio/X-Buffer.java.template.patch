diff a/src/java.base/share/classes/java/nio/X-Buffer.java.template b/src/java.base/share/classes/java/nio/X-Buffer.java.template
--- a/src/java.base/share/classes/java/nio/X-Buffer.java.template
+++ b/src/java.base/share/classes/java/nio/X-Buffer.java.template
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,10 +35,11 @@
 import java.util.stream.StreamSupport;
 import java.util.stream.$Streamtype$Stream;
 #end[streamableType]
 
 import java.util.Objects;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.util.ArraysSupport;
 
 /**
  * $A$ $type$ buffer.
  *
@@ -277,21 +278,29 @@
 
     // Creates a new buffer with the given mark, position, limit, capacity,
     // backing array, and array offset
     //
     $Type$Buffer(int mark, int pos, int lim, int cap,   // package-private
-                 $type$[] hb, int offset)
+                 $type$[] hb, int offset, MemorySegmentProxy segment)
     {
-        super(mark, pos, lim, cap);
+        super(mark, pos, lim, cap, segment);
         this.hb = hb;
         this.offset = offset;
     }
 
     // Creates a new buffer with the given mark, position, limit, and capacity
     //
-    $Type$Buffer(int mark, int pos, int lim, int cap) { // package-private
-        this(mark, pos, lim, cap, null, 0);
+    $Type$Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) { // package-private
+        this(mark, pos, lim, cap, null, 0, segment);
+    }
+
+    // Creates a new buffer with given base, address and capacity
+    //
+    $Type$Buffer($type$[] hb, long addr, int cap, MemorySegmentProxy segment) { // package-private
+        super(addr, cap, segment);
+        this.hb = hb;
+        this.offset = 0;
     }
 
     @Override
     Object base() {
         return hb;
@@ -346,11 +355,11 @@
      *          If the {@code capacity} is a negative integer
      */
     public static $Type$Buffer allocate(int capacity) {
         if (capacity < 0)
             throw createCapacityException(capacity);
-        return new Heap$Type$Buffer(capacity, capacity);
+        return new Heap$Type$Buffer(capacity, capacity, null);
     }
 
     /**
      * Wraps $a$ $type$ array into a buffer.
      *
@@ -391,11 +400,11 @@
      */
     public static $Type$Buffer wrap($type$[] array,
                                     int offset, int length)
     {
         try {
-            return new Heap$Type$Buffer(array, offset, length);
+            return new Heap$Type$Buffer(array, offset, length, null);
         } catch (IllegalArgumentException x) {
             throw new IndexOutOfBoundsException();
         }
     }
 
@@ -770,11 +779,11 @@
      * @throws  IndexOutOfBoundsException
      *          If the preconditions on the {@code offset} and {@code length}
      *          parameters do not hold
      */
     public $Type$Buffer get($type$[] dst, int offset, int length) {
-        checkBounds(offset, length, dst.length);
+        Objects.checkFromIndexSize(offset, length, dst.length);
         if (length > remaining())
             throw new BufferUnderflowException();
         int end = offset + length;
         for (int i = offset; i < end; i++)
             dst[i] = get();
@@ -994,11 +1003,11 @@
      *
      * @throws  ReadOnlyBufferException
      *          If this buffer is read-only
      */
     public $Type$Buffer put($type$[] src, int offset, int length) {
-        checkBounds(offset, length, src.length);
+        Objects.checkFromIndexSize(offset, length, src.length);
         if (length > remaining())
             throw new BufferOverflowException();
         int end = offset + length;
         for (int i = offset; i < end; i++)
             this.put(src[i]);
@@ -1174,11 +1183,11 @@
      *
      * @throws  ReadOnlyBufferException
      *          If this buffer is read-only
      */
     public $Type$Buffer put(String src, int start, int end) {
-        checkBounds(start, end - start, src.length());
+        Objects.checkFromIndexSize(start, end - start, src.length());
         if (isReadOnly())
             throw new ReadOnlyBufferException();
         if (end - start > remaining())
             throw new BufferOverflowException();
         for (int i = start; i < end; i++)
@@ -1858,18 +1867,31 @@
         return this;
     }
 
     /**
      * Returns the memory address, pointing to the byte at the given index,
-     * modulus the given unit size.
-     *
-     * <p> A return value greater than zero indicates the address of the byte at
-     * the index is misaligned for the unit size, and the value's quantity
-     * indicates how much the index should be rounded up or down to locate a
-     * byte at an aligned address.  Otherwise, a value of {@code 0} indicates
-     * that the address of the byte at the index is aligned for the unit size.
-     *
+     * modulo the given unit size.
+     *
+     * <p> The return value is non-negative in the range of {@code 0}
+     * (inclusive) up to {@code unitSize} (exclusive), with zero indicating
+     * that the address of the byte at the index is aligned for the unit size,
+     * and a positive value that the address is misaligned for the unit size.
+     * If the address of the byte at the index is misaligned, the return value
+     * represents how much the index should be adjusted to locate a byte at an
+     * aligned address.  Specifically, the index should either be decremented by
+     * the return value if the latter is not greater than {@code index}, or be
+     * incremented by the unit size minus the return value.  Therefore given
+     * <blockquote><pre>
+     * int value = alignmentOffset(index, unitSize)</pre></blockquote>
+     * then the identities
+     * <blockquote><pre>
+     * alignmentOffset(index - value, unitSize) == 0, value &le; index</pre></blockquote>
+     * and
+     * <blockquote><pre>
+     * alignmentOffset(index + (unitSize - value), unitSize) == 0</pre></blockquote>
+     * must hold.
+     * 
      * @apiNote
      * This method may be utilized to determine if unit size bytes from an
      * index can be accessed atomically, if supported by the native platform.
      *
      * @implNote
@@ -1881,11 +1903,11 @@
      *         upper bounds check is performed
      *
      * @param  unitSize
      *         The unit size in bytes, must be a power of {@code 2}
      *
-     * @return  The indexed byte's memory address modulus the unit size
+     * @return  The indexed byte's memory address modulo the unit size
      *
      * @throws IllegalArgumentException
      *         If the index is negative or the unit size is not a power of
      *         {@code 2}
      *
@@ -1907,11 +1929,11 @@
         if (unitSize < 1 || (unitSize & (unitSize - 1)) != 0)
             throw new IllegalArgumentException("Unit size not a power of two: " + unitSize);
         if (unitSize > 8 && !isDirect())
             throw new UnsupportedOperationException("Unit size unsupported for non-direct buffers: " + unitSize);
 
-        return (int) ((address + index) % unitSize);
+        return (int) ((address + index) & (unitSize - 1));
     }
 
     /**
      * Creates a new byte buffer whose content is a shared and aligned
      * subsequence of this buffer's content.

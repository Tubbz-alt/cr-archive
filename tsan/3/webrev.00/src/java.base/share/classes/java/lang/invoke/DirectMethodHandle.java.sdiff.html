<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantCallSite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="GenerateJLIClassesHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
289     }
290 
291     /* assert */ static Object findDirectMethodHandle(Name name) {
292         if (name.function.equals(getFunction(NF_internalMemberName)) ||
293             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
294             name.function.equals(getFunction(NF_constructorMethod))) {
295             assert(name.arguments.length == 1);
296             return name.arguments[0];
297         }
298         return null;
299     }
300 
301     private static void maybeCompile(LambdaForm lform, MemberName m) {
302         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
303             // Help along bootstrapping...
304             lform.compileToBytecode();
305     }
306 
307     /** Static wrapper for DirectMethodHandle.internalMemberName. */
308     @ForceInline
<span class="line-modified">309     /*non-public*/ static Object internalMemberName(Object mh) {</span>

310         return ((DirectMethodHandle)mh).member;
311     }
312 
313     /** Static wrapper for DirectMethodHandle.internalMemberName.
314      * This one also forces initialization.
315      */
<span class="line-modified">316     /*non-public*/ static Object internalMemberNameEnsureInit(Object mh) {</span>

317         DirectMethodHandle dmh = (DirectMethodHandle)mh;
318         dmh.ensureInitialized();
319         return dmh.member;
320     }
321 
<span class="line-modified">322     /*non-public*/ static</span>
<span class="line-modified">323     boolean shouldBeInitialized(MemberName member) {</span>
324         switch (member.getReferenceKind()) {
325         case REF_invokeStatic:
326         case REF_getStatic:
327         case REF_putStatic:
328         case REF_newInvokeSpecial:
329             break;
330         default:
331             // No need to initialize the class on this kind of member.
332             return false;
333         }
334         Class&lt;?&gt; cls = member.getDeclaringClass();
335         if (cls == ValueConversions.class ||
336             cls == MethodHandleImpl.class ||
337             cls == Invokers.class) {
338             // These guys have lots of &lt;clinit&gt; DMH creation but we know
339             // the MHs will not be used until the system is booted.
340             return false;
341         }
342         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
343             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
</pre>
<hr />
<pre>
379         if (ref == null) {
380             return true;  // the final state
381         }
382         Thread clinitThread = ref.get();
383         // Somebody may still be running defc.&lt;clinit&gt;.
384         if (clinitThread == Thread.currentThread()) {
385             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
386             if (UNSAFE.shouldBeInitialized(defc))
387                 // Yes, we are running it; keep the barrier for now.
388                 return false;
389         } else {
390             // We are in a random thread.  Block.
391             UNSAFE.ensureClassInitialized(defc);
392         }
393         assert(!UNSAFE.shouldBeInitialized(defc));
394         // put it into the final state
395         EnsureInitialized.INSTANCE.remove(defc);
396         return true;
397     }
398 
<span class="line-modified">399     /*non-public*/ static void ensureInitialized(Object mh) {</span>

400         ((DirectMethodHandle)mh).ensureInitialized();
401     }
402 
403     /** This subclass represents invokespecial instructions. */
404     static class Special extends DirectMethodHandle {
405         private final Class&lt;?&gt; caller;
406         private Special(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; caller) {
407             super(mtype, form, member);
408             this.caller = caller;
409         }
410         @Override
411         boolean isInvokeSpecial() {
412             return true;
413         }
414         @Override
415         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
416             return new Special(mt, lf, member, caller);
417         }
418         Object checkReceiver(Object recv) {
419             if (!caller.isInstance(recv)) {
</pre>
<hr />
<pre>
455 
456 
457     /** This subclass handles constructor references. */
458     static class Constructor extends DirectMethodHandle {
459         final MemberName initMethod;
460         final Class&lt;?&gt;   instanceClass;
461 
462         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
463                             MemberName initMethod, Class&lt;?&gt; instanceClass) {
464             super(mtype, form, constructor);
465             this.initMethod = initMethod;
466             this.instanceClass = instanceClass;
467             assert(initMethod.isResolved());
468         }
469         @Override
470         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
471             return new Constructor(mt, lf, member, initMethod, instanceClass);
472         }
473     }
474 
<span class="line-modified">475     /*non-public*/ static Object constructorMethod(Object mh) {</span>

476         Constructor dmh = (Constructor)mh;
477         return dmh.initMethod;
478     }
479 
<span class="line-modified">480     /*non-public*/ static Object allocateInstance(Object mh) throws InstantiationException {</span>

481         Constructor dmh = (Constructor)mh;
482         return UNSAFE.allocateInstance(dmh.instanceClass);
483     }
484 
485     /** This subclass handles non-static field references. */
486     static class Accessor extends DirectMethodHandle {
487         final Class&lt;?&gt; fieldType;
488         final int      fieldOffset;
489         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
490                          int fieldOffset) {
491             super(mtype, form, member);
492             this.fieldType   = member.getFieldType();
493             this.fieldOffset = fieldOffset;
494         }
495 
496         @Override Object checkCast(Object obj) {
497             return fieldType.cast(obj);
498         }
499         @Override
500         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
501             return new Accessor(mt, lf, member, fieldOffset);
502         }
503     }
504 
505     @ForceInline
<span class="line-modified">506     /*non-public*/ static long fieldOffset(Object accessorObj) {</span>

507         // Note: We return a long because that is what Unsafe.getObject likes.
508         // We store a plain int because it is more compact.
509         return ((Accessor)accessorObj).fieldOffset;
510     }
511 
512     @ForceInline
<span class="line-modified">513     /*non-public*/ static Object checkBase(Object obj) {</span>

514         // Note that the object&#39;s class has already been verified,
515         // since the parameter type of the Accessor method handle
516         // is either member.getDeclaringClass or a subclass.
517         // This was verified in DirectMethodHandle.make.
518         // Therefore, the only remaining check is for null.
519         // Since this check is *not* guaranteed by Unsafe.getInt
520         // and its siblings, we need to make an explicit one here.
521         return Objects.requireNonNull(obj);
522     }
523 
524     /** This subclass handles static field references. */
525     static class StaticAccessor extends DirectMethodHandle {
526         private final Class&lt;?&gt; fieldType;
527         private final Object   staticBase;
528         private final long     staticOffset;
529 
530         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
531                                Object staticBase, long staticOffset) {
532             super(mtype, form, member);
533             this.fieldType    = member.getFieldType();
534             this.staticBase   = staticBase;
535             this.staticOffset = staticOffset;
536         }
537 
538         @Override Object checkCast(Object obj) {
539             return fieldType.cast(obj);
540         }
541         @Override
542         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
543             return new StaticAccessor(mt, lf, member, staticBase, staticOffset);
544         }
545     }
546 
547     @ForceInline
<span class="line-modified">548     /*non-public*/ static Object nullCheck(Object obj) {</span>

549         return Objects.requireNonNull(obj);
550     }
551 
552     @ForceInline
<span class="line-modified">553     /*non-public*/ static Object staticBase(Object accessorObj) {</span>

554         return ((StaticAccessor)accessorObj).staticBase;
555     }
556 
557     @ForceInline
<span class="line-modified">558     /*non-public*/ static long staticOffset(Object accessorObj) {</span>

559         return ((StaticAccessor)accessorObj).staticOffset;
560     }
561 
562     @ForceInline
<span class="line-modified">563     /*non-public*/ static Object checkCast(Object mh, Object obj) {</span>

564         return ((DirectMethodHandle) mh).checkCast(obj);
565     }
566 
567     Object checkCast(Object obj) {
568         return member.getReturnType().cast(obj);
569     }
570 
571     // Caching machinery for field accessors:
572     static final byte
573             AF_GETFIELD        = 0,
574             AF_PUTFIELD        = 1,
575             AF_GETSTATIC       = 2,
576             AF_PUTSTATIC       = 3,
577             AF_GETSTATIC_INIT  = 4,
578             AF_PUTSTATIC_INIT  = 5,
579             AF_LIMIT           = 6;
580     // Enumerate the different field kinds using Wrapper,
581     // with an extra case added for checked references.
582     static final int
583             FT_LAST_WRAPPER    = Wrapper.COUNT-1,
</pre>
</td>
<td>
<hr />
<pre>
289     }
290 
291     /* assert */ static Object findDirectMethodHandle(Name name) {
292         if (name.function.equals(getFunction(NF_internalMemberName)) ||
293             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
294             name.function.equals(getFunction(NF_constructorMethod))) {
295             assert(name.arguments.length == 1);
296             return name.arguments[0];
297         }
298         return null;
299     }
300 
301     private static void maybeCompile(LambdaForm lform, MemberName m) {
302         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
303             // Help along bootstrapping...
304             lform.compileToBytecode();
305     }
306 
307     /** Static wrapper for DirectMethodHandle.internalMemberName. */
308     @ForceInline
<span class="line-modified">309     /*non-public*/</span>
<span class="line-added">310     static Object internalMemberName(Object mh) {</span>
311         return ((DirectMethodHandle)mh).member;
312     }
313 
314     /** Static wrapper for DirectMethodHandle.internalMemberName.
315      * This one also forces initialization.
316      */
<span class="line-modified">317     /*non-public*/</span>
<span class="line-added">318     static Object internalMemberNameEnsureInit(Object mh) {</span>
319         DirectMethodHandle dmh = (DirectMethodHandle)mh;
320         dmh.ensureInitialized();
321         return dmh.member;
322     }
323 
<span class="line-modified">324     /*non-public*/</span>
<span class="line-modified">325     static boolean shouldBeInitialized(MemberName member) {</span>
326         switch (member.getReferenceKind()) {
327         case REF_invokeStatic:
328         case REF_getStatic:
329         case REF_putStatic:
330         case REF_newInvokeSpecial:
331             break;
332         default:
333             // No need to initialize the class on this kind of member.
334             return false;
335         }
336         Class&lt;?&gt; cls = member.getDeclaringClass();
337         if (cls == ValueConversions.class ||
338             cls == MethodHandleImpl.class ||
339             cls == Invokers.class) {
340             // These guys have lots of &lt;clinit&gt; DMH creation but we know
341             // the MHs will not be used until the system is booted.
342             return false;
343         }
344         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
345             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
</pre>
<hr />
<pre>
381         if (ref == null) {
382             return true;  // the final state
383         }
384         Thread clinitThread = ref.get();
385         // Somebody may still be running defc.&lt;clinit&gt;.
386         if (clinitThread == Thread.currentThread()) {
387             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
388             if (UNSAFE.shouldBeInitialized(defc))
389                 // Yes, we are running it; keep the barrier for now.
390                 return false;
391         } else {
392             // We are in a random thread.  Block.
393             UNSAFE.ensureClassInitialized(defc);
394         }
395         assert(!UNSAFE.shouldBeInitialized(defc));
396         // put it into the final state
397         EnsureInitialized.INSTANCE.remove(defc);
398         return true;
399     }
400 
<span class="line-modified">401     /*non-public*/</span>
<span class="line-added">402     static void ensureInitialized(Object mh) {</span>
403         ((DirectMethodHandle)mh).ensureInitialized();
404     }
405 
406     /** This subclass represents invokespecial instructions. */
407     static class Special extends DirectMethodHandle {
408         private final Class&lt;?&gt; caller;
409         private Special(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; caller) {
410             super(mtype, form, member);
411             this.caller = caller;
412         }
413         @Override
414         boolean isInvokeSpecial() {
415             return true;
416         }
417         @Override
418         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
419             return new Special(mt, lf, member, caller);
420         }
421         Object checkReceiver(Object recv) {
422             if (!caller.isInstance(recv)) {
</pre>
<hr />
<pre>
458 
459 
460     /** This subclass handles constructor references. */
461     static class Constructor extends DirectMethodHandle {
462         final MemberName initMethod;
463         final Class&lt;?&gt;   instanceClass;
464 
465         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
466                             MemberName initMethod, Class&lt;?&gt; instanceClass) {
467             super(mtype, form, constructor);
468             this.initMethod = initMethod;
469             this.instanceClass = instanceClass;
470             assert(initMethod.isResolved());
471         }
472         @Override
473         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
474             return new Constructor(mt, lf, member, initMethod, instanceClass);
475         }
476     }
477 
<span class="line-modified">478     /*non-public*/</span>
<span class="line-added">479     static Object constructorMethod(Object mh) {</span>
480         Constructor dmh = (Constructor)mh;
481         return dmh.initMethod;
482     }
483 
<span class="line-modified">484     /*non-public*/</span>
<span class="line-added">485     static Object allocateInstance(Object mh) throws InstantiationException {</span>
486         Constructor dmh = (Constructor)mh;
487         return UNSAFE.allocateInstance(dmh.instanceClass);
488     }
489 
490     /** This subclass handles non-static field references. */
491     static class Accessor extends DirectMethodHandle {
492         final Class&lt;?&gt; fieldType;
493         final int      fieldOffset;
494         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
495                          int fieldOffset) {
496             super(mtype, form, member);
497             this.fieldType   = member.getFieldType();
498             this.fieldOffset = fieldOffset;
499         }
500 
501         @Override Object checkCast(Object obj) {
502             return fieldType.cast(obj);
503         }
504         @Override
505         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
506             return new Accessor(mt, lf, member, fieldOffset);
507         }
508     }
509 
510     @ForceInline
<span class="line-modified">511     /*non-public*/</span>
<span class="line-added">512     static long fieldOffset(Object accessorObj) {</span>
513         // Note: We return a long because that is what Unsafe.getObject likes.
514         // We store a plain int because it is more compact.
515         return ((Accessor)accessorObj).fieldOffset;
516     }
517 
518     @ForceInline
<span class="line-modified">519     /*non-public*/</span>
<span class="line-added">520     static Object checkBase(Object obj) {</span>
521         // Note that the object&#39;s class has already been verified,
522         // since the parameter type of the Accessor method handle
523         // is either member.getDeclaringClass or a subclass.
524         // This was verified in DirectMethodHandle.make.
525         // Therefore, the only remaining check is for null.
526         // Since this check is *not* guaranteed by Unsafe.getInt
527         // and its siblings, we need to make an explicit one here.
528         return Objects.requireNonNull(obj);
529     }
530 
531     /** This subclass handles static field references. */
532     static class StaticAccessor extends DirectMethodHandle {
533         private final Class&lt;?&gt; fieldType;
534         private final Object   staticBase;
535         private final long     staticOffset;
536 
537         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
538                                Object staticBase, long staticOffset) {
539             super(mtype, form, member);
540             this.fieldType    = member.getFieldType();
541             this.staticBase   = staticBase;
542             this.staticOffset = staticOffset;
543         }
544 
545         @Override Object checkCast(Object obj) {
546             return fieldType.cast(obj);
547         }
548         @Override
549         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
550             return new StaticAccessor(mt, lf, member, staticBase, staticOffset);
551         }
552     }
553 
554     @ForceInline
<span class="line-modified">555     /*non-public*/</span>
<span class="line-added">556     static Object nullCheck(Object obj) {</span>
557         return Objects.requireNonNull(obj);
558     }
559 
560     @ForceInline
<span class="line-modified">561     /*non-public*/</span>
<span class="line-added">562     static Object staticBase(Object accessorObj) {</span>
563         return ((StaticAccessor)accessorObj).staticBase;
564     }
565 
566     @ForceInline
<span class="line-modified">567     /*non-public*/</span>
<span class="line-added">568     static long staticOffset(Object accessorObj) {</span>
569         return ((StaticAccessor)accessorObj).staticOffset;
570     }
571 
572     @ForceInline
<span class="line-modified">573     /*non-public*/</span>
<span class="line-added">574     static Object checkCast(Object mh, Object obj) {</span>
575         return ((DirectMethodHandle) mh).checkCast(obj);
576     }
577 
578     Object checkCast(Object obj) {
579         return member.getReturnType().cast(obj);
580     }
581 
582     // Caching machinery for field accessors:
583     static final byte
584             AF_GETFIELD        = 0,
585             AF_PUTFIELD        = 1,
586             AF_GETSTATIC       = 2,
587             AF_PUTSTATIC       = 3,
588             AF_GETSTATIC_INIT  = 4,
589             AF_PUTSTATIC_INIT  = 5,
590             AF_LIMIT           = 6;
591     // Enumerate the different field kinds using Wrapper,
592     // with an extra case added for checked references.
593     static final int
594             FT_LAST_WRAPPER    = Wrapper.COUNT-1,
</pre>
</td>
</tr>
</table>
<center><a href="ConstantCallSite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="GenerateJLIClassesHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
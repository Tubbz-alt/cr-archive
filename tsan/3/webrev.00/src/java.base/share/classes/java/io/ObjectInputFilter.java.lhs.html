<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/ObjectInputFilter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.security.AccessController;
 29 import java.security.PrivilegedAction;
 30 import java.security.Security;
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.Optional;
 35 import java.util.function.Function;
 36 
 37 import jdk.internal.access.SharedSecrets;
<a name="1" id="anc1"></a>
 38 
 39 /**
 40  * Filter classes, array lengths, and graph metrics during deserialization.
 41  *
 42  * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
 43  * and should be avoided. Untrusted data should be carefully validated according to the
 44  * &quot;Serialization and Deserialization&quot; section of the
 45  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
 46  * {@extLink serialization_filter_guide Serialization Filtering} describes best
 47  * practices for defensive use of serial filters.
 48  * &lt;/strong&gt;&lt;/p&gt;
 49  *
 50  * If set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}
 51  * method is called to validate classes, the length of each array,
 52  * the number of objects being read from the stream, the depth of the graph,
 53  * and the total number of bytes read from the stream.
 54  * &lt;p&gt;
 55  * A filter can be set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}
 56  * for an individual ObjectInputStream.
 57  * A filter can be set via {@link Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}
 58  * to affect every {@code ObjectInputStream} that does not otherwise set a filter.
 59  * &lt;p&gt;
 60  * A filter determines whether the arguments are {@link Status#ALLOWED ALLOWED}
 61  * or {@link Status#REJECTED REJECTED} and should return the appropriate status.
 62  * If the filter cannot determine the status it should return
 63  * {@link Status#UNDECIDED UNDECIDED}.
 64  * Filters should be designed for the specific use case and expected types.
 65  * A filter designed for a particular use may be passed a class that is outside
 66  * of the scope of the filter. If the purpose of the filter is to black-list classes
 67  * then it can reject a candidate class that matches and report UNDECIDED for others.
 68  * A filter may be called with class equals {@code null}, {@code arrayLength} equal -1,
 69  * the depth, number of references, and stream size and return a status
 70  * that reflects only one or only some of the values.
 71  * This allows a filter to specific about the choice it is reporting and
 72  * to use other filters without forcing either allowed or rejected status.
 73  *
 74  * &lt;p&gt;
 75  * Typically, a custom filter should check if a system-wide filter
 76  * is configured and defer to it if so. For example,
 77  * &lt;pre&gt;{@code
 78  * ObjectInputFilter.Status checkInput(FilterInfo info) {
 79  *     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();
 80  *     if (serialFilter != null) {
 81  *         ObjectInputFilter.Status status = serialFilter.checkInput(info);
 82  *         if (status != ObjectInputFilter.Status.UNDECIDED) {
 83  *             // The system-wide filter overrides this filter
 84  *             return status;
 85  *         }
 86  *     }
 87  *     if (info.serialClass() != null &amp;&amp;
 88  *         Remote.class.isAssignableFrom(info.serialClass())) {
 89  *         return Status.REJECTED;      // Do not allow Remote objects
 90  *     }
 91  *     return Status.UNDECIDED;
 92  * }
 93  *}&lt;/pre&gt;
 94  * &lt;p&gt;
 95  * Unless otherwise noted, passing a {@code null} argument to a
 96  * method in this interface and its nested classes will cause a
 97  * {@link NullPointerException} to be thrown.
 98  *
 99  * @see ObjectInputStream#setObjectInputFilter(ObjectInputFilter)
100  * @since 9
101  */
102 @FunctionalInterface
103 public interface ObjectInputFilter {
104 
105     /**
106      * Check the class, array length, number of object references, depth,
107      * stream size, and other available filtering information.
108      * Implementations of this method check the contents of the object graph being created
109      * during deserialization. The filter returns {@link Status#ALLOWED Status.ALLOWED},
110      * {@link Status#REJECTED Status.REJECTED}, or {@link Status#UNDECIDED Status.UNDECIDED}.
111      *
112      * @param filterInfo provides information about the current object being deserialized,
113      *             if any, and the status of the {@link ObjectInputStream}
114      * @return  {@link Status#ALLOWED Status.ALLOWED} if accepted,
115      *          {@link Status#REJECTED Status.REJECTED} if rejected,
116      *          {@link Status#UNDECIDED Status.UNDECIDED} if undecided.
117      */
118     Status checkInput(FilterInfo filterInfo);
119 
120     /**
121      * FilterInfo provides access to information about the current object
122      * being deserialized and the status of the {@link ObjectInputStream}.
123      * @since 9
124      */
125     interface FilterInfo {
126         /**
127          * The class of an object being deserialized.
128          * For arrays, it is the array type.
129          * For example, the array class name of a 2 dimensional array of strings is
130          * &quot;{@code [[Ljava.lang.String;}&quot;.
131          * To check the array&#39;s element type, iteratively use
132          * {@link Class#getComponentType() Class.getComponentType} while the result
133          * is an array and then check the class.
134          * The {@code serialClass is null} in the case where a new object is not being
135          * created and to give the filter a chance to check the depth, number of
136          * references to existing objects, and the stream size.
137          *
138          * @return class of an object being deserialized; may be null
139          */
140         Class&lt;?&gt; serialClass();
141 
142         /**
143          * The number of array elements when deserializing an array of the class.
144          *
145          * @return the non-negative number of array elements when deserializing
146          * an array of the class, otherwise -1
147          */
148         long arrayLength();
149 
150         /**
151          * The current depth.
152          * The depth starts at {@code 1} and increases for each nested object and
153          * decrements when each nested object returns.
154          *
155          * @return the current depth
156          */
157         long depth();
158 
159         /**
160          * The current number of object references.
161          *
162          * @return the non-negative current number of object references
163          */
164         long references();
165 
166         /**
167          * The current number of bytes consumed.
168          * @implSpec  {@code streamBytes} is implementation specific
169          * and may not be directly related to the object in the stream
170          * that caused the callback.
171          *
172          * @return the non-negative current number of bytes consumed
173          */
174         long streamBytes();
175     }
176 
177     /**
178      * The status of a check on the class, array length, number of references,
179      * depth, and stream size.
180      *
181      * @since 9
182      */
183     enum Status {
184         /**
185          * The status is undecided, not allowed and not rejected.
186          */
187         UNDECIDED,
188         /**
189          * The status is allowed.
190          */
191         ALLOWED,
192         /**
193          * The status is rejected.
194          */
195         REJECTED;
196     }
197 
198     /**
199      * A utility class to set and get the system-wide filter or create a filter
200      * from a pattern string. If a system-wide filter is set, it will be
201      * used for each {@link ObjectInputStream} that does not set its own filter.
202      * &lt;p&gt;
203      * When setting the filter, it should be stateless and idempotent,
204      * reporting the same result when passed the same arguments.
205      * &lt;p&gt;
206      * The filter is configured during the initialization of the {@code ObjectInputFilter.Config}
207      * class. For example, by calling {@link #getSerialFilter() Config.getSerialFilter}.
<a name="2" id="anc2"></a><span class="line-modified">208      * If the system property {@code jdk.serialFilter} is defined, it is used</span>
<span class="line-modified">209      * to configure the filter.</span>
<span class="line-modified">210      * If the system property is not defined, and the {@link java.security.Security}</span>
<span class="line-modified">211      * property {@code jdk.serialFilter} is defined then it is used to configure the filter.</span>
<span class="line-modified">212      * Otherwise, the filter is not configured during initialization.</span>



213      * The syntax for each property is the same as for the
214      * {@link #createFilter(String) createFilter} method.
<a name="3" id="anc3"></a><span class="line-removed">215      * If a filter is not configured, it can be set with</span>
<span class="line-removed">216      * {@link #setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.</span>
217      *
218      * @since 9
219      */
220     final class Config {
221         /* No instances. */
222         private Config() {}
223 
224         /**
225          * Lock object for system-wide filter.
226          */
227         private final static Object serialFilterLock = new Object();
228 
229         /**
230          * Debug: Logger
231          */
232         private final static System.Logger configLog;
233 
234         /**
235          * Logger for debugging.
236          */
237         static void filterLog(System.Logger.Level level, String msg, Object... args) {
238             if (configLog != null) {
239                 configLog.log(level, msg, args);
240             }
241         }
242 
243         /**
244          * The name for the system-wide deserialization filter.
245          * Used as a system property and a java.security.Security property.
246          */
247         private final static String SERIAL_FILTER_PROPNAME = &quot;jdk.serialFilter&quot;;
248 
249         /**
250          * The system-wide filter; may be null.
251          * Lookup the filter in java.security.Security or
252          * the system property.
253          */
254         private final static ObjectInputFilter configuredFilter;
255 
256         static {
257             configuredFilter = AccessController
258                     .doPrivileged((PrivilegedAction&lt;ObjectInputFilter&gt;) () -&gt; {
<a name="4" id="anc4"></a><span class="line-modified">259                         String props = System.getProperty(SERIAL_FILTER_PROPNAME);</span>
260                         if (props == null) {
261                             props = Security.getProperty(SERIAL_FILTER_PROPNAME);
262                         }
263                         if (props != null) {
264                             System.Logger log =
265                                     System.getLogger(&quot;java.io.serialization&quot;);
266                             log.log(System.Logger.Level.INFO,
267                                     &quot;Creating serialization filter from {0}&quot;, props);
268                             try {
269                                 return createFilter(props);
270                             } catch (RuntimeException re) {
271                                 log.log(System.Logger.Level.ERROR,
272                                         &quot;Error configuring filter: {0}&quot;, re);
273                             }
274                         }
275                         return null;
276                     });
277             configLog = (configuredFilter != null) ? System.getLogger(&quot;java.io.serialization&quot;) : null;
278 
279             // Setup shared secrets for RegistryImpl to use.
280             SharedSecrets.setJavaObjectInputFilterAccess(Config::createFilter2);
281         }
282 
283         /**
284          * Current configured filter.
285          */
<a name="5" id="anc5"></a><span class="line-modified">286         private static ObjectInputFilter serialFilter = configuredFilter;</span>
287 
288         /**
289          * Returns the system-wide serialization filter or {@code null} if not configured.
290          *
291          * @return the system-wide serialization filter or {@code null} if not configured
292          */
293         public static ObjectInputFilter getSerialFilter() {
<a name="6" id="anc6"></a><span class="line-modified">294             synchronized (serialFilterLock) {</span>
<span class="line-removed">295                 return serialFilter;</span>
<span class="line-removed">296             }</span>
297         }
298 
299         /**
300          * Set the system-wide filter if it has not already been configured or set.
301          *
302          * @param filter the serialization filter to set as the system-wide filter; not null
303          * @throws SecurityException if there is security manager and the
304          *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted
305          * @throws IllegalStateException if the filter has already been set {@code non-null}
306          */
307         public static void setSerialFilter(ObjectInputFilter filter) {
308             Objects.requireNonNull(filter, &quot;filter&quot;);
309             SecurityManager sm = System.getSecurityManager();
310             if (sm != null) {
311                 sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);
312             }
313             synchronized (serialFilterLock) {
314                 if (serialFilter != null) {
315                     throw new IllegalStateException(&quot;Serial filter can only be set once&quot;);
316                 }
317                 serialFilter = filter;
318             }
319         }
320 
321         /**
322          * Returns an ObjectInputFilter from a string of patterns.
323          * &lt;p&gt;
324          * Patterns are separated by &quot;;&quot; (semicolon). Whitespace is significant and
325          * is considered part of the pattern.
326          * If a pattern includes an equals assignment, &quot;{@code =}&quot; it sets a limit.
327          * If a limit appears more than once the last value is used.
328          * &lt;ul&gt;
329          *     &lt;li&gt;maxdepth={@code value} - the maximum depth of a graph&lt;/li&gt;
330          *     &lt;li&gt;maxrefs={@code value}  - the maximum number of internal references&lt;/li&gt;
331          *     &lt;li&gt;maxbytes={@code value} - the maximum number of bytes in the input stream&lt;/li&gt;
332          *     &lt;li&gt;maxarray={@code value} - the maximum array length allowed&lt;/li&gt;
333          * &lt;/ul&gt;
334          * &lt;p&gt;
335          * Other patterns match or reject class or package name
336          * as returned from {@link Class#getName() Class.getName()} and
337          * if an optional module name is present
338          * {@link Module#getName() class.getModule().getName()}.
339          * Note that for arrays the element type is used in the pattern,
340          * not the array type.
341          * &lt;ul&gt;
342          * &lt;li&gt;If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched;
343          *     otherwise the class is allowed if the pattern matches.
344          * &lt;li&gt;If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name;
345          *     if the module name matches the module name of the class then
346          *     the remaining pattern is matched with the class name.
347          *     If there is no &quot;/&quot;, the module name is not compared.
348          * &lt;li&gt;If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.
349          * &lt;li&gt;If the pattern ends with &quot;.*&quot; it matches any class in the package.
350          * &lt;li&gt;If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.
351          * &lt;li&gt;If the pattern is equal to the class name, it matches.
352          * &lt;li&gt;Otherwise, the pattern is not matched.
353          * &lt;/ul&gt;
354          * &lt;p&gt;
355          * The resulting filter performs the limit checks and then
356          * tries to match the class, if any. If any of the limits are exceeded,
357          * the filter returns {@link Status#REJECTED Status.REJECTED}.
358          * If the class is an array type, the class to be matched is the element type.
359          * Arrays of any number of dimensions are treated the same as the element type.
360          * For example, a pattern of &quot;{@code !example.Foo}&quot;,
361          * rejects creation of any instance or array of {@code example.Foo}.
362          * The first pattern that matches, working from left to right, determines
363          * the {@link Status#ALLOWED Status.ALLOWED}
364          * or {@link Status#REJECTED Status.REJECTED} result.
365          * If the limits are not exceeded and no pattern matches the class,
366          * the result is {@link Status#UNDECIDED Status.UNDECIDED}.
367          *
368          * @param pattern the pattern string to parse; not null
369          * @return a filter to check a class being deserialized;
370          *          {@code null} if no patterns
371          * @throws IllegalArgumentException if the pattern string is illegal or
372          *         malformed and cannot be parsed.
373          *         In particular, if any of the following is true:
374          * &lt;ul&gt;
375          * &lt;li&gt;   if a limit is missing the name or the name is not one of
376          *        &quot;maxdepth&quot;, &quot;maxrefs&quot;, &quot;maxbytes&quot;, or &quot;maxarray&quot;
377          * &lt;li&gt;   if the value of the limit can not be parsed by
378          *        {@link Long#parseLong Long.parseLong} or is negative
379          * &lt;li&gt;   if the pattern contains &quot;/&quot; and the module name is missing
380          *        or the remaining pattern is empty
381          * &lt;li&gt;   if the package is missing for &quot;.*&quot; and &quot;.**&quot;
382          * &lt;/ul&gt;
383          */
384         public static ObjectInputFilter createFilter(String pattern) {
385             Objects.requireNonNull(pattern, &quot;pattern&quot;);
386             return Global.createFilter(pattern, true);
387         }
388 
389         /**
390          * Returns an ObjectInputFilter from a string of patterns that
391          * checks only the length for arrays, not the component type.
392          *
393          * @param pattern the pattern string to parse; not null
394          * @return a filter to check a class being deserialized;
395          *          {@code null} if no patterns
396          */
397         static ObjectInputFilter createFilter2(String pattern) {
398             Objects.requireNonNull(pattern, &quot;pattern&quot;);
399             return Global.createFilter(pattern, false);
400         }
401 
402         /**
403          * Implementation of ObjectInputFilter that performs the checks of
404          * the system-wide serialization filter. If configured, it will be
405          * used for all ObjectInputStreams that do not set their own filters.
406          *
407          */
408         final static class Global implements ObjectInputFilter {
409             /**
410              * The pattern used to create the filter.
411              */
412             private final String pattern;
413             /**
414              * The list of class filters.
415              */
416             private final List&lt;Function&lt;Class&lt;?&gt;, Status&gt;&gt; filters;
417             /**
418              * Maximum allowed bytes in the stream.
419              */
420             private long maxStreamBytes;
421             /**
422              * Maximum depth of the graph allowed.
423              */
424             private long maxDepth;
425             /**
426              * Maximum number of references in a graph.
427              */
428             private long maxReferences;
429             /**
430              * Maximum length of any array.
431              */
432             private long maxArrayLength;
433             /**
434              * True to check the component type for arrays.
435              */
436             private final boolean checkComponentType;
437 
438             /**
439              * Returns an ObjectInputFilter from a string of patterns.
440              *
441              * @param pattern the pattern string to parse
442              * @param checkComponentType true if the filter should check
443              *                           the component type of arrays
444              * @return a filter to check a class being deserialized;
445              *          {@code null} if no patterns
446              * @throws IllegalArgumentException if the parameter is malformed
447              *                if the pattern is missing the name, the long value
448              *                is not a number or is negative.
449              */
450             static ObjectInputFilter createFilter(String pattern, boolean checkComponentType) {
451                 try {
452                     return new Global(pattern, checkComponentType);
453                 } catch (UnsupportedOperationException uoe) {
454                     // no non-empty patterns
455                     return null;
456                 }
457             }
458 
459             /**
460              * Construct a new filter from the pattern String.
461              *
462              * @param pattern a pattern string of filters
463              * @param checkComponentType true if the filter should check
464              *                           the component type of arrays
465              * @throws IllegalArgumentException if the pattern is malformed
466              * @throws UnsupportedOperationException if there are no non-empty patterns
467              */
468             private Global(String pattern, boolean checkComponentType) {
469                 boolean hasLimits = false;
470                 this.pattern = pattern;
471                 this.checkComponentType = checkComponentType;
472 
473                 maxArrayLength = Long.MAX_VALUE; // Default values are unlimited
474                 maxDepth = Long.MAX_VALUE;
475                 maxReferences = Long.MAX_VALUE;
476                 maxStreamBytes = Long.MAX_VALUE;
477 
478                 String[] patterns = pattern.split(&quot;;&quot;);
479                 filters = new ArrayList&lt;&gt;(patterns.length);
480                 for (int i = 0; i &lt; patterns.length; i++) {
481                     String p = patterns[i];
482                     int nameLen = p.length();
483                     if (nameLen == 0) {
484                         continue;
485                     }
486                     if (parseLimit(p)) {
487                         // If the pattern contained a limit setting, i.e. type=value
488                         hasLimits = true;
489                         continue;
490                     }
491                     boolean negate = p.charAt(0) == &#39;!&#39;;
492                     int poffset = negate ? 1 : 0;
493 
494                     // isolate module name, if any
495                     int slash = p.indexOf(&#39;/&#39;, poffset);
496                     if (slash == poffset) {
497                         throw new IllegalArgumentException(&quot;module name is missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
498                     }
499                     final String moduleName = (slash &gt;= 0) ? p.substring(poffset, slash) : null;
500                     poffset = (slash &gt;= 0) ? slash + 1 : poffset;
501 
502                     final Function&lt;Class&lt;?&gt;, Status&gt; patternFilter;
503                     if (p.endsWith(&quot;*&quot;)) {
504                         // Wildcard cases
505                         if (p.endsWith(&quot;.*&quot;)) {
506                             // Pattern is a package name with a wildcard
507                             final String pkg = p.substring(poffset, nameLen - 2);
508                             if (pkg.isEmpty()) {
509                                 throw new IllegalArgumentException(&quot;package missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
510                             }
511                             if (negate) {
512                                 // A Function that fails if the class starts with the pattern, otherwise don&#39;t care
513                                 patternFilter = c -&gt; matchesPackage(c, pkg) ? Status.REJECTED : Status.UNDECIDED;
514                             } else {
515                                 // A Function that succeeds if the class starts with the pattern, otherwise don&#39;t care
516                                 patternFilter = c -&gt; matchesPackage(c, pkg) ? Status.ALLOWED : Status.UNDECIDED;
517                             }
518                         } else if (p.endsWith(&quot;.**&quot;)) {
519                             // Pattern is a package prefix with a double wildcard
520                             final String pkgs = p.substring(poffset, nameLen - 2);
521                             if (pkgs.length() &lt; 2) {
522                                 throw new IllegalArgumentException(&quot;package missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
523                             }
524                             if (negate) {
525                                 // A Function that fails if the class starts with the pattern, otherwise don&#39;t care
526                                 patternFilter = c -&gt; c.getName().startsWith(pkgs) ? Status.REJECTED : Status.UNDECIDED;
527                             } else {
528                                 // A Function that succeeds if the class starts with the pattern, otherwise don&#39;t care
529                                 patternFilter = c -&gt; c.getName().startsWith(pkgs) ? Status.ALLOWED : Status.UNDECIDED;
530                             }
531                         } else {
532                             // Pattern is a classname (possibly empty) with a trailing wildcard
533                             final String className = p.substring(poffset, nameLen - 1);
534                             if (negate) {
535                                 // A Function that fails if the class starts with the pattern, otherwise don&#39;t care
536                                 patternFilter = c -&gt; c.getName().startsWith(className) ? Status.REJECTED : Status.UNDECIDED;
537                             } else {
538                                 // A Function that succeeds if the class starts with the pattern, otherwise don&#39;t care
539                                 patternFilter = c -&gt; c.getName().startsWith(className) ? Status.ALLOWED : Status.UNDECIDED;
540                             }
541                         }
542                     } else {
543                         final String name = p.substring(poffset);
544                         if (name.isEmpty()) {
545                             throw new IllegalArgumentException(&quot;class or package missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
546                         }
547                         // Pattern is a class name
548                         if (negate) {
549                             // A Function that fails if the class equals the pattern, otherwise don&#39;t care
550                             patternFilter = c -&gt; c.getName().equals(name) ? Status.REJECTED : Status.UNDECIDED;
551                         } else {
552                             // A Function that succeeds if the class equals the pattern, otherwise don&#39;t care
553                             patternFilter = c -&gt; c.getName().equals(name) ? Status.ALLOWED : Status.UNDECIDED;
554                         }
555                     }
556                     // If there is a moduleName, combine the module name check with the package/class check
557                     if (moduleName == null) {
558                         filters.add(patternFilter);
559                     } else {
560                         filters.add(c -&gt; moduleName.equals(c.getModule().getName()) ? patternFilter.apply(c) : Status.UNDECIDED);
561                     }
562                 }
563                 if (filters.isEmpty() &amp;&amp; !hasLimits) {
564                     throw new UnsupportedOperationException(&quot;no non-empty patterns&quot;);
565                 }
566             }
567 
568             /**
569              * Parse out a limit for one of maxarray, maxdepth, maxbytes, maxreferences.
570              *
571              * @param pattern a string with a type name, &#39;=&#39; and a value
572              * @return {@code true} if a limit was parsed, else {@code false}
573              * @throws IllegalArgumentException if the pattern is missing
574              *                the name, the Long value is not a number or is negative.
575              */
576             private boolean parseLimit(String pattern) {
577                 int eqNdx = pattern.indexOf(&#39;=&#39;);
578                 if (eqNdx &lt; 0) {
579                     // not a limit pattern
580                     return false;
581                 }
582                 String valueString = pattern.substring(eqNdx + 1);
583                 if (pattern.startsWith(&quot;maxdepth=&quot;)) {
584                     maxDepth = parseValue(valueString);
585                 } else if (pattern.startsWith(&quot;maxarray=&quot;)) {
586                     maxArrayLength = parseValue(valueString);
587                 } else if (pattern.startsWith(&quot;maxrefs=&quot;)) {
588                     maxReferences = parseValue(valueString);
589                 } else if (pattern.startsWith(&quot;maxbytes=&quot;)) {
590                     maxStreamBytes = parseValue(valueString);
591                 } else {
592                     throw new IllegalArgumentException(&quot;unknown limit: &quot; + pattern.substring(0, eqNdx));
593                 }
594                 return true;
595             }
596 
597             /**
598              * Parse the value of a limit and check that it is non-negative.
599              * @param string inputstring
600              * @return the parsed value
601              * @throws IllegalArgumentException if parsing the value fails or the value is negative
602              */
603             private static long parseValue(String string) throws IllegalArgumentException {
604                 // Parse a Long from after the &#39;=&#39; to the end
605                 long value = Long.parseLong(string);
606                 if (value &lt; 0) {
607                     throw new IllegalArgumentException(&quot;negative limit: &quot; + string);
608                 }
609                 return value;
610             }
611 
612             /**
613              * {@inheritDoc}
614              */
615             @Override
616             public Status checkInput(FilterInfo filterInfo) {
617                 if (filterInfo.references() &lt; 0
618                         || filterInfo.depth() &lt; 0
619                         || filterInfo.streamBytes() &lt; 0
620                         || filterInfo.references() &gt; maxReferences
621                         || filterInfo.depth() &gt; maxDepth
622                         || filterInfo.streamBytes() &gt; maxStreamBytes) {
623                     return Status.REJECTED;
624                 }
625 
626                 Class&lt;?&gt; clazz = filterInfo.serialClass();
627                 if (clazz != null) {
628                     if (clazz.isArray()) {
629                         if (filterInfo.arrayLength() &gt;= 0 &amp;&amp; filterInfo.arrayLength() &gt; maxArrayLength) {
630                             // array length is too big
631                             return Status.REJECTED;
632                         }
633                         if (!checkComponentType) {
634                             // As revised; do not check the component type for arrays
635                             return Status.UNDECIDED;
636                         }
637                         do {
638                             // Arrays are decided based on the component type
639                             clazz = clazz.getComponentType();
640                         } while (clazz.isArray());
641                     }
642 
643                     if (clazz.isPrimitive())  {
644                         // Primitive types are undecided; let someone else decide
645                         return Status.UNDECIDED;
646                     } else {
647                         // Find any filter that allowed or rejected the class
648                         final Class&lt;?&gt; cl = clazz;
649                         Optional&lt;Status&gt; status = filters.stream()
650                                 .map(f -&gt; f.apply(cl))
651                                 .filter(p -&gt; p != Status.UNDECIDED)
652                                 .findFirst();
653                         return status.orElse(Status.UNDECIDED);
654                     }
655                 }
656                 return Status.UNDECIDED;
657             }
658 
659             /**
660              * Returns {@code true} if the class is in the package.
661              *
662              * @param c   a class
663              * @param pkg a package name
664              * @return {@code true} if the class is in the package,
665              * otherwise {@code false}
666              */
667             private static boolean matchesPackage(Class&lt;?&gt; c, String pkg) {
668                 return pkg.equals(c.getPackageName());
669             }
670 
671             /**
672              * Returns the pattern used to create this filter.
673              * @return the pattern used to create this filter
674              */
675             @Override
676             public String toString() {
677                 return pattern;
678             }
679         }
680     }
681 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
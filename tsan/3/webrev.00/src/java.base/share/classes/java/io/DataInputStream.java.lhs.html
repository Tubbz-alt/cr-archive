<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/DataInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data input stream lets an application read primitive Java data
 30  * types from an underlying input stream in a machine-independent
 31  * way. An application uses a data output stream to write data that
 32  * can later be read by a data input stream.
 33  * &lt;p&gt;
 34  * DataInputStream is not necessarily safe for multithreaded access.
 35  * Thread safety is optional and is the responsibility of users of
 36  * methods in this class.
 37  *
 38  * @author  Arthur van Hoff
 39  * @see     java.io.DataOutputStream
 40  * @since   1.0
 41  */
<a name="2" id="anc2"></a><span class="line-modified"> 42 public</span>
<span class="line-removed"> 43 class DataInputStream extends FilterInputStream implements DataInput {</span>
 44 
 45     /**
 46      * Creates a DataInputStream that uses the specified
 47      * underlying InputStream.
 48      *
 49      * @param  in   the specified input stream
 50      */
 51     public DataInputStream(InputStream in) {
 52         super(in);
 53     }
 54 
 55     /**
 56      * working arrays initialized on demand by readUTF
 57      */
 58     private byte bytearr[] = new byte[80];
 59     private char chararr[] = new char[80];
 60 
 61     /**
 62      * Reads some number of bytes from the contained input stream and
<a name="3" id="anc3"></a><span class="line-modified"> 63      * stores them into the buffer array &lt;code&gt;b&lt;/code&gt;. The number of</span>
 64      * bytes actually read is returned as an integer. This method blocks
 65      * until input data is available, end of file is detected, or an
 66      * exception is thrown.
 67      *
<a name="4" id="anc4"></a><span class="line-modified"> 68      * &lt;p&gt;If &lt;code&gt;b&lt;/code&gt; is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is</span>
<span class="line-modified"> 69      * thrown. If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are</span>
<span class="line-modified"> 70      * read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt</span>
 71      * to read at least one byte. If no byte is available because the
<a name="5" id="anc5"></a><span class="line-modified"> 72      * stream is at end of file, the value &lt;code&gt;-1&lt;/code&gt; is returned;</span>
<span class="line-modified"> 73      * otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
 74      *
<a name="6" id="anc6"></a><span class="line-modified"> 75      * &lt;p&gt;The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span>
<span class="line-modified"> 76      * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified"> 77      * is, at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;code&gt;k&lt;/code&gt;</span>
 78      * be the number of bytes actually read; these bytes will be stored in
<a name="7" id="anc7"></a><span class="line-modified"> 79      * elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[k-1]&lt;/code&gt;, leaving</span>
<span class="line-modified"> 80      * elements &lt;code&gt;b[k]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt;</span>
 81      * unaffected.
 82      *
<a name="8" id="anc8"></a><span class="line-modified"> 83      * &lt;p&gt;The &lt;code&gt;read(b)&lt;/code&gt; method has the same effect as:</span>
 84      * &lt;blockquote&gt;&lt;pre&gt;
 85      * read(b, 0, b.length)
 86      * &lt;/pre&gt;&lt;/blockquote&gt;
 87      *
 88      * @param      b   the buffer into which the data is read.
 89      * @return     the total number of bytes read into the buffer, or
<a name="9" id="anc9"></a><span class="line-modified"> 90      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end</span>
 91      *             of the stream has been reached.
<a name="10" id="anc10"></a><span class="line-modified"> 92      * @exception  IOException if the first byte cannot be read for any reason</span>
<span class="line-modified"> 93      * other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified"> 94      * input stream does not support reading after close, or another I/O</span>
<span class="line-modified"> 95      * error occurs.</span>
 96      * @see        java.io.FilterInputStream#in
 97      * @see        java.io.InputStream#read(byte[], int, int)
 98      */
 99     public final int read(byte b[]) throws IOException {
100         return in.read(b, 0, b.length);
101     }
102 
103     /**
<a name="11" id="anc11"></a><span class="line-modified">104      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the contained</span>
105      * input stream into an array of bytes.  An attempt is made to read
<a name="12" id="anc12"></a><span class="line-modified">106      * as many as &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read,</span>
107      * possibly zero. The number of bytes actually read is returned as an
108      * integer.
109      *
110      * &lt;p&gt; This method blocks until input data is available, end of file is
111      * detected, or an exception is thrown.
112      *
<a name="13" id="anc13"></a><span class="line-modified">113      * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">114      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
115      * least one byte. If no byte is available because the stream is at end of
<a name="14" id="anc14"></a><span class="line-modified">116      * file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one</span>
<span class="line-modified">117      * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
118      *
<a name="15" id="anc15"></a><span class="line-modified">119      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the</span>
<span class="line-modified">120      * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified">121      * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
122      * bytes actually read; these bytes will be stored in elements
<a name="16" id="anc16"></a><span class="line-modified">123      * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">124      * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">125      * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.</span>
126      *
<a name="17" id="anc17"></a><span class="line-modified">127      * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through</span>
<span class="line-modified">128      * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through</span>
<span class="line-modified">129      * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</span>
130      *
131      * @param      b     the buffer into which the data is read.
<a name="18" id="anc18"></a><span class="line-modified">132      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
133      * @param      len   the maximum number of bytes read.
134      * @return     the total number of bytes read into the buffer, or
<a name="19" id="anc19"></a><span class="line-modified">135      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end</span>
136      *             of the stream has been reached.
<a name="20" id="anc20"></a><span class="line-modified">137      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">138      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">139      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">140      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">141      * @exception  IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">142      * other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">143      * input stream does not support reading after close, or another I/O</span>
<span class="line-modified">144      * error occurs.</span>
145      * @see        java.io.FilterInputStream#in
146      * @see        java.io.InputStream#read(byte[], int, int)
147      */
148     public final int read(byte b[], int off, int len) throws IOException {
149         return in.read(b, off, len);
150     }
151 
152     /**
153      * See the general contract of the {@code readFully}
154      * method of {@code DataInput}.
155      * &lt;p&gt;
156      * Bytes
157      * for this operation are read from the contained
158      * input stream.
159      *
160      * @param   b   the buffer into which the data is read.
161      * @throws  NullPointerException if {@code b} is {@code null}.
162      * @throws  EOFException  if this input stream reaches the end before
163      *          reading all the bytes.
164      * @throws  IOException   the stream has been closed and the contained
165      *          input stream does not support reading after close, or
166      *          another I/O error occurs.
167      * @see     java.io.FilterInputStream#in
168      */
169     public final void readFully(byte b[]) throws IOException {
170         readFully(b, 0, b.length);
171     }
172 
173     /**
174      * See the general contract of the {@code readFully}
175      * method of {@code DataInput}.
176      * &lt;p&gt;
177      * Bytes
178      * for this operation are read from the contained
179      * input stream.
180      *
181      * @param      b     the buffer into which the data is read.
182      * @param      off   the start offset in the data array {@code b}.
183      * @param      len   the number of bytes to read.
<a name="21" id="anc21"></a><span class="line-modified">184      * @exception  NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">185      * @exception  IndexOutOfBoundsException if {@code off} is negative,</span>
186      *             {@code len} is negative, or {@code len} is greater than
187      *             {@code b.length - off}.
<a name="22" id="anc22"></a><span class="line-modified">188      * @exception  EOFException  if this input stream reaches the end before</span>
189      *             reading all the bytes.
<a name="23" id="anc23"></a><span class="line-modified">190      * @exception  IOException   the stream has been closed and the contained</span>
191      *             input stream does not support reading after close, or
192      *             another I/O error occurs.
193      * @see        java.io.FilterInputStream#in
194      */
195     public final void readFully(byte b[], int off, int len) throws IOException {
196         if (len &lt; 0)
197             throw new IndexOutOfBoundsException();
198         int n = 0;
199         while (n &lt; len) {
200             int count = in.read(b, off + n, len - n);
201             if (count &lt; 0)
202                 throw new EOFException();
203             n += count;
204         }
205     }
206 
207     /**
<a name="24" id="anc24"></a><span class="line-modified">208      * See the general contract of the &lt;code&gt;skipBytes&lt;/code&gt;</span>
<span class="line-modified">209      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
210      * &lt;p&gt;
211      * Bytes for this operation are read from the contained
212      * input stream.
213      *
214      * @param      n   the number of bytes to be skipped.
215      * @return     the actual number of bytes skipped.
<a name="25" id="anc25"></a><span class="line-modified">216      * @exception  IOException  if the contained input stream does not support</span>
217      *             seek, or the stream has been closed and
218      *             the contained input stream does not support
219      *             reading after close, or another I/O error occurs.
220      */
221     public final int skipBytes(int n) throws IOException {
222         int total = 0;
223         int cur = 0;
224 
225         while ((total&lt;n) &amp;&amp; ((cur = (int) in.skip(n-total)) &gt; 0)) {
226             total += cur;
227         }
228 
229         return total;
230     }
231 
232     /**
<a name="26" id="anc26"></a><span class="line-modified">233      * See the general contract of the &lt;code&gt;readBoolean&lt;/code&gt;</span>
<span class="line-modified">234      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
235      * &lt;p&gt;
236      * Bytes for this operation are read from the contained
237      * input stream.
238      *
<a name="27" id="anc27"></a><span class="line-modified">239      * @return     the &lt;code&gt;boolean&lt;/code&gt; value read.</span>
<span class="line-modified">240      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">241      * @exception  IOException   the stream has been closed and the contained</span>
242      *             input stream does not support reading after close, or
243      *             another I/O error occurs.
244      * @see        java.io.FilterInputStream#in
245      */
246     public final boolean readBoolean() throws IOException {
247         int ch = in.read();
248         if (ch &lt; 0)
249             throw new EOFException();
250         return (ch != 0);
251     }
252 
253     /**
<a name="28" id="anc28"></a><span class="line-modified">254      * See the general contract of the &lt;code&gt;readByte&lt;/code&gt;</span>
<span class="line-modified">255      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
256      * &lt;p&gt;
257      * Bytes
258      * for this operation are read from the contained
259      * input stream.
260      *
261      * @return     the next byte of this input stream as a signed 8-bit
<a name="29" id="anc29"></a><span class="line-modified">262      *             &lt;code&gt;byte&lt;/code&gt;.</span>
<span class="line-modified">263      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">264      * @exception  IOException   the stream has been closed and the contained</span>
265      *             input stream does not support reading after close, or
266      *             another I/O error occurs.
267      * @see        java.io.FilterInputStream#in
268      */
269     public final byte readByte() throws IOException {
270         int ch = in.read();
271         if (ch &lt; 0)
272             throw new EOFException();
273         return (byte)(ch);
274     }
275 
276     /**
<a name="30" id="anc30"></a><span class="line-modified">277      * See the general contract of the &lt;code&gt;readUnsignedByte&lt;/code&gt;</span>
<span class="line-modified">278      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
279      * &lt;p&gt;
280      * Bytes
281      * for this operation are read from the contained
282      * input stream.
283      *
284      * @return     the next byte of this input stream, interpreted as an
285      *             unsigned 8-bit number.
<a name="31" id="anc31"></a><span class="line-modified">286      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">287      * @exception  IOException   the stream has been closed and the contained</span>
288      *             input stream does not support reading after close, or
289      *             another I/O error occurs.
290      * @see         java.io.FilterInputStream#in
291      */
292     public final int readUnsignedByte() throws IOException {
293         int ch = in.read();
294         if (ch &lt; 0)
295             throw new EOFException();
296         return ch;
297     }
298 
299     /**
<a name="32" id="anc32"></a><span class="line-modified">300      * See the general contract of the &lt;code&gt;readShort&lt;/code&gt;</span>
<span class="line-modified">301      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
302      * &lt;p&gt;
303      * Bytes
304      * for this operation are read from the contained
305      * input stream.
306      *
307      * @return     the next two bytes of this input stream, interpreted as a
308      *             signed 16-bit number.
<a name="33" id="anc33"></a><span class="line-modified">309      * @exception  EOFException  if this input stream reaches the end before</span>
310      *               reading two bytes.
<a name="34" id="anc34"></a><span class="line-modified">311      * @exception  IOException   the stream has been closed and the contained</span>
312      *             input stream does not support reading after close, or
313      *             another I/O error occurs.
314      * @see        java.io.FilterInputStream#in
315      */
316     public final short readShort() throws IOException {
317         int ch1 = in.read();
318         int ch2 = in.read();
319         if ((ch1 | ch2) &lt; 0)
320             throw new EOFException();
321         return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
322     }
323 
324     /**
<a name="35" id="anc35"></a><span class="line-modified">325      * See the general contract of the &lt;code&gt;readUnsignedShort&lt;/code&gt;</span>
<span class="line-modified">326      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
327      * &lt;p&gt;
328      * Bytes
329      * for this operation are read from the contained
330      * input stream.
331      *
332      * @return     the next two bytes of this input stream, interpreted as an
333      *             unsigned 16-bit integer.
<a name="36" id="anc36"></a><span class="line-modified">334      * @exception  EOFException  if this input stream reaches the end before</span>
335      *             reading two bytes.
<a name="37" id="anc37"></a><span class="line-modified">336      * @exception  IOException   the stream has been closed and the contained</span>
337      *             input stream does not support reading after close, or
338      *             another I/O error occurs.
339      * @see        java.io.FilterInputStream#in
340      */
341     public final int readUnsignedShort() throws IOException {
342         int ch1 = in.read();
343         int ch2 = in.read();
344         if ((ch1 | ch2) &lt; 0)
345             throw new EOFException();
346         return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
347     }
348 
349     /**
<a name="38" id="anc38"></a><span class="line-modified">350      * See the general contract of the &lt;code&gt;readChar&lt;/code&gt;</span>
<span class="line-modified">351      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
352      * &lt;p&gt;
353      * Bytes
354      * for this operation are read from the contained
355      * input stream.
356      *
357      * @return     the next two bytes of this input stream, interpreted as a
<a name="39" id="anc39"></a><span class="line-modified">358      *             &lt;code&gt;char&lt;/code&gt;.</span>
<span class="line-modified">359      * @exception  EOFException  if this input stream reaches the end before</span>
360      *               reading two bytes.
<a name="40" id="anc40"></a><span class="line-modified">361      * @exception  IOException   the stream has been closed and the contained</span>
362      *             input stream does not support reading after close, or
363      *             another I/O error occurs.
364      * @see        java.io.FilterInputStream#in
365      */
366     public final char readChar() throws IOException {
367         int ch1 = in.read();
368         int ch2 = in.read();
369         if ((ch1 | ch2) &lt; 0)
370             throw new EOFException();
371         return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
372     }
373 
374     /**
<a name="41" id="anc41"></a><span class="line-modified">375      * See the general contract of the &lt;code&gt;readInt&lt;/code&gt;</span>
<span class="line-modified">376      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
377      * &lt;p&gt;
378      * Bytes
379      * for this operation are read from the contained
380      * input stream.
381      *
382      * @return     the next four bytes of this input stream, interpreted as an
<a name="42" id="anc42"></a><span class="line-modified">383      *             &lt;code&gt;int&lt;/code&gt;.</span>
<span class="line-modified">384      * @exception  EOFException  if this input stream reaches the end before</span>
385      *               reading four bytes.
<a name="43" id="anc43"></a><span class="line-modified">386      * @exception  IOException   the stream has been closed and the contained</span>
387      *             input stream does not support reading after close, or
388      *             another I/O error occurs.
389      * @see        java.io.FilterInputStream#in
390      */
391     public final int readInt() throws IOException {
392         int ch1 = in.read();
393         int ch2 = in.read();
394         int ch3 = in.read();
395         int ch4 = in.read();
396         if ((ch1 | ch2 | ch3 | ch4) &lt; 0)
397             throw new EOFException();
398         return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));
399     }
400 
401     private byte readBuffer[] = new byte[8];
402 
403     /**
<a name="44" id="anc44"></a><span class="line-modified">404      * See the general contract of the &lt;code&gt;readLong&lt;/code&gt;</span>
<span class="line-modified">405      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
406      * &lt;p&gt;
407      * Bytes
408      * for this operation are read from the contained
409      * input stream.
410      *
411      * @return     the next eight bytes of this input stream, interpreted as a
<a name="45" id="anc45"></a><span class="line-modified">412      *             &lt;code&gt;long&lt;/code&gt;.</span>
<span class="line-modified">413      * @exception  EOFException  if this input stream reaches the end before</span>
414      *               reading eight bytes.
<a name="46" id="anc46"></a><span class="line-modified">415      * @exception  IOException   the stream has been closed and the contained</span>
416      *             input stream does not support reading after close, or
417      *             another I/O error occurs.
418      * @see        java.io.FilterInputStream#in
419      */
420     public final long readLong() throws IOException {
421         readFully(readBuffer, 0, 8);
422         return (((long)readBuffer[0] &lt;&lt; 56) +
423                 ((long)(readBuffer[1] &amp; 255) &lt;&lt; 48) +
424                 ((long)(readBuffer[2] &amp; 255) &lt;&lt; 40) +
425                 ((long)(readBuffer[3] &amp; 255) &lt;&lt; 32) +
426                 ((long)(readBuffer[4] &amp; 255) &lt;&lt; 24) +
427                 ((readBuffer[5] &amp; 255) &lt;&lt; 16) +
428                 ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
429                 ((readBuffer[7] &amp; 255) &lt;&lt;  0));
430     }
431 
432     /**
<a name="47" id="anc47"></a><span class="line-modified">433      * See the general contract of the &lt;code&gt;readFloat&lt;/code&gt;</span>
<span class="line-modified">434      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
435      * &lt;p&gt;
436      * Bytes
437      * for this operation are read from the contained
438      * input stream.
439      *
440      * @return     the next four bytes of this input stream, interpreted as a
<a name="48" id="anc48"></a><span class="line-modified">441      *             &lt;code&gt;float&lt;/code&gt;.</span>
<span class="line-modified">442      * @exception  EOFException  if this input stream reaches the end before</span>
443      *               reading four bytes.
<a name="49" id="anc49"></a><span class="line-modified">444      * @exception  IOException   the stream has been closed and the contained</span>
445      *             input stream does not support reading after close, or
446      *             another I/O error occurs.
447      * @see        java.io.DataInputStream#readInt()
448      * @see        java.lang.Float#intBitsToFloat(int)
449      */
450     public final float readFloat() throws IOException {
451         return Float.intBitsToFloat(readInt());
452     }
453 
454     /**
<a name="50" id="anc50"></a><span class="line-modified">455      * See the general contract of the &lt;code&gt;readDouble&lt;/code&gt;</span>
<span class="line-modified">456      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
457      * &lt;p&gt;
458      * Bytes
459      * for this operation are read from the contained
460      * input stream.
461      *
462      * @return     the next eight bytes of this input stream, interpreted as a
<a name="51" id="anc51"></a><span class="line-modified">463      *             &lt;code&gt;double&lt;/code&gt;.</span>
<span class="line-modified">464      * @exception  EOFException  if this input stream reaches the end before</span>
465      *               reading eight bytes.
<a name="52" id="anc52"></a><span class="line-modified">466      * @exception  IOException   the stream has been closed and the contained</span>
467      *             input stream does not support reading after close, or
468      *             another I/O error occurs.
469      * @see        java.io.DataInputStream#readLong()
470      * @see        java.lang.Double#longBitsToDouble(long)
471      */
472     public final double readDouble() throws IOException {
473         return Double.longBitsToDouble(readLong());
474     }
475 
476     private char lineBuffer[];
477 
478     /**
<a name="53" id="anc53"></a><span class="line-modified">479      * See the general contract of the &lt;code&gt;readLine&lt;/code&gt;</span>
<span class="line-modified">480      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
481      * &lt;p&gt;
482      * Bytes
483      * for this operation are read from the contained
484      * input stream.
485      *
486      * @deprecated This method does not properly convert bytes to characters.
487      * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
<a name="54" id="anc54"></a><span class="line-modified">488      * &lt;code&gt;BufferedReader.readLine()&lt;/code&gt; method.  Programs that use the</span>
<span class="line-modified">489      * &lt;code&gt;DataInputStream&lt;/code&gt; class to read lines can be converted to use</span>
<span class="line-modified">490      * the &lt;code&gt;BufferedReader&lt;/code&gt; class by replacing code of the form:</span>
491      * &lt;blockquote&gt;&lt;pre&gt;
492      *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
493      * &lt;/pre&gt;&lt;/blockquote&gt;
494      * with:
495      * &lt;blockquote&gt;&lt;pre&gt;
496      *     BufferedReader d
497      *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
498      * &lt;/pre&gt;&lt;/blockquote&gt;
499      *
500      * @return     the next line of text from this input stream.
<a name="55" id="anc55"></a><span class="line-modified">501      * @exception  IOException  if an I/O error occurs.</span>
502      * @see        java.io.BufferedReader#readLine()
503      * @see        java.io.FilterInputStream#in
504      */
505     @Deprecated
506     public final String readLine() throws IOException {
507         char buf[] = lineBuffer;
508 
509         if (buf == null) {
510             buf = lineBuffer = new char[128];
511         }
512 
513         int room = buf.length;
514         int offset = 0;
515         int c;
516 
517 loop:   while (true) {
518             switch (c = in.read()) {
519               case -1:
520               case &#39;\n&#39;:
521                 break loop;
522 
523               case &#39;\r&#39;:
524                 int c2 = in.read();
525                 if ((c2 != &#39;\n&#39;) &amp;&amp; (c2 != -1)) {
526                     if (!(in instanceof PushbackInputStream)) {
527                         this.in = new PushbackInputStream(in);
528                     }
529                     ((PushbackInputStream)in).unread(c2);
530                 }
531                 break loop;
532 
533               default:
534                 if (--room &lt; 0) {
535                     buf = new char[offset + 128];
536                     room = buf.length - offset - 1;
537                     System.arraycopy(lineBuffer, 0, buf, 0, offset);
538                     lineBuffer = buf;
539                 }
540                 buf[offset++] = (char) c;
541                 break;
542             }
543         }
544         if ((c == -1) &amp;&amp; (offset == 0)) {
545             return null;
546         }
547         return String.copyValueOf(buf, 0, offset);
548     }
549 
550     /**
<a name="56" id="anc56"></a><span class="line-modified">551      * See the general contract of the &lt;code&gt;readUTF&lt;/code&gt;</span>
<span class="line-modified">552      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
553      * &lt;p&gt;
554      * Bytes
555      * for this operation are read from the contained
556      * input stream.
557      *
558      * @return     a Unicode string.
<a name="57" id="anc57"></a><span class="line-modified">559      * @exception  EOFException  if this input stream reaches the end before</span>
560      *               reading all the bytes.
<a name="58" id="anc58"></a><span class="line-modified">561      * @exception  IOException   the stream has been closed and the contained</span>
562      *             input stream does not support reading after close, or
563      *             another I/O error occurs.
<a name="59" id="anc59"></a><span class="line-modified">564      * @exception  UTFDataFormatException if the bytes do not represent a valid</span>
565      *             modified UTF-8 encoding of a string.
566      * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
567      */
568     public final String readUTF() throws IOException {
569         return readUTF(this);
570     }
571 
572     /**
573      * Reads from the
<a name="60" id="anc60"></a><span class="line-modified">574      * stream &lt;code&gt;in&lt;/code&gt; a representation</span>
575      * of a Unicode  character string encoded in
576      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
<a name="61" id="anc61"></a><span class="line-modified">577      * this string of characters is then returned as a &lt;code&gt;String&lt;/code&gt;.</span>
578      * The details of the modified UTF-8 representation
<a name="62" id="anc62"></a><span class="line-modified">579      * are  exactly the same as for the &lt;code&gt;readUTF&lt;/code&gt;</span>
<span class="line-modified">580      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
581      *
582      * @param      in   a data input stream.
583      * @return     a Unicode string.
<a name="63" id="anc63"></a><span class="line-modified">584      * @exception  EOFException            if the input stream reaches the end</span>
585      *               before all the bytes.
<a name="64" id="anc64"></a><span class="line-modified">586      * @exception  IOException   the stream has been closed and the contained</span>
587      *             input stream does not support reading after close, or
588      *             another I/O error occurs.
<a name="65" id="anc65"></a><span class="line-modified">589      * @exception  UTFDataFormatException  if the bytes do not represent a</span>
590      *               valid modified UTF-8 encoding of a Unicode string.
591      * @see        java.io.DataInputStream#readUnsignedShort()
592      */
593     public static final String readUTF(DataInput in) throws IOException {
594         int utflen = in.readUnsignedShort();
595         byte[] bytearr = null;
596         char[] chararr = null;
597         if (in instanceof DataInputStream) {
598             DataInputStream dis = (DataInputStream)in;
599             if (dis.bytearr.length &lt; utflen){
600                 dis.bytearr = new byte[utflen*2];
601                 dis.chararr = new char[utflen*2];
602             }
603             chararr = dis.chararr;
604             bytearr = dis.bytearr;
605         } else {
606             bytearr = new byte[utflen];
607             chararr = new char[utflen];
608         }
609 
610         int c, char2, char3;
611         int count = 0;
612         int chararr_count=0;
613 
614         in.readFully(bytearr, 0, utflen);
615 
616         while (count &lt; utflen) {
617             c = (int) bytearr[count] &amp; 0xff;
618             if (c &gt; 127) break;
619             count++;
620             chararr[chararr_count++]=(char)c;
621         }
622 
623         while (count &lt; utflen) {
624             c = (int) bytearr[count] &amp; 0xff;
625             switch (c &gt;&gt; 4) {
626                 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
627                     /* 0xxxxxxx*/
628                     count++;
629                     chararr[chararr_count++]=(char)c;
630                     break;
631                 case 12: case 13:
632                     /* 110x xxxx   10xx xxxx*/
633                     count += 2;
634                     if (count &gt; utflen)
635                         throw new UTFDataFormatException(
636                             &quot;malformed input: partial character at end&quot;);
637                     char2 = (int) bytearr[count-1];
638                     if ((char2 &amp; 0xC0) != 0x80)
639                         throw new UTFDataFormatException(
640                             &quot;malformed input around byte &quot; + count);
641                     chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) |
642                                                     (char2 &amp; 0x3F));
643                     break;
644                 case 14:
645                     /* 1110 xxxx  10xx xxxx  10xx xxxx */
646                     count += 3;
647                     if (count &gt; utflen)
648                         throw new UTFDataFormatException(
649                             &quot;malformed input: partial character at end&quot;);
650                     char2 = (int) bytearr[count-2];
651                     char3 = (int) bytearr[count-1];
652                     if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80))
653                         throw new UTFDataFormatException(
654                             &quot;malformed input around byte &quot; + (count-1));
655                     chararr[chararr_count++]=(char)(((c     &amp; 0x0F) &lt;&lt; 12) |
656                                                     ((char2 &amp; 0x3F) &lt;&lt; 6)  |
657                                                     ((char3 &amp; 0x3F) &lt;&lt; 0));
658                     break;
659                 default:
660                     /* 10xx xxxx,  1111 xxxx */
661                     throw new UTFDataFormatException(
662                         &quot;malformed input around byte &quot; + count);
663             }
664         }
665         // The number of chars produced may be less than utflen
666         return new String(chararr, 0, chararr_count);
667     }
668 }
<a name="66" id="anc66"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="66" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/URI.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InvalidObjectException;
  31 import java.io.ObjectInputStream;
  32 import java.io.ObjectOutputStream;
  33 import java.io.Serializable;
  34 import java.nio.ByteBuffer;
  35 import java.nio.CharBuffer;
  36 import java.nio.charset.CharsetDecoder;
  37 import java.nio.charset.CoderResult;
  38 import java.nio.charset.CodingErrorAction;
  39 import java.nio.charset.CharacterCodingException;
  40 import java.nio.file.Path;
  41 import java.text.Normalizer;
  42 import jdk.internal.access.JavaNetUriAccess;
  43 import jdk.internal.access.SharedSecrets;
  44 import sun.nio.cs.ThreadLocalCoders;
<a name="2" id="anc2"></a><span class="line-added">  45 import sun.nio.cs.UTF_8;</span>
  46 
  47 import java.lang.Character;             // for javadoc
  48 import java.lang.NullPointerException;  // for javadoc
  49 
<a name="3" id="anc3"></a>
  50 /**
  51  * Represents a Uniform Resource Identifier (URI) reference.
  52  *
  53  * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
  54  * class represents a URI reference as defined by
  55  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
  56  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
  57  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
  58  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
  59  * also supports scope_ids. The syntax and usage of scope_ids is described
  60  * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
  61  * This class provides constructors for creating URI instances from
  62  * their components or by parsing their string forms, methods for accessing the
  63  * various components of an instance, and methods for normalizing, resolving,
  64  * and relativizing URI instances.  Instances of this class are immutable.
  65  *
  66  *
<a name="4" id="anc4"></a><span class="line-modified">  67  * &lt;h2&gt; URI syntax and components &lt;/h2&gt;</span>
  68  *
  69  * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
  70  * form has the syntax
  71  *
  72  * &lt;blockquote&gt;
  73  * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
  74  * &lt;/blockquote&gt;
  75  *
  76  * where square brackets [...] delineate optional components and the characters
  77  * &lt;b&gt;{@code :}&lt;/b&gt; and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.
  78  *
  79  * &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
  80  * said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
  81  * they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
  82  *
  83  * &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
  84  * not begin with a slash character ({@code &#39;/&#39;}).  Opaque URIs are not
  85  * subject to further parsing.  Some examples of opaque URIs are:
  86  *
  87  * &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
  88  * &lt;li&gt;{@code mailto:java-net@www.example.com}&lt;/li&gt;
  89  * &lt;li&gt;{@code news:comp.lang.java}&lt;/li&gt;
  90  * &lt;li&gt;{@code urn:isbn:096139210x}&lt;/li&gt;
  91  * &lt;/ul&gt;&lt;/blockquote&gt;
  92  *
  93  * &lt;p&gt; A &lt;i&gt;hierarchical&lt;/i&gt; URI is either an absolute URI whose
  94  * scheme-specific part begins with a slash character, or a relative URI, that
  95  * is, a URI that does not specify a scheme.  Some examples of hierarchical
  96  * URIs are:
  97  *
  98  * &lt;blockquote&gt;
  99  * {@code http://example.com/languages/java/}&lt;br&gt;
 100  * {@code sample/a/index.html#28}&lt;br&gt;
 101  * {@code ../../demo/b/index.html}&lt;br&gt;
 102  * {@code file:///~/calendar}
 103  * &lt;/blockquote&gt;
 104  *
 105  * &lt;p&gt; A hierarchical URI is subject to further parsing according to the syntax
 106  *
 107  * &lt;blockquote&gt;
 108  * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;][&lt;b&gt;{@code //}&lt;/b&gt;&lt;i&gt;authority&lt;/i&gt;][&lt;i&gt;path&lt;/i&gt;][&lt;b&gt;{@code ?}&lt;/b&gt;&lt;i&gt;query&lt;/i&gt;][&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
 109  * &lt;/blockquote&gt;
 110  *
 111  * where the characters &lt;b&gt;{@code :}&lt;/b&gt;, &lt;b&gt;{@code /}&lt;/b&gt;,
 112  * &lt;b&gt;{@code ?}&lt;/b&gt;, and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.  The
 113  * scheme-specific part of a hierarchical URI consists of the characters
 114  * between the scheme and fragment components.
 115  *
 116  * &lt;p&gt; The authority component of a hierarchical URI is, if specified, either
 117  * &lt;i&gt;server-based&lt;/i&gt; or &lt;i&gt;registry-based&lt;/i&gt;.  A server-based authority
 118  * parses according to the familiar syntax
 119  *
 120  * &lt;blockquote&gt;
 121  * [&lt;i&gt;user-info&lt;/i&gt;&lt;b&gt;{@code @}&lt;/b&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;b&gt;{@code :}&lt;/b&gt;&lt;i&gt;port&lt;/i&gt;]
 122  * &lt;/blockquote&gt;
 123  *
 124  * where the characters &lt;b&gt;{@code @}&lt;/b&gt; and &lt;b&gt;{@code :}&lt;/b&gt; stand for
 125  * themselves.  Nearly all URI schemes currently in use are server-based.  An
 126  * authority component that does not parse in this way is considered to be
 127  * registry-based.
 128  *
 129  * &lt;p&gt; The path component of a hierarchical URI is itself said to be absolute
 130  * if it begins with a slash character ({@code &#39;/&#39;}); otherwise it is
 131  * relative.  The path of a hierarchical URI that is either absolute or
 132  * specifies an authority is always absolute.
 133  *
 134  * &lt;p&gt; All told, then, a URI instance has the following nine components:
 135  *
 136  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 137  * &lt;caption style=&quot;display:none&quot;&gt;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&lt;/caption&gt;
 138  * &lt;thead&gt;
 139  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Component&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;&lt;/tr&gt;
 140  * &lt;/thead&gt;
 141  * &lt;tbody style=&quot;text-align:left&quot;&gt;
 142  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;scheme&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 143  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;scheme-specific-part&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 144  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;authority&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 145  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;user-info&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 146  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;host&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 147  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;port&lt;/th&gt;&lt;td&gt;{@code int}&lt;/td&gt;&lt;/tr&gt;
 148  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;path&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 149  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;query&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 150  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;fragment&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
 151  * &lt;/tbody&gt;
 152  * &lt;/table&gt;
 153  *
 154  * In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
 155  * &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
 156  * represented by {@code null}, while undefined integer components are
 157  * represented by {@code -1}.  A string component may be defined to have the
 158  * empty string as its value; this is not equivalent to that component being
 159  * undefined.
 160  *
 161  * &lt;p&gt; Whether a particular component is or is not defined in an instance
 162  * depends upon the type of the URI being represented.  An absolute URI has a
 163  * scheme component.  An opaque URI has a scheme, a scheme-specific part, and
 164  * possibly a fragment, but has no other components.  A hierarchical URI always
 165  * has a path (though it may be empty) and a scheme-specific-part (which at
 166  * least contains the path), and may have any of the other components.  If the
 167  * authority component is present and is server-based then the host component
 168  * will be defined and the user-information and port components may be defined.
 169  *
 170  *
<a name="5" id="anc5"></a><span class="line-modified"> 171  * &lt;h3&gt; Operations on URI instances &lt;/h3&gt;</span>
 172  *
 173  * The key operations supported by this class are those of
 174  * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
 175  *
 176  * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
 177  * and {@code &quot;..&quot;} segments from the path component of a hierarchical URI.
 178  * Each {@code &quot;.&quot;} segment is simply removed.  A {@code &quot;..&quot;} segment is
 179  * removed only if it is preceded by a non-{@code &quot;..&quot;} segment.
 180  * Normalization has no effect upon opaque URIs.
 181  *
 182  * &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
 183  * &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
 184  * URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
 185  * base URI for those not specified in the original.  For hierarchical URIs,
 186  * the path of the original is resolved against the path of the base and then
 187  * normalized.  The result, for example, of resolving
 188  *
 189  * &lt;blockquote&gt;
 190  * {@code sample/a/index.html#28}
 191  * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
 192  * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)
 193  * &lt;/blockquote&gt;
 194  *
 195  * against the base URI {@code http://example.com/languages/java/} is the result
 196  * URI
 197  *
 198  * &lt;blockquote&gt;
 199  * {@code http://example.com/languages/java/sample/a/index.html#28}
 200  * &lt;/blockquote&gt;
 201  *
 202  * Resolving the relative URI
 203  *
 204  * &lt;blockquote&gt;
 205  * {@code ../../demo/b/index.html}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)
 206  * &lt;/blockquote&gt;
 207  *
 208  * against this result yields, in turn,
 209  *
 210  * &lt;blockquote&gt;
 211  * {@code http://example.com/languages/java/demo/b/index.html}
 212  * &lt;/blockquote&gt;
 213  *
 214  * Resolution of both absolute and relative URIs, and of both absolute and
 215  * relative paths in the case of hierarchical URIs, is supported.  Resolving
 216  * the URI {@code file:///~calendar} against any other URI simply yields the
 217  * original URI, since it is absolute.  Resolving the relative URI (2) above
 218  * against the relative base URI (1) yields the normalized, but still relative,
 219  * URI
 220  *
 221  * &lt;blockquote&gt;
 222  * {@code demo/b/index.html}
 223  * &lt;/blockquote&gt;
 224  *
 225  * &lt;p&gt; &lt;i&gt;Relativization&lt;/i&gt;, finally, is the inverse of resolution: For any
 226  * two normalized URIs &lt;i&gt;u&lt;/i&gt; and&amp;nbsp;&lt;i&gt;v&lt;/i&gt;,
 227  *
 228  * &lt;blockquote&gt;
 229  *   &lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;and&lt;br&gt;
 230  *   &lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;.&lt;br&gt;
 231  * &lt;/blockquote&gt;
 232  *
 233  * This operation is often useful when constructing a document containing URIs
 234  * that must be made relative to the base URI of the document wherever
 235  * possible.  For example, relativizing the URI
 236  *
 237  * &lt;blockquote&gt;
 238  * {@code http://example.com/languages/java/sample/a/index.html#28}
 239  * &lt;/blockquote&gt;
 240  *
 241  * against the base URI
 242  *
 243  * &lt;blockquote&gt;
 244  * {@code http://example.com/languages/java/}
 245  * &lt;/blockquote&gt;
 246  *
 247  * yields the relative URI {@code sample/a/index.html#28}.
 248  *
 249  *
<a name="6" id="anc6"></a><span class="line-modified"> 250  * &lt;h3&gt; Character categories &lt;/h3&gt;</span>
 251  *
 252  * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
 253  * various components of a URI reference.  The following categories, most of
 254  * which are taken from that specification, are used below to describe these
 255  * constraints:
 256  *
 257  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 258  * &lt;caption style=&quot;display:none&quot;&gt;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&lt;/caption&gt;
 259  *   &lt;thead&gt;
 260  *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Category&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 261  *   &lt;/thead&gt;
 262  *   &lt;tbody style=&quot;text-align:left&quot;&gt;
 263  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alpha&lt;/th&gt;
 264  *       &lt;td&gt;The US-ASCII alphabetic characters,
 265  *        {@code &#39;A&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;Z&#39;}
 266  *        and {@code &#39;a&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;z&#39;}&lt;/td&gt;&lt;/tr&gt;
 267  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;digit&lt;/th&gt;
 268  *       &lt;td&gt;The US-ASCII decimal digit characters,
 269  *       {@code &#39;0&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;9&#39;}&lt;/td&gt;&lt;/tr&gt;
 270  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alphanum&lt;/th&gt;
 271  *       &lt;td&gt;All &lt;i&gt;alpha&lt;/i&gt; and &lt;i&gt;digit&lt;/i&gt; characters&lt;/td&gt;&lt;/tr&gt;
 272  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;unreserved&lt;/th&gt;
 273  *       &lt;td&gt;All &lt;i&gt;alphanum&lt;/i&gt; characters together with those in the string
 274  *        {@code &quot;_-!.~&#39;()*&quot;}&lt;/td&gt;&lt;/tr&gt;
 275  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;punct&lt;/th&gt;
 276  *       &lt;td&gt;The characters in the string {@code &quot;,;:$&amp;+=&quot;}&lt;/td&gt;&lt;/tr&gt;
 277  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;reserved&lt;/th&gt;
 278  *       &lt;td&gt;All &lt;i&gt;punct&lt;/i&gt; characters together with those in the string
 279  *        {@code &quot;?/[]@&quot;}&lt;/td&gt;&lt;/tr&gt;
 280  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;escaped&lt;/th&gt;
 281  *       &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
 282  *           character ({@code &#39;%&#39;}) followed by two hexadecimal digits
 283  *           ({@code &#39;0&#39;}-{@code &#39;9&#39;}, {@code &#39;A&#39;}-{@code &#39;F&#39;}, and
 284  *           {@code &#39;a&#39;}-{@code &#39;f&#39;})&lt;/td&gt;&lt;/tr&gt;
 285  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;other&lt;/th&gt;
 286  *       &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
 287  *           are not control characters (according to the {@link
 288  *           java.lang.Character#isISOControl(char) Character.isISOControl}
 289  *           method), and are not space characters (according to the {@link
 290  *           java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
 291  *           method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
 292  *           limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 293  * &lt;/tbody&gt;
 294  * &lt;/table&gt;
 295  *
 296  * &lt;p&gt;&lt;a id=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
 297  * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
 298  * characters.
 299  *
 300  *
<a name="7" id="anc7"></a><span class="line-modified"> 301  * &lt;h3&gt; Escaped octets, quotation, encoding, and decoding &lt;/h3&gt;</span>
 302  *
 303  * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
 304  * fragment components.  Escaping serves two purposes in URIs:
 305  *
 306  * &lt;ul&gt;
 307  *
 308  *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
 309  *   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
 310  *   characters.  &lt;/p&gt;&lt;/li&gt;
 311  *
 312  *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
 313  *   component.  The user-info, path, query, and fragment components differ
 314  *   slightly in terms of which characters are considered legal and illegal.
 315  *   &lt;/p&gt;&lt;/li&gt;
 316  *
 317  * &lt;/ul&gt;
 318  *
 319  * These purposes are served in this class by three related operations:
 320  *
 321  * &lt;ul&gt;
 322  *
 323  *   &lt;li&gt;&lt;p&gt;&lt;a id=&quot;encode&quot;&gt;&lt;/a&gt; A character is &lt;i&gt;encoded&lt;/i&gt; by replacing it
 324  *   with the sequence of escaped octets that represent that character in the
 325  *   UTF-8 character set.  The Euro currency symbol ({@code &#39;\u005Cu20AC&#39;}),
 326  *   for example, is encoded as {@code &quot;%E2%82%AC&quot;}.  &lt;i&gt;(&lt;b&gt;Deviation from
 327  *   RFC&amp;nbsp;2396&lt;/b&gt;, which does not specify any particular character
 328  *   set.)&lt;/i&gt; &lt;/p&gt;&lt;/li&gt;
 329  *
 330  *   &lt;li&gt;&lt;p&gt;&lt;a id=&quot;quote&quot;&gt;&lt;/a&gt; An illegal character is &lt;i&gt;quoted&lt;/i&gt; simply by
 331  *   encoding it.  The space character, for example, is quoted by replacing it
 332  *   with {@code &quot;%20&quot;}.  UTF-8 contains US-ASCII, hence for US-ASCII
 333  *   characters this transformation has exactly the effect required by
 334  *   RFC&amp;nbsp;2396. &lt;/p&gt;&lt;/li&gt;
 335  *
 336  *   &lt;li&gt;&lt;p&gt;&lt;a id=&quot;decode&quot;&gt;&lt;/a&gt;
 337  *   A sequence of escaped octets is &lt;i&gt;decoded&lt;/i&gt; by
 338  *   replacing it with the sequence of characters that it represents in the
 339  *   UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the
 340  *   effect of de-quoting any quoted US-ASCII characters as well as that of
 341  *   decoding any encoded non-US-ASCII characters.  If a &lt;a
 342  *   href=&quot;../nio/charset/CharsetDecoder.html#ce&quot;&gt;decoding error&lt;/a&gt; occurs
 343  *   when decoding the escaped octets then the erroneous octets are replaced by
 344  *   {@code &#39;\u005CuFFFD&#39;}, the Unicode replacement character.  &lt;/p&gt;&lt;/li&gt;
 345  *
 346  * &lt;/ul&gt;
 347  *
 348  * These operations are exposed in the constructors and methods of this class
 349  * as follows:
 350  *
 351  * &lt;ul&gt;
 352  *
 353  *   &lt;li&gt;&lt;p&gt; The {@linkplain #URI(java.lang.String) single-argument
 354  *   constructor} requires any illegal characters in its argument to be
 355  *   quoted and preserves any escaped octets and &lt;i&gt;other&lt;/i&gt; characters that
 356  *   are present.  &lt;/p&gt;&lt;/li&gt;
 357  *
 358  *   &lt;li&gt;&lt;p&gt; The {@linkplain
 359  *   #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)
 360  *   multi-argument constructors} quote illegal characters as
 361  *   required by the components in which they appear.  The percent character
 362  *   ({@code &#39;%&#39;}) is always quoted by these constructors.  Any &lt;i&gt;other&lt;/i&gt;
 363  *   characters are preserved.  &lt;/p&gt;&lt;/li&gt;
 364  *
 365  *   &lt;li&gt;&lt;p&gt; The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()
 366  *   getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()
 367  *   getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link
 368  *   #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the
 369  *   values of their corresponding components in raw form, without interpreting
 370  *   any escaped octets.  The strings returned by these methods may contain
 371  *   both escaped octets and &lt;i&gt;other&lt;/i&gt; characters, and will not contain any
 372  *   illegal characters.  &lt;/p&gt;&lt;/li&gt;
 373  *
 374  *   &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
 375  *   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
 376  *   getFragment}, {@link #getAuthority() getAuthority}, and {@link
 377  *   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
 378  *   octets in their corresponding components.  The strings returned by these
 379  *   methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
 380  *   and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
 381  *
 382  *   &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
 383  *   all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
 384  *   &lt;/p&gt;&lt;/li&gt;
 385  *
 386  *   &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
 387  *   quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
 388  *   characters.  &lt;/p&gt;&lt;/li&gt;
 389  *
 390  * &lt;/ul&gt;
 391  *
 392  *
<a name="8" id="anc8"></a><span class="line-modified"> 393  * &lt;h3&gt; Identities &lt;/h3&gt;</span>
 394  *
 395  * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
 396  *
 397  * &lt;blockquote&gt;
 398  * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
 399  * &lt;/blockquote&gt;
 400  *
 401  * For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
 402  * slashes before an empty authority (as in {@code file:///tmp/}&amp;nbsp;) or a
 403  * colon following a host name but no port (as in
 404  * {@code http://www.example.com:}&amp;nbsp;), and that does not encode characters
 405  * except those that must be quoted, the following identities also hold:
 406  * &lt;pre&gt;
 407  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 408  *             &lt;i&gt;u&lt;/i&gt;.getSchemeSpecificPart(),
 409  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 410  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 411  * in all cases,
 412  * &lt;pre&gt;
 413  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 414  *             &lt;i&gt;u&lt;/i&gt;.getAuthority(),
 415  *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 416  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 417  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 418  * if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
 419  * &lt;pre&gt;
 420  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 421  *             &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getHost(), &lt;i&gt;u&lt;/i&gt;.getPort(),
 422  *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 423  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 424  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 425  * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
 426  * authority.
 427  *
 428  *
<a name="9" id="anc9"></a><span class="line-modified"> 429  * &lt;h3&gt; URIs, URLs, and URNs &lt;/h3&gt;</span>
 430  *
 431  * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
 432  * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
 433  * not every URI is a URL.  This is because there is another subcategory of
 434  * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
 435  * specify how to locate them.  The {@code mailto}, {@code news}, and
 436  * {@code isbn} URIs shown above are examples of URNs.
 437  *
 438  * &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
 439  * differences between this class and the {@link URL} class.
 440  *
 441  * &lt;p&gt; An instance of this class represents a URI reference in the syntactic
 442  * sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
 443  * A URI string is parsed according to the generic syntax without regard to the
 444  * scheme, if any, that it specifies.  No lookup of the host, if any, is
 445  * performed, and no scheme-dependent stream handler is constructed.  Equality,
 446  * hashing, and comparison are defined strictly in terms of the character
 447  * content of the instance.  In other words, a URI instance is little more than
 448  * a structured string that supports the syntactic, scheme-independent
 449  * operations of comparison, normalization, resolution, and relativization.
 450  *
 451  * &lt;p&gt; An instance of the {@link URL} class, by contrast, represents the
 452  * syntactic components of a URL together with some of the information required
 453  * to access the resource that it describes.  A URL must be absolute, that is,
 454  * it must always specify a scheme.  A URL string is parsed according to its
 455  * scheme.  A stream handler is always established for a URL, and in fact it is
 456  * impossible to create a URL instance for a scheme for which no handler is
 457  * available.  Equality and hashing depend upon both the scheme and the
 458  * Internet address of the host, if any; comparison is not defined.  In other
 459  * words, a URL is a structured string that supports the syntactic operation of
 460  * resolution as well as the network I/O operations of looking up the host and
 461  * opening a connection to the specified resource.
 462  *
 463  * @apiNote
 464  *
 465  * Applications working with file paths and file URIs should take great
 466  * care to use the appropriate methods to convert between the two.
 467  * The {@link Path#of(URI)} factory method and the {@link File#File(URI)}
 468  * constructor can be used to create {@link Path} or {@link File}
 469  * objects from a file URI. {@link Path#toUri()} and {@link File#toURI()}
 470  * can be used to create a {@link URI} from a file path.
 471  * Applications should never try to {@linkplain
 472  * #URI(String, String, String, int, String, String, String)
 473  * construct}, {@linkplain #URI(String) parse}, or
 474  * {@linkplain #resolve(String) resolve} a {@code URI}
 475  * from the direct string representation of a {@code File} or {@code Path}
 476  * instance.
 477  * &lt;p&gt;
 478  * Some components of a URL or URI, such as &lt;i&gt;userinfo&lt;/i&gt;, may
 479  * be abused to construct misleading URLs or URIs. Applications
 480  * that deal with URLs or URIs should take into account
 481  * the recommendations advised in &lt;a
 482  * href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;RFC3986,
 483  * Section 7, Security Considerations&lt;/a&gt;.
 484  *
 485  * @author Mark Reinhold
 486  * @since 1.4
 487  *
 488  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
 489  * transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 490  * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
 491  * Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 492  * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 493  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 494  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 495  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 496  * href=&quot;URISyntaxException.html&quot;&gt;URISyntaxException&lt;/a&gt;
 497  */
 498 
 499 public final class URI
 500     implements Comparable&lt;URI&gt;, Serializable
 501 {
 502 
 503     // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
 504     // throw of an InternalError should be replaced by an appropriate assertion
 505     // statement once asserts are enabled in the build.
<a name="10" id="anc10"></a><span class="line-modified"> 506     @java.io.Serial</span>
 507     static final long serialVersionUID = -6052424284110960213L;
 508 
 509 
 510     // -- Properties and components of this instance --
 511 
 512     // Components of all URIs: [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
 513     private transient String scheme;            // null ==&gt; relative URI
 514     private transient String fragment;
 515 
 516     // Hierarchical URI components: [//&lt;authority&gt;]&lt;path&gt;[?&lt;query&gt;]
 517     private transient String authority;         // Registry or server
 518 
 519     // Server-based authority: [&lt;userInfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
 520     private transient String userInfo;
 521     private transient String host;              // null ==&gt; registry-based
 522     private transient int port = -1;            // -1 ==&gt; undefined
 523 
 524     // Remaining components of hierarchical URIs
 525     private transient String path;              // null ==&gt; opaque
 526     private transient String query;
 527 
 528     // The remaining fields may be computed on demand, which is safe even in
 529     // the face of multiple threads racing to initialize them
 530     private transient String schemeSpecificPart;
 531     private transient int hash;        // Zero ==&gt; undefined
 532 
 533     private transient String decodedUserInfo;
 534     private transient String decodedAuthority;
 535     private transient String decodedPath;
 536     private transient String decodedQuery;
 537     private transient String decodedFragment;
 538     private transient String decodedSchemeSpecificPart;
 539 
 540     /**
 541      * The string form of this URI.
 542      *
 543      * @serial
 544      */
 545     private volatile String string;             // The only serializable field
 546 
 547 
 548 
 549     // -- Constructors and factories --
 550 
 551     private URI() { }                           // Used internally
 552 
 553     /**
 554      * Constructs a URI by parsing the given string.
 555      *
 556      * &lt;p&gt; This constructor parses the given string exactly as specified by the
 557      * grammar in &lt;a
 558      * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 559      * Appendix&amp;nbsp;A, &lt;b&gt;&lt;i&gt;except for the following deviations:&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;
 560      *
 561      * &lt;ul&gt;
 562      *
 563      *   &lt;li&gt;&lt;p&gt; An empty authority component is permitted as long as it is
 564      *   followed by a non-empty path, a query component, or a fragment
 565      *   component.  This allows the parsing of URIs such as
 566      *   {@code &quot;file:///foo/bar&quot;}, which seems to be the intent of
 567      *   RFC&amp;nbsp;2396 although the grammar does not permit it.  If the
 568      *   authority component is empty then the user-information, host, and port
 569      *   components are undefined. &lt;/p&gt;&lt;/li&gt;
 570      *
 571      *   &lt;li&gt;&lt;p&gt; Empty relative paths are permitted; this seems to be the
 572      *   intent of RFC&amp;nbsp;2396 although the grammar does not permit it.  The
 573      *   primary consequence of this deviation is that a standalone fragment
 574      *   such as {@code &quot;#foo&quot;} parses as a relative URI with an empty path
 575      *   and the given fragment, and can be usefully &lt;a
 576      *   href=&quot;#resolve-frag&quot;&gt;resolved&lt;/a&gt; against a base URI.
 577      *
 578      *   &lt;li&gt;&lt;p&gt; IPv4 addresses in host components are parsed rigorously, as
 579      *   specified by &lt;a
 580      *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;: Each
 581      *   element of a dotted-quad address must contain no more than three
 582      *   decimal digits.  Each element is further constrained to have a value
 583      *   no greater than 255. &lt;/p&gt;&lt;/li&gt;
 584      *
 585      *   &lt;li&gt; &lt;p&gt; Hostnames in host components that comprise only a single
 586      *   domain label are permitted to start with an &lt;i&gt;alphanum&lt;/i&gt;
 587      *   character. This seems to be the intent of &lt;a
 588      *   href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
 589      *   section&amp;nbsp;3.2.2 although the grammar does not permit it. The
 590      *   consequence of this deviation is that the authority component of a
 591      *   hierarchical URI such as {@code s://123}, will parse as a server-based
 592      *   authority. &lt;/p&gt;&lt;/li&gt;
 593      *
 594      *   &lt;li&gt;&lt;p&gt; IPv6 addresses are permitted for the host component.  An IPv6
 595      *   address must be enclosed in square brackets ({@code &#39;[&#39;} and
 596      *   {@code &#39;]&#39;}) as specified by &lt;a
 597      *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;.  The
 598      *   IPv6 address itself must parse according to &lt;a
 599      *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;.  IPv6
 600      *   addresses are further constrained to describe no more than sixteen
 601      *   bytes of address information, a constraint implicit in RFC&amp;nbsp;2373
 602      *   but not expressible in the grammar. &lt;/p&gt;&lt;/li&gt;
 603      *
 604      *   &lt;li&gt;&lt;p&gt; Characters in the &lt;i&gt;other&lt;/i&gt; category are permitted wherever
 605      *   RFC&amp;nbsp;2396 permits &lt;i&gt;escaped&lt;/i&gt; octets, that is, in the
 606      *   user-information, path, query, and fragment components, as well as in
 607      *   the authority component if the authority is registry-based.  This
 608      *   allows URIs to contain Unicode characters beyond those in the US-ASCII
 609      *   character set. &lt;/p&gt;&lt;/li&gt;
 610      *
 611      * &lt;/ul&gt;
 612      *
 613      * @param  str   The string to be parsed into a URI
 614      *
 615      * @throws  NullPointerException
 616      *          If {@code str} is {@code null}
 617      *
 618      * @throws  URISyntaxException
 619      *          If the given string violates RFC&amp;nbsp;2396, as augmented
 620      *          by the above deviations
 621      */
 622     public URI(String str) throws URISyntaxException {
 623         new Parser(str).parse(false);
 624     }
 625 
 626     /**
 627      * Constructs a hierarchical URI from the given components.
 628      *
 629      * &lt;p&gt; If a scheme is given then the path, if also given, must either be
 630      * empty or begin with a slash character ({@code &#39;/&#39;}).  Otherwise a
 631      * component of the new URI may be left undefined by passing {@code null}
 632      * for the corresponding parameter or, in the case of the {@code port}
 633      * parameter, by passing {@code -1}.
 634      *
 635      * &lt;p&gt; This constructor first builds a URI string from the given components
 636      * according to the rules specified in &lt;a
 637      * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 638      * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
 639      *
 640      * &lt;ol&gt;
 641      *
 642      *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty. &lt;/p&gt;&lt;/li&gt;
 643      *
 644      *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
 645      *   followed by a colon character ({@code &#39;:&#39;}).  &lt;/p&gt;&lt;/li&gt;
 646      *
 647      *   &lt;li&gt;&lt;p&gt; If user information, a host, or a port are given then the
 648      *   string {@code &quot;//&quot;} is appended.  &lt;/p&gt;&lt;/li&gt;
 649      *
 650      *   &lt;li&gt;&lt;p&gt; If user information is given then it is appended, followed by
 651      *   a commercial-at character ({@code &#39;@&#39;}).  Any character not in the
 652      *   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
 653      *   categories is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
 654      *
 655      *   &lt;li&gt;&lt;p&gt; If a host is given then it is appended.  If the host is a
 656      *   literal IPv6 address but is not enclosed in square brackets
 657      *   ({@code &#39;[&#39;} and {@code &#39;]&#39;}) then the square brackets are added.
 658      *   &lt;/p&gt;&lt;/li&gt;
 659      *
 660      *   &lt;li&gt;&lt;p&gt; If a port number is given then a colon character
 661      *   ({@code &#39;:&#39;}) is appended, followed by the port number in decimal.
 662      *   &lt;/p&gt;&lt;/li&gt;
 663      *
 664      *   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
 665      *   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
 666      *   categories, and not equal to the slash character ({@code &#39;/&#39;}) or the
 667      *   commercial-at character ({@code &#39;@&#39;}), is quoted.  &lt;/p&gt;&lt;/li&gt;
 668      *
 669      *   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
 670      *   ({@code &#39;?&#39;}) is appended, followed by the query.  Any character that
 671      *   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
 672      *   &lt;/p&gt;&lt;/li&gt;
 673      *
 674      *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
 675      *   ({@code &#39;#&#39;}) is appended, followed by the fragment.  Any character
 676      *   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
 677      *
 678      * &lt;/ol&gt;
 679      *
 680      * &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
 681      * #URI(String)} constructor and then invoking the {@link
 682      * #parseServerAuthority()} method upon the result; this may cause a {@link
 683      * URISyntaxException} to be thrown.  &lt;/p&gt;
 684      *
 685      * @param   scheme    Scheme name
 686      * @param   userInfo  User name and authorization information
 687      * @param   host      Host name
 688      * @param   port      Port number
 689      * @param   path      Path
 690      * @param   query     Query
 691      * @param   fragment  Fragment
 692      *
 693      * @throws URISyntaxException
 694      *         If both a scheme and a path are given but the path is relative,
 695      *         if the URI string constructed from the given components violates
 696      *         RFC&amp;nbsp;2396, or if the authority component of the string is
 697      *         present but cannot be parsed as a server-based authority
 698      */
 699     public URI(String scheme,
 700                String userInfo, String host, int port,
 701                String path, String query, String fragment)
 702         throws URISyntaxException
 703     {
 704         String s = toString(scheme, null,
 705                             null, userInfo, host, port,
 706                             path, query, fragment);
 707         checkPath(s, scheme, path);
 708         new Parser(s).parse(true);
 709     }
 710 
 711     /**
 712      * Constructs a hierarchical URI from the given components.
 713      *
 714      * &lt;p&gt; If a scheme is given then the path, if also given, must either be
 715      * empty or begin with a slash character ({@code &#39;/&#39;}).  Otherwise a
 716      * component of the new URI may be left undefined by passing {@code null}
 717      * for the corresponding parameter.
 718      *
 719      * &lt;p&gt; This constructor first builds a URI string from the given components
 720      * according to the rules specified in &lt;a
 721      * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 722      * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
 723      *
 724      * &lt;ol&gt;
 725      *
 726      *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
 727      *
 728      *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
 729      *   followed by a colon character ({@code &#39;:&#39;}).  &lt;/p&gt;&lt;/li&gt;
 730      *
 731      *   &lt;li&gt;&lt;p&gt; If an authority is given then the string {@code &quot;//&quot;} is
 732      *   appended, followed by the authority.  If the authority contains a
 733      *   literal IPv6 address then the address must be enclosed in square
 734      *   brackets ({@code &#39;[&#39;} and {@code &#39;]&#39;}).  Any character not in the
 735      *   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
 736      *   categories, and not equal to the commercial-at character
 737      *   ({@code &#39;@&#39;}), is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
 738      *
 739      *   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
 740      *   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
 741      *   categories, and not equal to the slash character ({@code &#39;/&#39;}) or the
 742      *   commercial-at character ({@code &#39;@&#39;}), is quoted.  &lt;/p&gt;&lt;/li&gt;
 743      *
 744      *   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
 745      *   ({@code &#39;?&#39;}) is appended, followed by the query.  Any character that
 746      *   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
 747      *   &lt;/p&gt;&lt;/li&gt;
 748      *
 749      *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
 750      *   ({@code &#39;#&#39;}) is appended, followed by the fragment.  Any character
 751      *   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
 752      *
 753      * &lt;/ol&gt;
 754      *
 755      * &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
 756      * #URI(String)} constructor and then invoking the {@link
 757      * #parseServerAuthority()} method upon the result; this may cause a {@link
 758      * URISyntaxException} to be thrown.  &lt;/p&gt;
 759      *
 760      * @param   scheme     Scheme name
 761      * @param   authority  Authority
 762      * @param   path       Path
 763      * @param   query      Query
 764      * @param   fragment   Fragment
 765      *
 766      * @throws URISyntaxException
 767      *         If both a scheme and a path are given but the path is relative,
 768      *         if the URI string constructed from the given components violates
 769      *         RFC&amp;nbsp;2396, or if the authority component of the string is
 770      *         present but cannot be parsed as a server-based authority
 771      */
 772     public URI(String scheme,
 773                String authority,
 774                String path, String query, String fragment)
 775         throws URISyntaxException
 776     {
 777         String s = toString(scheme, null,
 778                             authority, null, null, -1,
 779                             path, query, fragment);
 780         checkPath(s, scheme, path);
 781         new Parser(s).parse(false);
 782     }
 783 
 784     /**
 785      * Constructs a hierarchical URI from the given components.
 786      *
 787      * &lt;p&gt; A component may be left undefined by passing {@code null}.
 788      *
 789      * &lt;p&gt; This convenience constructor works as if by invoking the
 790      * seven-argument constructor as follows:
 791      *
 792      * &lt;blockquote&gt;
 793      * {@code new} {@link #URI(String, String, String, int, String, String, String)
 794      * URI}{@code (scheme, null, host, -1, path, null, fragment);}
 795      * &lt;/blockquote&gt;
 796      *
 797      * @param   scheme    Scheme name
 798      * @param   host      Host name
 799      * @param   path      Path
 800      * @param   fragment  Fragment
 801      *
 802      * @throws  URISyntaxException
 803      *          If the URI string constructed from the given components
 804      *          violates RFC&amp;nbsp;2396
 805      */
 806     public URI(String scheme, String host, String path, String fragment)
 807         throws URISyntaxException
 808     {
 809         this(scheme, null, host, -1, path, null, fragment);
 810     }
 811 
 812     /**
 813      * Constructs a URI from the given components.
 814      *
 815      * &lt;p&gt; A component may be left undefined by passing {@code null}.
 816      *
 817      * &lt;p&gt; This constructor first builds a URI in string form using the given
 818      * components as follows:  &lt;/p&gt;
 819      *
 820      * &lt;ol&gt;
 821      *
 822      *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
 823      *
 824      *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
 825      *   followed by a colon character ({@code &#39;:&#39;}).  &lt;/p&gt;&lt;/li&gt;
 826      *
 827      *   &lt;li&gt;&lt;p&gt; If a scheme-specific part is given then it is appended.  Any
 828      *   character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt;
 829      *   is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
 830      *
 831      *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
 832      *   ({@code &#39;#&#39;}) is appended to the string, followed by the fragment.
 833      *   Any character that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
 834      *
 835      * &lt;/ol&gt;
 836      *
 837      * &lt;p&gt; The resulting URI string is then parsed in order to create the new
 838      * URI instance as if by invoking the {@link #URI(String)} constructor;
 839      * this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;
 840      *
 841      * @param   scheme    Scheme name
 842      * @param   ssp       Scheme-specific part
 843      * @param   fragment  Fragment
 844      *
 845      * @throws  URISyntaxException
 846      *          If the URI string constructed from the given components
 847      *          violates RFC&amp;nbsp;2396
 848      */
 849     public URI(String scheme, String ssp, String fragment)
 850         throws URISyntaxException
 851     {
 852         new Parser(toString(scheme, ssp,
 853                             null, null, null, -1,
 854                             null, null, fragment))
 855             .parse(false);
 856     }
 857 
 858     /**
 859      * Constructs a simple URI consisting of only a scheme and a pre-validated
 860      * path. Provides a fast-path for some internal cases.
 861      */
 862     URI(String scheme, String path) {
 863         assert validSchemeAndPath(scheme, path);
 864         this.scheme = scheme;
 865         this.path = path;
 866     }
 867 
 868     private static boolean validSchemeAndPath(String scheme, String path) {
 869         try {
 870             URI u = new URI(scheme + &quot;:&quot; + path);
 871             return scheme.equals(u.scheme) &amp;&amp; path.equals(u.path);
 872         } catch (URISyntaxException e) {
 873             return false;
 874         }
 875     }
 876 
 877     /**
 878      * Creates a URI by parsing the given string.
 879      *
 880      * &lt;p&gt; This convenience factory method works as if by invoking the {@link
 881      * #URI(String)} constructor; any {@link URISyntaxException} thrown by the
 882      * constructor is caught and wrapped in a new {@link
 883      * IllegalArgumentException} object, which is then thrown.
 884      *
 885      * &lt;p&gt; This method is provided for use in situations where it is known that
 886      * the given string is a legal URI, for example for URI constants declared
 887      * within a program, and so it would be considered a programming error
 888      * for the string not to parse as such.  The constructors, which throw
 889      * {@link URISyntaxException} directly, should be used in situations where a
 890      * URI is being constructed from user input or from some other source that
 891      * may be prone to errors.  &lt;/p&gt;
 892      *
 893      * @param  str   The string to be parsed into a URI
 894      * @return The new URI
 895      *
 896      * @throws  NullPointerException
 897      *          If {@code str} is {@code null}
 898      *
 899      * @throws  IllegalArgumentException
 900      *          If the given string violates RFC&amp;nbsp;2396
 901      */
 902     public static URI create(String str) {
 903         try {
 904             return new URI(str);
 905         } catch (URISyntaxException x) {
 906             throw new IllegalArgumentException(x.getMessage(), x);
 907         }
 908     }
 909 
 910 
 911     // -- Operations --
 912 
 913     /**
 914      * Attempts to parse this URI&#39;s authority component, if defined, into
 915      * user-information, host, and port components.
 916      *
 917      * &lt;p&gt; If this URI&#39;s authority component has already been recognized as
 918      * being server-based then it will already have been parsed into
 919      * user-information, host, and port components.  In this case, or if this
 920      * URI has no authority component, this method simply returns this URI.
 921      *
 922      * &lt;p&gt; Otherwise this method attempts once more to parse the authority
 923      * component into user-information, host, and port components, and throws
 924      * an exception describing why the authority component could not be parsed
 925      * in that way.
 926      *
 927      * &lt;p&gt; This method is provided because the generic URI syntax specified in
 928      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
 929      * cannot always distinguish a malformed server-based authority from a
 930      * legitimate registry-based authority.  It must therefore treat some
 931      * instances of the former as instances of the latter.  The authority
 932      * component in the URI string {@code &quot;//foo:bar&quot;}, for example, is not a
 933      * legal server-based authority but it is legal as a registry-based
 934      * authority.
 935      *
 936      * &lt;p&gt; In many common situations, for example when working URIs that are
 937      * known to be either URNs or URLs, the hierarchical URIs being used will
 938      * always be server-based.  They therefore must either be parsed as such or
 939      * treated as an error.  In these cases a statement such as
 940      *
 941      * &lt;blockquote&gt;
 942      * {@code URI }&lt;i&gt;u&lt;/i&gt;{@code  = new URI(str).parseServerAuthority();}
 943      * &lt;/blockquote&gt;
 944      *
 945      * &lt;p&gt; can be used to ensure that &lt;i&gt;u&lt;/i&gt; always refers to a URI that, if
 946      * it has an authority component, has a server-based authority with proper
 947      * user-information, host, and port components.  Invoking this method also
 948      * ensures that if the authority could not be parsed in that way then an
 949      * appropriate diagnostic message can be issued based upon the exception
 950      * that is thrown. &lt;/p&gt;
 951      *
 952      * @return  A URI whose authority field has been parsed
 953      *          as a server-based authority
 954      *
 955      * @throws  URISyntaxException
 956      *          If the authority component of this URI is defined
 957      *          but cannot be parsed as a server-based authority
 958      *          according to RFC&amp;nbsp;2396
 959      */
 960     public URI parseServerAuthority()
 961         throws URISyntaxException
 962     {
 963         // We could be clever and cache the error message and index from the
 964         // exception thrown during the original parse, but that would require
 965         // either more fields or a more-obscure representation.
 966         if ((host != null) || (authority == null))
 967             return this;
 968         new Parser(toString()).parse(true);
 969         return this;
 970     }
 971 
 972     /**
 973      * Normalizes this URI&#39;s path.
 974      *
 975      * &lt;p&gt; If this URI is opaque, or if its path is already in normal form,
 976      * then this URI is returned.  Otherwise a new URI is constructed that is
 977      * identical to this URI except that its path is computed by normalizing
 978      * this URI&#39;s path in a manner consistent with &lt;a
 979      * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 980      * section&amp;nbsp;5.2, step&amp;nbsp;6, sub-steps&amp;nbsp;c through&amp;nbsp;f; that is:
 981      * &lt;/p&gt;
 982      *
 983      * &lt;ol&gt;
 984      *
 985      *   &lt;li&gt;&lt;p&gt; All {@code &quot;.&quot;} segments are removed. &lt;/p&gt;&lt;/li&gt;
 986      *
 987      *   &lt;li&gt;&lt;p&gt; If a {@code &quot;..&quot;} segment is preceded by a non-{@code &quot;..&quot;}
 988      *   segment then both of these segments are removed.  This step is
 989      *   repeated until it is no longer applicable. &lt;/p&gt;&lt;/li&gt;
 990      *
 991      *   &lt;li&gt;&lt;p&gt; If the path is relative, and if its first segment contains a
 992      *   colon character ({@code &#39;:&#39;}), then a {@code &quot;.&quot;} segment is
 993      *   prepended.  This prevents a relative URI with a path such as
 994      *   {@code &quot;a:b/c/d&quot;} from later being re-parsed as an opaque URI with a
 995      *   scheme of {@code &quot;a&quot;} and a scheme-specific part of {@code &quot;b/c/d&quot;}.
 996      *   &lt;b&gt;&lt;i&gt;(Deviation from RFC&amp;nbsp;2396)&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;&lt;/li&gt;
 997      *
 998      * &lt;/ol&gt;
 999      *
1000      * &lt;p&gt; A normalized path will begin with one or more {@code &quot;..&quot;} segments
1001      * if there were insufficient non-{@code &quot;..&quot;} segments preceding them to
1002      * allow their removal.  A normalized path will begin with a {@code &quot;.&quot;}
1003      * segment if one was inserted by step 3 above.  Otherwise, a normalized
1004      * path will not contain any {@code &quot;.&quot;} or {@code &quot;..&quot;} segments. &lt;/p&gt;
1005      *
1006      * @return  A URI equivalent to this URI,
1007      *          but whose path is in normal form
1008      */
1009     public URI normalize() {
1010         return normalize(this);
1011     }
1012 
1013     /**
1014      * Resolves the given URI against this URI.
1015      *
1016      * &lt;p&gt; If the given URI is already absolute, or if this URI is opaque, then
1017      * the given URI is returned.
1018      *
1019      * &lt;p&gt;&lt;a id=&quot;resolve-frag&quot;&gt;&lt;/a&gt; If the given URI&#39;s fragment component is
1020      * defined, its path component is empty, and its scheme, authority, and
1021      * query components are undefined, then a URI with the given fragment but
1022      * with all other components equal to those of this URI is returned.  This
1023      * allows a URI representing a standalone fragment reference, such as
1024      * {@code &quot;#foo&quot;}, to be usefully resolved against a base URI.
1025      *
1026      * &lt;p&gt; Otherwise this method constructs a new hierarchical URI in a manner
1027      * consistent with &lt;a
1028      * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
1029      * section&amp;nbsp;5.2; that is: &lt;/p&gt;
1030      *
1031      * &lt;ol&gt;
1032      *
1033      *   &lt;li&gt;&lt;p&gt; A new URI is constructed with this URI&#39;s scheme and the given
1034      *   URI&#39;s query and fragment components. &lt;/p&gt;&lt;/li&gt;
1035      *
1036      *   &lt;li&gt;&lt;p&gt; If the given URI has an authority component then the new URI&#39;s
1037      *   authority and path are taken from the given URI. &lt;/p&gt;&lt;/li&gt;
1038      *
1039      *   &lt;li&gt;&lt;p&gt; Otherwise the new URI&#39;s authority component is copied from
1040      *   this URI, and its path is computed as follows: &lt;/p&gt;
1041      *
1042      *   &lt;ol&gt;
1043      *
1044      *     &lt;li&gt;&lt;p&gt; If the given URI&#39;s path is absolute then the new URI&#39;s path
1045      *     is taken from the given URI. &lt;/p&gt;&lt;/li&gt;
1046      *
1047      *     &lt;li&gt;&lt;p&gt; Otherwise the given URI&#39;s path is relative, and so the new
1048      *     URI&#39;s path is computed by resolving the path of the given URI
1049      *     against the path of this URI.  This is done by concatenating all but
1050      *     the last segment of this URI&#39;s path, if any, with the given URI&#39;s
1051      *     path and then normalizing the result as if by invoking the {@link
1052      *     #normalize() normalize} method. &lt;/p&gt;&lt;/li&gt;
1053      *
1054      *   &lt;/ol&gt;&lt;/li&gt;
1055      *
1056      * &lt;/ol&gt;
1057      *
1058      * &lt;p&gt; The result of this method is absolute if, and only if, either this
1059      * URI is absolute or the given URI is absolute.  &lt;/p&gt;
1060      *
1061      * @param  uri  The URI to be resolved against this URI
1062      * @return The resulting URI
1063      *
1064      * @throws  NullPointerException
1065      *          If {@code uri} is {@code null}
1066      */
1067     public URI resolve(URI uri) {
1068         return resolve(this, uri);
1069     }
1070 
1071     /**
1072      * Constructs a new URI by parsing the given string and then resolving it
1073      * against this URI.
1074      *
1075      * &lt;p&gt; This convenience method works as if invoking it were equivalent to
1076      * evaluating the expression {@link #resolve(java.net.URI)
1077      * resolve}{@code (URI.}{@link #create(String) create}{@code (str))}. &lt;/p&gt;
1078      *
1079      * @param  str   The string to be parsed into a URI
1080      * @return The resulting URI
1081      *
1082      * @throws  NullPointerException
1083      *          If {@code str} is {@code null}
1084      *
1085      * @throws  IllegalArgumentException
1086      *          If the given string violates RFC&amp;nbsp;2396
1087      */
1088     public URI resolve(String str) {
1089         return resolve(URI.create(str));
1090     }
1091 
1092     /**
1093      * Relativizes the given URI against this URI.
1094      *
1095      * &lt;p&gt; The relativization of the given URI against this URI is computed as
1096      * follows: &lt;/p&gt;
1097      *
1098      * &lt;ol&gt;
1099      *
1100      *   &lt;li&gt;&lt;p&gt; If either this URI or the given URI are opaque, or if the
1101      *   scheme and authority components of the two URIs are not identical, or
1102      *   if the path of this URI is not a prefix of the path of the given URI,
1103      *   then the given URI is returned. &lt;/p&gt;&lt;/li&gt;
1104      *
1105      *   &lt;li&gt;&lt;p&gt; Otherwise a new relative hierarchical URI is constructed with
1106      *   query and fragment components taken from the given URI and with a path
1107      *   component computed by removing this URI&#39;s path from the beginning of
1108      *   the given URI&#39;s path. &lt;/p&gt;&lt;/li&gt;
1109      *
1110      * &lt;/ol&gt;
1111      *
1112      * @param  uri  The URI to be relativized against this URI
1113      * @return The resulting URI
1114      *
1115      * @throws  NullPointerException
1116      *          If {@code uri} is {@code null}
1117      */
1118     public URI relativize(URI uri) {
1119         return relativize(this, uri);
1120     }
1121 
1122     /**
1123      * Constructs a URL from this URI.
1124      *
1125      * &lt;p&gt; This convenience method works as if invoking it were equivalent to
1126      * evaluating the expression {@code new URL(this.toString())} after
1127      * first checking that this URI is absolute. &lt;/p&gt;
1128      *
1129      * @return  A URL constructed from this URI
1130      *
1131      * @throws  IllegalArgumentException
1132      *          If this URL is not absolute
1133      *
1134      * @throws  MalformedURLException
1135      *          If a protocol handler for the URL could not be found,
1136      *          or if some other error occurred while constructing the URL
1137      */
1138     public URL toURL() throws MalformedURLException {
1139         return URL.fromURI(this);
1140     }
1141 
1142     // -- Component access methods --
1143 
1144     /**
1145      * Returns the scheme component of this URI.
1146      *
1147      * &lt;p&gt; The scheme component of a URI, if defined, only contains characters
1148      * in the &lt;i&gt;alphanum&lt;/i&gt; category and in the string {@code &quot;-.+&quot;}.  A
1149      * scheme always starts with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;p&gt;
1150      *
1151      * The scheme component of a URI cannot contain escaped octets, hence this
1152      * method does not perform any decoding.
1153      *
1154      * @return  The scheme component of this URI,
1155      *          or {@code null} if the scheme is undefined
1156      */
1157     public String getScheme() {
1158         return scheme;
1159     }
1160 
1161     /**
1162      * Tells whether or not this URI is absolute.
1163      *
1164      * &lt;p&gt; A URI is absolute if, and only if, it has a scheme component. &lt;/p&gt;
1165      *
1166      * @return  {@code true} if, and only if, this URI is absolute
1167      */
1168     public boolean isAbsolute() {
1169         return scheme != null;
1170     }
1171 
1172     /**
1173      * Tells whether or not this URI is opaque.
1174      *
1175      * &lt;p&gt; A URI is opaque if, and only if, it is absolute and its
1176      * scheme-specific part does not begin with a slash character (&#39;/&#39;).
1177      * An opaque URI has a scheme, a scheme-specific part, and possibly
1178      * a fragment; all other components are undefined. &lt;/p&gt;
1179      *
1180      * @return  {@code true} if, and only if, this URI is opaque
1181      */
1182     public boolean isOpaque() {
1183         return path == null;
1184     }
1185 
1186     /**
1187      * Returns the raw scheme-specific part of this URI.  The scheme-specific
1188      * part is never undefined, though it may be empty.
1189      *
1190      * &lt;p&gt; The scheme-specific part of a URI only contains legal URI
1191      * characters. &lt;/p&gt;
1192      *
1193      * @return  The raw scheme-specific part of this URI
1194      *          (never {@code null})
1195      */
1196     public String getRawSchemeSpecificPart() {
1197         String part = schemeSpecificPart;
1198         if (part != null) {
1199             return part;
1200         }
1201 
1202         String s = string;
1203         if (s != null) {
1204             // if string is defined, components will have been parsed
1205             int start = 0;
1206             int end = s.length();
1207             if (scheme != null) {
1208                 start = scheme.length() + 1;
1209             }
1210             if (fragment != null) {
1211                 end -= fragment.length() + 1;
1212             }
1213             if (path != null &amp;&amp; path.length() == end - start) {
1214                 part = path;
1215             } else {
1216                 part = s.substring(start, end);
1217             }
1218         } else {
1219             StringBuilder sb = new StringBuilder();
1220             appendSchemeSpecificPart(sb, null, getAuthority(), getUserInfo(),
1221                                  host, port, getPath(), getQuery());
1222             part = sb.toString();
1223         }
1224         return schemeSpecificPart = part;
1225     }
1226 
1227     /**
1228      * Returns the decoded scheme-specific part of this URI.
1229      *
1230      * &lt;p&gt; The string returned by this method is equal to that returned by the
1231      * {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method
1232      * except that all sequences of escaped octets are &lt;a
1233      * href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
1234      *
1235      * @return  The decoded scheme-specific part of this URI
1236      *          (never {@code null})
1237      */
1238     public String getSchemeSpecificPart() {
1239         String part = decodedSchemeSpecificPart;
1240         if (part == null) {
1241             decodedSchemeSpecificPart = part = decode(getRawSchemeSpecificPart());
1242         }
1243         return part;
1244     }
1245 
1246     /**
1247      * Returns the raw authority component of this URI.
1248      *
1249      * &lt;p&gt; The authority component of a URI, if defined, only contains the
1250      * commercial-at character ({@code &#39;@&#39;}) and characters in the
1251      * &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
1252      * categories.  If the authority is server-based then it is further
1253      * constrained to have valid user-information, host, and port
1254      * components. &lt;/p&gt;
1255      *
1256      * @return  The raw authority component of this URI,
1257      *          or {@code null} if the authority is undefined
1258      */
1259     public String getRawAuthority() {
1260         return authority;
1261     }
1262 
1263     /**
1264      * Returns the decoded authority component of this URI.
1265      *
1266      * &lt;p&gt; The string returned by this method is equal to that returned by the
1267      * {@link #getRawAuthority() getRawAuthority} method except that all
1268      * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
1269      *
1270      * @return  The decoded authority component of this URI,
1271      *          or {@code null} if the authority is undefined
1272      */
1273     public String getAuthority() {
1274         String auth = decodedAuthority;
1275         if ((auth == null) &amp;&amp; (authority != null)) {
1276             decodedAuthority = auth = decode(authority);
1277         }
1278         return auth;
1279     }
1280 
1281     /**
1282      * Returns the raw user-information component of this URI.
1283      *
1284      * &lt;p&gt; The user-information component of a URI, if defined, only contains
1285      * characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and
1286      * &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;
1287      *
1288      * @return  The raw user-information component of this URI,
1289      *          or {@code null} if the user information is undefined
1290      */
1291     public String getRawUserInfo() {
1292         return userInfo;
1293     }
1294 
1295     /**
1296      * Returns the decoded user-information component of this URI.
1297      *
1298      * &lt;p&gt; The string returned by this method is equal to that returned by the
1299      * {@link #getRawUserInfo() getRawUserInfo} method except that all
1300      * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
1301      *
1302      * @return  The decoded user-information component of this URI,
1303      *          or {@code null} if the user information is undefined
1304      */
1305     public String getUserInfo() {
1306         String user = decodedUserInfo;
1307         if ((user == null) &amp;&amp; (userInfo != null)) {
1308             decodedUserInfo = user = decode(userInfo);
1309         }
1310         return user;
1311     }
1312 
1313     /**
1314      * Returns the host component of this URI.
1315      *
1316      * &lt;p&gt; The host component of a URI, if defined, will have one of the
1317      * following forms: &lt;/p&gt;
1318      *
1319      * &lt;ul&gt;
1320      *
1321      *   &lt;li&gt;&lt;p&gt; A domain name consisting of one or more &lt;i&gt;labels&lt;/i&gt;
1322      *   separated by period characters ({@code &#39;.&#39;}), optionally followed by
1323      *   a period character.  Each label consists of &lt;i&gt;alphanum&lt;/i&gt; characters
1324      *   as well as hyphen characters ({@code &#39;-&#39;}), though hyphens never
1325      *   occur as the first or last characters in a label. The rightmost
1326      *   label of a domain name consisting of two or more labels, begins
1327      *   with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;/li&gt;
1328      *
1329      *   &lt;li&gt;&lt;p&gt; A dotted-quad IPv4 address of the form
1330      *   &lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +},
1331      *   where no &lt;i&gt;digit&lt;/i&gt; sequence is longer than three characters and no
1332      *   sequence has a value larger than 255. &lt;/p&gt;&lt;/li&gt;
1333      *
1334      *   &lt;li&gt;&lt;p&gt; An IPv6 address enclosed in square brackets ({@code &#39;[&#39;} and
1335      *   {@code &#39;]&#39;}) and consisting of hexadecimal digits, colon characters
1336      *   ({@code &#39;:&#39;}), and possibly an embedded IPv4 address.  The full
1337      *   syntax of IPv6 addresses is specified in &lt;a
1338      *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6
1339      *   Addressing Architecture&lt;/i&gt;&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
1340      *
1341      * &lt;/ul&gt;
1342      *
1343      * The host component of a URI cannot contain escaped octets, hence this
1344      * method does not perform any decoding.
1345      *
1346      * @return  The host component of this URI,
1347      *          or {@code null} if the host is undefined
1348      */
1349     public String getHost() {
1350         return host;
1351     }
1352 
1353     /**
1354      * Returns the port number of this URI.
1355      *
1356      * &lt;p&gt; The port component of a URI, if defined, is a non-negative
1357      * integer. &lt;/p&gt;
1358      *
1359      * @return  The port component of this URI,
1360      *          or {@code -1} if the port is undefined
1361      */
1362     public int getPort() {
1363         return port;
1364     }
1365 
1366     /**
1367      * Returns the raw path component of this URI.
1368      *
1369      * &lt;p&gt; The path component of a URI, if defined, only contains the slash
1370      * character ({@code &#39;/&#39;}), the commercial-at character ({@code &#39;@&#39;}),
1371      * and characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;,
1372      * and &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;
1373      *
1374      * @return  The path component of this URI,
1375      *          or {@code null} if the path is undefined
1376      */
1377     public String getRawPath() {
1378         return path;
1379     }
1380 
1381     /**
1382      * Returns the decoded path component of this URI.
1383      *
1384      * &lt;p&gt; The string returned by this method is equal to that returned by the
1385      * {@link #getRawPath() getRawPath} method except that all sequences of
1386      * escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
1387      *
1388      * @return  The decoded path component of this URI,
1389      *          or {@code null} if the path is undefined
1390      */
1391     public String getPath() {
1392         String decoded = decodedPath;
1393         if ((decoded == null) &amp;&amp; (path != null)) {
1394             decodedPath = decoded = decode(path);
1395         }
1396         return decoded;
1397     }
1398 
1399     /**
1400      * Returns the raw query component of this URI.
1401      *
1402      * &lt;p&gt; The query component of a URI, if defined, only contains legal URI
1403      * characters. &lt;/p&gt;
1404      *
1405      * @return  The raw query component of this URI,
1406      *          or {@code null} if the query is undefined
1407      */
1408     public String getRawQuery() {
1409         return query;
1410     }
1411 
1412     /**
1413      * Returns the decoded query component of this URI.
1414      *
1415      * &lt;p&gt; The string returned by this method is equal to that returned by the
1416      * {@link #getRawQuery() getRawQuery} method except that all sequences of
1417      * escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
1418      *
1419      * @return  The decoded query component of this URI,
1420      *          or {@code null} if the query is undefined
1421      */
1422     public String getQuery() {
1423         String decoded = decodedQuery;
1424         if ((decoded == null) &amp;&amp; (query != null)) {
1425             decodedQuery = decoded = decode(query, false);
1426         }
1427         return decoded;
1428     }
1429 
1430     /**
1431      * Returns the raw fragment component of this URI.
1432      *
1433      * &lt;p&gt; The fragment component of a URI, if defined, only contains legal URI
1434      * characters. &lt;/p&gt;
1435      *
1436      * @return  The raw fragment component of this URI,
1437      *          or {@code null} if the fragment is undefined
1438      */
1439     public String getRawFragment() {
1440         return fragment;
1441     }
1442 
1443     /**
1444      * Returns the decoded fragment component of this URI.
1445      *
1446      * &lt;p&gt; The string returned by this method is equal to that returned by the
1447      * {@link #getRawFragment() getRawFragment} method except that all
1448      * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
1449      *
1450      * @return  The decoded fragment component of this URI,
1451      *          or {@code null} if the fragment is undefined
1452      */
1453     public String getFragment() {
1454         String decoded = decodedFragment;
1455         if ((decoded == null) &amp;&amp; (fragment != null)) {
1456             decodedFragment = decoded = decode(fragment, false);
1457         }
1458         return decoded;
1459     }
1460 
1461 
1462     // -- Equality, comparison, hash code, toString, and serialization --
1463 
1464     /**
1465      * Tests this URI for equality with another object.
1466      *
1467      * &lt;p&gt; If the given object is not a URI then this method immediately
1468      * returns {@code false}.
1469      *
1470      * &lt;p&gt; For two URIs to be considered equal requires that either both are
1471      * opaque or both are hierarchical.  Their schemes must either both be
1472      * undefined or else be equal without regard to case. Their fragments
1473      * must either both be undefined or else be equal.
1474      *
1475      * &lt;p&gt; For two opaque URIs to be considered equal, their scheme-specific
1476      * parts must be equal.
1477      *
1478      * &lt;p&gt; For two hierarchical URIs to be considered equal, their paths must
1479      * be equal and their queries must either both be undefined or else be
1480      * equal.  Their authorities must either both be undefined, or both be
1481      * registry-based, or both be server-based.  If their authorities are
1482      * defined and are registry-based, then they must be equal.  If their
1483      * authorities are defined and are server-based, then their hosts must be
1484      * equal without regard to case, their port numbers must be equal, and
1485      * their user-information components must be equal.
1486      *
1487      * &lt;p&gt; When testing the user-information, path, query, fragment, authority,
1488      * or scheme-specific parts of two URIs for equality, the raw forms rather
1489      * than the encoded forms of these components are compared and the
1490      * hexadecimal digits of escaped octets are compared without regard to
1491      * case.
1492      *
1493      * &lt;p&gt; This method satisfies the general contract of the {@link
1494      * java.lang.Object#equals(Object) Object.equals} method. &lt;/p&gt;
1495      *
1496      * @param   ob   The object to which this object is to be compared
1497      *
1498      * @return  {@code true} if, and only if, the given object is a URI that
1499      *          is identical to this URI
1500      */
1501     public boolean equals(Object ob) {
1502         if (ob == this)
1503             return true;
1504         if (!(ob instanceof URI))
1505             return false;
1506         URI that = (URI)ob;
1507         if (this.isOpaque() != that.isOpaque()) return false;
1508         if (!equalIgnoringCase(this.scheme, that.scheme)) return false;
1509         if (!equal(this.fragment, that.fragment)) return false;
1510 
1511         // Opaque
1512         if (this.isOpaque())
1513             return equal(this.schemeSpecificPart, that.schemeSpecificPart);
1514 
1515         // Hierarchical
1516         if (!equal(this.path, that.path)) return false;
1517         if (!equal(this.query, that.query)) return false;
1518 
1519         // Authorities
1520         if (this.authority == that.authority) return true;
1521         if (this.host != null) {
1522             // Server-based
1523             if (!equal(this.userInfo, that.userInfo)) return false;
1524             if (!equalIgnoringCase(this.host, that.host)) return false;
1525             if (this.port != that.port) return false;
1526         } else if (this.authority != null) {
1527             // Registry-based
1528             if (!equal(this.authority, that.authority)) return false;
1529         } else if (this.authority != that.authority) {
1530             return false;
1531         }
1532 
1533         return true;
1534     }
1535 
1536     /**
1537      * Returns a hash-code value for this URI.  The hash code is based upon all
1538      * of the URI&#39;s components, and satisfies the general contract of the
1539      * {@link java.lang.Object#hashCode() Object.hashCode} method.
1540      *
1541      * @return  A hash-code value for this URI
1542      */
1543     public int hashCode() {
1544         int h = hash;
1545         if (h == 0) {
1546             h = hashIgnoringCase(0, scheme);
1547             h = hash(h, fragment);
1548             if (isOpaque()) {
1549                 h = hash(h, schemeSpecificPart);
1550             } else {
1551                 h = hash(h, path);
1552                 h = hash(h, query);
1553                 if (host != null) {
1554                     h = hash(h, userInfo);
1555                     h = hashIgnoringCase(h, host);
1556                     h += 1949 * port;
1557                 } else {
1558                     h = hash(h, authority);
1559                 }
1560             }
1561             if (h != 0) {
1562                 hash = h;
1563             }
1564         }
1565         return h;
1566     }
1567 
1568     /**
1569      * Compares this URI to another object, which must be a URI.
1570      *
1571      * &lt;p&gt; When comparing corresponding components of two URIs, if one
1572      * component is undefined but the other is defined then the first is
1573      * considered to be less than the second.  Unless otherwise noted, string
1574      * components are ordered according to their natural, case-sensitive
<a name="11" id="anc11"></a><span class="line-modified">1575      * ordering as defined by the {@link java.lang.String#compareTo(String)</span>
1576      * String.compareTo} method.  String components that are subject to
1577      * encoding are compared by comparing their raw forms rather than their
<a name="12" id="anc12"></a><span class="line-modified">1578      * encoded forms and the hexadecimal digits of escaped octets are compared</span>
<span class="line-added">1579      * without regard to case.</span>
1580      *
1581      * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
1582      *
1583      * &lt;ul&gt;
1584      *
1585      *   &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the
1586      *   ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;
1587      *
1588      *   &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
1589      *   with an identical scheme. &lt;/p&gt;&lt;/li&gt;
1590      *
1591      *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according
1592      *   to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;
1593      *
1594      *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific
1595      *   parts are ordered according to the ordering of their
1596      *   fragments. &lt;/p&gt;&lt;/li&gt;
1597      *
1598      *   &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
1599      *   according to the ordering of their authority components: &lt;/p&gt;
1600      *
1601      *   &lt;ul&gt;
1602      *
1603      *     &lt;li&gt;&lt;p&gt; If both authority components are server-based then the URIs
1604      *     are ordered according to their user-information components; if these
1605      *     components are identical then the URIs are ordered according to the
1606      *     ordering of their hosts, without regard to case; if the hosts are
1607      *     identical then the URIs are ordered according to the ordering of
1608      *     their ports. &lt;/p&gt;&lt;/li&gt;
1609      *
1610      *     &lt;li&gt;&lt;p&gt; If one or both authority components are registry-based then
1611      *     the URIs are ordered according to the ordering of their authority
1612      *     components. &lt;/p&gt;&lt;/li&gt;
1613      *
1614      *   &lt;/ul&gt;&lt;/li&gt;
1615      *
1616      *   &lt;li&gt;&lt;p&gt; Finally, two hierarchical URIs with identical schemes and
1617      *   authority components are ordered according to the ordering of their
1618      *   paths; if their paths are identical then they are ordered according to
1619      *   the ordering of their queries; if the queries are identical then they
1620      *   are ordered according to the order of their fragments. &lt;/p&gt;&lt;/li&gt;
1621      *
1622      * &lt;/ul&gt;
1623      *
1624      * &lt;p&gt; This method satisfies the general contract of the {@link
1625      * java.lang.Comparable#compareTo(Object) Comparable.compareTo}
1626      * method. &lt;/p&gt;
1627      *
1628      * @param   that
1629      *          The object to which this URI is to be compared
1630      *
1631      * @return  A negative integer, zero, or a positive integer as this URI is
1632      *          less than, equal to, or greater than the given URI
1633      *
1634      * @throws  ClassCastException
1635      *          If the given object is not a URI
1636      */
1637     public int compareTo(URI that) {
1638         int c;
1639 
1640         if ((c = compareIgnoringCase(this.scheme, that.scheme)) != 0)
1641             return c;
1642 
1643         if (this.isOpaque()) {
1644             if (that.isOpaque()) {
1645                 // Both opaque
1646                 if ((c = compare(this.schemeSpecificPart,
1647                                  that.schemeSpecificPart)) != 0)
1648                     return c;
1649                 return compare(this.fragment, that.fragment);
1650             }
1651             return +1;                  // Opaque &gt; hierarchical
1652         } else if (that.isOpaque()) {
1653             return -1;                  // Hierarchical &lt; opaque
1654         }
1655 
1656         // Hierarchical
1657         if ((this.host != null) &amp;&amp; (that.host != null)) {
1658             // Both server-based
1659             if ((c = compare(this.userInfo, that.userInfo)) != 0)
1660                 return c;
1661             if ((c = compareIgnoringCase(this.host, that.host)) != 0)
1662                 return c;
1663             if ((c = this.port - that.port) != 0)
1664                 return c;
1665         } else {
1666             // If one or both authorities are registry-based then we simply
1667             // compare them in the usual, case-sensitive way.  If one is
1668             // registry-based and one is server-based then the strings are
1669             // guaranteed to be unequal, hence the comparison will never return
1670             // zero and the compareTo and equals methods will remain
1671             // consistent.
1672             if ((c = compare(this.authority, that.authority)) != 0) return c;
1673         }
1674 
1675         if ((c = compare(this.path, that.path)) != 0) return c;
1676         if ((c = compare(this.query, that.query)) != 0) return c;
1677         return compare(this.fragment, that.fragment);
1678     }
1679 
1680     /**
1681      * Returns the content of this URI as a string.
1682      *
1683      * &lt;p&gt; If this URI was created by invoking one of the constructors in this
1684      * class then a string equivalent to the original input string, or to the
1685      * string computed from the originally-given components, as appropriate, is
1686      * returned.  Otherwise this URI was created by normalization, resolution,
1687      * or relativization, and so a string is constructed from this URI&#39;s
1688      * components according to the rules specified in &lt;a
1689      * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
1690      * section&amp;nbsp;5.2, step&amp;nbsp;7. &lt;/p&gt;
1691      *
1692      * @return  The string form of this URI
1693      */
1694     public String toString() {
1695         String s = string;
1696         if (s == null) {
1697             s = defineString();
1698         }
1699         return s;
1700     }
1701 
1702     private String defineString() {
1703         String s = string;
1704         if (s != null) {
1705             return s;
1706         }
1707 
1708         StringBuilder sb = new StringBuilder();
1709         if (scheme != null) {
1710             sb.append(scheme);
1711             sb.append(&#39;:&#39;);
1712         }
1713         if (isOpaque()) {
1714             sb.append(schemeSpecificPart);
1715         } else {
1716             if (host != null) {
1717                 sb.append(&quot;//&quot;);
1718                 if (userInfo != null) {
1719                     sb.append(userInfo);
1720                     sb.append(&#39;@&#39;);
1721                 }
1722                 boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)
1723                         &amp;&amp; !host.startsWith(&quot;[&quot;)
1724                         &amp;&amp; !host.endsWith(&quot;]&quot;));
1725                 if (needBrackets) sb.append(&#39;[&#39;);
1726                 sb.append(host);
1727                 if (needBrackets) sb.append(&#39;]&#39;);
1728                 if (port != -1) {
1729                     sb.append(&#39;:&#39;);
1730                     sb.append(port);
1731                 }
1732             } else if (authority != null) {
1733                 sb.append(&quot;//&quot;);
1734                 sb.append(authority);
1735             }
1736             if (path != null)
1737                 sb.append(path);
1738             if (query != null) {
1739                 sb.append(&#39;?&#39;);
1740                 sb.append(query);
1741             }
1742         }
1743         if (fragment != null) {
1744             sb.append(&#39;#&#39;);
1745             sb.append(fragment);
1746         }
1747         return string = sb.toString();
1748     }
1749 
1750     /**
1751      * Returns the content of this URI as a US-ASCII string.
1752      *
1753      * &lt;p&gt; If this URI does not contain any characters in the &lt;i&gt;other&lt;/i&gt;
1754      * category then an invocation of this method will return the same value as
1755      * an invocation of the {@link #toString() toString} method.  Otherwise
1756      * this method works as if by invoking that method and then &lt;a
1757      * href=&quot;#encode&quot;&gt;encoding&lt;/a&gt; the result.  &lt;/p&gt;
1758      *
1759      * @return  The string form of this URI, encoded as needed
1760      *          so that it only contains characters in the US-ASCII
1761      *          charset
1762      */
1763     public String toASCIIString() {
1764         return encode(toString());
1765     }
1766 
1767 
1768     // -- Serialization support --
1769 
1770     /**
1771      * Saves the content of this URI to the given serial stream.
1772      *
1773      * &lt;p&gt; The only serializable field of a URI instance is its {@code string}
1774      * field.  That field is given a value, if it does not have one already,
1775      * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}
1776      * method of the given object-output stream is invoked. &lt;/p&gt;
1777      *
1778      * @param  os  The object-output stream to which this object
1779      *             is to be written
1780      */
<a name="13" id="anc13"></a><span class="line-added">1781     @java.io.Serial</span>
1782     private void writeObject(ObjectOutputStream os)
1783         throws IOException
1784     {
1785         defineString();
1786         os.defaultWriteObject();        // Writes the string field only
1787     }
1788 
1789     /**
1790      * Reconstitutes a URI from the given serial stream.
1791      *
1792      * &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
1793      * invoked to read the value of the {@code string} field.  The result is
1794      * then parsed in the usual way.
1795      *
1796      * @param  is  The object-input stream from which this object
1797      *             is being read
1798      */
<a name="14" id="anc14"></a><span class="line-added">1799     @java.io.Serial</span>
1800     private void readObject(ObjectInputStream is)
1801         throws ClassNotFoundException, IOException
1802     {
1803         port = -1;                      // Argh
1804         is.defaultReadObject();
1805         try {
1806             new Parser(string).parse(false);
1807         } catch (URISyntaxException x) {
1808             IOException y = new InvalidObjectException(&quot;Invalid URI&quot;);
1809             y.initCause(x);
1810             throw y;
1811         }
1812     }
1813 
1814 
1815     // -- End of public methods --
1816 
1817 
1818     // -- Utility methods for string-field comparison and hashing --
1819 
1820     // These methods return appropriate values for null string arguments,
1821     // thereby simplifying the equals, hashCode, and compareTo methods.
1822     //
1823     // The case-ignoring methods should only be applied to strings whose
1824     // characters are all known to be US-ASCII.  Because of this restriction,
1825     // these methods are faster than the similar methods in the String class.
1826 
1827     // US-ASCII only
1828     private static int toLower(char c) {
1829         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
1830             return c + (&#39;a&#39; - &#39;A&#39;);
1831         return c;
1832     }
1833 
1834     // US-ASCII only
1835     private static int toUpper(char c) {
1836         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;))
1837             return c - (&#39;a&#39; - &#39;A&#39;);
1838         return c;
1839     }
1840 
1841     private static boolean equal(String s, String t) {
<a name="15" id="anc15"></a><span class="line-modified">1842         boolean testForEquality = true;</span>
<span class="line-modified">1843         int result = percentNormalizedComparison(s, t, testForEquality);</span>
<span class="line-modified">1844         return result == 0;</span>


























1845     }
1846 
1847     // US-ASCII only
1848     private static boolean equalIgnoringCase(String s, String t) {
1849         if (s == t) return true;
1850         if ((s != null) &amp;&amp; (t != null)) {
1851             int n = s.length();
1852             if (t.length() != n)
1853                 return false;
1854             for (int i = 0; i &lt; n; i++) {
1855                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))
1856                     return false;
1857             }
1858             return true;
1859         }
1860         return false;
1861     }
1862 
1863     private static int hash(int hash, String s) {
1864         if (s == null) return hash;
1865         return s.indexOf(&#39;%&#39;) &lt; 0 ? hash * 127 + s.hashCode()
1866                                   : normalizedHash(hash, s);
1867     }
1868 
1869 
1870     private static int normalizedHash(int hash, String s) {
1871         int h = 0;
1872         for (int index = 0; index &lt; s.length(); index++) {
1873             char ch = s.charAt(index);
1874             h = 31 * h + ch;
1875             if (ch == &#39;%&#39;) {
1876                 /*
1877                  * Process the next two encoded characters
1878                  */
1879                 for (int i = index + 1; i &lt; index + 3; i++)
1880                     h = 31 * h + toUpper(s.charAt(i));
1881                 index += 2;
1882             }
1883         }
1884         return hash * 127 + h;
1885     }
1886 
1887     // US-ASCII only
1888     private static int hashIgnoringCase(int hash, String s) {
1889         if (s == null) return hash;
1890         int h = hash;
1891         int n = s.length();
1892         for (int i = 0; i &lt; n; i++)
1893             h = 31 * h + toLower(s.charAt(i));
1894         return h;
1895     }
1896 
1897     private static int compare(String s, String t) {
<a name="16" id="anc16"></a><span class="line-added">1898         boolean testForEquality = false;</span>
<span class="line-added">1899         int result = percentNormalizedComparison(s, t, testForEquality);</span>
<span class="line-added">1900         return result;</span>
<span class="line-added">1901     }</span>
<span class="line-added">1902 </span>
<span class="line-added">1903     // The percentNormalizedComparison method does not verify two</span>
<span class="line-added">1904     // characters that follow the % sign are hexadecimal digits.</span>
<span class="line-added">1905     // Reason being:</span>
<span class="line-added">1906     // 1) percentNormalizedComparison method is not called with</span>
<span class="line-added">1907     // &#39;decoded&#39; strings</span>
<span class="line-added">1908     // 2) The only place where a percent can be followed by anything</span>
<span class="line-added">1909     // other than hexadecimal digits is in the authority component</span>
<span class="line-added">1910     // (for a IPv6 scope) and the whole authority component is case</span>
<span class="line-added">1911     // insensitive.</span>
<span class="line-added">1912     private static int percentNormalizedComparison(String s, String t,</span>
<span class="line-added">1913                                                    boolean testForEquality) {</span>
<span class="line-added">1914 </span>
1915         if (s == t) return 0;
1916         if (s != null) {
<a name="17" id="anc17"></a><span class="line-modified">1917             if (t != null) {</span>
<span class="line-modified">1918                 if (s.indexOf(&#39;%&#39;) &lt; 0) {</span>
<span class="line-modified">1919                     return s.compareTo(t);</span>
<span class="line-added">1920                 }</span>
<span class="line-added">1921                 int sn = s.length();</span>
<span class="line-added">1922                 int tn = t.length();</span>
<span class="line-added">1923                 if ((sn != tn) &amp;&amp; testForEquality)</span>
<span class="line-added">1924                     return sn - tn;</span>
<span class="line-added">1925                 int val = 0;</span>
<span class="line-added">1926                 int n = sn &lt; tn ? sn : tn;</span>
<span class="line-added">1927                 for (int i = 0; i &lt; n; ) {</span>
<span class="line-added">1928                     char c = s.charAt(i);</span>
<span class="line-added">1929                     char d = t.charAt(i);</span>
<span class="line-added">1930                     val = c - d;</span>
<span class="line-added">1931                     if (c != &#39;%&#39;) {</span>
<span class="line-added">1932                         if (val != 0)</span>
<span class="line-added">1933                             return val;</span>
<span class="line-added">1934                         i++;</span>
<span class="line-added">1935                         continue;</span>
<span class="line-added">1936                     }</span>
<span class="line-added">1937                     if (d != &#39;%&#39;) {</span>
<span class="line-added">1938                         if (val != 0)</span>
<span class="line-added">1939                             return val;</span>
<span class="line-added">1940                     }</span>
<span class="line-added">1941                     i++;</span>
<span class="line-added">1942                     val = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="line-added">1943                     if (val != 0)</span>
<span class="line-added">1944                         return val;</span>
<span class="line-added">1945                     i++;</span>
<span class="line-added">1946                     val = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="line-added">1947                     if (val != 0)</span>
<span class="line-added">1948                         return val;</span>
<span class="line-added">1949                     i++;</span>
<span class="line-added">1950                 }</span>
<span class="line-added">1951                 return sn - tn;</span>
<span class="line-added">1952             } else</span>
1953                 return +1;
1954         } else {
1955             return -1;
1956         }
1957     }
1958 
1959     // US-ASCII only
1960     private static int compareIgnoringCase(String s, String t) {
1961         if (s == t) return 0;
1962         if (s != null) {
1963             if (t != null) {
1964                 int sn = s.length();
1965                 int tn = t.length();
1966                 int n = sn &lt; tn ? sn : tn;
1967                 for (int i = 0; i &lt; n; i++) {
1968                     int c = toLower(s.charAt(i)) - toLower(t.charAt(i));
1969                     if (c != 0)
1970                         return c;
1971                 }
1972                 return sn - tn;
1973             }
1974             return +1;
1975         } else {
1976             return -1;
1977         }
1978     }
1979 
1980 
1981     // -- String construction --
1982 
1983     // If a scheme is given then the path, if given, must be absolute
1984     //
1985     private static void checkPath(String s, String scheme, String path)
1986         throws URISyntaxException
1987     {
1988         if (scheme != null) {
1989             if (path != null &amp;&amp; !path.isEmpty() &amp;&amp; path.charAt(0) != &#39;/&#39;)
1990                 throw new URISyntaxException(s, &quot;Relative path in absolute URI&quot;);
1991         }
1992     }
1993 
1994     private void appendAuthority(StringBuilder sb,
1995                                  String authority,
1996                                  String userInfo,
1997                                  String host,
1998                                  int port)
1999     {
2000         if (host != null) {
2001             sb.append(&quot;//&quot;);
2002             if (userInfo != null) {
2003                 sb.append(quote(userInfo, L_USERINFO, H_USERINFO));
2004                 sb.append(&#39;@&#39;);
2005             }
2006             boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)
2007                                     &amp;&amp; !host.startsWith(&quot;[&quot;)
2008                                     &amp;&amp; !host.endsWith(&quot;]&quot;));
2009             if (needBrackets) sb.append(&#39;[&#39;);
2010             sb.append(host);
2011             if (needBrackets) sb.append(&#39;]&#39;);
2012             if (port != -1) {
2013                 sb.append(&#39;:&#39;);
2014                 sb.append(port);
2015             }
2016         } else if (authority != null) {
2017             sb.append(&quot;//&quot;);
2018             if (authority.startsWith(&quot;[&quot;)) {
2019                 // authority should (but may not) contain an embedded IPv6 address
2020                 int end = authority.indexOf(&#39;]&#39;);
2021                 String doquote = authority, dontquote = &quot;&quot;;
2022                 if (end != -1 &amp;&amp; authority.indexOf(&#39;:&#39;) != -1) {
2023                     // the authority contains an IPv6 address
2024                     if (end == authority.length()) {
2025                         dontquote = authority;
2026                         doquote = &quot;&quot;;
2027                     } else {
2028                         dontquote = authority.substring(0 , end + 1);
2029                         doquote = authority.substring(end + 1);
2030                     }
2031                 }
2032                 sb.append(dontquote);
2033                 sb.append(quote(doquote,
2034                             L_REG_NAME | L_SERVER,
2035                             H_REG_NAME | H_SERVER));
2036             } else {
2037                 sb.append(quote(authority,
2038                             L_REG_NAME | L_SERVER,
2039                             H_REG_NAME | H_SERVER));
2040             }
2041         }
2042     }
2043 
2044     private void appendSchemeSpecificPart(StringBuilder sb,
2045                                           String opaquePart,
2046                                           String authority,
2047                                           String userInfo,
2048                                           String host,
2049                                           int port,
2050                                           String path,
2051                                           String query)
2052     {
2053         if (opaquePart != null) {
2054             /* check if SSP begins with an IPv6 address
2055              * because we must not quote a literal IPv6 address
2056              */
2057             if (opaquePart.startsWith(&quot;//[&quot;)) {
2058                 int end =  opaquePart.indexOf(&#39;]&#39;);
2059                 if (end != -1 &amp;&amp; opaquePart.indexOf(&#39;:&#39;)!=-1) {
2060                     String doquote, dontquote;
2061                     if (end == opaquePart.length()) {
2062                         dontquote = opaquePart;
2063                         doquote = &quot;&quot;;
2064                     } else {
2065                         dontquote = opaquePart.substring(0,end+1);
2066                         doquote = opaquePart.substring(end+1);
2067                     }
2068                     sb.append (dontquote);
2069                     sb.append(quote(doquote, L_URIC, H_URIC));
2070                 }
2071             } else {
2072                 sb.append(quote(opaquePart, L_URIC, H_URIC));
2073             }
2074         } else {
2075             appendAuthority(sb, authority, userInfo, host, port);
2076             if (path != null)
2077                 sb.append(quote(path, L_PATH, H_PATH));
2078             if (query != null) {
2079                 sb.append(&#39;?&#39;);
2080                 sb.append(quote(query, L_URIC, H_URIC));
2081             }
2082         }
2083     }
2084 
2085     private void appendFragment(StringBuilder sb, String fragment) {
2086         if (fragment != null) {
2087             sb.append(&#39;#&#39;);
2088             sb.append(quote(fragment, L_URIC, H_URIC));
2089         }
2090     }
2091 
2092     private String toString(String scheme,
2093                             String opaquePart,
2094                             String authority,
2095                             String userInfo,
2096                             String host,
2097                             int port,
2098                             String path,
2099                             String query,
2100                             String fragment)
2101     {
2102         StringBuilder sb = new StringBuilder();
2103         if (scheme != null) {
2104             sb.append(scheme);
2105             sb.append(&#39;:&#39;);
2106         }
2107         appendSchemeSpecificPart(sb, opaquePart,
2108                                  authority, userInfo, host, port,
2109                                  path, query);
2110         appendFragment(sb, fragment);
2111         return sb.toString();
2112     }
2113 
2114     // -- Normalization, resolution, and relativization --
2115 
2116     // RFC2396 5.2 (6)
2117     private static String resolvePath(String base, String child,
2118                                       boolean absolute)
2119     {
2120         int i = base.lastIndexOf(&#39;/&#39;);
2121         int cn = child.length();
2122         String path = &quot;&quot;;
2123 
2124         if (cn == 0) {
2125             // 5.2 (6a)
2126             if (i &gt;= 0)
2127                 path = base.substring(0, i + 1);
2128         } else {
2129             StringBuilder sb = new StringBuilder(base.length() + cn);
2130             // 5.2 (6a)
2131             if (i &gt;= 0)
2132                 sb.append(base, 0, i + 1);
2133             // 5.2 (6b)
2134             sb.append(child);
2135             path = sb.toString();
2136         }
2137 
2138         // 5.2 (6c-f)
2139         String np = normalize(path);
2140 
2141         // 5.2 (6g): If the result is absolute but the path begins with &quot;../&quot;,
2142         // then we simply leave the path as-is
2143 
2144         return np;
2145     }
2146 
2147     // RFC2396 5.2
2148     private static URI resolve(URI base, URI child) {
2149         // check if child if opaque first so that NPE is thrown
2150         // if child is null.
2151         if (child.isOpaque() || base.isOpaque())
2152             return child;
2153 
2154         // 5.2 (2): Reference to current document (lone fragment)
2155         if ((child.scheme == null) &amp;&amp; (child.authority == null)
2156             &amp;&amp; child.path.isEmpty() &amp;&amp; (child.fragment != null)
2157             &amp;&amp; (child.query == null)) {
2158             if ((base.fragment != null)
2159                 &amp;&amp; child.fragment.equals(base.fragment)) {
2160                 return base;
2161             }
2162             URI ru = new URI();
2163             ru.scheme = base.scheme;
2164             ru.authority = base.authority;
2165             ru.userInfo = base.userInfo;
2166             ru.host = base.host;
2167             ru.port = base.port;
2168             ru.path = base.path;
2169             ru.fragment = child.fragment;
2170             ru.query = base.query;
2171             return ru;
2172         }
2173 
2174         // 5.2 (3): Child is absolute
2175         if (child.scheme != null)
2176             return child;
2177 
2178         URI ru = new URI();             // Resolved URI
2179         ru.scheme = base.scheme;
2180         ru.query = child.query;
2181         ru.fragment = child.fragment;
2182 
2183         // 5.2 (4): Authority
2184         if (child.authority == null) {
2185             ru.authority = base.authority;
2186             ru.host = base.host;
2187             ru.userInfo = base.userInfo;
2188             ru.port = base.port;
2189 
2190             String cp = (child.path == null) ? &quot;&quot; : child.path;
2191             if (!cp.isEmpty() &amp;&amp; cp.charAt(0) == &#39;/&#39;) {
2192                 // 5.2 (5): Child path is absolute
2193                 ru.path = child.path;
2194             } else {
2195                 // 5.2 (6): Resolve relative path
2196                 ru.path = resolvePath(base.path, cp, base.isAbsolute());
2197             }
2198         } else {
2199             ru.authority = child.authority;
2200             ru.host = child.host;
2201             ru.userInfo = child.userInfo;
2202             ru.host = child.host;
2203             ru.port = child.port;
2204             ru.path = child.path;
2205         }
2206 
2207         // 5.2 (7): Recombine (nothing to do here)
2208         return ru;
2209     }
2210 
2211     // If the given URI&#39;s path is normal then return the URI;
2212     // o.w., return a new URI containing the normalized path.
2213     //
2214     private static URI normalize(URI u) {
2215         if (u.isOpaque() || u.path == null || u.path.isEmpty())
2216             return u;
2217 
2218         String np = normalize(u.path);
2219         if (np == u.path)
2220             return u;
2221 
2222         URI v = new URI();
2223         v.scheme = u.scheme;
2224         v.fragment = u.fragment;
2225         v.authority = u.authority;
2226         v.userInfo = u.userInfo;
2227         v.host = u.host;
2228         v.port = u.port;
2229         v.path = np;
2230         v.query = u.query;
2231         return v;
2232     }
2233 
2234     // If both URIs are hierarchical, their scheme and authority components are
2235     // identical, and the base path is a prefix of the child&#39;s path, then
2236     // return a relative URI that, when resolved against the base, yields the
2237     // child; otherwise, return the child.
2238     //
2239     private static URI relativize(URI base, URI child) {
2240         // check if child if opaque first so that NPE is thrown
2241         // if child is null.
2242         if (child.isOpaque() || base.isOpaque())
2243             return child;
2244         if (!equalIgnoringCase(base.scheme, child.scheme)
2245             || !equal(base.authority, child.authority))
2246             return child;
2247 
2248         String bp = normalize(base.path);
2249         String cp = normalize(child.path);
2250         if (!bp.equals(cp)) {
2251             if (!bp.endsWith(&quot;/&quot;))
2252                 bp = bp + &quot;/&quot;;
2253             if (!cp.startsWith(bp))
2254                 return child;
2255         }
2256 
2257         URI v = new URI();
2258         v.path = cp.substring(bp.length());
2259         v.query = child.query;
2260         v.fragment = child.fragment;
2261         return v;
2262     }
2263 
2264 
2265 
2266     // -- Path normalization --
2267 
2268     // The following algorithm for path normalization avoids the creation of a
2269     // string object for each segment, as well as the use of a string buffer to
2270     // compute the final result, by using a single char array and editing it in
2271     // place.  The array is first split into segments, replacing each slash
2272     // with &#39;\0&#39; and creating a segment-index array, each element of which is
2273     // the index of the first char in the corresponding segment.  We then walk
2274     // through both arrays, removing &quot;.&quot;, &quot;..&quot;, and other segments as necessary
2275     // by setting their entries in the index array to -1.  Finally, the two
2276     // arrays are used to rejoin the segments and compute the final result.
2277     //
2278     // This code is based upon src/solaris/native/java/io/canonicalize_md.c
2279 
2280 
2281     // Check the given path to see if it might need normalization.  A path
2282     // might need normalization if it contains duplicate slashes, a &quot;.&quot;
2283     // segment, or a &quot;..&quot; segment.  Return -1 if no further normalization is
2284     // possible, otherwise return the number of segments found.
2285     //
2286     // This method takes a string argument rather than a char array so that
2287     // this test can be performed without invoking path.toCharArray().
2288     //
2289     private static int needsNormalization(String path) {
2290         boolean normal = true;
2291         int ns = 0;                     // Number of segments
2292         int end = path.length() - 1;    // Index of last char in path
2293         int p = 0;                      // Index of next char in path
2294 
2295         // Skip initial slashes
2296         while (p &lt;= end) {
2297             if (path.charAt(p) != &#39;/&#39;) break;
2298             p++;
2299         }
2300         if (p &gt; 1) normal = false;
2301 
2302         // Scan segments
2303         while (p &lt;= end) {
2304 
2305             // Looking at &quot;.&quot; or &quot;..&quot; ?
2306             if ((path.charAt(p) == &#39;.&#39;)
2307                 &amp;&amp; ((p == end)
2308                     || ((path.charAt(p + 1) == &#39;/&#39;)
2309                         || ((path.charAt(p + 1) == &#39;.&#39;)
2310                             &amp;&amp; ((p + 1 == end)
2311                                 || (path.charAt(p + 2) == &#39;/&#39;)))))) {
2312                 normal = false;
2313             }
2314             ns++;
2315 
2316             // Find beginning of next segment
2317             while (p &lt;= end) {
2318                 if (path.charAt(p++) != &#39;/&#39;)
2319                     continue;
2320 
2321                 // Skip redundant slashes
2322                 while (p &lt;= end) {
2323                     if (path.charAt(p) != &#39;/&#39;) break;
2324                     normal = false;
2325                     p++;
2326                 }
2327 
2328                 break;
2329             }
2330         }
2331 
2332         return normal ? -1 : ns;
2333     }
2334 
2335 
2336     // Split the given path into segments, replacing slashes with nulls and
2337     // filling in the given segment-index array.
2338     //
2339     // Preconditions:
2340     //   segs.length == Number of segments in path
2341     //
2342     // Postconditions:
2343     //   All slashes in path replaced by &#39;\0&#39;
2344     //   segs[i] == Index of first char in segment i (0 &lt;= i &lt; segs.length)
2345     //
2346     private static void split(char[] path, int[] segs) {
2347         int end = path.length - 1;      // Index of last char in path
2348         int p = 0;                      // Index of next char in path
2349         int i = 0;                      // Index of current segment
2350 
2351         // Skip initial slashes
2352         while (p &lt;= end) {
2353             if (path[p] != &#39;/&#39;) break;
2354             path[p] = &#39;\0&#39;;
2355             p++;
2356         }
2357 
2358         while (p &lt;= end) {
2359 
2360             // Note start of segment
2361             segs[i++] = p++;
2362 
2363             // Find beginning of next segment
2364             while (p &lt;= end) {
2365                 if (path[p++] != &#39;/&#39;)
2366                     continue;
2367                 path[p - 1] = &#39;\0&#39;;
2368 
2369                 // Skip redundant slashes
2370                 while (p &lt;= end) {
2371                     if (path[p] != &#39;/&#39;) break;
2372                     path[p++] = &#39;\0&#39;;
2373                 }
2374                 break;
2375             }
2376         }
2377 
2378         if (i != segs.length)
2379             throw new InternalError();  // ASSERT
2380     }
2381 
2382 
2383     // Join the segments in the given path according to the given segment-index
2384     // array, ignoring those segments whose index entries have been set to -1,
2385     // and inserting slashes as needed.  Return the length of the resulting
2386     // path.
2387     //
2388     // Preconditions:
2389     //   segs[i] == -1 implies segment i is to be ignored
2390     //   path computed by split, as above, with &#39;\0&#39; having replaced &#39;/&#39;
2391     //
2392     // Postconditions:
2393     //   path[0] .. path[return value] == Resulting path
2394     //
2395     private static int join(char[] path, int[] segs) {
2396         int ns = segs.length;           // Number of segments
2397         int end = path.length - 1;      // Index of last char in path
2398         int p = 0;                      // Index of next path char to write
2399 
2400         if (path[p] == &#39;\0&#39;) {
2401             // Restore initial slash for absolute paths
2402             path[p++] = &#39;/&#39;;
2403         }
2404 
2405         for (int i = 0; i &lt; ns; i++) {
2406             int q = segs[i];            // Current segment
2407             if (q == -1)
2408                 // Ignore this segment
2409                 continue;
2410 
2411             if (p == q) {
2412                 // We&#39;re already at this segment, so just skip to its end
2413                 while ((p &lt;= end) &amp;&amp; (path[p] != &#39;\0&#39;))
2414                     p++;
2415                 if (p &lt;= end) {
2416                     // Preserve trailing slash
2417                     path[p++] = &#39;/&#39;;
2418                 }
2419             } else if (p &lt; q) {
2420                 // Copy q down to p
2421                 while ((q &lt;= end) &amp;&amp; (path[q] != &#39;\0&#39;))
2422                     path[p++] = path[q++];
2423                 if (q &lt;= end) {
2424                     // Preserve trailing slash
2425                     path[p++] = &#39;/&#39;;
2426                 }
2427             } else
2428                 throw new InternalError(); // ASSERT false
2429         }
2430 
2431         return p;
2432     }
2433 
2434 
2435     // Remove &quot;.&quot; segments from the given path, and remove segment pairs
2436     // consisting of a non-&quot;..&quot; segment followed by a &quot;..&quot; segment.
2437     //
2438     private static void removeDots(char[] path, int[] segs) {
2439         int ns = segs.length;
2440         int end = path.length - 1;
2441 
2442         for (int i = 0; i &lt; ns; i++) {
2443             int dots = 0;               // Number of dots found (0, 1, or 2)
2444 
2445             // Find next occurrence of &quot;.&quot; or &quot;..&quot;
2446             do {
2447                 int p = segs[i];
2448                 if (path[p] == &#39;.&#39;) {
2449                     if (p == end) {
2450                         dots = 1;
2451                         break;
2452                     } else if (path[p + 1] == &#39;\0&#39;) {
2453                         dots = 1;
2454                         break;
2455                     } else if ((path[p + 1] == &#39;.&#39;)
2456                                &amp;&amp; ((p + 1 == end)
2457                                    || (path[p + 2] == &#39;\0&#39;))) {
2458                         dots = 2;
2459                         break;
2460                     }
2461                 }
2462                 i++;
2463             } while (i &lt; ns);
2464             if ((i &gt; ns) || (dots == 0))
2465                 break;
2466 
2467             if (dots == 1) {
2468                 // Remove this occurrence of &quot;.&quot;
2469                 segs[i] = -1;
2470             } else {
2471                 // If there is a preceding non-&quot;..&quot; segment, remove both that
2472                 // segment and this occurrence of &quot;..&quot;; otherwise, leave this
2473                 // &quot;..&quot; segment as-is.
2474                 int j;
2475                 for (j = i - 1; j &gt;= 0; j--) {
2476                     if (segs[j] != -1) break;
2477                 }
2478                 if (j &gt;= 0) {
2479                     int q = segs[j];
2480                     if (!((path[q] == &#39;.&#39;)
2481                           &amp;&amp; (path[q + 1] == &#39;.&#39;)
2482                           &amp;&amp; (path[q + 2] == &#39;\0&#39;))) {
2483                         segs[i] = -1;
2484                         segs[j] = -1;
2485                     }
2486                 }
2487             }
2488         }
2489     }
2490 
2491 
2492     // DEVIATION: If the normalized path is relative, and if the first
2493     // segment could be parsed as a scheme name, then prepend a &quot;.&quot; segment
2494     //
2495     private static void maybeAddLeadingDot(char[] path, int[] segs) {
2496 
2497         if (path[0] == &#39;\0&#39;)
2498             // The path is absolute
2499             return;
2500 
2501         int ns = segs.length;
2502         int f = 0;                      // Index of first segment
2503         while (f &lt; ns) {
2504             if (segs[f] &gt;= 0)
2505                 break;
2506             f++;
2507         }
2508         if ((f &gt;= ns) || (f == 0))
2509             // The path is empty, or else the original first segment survived,
2510             // in which case we already know that no leading &quot;.&quot; is needed
2511             return;
2512 
2513         int p = segs[f];
2514         while ((p &lt; path.length) &amp;&amp; (path[p] != &#39;:&#39;) &amp;&amp; (path[p] != &#39;\0&#39;)) p++;
2515         if (p &gt;= path.length || path[p] == &#39;\0&#39;)
2516             // No colon in first segment, so no &quot;.&quot; needed
2517             return;
2518 
2519         // At this point we know that the first segment is unused,
2520         // hence we can insert a &quot;.&quot; segment at that position
2521         path[0] = &#39;.&#39;;
2522         path[1] = &#39;\0&#39;;
2523         segs[0] = 0;
2524     }
2525 
2526 
2527     // Normalize the given path string.  A normal path string has no empty
2528     // segments (i.e., occurrences of &quot;//&quot;), no segments equal to &quot;.&quot;, and no
2529     // segments equal to &quot;..&quot; that are preceded by a segment not equal to &quot;..&quot;.
2530     // In contrast to Unix-style pathname normalization, for URI paths we
2531     // always retain trailing slashes.
2532     //
2533     private static String normalize(String ps) {
2534 
2535         // Does this path need normalization?
2536         int ns = needsNormalization(ps);        // Number of segments
2537         if (ns &lt; 0)
2538             // Nope -- just return it
2539             return ps;
2540 
2541         char[] path = ps.toCharArray();         // Path in char-array form
2542 
2543         // Split path into segments
2544         int[] segs = new int[ns];               // Segment-index array
2545         split(path, segs);
2546 
2547         // Remove dots
2548         removeDots(path, segs);
2549 
2550         // Prevent scheme-name confusion
2551         maybeAddLeadingDot(path, segs);
2552 
2553         // Join the remaining segments and return the result
2554         String s = new String(path, 0, join(path, segs));
2555         if (s.equals(ps)) {
2556             // string was already normalized
2557             return ps;
2558         }
2559         return s;
2560     }
2561 
2562 
2563 
2564     // -- Character classes for parsing --
2565 
2566     // RFC2396 precisely specifies which characters in the US-ASCII charset are
2567     // permissible in the various components of a URI reference.  We here
2568     // define a set of mask pairs to aid in enforcing these restrictions.  Each
2569     // mask pair consists of two longs, a low mask and a high mask.  Taken
2570     // together they represent a 128-bit mask, where bit i is set iff the
2571     // character with value i is permitted.
2572     //
2573     // This approach is more efficient than sequentially searching arrays of
2574     // permitted characters.  It could be made still more efficient by
2575     // precompiling the mask information so that a character&#39;s presence in a
2576     // given mask could be determined by a single table lookup.
2577 
2578     // To save startup time, we manually calculate the low-/highMask constants.
2579     // For reference, the following methods were used to calculate the values:
2580 
2581     // Compute the low-order mask for the characters in the given string
2582     //     private static long lowMask(String chars) {
2583     //        int n = chars.length();
2584     //        long m = 0;
2585     //        for (int i = 0; i &lt; n; i++) {
2586     //            char c = chars.charAt(i);
2587     //            if (c &lt; 64)
2588     //                m |= (1L &lt;&lt; c);
2589     //        }
2590     //        return m;
2591     //    }
2592 
2593     // Compute the high-order mask for the characters in the given string
2594     //    private static long highMask(String chars) {
2595     //        int n = chars.length();
2596     //        long m = 0;
2597     //        for (int i = 0; i &lt; n; i++) {
2598     //            char c = chars.charAt(i);
2599     //            if ((c &gt;= 64) &amp;&amp; (c &lt; 128))
2600     //                m |= (1L &lt;&lt; (c - 64));
2601     //        }
2602     //        return m;
2603     //    }
2604 
2605     // Compute a low-order mask for the characters
2606     // between first and last, inclusive
2607     //    private static long lowMask(char first, char last) {
2608     //        long m = 0;
2609     //        int f = Math.max(Math.min(first, 63), 0);
2610     //        int l = Math.max(Math.min(last, 63), 0);
2611     //        for (int i = f; i &lt;= l; i++)
2612     //            m |= 1L &lt;&lt; i;
2613     //        return m;
2614     //    }
2615 
2616     // Compute a high-order mask for the characters
2617     // between first and last, inclusive
2618     //    private static long highMask(char first, char last) {
2619     //        long m = 0;
2620     //        int f = Math.max(Math.min(first, 127), 64) - 64;
2621     //        int l = Math.max(Math.min(last, 127), 64) - 64;
2622     //        for (int i = f; i &lt;= l; i++)
2623     //            m |= 1L &lt;&lt; i;
2624     //        return m;
2625     //    }
2626 
2627     // Tell whether the given character is permitted by the given mask pair
2628     private static boolean match(char c, long lowMask, long highMask) {
2629         if (c == 0) // 0 doesn&#39;t have a slot in the mask. So, it never matches.
2630             return false;
2631         if (c &lt; 64)
2632             return ((1L &lt;&lt; c) &amp; lowMask) != 0;
2633         if (c &lt; 128)
2634             return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;
2635         return false;
2636     }
2637 
2638     // Character-class masks, in reverse order from RFC2396 because
2639     // initializers for static fields cannot make forward references.
2640 
2641     // digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
2642     //            &quot;8&quot; | &quot;9&quot;
2643     private static final long L_DIGIT = 0x3FF000000000000L; // lowMask(&#39;0&#39;, &#39;9&#39;);
2644     private static final long H_DIGIT = 0L;
2645 
2646     // upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |
2647     //            &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |
2648     //            &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;
2649     private static final long L_UPALPHA = 0L;
2650     private static final long H_UPALPHA = 0x7FFFFFEL; // highMask(&#39;A&#39;, &#39;Z&#39;);
2651 
2652     // lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |
2653     //            &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |
2654     //            &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;
2655     private static final long L_LOWALPHA = 0L;
2656     private static final long H_LOWALPHA = 0x7FFFFFE00000000L; // highMask(&#39;a&#39;, &#39;z&#39;);
2657 
2658     // alpha         = lowalpha | upalpha
2659     private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;
2660     private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;
2661 
2662     // alphanum      = alpha | digit
2663     private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;
2664     private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;
2665 
2666     // hex           = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |
2667     //                         &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
2668     private static final long L_HEX = L_DIGIT;
2669     private static final long H_HEX = 0x7E0000007EL; // highMask(&#39;A&#39;, &#39;F&#39;) | highMask(&#39;a&#39;, &#39;f&#39;);
2670 
2671     // mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;&#39;&quot; |
2672     //                 &quot;(&quot; | &quot;)&quot;
2673     private static final long L_MARK = 0x678200000000L; // lowMask(&quot;-_.!~*&#39;()&quot;);
2674     private static final long H_MARK = 0x4000000080000000L; // highMask(&quot;-_.!~*&#39;()&quot;);
2675 
2676     // unreserved    = alphanum | mark
2677     private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;
2678     private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;
2679 
2680     // reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |
2681     //                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;
2682     // Added per RFC2732: &quot;[&quot;, &quot;]&quot;
2683     private static final long L_RESERVED = 0xAC00985000000000L; // lowMask(&quot;;/?:@&amp;=+$,[]&quot;);
2684     private static final long H_RESERVED = 0x28000001L; // highMask(&quot;;/?:@&amp;=+$,[]&quot;);
2685 
2686     // The zero&#39;th bit is used to indicate that escape pairs and non-US-ASCII
2687     // characters are allowed; this is handled by the scanEscape method below.
2688     private static final long L_ESCAPED = 1L;
2689     private static final long H_ESCAPED = 0L;
2690 
2691     // uric          = reserved | unreserved | escaped
2692     private static final long L_URIC = L_RESERVED | L_UNRESERVED | L_ESCAPED;
2693     private static final long H_URIC = H_RESERVED | H_UNRESERVED | H_ESCAPED;
2694 
2695     // pchar         = unreserved | escaped |
2696     //                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
2697     private static final long L_PCHAR
2698         = L_UNRESERVED | L_ESCAPED | 0x2400185000000000L; // lowMask(&quot;:@&amp;=+$,&quot;);
2699     private static final long H_PCHAR
2700         = H_UNRESERVED | H_ESCAPED | 0x1L; // highMask(&quot;:@&amp;=+$,&quot;);
2701 
2702     // All valid path characters
2703     private static final long L_PATH = L_PCHAR | 0x800800000000000L; // lowMask(&quot;;/&quot;);
2704     private static final long H_PATH = H_PCHAR; // highMask(&quot;;/&quot;) == 0x0L;
2705 
2706     // Dash, for use in domainlabel and toplabel
2707     private static final long L_DASH = 0x200000000000L; // lowMask(&quot;-&quot;);
2708     private static final long H_DASH = 0x0L; // highMask(&quot;-&quot;);
2709 
2710     // Dot, for use in hostnames
2711     private static final long L_DOT = 0x400000000000L; // lowMask(&quot;.&quot;);
2712     private static final long H_DOT = 0x0L; // highMask(&quot;.&quot;);
2713 
2714     // userinfo      = *( unreserved | escaped |
2715     //                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )
2716     private static final long L_USERINFO
2717         = L_UNRESERVED | L_ESCAPED | 0x2C00185000000000L; // lowMask(&quot;;:&amp;=+$,&quot;);
2718     private static final long H_USERINFO
2719         = H_UNRESERVED | H_ESCAPED; // | highMask(&quot;;:&amp;=+$,&quot;) == 0L;
2720 
2721     // reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |
2722     //                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )
2723     private static final long L_REG_NAME
2724         = L_UNRESERVED | L_ESCAPED | 0x2C00185000000000L; // lowMask(&quot;$,;:@&amp;=+&quot;);
2725     private static final long H_REG_NAME
2726         = H_UNRESERVED | H_ESCAPED | 0x1L; // highMask(&quot;$,;:@&amp;=+&quot;);
2727 
2728     // All valid characters for server-based authorities
2729     private static final long L_SERVER
2730         = L_USERINFO | L_ALPHANUM | L_DASH | 0x400400000000000L; // lowMask(&quot;.:@[]&quot;);
2731     private static final long H_SERVER
2732         = H_USERINFO | H_ALPHANUM | H_DASH | 0x28000001L; // highMask(&quot;.:@[]&quot;);
2733 
2734     // Special case of server authority that represents an IPv6 address
2735     // In this case, a % does not signify an escape sequence
2736     private static final long L_SERVER_PERCENT
2737         = L_SERVER | 0x2000000000L; // lowMask(&quot;%&quot;);
2738     private static final long H_SERVER_PERCENT
2739         = H_SERVER; // | highMask(&quot;%&quot;) == 0L;
2740 
2741     // scheme        = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )
2742     private static final long L_SCHEME = L_ALPHA | L_DIGIT | 0x680000000000L; // lowMask(&quot;+-.&quot;);
2743     private static final long H_SCHEME = H_ALPHA | H_DIGIT; // | highMask(&quot;+-.&quot;) == 0L
2744 
2745     // scope_id = alpha | digit | &quot;_&quot; | &quot;.&quot;
2746     private static final long L_SCOPE_ID
2747         = L_ALPHANUM | 0x400000000000L; // lowMask(&quot;_.&quot;);
2748     private static final long H_SCOPE_ID
2749         = H_ALPHANUM | 0x80000000L; // highMask(&quot;_.&quot;);
2750 
2751     // -- Escaping and encoding --
2752 
2753     private static final char[] hexDigits = {
2754         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
2755         &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
2756     };
2757 
2758     private static void appendEscape(StringBuilder sb, byte b) {
2759         sb.append(&#39;%&#39;);
2760         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
2761         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
2762     }
2763 
2764     private static void appendEncoded(StringBuilder sb, char c) {
2765         ByteBuffer bb = null;
2766         try {
<a name="18" id="anc18"></a><span class="line-modified">2767             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
2768                 .encode(CharBuffer.wrap(&quot;&quot; + c));
2769         } catch (CharacterCodingException x) {
2770             assert false;
2771         }
2772         while (bb.hasRemaining()) {
2773             int b = bb.get() &amp; 0xff;
2774             if (b &gt;= 0x80)
2775                 appendEscape(sb, (byte)b);
2776             else
2777                 sb.append((char)b);
2778         }
2779     }
2780 
2781     // Quote any characters in s that are not permitted
2782     // by the given mask pair
2783     //
2784     private static String quote(String s, long lowMask, long highMask) {
2785         StringBuilder sb = null;
2786         boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);
2787         for (int i = 0; i &lt; s.length(); i++) {
2788             char c = s.charAt(i);
2789             if (c &lt; &#39;\u0080&#39;) {
2790                 if (!match(c, lowMask, highMask)) {
2791                     if (sb == null) {
2792                         sb = new StringBuilder();
2793                         sb.append(s, 0, i);
2794                     }
2795                     appendEscape(sb, (byte)c);
2796                 } else {
2797                     if (sb != null)
2798                         sb.append(c);
2799                 }
2800             } else if (allowNonASCII
2801                        &amp;&amp; (Character.isSpaceChar(c)
2802                            || Character.isISOControl(c))) {
2803                 if (sb == null) {
2804                     sb = new StringBuilder();
2805                     sb.append(s, 0, i);
2806                 }
2807                 appendEncoded(sb, c);
2808             } else {
2809                 if (sb != null)
2810                     sb.append(c);
2811             }
2812         }
2813         return (sb == null) ? s : sb.toString();
2814     }
2815 
2816     // Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,
2817     // assuming that s is otherwise legal
2818     //
2819     private static String encode(String s) {
2820         int n = s.length();
2821         if (n == 0)
2822             return s;
2823 
2824         // First check whether we actually need to encode
2825         for (int i = 0;;) {
2826             if (s.charAt(i) &gt;= &#39;\u0080&#39;)
2827                 break;
2828             if (++i &gt;= n)
2829                 return s;
2830         }
2831 
2832         String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
2833         ByteBuffer bb = null;
2834         try {
<a name="19" id="anc19"></a><span class="line-modified">2835             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
2836                 .encode(CharBuffer.wrap(ns));
2837         } catch (CharacterCodingException x) {
2838             assert false;
2839         }
2840 
2841         StringBuilder sb = new StringBuilder();
2842         while (bb.hasRemaining()) {
2843             int b = bb.get() &amp; 0xff;
2844             if (b &gt;= 0x80)
2845                 appendEscape(sb, (byte)b);
2846             else
2847                 sb.append((char)b);
2848         }
2849         return sb.toString();
2850     }
2851 
2852     private static int decode(char c) {
2853         if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
2854             return c - &#39;0&#39;;
2855         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
2856             return c - &#39;a&#39; + 10;
2857         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))
2858             return c - &#39;A&#39; + 10;
2859         assert false;
2860         return -1;
2861     }
2862 
2863     private static byte decode(char c1, char c2) {
2864         return (byte)(  ((decode(c1) &amp; 0xf) &lt;&lt; 4)
2865                       | ((decode(c2) &amp; 0xf) &lt;&lt; 0));
2866     }
2867 
2868     // Evaluates all escapes in s, applying UTF-8 decoding if needed.  Assumes
2869     // that escapes are well-formed syntactically, i.e., of the form %XX.  If a
2870     // sequence of escaped octets is not valid UTF-8 then the erroneous octets
2871     // are replaced with &#39;\uFFFD&#39;.
2872     // Exception: any &quot;%&quot; found between &quot;[]&quot; is left alone. It is an IPv6 literal
2873     //            with a scope_id
2874     //
2875     private static String decode(String s) {
2876         return decode(s, true);
2877     }
2878 
2879     // This method was introduced as a generalization of URI.decode method
2880     // to provide a fix for JDK-8037396
2881     private static String decode(String s, boolean ignorePercentInBrackets) {
2882         if (s == null)
2883             return s;
2884         int n = s.length();
2885         if (n == 0)
2886             return s;
2887         if (s.indexOf(&#39;%&#39;) &lt; 0)
2888             return s;
2889 
2890         StringBuilder sb = new StringBuilder(n);
2891         ByteBuffer bb = ByteBuffer.allocate(n);
2892         CharBuffer cb = CharBuffer.allocate(n);
<a name="20" id="anc20"></a><span class="line-modified">2893         CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)</span>
2894                 .onMalformedInput(CodingErrorAction.REPLACE)
2895                 .onUnmappableCharacter(CodingErrorAction.REPLACE);
2896 
2897         // This is not horribly efficient, but it will do for now
2898         char c = s.charAt(0);
2899         boolean betweenBrackets = false;
2900 
2901         for (int i = 0; i &lt; n;) {
2902             assert c == s.charAt(i);    // Loop invariant
2903             if (c == &#39;[&#39;) {
2904                 betweenBrackets = true;
2905             } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
2906                 betweenBrackets = false;
2907             }
2908             if (c != &#39;%&#39; || (betweenBrackets &amp;&amp; ignorePercentInBrackets)) {
2909                 sb.append(c);
2910                 if (++i &gt;= n)
2911                     break;
2912                 c = s.charAt(i);
2913                 continue;
2914             }
2915             bb.clear();
2916             int ui = i;
2917             for (;;) {
2918                 assert (n - i &gt;= 2);
2919                 bb.put(decode(s.charAt(++i), s.charAt(++i)));
2920                 if (++i &gt;= n)
2921                     break;
2922                 c = s.charAt(i);
2923                 if (c != &#39;%&#39;)
2924                     break;
2925             }
2926             bb.flip();
2927             cb.clear();
2928             dec.reset();
2929             CoderResult cr = dec.decode(bb, cb, true);
2930             assert cr.isUnderflow();
2931             cr = dec.flush(cb);
2932             assert cr.isUnderflow();
2933             sb.append(cb.flip().toString());
2934         }
2935 
2936         return sb.toString();
2937     }
2938 
2939 
2940     // -- Parsing --
2941 
2942     // For convenience we wrap the input URI string in a new instance of the
2943     // following internal class.  This saves always having to pass the input
2944     // string as an argument to each internal scan/parse method.
2945 
2946     private class Parser {
2947 
2948         private String input;           // URI input string
2949         private boolean requireServerAuthority = false;
2950 
2951         Parser(String s) {
2952             input = s;
2953             string = s;
2954         }
2955 
2956         // -- Methods for throwing URISyntaxException in various ways --
2957 
2958         private void fail(String reason) throws URISyntaxException {
2959             throw new URISyntaxException(input, reason);
2960         }
2961 
2962         private void fail(String reason, int p) throws URISyntaxException {
2963             throw new URISyntaxException(input, reason, p);
2964         }
2965 
2966         private void failExpecting(String expected, int p)
2967             throws URISyntaxException
2968         {
2969             fail(&quot;Expected &quot; + expected, p);
2970         }
2971 
2972 
2973         // -- Simple access to the input string --
2974 
2975         // Tells whether start &lt; end and, if so, whether charAt(start) == c
2976         //
2977         private boolean at(int start, int end, char c) {
2978             return (start &lt; end) &amp;&amp; (input.charAt(start) == c);
2979         }
2980 
2981         // Tells whether start + s.length() &lt; end and, if so,
2982         // whether the chars at the start position match s exactly
2983         //
2984         private boolean at(int start, int end, String s) {
2985             int p = start;
2986             int sn = s.length();
2987             if (sn &gt; end - p)
2988                 return false;
2989             int i = 0;
2990             while (i &lt; sn) {
2991                 if (input.charAt(p++) != s.charAt(i)) {
2992                     break;
2993                 }
2994                 i++;
2995             }
2996             return (i == sn);
2997         }
2998 
2999 
3000         // -- Scanning --
3001 
3002         // The various scan and parse methods that follow use a uniform
3003         // convention of taking the current start position and end index as
3004         // their first two arguments.  The start is inclusive while the end is
3005         // exclusive, just as in the String class, i.e., a start/end pair
3006         // denotes the left-open interval [start, end) of the input string.
3007         //
3008         // These methods never proceed past the end position.  They may return
3009         // -1 to indicate outright failure, but more often they simply return
3010         // the position of the first char after the last char scanned.  Thus
3011         // a typical idiom is
3012         //
3013         //     int p = start;
3014         //     int q = scan(p, end, ...);
3015         //     if (q &gt; p)
3016         //         // We scanned something
3017         //         ...;
3018         //     else if (q == p)
3019         //         // We scanned nothing
3020         //         ...;
3021         //     else if (q == -1)
3022         //         // Something went wrong
3023         //         ...;
3024 
3025 
3026         // Scan a specific char: If the char at the given start position is
3027         // equal to c, return the index of the next char; otherwise, return the
3028         // start position.
3029         //
3030         private int scan(int start, int end, char c) {
3031             if ((start &lt; end) &amp;&amp; (input.charAt(start) == c))
3032                 return start + 1;
3033             return start;
3034         }
3035 
3036         // Scan forward from the given start position.  Stop at the first char
3037         // in the err string (in which case -1 is returned), or the first char
3038         // in the stop string (in which case the index of the preceding char is
3039         // returned), or the end of the input string (in which case the length
3040         // of the input string is returned).  May return the start position if
3041         // nothing matches.
3042         //
3043         private int scan(int start, int end, String err, String stop) {
3044             int p = start;
3045             while (p &lt; end) {
3046                 char c = input.charAt(p);
3047                 if (err.indexOf(c) &gt;= 0)
3048                     return -1;
3049                 if (stop.indexOf(c) &gt;= 0)
3050                     break;
3051                 p++;
3052             }
3053             return p;
3054         }
3055 
3056         // Scan forward from the given start position.  Stop at the first char
3057         // in the stop string (in which case the index of the preceding char is
3058         // returned), or the end of the input string (in which case the length
3059         // of the input string is returned).  May return the start position if
3060         // nothing matches.
3061         //
3062         private int scan(int start, int end, String stop) {
3063             int p = start;
3064             while (p &lt; end) {
3065                 char c = input.charAt(p);
3066                 if (stop.indexOf(c) &gt;= 0)
3067                     break;
3068                 p++;
3069             }
3070             return p;
3071         }
3072 
3073         // Scan a potential escape sequence, starting at the given position,
3074         // with the given first char (i.e., charAt(start) == c).
3075         //
3076         // This method assumes that if escapes are allowed then visible
3077         // non-US-ASCII chars are also allowed.
3078         //
3079         private int scanEscape(int start, int n, char first)
3080             throws URISyntaxException
3081         {
3082             int p = start;
3083             char c = first;
3084             if (c == &#39;%&#39;) {
3085                 // Process escape pair
3086                 if ((p + 3 &lt;= n)
3087                     &amp;&amp; match(input.charAt(p + 1), L_HEX, H_HEX)
3088                     &amp;&amp; match(input.charAt(p + 2), L_HEX, H_HEX)) {
3089                     return p + 3;
3090                 }
3091                 fail(&quot;Malformed escape pair&quot;, p);
3092             } else if ((c &gt; 128)
3093                        &amp;&amp; !Character.isSpaceChar(c)
3094                        &amp;&amp; !Character.isISOControl(c)) {
3095                 // Allow unescaped but visible non-US-ASCII chars
3096                 return p + 1;
3097             }
3098             return p;
3099         }
3100 
3101         // Scan chars that match the given mask pair
3102         //
3103         private int scan(int start, int n, long lowMask, long highMask)
3104             throws URISyntaxException
3105         {
3106             int p = start;
3107             while (p &lt; n) {
3108                 char c = input.charAt(p);
3109                 if (match(c, lowMask, highMask)) {
3110                     p++;
3111                     continue;
3112                 }
3113                 if ((lowMask &amp; L_ESCAPED) != 0) {
3114                     int q = scanEscape(p, n, c);
3115                     if (q &gt; p) {
3116                         p = q;
3117                         continue;
3118                     }
3119                 }
3120                 break;
3121             }
3122             return p;
3123         }
3124 
3125         // Check that each of the chars in [start, end) matches the given mask
3126         //
3127         private void checkChars(int start, int end,
3128                                 long lowMask, long highMask,
3129                                 String what)
3130             throws URISyntaxException
3131         {
3132             int p = scan(start, end, lowMask, highMask);
3133             if (p &lt; end)
3134                 fail(&quot;Illegal character in &quot; + what, p);
3135         }
3136 
3137         // Check that the char at position p matches the given mask
3138         //
3139         private void checkChar(int p,
3140                                long lowMask, long highMask,
3141                                String what)
3142             throws URISyntaxException
3143         {
3144             checkChars(p, p + 1, lowMask, highMask, what);
3145         }
3146 
3147 
3148         // -- Parsing --
3149 
3150         // [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
3151         //
3152         void parse(boolean rsa) throws URISyntaxException {
3153             requireServerAuthority = rsa;
3154             int n = input.length();
3155             int p = scan(0, n, &quot;/?#&quot;, &quot;:&quot;);
3156             if ((p &gt;= 0) &amp;&amp; at(p, n, &#39;:&#39;)) {
3157                 if (p == 0)
3158                     failExpecting(&quot;scheme name&quot;, 0);
3159                 checkChar(0, L_ALPHA, H_ALPHA, &quot;scheme name&quot;);
3160                 checkChars(1, p, L_SCHEME, H_SCHEME, &quot;scheme name&quot;);
3161                 scheme = input.substring(0, p);
3162                 p++;                    // Skip &#39;:&#39;
3163                 if (at(p, n, &#39;/&#39;)) {
3164                     p = parseHierarchical(p, n);
3165                 } else {
3166                     // opaque; need to create the schemeSpecificPart
3167                     int q = scan(p, n, &quot;#&quot;);
3168                     if (q &lt;= p)
3169                         failExpecting(&quot;scheme-specific part&quot;, p);
3170                     checkChars(p, q, L_URIC, H_URIC, &quot;opaque part&quot;);
3171                     schemeSpecificPart = input.substring(p, q);
3172                     p = q;
3173                 }
3174             } else {
3175                 p = parseHierarchical(0, n);
3176             }
3177             if (at(p, n, &#39;#&#39;)) {
3178                 checkChars(p + 1, n, L_URIC, H_URIC, &quot;fragment&quot;);
3179                 fragment = input.substring(p + 1, n);
3180                 p = n;
3181             }
3182             if (p &lt; n)
3183                 fail(&quot;end of URI&quot;, p);
3184         }
3185 
3186         // [//authority]&lt;path&gt;[?&lt;query&gt;]
3187         //
3188         // DEVIATION from RFC2396: We allow an empty authority component as
3189         // long as it&#39;s followed by a non-empty path, query component, or
3190         // fragment component.  This is so that URIs such as &quot;file:///foo/bar&quot;
3191         // will parse.  This seems to be the intent of RFC2396, though the
3192         // grammar does not permit it.  If the authority is empty then the
3193         // userInfo, host, and port components are undefined.
3194         //
3195         // DEVIATION from RFC2396: We allow empty relative paths.  This seems
3196         // to be the intent of RFC2396, but the grammar does not permit it.
3197         // The primary consequence of this deviation is that &quot;#f&quot; parses as a
3198         // relative URI with an empty path.
3199         //
3200         private int parseHierarchical(int start, int n)
3201             throws URISyntaxException
3202         {
3203             int p = start;
3204             if (at(p, n, &#39;/&#39;) &amp;&amp; at(p + 1, n, &#39;/&#39;)) {
3205                 p += 2;
3206                 int q = scan(p, n, &quot;/?#&quot;);
3207                 if (q &gt; p) {
3208                     p = parseAuthority(p, q);
3209                 } else if (q &lt; n) {
3210                     // DEVIATION: Allow empty authority prior to non-empty
3211                     // path, query component or fragment identifier
3212                 } else
3213                     failExpecting(&quot;authority&quot;, p);
3214             }
3215             int q = scan(p, n, &quot;?#&quot;); // DEVIATION: May be empty
3216             checkChars(p, q, L_PATH, H_PATH, &quot;path&quot;);
3217             path = input.substring(p, q);
3218             p = q;
3219             if (at(p, n, &#39;?&#39;)) {
3220                 p++;
3221                 q = scan(p, n, &quot;#&quot;);
3222                 checkChars(p, q, L_URIC, H_URIC, &quot;query&quot;);
3223                 query = input.substring(p, q);
3224                 p = q;
3225             }
3226             return p;
3227         }
3228 
3229         // authority     = server | reg_name
3230         //
3231         // Ambiguity: An authority that is a registry name rather than a server
3232         // might have a prefix that parses as a server.  We use the fact that
3233         // the authority component is always followed by &#39;/&#39; or the end of the
3234         // input string to resolve this: If the complete authority did not
3235         // parse as a server then we try to parse it as a registry name.
3236         //
3237         private int parseAuthority(int start, int n)
3238             throws URISyntaxException
3239         {
3240             int p = start;
3241             int q = p;
3242             URISyntaxException ex = null;
3243 
3244             boolean serverChars;
3245             boolean regChars;
3246 
3247             if (scan(p, n, &quot;]&quot;) &gt; p) {
3248                 // contains a literal IPv6 address, therefore % is allowed
3249                 serverChars = (scan(p, n, L_SERVER_PERCENT, H_SERVER_PERCENT) == n);
3250             } else {
3251                 serverChars = (scan(p, n, L_SERVER, H_SERVER) == n);
3252             }
3253             regChars = (scan(p, n, L_REG_NAME, H_REG_NAME) == n);
3254 
3255             if (regChars &amp;&amp; !serverChars) {
3256                 // Must be a registry-based authority
3257                 authority = input.substring(p, n);
3258                 return n;
3259             }
3260 
3261             if (serverChars) {
3262                 // Might be (probably is) a server-based authority, so attempt
3263                 // to parse it as such.  If the attempt fails, try to treat it
3264                 // as a registry-based authority.
3265                 try {
3266                     q = parseServer(p, n);
3267                     if (q &lt; n)
3268                         failExpecting(&quot;end of authority&quot;, q);
3269                     authority = input.substring(p, n);
3270                 } catch (URISyntaxException x) {
3271                     // Undo results of failed parse
3272                     userInfo = null;
3273                     host = null;
3274                     port = -1;
3275                     if (requireServerAuthority) {
3276                         // If we&#39;re insisting upon a server-based authority,
3277                         // then just re-throw the exception
3278                         throw x;
3279                     } else {
3280                         // Save the exception in case it doesn&#39;t parse as a
3281                         // registry either
3282                         ex = x;
3283                         q = p;
3284                     }
3285                 }
3286             }
3287 
3288             if (q &lt; n) {
3289                 if (regChars) {
3290                     // Registry-based authority
3291                     authority = input.substring(p, n);
3292                 } else if (ex != null) {
3293                     // Re-throw exception; it was probably due to
3294                     // a malformed IPv6 address
3295                     throw ex;
3296                 } else {
3297                     fail(&quot;Illegal character in authority&quot;, q);
3298                 }
3299             }
3300 
3301             return n;
3302         }
3303 
3304 
3305         // [&lt;userinfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
3306         //
3307         private int parseServer(int start, int n)
3308             throws URISyntaxException
3309         {
3310             int p = start;
3311             int q;
3312 
3313             // userinfo
3314             q = scan(p, n, &quot;/?#&quot;, &quot;@&quot;);
3315             if ((q &gt;= p) &amp;&amp; at(q, n, &#39;@&#39;)) {
3316                 checkChars(p, q, L_USERINFO, H_USERINFO, &quot;user info&quot;);
3317                 userInfo = input.substring(p, q);
3318                 p = q + 1;              // Skip &#39;@&#39;
3319             }
3320 
3321             // hostname, IPv4 address, or IPv6 address
3322             if (at(p, n, &#39;[&#39;)) {
3323                 // DEVIATION from RFC2396: Support IPv6 addresses, per RFC2732
3324                 p++;
3325                 q = scan(p, n, &quot;/?#&quot;, &quot;]&quot;);
3326                 if ((q &gt; p) &amp;&amp; at(q, n, &#39;]&#39;)) {
3327                     // look for a &quot;%&quot; scope id
3328                     int r = scan (p, q, &quot;%&quot;);
3329                     if (r &gt; p) {
3330                         parseIPv6Reference(p, r);
3331                         if (r+1 == q) {
3332                             fail (&quot;scope id expected&quot;);
3333                         }
3334                         checkChars (r+1, q, L_SCOPE_ID, H_SCOPE_ID,
3335                                                 &quot;scope id&quot;);
3336                     } else {
3337                         parseIPv6Reference(p, q);
3338                     }
3339                     host = input.substring(p-1, q+1);
3340                     p = q + 1;
3341                 } else {
3342                     failExpecting(&quot;closing bracket for IPv6 address&quot;, q);
3343                 }
3344             } else {
3345                 q = parseIPv4Address(p, n);
3346                 if (q &lt;= p)
3347                     q = parseHostname(p, n);
3348                 p = q;
3349             }
3350 
3351             // port
3352             if (at(p, n, &#39;:&#39;)) {
3353                 p++;
3354                 q = scan(p, n, &quot;/&quot;);
3355                 if (q &gt; p) {
3356                     checkChars(p, q, L_DIGIT, H_DIGIT, &quot;port number&quot;);
3357                     try {
3358                         port = Integer.parseInt(input, p, q, 10);
3359                     } catch (NumberFormatException x) {
3360                         fail(&quot;Malformed port number&quot;, p);
3361                     }
3362                     p = q;
3363                 }
3364             }
3365             if (p &lt; n)
3366                 failExpecting(&quot;port number&quot;, p);
3367 
3368             return p;
3369         }
3370 
3371         // Scan a string of decimal digits whose value fits in a byte
3372         //
3373         private int scanByte(int start, int n)
3374             throws URISyntaxException
3375         {
3376             int p = start;
3377             int q = scan(p, n, L_DIGIT, H_DIGIT);
3378             if (q &lt;= p) return q;
3379             if (Integer.parseInt(input, p, q, 10) &gt; 255) return p;
3380             return q;
3381         }
3382 
3383         // Scan an IPv4 address.
3384         //
3385         // If the strict argument is true then we require that the given
3386         // interval contain nothing besides an IPv4 address; if it is false
3387         // then we only require that it start with an IPv4 address.
3388         //
3389         // If the interval does not contain or start with (depending upon the
3390         // strict argument) a legal IPv4 address characters then we return -1
3391         // immediately; otherwise we insist that these characters parse as a
3392         // legal IPv4 address and throw an exception on failure.
3393         //
3394         // We assume that any string of decimal digits and dots must be an IPv4
3395         // address.  It won&#39;t parse as a hostname anyway, so making that
3396         // assumption here allows more meaningful exceptions to be thrown.
3397         //
3398         private int scanIPv4Address(int start, int n, boolean strict)
3399             throws URISyntaxException
3400         {
3401             int p = start;
3402             int q;
3403             int m = scan(p, n, L_DIGIT | L_DOT, H_DIGIT | H_DOT);
3404             if ((m &lt;= p) || (strict &amp;&amp; (m != n)))
3405                 return -1;
3406             for (;;) {
3407                 // Per RFC2732: At most three digits per byte
3408                 // Further constraint: Each element fits in a byte
3409                 if ((q = scanByte(p, m)) &lt;= p) break;   p = q;
3410                 if ((q = scan(p, m, &#39;.&#39;)) &lt;= p) break;  p = q;
3411                 if ((q = scanByte(p, m)) &lt;= p) break;   p = q;
3412                 if ((q = scan(p, m, &#39;.&#39;)) &lt;= p) break;  p = q;
3413                 if ((q = scanByte(p, m)) &lt;= p) break;   p = q;
3414                 if ((q = scan(p, m, &#39;.&#39;)) &lt;= p) break;  p = q;
3415                 if ((q = scanByte(p, m)) &lt;= p) break;   p = q;
3416                 if (q &lt; m) break;
3417                 return q;
3418             }
3419             fail(&quot;Malformed IPv4 address&quot;, q);
3420             return -1;
3421         }
3422 
3423         // Take an IPv4 address: Throw an exception if the given interval
3424         // contains anything except an IPv4 address
3425         //
3426         private int takeIPv4Address(int start, int n, String expected)
3427             throws URISyntaxException
3428         {
3429             int p = scanIPv4Address(start, n, true);
3430             if (p &lt;= start)
3431                 failExpecting(expected, start);
3432             return p;
3433         }
3434 
3435         // Attempt to parse an IPv4 address, returning -1 on failure but
3436         // allowing the given interval to contain [:&lt;characters&gt;] after
3437         // the IPv4 address.
3438         //
3439         private int parseIPv4Address(int start, int n) {
3440             int p;
3441 
3442             try {
3443                 p = scanIPv4Address(start, n, false);
3444             } catch (URISyntaxException x) {
3445                 return -1;
3446             } catch (NumberFormatException nfe) {
3447                 return -1;
3448             }
3449 
3450             if (p &gt; start &amp;&amp; p &lt; n) {
3451                 // IPv4 address is followed by something - check that
3452                 // it&#39;s a &quot;:&quot; as this is the only valid character to
3453                 // follow an address.
3454                 if (input.charAt(p) != &#39;:&#39;) {
3455                     p = -1;
3456                 }
3457             }
3458 
3459             if (p &gt; start)
3460                 host = input.substring(start, p);
3461 
3462             return p;
3463         }
3464 
3465         // hostname      = domainlabel [ &quot;.&quot; ] | 1*( domainlabel &quot;.&quot; ) toplabel [ &quot;.&quot; ]
3466         // domainlabel   = alphanum | alphanum *( alphanum | &quot;-&quot; ) alphanum
3467         // toplabel      = alpha | alpha *( alphanum | &quot;-&quot; ) alphanum
3468         //
3469         private int parseHostname(int start, int n)
3470             throws URISyntaxException
3471         {
3472             int p = start;
3473             int q;
3474             int l = -1;                 // Start of last parsed label
3475 
3476             do {
3477                 // domainlabel = alphanum [ *( alphanum | &quot;-&quot; ) alphanum ]
3478                 q = scan(p, n, L_ALPHANUM, H_ALPHANUM);
3479                 if (q &lt;= p)
3480                     break;
3481                 l = p;
3482                 if (q &gt; p) {
3483                     p = q;
3484                     q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);
3485                     if (q &gt; p) {
3486                         if (input.charAt(q - 1) == &#39;-&#39;)
3487                             fail(&quot;Illegal character in hostname&quot;, q - 1);
3488                         p = q;
3489                     }
3490                 }
3491                 q = scan(p, n, &#39;.&#39;);
3492                 if (q &lt;= p)
3493                     break;
3494                 p = q;
3495             } while (p &lt; n);
3496 
3497             if ((p &lt; n) &amp;&amp; !at(p, n, &#39;:&#39;))
3498                 fail(&quot;Illegal character in hostname&quot;, p);
3499 
3500             if (l &lt; 0)
3501                 failExpecting(&quot;hostname&quot;, start);
3502 
3503             // for a fully qualified hostname check that the rightmost
3504             // label starts with an alpha character.
3505             if (l &gt; start &amp;&amp; !match(input.charAt(l), L_ALPHA, H_ALPHA)) {
3506                 fail(&quot;Illegal character in hostname&quot;, l);
3507             }
3508 
3509             host = input.substring(start, p);
3510             return p;
3511         }
3512 
3513 
3514         // IPv6 address parsing, from RFC2373: IPv6 Addressing Architecture
3515         //
3516         // Bug: The grammar in RFC2373 Appendix B does not allow addresses of
3517         // the form ::12.34.56.78, which are clearly shown in the examples
3518         // earlier in the document.  Here is the original grammar:
3519         //
3520         //   IPv6address = hexpart [ &quot;:&quot; IPv4address ]
3521         //   hexpart     = hexseq | hexseq &quot;::&quot; [ hexseq ] | &quot;::&quot; [ hexseq ]
3522         //   hexseq      = hex4 *( &quot;:&quot; hex4)
3523         //   hex4        = 1*4HEXDIG
3524         //
3525         // We therefore use the following revised grammar:
3526         //
3527         //   IPv6address = hexseq [ &quot;:&quot; IPv4address ]
3528         //                 | hexseq [ &quot;::&quot; [ hexpost ] ]
3529         //                 | &quot;::&quot; [ hexpost ]
3530         //   hexpost     = hexseq | hexseq &quot;:&quot; IPv4address | IPv4address
3531         //   hexseq      = hex4 *( &quot;:&quot; hex4)
3532         //   hex4        = 1*4HEXDIG
3533         //
3534         // This covers all and only the following cases:
3535         //
3536         //   hexseq
3537         //   hexseq : IPv4address
3538         //   hexseq ::
3539         //   hexseq :: hexseq
3540         //   hexseq :: hexseq : IPv4address
3541         //   hexseq :: IPv4address
3542         //   :: hexseq
3543         //   :: hexseq : IPv4address
3544         //   :: IPv4address
3545         //   ::
3546         //
3547         // Additionally we constrain the IPv6 address as follows :-
3548         //
3549         //  i.  IPv6 addresses without compressed zeros should contain
3550         //      exactly 16 bytes.
3551         //
3552         //  ii. IPv6 addresses with compressed zeros should contain
3553         //      less than 16 bytes.
3554 
3555         private int ipv6byteCount = 0;
3556 
3557         private int parseIPv6Reference(int start, int n)
3558             throws URISyntaxException
3559         {
3560             int p = start;
3561             int q;
3562             boolean compressedZeros = false;
3563 
3564             q = scanHexSeq(p, n);
3565 
3566             if (q &gt; p) {
3567                 p = q;
3568                 if (at(p, n, &quot;::&quot;)) {
3569                     compressedZeros = true;
3570                     p = scanHexPost(p + 2, n);
3571                 } else if (at(p, n, &#39;:&#39;)) {
3572                     p = takeIPv4Address(p + 1,  n, &quot;IPv4 address&quot;);
3573                     ipv6byteCount += 4;
3574                 }
3575             } else if (at(p, n, &quot;::&quot;)) {
3576                 compressedZeros = true;
3577                 p = scanHexPost(p + 2, n);
3578             }
3579             if (p &lt; n)
3580                 fail(&quot;Malformed IPv6 address&quot;, start);
3581             if (ipv6byteCount &gt; 16)
3582                 fail(&quot;IPv6 address too long&quot;, start);
3583             if (!compressedZeros &amp;&amp; ipv6byteCount &lt; 16)
3584                 fail(&quot;IPv6 address too short&quot;, start);
3585             if (compressedZeros &amp;&amp; ipv6byteCount == 16)
3586                 fail(&quot;Malformed IPv6 address&quot;, start);
3587 
3588             return p;
3589         }
3590 
3591         private int scanHexPost(int start, int n)
3592             throws URISyntaxException
3593         {
3594             int p = start;
3595             int q;
3596 
3597             if (p == n)
3598                 return p;
3599 
3600             q = scanHexSeq(p, n);
3601             if (q &gt; p) {
3602                 p = q;
3603                 if (at(p, n, &#39;:&#39;)) {
3604                     p++;
3605                     p = takeIPv4Address(p, n, &quot;hex digits or IPv4 address&quot;);
3606                     ipv6byteCount += 4;
3607                 }
3608             } else {
3609                 p = takeIPv4Address(p, n, &quot;hex digits or IPv4 address&quot;);
3610                 ipv6byteCount += 4;
3611             }
3612             return p;
3613         }
3614 
3615         // Scan a hex sequence; return -1 if one could not be scanned
3616         //
3617         private int scanHexSeq(int start, int n)
3618             throws URISyntaxException
3619         {
3620             int p = start;
3621             int q;
3622 
3623             q = scan(p, n, L_HEX, H_HEX);
3624             if (q &lt;= p)
3625                 return -1;
3626             if (at(q, n, &#39;.&#39;))          // Beginning of IPv4 address
3627                 return -1;
3628             if (q &gt; p + 4)
3629                 fail(&quot;IPv6 hexadecimal digit sequence too long&quot;, p);
3630             ipv6byteCount += 2;
3631             p = q;
3632             while (p &lt; n) {
3633                 if (!at(p, n, &#39;:&#39;))
3634                     break;
3635                 if (at(p + 1, n, &#39;:&#39;))
3636                     break;              // &quot;::&quot;
3637                 p++;
3638                 q = scan(p, n, L_HEX, H_HEX);
3639                 if (q &lt;= p)
3640                     failExpecting(&quot;digits for an IPv6 address&quot;, p);
3641                 if (at(q, n, &#39;.&#39;)) {    // Beginning of IPv4 address
3642                     p--;
3643                     break;
3644                 }
3645                 if (q &gt; p + 4)
3646                     fail(&quot;IPv6 hexadecimal digit sequence too long&quot;, p);
3647                 ipv6byteCount += 2;
3648                 p = q;
3649             }
3650 
3651             return p;
3652         }
3653 
3654     }
3655     static {
3656         SharedSecrets.setJavaNetUriAccess(
3657             new JavaNetUriAccess() {
3658                 public URI create(String scheme, String path) {
3659                     return new URI(scheme, path);
3660                 }
3661             }
3662         );
3663     }
3664 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/SocksSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
<a name="2" id="anc2"></a>
 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.io.OutputStream;
 29 import java.io.BufferedOutputStream;
<a name="3" id="anc3"></a>
 30 import java.security.AccessController;
<a name="4" id="anc4"></a>
 31 
 32 import jdk.internal.util.StaticProperty;
 33 import sun.net.SocksProxy;
 34 import sun.net.spi.DefaultProxySelector;
 35 import sun.net.www.ParseUtil;
 36 
 37 /**
 38  * SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).
<a name="5" id="anc5"></a><span class="line-removed"> 39  * This is a subclass of PlainSocketImpl.</span>
<span class="line-removed"> 40  * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.</span>
 41  */
 42 
<a name="6" id="anc6"></a><span class="line-modified"> 43 class SocksSocketImpl extends PlainSocketImpl implements SocksConsts {</span>
 44     private String server = null;
 45     private int serverPort = DEFAULT_PORT;
 46     private InetSocketAddress external_address;
 47     private boolean useV4 = false;
 48     private Socket cmdsock = null;
 49     private InputStream cmdIn = null;
 50     private OutputStream cmdOut = null;
 51 
<a name="7" id="anc7"></a><span class="line-modified"> 52     SocksSocketImpl() {</span>
<span class="line-modified"> 53         // Nothing needed</span>
 54     }
 55 
<a name="8" id="anc8"></a><span class="line-modified"> 56     SocksSocketImpl(Proxy proxy) {</span>

 57         SocketAddress a = proxy.address();
 58         if (a instanceof InetSocketAddress) {
 59             InetSocketAddress ad = (InetSocketAddress) a;
 60             // Use getHostString() to avoid reverse lookups
 61             server = ad.getHostString();
 62             serverPort = ad.getPort();
 63         }
 64         useV4 = useV4(proxy);
 65     }
 66 
 67     private static boolean useV4(Proxy proxy) {
 68         if (proxy instanceof SocksProxy
 69             &amp;&amp; ((SocksProxy)proxy).protocolVersion() == 4) {
 70             return true;
 71         }
 72         return DefaultProxySelector.socksProxyVersion() == 4;
 73     }
 74 
 75     private synchronized void privilegedConnect(final String host,
 76                                               final int port,
 77                                               final int timeout)
<a name="9" id="anc9"></a><span class="line-modified"> 78          throws IOException</span>
 79     {
 80         try {
 81             AccessController.doPrivileged(
 82                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
 83                     public Void run() throws IOException {
 84                               superConnectServer(host, port, timeout);
 85                               cmdIn = getInputStream();
 86                               cmdOut = getOutputStream();
 87                               return null;
 88                           }
 89                       });
 90         } catch (java.security.PrivilegedActionException pae) {
 91             throw (IOException) pae.getException();
 92         }
 93     }
 94 
 95     private void superConnectServer(String host, int port,
 96                                     int timeout) throws IOException {
<a name="10" id="anc10"></a><span class="line-modified"> 97         super.connect(new InetSocketAddress(host, port), timeout);</span>
 98     }
 99 
100     private static int remainingMillis(long deadlineMillis) throws IOException {
101         if (deadlineMillis == 0L)
102             return 0;
103 
104         final long remaining = deadlineMillis - System.currentTimeMillis();
105         if (remaining &gt; 0)
106             return (int) remaining;
107 
108         throw new SocketTimeoutException();
109     }
110 
111     private int readSocksReply(InputStream in, byte[] data, long deadlineMillis) throws IOException {
112         int len = data.length;
113         int received = 0;
<a name="11" id="anc11"></a><span class="line-modified">114         while (received &lt; len) {</span>
<span class="line-modified">115             int count;</span>
<span class="line-modified">116             try {</span>
<span class="line-modified">117                 count = ((SocketInputStream)in).read(data, received, len - received, remainingMillis(deadlineMillis));</span>
<span class="line-modified">118             } catch (SocketTimeoutException e) {</span>
<span class="line-modified">119                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>








120             }
<a name="12" id="anc12"></a><span class="line-modified">121             if (count &lt; 0)</span>
<span class="line-modified">122                 throw new SocketException(&quot;Malformed reply from SOCKS server&quot;);</span>
<span class="line-removed">123             received += count;</span>
124         }
125         return received;
126     }
127 
128     private boolean authenticate(byte method, InputStream in,
129                                  BufferedOutputStream out,
130                                  long deadlineMillis) throws IOException {
131         // No Authentication required. We&#39;re done then!
132         if (method == NO_AUTH)
133             return true;
134         /*
135          * User/Password authentication. Try, in that order :
136          * - The application provided Authenticator, if any
137          * - the user.name &amp; no password (backward compatibility behavior).
138          */
139         if (method == USER_PASSW) {
140             String userName;
141             String password = null;
142             final InetAddress addr = InetAddress.getByName(server);
143             PasswordAuthentication pw =
144                 java.security.AccessController.doPrivileged(
145                     new java.security.PrivilegedAction&lt;&gt;() {
146                         public PasswordAuthentication run() {
147                                 return Authenticator.requestPasswordAuthentication(
148                                        server, addr, serverPort, &quot;SOCKS5&quot;, &quot;SOCKS authentication&quot;, null);
149                             }
150                         });
151             if (pw != null) {
152                 userName = pw.getUserName();
153                 password = new String(pw.getPassword());
154             } else {
155                 userName = StaticProperty.userName();
156             }
157             if (userName == null)
158                 return false;
159             out.write(1);
160             out.write(userName.length());
<a name="13" id="anc13"></a><span class="line-modified">161             try {</span>
<span class="line-removed">162                 out.write(userName.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">163             } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">164                 assert false;</span>
<span class="line-removed">165             }</span>
166             if (password != null) {
167                 out.write(password.length());
<a name="14" id="anc14"></a><span class="line-modified">168                 try {</span>
<span class="line-removed">169                     out.write(password.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">170                 } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">171                     assert false;</span>
<span class="line-removed">172                 }</span>
173             } else
174                 out.write(0);
175             out.flush();
176             byte[] data = new byte[2];
177             int i = readSocksReply(in, data, deadlineMillis);
178             if (i != 2 || data[1] != 0) {
179                 /* RFC 1929 specifies that the connection MUST be closed if
180                    authentication fails */
181                 out.close();
182                 in.close();
183                 return false;
184             }
185             /* Authentication succeeded */
186             return true;
187         }
188         return false;
189     }
190 
191     private void connectV4(InputStream in, OutputStream out,
192                            InetSocketAddress endpoint,
193                            long deadlineMillis) throws IOException {
194         if (!(endpoint.getAddress() instanceof Inet4Address)) {
195             throw new SocketException(&quot;SOCKS V4 requires IPv4 only addresses&quot;);
196         }
197         out.write(PROTO_VERS4);
198         out.write(CONNECT);
199         out.write((endpoint.getPort() &gt;&gt; 8) &amp; 0xff);
200         out.write((endpoint.getPort() &gt;&gt; 0) &amp; 0xff);
201         out.write(endpoint.getAddress().getAddress());
202         String userName = getUserName();
<a name="15" id="anc15"></a><span class="line-modified">203         try {</span>
<span class="line-removed">204             out.write(userName.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">205         } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">206             assert false;</span>
<span class="line-removed">207         }</span>
208         out.write(0);
209         out.flush();
210         byte[] data = new byte[8];
211         int n = readSocksReply(in, data, deadlineMillis);
212         if (n != 8)
213             throw new SocketException(&quot;Reply from SOCKS server has bad length: &quot; + n);
214         if (data[0] != 0 &amp;&amp; data[0] != 4)
215             throw new SocketException(&quot;Reply from SOCKS server has bad version&quot;);
216         SocketException ex = null;
217         switch (data[1]) {
218         case 90:
219             // Success!
220             external_address = endpoint;
221             break;
222         case 91:
223             ex = new SocketException(&quot;SOCKS request rejected&quot;);
224             break;
225         case 92:
226             ex = new SocketException(&quot;SOCKS server couldn&#39;t reach destination&quot;);
227             break;
228         case 93:
229             ex = new SocketException(&quot;SOCKS authentication failed&quot;);
230             break;
231         default:
232             ex = new SocketException(&quot;Reply from SOCKS server contains bad status&quot;);
233             break;
234         }
235         if (ex != null) {
236             in.close();
237             out.close();
238             throw ex;
239         }
240     }
241 
<a name="16" id="anc16"></a>









242     /**
243      * Connects the Socks Socket to the specified endpoint. It will first
244      * connect to the SOCKS proxy and negotiate the access. If the proxy
245      * grants the connections, then the connect is successful and all
246      * further traffic will go to the &quot;real&quot; endpoint.
247      *
248      * @param   endpoint        the {@code SocketAddress} to connect to.
249      * @param   timeout         the timeout value in milliseconds
250      * @throws  IOException     if the connection can&#39;t be established.
251      * @throws  SecurityException if there is a security manager and it
252      *                          doesn&#39;t allow the connection
253      * @throws  IllegalArgumentException if endpoint is null or a
254      *          SocketAddress subclass not supported by this socket
255      */
256     @Override
257     protected void connect(SocketAddress endpoint, int timeout) throws IOException {
258         final long deadlineMillis;
259 
260         if (timeout == 0) {
261             deadlineMillis = 0L;
262         } else {
263             long finish = System.currentTimeMillis() + timeout;
264             deadlineMillis = finish &lt; 0 ? Long.MAX_VALUE : finish;
265         }
266 
267         SecurityManager security = System.getSecurityManager();
268         if (endpoint == null || !(endpoint instanceof InetSocketAddress))
269             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
270         InetSocketAddress epoint = (InetSocketAddress) endpoint;
271         if (security != null) {
272             if (epoint.isUnresolved())
273                 security.checkConnect(epoint.getHostName(),
274                                       epoint.getPort());
275             else
276                 security.checkConnect(epoint.getAddress().getHostAddress(),
277                                       epoint.getPort());
278         }
279         if (server == null) {
280             // This is the general case
281             // server is not null only when the socket was created with a
282             // specified proxy in which case it does bypass the ProxySelector
283             ProxySelector sel = java.security.AccessController.doPrivileged(
284                 new java.security.PrivilegedAction&lt;&gt;() {
285                     public ProxySelector run() {
286                             return ProxySelector.getDefault();
287                         }
288                     });
289             if (sel == null) {
290                 /*
291                  * No default proxySelector --&gt; direct connection
292                  */
<a name="17" id="anc17"></a><span class="line-modified">293                 super.connect(epoint, remainingMillis(deadlineMillis));</span>
294                 return;
295             }
296             URI uri;
297             // Use getHostString() to avoid reverse lookups
298             String host = epoint.getHostString();
299             // IPv6 literal?
300             if (epoint.getAddress() instanceof Inet6Address &amp;&amp;
301                 (!host.startsWith(&quot;[&quot;)) &amp;&amp; (host.indexOf(&#39;:&#39;) &gt;= 0)) {
302                 host = &quot;[&quot; + host + &quot;]&quot;;
303             }
304             try {
305                 uri = new URI(&quot;socket://&quot; + ParseUtil.encodePath(host) + &quot;:&quot;+ epoint.getPort());
306             } catch (URISyntaxException e) {
307                 // This shouldn&#39;t happen
308                 assert false : e;
309                 uri = null;
310             }
311             Proxy p = null;
312             IOException savedExc = null;
<a name="18" id="anc18"></a><span class="line-modified">313             java.util.Iterator&lt;Proxy&gt; iProxy = null;</span>
<span class="line-modified">314             iProxy = sel.select(uri).iterator();</span>




315             if (iProxy == null || !(iProxy.hasNext())) {
<a name="19" id="anc19"></a><span class="line-modified">316                 super.connect(epoint, remainingMillis(deadlineMillis));</span>
317                 return;
318             }
319             while (iProxy.hasNext()) {
320                 p = iProxy.next();
321                 if (p == null || p.type() != Proxy.Type.SOCKS) {
<a name="20" id="anc20"></a><span class="line-modified">322                     super.connect(epoint, remainingMillis(deadlineMillis));</span>
323                     return;
324                 }
325 
326                 if (!(p.address() instanceof InetSocketAddress))
327                     throw new SocketException(&quot;Unknown address type for proxy: &quot; + p);
328                 // Use getHostString() to avoid reverse lookups
329                 server = ((InetSocketAddress) p.address()).getHostString();
330                 serverPort = ((InetSocketAddress) p.address()).getPort();
331                 useV4 = useV4(p);
332 
333                 // Connects to the SOCKS server
334                 try {
335                     privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
336                     // Worked, let&#39;s get outta here
337                     break;
338                 } catch (IOException e) {
339                     // Ooops, let&#39;s notify the ProxySelector
340                     sel.connectFailed(uri,p.address(),e);
341                     server = null;
342                     serverPort = -1;
343                     savedExc = e;
344                     // Will continue the while loop and try the next proxy
345                 }
346             }
347 
348             /*
349              * If server is still null at this point, none of the proxy
350              * worked
351              */
352             if (server == null) {
353                 throw new SocketException(&quot;Can&#39;t connect to SOCKS proxy:&quot;
354                                           + savedExc.getMessage());
355             }
356         } else {
357             // Connects to the SOCKS server
358             try {
359                 privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
360             } catch (IOException e) {
361                 throw new SocketException(e.getMessage());
362             }
363         }
364 
365         // cmdIn &amp; cmdOut were initialized during the privilegedConnect() call
366         BufferedOutputStream out = new BufferedOutputStream(cmdOut, 512);
367         InputStream in = cmdIn;
368 
369         if (useV4) {
370             // SOCKS Protocol version 4 doesn&#39;t know how to deal with
371             // DOMAIN type of addresses (unresolved addresses here)
372             if (epoint.isUnresolved())
373                 throw new UnknownHostException(epoint.toString());
374             connectV4(in, out, epoint, deadlineMillis);
375             return;
376         }
377 
378         // This is SOCKS V5
379         out.write(PROTO_VERS);
380         out.write(2);
381         out.write(NO_AUTH);
382         out.write(USER_PASSW);
383         out.flush();
384         byte[] data = new byte[2];
385         int i = readSocksReply(in, data, deadlineMillis);
386         if (i != 2 || ((int)data[0]) != PROTO_VERS) {
387             // Maybe it&#39;s not a V5 sever after all
388             // Let&#39;s try V4 before we give up
389             // SOCKS Protocol version 4 doesn&#39;t know how to deal with
390             // DOMAIN type of addresses (unresolved addresses here)
391             if (epoint.isUnresolved())
392                 throw new UnknownHostException(epoint.toString());
393             connectV4(in, out, epoint, deadlineMillis);
394             return;
395         }
396         if (((int)data[1]) == NO_METHODS)
397             throw new SocketException(&quot;SOCKS : No acceptable methods&quot;);
398         if (!authenticate(data[1], in, out, deadlineMillis)) {
399             throw new SocketException(&quot;SOCKS : authentication failed&quot;);
400         }
401         out.write(PROTO_VERS);
402         out.write(CONNECT);
403         out.write(0);
404         /* Test for IPV4/IPV6/Unresolved */
405         if (epoint.isUnresolved()) {
406             out.write(DOMAIN_NAME);
407             out.write(epoint.getHostName().length());
<a name="21" id="anc21"></a><span class="line-modified">408             try {</span>
<span class="line-removed">409                 out.write(epoint.getHostName().getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">410             } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">411                 assert false;</span>
<span class="line-removed">412             }</span>
413             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
414             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
415         } else if (epoint.getAddress() instanceof Inet6Address) {
416             out.write(IPV6);
417             out.write(epoint.getAddress().getAddress());
418             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
419             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
420         } else {
421             out.write(IPV4);
422             out.write(epoint.getAddress().getAddress());
423             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
424             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
425         }
426         out.flush();
427         data = new byte[4];
428         i = readSocksReply(in, data, deadlineMillis);
429         if (i != 4)
430             throw new SocketException(&quot;Reply from SOCKS server has bad length&quot;);
431         SocketException ex = null;
432         int len;
433         byte[] addr;
434         switch (data[1]) {
435         case REQUEST_OK:
436             // success!
437             switch(data[3]) {
438             case IPV4:
439                 addr = new byte[4];
440                 i = readSocksReply(in, addr, deadlineMillis);
441                 if (i != 4)
442                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
443                 data = new byte[2];
444                 i = readSocksReply(in, data, deadlineMillis);
445                 if (i != 2)
446                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
447                 break;
448             case DOMAIN_NAME:
449                 byte[] lenByte = new byte[1];
450                 i = readSocksReply(in, lenByte, deadlineMillis);
451                 if (i != 1)
452                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
453                 len = lenByte[0] &amp; 0xFF;
454                 byte[] host = new byte[len];
455                 i = readSocksReply(in, host, deadlineMillis);
456                 if (i != len)
457                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
458                 data = new byte[2];
459                 i = readSocksReply(in, data, deadlineMillis);
460                 if (i != 2)
461                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
462                 break;
463             case IPV6:
464                 len = 16;
465                 addr = new byte[len];
466                 i = readSocksReply(in, addr, deadlineMillis);
467                 if (i != len)
468                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
469                 data = new byte[2];
470                 i = readSocksReply(in, data, deadlineMillis);
471                 if (i != 2)
472                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
473                 break;
474             default:
475                 ex = new SocketException(&quot;Reply from SOCKS server contains wrong code&quot;);
476                 break;
477             }
478             break;
479         case GENERAL_FAILURE:
480             ex = new SocketException(&quot;SOCKS server general failure&quot;);
481             break;
482         case NOT_ALLOWED:
483             ex = new SocketException(&quot;SOCKS: Connection not allowed by ruleset&quot;);
484             break;
485         case NET_UNREACHABLE:
486             ex = new SocketException(&quot;SOCKS: Network unreachable&quot;);
487             break;
488         case HOST_UNREACHABLE:
489             ex = new SocketException(&quot;SOCKS: Host unreachable&quot;);
490             break;
491         case CONN_REFUSED:
492             ex = new SocketException(&quot;SOCKS: Connection refused&quot;);
493             break;
494         case TTL_EXPIRED:
495             ex =  new SocketException(&quot;SOCKS: TTL expired&quot;);
496             break;
497         case CMD_NOT_SUPPORTED:
498             ex = new SocketException(&quot;SOCKS: Command not supported&quot;);
499             break;
500         case ADDR_TYPE_NOT_SUP:
501             ex = new SocketException(&quot;SOCKS: address type not supported&quot;);
502             break;
503         }
504         if (ex != null) {
505             in.close();
506             out.close();
507             throw ex;
508         }
509         external_address = epoint;
510     }
511 
<a name="22" id="anc22"></a>



512 
<a name="23" id="anc23"></a>



513 
514     /**
515      * Returns the value of this socket&#39;s {@code address} field.
516      *
517      * @return  the value of this socket&#39;s {@code address} field.
518      * @see     java.net.SocketImpl#address
519      */
520     @Override
521     protected InetAddress getInetAddress() {
522         if (external_address != null)
523             return external_address.getAddress();
524         else
<a name="24" id="anc24"></a><span class="line-modified">525             return super.getInetAddress();</span>
526     }
527 
528     /**
529      * Returns the value of this socket&#39;s {@code port} field.
530      *
531      * @return  the value of this socket&#39;s {@code port} field.
532      * @see     java.net.SocketImpl#port
533      */
534     @Override
535     protected int getPort() {
536         if (external_address != null)
537             return external_address.getPort();
538         else
<a name="25" id="anc25"></a><span class="line-modified">539             return super.getPort();</span>
540     }
541 
542     @Override
543     protected void close() throws IOException {
544         if (cmdsock != null)
545             cmdsock.close();
546         cmdsock = null;
<a name="26" id="anc26"></a><span class="line-modified">547         super.close();</span>
548     }
549 
550     private String getUserName() {
551         return StaticProperty.userName();
552     }
<a name="27" id="anc27"></a>




553 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
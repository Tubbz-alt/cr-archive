<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/StringBuffer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="String.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/StringBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 98  * See {@link Comparable}, {@link java.util.SortedMap SortedMap}, or
 99  * {@link java.util.SortedSet SortedSet} for more information.
100  *
101  * @author      Arthur van Hoff
102  * @see     java.lang.StringBuilder
103  * @see     java.lang.String
104  * @since   1.0
105  */
106  public final class StringBuffer
107     extends AbstractStringBuilder
108     implements java.io.Serializable, Comparable&lt;StringBuffer&gt;, CharSequence
109 {
110 
111     /**
112      * A cache of the last value returned by toString. Cleared
113      * whenever the StringBuffer is modified.
114      */
115     private transient String toStringCache;
116 
117     /** use serialVersionUID from JDK 1.0.2 for interoperability */

118     static final long serialVersionUID = 3388685877147921107L;
119 
120     /**
121      * Constructs a string buffer with no characters in it and an
122      * initial capacity of 16 characters.
123      */
124     @HotSpotIntrinsicCandidate
125     public StringBuffer() {
126         super(16);
127     }
128 
129     /**
130      * Constructs a string buffer with no characters in it and
131      * the specified initial capacity.
132      *
133      * @param      capacity  the initial capacity.
134      * @throws     NegativeArraySizeException  if the {@code capacity}
135      *             argument is less than {@code 0}.
136      */
137     @HotSpotIntrinsicCandidate
138     public StringBuffer(int capacity) {
139         super(capacity);
140     }
141 
142     /**
143      * Constructs a string buffer initialized to the contents of the
144      * specified string. The initial capacity of the string buffer is
145      * {@code 16} plus the length of the string argument.
146      *
147      * @param   str   the initial contents of the buffer.
148      */
149     @HotSpotIntrinsicCandidate
150     public StringBuffer(String str) {
<span class="line-modified">151         super(str.coder(), str.length(), 16);</span>
<span class="line-removed">152         append(str);</span>
153     }
154 
155     /**
156      * Constructs a string buffer that contains the same characters
157      * as the specified {@code CharSequence}. The initial capacity of
158      * the string buffer is {@code 16} plus the length of the
159      * {@code CharSequence} argument.
160      *
161      * @param      seq   the sequence to copy.
162      * @since 1.5
163      */
164     public StringBuffer(CharSequence seq) {
<span class="line-modified">165         super(String.LATIN1, seq.length(), 16);</span>
<span class="line-removed">166         append(seq);</span>
167     }
168 
169     /**
170      * Compares two {@code StringBuffer} instances lexicographically. This method
171      * follows the same rules for lexicographical comparison as defined in the
172      * {@linkplain java.lang.CharSequence#compare(java.lang.CharSequence,
173      * java.lang.CharSequence)  CharSequence.compare(this, another)} method.
174      *
175      * &lt;p&gt;
176      * For finer-grained, locale-sensitive String comparison, refer to
177      * {@link java.text.Collator}.
178      *
179      * @implNote
180      * This method synchronizes on {@code this}, the current object, but not
181      * {@code StringBuffer another} with which {@code this StringBuffer} is compared.
182      *
183      * @param another the {@code StringBuffer} to be compared with
184      *
185      * @return  the value {@code 0} if this {@code StringBuffer} contains the same
186      * character sequence as that of the argument {@code StringBuffer}; a negative integer
</pre>
<hr />
<pre>
708     public synchronized String toString() {
709         if (toStringCache == null) {
710             return toStringCache =
711                     isLatin1() ? StringLatin1.newString(value, 0, count)
712                                : StringUTF16.newString(value, 0, count);
713         }
714         return new String(toStringCache);
715     }
716 
717     /**
718      * Serializable fields for StringBuffer.
719      *
720      * @serialField value  char[]
721      *              The backing character array of this StringBuffer.
722      * @serialField count int
723      *              The number of characters in this StringBuffer.
724      * @serialField shared  boolean
725      *              A flag indicating whether the backing array is shared.
726      *              The value is ignored upon deserialization.
727      */

728     private static final java.io.ObjectStreamField[] serialPersistentFields =
729     {
730         new java.io.ObjectStreamField(&quot;value&quot;, char[].class),
731         new java.io.ObjectStreamField(&quot;count&quot;, Integer.TYPE),
732         new java.io.ObjectStreamField(&quot;shared&quot;, Boolean.TYPE),
733     };
734 
735     /**
736      * readObject is called to restore the state of the StringBuffer from
737      * a stream.
738      */

739     private synchronized void writeObject(java.io.ObjectOutputStream s)
740         throws java.io.IOException {
741         java.io.ObjectOutputStream.PutField fields = s.putFields();
742         char[] val = new char[capacity()];
743         if (isLatin1()) {
744             StringLatin1.getChars(value, 0, count, val, 0);
745         } else {
746             StringUTF16.getChars(value, 0, count, val, 0);
747         }
748         fields.put(&quot;value&quot;, val);
749         fields.put(&quot;count&quot;, count);
750         fields.put(&quot;shared&quot;, false);
751         s.writeFields();
752     }
753 
754     /**
755      * readObject is called to restore the state of the StringBuffer from
756      * a stream.
757      */

758     private void readObject(java.io.ObjectInputStream s)
759         throws java.io.IOException, ClassNotFoundException {
760         java.io.ObjectInputStream.GetField fields = s.readFields();
761         char[] val = (char[])fields.get(&quot;value&quot;, null);
762         initBytes(val, 0, val.length);
763         count = fields.get(&quot;count&quot;, 0);
764     }
765 
766     synchronized void getBytes(byte dst[], int dstBegin, byte coder) {
767         super.getBytes(dst, dstBegin, coder);
768     }
769 }
</pre>
</td>
<td>
<hr />
<pre>
 98  * See {@link Comparable}, {@link java.util.SortedMap SortedMap}, or
 99  * {@link java.util.SortedSet SortedSet} for more information.
100  *
101  * @author      Arthur van Hoff
102  * @see     java.lang.StringBuilder
103  * @see     java.lang.String
104  * @since   1.0
105  */
106  public final class StringBuffer
107     extends AbstractStringBuilder
108     implements java.io.Serializable, Comparable&lt;StringBuffer&gt;, CharSequence
109 {
110 
111     /**
112      * A cache of the last value returned by toString. Cleared
113      * whenever the StringBuffer is modified.
114      */
115     private transient String toStringCache;
116 
117     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">118     @java.io.Serial</span>
119     static final long serialVersionUID = 3388685877147921107L;
120 
121     /**
122      * Constructs a string buffer with no characters in it and an
123      * initial capacity of 16 characters.
124      */
125     @HotSpotIntrinsicCandidate
126     public StringBuffer() {
127         super(16);
128     }
129 
130     /**
131      * Constructs a string buffer with no characters in it and
132      * the specified initial capacity.
133      *
134      * @param      capacity  the initial capacity.
135      * @throws     NegativeArraySizeException  if the {@code capacity}
136      *             argument is less than {@code 0}.
137      */
138     @HotSpotIntrinsicCandidate
139     public StringBuffer(int capacity) {
140         super(capacity);
141     }
142 
143     /**
144      * Constructs a string buffer initialized to the contents of the
145      * specified string. The initial capacity of the string buffer is
146      * {@code 16} plus the length of the string argument.
147      *
148      * @param   str   the initial contents of the buffer.
149      */
150     @HotSpotIntrinsicCandidate
151     public StringBuffer(String str) {
<span class="line-modified">152         super(str);</span>

153     }
154 
155     /**
156      * Constructs a string buffer that contains the same characters
157      * as the specified {@code CharSequence}. The initial capacity of
158      * the string buffer is {@code 16} plus the length of the
159      * {@code CharSequence} argument.
160      *
161      * @param      seq   the sequence to copy.
162      * @since 1.5
163      */
164     public StringBuffer(CharSequence seq) {
<span class="line-modified">165         super(seq);</span>

166     }
167 
168     /**
169      * Compares two {@code StringBuffer} instances lexicographically. This method
170      * follows the same rules for lexicographical comparison as defined in the
171      * {@linkplain java.lang.CharSequence#compare(java.lang.CharSequence,
172      * java.lang.CharSequence)  CharSequence.compare(this, another)} method.
173      *
174      * &lt;p&gt;
175      * For finer-grained, locale-sensitive String comparison, refer to
176      * {@link java.text.Collator}.
177      *
178      * @implNote
179      * This method synchronizes on {@code this}, the current object, but not
180      * {@code StringBuffer another} with which {@code this StringBuffer} is compared.
181      *
182      * @param another the {@code StringBuffer} to be compared with
183      *
184      * @return  the value {@code 0} if this {@code StringBuffer} contains the same
185      * character sequence as that of the argument {@code StringBuffer}; a negative integer
</pre>
<hr />
<pre>
707     public synchronized String toString() {
708         if (toStringCache == null) {
709             return toStringCache =
710                     isLatin1() ? StringLatin1.newString(value, 0, count)
711                                : StringUTF16.newString(value, 0, count);
712         }
713         return new String(toStringCache);
714     }
715 
716     /**
717      * Serializable fields for StringBuffer.
718      *
719      * @serialField value  char[]
720      *              The backing character array of this StringBuffer.
721      * @serialField count int
722      *              The number of characters in this StringBuffer.
723      * @serialField shared  boolean
724      *              A flag indicating whether the backing array is shared.
725      *              The value is ignored upon deserialization.
726      */
<span class="line-added">727     @java.io.Serial</span>
728     private static final java.io.ObjectStreamField[] serialPersistentFields =
729     {
730         new java.io.ObjectStreamField(&quot;value&quot;, char[].class),
731         new java.io.ObjectStreamField(&quot;count&quot;, Integer.TYPE),
732         new java.io.ObjectStreamField(&quot;shared&quot;, Boolean.TYPE),
733     };
734 
735     /**
736      * readObject is called to restore the state of the StringBuffer from
737      * a stream.
738      */
<span class="line-added">739     @java.io.Serial</span>
740     private synchronized void writeObject(java.io.ObjectOutputStream s)
741         throws java.io.IOException {
742         java.io.ObjectOutputStream.PutField fields = s.putFields();
743         char[] val = new char[capacity()];
744         if (isLatin1()) {
745             StringLatin1.getChars(value, 0, count, val, 0);
746         } else {
747             StringUTF16.getChars(value, 0, count, val, 0);
748         }
749         fields.put(&quot;value&quot;, val);
750         fields.put(&quot;count&quot;, count);
751         fields.put(&quot;shared&quot;, false);
752         s.writeFields();
753     }
754 
755     /**
756      * readObject is called to restore the state of the StringBuffer from
757      * a stream.
758      */
<span class="line-added">759     @java.io.Serial</span>
760     private void readObject(java.io.ObjectInputStream s)
761         throws java.io.IOException, ClassNotFoundException {
762         java.io.ObjectInputStream.GetField fields = s.readFields();
763         char[] val = (char[])fields.get(&quot;value&quot;, null);
764         initBytes(val, 0, val.length);
765         count = fields.get(&quot;count&quot;, 0);
766     }
767 
768     synchronized void getBytes(byte dst[], int dstBegin, byte coder) {
769         super.getBytes(dst, dstBegin, coder);
770     }
771 }
</pre>
</td>
</tr>
</table>
<center><a href="String.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
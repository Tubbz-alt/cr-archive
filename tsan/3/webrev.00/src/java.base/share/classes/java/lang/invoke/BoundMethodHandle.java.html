<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/invoke/BoundMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.vm.annotation.Stable;
 29 import sun.invoke.util.ValueConversions;
 30 
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 
 34 import static java.lang.invoke.LambdaForm.BasicType;
 35 import static java.lang.invoke.LambdaForm.BasicType.*;
 36 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 37 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 38 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 39 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
 40 import static java.lang.invoke.MethodHandleNatives.Constants.*;
 41 import static java.lang.invoke.MethodHandleStatics.newInternalError;
 42 import static java.lang.invoke.MethodHandleStatics.uncaughtException;
 43 
 44 /**
 45  * The flavor of method handle which emulates an invoke instruction
 46  * on a predetermined argument.  The JVM dispatches to the correct method
 47  * when the handle is created, not when it is invoked.
 48  *
 49  * All bound arguments are encapsulated in dedicated species.
 50  */
 51 /*non-public*/
 52 abstract class BoundMethodHandle extends MethodHandle {
 53 
 54     /*non-public*/
 55     BoundMethodHandle(MethodType type, LambdaForm form) {
 56         super(type, form);
 57         assert(speciesData() == speciesDataFor(form));
 58     }
 59 
 60     //
 61     // BMH API and internals
 62     //
 63 
 64     static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {
 65         // for some type signatures, there exist pre-defined concrete BMH classes
 66         try {
 67             switch (xtype) {
 68             case L_TYPE:
 69                 return bindSingle(type, form, x);  // Use known fast path.
 70             case I_TYPE:
 71                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));
 72             case J_TYPE:
 73                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);
 74             case F_TYPE:
 75                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);
 76             case D_TYPE:
 77                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);
 78             default : throw newInternalError(&quot;unexpected xtype: &quot; + xtype);
 79             }
 80         } catch (Throwable t) {
 81             throw uncaughtException(t);
 82         }
 83     }
 84 
 85     /*non-public*/
 86     LambdaFormEditor editor() {
 87         return form.editor();
 88     }
 89 
 90     static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, Object x) {
 91         return Species_L.make(type, form, x);
 92     }
 93 
 94     @Override // there is a default binder in the super class, for &#39;L&#39; types only
 95     /*non-public*/
 96     BoundMethodHandle bindArgumentL(int pos, Object value) {
 97         return editor().bindArgumentL(this, pos, value);
 98     }
 99 
100     /*non-public*/
101     BoundMethodHandle bindArgumentI(int pos, int value) {
102         return editor().bindArgumentI(this, pos, value);
103     }
104     /*non-public*/
105     BoundMethodHandle bindArgumentJ(int pos, long value) {
106         return editor().bindArgumentJ(this, pos, value);
107     }
108     /*non-public*/
109     BoundMethodHandle bindArgumentF(int pos, float value) {
110         return editor().bindArgumentF(this, pos, value);
111     }
112     /*non-public*/
113     BoundMethodHandle bindArgumentD(int pos, double value) {
114         return editor().bindArgumentD(this, pos, value);
115     }
116     @Override
117     BoundMethodHandle rebind() {
118         if (!tooComplex()) {
119             return this;
120         }
121         return makeReinvoker(this);
122     }
123 
124     private boolean tooComplex() {
125         return (fieldCount() &gt; FIELD_COUNT_THRESHOLD ||
126                 form.expressionCount() &gt; FORM_EXPRESSION_THRESHOLD);
127     }
128     private static final int FIELD_COUNT_THRESHOLD = 12;      // largest convenient BMH field count
129     private static final int FORM_EXPRESSION_THRESHOLD = 24;  // largest convenient BMH expression count
130 
131     /**
132      * A reinvoker MH has this form:
133      * {@code lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }}
134      */
135     static BoundMethodHandle makeReinvoker(MethodHandle target) {
136         LambdaForm form = DelegatingMethodHandle.makeReinvokerForm(
137                 target, MethodTypeForm.LF_REBIND,
138                 Species_L.BMH_SPECIES, Species_L.BMH_SPECIES.getterFunction(0));
139         return Species_L.make(target.type(), form, target);
140     }
141 
142     /**
143      * Return the {@link BoundMethodHandle.SpeciesData} instance representing this BMH species. All subclasses must provide a
144      * static field containing this value, and they must accordingly implement this method.
145      */
146     /*non-public*/
147     abstract BoundMethodHandle.SpeciesData speciesData();
148 
149     /*non-public*/
150     static BoundMethodHandle.SpeciesData speciesDataFor(LambdaForm form) {
151         Object c = form.names[0].constraint;
152         if (c instanceof SpeciesData) {
153             return (SpeciesData) c;
154         }
155         // if there is no BMH constraint, then use the null constraint
156         return SPECIALIZER.topSpecies();
157     }
158 
159     /**
160      * Return the number of fields in this BMH.  Equivalent to speciesData().fieldCount().
161      */
162     /*non-public*/
163     final int fieldCount() { return speciesData().fieldCount(); }
164 
165     @Override
166     Object internalProperties() {
167         return &quot;\n&amp; BMH=&quot;+internalValues();
168     }
169 
170     @Override
171     final String internalValues() {
172         int count = fieldCount();
173         if (count == 1) {
174             return &quot;[&quot; + arg(0) + &quot;]&quot;;
175         }
176         StringBuilder sb = new StringBuilder(&quot;[&quot;);
177         for (int i = 0; i &lt; count; ++i) {
178             sb.append(&quot;\n  &quot;).append(i).append(&quot;: ( &quot;).append(arg(i)).append(&quot; )&quot;);
179         }
180         return sb.append(&quot;\n]&quot;).toString();
181     }
182 
183     /*non-public*/
184     final Object arg(int i) {
185         try {
186             Class&lt;?&gt; fieldType = speciesData().fieldTypes().get(i);
187             switch (BasicType.basicType(fieldType)) {
188                 case L_TYPE: return          speciesData().getter(i).invokeBasic(this);
189                 case I_TYPE: return (int)    speciesData().getter(i).invokeBasic(this);
190                 case J_TYPE: return (long)   speciesData().getter(i).invokeBasic(this);
191                 case F_TYPE: return (float)  speciesData().getter(i).invokeBasic(this);
192                 case D_TYPE: return (double) speciesData().getter(i).invokeBasic(this);
193             }
194         } catch (Throwable ex) {
195             throw uncaughtException(ex);
196         }
197         throw new InternalError(&quot;unexpected type: &quot; + speciesData().key()+&quot;.&quot;+i);
198     }
199 
200     //
201     // cloning API
202     //
203 
204     /*non-public*/
205     abstract BoundMethodHandle copyWith(MethodType mt, LambdaForm lf);
206     /*non-public*/
207     abstract BoundMethodHandle copyWithExtendL(MethodType mt, LambdaForm lf, Object narg);
208     /*non-public*/
209     abstract BoundMethodHandle copyWithExtendI(MethodType mt, LambdaForm lf, int    narg);
210     /*non-public*/
211     abstract BoundMethodHandle copyWithExtendJ(MethodType mt, LambdaForm lf, long   narg);
212     /*non-public*/
213     abstract BoundMethodHandle copyWithExtendF(MethodType mt, LambdaForm lf, float  narg);
214     /*non-public*/
215     abstract BoundMethodHandle copyWithExtendD(MethodType mt, LambdaForm lf, double narg);
216 
217     //
218     // concrete BMH classes required to close bootstrap loops
219     //
220 
221     private  // make it private to force users to access the enclosing class first
222     static final class Species_L extends BoundMethodHandle {
223 
224         final Object argL0;
225 
226         private Species_L(MethodType mt, LambdaForm lf, Object argL0) {
227             super(mt, lf);
228             this.argL0 = argL0;
229         }
230 
231         @Override
232         /*non-public*/
233         SpeciesData speciesData() {
234             return BMH_SPECIES;
235         }
236 
237         /*non-public*/
238         static @Stable SpeciesData BMH_SPECIES;
239 
240         /*non-public*/
241         static BoundMethodHandle make(MethodType mt, LambdaForm lf, Object argL0) {
242             return new Species_L(mt, lf, argL0);
243         }
244         @Override
245         /*non-public*/
246         final BoundMethodHandle copyWith(MethodType mt, LambdaForm lf) {
247             return new Species_L(mt, lf, argL0);
248         }
249         @Override
250         /*non-public*/
251         final BoundMethodHandle copyWithExtendL(MethodType mt, LambdaForm lf, Object narg) {
252             try {
253                 return (BoundMethodHandle) BMH_SPECIES.extendWith(L_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
254             } catch (Throwable ex) {
255                 throw uncaughtException(ex);
256             }
257         }
258         @Override
259         /*non-public*/
260         final BoundMethodHandle copyWithExtendI(MethodType mt, LambdaForm lf, int narg) {
261             try {
262                 return (BoundMethodHandle) BMH_SPECIES.extendWith(I_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
263             } catch (Throwable ex) {
264                 throw uncaughtException(ex);
265             }
266         }
267         @Override
268         /*non-public*/
269         final BoundMethodHandle copyWithExtendJ(MethodType mt, LambdaForm lf, long narg) {
270             try {
271                 return (BoundMethodHandle) BMH_SPECIES.extendWith(J_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
272             } catch (Throwable ex) {
273                 throw uncaughtException(ex);
274             }
275         }
276         @Override
277         /*non-public*/
278         final BoundMethodHandle copyWithExtendF(MethodType mt, LambdaForm lf, float narg) {
279             try {
280                 return (BoundMethodHandle) BMH_SPECIES.extendWith(F_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
281             } catch (Throwable ex) {
282                 throw uncaughtException(ex);
283             }
284         }
285         @Override
286         /*non-public*/
287         final BoundMethodHandle copyWithExtendD(MethodType mt, LambdaForm lf, double narg) {
288             try {
289                 return (BoundMethodHandle) BMH_SPECIES.extendWith(D_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
290             } catch (Throwable ex) {
291                 throw uncaughtException(ex);
292             }
293         }
294     }
295 
296     //
297     // BMH species meta-data
298     //
299 
300     /*non-public*/
301     static final class SpeciesData
302             extends ClassSpecializer&lt;BoundMethodHandle, String, SpeciesData&gt;.SpeciesData {
303         // This array is filled in lazily, as new species come into being over time.
304         @Stable final private SpeciesData[] extensions = new SpeciesData[ARG_TYPE_LIMIT];
305 
306         public SpeciesData(Specializer outer, String key) {
307             outer.super(key);
308         }
309 
310         @Override
311         protected String deriveClassName() {
312             String typeString = deriveTypeString();
313             if (typeString.isEmpty()) {
314                 return SimpleMethodHandle.class.getName();
315             }
316             return BoundMethodHandle.class.getName() + &quot;$Species_&quot; + typeString;
317         }
318 
319         @Override
320         protected List&lt;Class&lt;?&gt;&gt; deriveFieldTypes(String key) {
321             ArrayList&lt;Class&lt;?&gt;&gt; types = new ArrayList&lt;&gt;(key.length());
322             for (int i = 0; i &lt; key.length(); i++) {
323                 types.add(basicType(key.charAt(i)).basicTypeClass());
324             }
325             return types;
326         }
327 
328         @Override
329         protected String deriveTypeString() {
330             // (If/when we have to add nominal types, just inherit the more complex default.)
331             return key();
332         }
333 
334         @Override
335         protected MethodHandle deriveTransformHelper(MemberName transform, int whichtm) {
336             if (whichtm == Specializer.TN_COPY_NO_EXTEND) {
337                 return factory();
338             } else if (whichtm &lt; ARG_TYPE_LIMIT) {
339                 return extendWith((byte) whichtm).factory();
340             } else {
341                 throw newInternalError(&quot;bad transform&quot;);
342             }
343         }
344 
345         @Override
346         protected &lt;X&gt; List&lt;X&gt; deriveTransformHelperArguments(MemberName transform, int whichtm, List&lt;X&gt; args, List&lt;X&gt; fields) {
347             assert(verifyTHAargs(transform, whichtm, args, fields));
348             // The rule is really simple:  Keep the first two arguments
349             // the same, then put in the fields, then put any other argument.
350             args.addAll(2, fields);
351             return args;
352         }
353 
354         private boolean verifyTHAargs(MemberName transform, int whichtm, List&lt;?&gt; args, List&lt;?&gt; fields) {
355             assert(transform == Specializer.BMH_TRANSFORMS.get(whichtm));
356             assert(args.size() == transform.getMethodType().parameterCount());
357             assert(fields.size() == this.fieldCount());
358             final int MH_AND_LF = 2;
359             if (whichtm == Specializer.TN_COPY_NO_EXTEND) {
360                 assert(transform.getMethodType().parameterCount() == MH_AND_LF);
361             } else if (whichtm &lt; ARG_TYPE_LIMIT) {
362                 assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);
363                 final BasicType type = basicType((byte) whichtm);
364                 assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());
365             } else {
366                 return false;
367             }
368             return true;
369         }
370 
371         /*non-public*/
372         SpeciesData extendWith(byte typeNum) {
373             SpeciesData sd = extensions[typeNum];
374             if (sd != null)  return sd;
375             sd = SPECIALIZER.findSpecies(key() + BasicType.basicType(typeNum).basicTypeChar());
376             extensions[typeNum] = sd;
377             return sd;
378         }
379     }
380 
381     /*non-public*/
382     static final Specializer SPECIALIZER = new Specializer();
383     static {
384         SimpleMethodHandle.BMH_SPECIES = BoundMethodHandle.SPECIALIZER.findSpecies(&quot;&quot;);
385         Species_L.BMH_SPECIES = BoundMethodHandle.SPECIALIZER.findSpecies(&quot;L&quot;);
386     }
387 
388     /*non-public*/
389     static final class Specializer
390             extends ClassSpecializer&lt;BoundMethodHandle, String, SpeciesData&gt; {
391 
392         private static final MemberName SPECIES_DATA_ACCESSOR;
393 
394         static {
395             try {
396                 SPECIES_DATA_ACCESSOR = IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BoundMethodHandle.class,
397                         &quot;speciesData&quot;, MethodType.methodType(BoundMethodHandle.SpeciesData.class));
398             } catch (ReflectiveOperationException ex) {
399                 throw newInternalError(&quot;Bootstrap link error&quot;, ex);
400             }
401         }
402 
403         private Specializer() {
404             super(  // Reified type parameters:
405                     BoundMethodHandle.class, String.class, BoundMethodHandle.SpeciesData.class,
406                     // Principal constructor type:
407                     MethodType.methodType(void.class, MethodType.class, LambdaForm.class),
408                     // Required linkage between class and species:
409                     SPECIES_DATA_ACCESSOR,
410                     &quot;BMH_SPECIES&quot;,
411                     BMH_TRANSFORMS);
412         }
413 
414         @Override
415         protected String topSpeciesKey() {
416             return &quot;&quot;;
417         }
418 
419         @Override
420         protected BoundMethodHandle.SpeciesData newSpeciesData(String key) {
421             return new BoundMethodHandle.SpeciesData(this, key);
422         }
423 
424         static final List&lt;MemberName&gt; BMH_TRANSFORMS;
425         static final int TN_COPY_NO_EXTEND = V_TYPE_NUM;
426         static {
427             final Class&lt;BoundMethodHandle&gt; BMH = BoundMethodHandle.class;
428             // copyWithExtendLIJFD + copyWith
429             try {
430                 BMH_TRANSFORMS = List.of(
431                         IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BMH, &quot;copyWithExtendL&quot;, MethodType.methodType(BMH, MethodType.class, LambdaForm.class, Object.class)),
432                         IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BMH, &quot;copyWithExtendI&quot;, MethodType.methodType(BMH, MethodType.class, LambdaForm.class, int.class)),
433                         IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BMH, &quot;copyWithExtendJ&quot;, MethodType.methodType(BMH, MethodType.class, LambdaForm.class, long.class)),
434                         IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BMH, &quot;copyWithExtendF&quot;, MethodType.methodType(BMH, MethodType.class, LambdaForm.class, float.class)),
435                         IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BMH, &quot;copyWithExtendD&quot;, MethodType.methodType(BMH, MethodType.class, LambdaForm.class, double.class)),
436                         IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BMH, &quot;copyWith&quot;, MethodType.methodType(BMH, MethodType.class, LambdaForm.class))
437                 );
438             } catch (ReflectiveOperationException ex) {
439                 throw newInternalError(&quot;Failed resolving copyWith methods&quot;, ex);
440             }
441 
442             // as it happens, there is one transform per BasicType including V_TYPE
443             assert(BMH_TRANSFORMS.size() == TYPE_LIMIT);
444         }
445 
446         /**
447          * Generation of concrete BMH classes.
448          *
449          * A concrete BMH species is fit for binding a number of values adhering to a
450          * given type pattern. Reference types are erased.
451          *
452          * BMH species are cached by type pattern.
453          *
454          * A BMH species has a number of fields with the concrete (possibly erased) types of
455          * bound values. Setters are provided as an API in BMH. Getters are exposed as MHs,
456          * which can be included as names in lambda forms.
457          */
458         class Factory extends ClassSpecializer&lt;BoundMethodHandle, String, BoundMethodHandle.SpeciesData&gt;.Factory {
459             @Override
460             protected String chooseFieldName(Class&lt;?&gt; type, int index) {
461                 return &quot;arg&quot; + super.chooseFieldName(type, index);
462             }
463         }
464 
465         @Override
466         protected Factory makeFactory() {
467             return new Factory();
468         }
469       }
470 
471     static SpeciesData speciesData_L()      { return Species_L.BMH_SPECIES; }
472     static SpeciesData speciesData_LL()     { return SPECIALIZER.findSpecies(&quot;LL&quot;); }
473     static SpeciesData speciesData_LLL()    { return SPECIALIZER.findSpecies(&quot;LLL&quot;); }
474     static SpeciesData speciesData_LLLL()   { return SPECIALIZER.findSpecies(&quot;LLLL&quot;); }
475     static SpeciesData speciesData_LLLLL()  { return SPECIALIZER.findSpecies(&quot;LLLLL&quot;); }
476 }
    </pre>
  </body>
</html>
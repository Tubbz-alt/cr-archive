<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/SocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketImplFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 

 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
<span class="line-modified"> 31 import java.io.FileDescriptor;</span>


 32 import java.util.Set;
 33 




 34 /**
 35  * The abstract class {@code SocketImpl} is a common superclass
 36  * of all classes that actually implement sockets. It is used to
 37  * create both client and server sockets.
<span class="line-modified"> 38  * &lt;p&gt;</span>
<span class="line-modified"> 39  * A &quot;plain&quot; socket implements these methods exactly as</span>
<span class="line-modified"> 40  * described, without attempting to go through a firewall or proxy.</span>














 41  *
 42  * @author  unascribed
 43  * @since   1.0
 44  */
 45 public abstract class SocketImpl implements SocketOptions {








 46     /**
<span class="line-modified"> 47      * The actual Socket object.</span>
 48      */
<span class="line-modified"> 49     Socket socket = null;</span>
<span class="line-modified"> 50     ServerSocket serverSocket = null;</span>






 51 
 52     /**
 53      * The file descriptor object for this socket.
 54      */
 55     protected FileDescriptor fd;
 56 
 57     /**
 58      * The IP address of the remote end of this socket.
 59      */
 60     protected InetAddress address;
 61 
 62     /**
 63      * The port number on the remote host to which this socket is connected.
 64      */
 65     protected int port;
 66 
 67     /**
 68      * The local port number to which this socket is connected.
 69      */
 70     protected int localport;
 71 





 72     /**
 73      * Creates either a stream or a datagram socket.
 74      *
 75      * @param      stream   if {@code true}, create a stream socket;
 76      *                      otherwise, create a datagram socket.
<span class="line-modified"> 77      * @exception  IOException  if an I/O error occurs while creating the</span>
 78      *               socket.
 79      */
 80     protected abstract void create(boolean stream) throws IOException;
 81 
 82     /**
 83      * Connects this socket to the specified port on the named host.
 84      *
 85      * @param      host   the name of the remote host.
 86      * @param      port   the port number.
<span class="line-modified"> 87      * @exception  IOException  if an I/O error occurs when connecting to the</span>
 88      *               remote host.
 89      */
 90     protected abstract void connect(String host, int port) throws IOException;
 91 
 92     /**
 93      * Connects this socket to the specified port number on the specified host.
 94      *
 95      * @param      address   the IP address of the remote host.
 96      * @param      port      the port number.
<span class="line-modified"> 97      * @exception  IOException  if an I/O error occurs when attempting a</span>
 98      *               connection.
 99      */
100     protected abstract void connect(InetAddress address, int port) throws IOException;
101 
102     /**
103      * Connects this socket to the specified port number on the specified host.
104      * A timeout of zero is interpreted as an infinite timeout. The connection
105      * will then block until established or an error occurs.
106      *
107      * @param      address   the Socket address of the remote host.
108      * @param     timeout  the timeout value, in milliseconds, or zero for no timeout.
<span class="line-modified">109      * @exception  IOException  if an I/O error occurs when attempting a</span>
110      *               connection.
111      * @since 1.4
112      */
113     protected abstract void connect(SocketAddress address, int timeout) throws IOException;
114 
115     /**
116      * Binds this socket to the specified local IP address and port number.
117      *
118      * @param      host   an IP address that belongs to a local interface.
119      * @param      port   the port number.
<span class="line-modified">120      * @exception  IOException  if an I/O error occurs when binding this socket.</span>
121      */
122     protected abstract void bind(InetAddress host, int port) throws IOException;
123 
124     /**
125      * Sets the maximum queue length for incoming connection indications
126      * (a request to connect) to the {@code count} argument. If a
127      * connection indication arrives when the queue is full, the
128      * connection is refused.
129      *
130      * @param      backlog   the maximum length of the queue.
<span class="line-modified">131      * @exception  IOException  if an I/O error occurs when creating the queue.</span>
132      */
133     protected abstract void listen(int backlog) throws IOException;
134 
135     /**
136      * Accepts a connection.
137      *
138      * @param      s   the accepted connection.
<span class="line-modified">139      * @exception  IOException  if an I/O error occurs when accepting the</span>
140      *               connection.
141      */
142     protected abstract void accept(SocketImpl s) throws IOException;
143 
144     /**
145      * Returns an input stream for this socket.
146      *
147      * @return     a stream for reading from this socket.
<span class="line-modified">148      * @exception  IOException  if an I/O error occurs when creating the</span>
149      *               input stream.
150     */
151     protected abstract InputStream getInputStream() throws IOException;
152 
153     /**
154      * Returns an output stream for this socket.
155      *
156      * @return     an output stream for writing to this socket.
<span class="line-modified">157      * @exception  IOException  if an I/O error occurs when creating the</span>
158      *               output stream.
159      */
160     protected abstract OutputStream getOutputStream() throws IOException;
161 
162     /**
163      * Returns the number of bytes that can be read from this socket
164      * without blocking.
165      *
166      * @return     the number of bytes that can be read from this socket
167      *             without blocking.
<span class="line-modified">168      * @exception  IOException  if an I/O error occurs when determining the</span>
169      *               number of bytes available.
170      */
171     protected abstract int available() throws IOException;
172 
173     /**
174      * Closes this socket.
175      *
<span class="line-modified">176      * @exception  IOException  if an I/O error occurs when closing this socket.</span>
177      */
178     protected abstract void close() throws IOException;
179 









180     /**
181      * Places the input stream for this socket at &quot;end of stream&quot;.
182      * Any data sent to this socket is acknowledged and then
183      * silently discarded.
184      *
185      * If you read from a socket input stream after invoking this method on the
186      * socket, the stream&#39;s {@code available} method will return 0, and its
187      * {@code read} methods will return {@code -1} (end of stream).
188      *
<span class="line-modified">189      * @exception IOException if an I/O error occurs when shutting down this</span>
190      * socket.
191      * @see java.net.Socket#shutdownOutput()
192      * @see java.net.Socket#close()
193      * @see java.net.Socket#setSoLinger(boolean, int)
194      * @since 1.3
195      */
196     protected void shutdownInput() throws IOException {
197       throw new IOException(&quot;Method not implemented!&quot;);
198     }
199 
200     /**
201      * Disables the output stream for this socket.
202      * For a TCP socket, any previously written data will be sent
203      * followed by TCP&#39;s normal connection termination sequence.
204      *
205      * If you write to a socket output stream after invoking
206      * shutdownOutput() on the socket, the stream will throw
207      * an IOException.
208      *
<span class="line-modified">209      * @exception IOException if an I/O error occurs when shutting down this</span>
210      * socket.
211      * @see java.net.Socket#shutdownInput()
212      * @see java.net.Socket#close()
213      * @see java.net.Socket#setSoLinger(boolean, int)
214      * @since 1.3
215      */
216     protected void shutdownOutput() throws IOException {
217       throw new IOException(&quot;Method not implemented!&quot;);
218     }
219 
220     /**
221      * Returns the value of this socket&#39;s {@code fd} field.
222      *
223      * @return  the value of this socket&#39;s {@code fd} field.
224      * @see     java.net.SocketImpl#fd
225      */
226     protected FileDescriptor getFileDescriptor() {
227         return fd;
228     }
229 
</pre>
<hr />
<pre>
247         return port;
248     }
249 
250     /**
251      * Returns whether or not this SocketImpl supports sending
252      * urgent data. By default, false is returned
253      * unless the method is overridden in a sub-class
254      *
255      * @return  true if urgent data supported
256      * @see     java.net.SocketImpl#address
257      * @since 1.4
258      */
259     protected boolean supportsUrgentData () {
260         return false; // must be overridden in sub-class
261     }
262 
263     /**
264      * Send one byte of urgent data on the socket.
265      * The byte to be sent is the low eight bits of the parameter
266      * @param data The byte of data to send
<span class="line-modified">267      * @exception IOException if there is an error</span>
268      *  sending the data.
269      * @since 1.4
270      */
271     protected abstract void sendUrgentData (int data) throws IOException;
272 
273     /**
274      * Returns the value of this socket&#39;s {@code localport} field.
275      *
276      * @return  the value of this socket&#39;s {@code localport} field.
277      * @see     java.net.SocketImpl#localport
278      */
279     protected int getLocalPort() {
280         return localport;
281     }
282 
<span class="line-removed">283     void setSocket(Socket soc) {</span>
<span class="line-removed">284         this.socket = soc;</span>
<span class="line-removed">285     }</span>
<span class="line-removed">286 </span>
<span class="line-removed">287     Socket getSocket() {</span>
<span class="line-removed">288         return socket;</span>
<span class="line-removed">289     }</span>
<span class="line-removed">290 </span>
<span class="line-removed">291     void setServerSocket(ServerSocket soc) {</span>
<span class="line-removed">292         this.serverSocket = soc;</span>
<span class="line-removed">293     }</span>
<span class="line-removed">294 </span>
<span class="line-removed">295     ServerSocket getServerSocket() {</span>
<span class="line-removed">296         return serverSocket;</span>
<span class="line-removed">297     }</span>
<span class="line-removed">298 </span>
299     /**
300      * Returns the address and port of this socket as a {@code String}.
301      *
302      * @return  a string representation of this socket.
303      */
304     public String toString() {
305         return &quot;Socket[addr=&quot; + getInetAddress() +
306             &quot;,port=&quot; + getPort() + &quot;,localport=&quot; + getLocalPort()  + &quot;]&quot;;
307     }
308 
<span class="line-modified">309     void reset() throws IOException {</span>

310         address = null;
311         port = 0;
312         localport = 0;
313     }
314 
315     /**
316      * Sets performance preferences for this socket.
317      *
318      * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
319      * may offer alternative protocols which have different performance
320      * characteristics than TCP/IP.  This method allows the application to
321      * express its own preferences as to how these tradeoffs should be made
322      * when the implementation chooses from the available protocols.
323      *
324      * &lt;p&gt; Performance preferences are described by three integers
325      * whose values indicate the relative importance of short connection time,
326      * low latency, and high bandwidth.  The absolute values of the integers
327      * are irrelevant; in order to choose a protocol the values are simply
328      * compared, with larger values indicating stronger preferences. Negative
329      * values represent a lower priority than positive values. If the
</pre>
<hr />
<pre>
343      * @param  latency
344      *         An {@code int} expressing the relative importance of low
345      *         latency
346      *
347      * @param  bandwidth
348      *         An {@code int} expressing the relative importance of high
349      *         bandwidth
350      *
351      * @since 1.5
352      */
353     protected void setPerformancePreferences(int connectionTime,
354                                           int latency,
355                                           int bandwidth)
356     {
357         /* Not implemented yet */
358     }
359 
360     /**
361      * Called to set a socket option.
362      *






363      * @param &lt;T&gt; The type of the socket option value
364      * @param name The socket option
<span class="line-removed">365      *</span>
366      * @param value The value of the socket option. A value of {@code null}
367      *              may be valid for some options.
368      *
369      * @throws UnsupportedOperationException if the SocketImpl does not
370      *         support the option
<span class="line-modified">371      *</span>
<span class="line-modified">372      * @throws IOException if an I/O error occurs, or if the socket is closed.</span>


373      *
374      * @since 9
375      */
376     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="line-modified">377         if (name == StandardSocketOptions.SO_KEEPALIVE &amp;&amp;</span>
<span class="line-modified">378                 (getSocket() != null)) {</span>
<span class="line-removed">379             setOption(SocketOptions.SO_KEEPALIVE, value);</span>
<span class="line-removed">380         } else if (name == StandardSocketOptions.SO_SNDBUF &amp;&amp;</span>
<span class="line-removed">381                 (getSocket() != null)) {</span>
<span class="line-removed">382             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-removed">383         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-removed">384             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-removed">385         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-removed">386             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-removed">387         } else if (name == StandardSocketOptions.SO_REUSEPORT &amp;&amp;</span>
<span class="line-removed">388             supportedOptions().contains(name)) {</span>
<span class="line-removed">389             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-removed">390         } else if (name == StandardSocketOptions.SO_LINGER &amp;&amp;</span>
<span class="line-removed">391                 (getSocket() != null)) {</span>
<span class="line-removed">392             setOption(SocketOptions.SO_LINGER, value);</span>
<span class="line-removed">393         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-removed">394             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-removed">395         } else if (name == StandardSocketOptions.TCP_NODELAY &amp;&amp;</span>
<span class="line-removed">396                 (getSocket() != null)) {</span>
<span class="line-removed">397             setOption(SocketOptions.TCP_NODELAY, value);</span>
<span class="line-removed">398         } else {</span>
<span class="line-removed">399             throw new UnsupportedOperationException(&quot;unsupported option&quot;);</span>
<span class="line-removed">400         }</span>
401     }
402 
403     /**
404      * Called to get a socket option.
405      *






406      * @param &lt;T&gt; The type of the socket option value
407      * @param name The socket option
<span class="line-removed">408      *</span>
409      * @return the value of the named option
410      *
411      * @throws UnsupportedOperationException if the SocketImpl does not
<span class="line-modified">412      *         support the option.</span>
<span class="line-modified">413      *</span>
<span class="line-modified">414      * @throws IOException if an I/O error occurs, or if the socket is closed.</span>
415      *
416      * @since 9
417      */
<span class="line-removed">418     @SuppressWarnings(&quot;unchecked&quot;)</span>
419     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">420         if (name == StandardSocketOptions.SO_KEEPALIVE &amp;&amp;</span>
<span class="line-modified">421                 (getSocket() != null)) {</span>
<span class="line-removed">422             return (T)getOption(SocketOptions.SO_KEEPALIVE);</span>
<span class="line-removed">423         } else if (name == StandardSocketOptions.SO_SNDBUF &amp;&amp;</span>
<span class="line-removed">424                 (getSocket() != null)) {</span>
<span class="line-removed">425             return (T)getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-removed">426         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-removed">427             return (T)getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-removed">428         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-removed">429             return (T)getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-removed">430         } else if (name == StandardSocketOptions.SO_REUSEPORT &amp;&amp;</span>
<span class="line-removed">431             supportedOptions().contains(name)) {</span>
<span class="line-removed">432             return (T)getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-removed">433         } else if (name == StandardSocketOptions.SO_LINGER &amp;&amp;</span>
<span class="line-removed">434                 (getSocket() != null)) {</span>
<span class="line-removed">435             return (T)getOption(SocketOptions.SO_LINGER);</span>
<span class="line-removed">436         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-removed">437             return (T)getOption(SocketOptions.IP_TOS);</span>
<span class="line-removed">438         } else if (name == StandardSocketOptions.TCP_NODELAY &amp;&amp;</span>
<span class="line-removed">439                 (getSocket() != null)) {</span>
<span class="line-removed">440             return (T)getOption(SocketOptions.TCP_NODELAY);</span>
<span class="line-removed">441         } else {</span>
<span class="line-removed">442             throw new UnsupportedOperationException(&quot;unsupported option&quot;);</span>
<span class="line-removed">443         }</span>
444     }
445 
<span class="line-modified">446     private static final Set&lt;SocketOption&lt;?&gt;&gt; socketOptions;</span>
<span class="line-modified">447 </span>
<span class="line-modified">448     private static final Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions;</span>
<span class="line-modified">449 </span>
<span class="line-modified">450     static {</span>
<span class="line-modified">451         socketOptions = Set.of(StandardSocketOptions.SO_KEEPALIVE,</span>
<span class="line-modified">452                                StandardSocketOptions.SO_SNDBUF,</span>
<span class="line-modified">453                                StandardSocketOptions.SO_RCVBUF,</span>
<span class="line-modified">454                                StandardSocketOptions.SO_REUSEADDR,</span>
<span class="line-modified">455                                StandardSocketOptions.SO_LINGER,</span>
<span class="line-modified">456                                StandardSocketOptions.IP_TOS,</span>
<span class="line-removed">457                                StandardSocketOptions.TCP_NODELAY);</span>
<span class="line-removed">458 </span>
<span class="line-removed">459         serverSocketOptions = Set.of(StandardSocketOptions.SO_RCVBUF,</span>
<span class="line-removed">460                                      StandardSocketOptions.SO_REUSEADDR,</span>
<span class="line-removed">461                                      StandardSocketOptions.IP_TOS);</span>
462     }
463 
464     /**
465      * Returns a set of SocketOptions supported by this impl
466      * and by this impl&#39;s socket (Socket or ServerSocket)
467      *




468      * @return a Set of SocketOptions
469      *
470      * @since 9
471      */
472     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">473         if (getSocket() != null) {</span>
<span class="line-removed">474             return socketOptions;</span>
<span class="line-removed">475         } else {</span>
<span class="line-removed">476             return serverSocketOptions;</span>
<span class="line-removed">477         }</span>
478     }
479 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
<span class="line-added"> 28 import java.io.FileDescriptor;</span>
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
<span class="line-modified"> 32 import java.security.AccessController;</span>
<span class="line-added"> 33 import java.security.PrivilegedAction;</span>
<span class="line-added"> 34 import java.util.Objects;</span>
 35 import java.util.Set;
 36 
<span class="line-added"> 37 import sun.net.NetProperties;</span>
<span class="line-added"> 38 import sun.net.PlatformSocketImpl;</span>
<span class="line-added"> 39 import sun.nio.ch.NioSocketImpl;</span>
<span class="line-added"> 40 </span>
 41 /**
 42  * The abstract class {@code SocketImpl} is a common superclass
 43  * of all classes that actually implement sockets. It is used to
 44  * create both client and server sockets.
<span class="line-modified"> 45  *</span>
<span class="line-modified"> 46  * @implNote Client and server sockets created with the {@code Socket} and</span>
<span class="line-modified"> 47  * {@code SocketServer} public constructors create a system-default</span>
<span class="line-added"> 48  * {@code SocketImpl}. The JDK historically used a {@code SocketImpl}</span>
<span class="line-added"> 49  * implementation type named &quot;PlainSocketImpl&quot; that has since been replaced by a</span>
<span class="line-added"> 50  * newer implementation. The JDK continues to ship with the older implementation</span>
<span class="line-added"> 51  * to allow code to run that depends on unspecified behavior that differs between</span>
<span class="line-added"> 52  * the old and new implementations. The old implementation will be used if the</span>
<span class="line-added"> 53  * Java virtual machine is started with the system property {@systemProperty</span>
<span class="line-added"> 54  * jdk.net.usePlainSocketImpl} set to use the old implementation. It may also be</span>
<span class="line-added"> 55  * set in the JDK&#39;s network configuration file, located in {@code</span>
<span class="line-added"> 56  * ${java.home}/conf/net.properties}. The value of the property is the string</span>
<span class="line-added"> 57  * representation of a boolean. If set without a value then it defaults to {@code</span>
<span class="line-added"> 58  * true}, hence running with {@code -Djdk.net.usePlainSocketImpl} or {@code</span>
<span class="line-added"> 59  * -Djdk.net.usePlainSocketImpl=true} will configure the Java virtual machine</span>
<span class="line-added"> 60  * to use the old implementation. The property and old implementation will be</span>
<span class="line-added"> 61  * removed in a future version.</span>
 62  *
 63  * @author  unascribed
 64  * @since   1.0
 65  */
 66 public abstract class SocketImpl implements SocketOptions {
<span class="line-added"> 67     private static final boolean USE_PLAINSOCKETIMPL = usePlainSocketImpl();</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69     private static boolean usePlainSocketImpl() {</span>
<span class="line-added"> 70         PrivilegedAction&lt;String&gt; pa = () -&gt; NetProperties.get(&quot;jdk.net.usePlainSocketImpl&quot;);</span>
<span class="line-added"> 71         String s = AccessController.doPrivileged(pa);</span>
<span class="line-added"> 72         return (s != null) &amp;&amp; !s.equalsIgnoreCase(&quot;false&quot;);</span>
<span class="line-added"> 73     }</span>
<span class="line-added"> 74 </span>
 75     /**
<span class="line-modified"> 76      * Creates an instance of platform&#39;s SocketImpl</span>
 77      */
<span class="line-modified"> 78     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified"> 79     static &lt;S extends SocketImpl &amp; PlatformSocketImpl&gt; S createPlatformSocketImpl(boolean server) {</span>
<span class="line-added"> 80         if (USE_PLAINSOCKETIMPL) {</span>
<span class="line-added"> 81             return (S) new PlainSocketImpl(server);</span>
<span class="line-added"> 82         } else {</span>
<span class="line-added"> 83             return (S) new NioSocketImpl(server);</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85     }</span>
 86 
 87     /**
 88      * The file descriptor object for this socket.
 89      */
 90     protected FileDescriptor fd;
 91 
 92     /**
 93      * The IP address of the remote end of this socket.
 94      */
 95     protected InetAddress address;
 96 
 97     /**
 98      * The port number on the remote host to which this socket is connected.
 99      */
100     protected int port;
101 
102     /**
103      * The local port number to which this socket is connected.
104      */
105     protected int localport;
106 
<span class="line-added">107     /**</span>
<span class="line-added">108      * Initialize a new instance of this class</span>
<span class="line-added">109      */</span>
<span class="line-added">110     public SocketImpl() { }</span>
<span class="line-added">111 </span>
112     /**
113      * Creates either a stream or a datagram socket.
114      *
115      * @param      stream   if {@code true}, create a stream socket;
116      *                      otherwise, create a datagram socket.
<span class="line-modified">117      * @throws     IOException  if an I/O error occurs while creating the</span>
118      *               socket.
119      */
120     protected abstract void create(boolean stream) throws IOException;
121 
122     /**
123      * Connects this socket to the specified port on the named host.
124      *
125      * @param      host   the name of the remote host.
126      * @param      port   the port number.
<span class="line-modified">127      * @throws     IOException  if an I/O error occurs when connecting to the</span>
128      *               remote host.
129      */
130     protected abstract void connect(String host, int port) throws IOException;
131 
132     /**
133      * Connects this socket to the specified port number on the specified host.
134      *
135      * @param      address   the IP address of the remote host.
136      * @param      port      the port number.
<span class="line-modified">137      * @throws     IOException  if an I/O error occurs when attempting a</span>
138      *               connection.
139      */
140     protected abstract void connect(InetAddress address, int port) throws IOException;
141 
142     /**
143      * Connects this socket to the specified port number on the specified host.
144      * A timeout of zero is interpreted as an infinite timeout. The connection
145      * will then block until established or an error occurs.
146      *
147      * @param      address   the Socket address of the remote host.
148      * @param     timeout  the timeout value, in milliseconds, or zero for no timeout.
<span class="line-modified">149      * @throws     IOException  if an I/O error occurs when attempting a</span>
150      *               connection.
151      * @since 1.4
152      */
153     protected abstract void connect(SocketAddress address, int timeout) throws IOException;
154 
155     /**
156      * Binds this socket to the specified local IP address and port number.
157      *
158      * @param      host   an IP address that belongs to a local interface.
159      * @param      port   the port number.
<span class="line-modified">160      * @throws     IOException  if an I/O error occurs when binding this socket.</span>
161      */
162     protected abstract void bind(InetAddress host, int port) throws IOException;
163 
164     /**
165      * Sets the maximum queue length for incoming connection indications
166      * (a request to connect) to the {@code count} argument. If a
167      * connection indication arrives when the queue is full, the
168      * connection is refused.
169      *
170      * @param      backlog   the maximum length of the queue.
<span class="line-modified">171      * @throws     IOException  if an I/O error occurs when creating the queue.</span>
172      */
173     protected abstract void listen(int backlog) throws IOException;
174 
175     /**
176      * Accepts a connection.
177      *
178      * @param      s   the accepted connection.
<span class="line-modified">179      * @throws     IOException  if an I/O error occurs when accepting the</span>
180      *               connection.
181      */
182     protected abstract void accept(SocketImpl s) throws IOException;
183 
184     /**
185      * Returns an input stream for this socket.
186      *
187      * @return     a stream for reading from this socket.
<span class="line-modified">188      * @throws     IOException  if an I/O error occurs when creating the</span>
189      *               input stream.
190     */
191     protected abstract InputStream getInputStream() throws IOException;
192 
193     /**
194      * Returns an output stream for this socket.
195      *
196      * @return     an output stream for writing to this socket.
<span class="line-modified">197      * @throws     IOException  if an I/O error occurs when creating the</span>
198      *               output stream.
199      */
200     protected abstract OutputStream getOutputStream() throws IOException;
201 
202     /**
203      * Returns the number of bytes that can be read from this socket
204      * without blocking.
205      *
206      * @return     the number of bytes that can be read from this socket
207      *             without blocking.
<span class="line-modified">208      * @throws     IOException  if an I/O error occurs when determining the</span>
209      *               number of bytes available.
210      */
211     protected abstract int available() throws IOException;
212 
213     /**
214      * Closes this socket.
215      *
<span class="line-modified">216      * @throws     IOException  if an I/O error occurs when closing this socket.</span>
217      */
218     protected abstract void close() throws IOException;
219 
<span class="line-added">220     /**</span>
<span class="line-added">221      * Closes this socket, ignoring any IOException that is thrown by close.</span>
<span class="line-added">222      */</span>
<span class="line-added">223     void closeQuietly() {</span>
<span class="line-added">224         try {</span>
<span class="line-added">225             close();</span>
<span class="line-added">226         } catch (IOException ignore) { }</span>
<span class="line-added">227     }</span>
<span class="line-added">228 </span>
229     /**
230      * Places the input stream for this socket at &quot;end of stream&quot;.
231      * Any data sent to this socket is acknowledged and then
232      * silently discarded.
233      *
234      * If you read from a socket input stream after invoking this method on the
235      * socket, the stream&#39;s {@code available} method will return 0, and its
236      * {@code read} methods will return {@code -1} (end of stream).
237      *
<span class="line-modified">238      * @throws    IOException if an I/O error occurs when shutting down this</span>
239      * socket.
240      * @see java.net.Socket#shutdownOutput()
241      * @see java.net.Socket#close()
242      * @see java.net.Socket#setSoLinger(boolean, int)
243      * @since 1.3
244      */
245     protected void shutdownInput() throws IOException {
246       throw new IOException(&quot;Method not implemented!&quot;);
247     }
248 
249     /**
250      * Disables the output stream for this socket.
251      * For a TCP socket, any previously written data will be sent
252      * followed by TCP&#39;s normal connection termination sequence.
253      *
254      * If you write to a socket output stream after invoking
255      * shutdownOutput() on the socket, the stream will throw
256      * an IOException.
257      *
<span class="line-modified">258      * @throws    IOException if an I/O error occurs when shutting down this</span>
259      * socket.
260      * @see java.net.Socket#shutdownInput()
261      * @see java.net.Socket#close()
262      * @see java.net.Socket#setSoLinger(boolean, int)
263      * @since 1.3
264      */
265     protected void shutdownOutput() throws IOException {
266       throw new IOException(&quot;Method not implemented!&quot;);
267     }
268 
269     /**
270      * Returns the value of this socket&#39;s {@code fd} field.
271      *
272      * @return  the value of this socket&#39;s {@code fd} field.
273      * @see     java.net.SocketImpl#fd
274      */
275     protected FileDescriptor getFileDescriptor() {
276         return fd;
277     }
278 
</pre>
<hr />
<pre>
296         return port;
297     }
298 
299     /**
300      * Returns whether or not this SocketImpl supports sending
301      * urgent data. By default, false is returned
302      * unless the method is overridden in a sub-class
303      *
304      * @return  true if urgent data supported
305      * @see     java.net.SocketImpl#address
306      * @since 1.4
307      */
308     protected boolean supportsUrgentData () {
309         return false; // must be overridden in sub-class
310     }
311 
312     /**
313      * Send one byte of urgent data on the socket.
314      * The byte to be sent is the low eight bits of the parameter
315      * @param data The byte of data to send
<span class="line-modified">316      * @throws    IOException if there is an error</span>
317      *  sending the data.
318      * @since 1.4
319      */
320     protected abstract void sendUrgentData (int data) throws IOException;
321 
322     /**
323      * Returns the value of this socket&#39;s {@code localport} field.
324      *
325      * @return  the value of this socket&#39;s {@code localport} field.
326      * @see     java.net.SocketImpl#localport
327      */
328     protected int getLocalPort() {
329         return localport;
330     }
331 
















332     /**
333      * Returns the address and port of this socket as a {@code String}.
334      *
335      * @return  a string representation of this socket.
336      */
337     public String toString() {
338         return &quot;Socket[addr=&quot; + getInetAddress() +
339             &quot;,port=&quot; + getPort() + &quot;,localport=&quot; + getLocalPort()  + &quot;]&quot;;
340     }
341 
<span class="line-modified">342     void reset() {</span>
<span class="line-added">343         fd = null;</span>
344         address = null;
345         port = 0;
346         localport = 0;
347     }
348 
349     /**
350      * Sets performance preferences for this socket.
351      *
352      * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
353      * may offer alternative protocols which have different performance
354      * characteristics than TCP/IP.  This method allows the application to
355      * express its own preferences as to how these tradeoffs should be made
356      * when the implementation chooses from the available protocols.
357      *
358      * &lt;p&gt; Performance preferences are described by three integers
359      * whose values indicate the relative importance of short connection time,
360      * low latency, and high bandwidth.  The absolute values of the integers
361      * are irrelevant; in order to choose a protocol the values are simply
362      * compared, with larger values indicating stronger preferences. Negative
363      * values represent a lower priority than positive values. If the
</pre>
<hr />
<pre>
377      * @param  latency
378      *         An {@code int} expressing the relative importance of low
379      *         latency
380      *
381      * @param  bandwidth
382      *         An {@code int} expressing the relative importance of high
383      *         bandwidth
384      *
385      * @since 1.5
386      */
387     protected void setPerformancePreferences(int connectionTime,
388                                           int latency,
389                                           int bandwidth)
390     {
391         /* Not implemented yet */
392     }
393 
394     /**
395      * Called to set a socket option.
396      *
<span class="line-added">397      * @implSpec</span>
<span class="line-added">398      * The default implementation of this method first checks that the given</span>
<span class="line-added">399      * socket option {@code name} is not null, then throws {@code</span>
<span class="line-added">400      * UnsupportedOperationException}. Subclasses should override this method</span>
<span class="line-added">401      * with an appropriate implementation.</span>
<span class="line-added">402      *</span>
403      * @param &lt;T&gt; The type of the socket option value
404      * @param name The socket option

405      * @param value The value of the socket option. A value of {@code null}
406      *              may be valid for some options.
407      *
408      * @throws UnsupportedOperationException if the SocketImpl does not
409      *         support the option
<span class="line-modified">410      * @throws IllegalArgumentException if the value is not valid for</span>
<span class="line-modified">411      *         the option</span>
<span class="line-added">412      * @throws IOException if an I/O error occurs, or if the socket is closed</span>
<span class="line-added">413      * @throws NullPointerException if name is {@code null}</span>
414      *
415      * @since 9
416      */
417     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="line-modified">418         Objects.requireNonNull(name);</span>
<span class="line-modified">419         throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>






















420     }
421 
422     /**
423      * Called to get a socket option.
424      *
<span class="line-added">425      * @implSpec</span>
<span class="line-added">426      * The default implementation of this method first checks that the given</span>
<span class="line-added">427      * socket option {@code name} is not null, then throws {@code</span>
<span class="line-added">428      * UnsupportedOperationException}. Subclasses should override this method</span>
<span class="line-added">429      * with an appropriate implementation.</span>
<span class="line-added">430      *</span>
431      * @param &lt;T&gt; The type of the socket option value
432      * @param name The socket option

433      * @return the value of the named option
434      *
435      * @throws UnsupportedOperationException if the SocketImpl does not
<span class="line-modified">436      *         support the option</span>
<span class="line-modified">437      * @throws IOException if an I/O error occurs, or if the socket is closed</span>
<span class="line-modified">438      * @throws NullPointerException if name is {@code null}</span>
439      *
440      * @since 9
441      */

442     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">443         Objects.requireNonNull(name);</span>
<span class="line-modified">444         throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>






















445     }
446 
<span class="line-modified">447     /**</span>
<span class="line-modified">448      * Attempts to copy socket options from this SocketImpl to a target SocketImpl.</span>
<span class="line-modified">449      * At this time, only the SO_TIMEOUT make sense to copy.</span>
<span class="line-modified">450      */</span>
<span class="line-modified">451     void copyOptionsTo(SocketImpl target) {</span>
<span class="line-modified">452         try {</span>
<span class="line-modified">453             Object timeout = getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-modified">454             if (timeout instanceof Integer) {</span>
<span class="line-modified">455                 target.setOption(SocketOptions.SO_TIMEOUT, timeout);</span>
<span class="line-modified">456             }</span>
<span class="line-modified">457         } catch (IOException ignore) { }</span>





458     }
459 
460     /**
461      * Returns a set of SocketOptions supported by this impl
462      * and by this impl&#39;s socket (Socket or ServerSocket)
463      *
<span class="line-added">464      * @implSpec</span>
<span class="line-added">465      * The default implementation of this method returns an empty set.</span>
<span class="line-added">466      * Subclasses should override this method with an appropriate implementation.</span>
<span class="line-added">467      *</span>
468      * @return a Set of SocketOptions
469      *
470      * @since 9
471      */
472     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">473         return Set.of();</span>




474     }
475 }
</pre>
</td>
</tr>
</table>
<center><a href="SocketException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketImplFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/nio/file/Files.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.nio.file;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.BufferedWriter;
  30 import java.io.Closeable;
  31 import java.io.File;
  32 import java.io.IOException;
  33 import java.io.InputStream;
  34 import java.io.InputStreamReader;
  35 import java.io.OutputStream;
  36 import java.io.OutputStreamWriter;
  37 import java.io.Reader;
  38 import java.io.UncheckedIOException;
  39 import java.io.Writer;
  40 import java.nio.channels.Channels;
  41 import java.nio.channels.FileChannel;
  42 import java.nio.channels.SeekableByteChannel;
  43 import java.nio.charset.Charset;
  44 import java.nio.charset.CharsetDecoder;
  45 import java.nio.charset.CharsetEncoder;
  46 import java.nio.charset.StandardCharsets;
  47 import java.nio.file.attribute.BasicFileAttributeView;
  48 import java.nio.file.attribute.BasicFileAttributes;
  49 import java.nio.file.attribute.DosFileAttributes;   // javadoc
  50 import java.nio.file.attribute.FileAttribute;
  51 import java.nio.file.attribute.FileAttributeView;
  52 import java.nio.file.attribute.FileOwnerAttributeView;
  53 import java.nio.file.attribute.FileStoreAttributeView;
  54 import java.nio.file.attribute.FileTime;
  55 import java.nio.file.attribute.PosixFileAttributeView;
  56 import java.nio.file.attribute.PosixFileAttributes;
  57 import java.nio.file.attribute.PosixFilePermission;
  58 import java.nio.file.attribute.UserPrincipal;
  59 import java.nio.file.spi.FileSystemProvider;
  60 import java.nio.file.spi.FileTypeDetector;
  61 import java.security.AccessController;
  62 import java.security.PrivilegedAction;
  63 import java.util.ArrayList;
  64 import java.util.Arrays;
  65 import java.util.Collections;
  66 import java.util.EnumSet;
  67 import java.util.HashSet;
  68 import java.util.Iterator;
  69 import java.util.List;
  70 import java.util.Map;
  71 import java.util.Objects;
  72 import java.util.ServiceLoader;
  73 import java.util.Set;
  74 import java.util.Spliterator;
  75 import java.util.Spliterators;
  76 import java.util.function.BiPredicate;
  77 import java.util.stream.Stream;
  78 import java.util.stream.StreamSupport;
  79 
  80 import jdk.internal.util.ArraysSupport;
  81 import sun.nio.ch.FileChannelImpl;
  82 import sun.nio.cs.UTF_8;
  83 import sun.nio.fs.AbstractFileSystemProvider;
  84 
  85 /**
  86  * This class consists exclusively of static methods that operate on files,
  87  * directories, or other types of files.
  88  *
  89  * &lt;p&gt; In most cases, the methods defined here will delegate to the associated
  90  * file system provider to perform the file operations.
  91  *
  92  * @since 1.7
  93  */
  94 
  95 public final class Files {
  96     // buffer size used for reading and writing
  97     private static final int BUFFER_SIZE = 8192;
  98 
  99     private Files() { }
 100 
 101     /**
 102      * Returns the {@code FileSystemProvider} to delegate to.
 103      */
 104     private static FileSystemProvider provider(Path path) {
 105         return path.getFileSystem().provider();
 106     }
 107 
 108     /**
 109      * Convert a Closeable to a Runnable by converting checked IOException
 110      * to UncheckedIOException
 111      */
 112     private static Runnable asUncheckedRunnable(Closeable c) {
 113         return () -&gt; {
 114             try {
 115                 c.close();
 116             } catch (IOException e) {
 117                 throw new UncheckedIOException(e);
 118             }
 119         };
 120     }
 121 
 122     // -- File contents --
 123 
 124     /**
 125      * Opens a file, returning an input stream to read from the file. The stream
 126      * will not be buffered, and is not required to support the {@link
 127      * InputStream#mark mark} or {@link InputStream#reset reset} methods. The
 128      * stream will be safe for access by multiple concurrent threads. Reading
 129      * commences at the beginning of the file. Whether the returned stream is
 130      * &lt;i&gt;asynchronously closeable&lt;/i&gt; and/or &lt;i&gt;interruptible&lt;/i&gt; is highly
 131      * file system provider specific and therefore not specified.
 132      *
 133      * &lt;p&gt; The {@code options} parameter determines how the file is opened.
 134      * If no options are present then it is equivalent to opening the file with
 135      * the {@link StandardOpenOption#READ READ} option. In addition to the {@code
 136      * READ} option, an implementation may also support additional implementation
 137      * specific options.
 138      *
 139      * @param   path
 140      *          the path to the file to open
 141      * @param   options
 142      *          options specifying how the file is opened
 143      *
 144      * @return  a new input stream
 145      *
 146      * @throws  IllegalArgumentException
 147      *          if an invalid combination of options is specified
 148      * @throws  UnsupportedOperationException
 149      *          if an unsupported option is specified
 150      * @throws  IOException
 151      *          if an I/O error occurs
 152      * @throws  SecurityException
 153      *          In the case of the default provider, and a security manager is
 154      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 155      *          method is invoked to check read access to the file.
 156      */
 157     public static InputStream newInputStream(Path path, OpenOption... options)
 158         throws IOException
 159     {
 160         return provider(path).newInputStream(path, options);
 161     }
 162 
 163     /**
 164      * Opens or creates a file, returning an output stream that may be used to
 165      * write bytes to the file. The resulting stream will not be buffered. The
 166      * stream will be safe for access by multiple concurrent threads. Whether
 167      * the returned stream is &lt;i&gt;asynchronously closeable&lt;/i&gt; and/or
 168      * &lt;i&gt;interruptible&lt;/i&gt; is highly file system provider specific and
 169      * therefore not specified.
 170      *
 171      * &lt;p&gt; This method opens or creates a file in exactly the manner specified
 172      * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}
 173      * method with the exception that the {@link StandardOpenOption#READ READ}
 174      * option may not be present in the array of options. If no options are
 175      * present then this method works as if the {@link StandardOpenOption#CREATE
 176      * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},
 177      * and {@link StandardOpenOption#WRITE WRITE} options are present. In other
 178      * words, it opens the file for writing, creating the file if it doesn&#39;t
 179      * exist, or initially truncating an existing {@link #isRegularFile
 180      * regular-file} to a size of {@code 0} if it exists.
 181      *
 182      * &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
 183      * &lt;pre&gt;
 184      *     Path path = ...
 185      *
 186      *     // truncate and overwrite an existing file, or create the file if
 187      *     // it doesn&#39;t initially exist
 188      *     OutputStream out = Files.newOutputStream(path);
 189      *
 190      *     // append to an existing file, fail if the file does not exist
 191      *     out = Files.newOutputStream(path, APPEND);
 192      *
 193      *     // append to an existing file, create file if it doesn&#39;t initially exist
 194      *     out = Files.newOutputStream(path, CREATE, APPEND);
 195      *
 196      *     // always create new file, failing if it already exists
 197      *     out = Files.newOutputStream(path, CREATE_NEW);
 198      * &lt;/pre&gt;
 199      *
 200      * @param   path
 201      *          the path to the file to open or create
 202      * @param   options
 203      *          options specifying how the file is opened
 204      *
 205      * @return  a new output stream
 206      *
 207      * @throws  IllegalArgumentException
 208      *          if {@code options} contains an invalid combination of options
 209      * @throws  UnsupportedOperationException
 210      *          if an unsupported option is specified
 211      * @throws  IOException
 212      *          if an I/O error occurs
 213      * @throws  SecurityException
 214      *          In the case of the default provider, and a security manager is
 215      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 216      *          method is invoked to check write access to the file. The {@link
 217      *          SecurityManager#checkDelete(String) checkDelete} method is
 218      *          invoked to check delete access if the file is opened with the
 219      *          {@code DELETE_ON_CLOSE} option.
 220      */
 221     public static OutputStream newOutputStream(Path path, OpenOption... options)
 222         throws IOException
 223     {
 224         return provider(path).newOutputStream(path, options);
 225     }
 226 
 227     /**
 228      * Opens or creates a file, returning a seekable byte channel to access the
 229      * file.
 230      *
 231      * &lt;p&gt; The {@code options} parameter determines how the file is opened.
 232      * The {@link StandardOpenOption#READ READ} and {@link
 233      * StandardOpenOption#WRITE WRITE} options determine if the file should be
 234      * opened for reading and/or writing. If neither option (or the {@link
 235      * StandardOpenOption#APPEND APPEND} option) is present then the file is
 236      * opened for reading. By default reading or writing commence at the
 237      * beginning of the file.
 238      *
 239      * &lt;p&gt; In the addition to {@code READ} and {@code WRITE}, the following
 240      * options may be present:
 241      *
 242      * &lt;table class=&quot;striped&quot;&gt;
 243      * &lt;caption style=&quot;display:none&quot;&gt;Options&lt;/caption&gt;
 244      * &lt;thead&gt;
 245      * &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;Option&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt; &lt;/tr&gt;
 246      * &lt;/thead&gt;
 247      * &lt;tbody&gt;
 248      * &lt;tr&gt;
 249      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardOpenOption#APPEND APPEND} &lt;/th&gt;
 250      *   &lt;td&gt; If this option is present then the file is opened for writing and
 251      *     each invocation of the channel&#39;s {@code write} method first advances
 252      *     the position to the end of the file and then writes the requested
 253      *     data. Whether the advancement of the position and the writing of the
 254      *     data are done in a single atomic operation is system-dependent and
 255      *     therefore unspecified. This option may not be used in conjunction
 256      *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. &lt;/td&gt;
 257      * &lt;/tr&gt;
 258      * &lt;tr&gt;
 259      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} &lt;/th&gt;
 260      *   &lt;td&gt; If this option is present then the existing file is truncated to
 261      *   a size of 0 bytes. This option is ignored when the file is opened only
 262      *   for reading. &lt;/td&gt;
 263      * &lt;/tr&gt;
 264      * &lt;tr&gt;
 265      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardOpenOption#CREATE_NEW CREATE_NEW} &lt;/th&gt;
 266      *   &lt;td&gt; If this option is present then a new file is created, failing if
 267      *   the file already exists or is a symbolic link. When creating a file the
 268      *   check for the existence of the file and the creation of the file if it
 269      *   does not exist is atomic with respect to other file system operations.
 270      *   This option is ignored when the file is opened only for reading. &lt;/td&gt;
 271      * &lt;/tr&gt;
 272      * &lt;tr&gt;
 273      *   &lt;th scope=&quot;row&quot; &gt; {@link StandardOpenOption#CREATE CREATE} &lt;/th&gt;
 274      *   &lt;td&gt; If this option is present then an existing file is opened if it
 275      *   exists, otherwise a new file is created. This option is ignored if the
 276      *   {@code CREATE_NEW} option is also present or the file is opened only
 277      *   for reading. &lt;/td&gt;
 278      * &lt;/tr&gt;
 279      * &lt;tr&gt;
 280      *   &lt;th scope=&quot;row&quot; &gt; {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} &lt;/th&gt;
 281      *   &lt;td&gt; When this option is present then the implementation makes a
 282      *   &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the
 283      *   {@link SeekableByteChannel#close close} method. If the {@code close}
 284      *   method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to
 285      *   delete the file when the Java virtual machine terminates. &lt;/td&gt;
 286      * &lt;/tr&gt;
 287      * &lt;tr&gt;
 288      *   &lt;th scope=&quot;row&quot;&gt;{@link StandardOpenOption#SPARSE SPARSE} &lt;/th&gt;
 289      *   &lt;td&gt; When creating a new file this option is a &lt;em&gt;hint&lt;/em&gt; that the
 290      *   new file will be sparse. This option is ignored when not creating
 291      *   a new file. &lt;/td&gt;
 292      * &lt;/tr&gt;
 293      * &lt;tr&gt;
 294      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardOpenOption#SYNC SYNC} &lt;/th&gt;
 295      *   &lt;td&gt; Requires that every update to the file&#39;s content or metadata be
 296      *   written synchronously to the underlying storage device. (see &lt;a
 297      *   href=&quot;package-summary.html#integrity&quot;&gt; Synchronized I/O file
 298      *   integrity&lt;/a&gt;). &lt;/td&gt;
 299      * &lt;/tr&gt;
 300      * &lt;tr&gt;
 301      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardOpenOption#DSYNC DSYNC} &lt;/th&gt;
 302      *   &lt;td&gt; Requires that every update to the file&#39;s content be written
 303      *   synchronously to the underlying storage device. (see &lt;a
 304      *   href=&quot;package-summary.html#integrity&quot;&gt; Synchronized I/O file
 305      *   integrity&lt;/a&gt;). &lt;/td&gt;
 306      * &lt;/tr&gt;
 307      * &lt;/tbody&gt;
 308      * &lt;/table&gt;
 309      *
 310      * &lt;p&gt; An implementation may also support additional implementation specific
 311      * options.
 312      *
 313      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
 314      * file-attributes} to set atomically when a new file is created.
 315      *
 316      * &lt;p&gt; In the case of the default provider, the returned seekable byte channel
 317      * is a {@link java.nio.channels.FileChannel}.
 318      *
 319      * &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
 320      * &lt;pre&gt;{@code
 321      *     Path path = ...
 322      *
 323      *     // open file for reading
 324      *     ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));
 325      *
 326      *     // open file for writing to the end of an existing file, creating
 327      *     // the file if it doesn&#39;t already exist
 328      *     WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));
 329      *
 330      *     // create file with initial permissions, opening it for both reading and writing
 331      *     FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; perms = ...
 332      *     SeekableByteChannel sbc =
 333      *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
 334      * }&lt;/pre&gt;
 335      *
 336      * @param   path
 337      *          the path to the file to open or create
 338      * @param   options
 339      *          options specifying how the file is opened
 340      * @param   attrs
 341      *          an optional list of file attributes to set atomically when
 342      *          creating the file
 343      *
 344      * @return  a new seekable byte channel
 345      *
 346      * @throws  IllegalArgumentException
 347      *          if the set contains an invalid combination of options
 348      * @throws  UnsupportedOperationException
 349      *          if an unsupported open option is specified or the array contains
 350      *          attributes that cannot be set atomically when creating the file
 351      * @throws  FileAlreadyExistsException
 352      *          if a file of that name already exists and the {@link
 353      *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
 354      *          &lt;i&gt;(optional specific exception)&lt;/i&gt;
 355      * @throws  IOException
 356      *          if an I/O error occurs
 357      * @throws  SecurityException
 358      *          In the case of the default provider, and a security manager is
 359      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 360      *          method is invoked to check read access to the path if the file is
 361      *          opened for reading. The {@link SecurityManager#checkWrite(String)
 362      *          checkWrite} method is invoked to check write access to the path
 363      *          if the file is opened for writing. The {@link
 364      *          SecurityManager#checkDelete(String) checkDelete} method is
 365      *          invoked to check delete access if the file is opened with the
 366      *          {@code DELETE_ON_CLOSE} option.
 367      *
 368      * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])
 369      */
 370     public static SeekableByteChannel newByteChannel(Path path,
 371                                                      Set&lt;? extends OpenOption&gt; options,
 372                                                      FileAttribute&lt;?&gt;... attrs)
 373         throws IOException
 374     {
 375         return provider(path).newByteChannel(path, options, attrs);
 376     }
 377 
 378     /**
 379      * Opens or creates a file, returning a seekable byte channel to access the
 380      * file.
 381      *
 382      * &lt;p&gt; This method opens or creates a file in exactly the manner specified
 383      * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}
 384      * method.
 385      *
 386      * @param   path
 387      *          the path to the file to open or create
 388      * @param   options
 389      *          options specifying how the file is opened
 390      *
 391      * @return  a new seekable byte channel
 392      *
 393      * @throws  IllegalArgumentException
 394      *          if the set contains an invalid combination of options
 395      * @throws  UnsupportedOperationException
 396      *          if an unsupported open option is specified
 397      * @throws  FileAlreadyExistsException
 398      *          if a file of that name already exists and the {@link
 399      *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
 400      *          &lt;i&gt;(optional specific exception)&lt;/i&gt;
 401      * @throws  IOException
 402      *          if an I/O error occurs
 403      * @throws  SecurityException
 404      *          In the case of the default provider, and a security manager is
 405      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 406      *          method is invoked to check read access to the path if the file is
 407      *          opened for reading. The {@link SecurityManager#checkWrite(String)
 408      *          checkWrite} method is invoked to check write access to the path
 409      *          if the file is opened for writing. The {@link
 410      *          SecurityManager#checkDelete(String) checkDelete} method is
 411      *          invoked to check delete access if the file is opened with the
 412      *          {@code DELETE_ON_CLOSE} option.
 413      *
 414      * @see java.nio.channels.FileChannel#open(Path,OpenOption[])
 415      */
 416     public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)
 417         throws IOException
 418     {
 419         Set&lt;OpenOption&gt; set;
 420         if (options.length == 0) {
 421             set = Collections.emptySet();
 422         } else {
 423             set = new HashSet&lt;&gt;();
 424             Collections.addAll(set, options);
 425         }
 426         return newByteChannel(path, set);
 427     }
 428 
 429     // -- Directories --
 430 
 431     private static class AcceptAllFilter
 432         implements DirectoryStream.Filter&lt;Path&gt;
 433     {
 434         private AcceptAllFilter() { }
 435 
 436         @Override
 437         public boolean accept(Path entry) { return true; }
 438 
 439         static final AcceptAllFilter FILTER = new AcceptAllFilter();
 440     }
 441 
 442     /**
 443      * Opens a directory, returning a {@link DirectoryStream} to iterate over
 444      * all entries in the directory. The elements returned by the directory
 445      * stream&#39;s {@link DirectoryStream#iterator iterator} are of type {@code
 446      * Path}, each one representing an entry in the directory. The {@code Path}
 447      * objects are obtained as if by {@link Path#resolve(Path) resolving} the
 448      * name of the directory entry against {@code dir}.
 449      *
 450      * &lt;p&gt; When not using the try-with-resources construct, then directory
 451      * stream&#39;s {@code close} method should be invoked after iteration is
 452      * completed so as to free any resources held for the open directory.
 453      *
 454      * &lt;p&gt; When an implementation supports operations on entries in the
 455      * directory that execute in a race-free manner then the returned directory
 456      * stream is a {@link SecureDirectoryStream}.
 457      *
 458      * @param   dir
 459      *          the path to the directory
 460      *
 461      * @return  a new and open {@code DirectoryStream} object
 462      *
 463      * @throws  NotDirectoryException
 464      *          if the file could not otherwise be opened because it is not
 465      *          a directory &lt;i&gt;(optional specific exception)&lt;/i&gt;
 466      * @throws  IOException
 467      *          if an I/O error occurs
 468      * @throws  SecurityException
 469      *          In the case of the default provider, and a security manager is
 470      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 471      *          method is invoked to check read access to the directory.
 472      */
 473     public static DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir)
 474         throws IOException
 475     {
 476         return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);
 477     }
 478 
 479     /**
 480      * Opens a directory, returning a {@link DirectoryStream} to iterate over
 481      * the entries in the directory. The elements returned by the directory
 482      * stream&#39;s {@link DirectoryStream#iterator iterator} are of type {@code
 483      * Path}, each one representing an entry in the directory. The {@code Path}
 484      * objects are obtained as if by {@link Path#resolve(Path) resolving} the
 485      * name of the directory entry against {@code dir}. The entries returned by
 486      * the iterator are filtered by matching the {@code String} representation
 487      * of their file names against the given &lt;em&gt;globbing&lt;/em&gt; pattern.
 488      *
 489      * &lt;p&gt; For example, suppose we want to iterate over the files ending with
 490      * &quot;.java&quot; in a directory:
 491      * &lt;pre&gt;
 492      *     Path dir = ...
 493      *     try (DirectoryStream&amp;lt;Path&amp;gt; stream = Files.newDirectoryStream(dir, &quot;*.java&quot;)) {
 494      *         :
 495      *     }
 496      * &lt;/pre&gt;
 497      *
 498      * &lt;p&gt; The globbing pattern is specified by the {@link
 499      * FileSystem#getPathMatcher getPathMatcher} method.
 500      *
 501      * &lt;p&gt; When not using the try-with-resources construct, then directory
 502      * stream&#39;s {@code close} method should be invoked after iteration is
 503      * completed so as to free any resources held for the open directory.
 504      *
 505      * &lt;p&gt; When an implementation supports operations on entries in the
 506      * directory that execute in a race-free manner then the returned directory
 507      * stream is a {@link SecureDirectoryStream}.
 508      *
 509      * @param   dir
 510      *          the path to the directory
 511      * @param   glob
 512      *          the glob pattern
 513      *
 514      * @return  a new and open {@code DirectoryStream} object
 515      *
 516      * @throws  java.util.regex.PatternSyntaxException
 517      *          if the pattern is invalid
 518      * @throws  NotDirectoryException
 519      *          if the file could not otherwise be opened because it is not
 520      *          a directory &lt;i&gt;(optional specific exception)&lt;/i&gt;
 521      * @throws  IOException
 522      *          if an I/O error occurs
 523      * @throws  SecurityException
 524      *          In the case of the default provider, and a security manager is
 525      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 526      *          method is invoked to check read access to the directory.
 527      */
 528     public static DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir, String glob)
 529         throws IOException
 530     {
 531         // avoid creating a matcher if all entries are required.
 532         if (glob.equals(&quot;*&quot;))
 533             return newDirectoryStream(dir);
 534 
 535         // create a matcher and return a filter that uses it.
 536         FileSystem fs = dir.getFileSystem();
 537         final PathMatcher matcher = fs.getPathMatcher(&quot;glob:&quot; + glob);
 538         DirectoryStream.Filter&lt;Path&gt; filter = new DirectoryStream.Filter&lt;&gt;() {
 539             @Override
 540             public boolean accept(Path entry)  {
 541                 return matcher.matches(entry.getFileName());
 542             }
 543         };
 544         return fs.provider().newDirectoryStream(dir, filter);
 545     }
 546 
 547     /**
 548      * Opens a directory, returning a {@link DirectoryStream} to iterate over
 549      * the entries in the directory. The elements returned by the directory
 550      * stream&#39;s {@link DirectoryStream#iterator iterator} are of type {@code
 551      * Path}, each one representing an entry in the directory. The {@code Path}
 552      * objects are obtained as if by {@link Path#resolve(Path) resolving} the
 553      * name of the directory entry against {@code dir}. The entries returned by
 554      * the iterator are filtered by the given {@link DirectoryStream.Filter
 555      * filter}.
 556      *
 557      * &lt;p&gt; When not using the try-with-resources construct, then directory
 558      * stream&#39;s {@code close} method should be invoked after iteration is
 559      * completed so as to free any resources held for the open directory.
 560      *
 561      * &lt;p&gt; Where the filter terminates due to an uncaught error or runtime
 562      * exception then it is propagated to the {@link Iterator#hasNext()
 563      * hasNext} or {@link Iterator#next() next} method. Where an {@code
 564      * IOException} is thrown, it results in the {@code hasNext} or {@code
 565      * next} method throwing a {@link DirectoryIteratorException} with the
 566      * {@code IOException} as the cause.
 567      *
 568      * &lt;p&gt; When an implementation supports operations on entries in the
 569      * directory that execute in a race-free manner then the returned directory
 570      * stream is a {@link SecureDirectoryStream}.
 571      *
 572      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
 573      * Suppose we want to iterate over the files in a directory that are
 574      * larger than 8K.
 575      * &lt;pre&gt;
 576      *     DirectoryStream.Filter&amp;lt;Path&amp;gt; filter = new DirectoryStream.Filter&amp;lt;Path&amp;gt;() {
 577      *         public boolean accept(Path file) throws IOException {
 578      *             return (Files.size(file) &amp;gt; 8192L);
 579      *         }
 580      *     };
 581      *     Path dir = ...
 582      *     try (DirectoryStream&amp;lt;Path&amp;gt; stream = Files.newDirectoryStream(dir, filter)) {
 583      *         :
 584      *     }
 585      * &lt;/pre&gt;
 586      *
 587      * @param   dir
 588      *          the path to the directory
 589      * @param   filter
 590      *          the directory stream filter
 591      *
 592      * @return  a new and open {@code DirectoryStream} object
 593      *
 594      * @throws  NotDirectoryException
 595      *          if the file could not otherwise be opened because it is not
 596      *          a directory &lt;i&gt;(optional specific exception)&lt;/i&gt;
 597      * @throws  IOException
 598      *          if an I/O error occurs
 599      * @throws  SecurityException
 600      *          In the case of the default provider, and a security manager is
 601      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 602      *          method is invoked to check read access to the directory.
 603      */
 604     public static DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir,
 605                                                            DirectoryStream.Filter&lt;? super Path&gt; filter)
 606         throws IOException
 607     {
 608         return provider(dir).newDirectoryStream(dir, filter);
 609     }
 610 
 611     // -- Creation and deletion --
 612 
 613     private static final Set&lt;OpenOption&gt; DEFAULT_CREATE_OPTIONS =
 614         Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);
 615 
 616     /**
 617      * Creates a new and empty file, failing if the file already exists. The
 618      * check for the existence of the file and the creation of the new file if
 619      * it does not exist are a single operation that is atomic with respect to
 620      * all other filesystem activities that might affect the directory.
 621      *
 622      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
 623      * file-attributes} to set atomically when creating the file. Each attribute
 624      * is identified by its {@link FileAttribute#name name}. If more than one
 625      * attribute of the same name is included in the array then all but the last
 626      * occurrence is ignored.
 627      *
 628      * @param   path
 629      *          the path to the file to create
 630      * @param   attrs
 631      *          an optional list of file attributes to set atomically when
 632      *          creating the file
 633      *
 634      * @return  the file
 635      *
 636      * @throws  UnsupportedOperationException
 637      *          if the array contains an attribute that cannot be set atomically
 638      *          when creating the file
 639      * @throws  FileAlreadyExistsException
 640      *          if a file of that name already exists
 641      *          &lt;i&gt;(optional specific exception)&lt;/i&gt;
 642      * @throws  IOException
 643      *          if an I/O error occurs or the parent directory does not exist
 644      * @throws  SecurityException
 645      *          In the case of the default provider, and a security manager is
 646      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 647      *          method is invoked to check write access to the new file.
 648      */
 649     public static Path createFile(Path path, FileAttribute&lt;?&gt;... attrs)
 650         throws IOException
 651     {
 652         newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();
 653         return path;
 654     }
 655 
 656     /**
 657      * Creates a new directory. The check for the existence of the file and the
 658      * creation of the directory if it does not exist are a single operation
 659      * that is atomic with respect to all other filesystem activities that might
 660      * affect the directory. The {@link #createDirectories createDirectories}
 661      * method should be used where it is required to create all nonexistent
 662      * parent directories first.
 663      *
 664      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
 665      * file-attributes} to set atomically when creating the directory. Each
 666      * attribute is identified by its {@link FileAttribute#name name}. If more
 667      * than one attribute of the same name is included in the array then all but
 668      * the last occurrence is ignored.
 669      *
 670      * @param   dir
 671      *          the directory to create
 672      * @param   attrs
 673      *          an optional list of file attributes to set atomically when
 674      *          creating the directory
 675      *
 676      * @return  the directory
 677      *
 678      * @throws  UnsupportedOperationException
 679      *          if the array contains an attribute that cannot be set atomically
 680      *          when creating the directory
 681      * @throws  FileAlreadyExistsException
 682      *          if a directory could not otherwise be created because a file of
 683      *          that name already exists &lt;i&gt;(optional specific exception)&lt;/i&gt;
 684      * @throws  IOException
 685      *          if an I/O error occurs or the parent directory does not exist
 686      * @throws  SecurityException
 687      *          In the case of the default provider, and a security manager is
 688      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 689      *          method is invoked to check write access to the new directory.
 690      */
 691     public static Path createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)
 692         throws IOException
 693     {
 694         provider(dir).createDirectory(dir, attrs);
 695         return dir;
 696     }
 697 
 698     /**
 699      * Creates a directory by creating all nonexistent parent directories first.
 700      * Unlike the {@link #createDirectory createDirectory} method, an exception
 701      * is not thrown if the directory could not be created because it already
 702      * exists.
 703      *
 704      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
 705      * file-attributes} to set atomically when creating the nonexistent
 706      * directories. Each file attribute is identified by its {@link
 707      * FileAttribute#name name}. If more than one attribute of the same name is
 708      * included in the array then all but the last occurrence is ignored.
 709      *
 710      * &lt;p&gt; If this method fails, then it may do so after creating some, but not
 711      * all, of the parent directories.
 712      *
 713      * @param   dir
 714      *          the directory to create
 715      *
 716      * @param   attrs
 717      *          an optional list of file attributes to set atomically when
 718      *          creating the directory
 719      *
 720      * @return  the directory
 721      *
 722      * @throws  UnsupportedOperationException
 723      *          if the array contains an attribute that cannot be set atomically
 724      *          when creating the directory
 725      * @throws  FileAlreadyExistsException
 726      *          if {@code dir} exists but is not a directory &lt;i&gt;(optional specific
 727      *          exception)&lt;/i&gt;
 728      * @throws  IOException
 729      *          if an I/O error occurs
 730      * @throws  SecurityException
 731      *          in the case of the default provider, and a security manager is
 732      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 733      *          method is invoked prior to attempting to create a directory and
 734      *          its {@link SecurityManager#checkRead(String) checkRead} is
 735      *          invoked for each parent directory that is checked. If {@code
 736      *          dir} is not an absolute path then its {@link Path#toAbsolutePath
 737      *          toAbsolutePath} may need to be invoked to get its absolute path.
 738      *          This may invoke the security manager&#39;s {@link
 739      *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}
 740      *          method to check access to the system property {@code user.dir}
 741      */
 742     public static Path createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)
 743         throws IOException
 744     {
 745         // attempt to create the directory
 746         try {
 747             createAndCheckIsDirectory(dir, attrs);
 748             return dir;
 749         } catch (FileAlreadyExistsException x) {
 750             // file exists and is not a directory
 751             throw x;
 752         } catch (IOException x) {
 753             // parent may not exist or other reason
 754         }
 755         SecurityException se = null;
 756         try {
 757             dir = dir.toAbsolutePath();
 758         } catch (SecurityException x) {
 759             // don&#39;t have permission to get absolute path
 760             se = x;
 761         }
 762         // find a descendant that exists
 763         Path parent = dir.getParent();
 764         while (parent != null) {
 765             try {
 766                 provider(parent).checkAccess(parent);
 767                 break;
 768             } catch (NoSuchFileException x) {
 769                 // does not exist
 770             }
 771             parent = parent.getParent();
 772         }
 773         if (parent == null) {
 774             // unable to find existing parent
 775             if (se == null) {
 776                 throw new FileSystemException(dir.toString(), null,
 777                     &quot;Unable to determine if root directory exists&quot;);
 778             } else {
 779                 throw se;
 780             }
 781         }
 782 
 783         // create directories
 784         Path child = parent;
 785         for (Path name: parent.relativize(dir)) {
 786             child = child.resolve(name);
 787             createAndCheckIsDirectory(child, attrs);
 788         }
 789         return dir;
 790     }
 791 
 792     /**
 793      * Used by createDirectories to attempt to create a directory. A no-op
 794      * if the directory already exists.
 795      */
 796     private static void createAndCheckIsDirectory(Path dir,
 797                                                   FileAttribute&lt;?&gt;... attrs)
 798         throws IOException
 799     {
 800         try {
 801             createDirectory(dir, attrs);
 802         } catch (FileAlreadyExistsException x) {
 803             if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))
 804                 throw x;
 805         }
 806     }
 807 
 808     /**
 809      * Creates a new empty file in the specified directory, using the given
 810      * prefix and suffix strings to generate its name. The resulting
 811      * {@code Path} is associated with the same {@code FileSystem} as the given
 812      * directory.
 813      *
 814      * &lt;p&gt; The details as to how the name of the file is constructed is
 815      * implementation dependent and therefore not specified. Where possible
 816      * the {@code prefix} and {@code suffix} are used to construct candidate
 817      * names in the same manner as the {@link
 818      * java.io.File#createTempFile(String,String,File)} method.
 819      *
 820      * &lt;p&gt; As with the {@code File.createTempFile} methods, this method is only
 821      * part of a temporary-file facility. Where used as a &lt;em&gt;work files&lt;/em&gt;,
 822      * the resulting file may be opened using the {@link
 823      * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the
 824      * file is deleted when the appropriate {@code close} method is invoked.
 825      * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the
 826      * {@link java.io.File#deleteOnExit} mechanism may be used to delete the
 827      * file automatically.
 828      *
 829      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
 830      * file-attributes} to set atomically when creating the file. Each attribute
 831      * is identified by its {@link FileAttribute#name name}. If more than one
 832      * attribute of the same name is included in the array then all but the last
 833      * occurrence is ignored. When no file attributes are specified, then the
 834      * resulting file may have more restrictive access permissions to files
 835      * created by the {@link java.io.File#createTempFile(String,String,File)}
 836      * method.
 837      *
 838      * @param   dir
 839      *          the path to directory in which to create the file
 840      * @param   prefix
 841      *          the prefix string to be used in generating the file&#39;s name;
 842      *          may be {@code null}
 843      * @param   suffix
 844      *          the suffix string to be used in generating the file&#39;s name;
 845      *          may be {@code null}, in which case &quot;{@code .tmp}&quot; is used
 846      * @param   attrs
 847      *          an optional list of file attributes to set atomically when
 848      *          creating the file
 849      *
 850      * @return  the path to the newly created file that did not exist before
 851      *          this method was invoked
 852      *
 853      * @throws  IllegalArgumentException
 854      *          if the prefix or suffix parameters cannot be used to generate
 855      *          a candidate file name
 856      * @throws  UnsupportedOperationException
 857      *          if the array contains an attribute that cannot be set atomically
 858      *          when creating the directory
 859      * @throws  IOException
 860      *          if an I/O error occurs or {@code dir} does not exist
 861      * @throws  SecurityException
 862      *          In the case of the default provider, and a security manager is
 863      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 864      *          method is invoked to check write access to the file.
 865      */
 866     public static Path createTempFile(Path dir,
 867                                       String prefix,
 868                                       String suffix,
 869                                       FileAttribute&lt;?&gt;... attrs)
 870         throws IOException
 871     {
 872         return TempFileHelper.createTempFile(Objects.requireNonNull(dir),
 873                                              prefix, suffix, attrs);
 874     }
 875 
 876     /**
 877      * Creates an empty file in the default temporary-file directory, using
 878      * the given prefix and suffix to generate its name. The resulting {@code
 879      * Path} is associated with the default {@code FileSystem}.
 880      *
 881      * &lt;p&gt; This method works in exactly the manner specified by the
 882      * {@link #createTempFile(Path,String,String,FileAttribute[])} method for
 883      * the case that the {@code dir} parameter is the temporary-file directory.
 884      *
 885      * @param   prefix
 886      *          the prefix string to be used in generating the file&#39;s name;
 887      *          may be {@code null}
 888      * @param   suffix
 889      *          the suffix string to be used in generating the file&#39;s name;
 890      *          may be {@code null}, in which case &quot;{@code .tmp}&quot; is used
 891      * @param   attrs
 892      *          an optional list of file attributes to set atomically when
 893      *          creating the file
 894      *
 895      * @return  the path to the newly created file that did not exist before
 896      *          this method was invoked
 897      *
 898      * @throws  IllegalArgumentException
 899      *          if the prefix or suffix parameters cannot be used to generate
 900      *          a candidate file name
 901      * @throws  UnsupportedOperationException
 902      *          if the array contains an attribute that cannot be set atomically
 903      *          when creating the directory
 904      * @throws  IOException
 905      *          if an I/O error occurs or the temporary-file directory does not
 906      *          exist
 907      * @throws  SecurityException
 908      *          In the case of the default provider, and a security manager is
 909      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 910      *          method is invoked to check write access to the file.
 911      */
 912     public static Path createTempFile(String prefix,
 913                                       String suffix,
 914                                       FileAttribute&lt;?&gt;... attrs)
 915         throws IOException
 916     {
 917         return TempFileHelper.createTempFile(null, prefix, suffix, attrs);
 918     }
 919 
 920     /**
 921      * Creates a new directory in the specified directory, using the given
 922      * prefix to generate its name.  The resulting {@code Path} is associated
 923      * with the same {@code FileSystem} as the given directory.
 924      *
 925      * &lt;p&gt; The details as to how the name of the directory is constructed is
 926      * implementation dependent and therefore not specified. Where possible
 927      * the {@code prefix} is used to construct candidate names.
 928      *
 929      * &lt;p&gt; As with the {@code createTempFile} methods, this method is only
 930      * part of a temporary-file facility. A {@link Runtime#addShutdownHook
 931      * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be
 932      * used to delete the directory automatically.
 933      *
 934      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
 935      * file-attributes} to set atomically when creating the directory. Each
 936      * attribute is identified by its {@link FileAttribute#name name}. If more
 937      * than one attribute of the same name is included in the array then all but
 938      * the last occurrence is ignored.
 939      *
 940      * @param   dir
 941      *          the path to directory in which to create the directory
 942      * @param   prefix
 943      *          the prefix string to be used in generating the directory&#39;s name;
 944      *          may be {@code null}
 945      * @param   attrs
 946      *          an optional list of file attributes to set atomically when
 947      *          creating the directory
 948      *
 949      * @return  the path to the newly created directory that did not exist before
 950      *          this method was invoked
 951      *
 952      * @throws  IllegalArgumentException
 953      *          if the prefix cannot be used to generate a candidate directory name
 954      * @throws  UnsupportedOperationException
 955      *          if the array contains an attribute that cannot be set atomically
 956      *          when creating the directory
 957      * @throws  IOException
 958      *          if an I/O error occurs or {@code dir} does not exist
 959      * @throws  SecurityException
 960      *          In the case of the default provider, and a security manager is
 961      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 962      *          method is invoked to check write access when creating the
 963      *          directory.
 964      */
 965     public static Path createTempDirectory(Path dir,
 966                                            String prefix,
 967                                            FileAttribute&lt;?&gt;... attrs)
 968         throws IOException
 969     {
 970         return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),
 971                                                   prefix, attrs);
 972     }
 973 
 974     /**
 975      * Creates a new directory in the default temporary-file directory, using
 976      * the given prefix to generate its name. The resulting {@code Path} is
 977      * associated with the default {@code FileSystem}.
 978      *
 979      * &lt;p&gt; This method works in exactly the manner specified by {@link
 980      * #createTempDirectory(Path,String,FileAttribute[])} method for the case
 981      * that the {@code dir} parameter is the temporary-file directory.
 982      *
 983      * @param   prefix
 984      *          the prefix string to be used in generating the directory&#39;s name;
 985      *          may be {@code null}
 986      * @param   attrs
 987      *          an optional list of file attributes to set atomically when
 988      *          creating the directory
 989      *
 990      * @return  the path to the newly created directory that did not exist before
 991      *          this method was invoked
 992      *
 993      * @throws  IllegalArgumentException
 994      *          if the prefix cannot be used to generate a candidate directory name
 995      * @throws  UnsupportedOperationException
 996      *          if the array contains an attribute that cannot be set atomically
 997      *          when creating the directory
 998      * @throws  IOException
 999      *          if an I/O error occurs or the temporary-file directory does not
1000      *          exist
1001      * @throws  SecurityException
1002      *          In the case of the default provider, and a security manager is
1003      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
1004      *          method is invoked to check write access when creating the
1005      *          directory.
1006      */
1007     public static Path createTempDirectory(String prefix,
1008                                            FileAttribute&lt;?&gt;... attrs)
1009         throws IOException
1010     {
1011         return TempFileHelper.createTempDirectory(null, prefix, attrs);
1012     }
1013 
1014     /**
1015      * Creates a symbolic link to a target &lt;i&gt;(optional operation)&lt;/i&gt;.
1016      *
1017      * &lt;p&gt; The {@code target} parameter is the target of the link. It may be an
1018      * {@link Path#isAbsolute absolute} or relative path and may not exist. When
1019      * the target is a relative path then file system operations on the resulting
1020      * link are relative to the path of the link.
1021      *
1022      * &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttribute
1023      * attributes} to set atomically when creating the link. Each attribute is
1024      * identified by its {@link FileAttribute#name name}. If more than one attribute
1025      * of the same name is included in the array then all but the last occurrence
1026      * is ignored.
1027      *
1028      * &lt;p&gt; Where symbolic links are supported, but the underlying {@link FileStore}
1029      * does not support symbolic links, then this may fail with an {@link
1030      * IOException}. Additionally, some operating systems may require that the
1031      * Java virtual machine be started with implementation specific privileges to
1032      * create symbolic links, in which case this method may throw {@code IOException}.
1033      *
1034      * @param   link
1035      *          the path of the symbolic link to create
1036      * @param   target
1037      *          the target of the symbolic link
1038      * @param   attrs
1039      *          the array of attributes to set atomically when creating the
1040      *          symbolic link
1041      *
1042      * @return  the path to the symbolic link
1043      *
1044      * @throws  UnsupportedOperationException
1045      *          if the implementation does not support symbolic links or the
1046      *          array contains an attribute that cannot be set atomically when
1047      *          creating the symbolic link
1048      * @throws  FileAlreadyExistsException
1049      *          if a file with the name already exists &lt;i&gt;(optional specific
1050      *          exception)&lt;/i&gt;
1051      * @throws  IOException
1052      *          if an I/O error occurs
1053      * @throws  SecurityException
1054      *          In the case of the default provider, and a security manager
1055      *          is installed, it denies {@link LinkPermission}{@code (&quot;symbolic&quot;)}
1056      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
1057      *          method denies write access to the path of the symbolic link.
1058      */
1059     public static Path createSymbolicLink(Path link, Path target,
1060                                           FileAttribute&lt;?&gt;... attrs)
1061         throws IOException
1062     {
1063         provider(link).createSymbolicLink(link, target, attrs);
1064         return link;
1065     }
1066 
1067     /**
1068      * Creates a new link (directory entry) for an existing file &lt;i&gt;(optional
1069      * operation)&lt;/i&gt;.
1070      *
1071      * &lt;p&gt; The {@code link} parameter locates the directory entry to create.
1072      * The {@code existing} parameter is the path to an existing file. This
1073      * method creates a new directory entry for the file so that it can be
1074      * accessed using {@code link} as the path. On some file systems this is
1075      * known as creating a &quot;hard link&quot;. Whether the file attributes are
1076      * maintained for the file or for each directory entry is file system
1077      * specific and therefore not specified. Typically, a file system requires
1078      * that all links (directory entries) for a file be on the same file system.
1079      * Furthermore, on some platforms, the Java virtual machine may require to
1080      * be started with implementation specific privileges to create hard links
1081      * or to create links to directories.
1082      *
1083      * @param   link
1084      *          the link (directory entry) to create
1085      * @param   existing
1086      *          a path to an existing file
1087      *
1088      * @return  the path to the link (directory entry)
1089      *
1090      * @throws  UnsupportedOperationException
1091      *          if the implementation does not support adding an existing file
1092      *          to a directory
1093      * @throws  FileAlreadyExistsException
1094      *          if the entry could not otherwise be created because a file of
1095      *          that name already exists &lt;i&gt;(optional specific exception)&lt;/i&gt;
1096      * @throws  IOException
1097      *          if an I/O error occurs
1098      * @throws  SecurityException
1099      *          In the case of the default provider, and a security manager
1100      *          is installed, it denies {@link LinkPermission}{@code (&quot;hard&quot;)}
1101      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
1102      *          method denies write access to either the link or the
1103      *          existing file.
1104      */
1105     public static Path createLink(Path link, Path existing) throws IOException {
1106         provider(link).createLink(link, existing);
1107         return link;
1108     }
1109 
1110     /**
1111      * Deletes a file.
1112      *
1113      * &lt;p&gt; An implementation may require to examine the file to determine if the
1114      * file is a directory. Consequently this method may not be atomic with respect
1115      * to other file system operations.  If the file is a symbolic link then the
1116      * symbolic link itself, not the final target of the link, is deleted.
1117      *
1118      * &lt;p&gt; If the file is a directory then the directory must be empty. In some
1119      * implementations a directory has entries for special files or links that
1120      * are created when the directory is created. In such implementations a
1121      * directory is considered empty when only the special entries exist.
1122      * This method can be used with the {@link #walkFileTree walkFileTree}
1123      * method to delete a directory and all entries in the directory, or an
1124      * entire &lt;i&gt;file-tree&lt;/i&gt; where required.
1125      *
1126      * &lt;p&gt; On some operating systems it may not be possible to remove a file when
1127      * it is open and in use by this Java virtual machine or other programs.
1128      *
1129      * @param   path
1130      *          the path to the file to delete
1131      *
1132      * @throws  NoSuchFileException
1133      *          if the file does not exist &lt;i&gt;(optional specific exception)&lt;/i&gt;
1134      * @throws  DirectoryNotEmptyException
1135      *          if the file is a directory and could not otherwise be deleted
1136      *          because the directory is not empty &lt;i&gt;(optional specific
1137      *          exception)&lt;/i&gt;
1138      * @throws  IOException
1139      *          if an I/O error occurs
1140      * @throws  SecurityException
1141      *          In the case of the default provider, and a security manager is
1142      *          installed, the {@link SecurityManager#checkDelete(String)} method
1143      *          is invoked to check delete access to the file
1144      */
1145     public static void delete(Path path) throws IOException {
1146         provider(path).delete(path);
1147     }
1148 
1149     /**
1150      * Deletes a file if it exists.
1151      *
1152      * &lt;p&gt; As with the {@link #delete(Path) delete(Path)} method, an
1153      * implementation may need to examine the file to determine if the file is a
1154      * directory. Consequently this method may not be atomic with respect to
1155      * other file system operations.  If the file is a symbolic link, then the
1156      * symbolic link itself, not the final target of the link, is deleted.
1157      *
1158      * &lt;p&gt; If the file is a directory then the directory must be empty. In some
1159      * implementations a directory has entries for special files or links that
1160      * are created when the directory is created. In such implementations a
1161      * directory is considered empty when only the special entries exist.
1162      *
1163      * &lt;p&gt; On some operating systems it may not be possible to remove a file when
1164      * it is open and in use by this Java virtual machine or other programs.
1165      *
1166      * @param   path
1167      *          the path to the file to delete
1168      *
1169      * @return  {@code true} if the file was deleted by this method; {@code
1170      *          false} if the file could not be deleted because it did not
1171      *          exist
1172      *
1173      * @throws  DirectoryNotEmptyException
1174      *          if the file is a directory and could not otherwise be deleted
1175      *          because the directory is not empty &lt;i&gt;(optional specific
1176      *          exception)&lt;/i&gt;
1177      * @throws  IOException
1178      *          if an I/O error occurs
1179      * @throws  SecurityException
1180      *          In the case of the default provider, and a security manager is
1181      *          installed, the {@link SecurityManager#checkDelete(String)} method
1182      *          is invoked to check delete access to the file.
1183      */
1184     public static boolean deleteIfExists(Path path) throws IOException {
1185         return provider(path).deleteIfExists(path);
1186     }
1187 
1188     // -- Copying and moving files --
1189 
1190     /**
1191      * Copy a file to a target file.
1192      *
1193      * &lt;p&gt; This method copies a file to the target file with the {@code
1194      * options} parameter specifying how the copy is performed. By default, the
1195      * copy fails if the target file already exists or is a symbolic link,
1196      * except if the source and target are the {@link #isSameFile same} file, in
1197      * which case the method completes without copying the file. File attributes
1198      * are not required to be copied to the target file. If symbolic links are
1199      * supported, and the file is a symbolic link, then the final target of the
1200      * link is copied. If the file is a directory then it creates an empty
1201      * directory in the target location (entries in the directory are not
1202      * copied). This method can be used with the {@link #walkFileTree
1203      * walkFileTree} method to copy a directory and all entries in the directory,
1204      * or an entire &lt;i&gt;file-tree&lt;/i&gt; where required.
1205      *
1206      * &lt;p&gt; The {@code options} parameter may include any of the following:
1207      *
1208      * &lt;table class=&quot;striped&quot;&gt;
1209      * &lt;caption style=&quot;display:none&quot;&gt;Options&lt;/caption&gt;
1210      * &lt;thead&gt;
1211      * &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;Option&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt; &lt;/tr&gt;
1212      * &lt;/thead&gt;
1213      * &lt;tbody&gt;
1214      * &lt;tr&gt;
1215      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} &lt;/th&gt;
1216      *   &lt;td&gt; If the target file exists, then the target file is replaced if it
1217      *     is not a non-empty directory. If the target file exists and is a
1218      *     symbolic link, then the symbolic link itself, not the target of
1219      *     the link, is replaced. &lt;/td&gt;
1220      * &lt;/tr&gt;
1221      * &lt;tr&gt;
1222      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} &lt;/th&gt;
1223      *   &lt;td&gt; Attempts to copy the file attributes associated with this file to
1224      *     the target file. The exact file attributes that are copied is platform
1225      *     and file system dependent and therefore unspecified. Minimally, the
1226      *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is
1227      *     copied to the target file if supported by both the source and target
1228      *     file stores. Copying of file timestamps may result in precision
1229      *     loss. &lt;/td&gt;
1230      * &lt;/tr&gt;
1231      * &lt;tr&gt;
1232      *   &lt;th scope=&quot;row&quot;&gt; {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} &lt;/th&gt;
1233      *   &lt;td&gt; Symbolic links are not followed. If the file is a symbolic link,
1234      *     then the symbolic link itself, not the target of the link, is copied.
1235      *     It is implementation specific if file attributes can be copied to the
1236      *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be
1237      *     ignored when copying a symbolic link. &lt;/td&gt;
1238      * &lt;/tr&gt;
1239      * &lt;/tbody&gt;
1240      * &lt;/table&gt;
1241      *
1242      * &lt;p&gt; An implementation of this interface may support additional
1243      * implementation specific options.
1244      *
1245      * &lt;p&gt; Copying a file is not an atomic operation. If an {@link IOException}
1246      * is thrown, then it is possible that the target file is incomplete or some
1247      * of its file attributes have not been copied from the source file. When
1248      * the {@code REPLACE_EXISTING} option is specified and the target file
1249      * exists, then the target file is replaced. The check for the existence of
1250      * the file and the creation of the new file may not be atomic with respect
1251      * to other file system activities.
1252      *
1253      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
1254      * Suppose we want to copy a file into a directory, giving it the same file
1255      * name as the source file:
1256      * &lt;pre&gt;
1257      *     Path source = ...
1258      *     Path newdir = ...
1259      *     Files.copy(source, newdir.resolve(source.getFileName());
1260      * &lt;/pre&gt;
1261      *
1262      * @param   source
1263      *          the path to the file to copy
1264      * @param   target
1265      *          the path to the target file (may be associated with a different
1266      *          provider to the source path)
1267      * @param   options
1268      *          options specifying how the copy should be done
1269      *
1270      * @return  the path to the target file
1271      *
1272      * @throws  UnsupportedOperationException
1273      *          if the array contains a copy option that is not supported
1274      * @throws  FileAlreadyExistsException
1275      *          if the target file exists but cannot be replaced because the
1276      *          {@code REPLACE_EXISTING} option is not specified &lt;i&gt;(optional
1277      *          specific exception)&lt;/i&gt;
1278      * @throws  DirectoryNotEmptyException
1279      *          the {@code REPLACE_EXISTING} option is specified but the file
1280      *          cannot be replaced because it is a non-empty directory
1281      *          &lt;i&gt;(optional specific exception)&lt;/i&gt;
1282      * @throws  IOException
1283      *          if an I/O error occurs
1284      * @throws  SecurityException
1285      *          In the case of the default provider, and a security manager is
1286      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
1287      *          method is invoked to check read access to the source file, the
1288      *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked
1289      *          to check write access to the target file. If a symbolic link is
1290      *          copied the security manager is invoked to check {@link
1291      *          LinkPermission}{@code (&quot;symbolic&quot;)}.
1292      */
1293     public static Path copy(Path source, Path target, CopyOption... options)
1294         throws IOException
1295     {
1296         FileSystemProvider provider = provider(source);
1297         if (provider(target) == provider) {
1298             // same provider
1299             provider.copy(source, target, options);
1300         } else {
1301             // different providers
1302             CopyMoveHelper.copyToForeignTarget(source, target, options);
1303         }
1304         return target;
1305     }
1306 
1307     /**
1308      * Move or rename a file to a target file.
1309      *
1310      * &lt;p&gt; By default, this method attempts to move the file to the target
1311      * file, failing if the target file exists except if the source and
1312      * target are the {@link #isSameFile same} file, in which case this method
1313      * has no effect. If the file is a symbolic link then the symbolic link
1314      * itself, not the target of the link, is moved. This method may be
1315      * invoked to move an empty directory. In some implementations a directory
1316      * has entries for special files or links that are created when the
1317      * directory is created. In such implementations a directory is considered
1318      * empty when only the special entries exist. When invoked to move a
1319      * directory that is not empty then the directory is moved if it does not
1320      * require moving the entries in the directory.  For example, renaming a
1321      * directory on the same {@link FileStore} will usually not require moving
1322      * the entries in the directory. When moving a directory requires that its
1323      * entries be moved then this method fails (by throwing an {@code
1324      * IOException}). To move a &lt;i&gt;file tree&lt;/i&gt; may involve copying rather
1325      * than moving directories and this can be done using the {@link
1326      * #copy copy} method in conjunction with the {@link
1327      * #walkFileTree Files.walkFileTree} utility method.
1328      *
1329      * &lt;p&gt; The {@code options} parameter may include any of the following:
1330      *
1331      * &lt;table class=&quot;striped&quot;&gt;
1332      * &lt;caption style=&quot;display:none&quot;&gt;Options&lt;/caption&gt;
1333      * &lt;thead&gt;
1334      * &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;Option&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt; &lt;/tr&gt;
1335      * &lt;/thead&gt;
1336      * &lt;tbody&gt;
1337      * &lt;tr&gt;
1338      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} &lt;/th&gt;
1339      *   &lt;td&gt; If the target file exists, then the target file is replaced if it
1340      *     is not a non-empty directory. If the target file exists and is a
1341      *     symbolic link, then the symbolic link itself, not the target of
1342      *     the link, is replaced. &lt;/td&gt;
1343      * &lt;/tr&gt;
1344      * &lt;tr&gt;
1345      *   &lt;th scope=&quot;row&quot;&gt; {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} &lt;/th&gt;
1346      *   &lt;td&gt; The move is performed as an atomic file system operation and all
1347      *     other options are ignored. If the target file exists then it is
1348      *     implementation specific if the existing file is replaced or this method
1349      *     fails by throwing an {@link IOException}. If the move cannot be
1350      *     performed as an atomic file system operation then {@link
1351      *     AtomicMoveNotSupportedException} is thrown. This can arise, for
1352      *     example, when the target location is on a different {@code FileStore}
1353      *     and would require that the file be copied, or target location is
1354      *     associated with a different provider to this object. &lt;/td&gt;
1355      * &lt;/tbody&gt;
1356      * &lt;/table&gt;
1357      *
1358      * &lt;p&gt; An implementation of this interface may support additional
1359      * implementation specific options.
1360      *
1361      * &lt;p&gt; Moving a file will copy the {@link
1362      * BasicFileAttributes#lastModifiedTime last-modified-time} to the target
1363      * file if supported by both source and target file stores. Copying of file
1364      * timestamps may result in precision loss. An implementation may also
1365      * attempt to copy other file attributes but is not required to fail if the
1366      * file attributes cannot be copied. When the move is performed as
1367      * a non-atomic operation, and an {@code IOException} is thrown, then the
1368      * state of the files is not defined. The original file and the target file
1369      * may both exist, the target file may be incomplete or some of its file
1370      * attributes may not been copied from the original file.
1371      *
1372      * &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
1373      * Suppose we want to rename a file to &quot;newname&quot;, keeping the file in the
1374      * same directory:
1375      * &lt;pre&gt;
1376      *     Path source = ...
1377      *     Files.move(source, source.resolveSibling(&quot;newname&quot;));
1378      * &lt;/pre&gt;
1379      * Alternatively, suppose we want to move a file to new directory, keeping
1380      * the same file name, and replacing any existing file of that name in the
1381      * directory:
1382      * &lt;pre&gt;
1383      *     Path source = ...
1384      *     Path newdir = ...
1385      *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);
1386      * &lt;/pre&gt;
1387      *
1388      * @param   source
1389      *          the path to the file to move
1390      * @param   target
1391      *          the path to the target file (may be associated with a different
1392      *          provider to the source path)
1393      * @param   options
1394      *          options specifying how the move should be done
1395      *
1396      * @return  the path to the target file
1397      *
1398      * @throws  UnsupportedOperationException
1399      *          if the array contains a copy option that is not supported
1400      * @throws  FileAlreadyExistsException
1401      *          if the target file exists but cannot be replaced because the
1402      *          {@code REPLACE_EXISTING} option is not specified &lt;i&gt;(optional
1403      *          specific exception)&lt;/i&gt;
1404      * @throws  DirectoryNotEmptyException
1405      *          the {@code REPLACE_EXISTING} option is specified but the file
1406      *          cannot be replaced because it is a non-empty directory, or the
1407      *          source is a non-empty directory containing entries that would
1408      *          be required to be moved &lt;i&gt;(optional specific exceptions)&lt;/i&gt;
1409      * @throws  AtomicMoveNotSupportedException
1410      *          if the options array contains the {@code ATOMIC_MOVE} option but
1411      *          the file cannot be moved as an atomic file system operation.
1412      * @throws  IOException
1413      *          if an I/O error occurs
1414      * @throws  SecurityException
1415      *          In the case of the default provider, and a security manager is
1416      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
1417      *          method is invoked to check write access to both the source and
1418      *          target file.
1419      */
1420     public static Path move(Path source, Path target, CopyOption... options)
1421         throws IOException
1422     {
1423         FileSystemProvider provider = provider(source);
1424         if (provider(target) == provider) {
1425             // same provider
1426             provider.move(source, target, options);
1427         } else {
1428             // different providers
1429             CopyMoveHelper.moveToForeignTarget(source, target, options);
1430         }
1431         return target;
1432     }
1433 
1434     // -- Miscellaneous --
1435 
1436     /**
1437      * Reads the target of a symbolic link &lt;i&gt;(optional operation)&lt;/i&gt;.
1438      *
1439      * &lt;p&gt; If the file system supports &lt;a href=&quot;package-summary.html#links&quot;&gt;symbolic
1440      * links&lt;/a&gt; then this method is used to read the target of the link, failing
1441      * if the file is not a symbolic link. The target of the link need not exist.
1442      * The returned {@code Path} object will be associated with the same file
1443      * system as {@code link}.
1444      *
1445      * @param   link
1446      *          the path to the symbolic link
1447      *
1448      * @return  a {@code Path} object representing the target of the link
1449      *
1450      * @throws  UnsupportedOperationException
1451      *          if the implementation does not support symbolic links
1452      * @throws  NotLinkException
1453      *          if the target could otherwise not be read because the file
1454      *          is not a symbolic link &lt;i&gt;(optional specific exception)&lt;/i&gt;
1455      * @throws  IOException
1456      *          if an I/O error occurs
1457      * @throws  SecurityException
1458      *          In the case of the default provider, and a security manager
1459      *          is installed, it checks that {@code FilePermission} has been
1460      *          granted with the &quot;{@code readlink}&quot; action to read the link.
1461      */
1462     public static Path readSymbolicLink(Path link) throws IOException {
1463         return provider(link).readSymbolicLink(link);
1464     }
1465 
1466     /**
1467      * Returns the {@link FileStore} representing the file store where a file
1468      * is located.
1469      *
1470      * &lt;p&gt; Once a reference to the {@code FileStore} is obtained it is
1471      * implementation specific if operations on the returned {@code FileStore},
1472      * or {@link FileStoreAttributeView} objects obtained from it, continue
1473      * to depend on the existence of the file. In particular the behavior is not
1474      * defined for the case that the file is deleted or moved to a different
1475      * file store.
1476      *
1477      * @param   path
1478      *          the path to the file
1479      *
1480      * @return  the file store where the file is stored
1481      *
1482      * @throws  IOException
1483      *          if an I/O error occurs
1484      * @throws  SecurityException
1485      *          In the case of the default provider, and a security manager is
1486      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
1487      *          method is invoked to check read access to the file, and in
1488      *          addition it checks
1489      *          {@link RuntimePermission}{@code (&quot;getFileStoreAttributes&quot;)}
1490      */
1491     public static FileStore getFileStore(Path path) throws IOException {
1492         return provider(path).getFileStore(path);
1493     }
1494 
1495     /**
1496      * Tests if two paths locate the same file.
1497      *
1498      * &lt;p&gt; If both {@code Path} objects are {@link Path#equals(Object) equal}
1499      * then this method returns {@code true} without checking if the file exists.
1500      * If the two {@code Path} objects are associated with different providers
1501      * then this method returns {@code false}. Otherwise, this method checks if
1502      * both {@code Path} objects locate the same file, and depending on the
1503      * implementation, may require to open or access both files.
1504      *
1505      * &lt;p&gt; If the file system and files remain static, then this method implements
1506      * an equivalence relation for non-null {@code Paths}.
1507      * &lt;ul&gt;
1508      * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for {@code Path} {@code f},
1509      *     {@code isSameFile(f,f)} should return {@code true}.
1510      * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for two {@code Paths} {@code f} and {@code g},
1511      *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.
1512      * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for three {@code Paths}
1513      *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns
1514      *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then
1515      *     {@code isSameFile(f,h)} will return {@code true}.
1516      * &lt;/ul&gt;
1517      *
1518      * @param   path
1519      *          one path to the file
1520      * @param   path2
1521      *          the other path
1522      *
1523      * @return  {@code true} if, and only if, the two paths locate the same file
1524      *
1525      * @throws  IOException
1526      *          if an I/O error occurs
1527      * @throws  SecurityException
1528      *          In the case of the default provider, and a security manager is
1529      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
1530      *          method is invoked to check read access to both files.
1531      *
1532      * @see java.nio.file.attribute.BasicFileAttributes#fileKey
1533      */
1534     public static boolean isSameFile(Path path, Path path2) throws IOException {
1535         return provider(path).isSameFile(path, path2);
1536     }
1537 
1538     /**
1539      * Finds and returns the position of the first mismatched byte in the content
1540      * of two files, or {@code -1L} if there is no mismatch. The position will be
1541      * in the inclusive range of {@code 0L} up to the size (in bytes) of the
1542      * smaller file.
1543      *
1544      * &lt;p&gt; Two files are considered to match if they satisfy one of the following
1545      * conditions:
1546      * &lt;ul&gt;
1547      * &lt;li&gt; The two paths locate the {@linkplain #isSameFile(Path, Path) same file},
1548      *      even if two {@linkplain Path#equals(Object) equal} paths locate a file
1549      *      does not exist, or &lt;/li&gt;
1550      * &lt;li&gt; The two files are the same size, and every byte in the first file
1551      *      is identical to the corresponding byte in the second file. &lt;/li&gt;
1552      * &lt;/ul&gt;
1553      *
1554      * &lt;p&gt; Otherwise there is a mismatch between the two files and the value
1555      * returned by this method is:
1556      * &lt;ul&gt;
1557      * &lt;li&gt; The position of the first mismatched byte, or &lt;/li&gt;
1558      * &lt;li&gt; The size of the smaller file (in bytes) when the files are different
1559      *      sizes and every byte of the smaller file is identical to the
1560      *      corresponding byte of the larger file. &lt;/li&gt;
1561      * &lt;/ul&gt;
1562      *
1563      * &lt;p&gt; This method may not be atomic with respect to other file system
1564      * operations. This method is always &lt;i&gt;reflexive&lt;/i&gt; (for {@code Path f},
1565      * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files
1566      * remain static, then this method is &lt;i&gt;symmetric&lt;/i&gt; (for two {@code Paths f}
1567      * and {@code g}, {@code mismatch(f,g)} will return the same value as
1568      * {@code mismatch(g,f)}).
1569      *
1570      * @param   path
1571      *          the path to the first file
1572      * @param   path2
1573      *          the path to the second file
1574      *
1575      * @return  the position of the first mismatch or {@code -1L} if no mismatch
1576      *
1577      * @throws  IOException
1578      *          if an I/O error occurs
1579      * @throws  SecurityException
1580      *          In the case of the default provider, and a security manager is
1581      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
1582      *          method is invoked to check read access to both files.
1583      *
1584      * @since 12
1585      */
1586     public static long mismatch(Path path, Path path2) throws IOException {
1587         if (isSameFile(path, path2)) {
1588             return -1;
1589         }
1590         byte[] buffer1 = new byte[BUFFER_SIZE];
1591         byte[] buffer2 = new byte[BUFFER_SIZE];
1592         try (InputStream in1 = Files.newInputStream(path);
1593              InputStream in2 = Files.newInputStream(path2);) {
1594             long totalRead = 0;
1595             while (true) {
1596                 int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);
1597                 int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);
1598 
1599                 int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);
1600                 if (i &gt; -1) {
1601                     return totalRead + i;
1602                 }
1603                 if (nRead1 &lt; BUFFER_SIZE) {
1604                     // we&#39;ve reached the end of the files, but found no mismatch
1605                     return -1;
1606                 }
1607                 totalRead += nRead1;
1608             }
1609         }
1610     }
1611 
1612     /**
1613      * Tells whether or not a file is considered &lt;em&gt;hidden&lt;/em&gt;.
1614      *
1615      * @apiNote
1616      * The exact definition of hidden is platform or provider dependent. On UNIX
1617      * for example a file is considered to be hidden if its name begins with a
1618      * period character (&#39;.&#39;). On Windows a file is considered hidden if the DOS
1619      * {@link DosFileAttributes#isHidden hidden} attribute is set.
1620      *
1621      * &lt;p&gt; Depending on the implementation this method may require to access
1622      * the file system to determine if the file is considered hidden.
1623      *
1624      * @param   path
1625      *          the path to the file to test
1626      *
1627      * @return  {@code true} if the file is considered hidden
1628      *
1629      * @throws  IOException
1630      *          if an I/O error occurs
1631      * @throws  SecurityException
1632      *          In the case of the default provider, and a security manager is
1633      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
1634      *          method is invoked to check read access to the file.
1635      */
1636     public static boolean isHidden(Path path) throws IOException {
1637         return provider(path).isHidden(path);
1638     }
1639 
1640     // lazy loading of default and installed file type detectors
1641     private static class FileTypeDetectors{
1642         static final FileTypeDetector defaultFileTypeDetector =
1643             createDefaultFileTypeDetector();
1644         static final List&lt;FileTypeDetector&gt; installedDetectors =
1645             loadInstalledDetectors();
1646 
1647         // creates the default file type detector
1648         private static FileTypeDetector createDefaultFileTypeDetector() {
1649             return AccessController
1650                 .doPrivileged(new PrivilegedAction&lt;&gt;() {
1651                     @Override public FileTypeDetector run() {
1652                         return sun.nio.fs.DefaultFileTypeDetector.create();
1653                 }});
1654         }
1655 
1656         // loads all installed file type detectors
1657         private static List&lt;FileTypeDetector&gt; loadInstalledDetectors() {
1658             return AccessController
1659                 .doPrivileged(new PrivilegedAction&lt;&gt;() {
1660                     @Override public List&lt;FileTypeDetector&gt; run() {
1661                         List&lt;FileTypeDetector&gt; list = new ArrayList&lt;&gt;();
1662                         ServiceLoader&lt;FileTypeDetector&gt; loader = ServiceLoader
1663                             .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());
1664                         for (FileTypeDetector detector: loader) {
1665                             list.add(detector);
1666                         }
1667                         return list;
1668                 }});
1669         }
1670     }
1671 
1672     /**
1673      * Probes the content type of a file.
1674      *
1675      * &lt;p&gt; This method uses the installed {@link FileTypeDetector} implementations
1676      * to probe the given file to determine its content type. Each file type
1677      * detector&#39;s {@link FileTypeDetector#probeContentType probeContentType} is
1678      * invoked, in turn, to probe the file type. If the file is recognized then
1679      * the content type is returned. If the file is not recognized by any of the
1680      * installed file type detectors then a system-default file type detector is
1681      * invoked to guess the content type.
1682      *
1683      * &lt;p&gt; A given invocation of the Java virtual machine maintains a system-wide
1684      * list of file type detectors. Installed file type detectors are loaded
1685      * using the service-provider loading facility defined by the {@link ServiceLoader}
1686      * class. Installed file type detectors are loaded using the system class
1687      * loader. If the system class loader cannot be found then the platform class
1688      * loader is used. File type detectors are typically installed
1689      * by placing them in a JAR file on the application class path,
1690      * the JAR file contains a provider-configuration file
1691      * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory
1692      * {@code META-INF/services}, and the file lists one or more fully-qualified
1693      * names of concrete subclass of {@code FileTypeDetector } that have a zero
1694      * argument constructor. If the process of locating or instantiating the
1695      * installed file type detectors fails then an unspecified error is thrown.
1696      * The ordering that installed providers are located is implementation
1697      * specific.
1698      *
1699      * &lt;p&gt; The return value of this method is the string form of the value of a
1700      * Multipurpose Internet Mail Extension (MIME) content type as
1701      * defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2045:
1702      * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet
1703      * Message Bodies&lt;/i&gt;&lt;/a&gt;. The string is guaranteed to be parsable according
1704      * to the grammar in the RFC.
1705      *
1706      * @param   path
1707      *          the path to the file to probe
1708      *
1709      * @return  The content type of the file, or {@code null} if the content
1710      *          type cannot be determined
1711      *
1712      * @throws  IOException
1713      *          if an I/O error occurs
1714      * @throws  SecurityException
1715      *          If a security manager is installed and it denies an unspecified
1716      *          permission required by a file type detector implementation.
1717      */
1718     public static String probeContentType(Path path)
1719         throws IOException
1720     {
1721         // try installed file type detectors
1722         for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {
1723             String result = detector.probeContentType(path);
1724             if (result != null)
1725                 return result;
1726         }
1727 
1728         // fallback to default
1729         return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);
1730     }
1731 
1732     // -- File Attributes --
1733 
1734     /**
1735      * Returns a file attribute view of a given type.
1736      *
1737      * &lt;p&gt; A file attribute view provides a read-only or updatable view of a
1738      * set of file attributes. This method is intended to be used where the file
1739      * attribute view defines type-safe methods to read or update the file
1740      * attributes. The {@code type} parameter is the type of the attribute view
1741      * required and the method returns an instance of that type if supported.
1742      * The {@link BasicFileAttributeView} type supports access to the basic
1743      * attributes of a file. Invoking this method to select a file attribute
1744      * view of that type will always return an instance of that class.
1745      *
1746      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
1747      * are handled by the resulting file attribute view for the case that the
1748      * file is a symbolic link. By default, symbolic links are followed. If the
1749      * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then
1750      * symbolic links are not followed. This option is ignored by implementations
1751      * that do not support symbolic links.
1752      *
1753      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
1754      * Suppose we want read or set a file&#39;s ACL, if supported:
1755      * &lt;pre&gt;
1756      *     Path path = ...
1757      *     AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class);
1758      *     if (view != null) {
1759      *         List&amp;lt;AclEntry&amp;gt; acl = view.getAcl();
1760      *         :
1761      *     }
1762      * &lt;/pre&gt;
1763      *
1764      * @param   &lt;V&gt;
1765      *          The {@code FileAttributeView} type
1766      * @param   path
1767      *          the path to the file
1768      * @param   type
1769      *          the {@code Class} object corresponding to the file attribute view
1770      * @param   options
1771      *          options indicating how symbolic links are handled
1772      *
1773      * @return  a file attribute view of the specified type, or {@code null} if
1774      *          the attribute view type is not available
1775      */
1776     public static &lt;V extends FileAttributeView&gt; V getFileAttributeView(Path path,
1777                                                                        Class&lt;V&gt; type,
1778                                                                        LinkOption... options)
1779     {
1780         return provider(path).getFileAttributeView(path, type, options);
1781     }
1782 
1783     /**
1784      * Reads a file&#39;s attributes as a bulk operation.
1785      *
1786      * &lt;p&gt; The {@code type} parameter is the type of the attributes required
1787      * and this method returns an instance of that type if supported. All
1788      * implementations support a basic set of file attributes and so invoking
1789      * this method with a  {@code type} parameter of {@code
1790      * BasicFileAttributes.class} will not throw {@code
1791      * UnsupportedOperationException}.
1792      *
1793      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
1794      * are handled for the case that the file is a symbolic link. By default,
1795      * symbolic links are followed and the file attribute of the final target
1796      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
1797      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
1798      *
1799      * &lt;p&gt; It is implementation specific if all file attributes are read as an
1800      * atomic operation with respect to other file system operations.
1801      *
1802      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
1803      * Suppose we want to read a file&#39;s attributes in bulk:
1804      * &lt;pre&gt;
1805      *    Path path = ...
1806      *    BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
1807      * &lt;/pre&gt;
1808      * Alternatively, suppose we want to read file&#39;s POSIX attributes without
1809      * following symbolic links:
1810      * &lt;pre&gt;
1811      *    PosixFileAttributes attrs =
1812      *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);
1813      * &lt;/pre&gt;
1814      *
1815      * @param   &lt;A&gt;
1816      *          The {@code BasicFileAttributes} type
1817      * @param   path
1818      *          the path to the file
1819      * @param   type
1820      *          the {@code Class} of the file attributes required
1821      *          to read
1822      * @param   options
1823      *          options indicating how symbolic links are handled
1824      *
1825      * @return  the file attributes
1826      *
1827      * @throws  UnsupportedOperationException
1828      *          if an attributes of the given type are not supported
1829      * @throws  IOException
1830      *          if an I/O error occurs
1831      * @throws  SecurityException
1832      *          In the case of the default provider, a security manager is
1833      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
1834      *          method is invoked to check read access to the file. If this
1835      *          method is invoked to read security sensitive attributes then the
1836      *          security manager may be invoke to check for additional permissions.
1837      */
1838     public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,
1839                                                                    Class&lt;A&gt; type,
1840                                                                    LinkOption... options)
1841         throws IOException
1842     {
1843         return provider(path).readAttributes(path, type, options);
1844     }
1845 
1846     /**
1847      * Sets the value of a file attribute.
1848      *
1849      * &lt;p&gt; The {@code attribute} parameter identifies the attribute to be set
1850      * and takes the form:
1851      * &lt;blockquote&gt;
1852      * [&lt;i&gt;view-name&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;]&lt;i&gt;attribute-name&lt;/i&gt;
1853      * &lt;/blockquote&gt;
1854      * where square brackets [...] delineate an optional component and the
1855      * character {@code &#39;:&#39;} stands for itself.
1856      *
1857      * &lt;p&gt; &lt;i&gt;view-name&lt;/i&gt; is the {@link FileAttributeView#name name} of a {@link
1858      * FileAttributeView} that identifies a set of file attributes. If not
1859      * specified then it defaults to {@code &quot;basic&quot;}, the name of the file
1860      * attribute view that identifies the basic set of file attributes common to
1861      * many file systems. &lt;i&gt;attribute-name&lt;/i&gt; is the name of the attribute
1862      * within the set.
1863      *
1864      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
1865      * are handled for the case that the file is a symbolic link. By default,
1866      * symbolic links are followed and the file attribute of the final target
1867      * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS
1868      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
1869      *
1870      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
1871      * Suppose we want to set the DOS &quot;hidden&quot; attribute:
1872      * &lt;pre&gt;
1873      *    Path path = ...
1874      *    Files.setAttribute(path, &quot;dos:hidden&quot;, true);
1875      * &lt;/pre&gt;
1876      *
1877      * @param   path
1878      *          the path to the file
1879      * @param   attribute
1880      *          the attribute to set
1881      * @param   value
1882      *          the attribute value
1883      * @param   options
1884      *          options indicating how symbolic links are handled
1885      *
1886      * @return  the given path
1887      *
1888      * @throws  UnsupportedOperationException
1889      *          if the attribute view is not available
1890      * @throws  IllegalArgumentException
1891      *          if the attribute name is not specified, or is not recognized, or
1892      *          the attribute value is of the correct type but has an
1893      *          inappropriate value
1894      * @throws  ClassCastException
1895      *          if the attribute value is not of the expected type or is a
1896      *          collection containing elements that are not of the expected
1897      *          type
1898      * @throws  IOException
1899      *          if an I/O error occurs
1900      * @throws  SecurityException
1901      *          In the case of the default provider, and a security manager is
1902      *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}
1903      *          method denies write access to the file. If this method is invoked
1904      *          to set security sensitive attributes then the security manager
1905      *          may be invoked to check for additional permissions.
1906      */
1907     public static Path setAttribute(Path path, String attribute, Object value,
1908                                     LinkOption... options)
1909         throws IOException
1910     {
1911         provider(path).setAttribute(path, attribute, value, options);
1912         return path;
1913     }
1914 
1915     /**
1916      * Reads the value of a file attribute.
1917      *
1918      * &lt;p&gt; The {@code attribute} parameter identifies the attribute to be read
1919      * and takes the form:
1920      * &lt;blockquote&gt;
1921      * [&lt;i&gt;view-name&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;]&lt;i&gt;attribute-name&lt;/i&gt;
1922      * &lt;/blockquote&gt;
1923      * where square brackets [...] delineate an optional component and the
1924      * character {@code &#39;:&#39;} stands for itself.
1925      *
1926      * &lt;p&gt; &lt;i&gt;view-name&lt;/i&gt; is the {@link FileAttributeView#name name} of a {@link
1927      * FileAttributeView} that identifies a set of file attributes. If not
1928      * specified then it defaults to {@code &quot;basic&quot;}, the name of the file
1929      * attribute view that identifies the basic set of file attributes common to
1930      * many file systems. &lt;i&gt;attribute-name&lt;/i&gt; is the name of the attribute.
1931      *
1932      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
1933      * are handled for the case that the file is a symbolic link. By default,
1934      * symbolic links are followed and the file attribute of the final target
1935      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
1936      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
1937      *
1938      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
1939      * Suppose we require the user ID of the file owner on a system that
1940      * supports a &quot;{@code unix}&quot; view:
1941      * &lt;pre&gt;
1942      *    Path path = ...
1943      *    int uid = (Integer)Files.getAttribute(path, &quot;unix:uid&quot;);
1944      * &lt;/pre&gt;
1945      *
1946      * @param   path
1947      *          the path to the file
1948      * @param   attribute
1949      *          the attribute to read
1950      * @param   options
1951      *          options indicating how symbolic links are handled
1952      *
1953      * @return  the attribute value
1954      *
1955      * @throws  UnsupportedOperationException
1956      *          if the attribute view is not available
1957      * @throws  IllegalArgumentException
1958      *          if the attribute name is not specified or is not recognized
1959      * @throws  IOException
1960      *          if an I/O error occurs
1961      * @throws  SecurityException
1962      *          In the case of the default provider, and a security manager is
1963      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
1964      *          method denies read access to the file. If this method is invoked
1965      *          to read security sensitive attributes then the security manager
1966      *          may be invoked to check for additional permissions.
1967      */
1968     public static Object getAttribute(Path path, String attribute,
1969                                       LinkOption... options)
1970         throws IOException
1971     {
1972         // only one attribute should be read
1973         if (attribute.indexOf(&#39;*&#39;) &gt;= 0 || attribute.indexOf(&#39;,&#39;) &gt;= 0)
1974             throw new IllegalArgumentException(attribute);
1975         Map&lt;String,Object&gt; map = readAttributes(path, attribute, options);
1976         assert map.size() == 1;
1977         String name;
1978         int pos = attribute.indexOf(&#39;:&#39;);
1979         if (pos == -1) {
1980             name = attribute;
1981         } else {
1982             name = (pos == attribute.length()) ? &quot;&quot; : attribute.substring(pos+1);
1983         }
1984         return map.get(name);
1985     }
1986 
1987     /**
1988      * Reads a set of file attributes as a bulk operation.
1989      *
1990      * &lt;p&gt; The {@code attributes} parameter identifies the attributes to be read
1991      * and takes the form:
1992      * &lt;blockquote&gt;
1993      * [&lt;i&gt;view-name&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;]&lt;i&gt;attribute-list&lt;/i&gt;
1994      * &lt;/blockquote&gt;
1995      * where square brackets [...] delineate an optional component and the
1996      * character {@code &#39;:&#39;} stands for itself.
1997      *
1998      * &lt;p&gt; &lt;i&gt;view-name&lt;/i&gt; is the {@link FileAttributeView#name name} of a {@link
1999      * FileAttributeView} that identifies a set of file attributes. If not
2000      * specified then it defaults to {@code &quot;basic&quot;}, the name of the file
2001      * attribute view that identifies the basic set of file attributes common to
2002      * many file systems.
2003      *
2004      * &lt;p&gt; The &lt;i&gt;attribute-list&lt;/i&gt; component is a comma separated list of
2005      * one or more names of attributes to read. If the list contains the value
2006      * {@code &quot;*&quot;} then all attributes are read. Attributes that are not supported
2007      * are ignored and will not be present in the returned map. It is
2008      * implementation specific if all attributes are read as an atomic operation
2009      * with respect to other file system operations.
2010      *
2011      * &lt;p&gt; The following examples demonstrate possible values for the {@code
2012      * attributes} parameter:
2013      *
2014      * &lt;table class=&quot;striped&quot; style=&quot;text-align: left; margin-left:2em&quot;&gt;
2015      * &lt;caption style=&quot;display:none&quot;&gt;Possible values&lt;/caption&gt;
2016      * &lt;thead&gt;
2017      * &lt;tr&gt;
2018      *  &lt;th scope=&quot;col&quot;&gt;Example
2019      *  &lt;th scope=&quot;col&quot;&gt;Description
2020      * &lt;/thead&gt;
2021      * &lt;tbody&gt;
2022      * &lt;tr&gt;
2023      *   &lt;th scope=&quot;row&quot;&gt; {@code &quot;*&quot;} &lt;/th&gt;
2024      *   &lt;td&gt; Read all {@link BasicFileAttributes basic-file-attributes}. &lt;/td&gt;
2025      * &lt;/tr&gt;
2026      * &lt;tr&gt;
2027      *   &lt;th scope=&quot;row&quot;&gt; {@code &quot;size,lastModifiedTime,lastAccessTime&quot;} &lt;/th&gt;
2028      *   &lt;td&gt; Reads the file size, last modified time, and last access time
2029      *     attributes. &lt;/td&gt;
2030      * &lt;/tr&gt;
2031      * &lt;tr&gt;
2032      *   &lt;th scope=&quot;row&quot;&gt; {@code &quot;posix:*&quot;} &lt;/th&gt;
2033      *   &lt;td&gt; Read all {@link PosixFileAttributes POSIX-file-attributes}. &lt;/td&gt;
2034      * &lt;/tr&gt;
2035      * &lt;tr&gt;
2036      *   &lt;th scope=&quot;row&quot;&gt; {@code &quot;posix:permissions,owner,size&quot;} &lt;/th&gt;
2037      *   &lt;td&gt; Reads the POSIX file permissions, owner, and file size. &lt;/td&gt;
2038      * &lt;/tr&gt;
2039      * &lt;/tbody&gt;
2040      * &lt;/table&gt;
2041      *
2042      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
2043      * are handled for the case that the file is a symbolic link. By default,
2044      * symbolic links are followed and the file attribute of the final target
2045      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
2046      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2047      *
2048      * @param   path
2049      *          the path to the file
2050      * @param   attributes
2051      *          the attributes to read
2052      * @param   options
2053      *          options indicating how symbolic links are handled
2054      *
2055      * @return  a map of the attributes returned; The map&#39;s keys are the
2056      *          attribute names, its values are the attribute values
2057      *
2058      * @throws  UnsupportedOperationException
2059      *          if the attribute view is not available
2060      * @throws  IllegalArgumentException
2061      *          if no attributes are specified or an unrecognized attribute is
2062      *          specified
2063      * @throws  IOException
2064      *          if an I/O error occurs
2065      * @throws  SecurityException
2066      *          In the case of the default provider, and a security manager is
2067      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
2068      *          method denies read access to the file. If this method is invoked
2069      *          to read security sensitive attributes then the security manager
2070      *          may be invoke to check for additional permissions.
2071      */
2072     public static Map&lt;String,Object&gt; readAttributes(Path path, String attributes,
2073                                                     LinkOption... options)
2074         throws IOException
2075     {
2076         return provider(path).readAttributes(path, attributes, options);
2077     }
2078 
2079     /**
2080      * Returns a file&#39;s POSIX file permissions.
2081      *
2082      * &lt;p&gt; The {@code path} parameter is associated with a {@code FileSystem}
2083      * that supports the {@link PosixFileAttributeView}. This attribute view
2084      * provides access to file attributes commonly associated with files on file
2085      * systems used by operating systems that implement the Portable Operating
2086      * System Interface (POSIX) family of standards.
2087      *
2088      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
2089      * are handled for the case that the file is a symbolic link. By default,
2090      * symbolic links are followed and the file attribute of the final target
2091      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
2092      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2093      *
2094      * @param   path
2095      *          the path to the file
2096      * @param   options
2097      *          options indicating how symbolic links are handled
2098      *
2099      * @return  the file permissions
2100      *
2101      * @throws  UnsupportedOperationException
2102      *          if the associated file system does not support the {@code
2103      *          PosixFileAttributeView}
2104      * @throws  IOException
2105      *          if an I/O error occurs
2106      * @throws  SecurityException
2107      *          In the case of the default provider, a security manager is
2108      *          installed, and it denies
2109      *          {@link RuntimePermission}{@code (&quot;accessUserInformation&quot;)}
2110      *          or its {@link SecurityManager#checkRead(String) checkRead} method
2111      *          denies read access to the file.
2112      */
2113     public static Set&lt;PosixFilePermission&gt; getPosixFilePermissions(Path path,
2114                                                                    LinkOption... options)
2115         throws IOException
2116     {
2117         return readAttributes(path, PosixFileAttributes.class, options).permissions();
2118     }
2119 
2120     /**
2121      * Sets a file&#39;s POSIX permissions.
2122      *
2123      * &lt;p&gt; The {@code path} parameter is associated with a {@code FileSystem}
2124      * that supports the {@link PosixFileAttributeView}. This attribute view
2125      * provides access to file attributes commonly associated with files on file
2126      * systems used by operating systems that implement the Portable Operating
2127      * System Interface (POSIX) family of standards.
2128      *
2129      * @param   path
2130      *          The path to the file
2131      * @param   perms
2132      *          The new set of permissions
2133      *
2134      * @return  The given path
2135      *
2136      * @throws  UnsupportedOperationException
2137      *          if the associated file system does not support the {@code
2138      *          PosixFileAttributeView}
2139      * @throws  ClassCastException
2140      *          if the sets contains elements that are not of type {@code
2141      *          PosixFilePermission}
2142      * @throws  IOException
2143      *          if an I/O error occurs
2144      * @throws  SecurityException
2145      *          In the case of the default provider, and a security manager is
2146      *          installed, it denies
2147      *          {@link RuntimePermission}{@code (&quot;accessUserInformation&quot;)}
2148      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
2149      *          method denies write access to the file.
2150      */
2151     public static Path setPosixFilePermissions(Path path,
2152                                                Set&lt;PosixFilePermission&gt; perms)
2153         throws IOException
2154     {
2155         PosixFileAttributeView view =
2156             getFileAttributeView(path, PosixFileAttributeView.class);
2157         if (view == null)
2158             throw new UnsupportedOperationException();
2159         view.setPermissions(perms);
2160         return path;
2161     }
2162 
2163     /**
2164      * Returns the owner of a file.
2165      *
2166      * &lt;p&gt; The {@code path} parameter is associated with a file system that
2167      * supports {@link FileOwnerAttributeView}. This file attribute view provides
2168      * access to a file attribute that is the owner of the file.
2169      *
2170      * @param   path
2171      *          The path to the file
2172      * @param   options
2173      *          options indicating how symbolic links are handled
2174      *
2175      * @return  A user principal representing the owner of the file
2176      *
2177      * @throws  UnsupportedOperationException
2178      *          if the associated file system does not support the {@code
2179      *          FileOwnerAttributeView}
2180      * @throws  IOException
2181      *          if an I/O error occurs
2182      * @throws  SecurityException
2183      *          In the case of the default provider, and a security manager is
2184      *          installed, it denies
2185      *          {@link RuntimePermission}{@code (&quot;accessUserInformation&quot;)}
2186      *          or its {@link SecurityManager#checkRead(String) checkRead} method
2187      *          denies read access to the file.
2188      */
2189     public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {
2190         FileOwnerAttributeView view =
2191             getFileAttributeView(path, FileOwnerAttributeView.class, options);
2192         if (view == null)
2193             throw new UnsupportedOperationException();
2194         return view.getOwner();
2195     }
2196 
2197     /**
2198      * Updates the file owner.
2199      *
2200      * &lt;p&gt; The {@code path} parameter is associated with a file system that
2201      * supports {@link FileOwnerAttributeView}. This file attribute view provides
2202      * access to a file attribute that is the owner of the file.
2203      *
2204      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
2205      * Suppose we want to make &quot;joe&quot; the owner of a file:
2206      * &lt;pre&gt;
2207      *     Path path = ...
2208      *     UserPrincipalLookupService lookupService =
2209      *         provider(path).getUserPrincipalLookupService();
2210      *     UserPrincipal joe = lookupService.lookupPrincipalByName(&quot;joe&quot;);
2211      *     Files.setOwner(path, joe);
2212      * &lt;/pre&gt;
2213      *
2214      * @param   path
2215      *          The path to the file
2216      * @param   owner
2217      *          The new file owner
2218      *
2219      * @return  The given path
2220      *
2221      * @throws  UnsupportedOperationException
2222      *          if the associated file system does not support the {@code
2223      *          FileOwnerAttributeView}
2224      * @throws  IOException
2225      *          if an I/O error occurs
2226      * @throws  SecurityException
2227      *          In the case of the default provider, and a security manager is
2228      *          installed, it denies
2229      *          {@link RuntimePermission}{@code (&quot;accessUserInformation&quot;)}
2230      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
2231      *          method denies write access to the file.
2232      *
2233      * @see FileSystem#getUserPrincipalLookupService
2234      * @see java.nio.file.attribute.UserPrincipalLookupService
2235      */
2236     public static Path setOwner(Path path, UserPrincipal owner)
2237         throws IOException
2238     {
2239         FileOwnerAttributeView view =
2240             getFileAttributeView(path, FileOwnerAttributeView.class);
2241         if (view == null)
2242             throw new UnsupportedOperationException();
2243         view.setOwner(owner);
2244         return path;
2245     }
2246 
2247     /**
2248      * Tests whether a file is a symbolic link.
2249      *
2250      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
2251      * that the file is not a symbolic link then the file attributes can be
2252      * read with the {@link #readAttributes(Path,Class,LinkOption[])
2253      * readAttributes} method and the file type tested with the {@link
2254      * BasicFileAttributes#isSymbolicLink} method.
2255      *
2256      * @param   path  The path to the file
2257      *
2258      * @return  {@code true} if the file is a symbolic link; {@code false} if
2259      *          the file does not exist, is not a symbolic link, or it cannot
2260      *          be determined if the file is a symbolic link or not.
2261      *
2262      * @throws  SecurityException
2263      *          In the case of the default provider, and a security manager is
2264      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
2265      *          method denies read access to the file.
2266      */
2267     public static boolean isSymbolicLink(Path path) {
2268         try {
2269             return readAttributes(path,
2270                                   BasicFileAttributes.class,
2271                                   LinkOption.NOFOLLOW_LINKS).isSymbolicLink();
2272         } catch (IOException ioe) {
2273             return false;
2274         }
2275     }
2276 
2277     /**
2278      * Tests whether a file is a directory.
2279      *
2280      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
2281      * are handled for the case that the file is a symbolic link. By default,
2282      * symbolic links are followed and the file attribute of the final target
2283      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
2284      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2285      *
2286      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
2287      * that the file is not a directory then the file attributes can be
2288      * read with the {@link #readAttributes(Path,Class,LinkOption[])
2289      * readAttributes} method and the file type tested with the {@link
2290      * BasicFileAttributes#isDirectory} method.
2291      *
2292      * @param   path
2293      *          the path to the file to test
2294      * @param   options
2295      *          options indicating how symbolic links are handled
2296      *
2297      * @return  {@code true} if the file is a directory; {@code false} if
2298      *          the file does not exist, is not a directory, or it cannot
2299      *          be determined if the file is a directory or not.
2300      *
2301      * @throws  SecurityException
2302      *          In the case of the default provider, and a security manager is
2303      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
2304      *          method denies read access to the file.
2305      */
2306     public static boolean isDirectory(Path path, LinkOption... options) {
2307         if (options.length == 0) {
2308             FileSystemProvider provider = provider(path);
2309             if (provider instanceof AbstractFileSystemProvider)
2310                 return ((AbstractFileSystemProvider)provider).isDirectory(path);
2311         }
2312 
2313         try {
2314             return readAttributes(path, BasicFileAttributes.class, options).isDirectory();
2315         } catch (IOException ioe) {
2316             return false;
2317         }
2318     }
2319 
2320     /**
2321      * Tests whether a file is a regular file with opaque content.
2322      *
2323      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
2324      * are handled for the case that the file is a symbolic link. By default,
2325      * symbolic links are followed and the file attribute of the final target
2326      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
2327      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2328      *
2329      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
2330      * that the file is not a regular file then the file attributes can be
2331      * read with the {@link #readAttributes(Path,Class,LinkOption[])
2332      * readAttributes} method and the file type tested with the {@link
2333      * BasicFileAttributes#isRegularFile} method.
2334      *
2335      * @param   path
2336      *          the path to the file
2337      * @param   options
2338      *          options indicating how symbolic links are handled
2339      *
2340      * @return  {@code true} if the file is a regular file; {@code false} if
2341      *          the file does not exist, is not a regular file, or it
2342      *          cannot be determined if the file is a regular file or not.
2343      *
2344      * @throws  SecurityException
2345      *          In the case of the default provider, and a security manager is
2346      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
2347      *          method denies read access to the file.
2348      */
2349     public static boolean isRegularFile(Path path, LinkOption... options) {
2350         if (options.length == 0) {
2351             FileSystemProvider provider = provider(path);
2352             if (provider instanceof AbstractFileSystemProvider)
2353                 return ((AbstractFileSystemProvider)provider).isRegularFile(path);
2354         }
2355 
2356         try {
2357             return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();
2358         } catch (IOException ioe) {
2359             return false;
2360         }
2361     }
2362 
2363     /**
2364      * Returns a file&#39;s last modified time.
2365      *
2366      * &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
2367      * are handled for the case that the file is a symbolic link. By default,
2368      * symbolic links are followed and the file attribute of the final target
2369      * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
2370      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2371      *
2372      * @param   path
2373      *          the path to the file
2374      * @param   options
2375      *          options indicating how symbolic links are handled
2376      *
2377      * @return  a {@code FileTime} representing the time the file was last
2378      *          modified, or an implementation specific default when a time
2379      *          stamp to indicate the time of last modification is not supported
2380      *          by the file system
2381      *
2382      * @throws  IOException
2383      *          if an I/O error occurs
2384      * @throws  SecurityException
2385      *          In the case of the default provider, and a security manager is
2386      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
2387      *          method denies read access to the file.
2388      *
2389      * @see BasicFileAttributes#lastModifiedTime
2390      */
2391     public static FileTime getLastModifiedTime(Path path, LinkOption... options)
2392         throws IOException
2393     {
2394         return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();
2395     }
2396 
2397     /**
2398      * Updates a file&#39;s last modified time attribute. The file time is converted
2399      * to the epoch and precision supported by the file system. Converting from
2400      * finer to coarser granularities result in precision loss. The behavior of
2401      * this method when attempting to set the last modified time when it is not
2402      * supported by the file system or is outside the range supported by the
2403      * underlying file store is not defined. It may or not fail by throwing an
2404      * {@code IOException}.
2405      *
2406      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
2407      * Suppose we want to set the last modified time to the current time:
2408      * &lt;pre&gt;
2409      *    Path path = ...
2410      *    FileTime now = FileTime.fromMillis(System.currentTimeMillis());
2411      *    Files.setLastModifiedTime(path, now);
2412      * &lt;/pre&gt;
2413      *
2414      * @param   path
2415      *          the path to the file
2416      * @param   time
2417      *          the new last modified time
2418      *
2419      * @return  the given path
2420      *
2421      * @throws  IOException
2422      *          if an I/O error occurs
2423      * @throws  SecurityException
2424      *          In the case of the default provider, and a security manager is
2425      *          installed, its {@link SecurityManager#checkWrite(String)
2426      *          checkWrite} method denies write access to the file.
2427      *
2428      * @see BasicFileAttributeView#setTimes
2429      */
2430     public static Path setLastModifiedTime(Path path, FileTime time)
2431         throws IOException
2432     {
2433         getFileAttributeView(path, BasicFileAttributeView.class)
2434             .setTimes(Objects.requireNonNull(time), null, null);
2435         return path;
2436     }
2437 
2438     /**
2439      * Returns the size of a file (in bytes). The size may differ from the
2440      * actual size on the file system due to compression, support for sparse
2441      * files, or other reasons. The size of files that are not {@link
2442      * #isRegularFile regular} files is implementation specific and
2443      * therefore unspecified.
2444      *
2445      * @param   path
2446      *          the path to the file
2447      *
2448      * @return  the file size, in bytes
2449      *
2450      * @throws  IOException
2451      *          if an I/O error occurs
2452      * @throws  SecurityException
2453      *          In the case of the default provider, and a security manager is
2454      *          installed, its {@link SecurityManager#checkRead(String) checkRead}
2455      *          method denies read access to the file.
2456      *
2457      * @see BasicFileAttributes#size
2458      */
2459     public static long size(Path path) throws IOException {
2460         return readAttributes(path, BasicFileAttributes.class).size();
2461     }
2462 
2463     // -- Accessibility --
2464 
2465     /**
2466      * Returns {@code false} if NOFOLLOW_LINKS is present.
2467      */
2468     private static boolean followLinks(LinkOption... options) {
2469         boolean followLinks = true;
2470         for (LinkOption opt: options) {
2471             if (opt == LinkOption.NOFOLLOW_LINKS) {
2472                 followLinks = false;
2473                 continue;
2474             }
2475             if (opt == null)
2476                 throw new NullPointerException();
2477             throw new AssertionError(&quot;Should not get here&quot;);
2478         }
2479         return followLinks;
2480     }
2481 
2482     /**
2483      * Tests whether a file exists.
2484      *
2485      * &lt;p&gt; The {@code options} parameter may be used to indicate how symbolic links
2486      * are handled for the case that the file is a symbolic link. By default,
2487      * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS
2488      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2489      *
2490      * &lt;p&gt; Note that the result of this method is immediately outdated. If this
2491      * method indicates the file exists then there is no guarantee that a
2492      * subsequent access will succeed. Care should be taken when using this
2493      * method in security sensitive applications.
2494      *
2495      * @param   path
2496      *          the path to the file to test
2497      * @param   options
2498      *          options indicating how symbolic links are handled
2499      * .
2500      * @return  {@code true} if the file exists; {@code false} if the file does
2501      *          not exist or its existence cannot be determined.
2502      *
2503      * @throws  SecurityException
2504      *          In the case of the default provider, the {@link
2505      *          SecurityManager#checkRead(String)} is invoked to check
2506      *          read access to the file.
2507      *
2508      * @see #notExists
2509      */
2510     public static boolean exists(Path path, LinkOption... options) {
2511         if (options.length == 0) {
2512             FileSystemProvider provider = provider(path);
2513             if (provider instanceof AbstractFileSystemProvider)
2514                 return ((AbstractFileSystemProvider)provider).exists(path);
2515         }
2516 
2517         try {
2518             if (followLinks(options)) {
2519                 provider(path).checkAccess(path);
2520             } else {
2521                 // attempt to read attributes without following links
2522                 readAttributes(path, BasicFileAttributes.class,
2523                                LinkOption.NOFOLLOW_LINKS);
2524             }
2525             // file exists
2526             return true;
2527         } catch (IOException x) {
2528             // does not exist or unable to determine if file exists
2529             return false;
2530         }
2531 
2532     }
2533 
2534     /**
2535      * Tests whether the file located by this path does not exist. This method
2536      * is intended for cases where it is required to take action when it can be
2537      * confirmed that a file does not exist.
2538      *
2539      * &lt;p&gt; The {@code options} parameter may be used to indicate how symbolic links
2540      * are handled for the case that the file is a symbolic link. By default,
2541      * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS
2542      * NOFOLLOW_LINKS} is present then symbolic links are not followed.
2543      *
2544      * &lt;p&gt; Note that this method is not the complement of the {@link #exists
2545      * exists} method. Where it is not possible to determine if a file exists
2546      * or not then both methods return {@code false}. As with the {@code exists}
2547      * method, the result of this method is immediately outdated. If this
2548      * method indicates the file does exist then there is no guarantee that a
2549      * subsequent attempt to create the file will succeed. Care should be taken
2550      * when using this method in security sensitive applications.
2551      *
2552      * @param   path
2553      *          the path to the file to test
2554      * @param   options
2555      *          options indicating how symbolic links are handled
2556      *
2557      * @return  {@code true} if the file does not exist; {@code false} if the
2558      *          file exists or its existence cannot be determined
2559      *
2560      * @throws  SecurityException
2561      *          In the case of the default provider, the {@link
2562      *          SecurityManager#checkRead(String)} is invoked to check
2563      *          read access to the file.
2564      */
2565     public static boolean notExists(Path path, LinkOption... options) {
2566         try {
2567             if (followLinks(options)) {
2568                 provider(path).checkAccess(path);
2569             } else {
2570                 // attempt to read attributes without following links
2571                 readAttributes(path, BasicFileAttributes.class,
2572                                LinkOption.NOFOLLOW_LINKS);
2573             }
2574             // file exists
2575             return false;
2576         } catch (NoSuchFileException x) {
2577             // file confirmed not to exist
2578             return true;
2579         } catch (IOException x) {
2580             return false;
2581         }
2582     }
2583 
2584     /**
2585      * Used by isReadable, isWritable, isExecutable to test access to a file.
2586      */
2587     private static boolean isAccessible(Path path, AccessMode... modes) {
2588         try {
2589             provider(path).checkAccess(path, modes);
2590             return true;
2591         } catch (IOException x) {
2592             return false;
2593         }
2594     }
2595 
2596     /**
2597      * Tests whether a file is readable. This method checks that a file exists
2598      * and that this Java virtual machine has appropriate privileges that would
2599      * allow it open the file for reading. Depending on the implementation, this
2600      * method may require to read file permissions, access control lists, or
2601      * other file attributes in order to check the effective access to the file.
2602      * Consequently, this method may not be atomic with respect to other file
2603      * system operations.
2604      *
2605      * &lt;p&gt; Note that the result of this method is immediately outdated, there is
2606      * no guarantee that a subsequent attempt to open the file for reading will
2607      * succeed (or even that it will access the same file). Care should be taken
2608      * when using this method in security sensitive applications.
2609      *
2610      * @param   path
2611      *          the path to the file to check
2612      *
2613      * @return  {@code true} if the file exists and is readable; {@code false}
2614      *          if the file does not exist, read access would be denied because
2615      *          the Java virtual machine has insufficient privileges, or access
2616      *          cannot be determined
2617      *
2618      * @throws  SecurityException
2619      *          In the case of the default provider, and a security manager is
2620      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
2621      *          is invoked to check read access to the file.
2622      */
2623     public static boolean isReadable(Path path) {
2624         return isAccessible(path, AccessMode.READ);
2625     }
2626 
2627     /**
2628      * Tests whether a file is writable. This method checks that a file exists
2629      * and that this Java virtual machine has appropriate privileges that would
2630      * allow it open the file for writing. Depending on the implementation, this
2631      * method may require to read file permissions, access control lists, or
2632      * other file attributes in order to check the effective access to the file.
2633      * Consequently, this method may not be atomic with respect to other file
2634      * system operations.
2635      *
2636      * &lt;p&gt; Note that result of this method is immediately outdated, there is no
2637      * guarantee that a subsequent attempt to open the file for writing will
2638      * succeed (or even that it will access the same file). Care should be taken
2639      * when using this method in security sensitive applications.
2640      *
2641      * @param   path
2642      *          the path to the file to check
2643      *
2644      * @return  {@code true} if the file exists and is writable; {@code false}
2645      *          if the file does not exist, write access would be denied because
2646      *          the Java virtual machine has insufficient privileges, or access
2647      *          cannot be determined
2648      *
2649      * @throws  SecurityException
2650      *          In the case of the default provider, and a security manager is
2651      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
2652      *          is invoked to check write access to the file.
2653      */
2654     public static boolean isWritable(Path path) {
2655         return isAccessible(path, AccessMode.WRITE);
2656     }
2657 
2658     /**
2659      * Tests whether a file is executable. This method checks that a file exists
2660      * and that this Java virtual machine has appropriate privileges to {@link
2661      * Runtime#exec execute} the file. The semantics may differ when checking
2662      * access to a directory. For example, on UNIX systems, checking for
2663      * execute access checks that the Java virtual machine has permission to
2664      * search the directory in order to access file or subdirectories.
2665      *
2666      * &lt;p&gt; Depending on the implementation, this method may require to read file
2667      * permissions, access control lists, or other file attributes in order to
2668      * check the effective access to the file. Consequently, this method may not
2669      * be atomic with respect to other file system operations.
2670      *
2671      * &lt;p&gt; Note that the result of this method is immediately outdated, there is
2672      * no guarantee that a subsequent attempt to execute the file will succeed
2673      * (or even that it will access the same file). Care should be taken when
2674      * using this method in security sensitive applications.
2675      *
2676      * @param   path
2677      *          the path to the file to check
2678      *
2679      * @return  {@code true} if the file exists and is executable; {@code false}
2680      *          if the file does not exist, execute access would be denied because
2681      *          the Java virtual machine has insufficient privileges, or access
2682      *          cannot be determined
2683      *
2684      * @throws  SecurityException
2685      *          In the case of the default provider, and a security manager is
2686      *          installed, the {@link SecurityManager#checkExec(String)
2687      *          checkExec} is invoked to check execute access to the file.
2688      */
2689     public static boolean isExecutable(Path path) {
2690         return isAccessible(path, AccessMode.EXECUTE);
2691     }
2692 
2693     // -- Recursive operations --
2694 
2695     /**
2696      * Walks a file tree.
2697      *
2698      * &lt;p&gt; This method walks a file tree rooted at a given starting file. The
2699      * file tree traversal is &lt;em&gt;depth-first&lt;/em&gt; with the given {@link
2700      * FileVisitor} invoked for each file encountered. File tree traversal
2701      * completes when all accessible files in the tree have been visited, or a
2702      * visit method returns a result of {@link FileVisitResult#TERMINATE
2703      * TERMINATE}. Where a visit method terminates due an {@code IOException},
2704      * an uncaught error, or runtime exception, then the traversal is terminated
2705      * and the error or exception is propagated to the caller of this method.
2706      *
2707      * &lt;p&gt; For each file encountered this method attempts to read its {@link
2708      * java.nio.file.attribute.BasicFileAttributes}. If the file is not a
2709      * directory then the {@link FileVisitor#visitFile visitFile} method is
2710      * invoked with the file attributes. If the file attributes cannot be read,
2711      * due to an I/O exception, then the {@link FileVisitor#visitFileFailed
2712      * visitFileFailed} method is invoked with the I/O exception.
2713      *
2714      * &lt;p&gt; Where the file is a directory, and the directory could not be opened,
2715      * then the {@code visitFileFailed} method is invoked with the I/O exception,
2716      * after which, the file tree walk continues, by default, at the next
2717      * &lt;em&gt;sibling&lt;/em&gt; of the directory.
2718      *
2719      * &lt;p&gt; Where the directory is opened successfully, then the entries in the
2720      * directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries
2721      * have been visited, or an I/O error occurs during iteration of the
2722      * directory, then the directory is closed and the visitor&#39;s {@link
2723      * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.
2724      * The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt;
2725      * of the directory.
2726      *
2727      * &lt;p&gt; By default, symbolic links are not automatically followed by this
2728      * method. If the {@code options} parameter contains the {@link
2729      * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are
2730      * followed. When following links, and the attributes of the target cannot
2731      * be read, then this method attempts to get the {@code BasicFileAttributes}
2732      * of the link. If they can be read then the {@code visitFile} method is
2733      * invoked with the attributes of the link (otherwise the {@code visitFileFailed}
2734      * method is invoked as specified above).
2735      *
2736      * &lt;p&gt; If the {@code options} parameter contains the {@link
2737      * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps
2738      * track of directories visited so that cycles can be detected. A cycle
2739      * arises when there is an entry in a directory that is an ancestor of the
2740      * directory. Cycle detection is done by recording the {@link
2741      * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,
2742      * or if file keys are not available, by invoking the {@link #isSameFile
2743      * isSameFile} method to test if a directory is the same file as an
2744      * ancestor. When a cycle is detected it is treated as an I/O error, and the
2745      * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with
2746      * an instance of {@link FileSystemLoopException}.
2747      *
2748      * &lt;p&gt; The {@code maxDepth} parameter is the maximum number of levels of
2749      * directories to visit. A value of {@code 0} means that only the starting
2750      * file is visited, unless denied by the security manager. A value of
2751      * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all
2752      * levels should be visited. The {@code visitFile} method is invoked for all
2753      * files, including directories, encountered at {@code maxDepth}, unless the
2754      * basic file attributes cannot be read, in which case the {@code
2755      * visitFileFailed} method is invoked.
2756      *
2757      * &lt;p&gt; If a visitor returns a result of {@code null} then {@code
2758      * NullPointerException} is thrown.
2759      *
2760      * &lt;p&gt; When a security manager is installed and it denies access to a file
2761      * (or directory), then it is ignored and the visitor is not invoked for
2762      * that file (or directory).
2763      *
2764      * @param   start
2765      *          the starting file
2766      * @param   options
2767      *          options to configure the traversal
2768      * @param   maxDepth
2769      *          the maximum number of directory levels to visit
2770      * @param   visitor
2771      *          the file visitor to invoke for each file
2772      *
2773      * @return  the starting file
2774      *
2775      * @throws  IllegalArgumentException
2776      *          if the {@code maxDepth} parameter is negative
2777      * @throws  SecurityException
2778      *          If the security manager denies access to the starting file.
2779      *          In the case of the default provider, the {@link
2780      *          SecurityManager#checkRead(String) checkRead} method is invoked
2781      *          to check read access to the directory.
2782      * @throws  IOException
2783      *          if an I/O error is thrown by a visitor method
2784      */
2785     public static Path walkFileTree(Path start,
2786                                     Set&lt;FileVisitOption&gt; options,
2787                                     int maxDepth,
2788                                     FileVisitor&lt;? super Path&gt; visitor)
2789         throws IOException
2790     {
2791         /**
2792          * Create a FileTreeWalker to walk the file tree, invoking the visitor
2793          * for each event.
2794          */
2795         try (FileTreeWalker walker = new FileTreeWalker(options, maxDepth)) {
2796             FileTreeWalker.Event ev = walker.walk(start);
2797             do {
2798                 FileVisitResult result;
2799                 switch (ev.type()) {
2800                     case ENTRY :
2801                         IOException ioe = ev.ioeException();
2802                         if (ioe == null) {
2803                             assert ev.attributes() != null;
2804                             result = visitor.visitFile(ev.file(), ev.attributes());
2805                         } else {
2806                             result = visitor.visitFileFailed(ev.file(), ioe);
2807                         }
2808                         break;
2809 
2810                     case START_DIRECTORY :
2811                         result = visitor.preVisitDirectory(ev.file(), ev.attributes());
2812 
2813                         // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then
2814                         // there shouldn&#39;t be any more events for the current
2815                         // directory.
2816                         if (result == FileVisitResult.SKIP_SUBTREE ||
2817                             result == FileVisitResult.SKIP_SIBLINGS)
2818                             walker.pop();
2819                         break;
2820 
2821                     case END_DIRECTORY :
2822                         result = visitor.postVisitDirectory(ev.file(), ev.ioeException());
2823 
2824                         // SKIP_SIBLINGS is a no-op for postVisitDirectory
2825                         if (result == FileVisitResult.SKIP_SIBLINGS)
2826                             result = FileVisitResult.CONTINUE;
2827                         break;
2828 
2829                     default :
2830                         throw new AssertionError(&quot;Should not get here&quot;);
2831                 }
2832 
2833                 if (Objects.requireNonNull(result) != FileVisitResult.CONTINUE) {
2834                     if (result == FileVisitResult.TERMINATE) {
2835                         break;
2836                     } else if (result == FileVisitResult.SKIP_SIBLINGS) {
2837                         walker.skipRemainingSiblings();
2838                     }
2839                 }
2840                 ev = walker.next();
2841             } while (ev != null);
2842         }
2843 
2844         return start;
2845     }
2846 
2847     /**
2848      * Walks a file tree.
2849      *
2850      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
2851      * expression:
2852      * &lt;blockquote&gt;&lt;pre&gt;
2853      * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)
2854      * &lt;/pre&gt;&lt;/blockquote&gt;
2855      * In other words, it does not follow symbolic links, and visits all levels
2856      * of the file tree.
2857      *
2858      * @param   start
2859      *          the starting file
2860      * @param   visitor
2861      *          the file visitor to invoke for each file
2862      *
2863      * @return  the starting file
2864      *
2865      * @throws  SecurityException
2866      *          If the security manager denies access to the starting file.
2867      *          In the case of the default provider, the {@link
2868      *          SecurityManager#checkRead(String) checkRead} method is invoked
2869      *          to check read access to the directory.
2870      * @throws  IOException
2871      *          if an I/O error is thrown by a visitor method
2872      */
2873     public static Path walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor)
2874         throws IOException
2875     {
2876         return walkFileTree(start,
2877                             EnumSet.noneOf(FileVisitOption.class),
2878                             Integer.MAX_VALUE,
2879                             visitor);
2880     }
2881 
2882 
2883     // -- Utility methods for simple usages --
2884 
2885 
2886     /**
2887      * Opens a file for reading, returning a {@code BufferedReader} that may be
2888      * used to read text from the file in an efficient manner. Bytes from the
2889      * file are decoded into characters using the specified charset. Reading
2890      * commences at the beginning of the file.
2891      *
2892      * &lt;p&gt; The {@code Reader} methods that read from the file throw {@code
2893      * IOException} if a malformed or unmappable byte sequence is read.
2894      *
2895      * @param   path
2896      *          the path to the file
2897      * @param   cs
2898      *          the charset to use for decoding
2899      *
2900      * @return  a new buffered reader, with default buffer size, to read text
2901      *          from the file
2902      *
2903      * @throws  IOException
2904      *          if an I/O error occurs opening the file
2905      * @throws  SecurityException
2906      *          In the case of the default provider, and a security manager is
2907      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
2908      *          method is invoked to check read access to the file.
2909      *
2910      * @see #readAllLines
2911      */
2912     public static BufferedReader newBufferedReader(Path path, Charset cs)
2913         throws IOException
2914     {
2915         CharsetDecoder decoder = cs.newDecoder();
2916         Reader reader = new InputStreamReader(newInputStream(path), decoder);
2917         return new BufferedReader(reader);
2918     }
2919 
2920     /**
2921      * Opens a file for reading, returning a {@code BufferedReader} to read text
2922      * from the file in an efficient manner. Bytes from the file are decoded into
2923      * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset
2924      * charset}.
2925      *
2926      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
2927      * expression:
2928      * &lt;pre&gt;{@code
2929      * Files.newBufferedReader(path, StandardCharsets.UTF_8)
2930      * }&lt;/pre&gt;
2931      *
2932      * @param   path
2933      *          the path to the file
2934      *
2935      * @return  a new buffered reader, with default buffer size, to read text
2936      *          from the file
2937      *
2938      * @throws  IOException
2939      *          if an I/O error occurs opening the file
2940      * @throws  SecurityException
2941      *          In the case of the default provider, and a security manager is
2942      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
2943      *          method is invoked to check read access to the file.
2944      *
2945      * @since 1.8
2946      */
2947     public static BufferedReader newBufferedReader(Path path) throws IOException {
2948         return newBufferedReader(path, UTF_8.INSTANCE);
2949     }
2950 
2951     /**
2952      * Opens or creates a file for writing, returning a {@code BufferedWriter}
2953      * that may be used to write text to the file in an efficient manner.
2954      * The {@code options} parameter specifies how the file is created or
2955      * opened. If no options are present then this method works as if the {@link
2956      * StandardOpenOption#CREATE CREATE}, {@link
2957      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
2958      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
2959      * opens the file for writing, creating the file if it doesn&#39;t exist, or
2960      * initially truncating an existing {@link #isRegularFile regular-file} to
2961      * a size of {@code 0} if it exists.
2962      *
2963      * &lt;p&gt; The {@code Writer} methods to write text throw {@code IOException}
2964      * if the text cannot be encoded using the specified charset.
2965      *
2966      * @param   path
2967      *          the path to the file
2968      * @param   cs
2969      *          the charset to use for encoding
2970      * @param   options
2971      *          options specifying how the file is opened
2972      *
2973      * @return  a new buffered writer, with default buffer size, to write text
2974      *          to the file
2975      *
2976      * @throws  IllegalArgumentException
2977      *          if {@code options} contains an invalid combination of options
2978      * @throws  IOException
2979      *          if an I/O error occurs opening or creating the file
2980      * @throws  UnsupportedOperationException
2981      *          if an unsupported option is specified
2982      * @throws  SecurityException
2983      *          In the case of the default provider, and a security manager is
2984      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
2985      *          method is invoked to check write access to the file. The {@link
2986      *          SecurityManager#checkDelete(String) checkDelete} method is
2987      *          invoked to check delete access if the file is opened with the
2988      *          {@code DELETE_ON_CLOSE} option.
2989      *
2990      * @see #write(Path,Iterable,Charset,OpenOption[])
2991      */
2992     public static BufferedWriter newBufferedWriter(Path path, Charset cs,
2993                                                    OpenOption... options)
2994         throws IOException
2995     {
2996         CharsetEncoder encoder = cs.newEncoder();
2997         Writer writer = new OutputStreamWriter(newOutputStream(path, options), encoder);
2998         return new BufferedWriter(writer);
2999     }
3000 
3001     /**
3002      * Opens or creates a file for writing, returning a {@code BufferedWriter}
3003      * to write text to the file in an efficient manner. The text is encoded
3004      * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}
3005      * {@link Charset charset}.
3006      *
3007      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
3008      * expression:
3009      * &lt;pre&gt;{@code
3010      * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)
3011      * }&lt;/pre&gt;
3012      *
3013      * @param   path
3014      *          the path to the file
3015      * @param   options
3016      *          options specifying how the file is opened
3017      *
3018      * @return  a new buffered writer, with default buffer size, to write text
3019      *          to the file
3020      *
3021      * @throws  IllegalArgumentException
3022      *          if {@code options} contains an invalid combination of options
3023      * @throws  IOException
3024      *          if an I/O error occurs opening or creating the file
3025      * @throws  UnsupportedOperationException
3026      *          if an unsupported option is specified
3027      * @throws  SecurityException
3028      *          In the case of the default provider, and a security manager is
3029      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3030      *          method is invoked to check write access to the file. The {@link
3031      *          SecurityManager#checkDelete(String) checkDelete} method is
3032      *          invoked to check delete access if the file is opened with the
3033      *          {@code DELETE_ON_CLOSE} option.
3034      *
3035      * @since 1.8
3036      */
3037     public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
3038         throws IOException
3039     {
3040         return newBufferedWriter(path, UTF_8.INSTANCE, options);
3041     }
3042 
3043     /**
3044      * Copies all bytes from an input stream to a file. On return, the input
3045      * stream will be at end of stream.
3046      *
3047      * &lt;p&gt; By default, the copy fails if the target file already exists or is a
3048      * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING
3049      * REPLACE_EXISTING} option is specified, and the target file already exists,
3050      * then it is replaced if it is not a non-empty directory. If the target
3051      * file exists and is a symbolic link, then the symbolic link is replaced.
3052      * In this release, the {@code REPLACE_EXISTING} option is the only option
3053      * required to be supported by this method. Additional options may be
3054      * supported in future releases.
3055      *
3056      * &lt;p&gt;  If an I/O error occurs reading from the input stream or writing to
3057      * the file, then it may do so after the target file has been created and
3058      * after some bytes have been read or written. Consequently the input
3059      * stream may not be at end of stream and may be in an inconsistent state.
3060      * It is strongly recommended that the input stream be promptly closed if an
3061      * I/O error occurs.
3062      *
3063      * &lt;p&gt; This method may block indefinitely reading from the input stream (or
3064      * writing to the file). The behavior for the case that the input stream is
3065      * &lt;i&gt;asynchronously closed&lt;/i&gt; or the thread interrupted during the copy is
3066      * highly input stream and file system provider specific and therefore not
3067      * specified.
3068      *
3069      * &lt;p&gt; &lt;b&gt;Usage example&lt;/b&gt;: Suppose we want to capture a web page and save
3070      * it to a file:
3071      * &lt;pre&gt;
3072      *     Path path = ...
3073      *     URI u = URI.create(&quot;http://www.example.com/&quot;);
3074      *     try (InputStream in = u.toURL().openStream()) {
3075      *         Files.copy(in, path);
3076      *     }
3077      * &lt;/pre&gt;
3078      *
3079      * @param   in
3080      *          the input stream to read from
3081      * @param   target
3082      *          the path to the file
3083      * @param   options
3084      *          options specifying how the copy should be done
3085      *
3086      * @return  the number of bytes read or written
3087      *
3088      * @throws  IOException
3089      *          if an I/O error occurs when reading or writing
3090      * @throws  FileAlreadyExistsException
3091      *          if the target file exists but cannot be replaced because the
3092      *          {@code REPLACE_EXISTING} option is not specified &lt;i&gt;(optional
3093      *          specific exception)&lt;/i&gt;
3094      * @throws  DirectoryNotEmptyException
3095      *          the {@code REPLACE_EXISTING} option is specified but the file
3096      *          cannot be replaced because it is a non-empty directory
3097      *          &lt;i&gt;(optional specific exception)&lt;/i&gt;     *
3098      * @throws  UnsupportedOperationException
3099      *          if {@code options} contains a copy option that is not supported
3100      * @throws  SecurityException
3101      *          In the case of the default provider, and a security manager is
3102      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3103      *          method is invoked to check write access to the file. Where the
3104      *          {@code REPLACE_EXISTING} option is specified, the security
3105      *          manager&#39;s {@link SecurityManager#checkDelete(String) checkDelete}
3106      *          method is invoked to check that an existing file can be deleted.
3107      */
3108     public static long copy(InputStream in, Path target, CopyOption... options)
3109         throws IOException
3110     {
3111         // ensure not null before opening file
3112         Objects.requireNonNull(in);
3113 
3114         // check for REPLACE_EXISTING
3115         boolean replaceExisting = false;
3116         for (CopyOption opt: options) {
3117             if (opt == StandardCopyOption.REPLACE_EXISTING) {
3118                 replaceExisting = true;
3119             } else {
3120                 if (opt == null) {
3121                     throw new NullPointerException(&quot;options contains &#39;null&#39;&quot;);
3122                 }  else {
3123                     throw new UnsupportedOperationException(opt + &quot; not supported&quot;);
3124                 }
3125             }
3126         }
3127 
3128         // attempt to delete an existing file
3129         SecurityException se = null;
3130         if (replaceExisting) {
3131             try {
3132                 deleteIfExists(target);
3133             } catch (SecurityException x) {
3134                 se = x;
3135             }
3136         }
3137 
3138         // attempt to create target file. If it fails with
3139         // FileAlreadyExistsException then it may be because the security
3140         // manager prevented us from deleting the file, in which case we just
3141         // throw the SecurityException.
3142         OutputStream ostream;
3143         try {
3144             ostream = newOutputStream(target, StandardOpenOption.CREATE_NEW,
3145                                               StandardOpenOption.WRITE);
3146         } catch (FileAlreadyExistsException x) {
3147             if (se != null)
3148                 throw se;
3149             // someone else won the race and created the file
3150             throw x;
3151         }
3152 
3153         // do the copy
3154         try (OutputStream out = ostream) {
3155             return in.transferTo(out);
3156         }
3157     }
3158 
3159     /**
3160      * Copies all bytes from a file to an output stream.
3161      *
3162      * &lt;p&gt; If an I/O error occurs reading from the file or writing to the output
3163      * stream, then it may do so after some bytes have been read or written.
3164      * Consequently the output stream may be in an inconsistent state. It is
3165      * strongly recommended that the output stream be promptly closed if an I/O
3166      * error occurs.
3167      *
3168      * &lt;p&gt; This method may block indefinitely writing to the output stream (or
3169      * reading from the file). The behavior for the case that the output stream
3170      * is &lt;i&gt;asynchronously closed&lt;/i&gt; or the thread interrupted during the copy
3171      * is highly output stream and file system provider specific and therefore
3172      * not specified.
3173      *
3174      * &lt;p&gt; Note that if the given output stream is {@link java.io.Flushable}
3175      * then its {@link java.io.Flushable#flush flush} method may need to invoked
3176      * after this method completes so as to flush any buffered output.
3177      *
3178      * @param   source
3179      *          the  path to the file
3180      * @param   out
3181      *          the output stream to write to
3182      *
3183      * @return  the number of bytes read or written
3184      *
3185      * @throws  IOException
3186      *          if an I/O error occurs when reading or writing
3187      * @throws  SecurityException
3188      *          In the case of the default provider, and a security manager is
3189      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3190      *          method is invoked to check read access to the file.
3191      */
3192     public static long copy(Path source, OutputStream out) throws IOException {
3193         // ensure not null before opening file
3194         Objects.requireNonNull(out);
3195 
3196         try (InputStream in = newInputStream(source)) {
3197             return in.transferTo(out);
3198         }
3199     }
3200 
3201     private static final jdk.internal.access.JavaLangAccess JLA =
3202             jdk.internal.access.SharedSecrets.getJavaLangAccess();
3203 
3204     /**
3205      * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
3206      * about how many bytes the stream will have.
3207      *
3208      * @param   source
3209      *          the input stream to read from
3210      * @param   initialSize
3211      *          the initial size of the byte array to allocate
3212      *
3213      * @return  a byte array containing the bytes read from the file
3214      *
3215      * @throws  IOException
3216      *          if an I/O error occurs reading from the stream
3217      * @throws  OutOfMemoryError
3218      *          if an array of the required size cannot be allocated
3219      */
3220     private static byte[] read(InputStream source, int initialSize) throws IOException {
3221         int capacity = initialSize;
3222         byte[] buf = new byte[capacity];
3223         int nread = 0;
3224         int n;
3225         for (;;) {
3226             // read to EOF which may read more or less than initialSize (eg: file
3227             // is truncated while we are reading)
3228             while ((n = source.read(buf, nread, capacity - nread)) &gt; 0)
3229                 nread += n;
3230 
3231             // if last call to source.read() returned -1, we are done
3232             // otherwise, try to read one more byte; if that failed we&#39;re done too
3233             if (n &lt; 0 || (n = source.read()) &lt; 0)
3234                 break;
3235 
3236             // one more byte was read; need to allocate a larger buffer
3237             capacity = Math.max(ArraysSupport.newLength(capacity,
3238                                                         1,       /* minimum growth */
3239                                                         capacity /* preferred growth */),
3240                                 BUFFER_SIZE);
3241             buf = Arrays.copyOf(buf, capacity);
3242             buf[nread++] = (byte)n;
3243         }
3244         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
3245     }
3246 
3247     /**
3248      * Reads all the bytes from a file. The method ensures that the file is
3249      * closed when all bytes have been read or an I/O error, or other runtime
3250      * exception, is thrown.
3251      *
3252      * &lt;p&gt; Note that this method is intended for simple cases where it is
3253      * convenient to read all bytes into a byte array. It is not intended for
3254      * reading in large files.
3255      *
3256      * @param   path
3257      *          the path to the file
3258      *
3259      * @return  a byte array containing the bytes read from the file
3260      *
3261      * @throws  IOException
3262      *          if an I/O error occurs reading from the stream
3263      * @throws  OutOfMemoryError
3264      *          if an array of the required size cannot be allocated, for
3265      *          example the file is larger that {@code 2GB}
3266      * @throws  SecurityException
3267      *          In the case of the default provider, and a security manager is
3268      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3269      *          method is invoked to check read access to the file.
3270      */
3271     public static byte[] readAllBytes(Path path) throws IOException {
3272         try (SeekableByteChannel sbc = Files.newByteChannel(path);
3273              InputStream in = Channels.newInputStream(sbc)) {
3274             if (sbc instanceof FileChannelImpl)
3275                 ((FileChannelImpl) sbc).setUninterruptible();
3276             long size = sbc.size();
3277             if (size &gt; (long) Integer.MAX_VALUE)
3278                 throw new OutOfMemoryError(&quot;Required array size too large&quot;);
3279             return read(in, (int)size);
3280         }
3281     }
3282 
3283     /**
3284      * Reads all content from a file into a string, decoding from bytes to characters
3285      * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3286      * The method ensures that the file is closed when all content have been read
3287      * or an I/O error, or other runtime exception, is thrown.
3288      *
3289      * &lt;p&gt; This method is equivalent to:
3290      * {@code readString(path, StandardCharsets.UTF_8) }
3291      *
3292      * @param   path the path to the file
3293      *
3294      * @return  a String containing the content read from the file
3295      *
3296      * @throws  IOException
3297      *          if an I/O error occurs reading from the file or a malformed or
3298      *          unmappable byte sequence is read
3299      * @throws  OutOfMemoryError
3300      *          if the file is extremely large, for example larger than {@code 2GB}
3301      * @throws  SecurityException
3302      *          In the case of the default provider, and a security manager is
3303      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3304      *          method is invoked to check read access to the file.
3305      *
3306      * @since 11
3307      */
3308     public static String readString(Path path) throws IOException {
3309         return readString(path, UTF_8.INSTANCE);
3310     }
3311 
3312     /**
3313      * Reads all characters from a file into a string, decoding from bytes to characters
3314      * using the specified {@linkplain Charset charset}.
3315      * The method ensures that the file is closed when all content have been read
3316      * or an I/O error, or other runtime exception, is thrown.
3317      *
3318      * &lt;p&gt; This method reads all content including the line separators in the middle
3319      * and/or at the end. The resulting string will contain line separators as they
3320      * appear in the file.
3321      *
3322      * @apiNote
3323      * This method is intended for simple cases where it is appropriate and convenient
3324      * to read the content of a file into a String. It is not intended for reading
3325      * very large files.
3326      *
3327      *
3328      *
3329      * @param   path the path to the file
3330      * @param   cs the charset to use for decoding
3331      *
3332      * @return  a String containing the content read from the file
3333      *
3334      * @throws  IOException
3335      *          if an I/O error occurs reading from the file or a malformed or
3336      *          unmappable byte sequence is read
3337      * @throws  OutOfMemoryError
3338      *          if the file is extremely large, for example larger than {@code 2GB}
3339      * @throws  SecurityException
3340      *          In the case of the default provider, and a security manager is
3341      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3342      *          method is invoked to check read access to the file.
3343      *
3344      * @since 11
3345      */
3346     public static String readString(Path path, Charset cs) throws IOException {
3347         Objects.requireNonNull(path);
3348         Objects.requireNonNull(cs);
3349 
3350         byte[] ba = readAllBytes(path);
3351         if (path.getClass().getModule() != Object.class.getModule())
3352             ba = ba.clone();
3353         return JLA.newStringNoRepl(ba, cs);
3354     }
3355 
3356     /**
3357      * Read all lines from a file. This method ensures that the file is
3358      * closed when all bytes have been read or an I/O error, or other runtime
3359      * exception, is thrown. Bytes from the file are decoded into characters
3360      * using the specified charset.
3361      *
3362      * &lt;p&gt; This method recognizes the following as line terminators:
3363      * &lt;ul&gt;
3364      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt; followed by &lt;code&gt;&amp;#92;u000A&lt;/code&gt;,
3365      *     CARRIAGE RETURN followed by LINE FEED &lt;/li&gt;
3366      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000A&lt;/code&gt;, LINE FEED &lt;/li&gt;
3367      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt;, CARRIAGE RETURN &lt;/li&gt;
3368      * &lt;/ul&gt;
3369      * &lt;p&gt; Additional Unicode line terminators may be recognized in future
3370      * releases.
3371      *
3372      * &lt;p&gt; Note that this method is intended for simple cases where it is
3373      * convenient to read all lines in a single operation. It is not intended
3374      * for reading in large files.
3375      *
3376      * @param   path
3377      *          the path to the file
3378      * @param   cs
3379      *          the charset to use for decoding
3380      *
3381      * @return  the lines from the file as a {@code List}; whether the {@code
3382      *          List} is modifiable or not is implementation dependent and
3383      *          therefore not specified
3384      *
3385      * @throws  IOException
3386      *          if an I/O error occurs reading from the file or a malformed or
3387      *          unmappable byte sequence is read
3388      * @throws  SecurityException
3389      *          In the case of the default provider, and a security manager is
3390      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3391      *          method is invoked to check read access to the file.
3392      *
3393      * @see #newBufferedReader
3394      */
3395     public static List&lt;String&gt; readAllLines(Path path, Charset cs) throws IOException {
3396         try (BufferedReader reader = newBufferedReader(path, cs)) {
3397             List&lt;String&gt; result = new ArrayList&lt;&gt;();
3398             for (;;) {
3399                 String line = reader.readLine();
3400                 if (line == null)
3401                     break;
3402                 result.add(line);
3403             }
3404             return result;
3405         }
3406     }
3407 
3408     /**
3409      * Read all lines from a file. Bytes from the file are decoded into characters
3410      * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3411      *
3412      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
3413      * expression:
3414      * &lt;pre&gt;{@code
3415      * Files.readAllLines(path, StandardCharsets.UTF_8)
3416      * }&lt;/pre&gt;
3417      *
3418      * @param   path
3419      *          the path to the file
3420      *
3421      * @return  the lines from the file as a {@code List}; whether the {@code
3422      *          List} is modifiable or not is implementation dependent and
3423      *          therefore not specified
3424      *
3425      * @throws  IOException
3426      *          if an I/O error occurs reading from the file or a malformed or
3427      *          unmappable byte sequence is read
3428      * @throws  SecurityException
3429      *          In the case of the default provider, and a security manager is
3430      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3431      *          method is invoked to check read access to the file.
3432      *
3433      * @since 1.8
3434      */
3435     public static List&lt;String&gt; readAllLines(Path path) throws IOException {
3436         return readAllLines(path, UTF_8.INSTANCE);
3437     }
3438 
3439     /**
3440      * Writes bytes to a file. The {@code options} parameter specifies how
3441      * the file is created or opened. If no options are present then this method
3442      * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link
3443      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3444      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3445      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3446      * initially truncating an existing {@link #isRegularFile regular-file} to
3447      * a size of {@code 0}. All bytes in the byte array are written to the file.
3448      * The method ensures that the file is closed when all bytes have been
3449      * written (or an I/O error or other runtime exception is thrown). If an I/O
3450      * error occurs then it may do so after the file has been created or
3451      * truncated, or after some bytes have been written to the file.
3452      *
3453      * &lt;p&gt; &lt;b&gt;Usage example&lt;/b&gt;: By default the method creates a new file or
3454      * overwrites an existing file. Suppose you instead want to append bytes
3455      * to an existing file:
3456      * &lt;pre&gt;
3457      *     Path path = ...
3458      *     byte[] bytes = ...
3459      *     Files.write(path, bytes, StandardOpenOption.APPEND);
3460      * &lt;/pre&gt;
3461      *
3462      * @param   path
3463      *          the path to the file
3464      * @param   bytes
3465      *          the byte array with the bytes to write
3466      * @param   options
3467      *          options specifying how the file is opened
3468      *
3469      * @return  the path
3470      *
3471      * @throws  IllegalArgumentException
3472      *          if {@code options} contains an invalid combination of options
3473      * @throws  IOException
3474      *          if an I/O error occurs writing to or creating the file
3475      * @throws  UnsupportedOperationException
3476      *          if an unsupported option is specified
3477      * @throws  SecurityException
3478      *          In the case of the default provider, and a security manager is
3479      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3480      *          method is invoked to check write access to the file. The {@link
3481      *          SecurityManager#checkDelete(String) checkDelete} method is
3482      *          invoked to check delete access if the file is opened with the
3483      *          {@code DELETE_ON_CLOSE} option.
3484      */
3485     public static Path write(Path path, byte[] bytes, OpenOption... options)
3486         throws IOException
3487     {
3488         // ensure bytes is not null before opening file
3489         Objects.requireNonNull(bytes);
3490 
3491         try (OutputStream out = Files.newOutputStream(path, options)) {
3492             int len = bytes.length;
3493             int rem = len;
3494             while (rem &gt; 0) {
3495                 int n = Math.min(rem, BUFFER_SIZE);
3496                 out.write(bytes, (len-rem), n);
3497                 rem -= n;
3498             }
3499         }
3500         return path;
3501     }
3502 
3503     /**
3504      * Write lines of text to a file. Each line is a char sequence and is
3505      * written to the file in sequence with each line terminated by the
3506      * platform&#39;s line separator, as defined by the system property {@code
3507      * line.separator}. Characters are encoded into bytes using the specified
3508      * charset.
3509      *
3510      * &lt;p&gt; The {@code options} parameter specifies how the file is created
3511      * or opened. If no options are present then this method works as if the
3512      * {@link StandardOpenOption#CREATE CREATE}, {@link
3513      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3514      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3515      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3516      * initially truncating an existing {@link #isRegularFile regular-file} to
3517      * a size of {@code 0}. The method ensures that the file is closed when all
3518      * lines have been written (or an I/O error or other runtime exception is
3519      * thrown). If an I/O error occurs then it may do so after the file has
3520      * been created or truncated, or after some bytes have been written to the
3521      * file.
3522      *
3523      * @param   path
3524      *          the path to the file
3525      * @param   lines
3526      *          an object to iterate over the char sequences
3527      * @param   cs
3528      *          the charset to use for encoding
3529      * @param   options
3530      *          options specifying how the file is opened
3531      *
3532      * @return  the path
3533      *
3534      * @throws  IllegalArgumentException
3535      *          if {@code options} contains an invalid combination of options
3536      * @throws  IOException
3537      *          if an I/O error occurs writing to or creating the file, or the
3538      *          text cannot be encoded using the specified charset
3539      * @throws  UnsupportedOperationException
3540      *          if an unsupported option is specified
3541      * @throws  SecurityException
3542      *          In the case of the default provider, and a security manager is
3543      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3544      *          method is invoked to check write access to the file. The {@link
3545      *          SecurityManager#checkDelete(String) checkDelete} method is
3546      *          invoked to check delete access if the file is opened with the
3547      *          {@code DELETE_ON_CLOSE} option.
3548      */
3549     public static Path write(Path path, Iterable&lt;? extends CharSequence&gt; lines,
3550                              Charset cs, OpenOption... options)
3551         throws IOException
3552     {
3553         // ensure lines is not null before opening file
3554         Objects.requireNonNull(lines);
3555         CharsetEncoder encoder = cs.newEncoder();
3556         try (OutputStream out = newOutputStream(path, options);
3557              BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {
3558             for (CharSequence line: lines) {
3559                 writer.append(line);
3560                 writer.newLine();
3561             }
3562         }
3563         return path;
3564     }
3565 
3566     /**
3567      * Write lines of text to a file. Characters are encoded into bytes using
3568      * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3569      *
3570      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
3571      * expression:
3572      * &lt;pre&gt;{@code
3573      * Files.write(path, lines, StandardCharsets.UTF_8, options);
3574      * }&lt;/pre&gt;
3575      *
3576      * @param   path
3577      *          the path to the file
3578      * @param   lines
3579      *          an object to iterate over the char sequences
3580      * @param   options
3581      *          options specifying how the file is opened
3582      *
3583      * @return  the path
3584      *
3585      * @throws  IllegalArgumentException
3586      *          if {@code options} contains an invalid combination of options
3587      * @throws  IOException
3588      *          if an I/O error occurs writing to or creating the file, or the
3589      *          text cannot be encoded as {@code UTF-8}
3590      * @throws  UnsupportedOperationException
3591      *          if an unsupported option is specified
3592      * @throws  SecurityException
3593      *          In the case of the default provider, and a security manager is
3594      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3595      *          method is invoked to check write access to the file. The {@link
3596      *          SecurityManager#checkDelete(String) checkDelete} method is
3597      *          invoked to check delete access if the file is opened with the
3598      *          {@code DELETE_ON_CLOSE} option.
3599      *
3600      * @since 1.8
3601      */
3602     public static Path write(Path path,
3603                              Iterable&lt;? extends CharSequence&gt; lines,
3604                              OpenOption... options)
3605         throws IOException
3606     {
3607         return write(path, lines, UTF_8.INSTANCE, options);
3608     }
3609 
3610     /**
3611      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
3612      * Characters are encoded into bytes using the
3613      * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3614      *
3615      * &lt;p&gt; This method is equivalent to:
3616      * {@code writeString(path, test, StandardCharsets.UTF_8, options) }
3617      *
3618      * @param   path
3619      *          the path to the file
3620      * @param   csq
3621      *          the CharSequence to be written
3622      * @param   options
3623      *          options specifying how the file is opened
3624      *
3625      * @return  the path
3626      *
3627      * @throws  IllegalArgumentException
3628      *          if {@code options} contains an invalid combination of options
3629      * @throws  IOException
3630      *          if an I/O error occurs writing to or creating the file, or the
3631      *          text cannot be encoded using the specified charset
3632      * @throws  UnsupportedOperationException
3633      *          if an unsupported option is specified
3634      * @throws  SecurityException
3635      *          In the case of the default provider, and a security manager is
3636      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3637      *          method is invoked to check write access to the file. The {@link
3638      *          SecurityManager#checkDelete(String) checkDelete} method is
3639      *          invoked to check delete access if the file is opened with the
3640      *          {@code DELETE_ON_CLOSE} option.
3641      *
3642      * @since 11
3643      */
3644     public static Path writeString(Path path, CharSequence csq, OpenOption... options)
3645             throws IOException
3646     {
3647         return writeString(path, csq, UTF_8.INSTANCE, options);
3648     }
3649 
3650     /**
3651      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
3652      * Characters are encoded into bytes using the specified
3653      * {@linkplain java.nio.charset.Charset charset}.
3654      *
3655      * &lt;p&gt; All characters are written as they are, including the line separators in
3656      * the char sequence. No extra characters are added.
3657      *
3658      * &lt;p&gt; The {@code options} parameter specifies how the file is created
3659      * or opened. If no options are present then this method works as if the
3660      * {@link StandardOpenOption#CREATE CREATE}, {@link
3661      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3662      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3663      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3664      * initially truncating an existing {@link #isRegularFile regular-file} to
3665      * a size of {@code 0}.
3666      *
3667      *
3668      * @param   path
3669      *          the path to the file
3670      * @param   csq
3671      *          the CharSequence to be written
3672      * @param   cs
3673      *          the charset to use for encoding
3674      * @param   options
3675      *          options specifying how the file is opened
3676      *
3677      * @return  the path
3678      *
3679      * @throws  IllegalArgumentException
3680      *          if {@code options} contains an invalid combination of options
3681      * @throws  IOException
3682      *          if an I/O error occurs writing to or creating the file, or the
3683      *          text cannot be encoded using the specified charset
3684      * @throws  UnsupportedOperationException
3685      *          if an unsupported option is specified
3686      * @throws  SecurityException
3687      *          In the case of the default provider, and a security manager is
3688      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3689      *          method is invoked to check write access to the file. The {@link
3690      *          SecurityManager#checkDelete(String) checkDelete} method is
3691      *          invoked to check delete access if the file is opened with the
3692      *          {@code DELETE_ON_CLOSE} option.
3693      *
3694      * @since 11
3695      */
3696     public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)
3697             throws IOException
3698     {
3699         // ensure the text is not null before opening file
3700         Objects.requireNonNull(path);
3701         Objects.requireNonNull(csq);
3702         Objects.requireNonNull(cs);
3703 
3704         byte[] bytes = JLA.getBytesNoRepl(String.valueOf(csq), cs);
3705         write(path, bytes, options);
3706 
3707         return path;
3708     }
3709 
3710     // -- Stream APIs --
3711 
3712     /**
3713      * Return a lazily populated {@code Stream}, the elements of
3714      * which are the entries in the directory.  The listing is not recursive.
3715      *
3716      * &lt;p&gt; The elements of the stream are {@link Path} objects that are
3717      * obtained as if by {@link Path#resolve(Path) resolving} the name of the
3718      * directory entry against {@code dir}. Some file systems maintain special
3719      * links to the directory itself and the directory&#39;s parent directory.
3720      * Entries representing these links are not included.
3721      *
3722      * &lt;p&gt; The stream is &lt;i&gt;weakly consistent&lt;/i&gt;. It is thread safe but does
3723      * not freeze the directory while iterating, so it may (or may not)
3724      * reflect updates to the directory that occur after returning from this
3725      * method.
3726      *
3727      * &lt;p&gt; The returned stream contains a reference to an open directory.
3728      * The directory is closed by closing the stream.
3729      *
3730      * &lt;p&gt; Operating on a closed stream behaves as if the end of stream
3731      * has been reached. Due to read-ahead, one or more elements may be
3732      * returned after the stream has been closed.
3733      *
3734      * &lt;p&gt; If an {@link IOException} is thrown when accessing the directory
3735      * after this method has returned, it is wrapped in an {@link
3736      * UncheckedIOException} which will be thrown from the method that caused
3737      * the access to take place.
3738      *
3739      * @apiNote
3740      * This method must be used within a try-with-resources statement or similar
3741      * control structure to ensure that the stream&#39;s open directory is closed
3742      * promptly after the stream&#39;s operations have completed.
3743      *
3744      * @param   dir  The path to the directory
3745      *
3746      * @return  The {@code Stream} describing the content of the
3747      *          directory
3748      *
3749      * @throws  NotDirectoryException
3750      *          if the file could not otherwise be opened because it is not
3751      *          a directory &lt;i&gt;(optional specific exception)&lt;/i&gt;
3752      * @throws  IOException
3753      *          if an I/O error occurs when opening the directory
3754      * @throws  SecurityException
3755      *          In the case of the default provider, and a security manager is
3756      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3757      *          method is invoked to check read access to the directory.
3758      *
3759      * @see     #newDirectoryStream(Path)
3760      * @since   1.8
3761      */
3762     public static Stream&lt;Path&gt; list(Path dir) throws IOException {
3763         DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(dir);
3764         try {
3765             final Iterator&lt;Path&gt; delegate = ds.iterator();
3766 
3767             // Re-wrap DirectoryIteratorException to UncheckedIOException
3768             Iterator&lt;Path&gt; iterator = new Iterator&lt;&gt;() {
3769                 @Override
3770                 public boolean hasNext() {
3771                     try {
3772                         return delegate.hasNext();
3773                     } catch (DirectoryIteratorException e) {
3774                         throw new UncheckedIOException(e.getCause());
3775                     }
3776                 }
3777                 @Override
3778                 public Path next() {
3779                     try {
3780                         return delegate.next();
3781                     } catch (DirectoryIteratorException e) {
3782                         throw new UncheckedIOException(e.getCause());
3783                     }
3784                 }
3785             };
3786 
3787             Spliterator&lt;Path&gt; spliterator =
3788                 Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
3789             return StreamSupport.stream(spliterator, false)
3790                                 .onClose(asUncheckedRunnable(ds));
3791         } catch (Error|RuntimeException e) {
3792             try {
3793                 ds.close();
3794             } catch (IOException ex) {
3795                 try {
3796                     e.addSuppressed(ex);
3797                 } catch (Throwable ignore) {}
3798             }
3799             throw e;
3800         }
3801     }
3802 
3803     /**
3804      * Return a {@code Stream} that is lazily populated with {@code
3805      * Path} by walking the file tree rooted at a given starting file.  The
3806      * file tree is traversed &lt;em&gt;depth-first&lt;/em&gt;, the elements in the stream
3807      * are {@link Path} objects that are obtained as if by {@link
3808      * Path#resolve(Path) resolving} the relative path against {@code start}.
3809      *
3810      * &lt;p&gt; The {@code stream} walks the file tree as elements are consumed.
3811      * The {@code Stream} returned is guaranteed to have at least one
3812      * element, the starting file itself. For each file visited, the stream
3813      * attempts to read its {@link BasicFileAttributes}. If the file is a
3814      * directory and can be opened successfully, entries in the directory, and
3815      * their &lt;em&gt;descendants&lt;/em&gt; will follow the directory in the stream as
3816      * they are encountered. When all entries have been visited, then the
3817      * directory is closed. The file tree walk then continues at the next
3818      * &lt;em&gt;sibling&lt;/em&gt; of the directory.
3819      *
3820      * &lt;p&gt; The stream is &lt;i&gt;weakly consistent&lt;/i&gt;. It does not freeze the
3821      * file tree while iterating, so it may (or may not) reflect updates to
3822      * the file tree that occur after returned from this method.
3823      *
3824      * &lt;p&gt; By default, symbolic links are not automatically followed by this
3825      * method. If the {@code options} parameter contains the {@link
3826      * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are
3827      * followed. When following links, and the attributes of the target cannot
3828      * be read, then this method attempts to get the {@code BasicFileAttributes}
3829      * of the link.
3830      *
3831      * &lt;p&gt; If the {@code options} parameter contains the {@link
3832      * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps
3833      * track of directories visited so that cycles can be detected. A cycle
3834      * arises when there is an entry in a directory that is an ancestor of the
3835      * directory. Cycle detection is done by recording the {@link
3836      * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,
3837      * or if file keys are not available, by invoking the {@link #isSameFile
3838      * isSameFile} method to test if a directory is the same file as an
3839      * ancestor. When a cycle is detected it is treated as an I/O error with
3840      * an instance of {@link FileSystemLoopException}.
3841      *
3842      * &lt;p&gt; The {@code maxDepth} parameter is the maximum number of levels of
3843      * directories to visit. A value of {@code 0} means that only the starting
3844      * file is visited, unless denied by the security manager. A value of
3845      * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all
3846      * levels should be visited.
3847      *
3848      * &lt;p&gt; When a security manager is installed and it denies access to a file
3849      * (or directory), then it is ignored and not included in the stream.
3850      *
3851      * &lt;p&gt; The returned stream contains references to one or more open directories.
3852      * The directories are closed by closing the stream.
3853      *
3854      * &lt;p&gt; If an {@link IOException} is thrown when accessing the directory
3855      * after this method has returned, it is wrapped in an {@link
3856      * UncheckedIOException} which will be thrown from the method that caused
3857      * the access to take place.
3858      *
3859      * @apiNote
3860      * This method must be used within a try-with-resources statement or similar
3861      * control structure to ensure that the stream&#39;s open directories are closed
3862      * promptly after the stream&#39;s operations have completed.
3863      *
3864      * @param   start
3865      *          the starting file
3866      * @param   maxDepth
3867      *          the maximum number of directory levels to visit
3868      * @param   options
3869      *          options to configure the traversal
3870      *
3871      * @return  the {@link Stream} of {@link Path}
3872      *
3873      * @throws  IllegalArgumentException
3874      *          if the {@code maxDepth} parameter is negative
3875      * @throws  SecurityException
3876      *          If the security manager denies access to the starting file.
3877      *          In the case of the default provider, the {@link
3878      *          SecurityManager#checkRead(String) checkRead} method is invoked
3879      *          to check read access to the directory.
3880      * @throws  IOException
3881      *          if an I/O error is thrown when accessing the starting file.
3882      * @since   1.8
3883      */
3884     public static Stream&lt;Path&gt; walk(Path start,
3885                                     int maxDepth,
3886                                     FileVisitOption... options)
3887         throws IOException
3888     {
3889         FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
3890         try {
3891             Spliterator&lt;FileTreeWalker.Event&gt; spliterator =
3892                 Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
3893             return StreamSupport.stream(spliterator, false)
3894                                 .onClose(iterator::close)
3895                                 .map(entry -&gt; entry.file());
3896         } catch (Error|RuntimeException e) {
3897             iterator.close();
3898             throw e;
3899         }
3900     }
3901 
3902     /**
3903      * Return a {@code Stream} that is lazily populated with {@code
3904      * Path} by walking the file tree rooted at a given starting file.  The
3905      * file tree is traversed &lt;em&gt;depth-first&lt;/em&gt;, the elements in the stream
3906      * are {@link Path} objects that are obtained as if by {@link
3907      * Path#resolve(Path) resolving} the relative path against {@code start}.
3908      *
3909      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
3910      * expression:
3911      * &lt;blockquote&gt;&lt;pre&gt;
3912      * walk(start, Integer.MAX_VALUE, options)
3913      * &lt;/pre&gt;&lt;/blockquote&gt;
3914      * In other words, it visits all levels of the file tree.
3915      *
3916      * &lt;p&gt; The returned stream contains references to one or more open directories.
3917      * The directories are closed by closing the stream.
3918      *
3919      * @apiNote
3920      * This method must be used within a try-with-resources statement or similar
3921      * control structure to ensure that the stream&#39;s open directories are closed
3922      * promptly after the stream&#39;s operations have completed.
3923      *
3924      * @param   start
3925      *          the starting file
3926      * @param   options
3927      *          options to configure the traversal
3928      *
3929      * @return  the {@link Stream} of {@link Path}
3930      *
3931      * @throws  SecurityException
3932      *          If the security manager denies access to the starting file.
3933      *          In the case of the default provider, the {@link
3934      *          SecurityManager#checkRead(String) checkRead} method is invoked
3935      *          to check read access to the directory.
3936      * @throws  IOException
3937      *          if an I/O error is thrown when accessing the starting file.
3938      *
3939      * @see     #walk(Path, int, FileVisitOption...)
3940      * @since   1.8
3941      */
3942     public static Stream&lt;Path&gt; walk(Path start, FileVisitOption... options) throws IOException {
3943         return walk(start, Integer.MAX_VALUE, options);
3944     }
3945 
3946     /**
3947      * Return a {@code Stream} that is lazily populated with {@code
3948      * Path} by searching for files in a file tree rooted at a given starting
3949      * file.
3950      *
3951      * &lt;p&gt; This method walks the file tree in exactly the manner specified by
3952      * the {@link #walk walk} method. For each file encountered, the given
3953      * {@link BiPredicate} is invoked with its {@link Path} and {@link
3954      * BasicFileAttributes}. The {@code Path} object is obtained as if by
3955      * {@link Path#resolve(Path) resolving} the relative path against {@code
3956      * start} and is only included in the returned {@link Stream} if
3957      * the {@code BiPredicate} returns true. Compare to calling {@link
3958      * java.util.stream.Stream#filter filter} on the {@code Stream}
3959      * returned by {@code walk} method, this method may be more efficient by
3960      * avoiding redundant retrieval of the {@code BasicFileAttributes}.
3961      *
3962      * &lt;p&gt; The returned stream contains references to one or more open directories.
3963      * The directories are closed by closing the stream.
3964      *
3965      * &lt;p&gt; If an {@link IOException} is thrown when accessing the directory
3966      * after returned from this method, it is wrapped in an {@link
3967      * UncheckedIOException} which will be thrown from the method that caused
3968      * the access to take place.
3969      *
3970      * @apiNote
3971      * This method must be used within a try-with-resources statement or similar
3972      * control structure to ensure that the stream&#39;s open directories are closed
3973      * promptly after the stream&#39;s operations have completed.
3974      *
3975      * @param   start
3976      *          the starting file
3977      * @param   maxDepth
3978      *          the maximum number of directory levels to search
3979      * @param   matcher
3980      *          the function used to decide whether a file should be included
3981      *          in the returned stream
3982      * @param   options
3983      *          options to configure the traversal
3984      *
3985      * @return  the {@link Stream} of {@link Path}
3986      *
3987      * @throws  IllegalArgumentException
3988      *          if the {@code maxDepth} parameter is negative
3989      * @throws  SecurityException
3990      *          If the security manager denies access to the starting file.
3991      *          In the case of the default provider, the {@link
3992      *          SecurityManager#checkRead(String) checkRead} method is invoked
3993      *          to check read access to the directory.
3994      * @throws  IOException
3995      *          if an I/O error is thrown when accessing the starting file.
3996      *
3997      * @see     #walk(Path, int, FileVisitOption...)
3998      * @since   1.8
3999      */
4000     public static Stream&lt;Path&gt; find(Path start,
4001                                     int maxDepth,
4002                                     BiPredicate&lt;Path, BasicFileAttributes&gt; matcher,
4003                                     FileVisitOption... options)
4004         throws IOException
4005     {
4006         FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
4007         try {
4008             Spliterator&lt;FileTreeWalker.Event&gt; spliterator =
4009                 Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
4010             return StreamSupport.stream(spliterator, false)
4011                                 .onClose(iterator::close)
4012                                 .filter(entry -&gt; matcher.test(entry.file(), entry.attributes()))
4013                                 .map(entry -&gt; entry.file());
4014         } catch (Error|RuntimeException e) {
4015             iterator.close();
4016             throw e;
4017         }
4018     }
4019 
4020 
4021     /**
4022      * Read all lines from a file as a {@code Stream}. Unlike {@link
4023      * #readAllLines(Path, Charset) readAllLines}, this method does not read
4024      * all lines into a {@code List}, but instead populates lazily as the stream
4025      * is consumed.
4026      *
4027      * &lt;p&gt; Bytes from the file are decoded into characters using the specified
4028      * charset and the same line terminators as specified by {@code
4029      * readAllLines} are supported.
4030      *
4031      * &lt;p&gt; The returned stream contains a reference to an open file. The file
4032      * is closed by closing the stream.
4033      *
4034      * &lt;p&gt; The file contents should not be modified during the execution of the
4035      * terminal stream operation. Otherwise, the result of the terminal stream
4036      * operation is undefined.
4037      *
4038      * &lt;p&gt; After this method returns, then any subsequent I/O exception that
4039      * occurs while reading from the file or when a malformed or unmappable byte
4040      * sequence is read, is wrapped in an {@link UncheckedIOException} that will
4041      * be thrown from the
4042      * {@link java.util.stream.Stream} method that caused the read to take
4043      * place. In case an {@code IOException} is thrown when closing the file,
4044      * it is also wrapped as an {@code UncheckedIOException}.
4045      *
4046      * @apiNote
4047      * This method must be used within a try-with-resources statement or similar
4048      * control structure to ensure that the stream&#39;s open file is closed promptly
4049      * after the stream&#39;s operations have completed.
4050      *
4051      * @implNote
4052      * This implementation supports good parallel stream performance for the
4053      * standard charsets {@link StandardCharsets#UTF_8 UTF-8},
4054      * {@link StandardCharsets#US_ASCII US-ASCII} and
4055      * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such
4056      * &lt;em&gt;line-optimal&lt;/em&gt; charsets have the property that the encoded bytes
4057      * of a line feed (&#39;\n&#39;) or a carriage return (&#39;\r&#39;) are efficiently
4058      * identifiable from other encoded characters when randomly accessing the
4059      * bytes of the file.
4060      *
4061      * &lt;p&gt; For non-&lt;em&gt;line-optimal&lt;/em&gt; charsets the stream source&#39;s
4062      * spliterator has poor splitting properties, similar to that of a
4063      * spliterator associated with an iterator or that associated with a stream
4064      * returned from {@link BufferedReader#lines()}.  Poor splitting properties
4065      * can result in poor parallel stream performance.
4066      *
4067      * &lt;p&gt; For &lt;em&gt;line-optimal&lt;/em&gt; charsets the stream source&#39;s spliterator
4068      * has good splitting properties, assuming the file contains a regular
4069      * sequence of lines.  Good splitting properties can result in good parallel
4070      * stream performance.  The spliterator for a &lt;em&gt;line-optimal&lt;/em&gt; charset
4071      * takes advantage of the charset properties (a line feed or a carriage
4072      * return being efficient identifiable) such that when splitting it can
4073      * approximately divide the number of covered lines in half.
4074      *
4075      * @param   path
4076      *          the path to the file
4077      * @param   cs
4078      *          the charset to use for decoding
4079      *
4080      * @return  the lines from the file as a {@code Stream}
4081      *
4082      * @throws  IOException
4083      *          if an I/O error occurs opening the file
4084      * @throws  SecurityException
4085      *          In the case of the default provider, and a security manager is
4086      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
4087      *          method is invoked to check read access to the file.
4088      *
4089      * @see     #readAllLines(Path, Charset)
4090      * @see     #newBufferedReader(Path, Charset)
4091      * @see     java.io.BufferedReader#lines()
4092      * @since   1.8
4093      */
4094     public static Stream&lt;String&gt; lines(Path path, Charset cs) throws IOException {
4095         // Use the good splitting spliterator if:
4096         // 1) the path is associated with the default file system;
4097         // 2) the character set is supported; and
4098         // 3) the file size is such that all bytes can be indexed by int values
4099         //    (this limitation is imposed by ByteBuffer)
4100         if (path.getFileSystem() == FileSystems.getDefault() &amp;&amp;
4101             FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {
4102             FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);
4103 
4104             Stream&lt;String&gt; fcls = createFileChannelLinesStream(fc, cs);
4105             if (fcls != null) {
4106                 return fcls;
4107             }
4108             fc.close();
4109         }
4110 
4111         return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));
4112     }
4113 
4114     private static Stream&lt;String&gt; createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {
4115         try {
4116             // Obtaining the size from the FileChannel is much faster
4117             // than obtaining using path.toFile().length()
4118             long length = fc.size();
4119             // FileChannel.size() may in certain circumstances return zero
4120             // for a non-zero length file so disallow this case.
4121             if (length &gt; 0 &amp;&amp; length &lt;= Integer.MAX_VALUE) {
4122                 Spliterator&lt;String&gt; s = new FileChannelLinesSpliterator(fc, cs, 0, (int) length);
4123                 return StreamSupport.stream(s, false)
4124                         .onClose(Files.asUncheckedRunnable(fc));
4125             }
4126         } catch (Error|RuntimeException|IOException e) {
4127             try {
4128                 fc.close();
4129             } catch (IOException ex) {
4130                 try {
4131                     e.addSuppressed(ex);
4132                 } catch (Throwable ignore) {
4133                 }
4134             }
4135             throw e;
4136         }
4137         return null;
4138     }
4139 
4140     private static Stream&lt;String&gt; createBufferedReaderLinesStream(BufferedReader br) {
4141         try {
4142             return br.lines().onClose(asUncheckedRunnable(br));
4143         } catch (Error|RuntimeException e) {
4144             try {
4145                 br.close();
4146             } catch (IOException ex) {
4147                 try {
4148                     e.addSuppressed(ex);
4149                 } catch (Throwable ignore) {
4150                 }
4151             }
4152             throw e;
4153         }
4154     }
4155 
4156     /**
4157      * Read all lines from a file as a {@code Stream}. Bytes from the file are
4158      * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}
4159      * {@link Charset charset}.
4160      *
4161      * &lt;p&gt; The returned stream contains a reference to an open file. The file
4162      * is closed by closing the stream.
4163      *
4164      * &lt;p&gt; The file contents should not be modified during the execution of the
4165      * terminal stream operation. Otherwise, the result of the terminal stream
4166      * operation is undefined.
4167      *
4168      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
4169      * expression:
4170      * &lt;pre&gt;{@code
4171      * Files.lines(path, StandardCharsets.UTF_8)
4172      * }&lt;/pre&gt;
4173      *
4174      * @apiNote
4175      * This method must be used within a try-with-resources statement or similar
4176      * control structure to ensure that the stream&#39;s open file is closed promptly
4177      * after the stream&#39;s operations have completed.
4178      *
4179      * @param   path
4180      *          the path to the file
4181      *
4182      * @return  the lines from the file as a {@code Stream}
4183      *
4184      * @throws  IOException
4185      *          if an I/O error occurs opening the file
4186      * @throws  SecurityException
4187      *          In the case of the default provider, and a security manager is
4188      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
4189      *          method is invoked to check read access to the file.
4190      *
4191      * @since 1.8
4192      */
4193     public static Stream&lt;String&gt; lines(Path path) throws IOException {
4194         return lines(path, UTF_8.INSTANCE);
4195     }
4196 }
    </pre>
  </body>
</html>
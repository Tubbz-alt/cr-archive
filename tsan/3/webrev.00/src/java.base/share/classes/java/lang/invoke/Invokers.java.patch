diff a/src/java.base/share/classes/java/lang/invoke/Invokers.java b/src/java.base/share/classes/java/lang/invoke/Invokers.java
--- a/src/java.base/share/classes/java/lang/invoke/Invokers.java
+++ b/src/java.base/share/classes/java/lang/invoke/Invokers.java
@@ -56,29 +56,33 @@
             INV_LIMIT          =  3;
 
     /** Compute and cache information common to all collecting adapters
      *  that implement members of the erasure-family of the given erased type.
      */
-    /*non-public*/ Invokers(MethodType targetType) {
+    /*non-public*/
+    Invokers(MethodType targetType) {
         this.targetType = targetType;
     }
 
-    /*non-public*/ MethodHandle exactInvoker() {
+    /*non-public*/
+    MethodHandle exactInvoker() {
         MethodHandle invoker = cachedInvoker(INV_EXACT);
         if (invoker != null)  return invoker;
         invoker = makeExactOrGeneralInvoker(true);
         return setCachedInvoker(INV_EXACT, invoker);
     }
 
-    /*non-public*/ MethodHandle genericInvoker() {
+    /*non-public*/
+    MethodHandle genericInvoker() {
         MethodHandle invoker = cachedInvoker(INV_GENERIC);
         if (invoker != null)  return invoker;
         invoker = makeExactOrGeneralInvoker(false);
         return setCachedInvoker(INV_GENERIC, invoker);
     }
 
-    /*non-public*/ MethodHandle basicInvoker() {
+    /*non-public*/
+    MethodHandle basicInvoker() {
         MethodHandle invoker = cachedInvoker(INV_BASIC);
         if (invoker != null)  return invoker;
         MethodType basicType = targetType.basicType();
         if (basicType != targetType) {
             // double cache; not used significantly
@@ -92,16 +96,18 @@
             invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_BASIC_INV, invoker);
         }
         return setCachedInvoker(INV_BASIC, invoker);
     }
 
-    /*non-public*/ MethodHandle varHandleMethodInvoker(VarHandle.AccessMode ak) {
+    /*non-public*/
+    MethodHandle varHandleMethodInvoker(VarHandle.AccessMode ak) {
         // TODO cache invoker
         return makeVarHandleMethodInvoker(ak, false);
     }
 
-    /*non-public*/ MethodHandle varHandleMethodExactInvoker(VarHandle.AccessMode ak) {
+    /*non-public*/
+    MethodHandle varHandleMethodExactInvoker(VarHandle.AccessMode ak) {
         // TODO cache invoker
         return makeVarHandleMethodInvoker(ak, true);
     }
 
     private MethodHandle cachedInvoker(int idx) {
@@ -151,11 +157,12 @@
             invoker.form.compileToBytecode();
         }
     }
 
     // This next one is called from LambdaForm.NamedFunction.<init>.
-    /*non-public*/ static MemberName invokeBasicMethod(MethodType basicType) {
+    /*non-public*/
+    static MemberName invokeBasicMethod(MethodType basicType) {
         assert(basicType == basicType.basicType());
         try {
             //Lookup.findVirtual(MethodHandle.class, name, type);
             return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, "invokeBasic", basicType);
         } catch (ReflectiveOperationException ex) {
@@ -188,11 +195,12 @@
      * The invoker target type is the post-spread type {@code (TYPEOF(uarg*), TYPEOF(sarg*))=>RT}.
      * All the {@code sarg}s must have a common type {@code C}.  (If there are none, {@code Object} is assumed.}
      * @param leadingArgCount the number of unchanged (non-spread) arguments
      * @return {@code invoker.invokeExact(mh, uarg*, C[]{sarg*}) := (RT)mh.invoke(uarg*, sarg*)}
      */
-    /*non-public*/ MethodHandle spreadInvoker(int leadingArgCount) {
+    /*non-public*/
+    MethodHandle spreadInvoker(int leadingArgCount) {
         int spreadArgCount = targetType.parameterCount() - leadingArgCount;
         MethodType postSpreadType = targetType;
         Class<?> argArrayType = impliedRestargType(postSpreadType, leadingArgCount);
         if (postSpreadType.parameterSlotCount() <= MethodType.MAX_MH_INVOKER_ARITY) {
             return genericInvoker().asSpreader(argArrayType, spreadArgCount);
@@ -443,13 +451,13 @@
         }
         lform.prepare();
         return lform;
     }
 
-    /*non-public*/ static
     @ForceInline
-    MethodHandle checkVarHandleGenericType(VarHandle handle, VarHandle.AccessDescriptor ad) {
+    /*non-public*/
+    static MethodHandle checkVarHandleGenericType(VarHandle handle, VarHandle.AccessDescriptor ad) {
         // Test for exact match on invoker types
         // TODO match with erased types and add cast of return value to lambda form
         MethodHandle mh = handle.getMethodHandle(ad.mode);
         if (mh.type() == ad.symbolicMethodTypeInvoker) {
             return mh;
@@ -457,43 +465,43 @@
         else {
             return mh.asType(ad.symbolicMethodTypeInvoker);
         }
     }
 
-    /*non-public*/ static
     @ForceInline
-    MethodHandle checkVarHandleExactType(VarHandle handle, VarHandle.AccessDescriptor ad) {
+    /*non-public*/
+    static MethodHandle checkVarHandleExactType(VarHandle handle, VarHandle.AccessDescriptor ad) {
         MethodHandle mh = handle.getMethodHandle(ad.mode);
         MethodType mt = mh.type();
         if (mt != ad.symbolicMethodTypeInvoker) {
             throw newWrongMethodTypeException(mt, ad.symbolicMethodTypeInvoker);
         }
         return mh;
     }
 
-    /*non-public*/ static
-    WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {
+    /*non-public*/
+    static WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {
         // FIXME: merge with JVM logic for throwing WMTE
         return new WrongMethodTypeException("expected "+expected+" but found "+actual);
     }
 
     /** Static definition of MethodHandle.invokeExact checking code. */
-    /*non-public*/ static
     @ForceInline
-    void checkExactType(MethodHandle mh, MethodType expected) {
+    /*non-public*/
+    static void checkExactType(MethodHandle mh, MethodType expected) {
         MethodType actual = mh.type();
         if (actual != expected)
             throw newWrongMethodTypeException(expected, actual);
     }
 
     /** Static definition of MethodHandle.invokeGeneric checking code.
      * Directly returns the type-adjusted MH to invoke, as follows:
      * {@code (R)MH.invoke(a*) => MH.asType(TYPEOF(a*:R)).invokeBasic(a*)}
      */
-    /*non-public*/ static
     @ForceInline
-    MethodHandle checkGenericType(MethodHandle mh,  MethodType expected) {
+    /*non-public*/
+    static MethodHandle checkGenericType(MethodHandle mh,  MethodType expected) {
         return mh.asType(expected);
         /* Maybe add more paths here.  Possible optimizations:
          * for (R)MH.invoke(a*),
          * let MT0 = TYPEOF(a*:R), MT1 = MH.type
          *
@@ -557,28 +565,28 @@
         lform = mtype.form().setCachedLambdaForm(which, lform);
         return lform;
     }
 
     /** Static definition of MethodHandle.invokeGeneric checking code. */
-    /*non-public*/ static
     @ForceInline
-    MethodHandle getCallSiteTarget(CallSite site) {
+    /*non-public*/
+    static MethodHandle getCallSiteTarget(CallSite site) {
         return site.getTarget();
     }
 
-    /*non-public*/ static
     @ForceInline
-    void checkCustomized(MethodHandle mh) {
+    /*non-public*/
+    static void checkCustomized(MethodHandle mh) {
         if (MethodHandleImpl.isCompileConstant(mh)) return;
         if (mh.form.customized == null) {
             maybeCustomize(mh);
         }
     }
 
-    /*non-public*/ static
     @DontInline
-    void maybeCustomize(MethodHandle mh) {
+    /*non-public*/
+    static void maybeCustomize(MethodHandle mh) {
         byte count = mh.customizationCount;
         if (count >= CUSTOMIZE_THRESHOLD) {
             mh.customize();
         } else {
             mh.customizationCount = (byte)(count+1);

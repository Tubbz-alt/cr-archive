<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/PropertyPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Properties.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyResourceBundle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/PropertyPermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 37 import sun.security.util.SecurityConstants;
 38 
 39 /**
 40  * This class is for property permissions.
 41  *
 42  * &lt;P&gt;
 43  * The name is the name of the property (&quot;java.home&quot;,
 44  * &quot;os.name&quot;, etc). The naming
 45  * convention follows the  hierarchical property naming convention.
 46  * Also, an asterisk
 47  * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 48  * signify a wildcard match. For example: &quot;java.*&quot; and &quot;*&quot; signify a wildcard
 49  * match, while &quot;*java&quot; and &quot;a*b&quot; do not.
 50  * &lt;P&gt;
 51  * The actions to be granted are passed to the constructor in a string containing
 52  * a list of one or more comma-separated keywords. The possible keywords are
 53  * &quot;read&quot; and &quot;write&quot;. Their meaning is defined as follows:
 54  *
 55  * &lt;DL&gt;
 56  *    &lt;DT&gt; read
<span class="line-modified"> 57  *    &lt;DD&gt; read permission. Allows &lt;code&gt;System.getProperty&lt;/code&gt; to</span>
 58  *         be called.
 59  *    &lt;DT&gt; write
<span class="line-modified"> 60  *    &lt;DD&gt; write permission. Allows &lt;code&gt;System.setProperty&lt;/code&gt; to</span>
 61  *         be called.
 62  * &lt;/DL&gt;
 63  * &lt;P&gt;
 64  * The actions string is converted to lowercase before processing.
 65  * &lt;P&gt;
 66  * Care should be taken before granting code permission to access
 67  * certain system properties.  For example, granting permission to
 68  * access the &quot;java.home&quot; system property gives potentially malevolent
 69  * code sensitive information about the system environment (the Java
 70  * installation directory).  Also, granting permission to access
 71  * the &quot;user.name&quot; and &quot;user.home&quot; system properties gives potentially
 72  * malevolent code sensitive information about the user environment
 73  * (the user&#39;s account name and home directory).
 74  *
 75  * @see java.security.BasicPermission
 76  * @see java.security.Permission
 77  * @see java.security.Permissions
 78  * @see java.security.PermissionCollection
 79  * @see java.lang.SecurityManager
 80  *
</pre>
<hr />
<pre>
132 
133         if (mask == NONE)
134             throw new IllegalArgumentException(&quot;invalid actions mask&quot;);
135 
136         if (getName() == null)
137             throw new NullPointerException(&quot;name can&#39;t be null&quot;);
138 
139         this.mask = mask;
140     }
141 
142     /**
143      * Creates a new PropertyPermission object with the specified name.
144      * The name is the name of the system property, and
145      * &lt;i&gt;actions&lt;/i&gt; contains a comma-separated list of the
146      * desired actions granted on the property. Possible actions are
147      * &quot;read&quot; and &quot;write&quot;.
148      *
149      * @param name the name of the PropertyPermission.
150      * @param actions the actions string.
151      *
<span class="line-modified">152      * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">153      * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty or if</span>
<span class="line-modified">154      * &lt;code&gt;actions&lt;/code&gt; is invalid.</span>
155      */
156     public PropertyPermission(String name, String actions) {
157         super(name,actions);
158         init(getMask(actions));
159     }
160 
161     /**
162      * Creates a PropertyPermission object with the specified name and
163      * a pre-calculated mask. Avoids the overhead of re-computing the mask.
164      * Called by PropertyPermissionCollection.
165      */
166     PropertyPermission(String name, int mask) {
167         super(name, getActions(mask));
168         this.mask = mask;
169     }
170 
171     /**
172      * Checks if this PropertyPermission object &quot;implies&quot; the specified
173      * permission.
174      * &lt;P&gt;
</pre>
<hr />
<pre>
206      * @return true if obj is a PropertyPermission, and has the same name and
207      * actions as this PropertyPermission object.
208      */
209     @Override
210     public boolean equals(Object obj) {
211         if (obj == this)
212             return true;
213 
214         if (! (obj instanceof PropertyPermission))
215             return false;
216 
217         PropertyPermission that = (PropertyPermission) obj;
218 
219         return (this.mask == that.mask) &amp;&amp;
220             (this.getName().equals(that.getName()));
221     }
222 
223     /**
224      * Returns the hash code value for this object.
225      * The hash code used is the hash code of this permissions name, that is,
<span class="line-modified">226      * &lt;code&gt;getName().hashCode()&lt;/code&gt;, where &lt;code&gt;getName&lt;/code&gt; is</span>
227      * from the Permission superclass.
228      *
229      * @return a hash code value for this object.
230      */
231     @Override
232     public int hashCode() {
233         return this.getName().hashCode();
234     }
235 
236     /**
237      * Converts an actions String to an actions mask.
238      *
239      * @param actions the action string.
240      * @return the actions mask.
241      */
242     private static int getMask(String actions) {
243 
244         int mask = NONE;
245 
246         if (actions == null) {
</pre>
<hr />
<pre>
333      *
334      * @return the canonical string representation of the actions.
335      */
336     static String getActions(int mask) {
337         switch (mask &amp; (READ|WRITE)) {
338             case READ:
339                 return SecurityConstants.PROPERTY_READ_ACTION;
340             case WRITE:
341                 return SecurityConstants.PROPERTY_WRITE_ACTION;
342             case READ|WRITE:
343                 return SecurityConstants.PROPERTY_RW_ACTION;
344             default:
345                 return &quot;&quot;;
346         }
347     }
348 
349     /**
350      * Returns the &quot;canonical string representation&quot; of the actions.
351      * That is, this method always returns present actions in the following order:
352      * read, write. For example, if this PropertyPermission object
<span class="line-modified">353      * allows both write and read actions, a call to &lt;code&gt;getActions&lt;/code&gt;</span>
354      * will return the string &quot;read,write&quot;.
355      *
356      * @return the canonical string representation of the actions.
357      */
358     @Override
359     public String getActions() {
360         if (actions == null)
361             actions = getActions(this.mask);
362 
363         return actions;
364     }
365 
366     /**
367      * Return the current action mask.
368      * Used by the PropertyPermissionCollection
369      *
370      * @return the actions mask.
371      */
372     int getMask() {
373         return mask;
374     }
375 
376     /**
377      * Returns a new PermissionCollection object for storing
378      * PropertyPermission objects.
379      *
380      * @return a new PermissionCollection object suitable for storing
381      * PropertyPermissions.
382      */
383     @Override
384     public PermissionCollection newPermissionCollection() {
385         return new PropertyPermissionCollection();
386     }
387 
<span class="line-modified">388 </span>
389     private static final long serialVersionUID = 885438825399942851L;
390 
391     /**
392      * WriteObject is called to save the state of the PropertyPermission
393      * to a stream. The actions are serialized, and the superclass
394      * takes care of the name.
395      */

396     private synchronized void writeObject(java.io.ObjectOutputStream s)
397         throws IOException
398     {
399         // Write out the actions. The superclass takes care of the name
400         // call getActions to make sure actions field is initialized
401         if (actions == null)
402             getActions();
403         s.defaultWriteObject();
404     }
405 
406     /**
407      * readObject is called to restore the state of the PropertyPermission from
408      * a stream.
409      */

410     private synchronized void readObject(java.io.ObjectInputStream s)
411          throws IOException, ClassNotFoundException
412     {
413         // Read in the action, then initialize the rest
414         s.defaultReadObject();
415         init(getMask(actions));
416     }
417 }
418 
419 /**
420  * A PropertyPermissionCollection stores a set of PropertyPermission
421  * permissions.
422  *
423  * @see java.security.Permission
424  * @see java.security.Permissions
425  * @see java.security.PermissionCollection
426  *
427  *
428  * @author Roland Schemers
429  *
</pre>
<hr />
<pre>
444      *
445      * @see #serialPersistentFields
446      */
447     // No sync access; OK for this to be stale.
448     private boolean all_allowed;
449 
450     /**
451      * Create an empty PropertyPermissionCollection object.
452      */
453     public PropertyPermissionCollection() {
454         perms = new ConcurrentHashMap&lt;&gt;(32);     // Capacity for default policy
455         all_allowed = false;
456     }
457 
458     /**
459      * Adds a permission to the PropertyPermissions. The key for the hash is
460      * the name.
461      *
462      * @param permission the Permission object to add.
463      *
<span class="line-modified">464      * @exception IllegalArgumentException - if the permission is not a</span>
465      *                                       PropertyPermission
466      *
<span class="line-modified">467      * @exception SecurityException - if this PropertyPermissionCollection</span>
468      *                                object has been marked readonly
469      */
470     @Override
471     public void add(Permission permission) {
472         if (! (permission instanceof PropertyPermission))
473             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
474                                                permission);
475         if (isReadOnly())
476             throw new SecurityException(
477                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
478 
479         PropertyPermission pp = (PropertyPermission) permission;
480         String propName = pp.getName();
481 
482         // Add permission to map if it is absent, or replace with new
483         // permission if applicable. NOTE: cannot use lambda for
484         // remappingFunction parameter until JDK-8076596 is fixed.
485         perms.merge(propName, pp,
486             new java.util.function.BiFunction&lt;&gt;() {
487                 @Override
</pre>
<hr />
<pre>
579         // at the top (all_allowed), so we just return false
580         return false;
581     }
582 
583     /**
584      * Returns an enumeration of all the PropertyPermission objects in the
585      * container.
586      *
587      * @return an enumeration of all the PropertyPermission objects.
588      */
589     @Override
590     @SuppressWarnings(&quot;unchecked&quot;)
591     public Enumeration&lt;Permission&gt; elements() {
592         /**
593          * Casting to rawtype since Enumeration&lt;PropertyPermission&gt;
594          * cannot be directly cast to Enumeration&lt;Permission&gt;
595          */
596         return (Enumeration)perms.elements();
597     }
598 

599     private static final long serialVersionUID = 7015263904581634791L;
600 
601     // Need to maintain serialization interoperability with earlier releases,
602     // which had the serializable field:
603     //
604     // Table of permissions.
605     //
606     // @serial
607     //
608     // private Hashtable permissions;
609     /**
610      * @serialField permissions java.util.Hashtable
611      *     A table of the PropertyPermissions.
612      * @serialField all_allowed boolean
613      *     boolean saying if &quot;*&quot; is in the collection.
614      */
615     private static final ObjectStreamField[] serialPersistentFields = {
616         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
617         new ObjectStreamField(&quot;all_allowed&quot;, Boolean.TYPE),
618     };
619 
620     /**
621      * @serialData Default fields.
622      */
623     /*
624      * Writes the contents of the perms field out as a Hashtable for
625      * serialization compatibility with earlier releases. all_allowed
626      * unchanged.
627      */

628     private void writeObject(ObjectOutputStream out) throws IOException {
629         // Don&#39;t call out.defaultWriteObject()
630 
631         // Copy perms into a Hashtable
632         Hashtable&lt;String, Permission&gt; permissions =
633             new Hashtable&lt;&gt;(perms.size()*2);
634         permissions.putAll(perms);
635 
636         // Write out serializable fields
637         ObjectOutputStream.PutField pfields = out.putFields();
638         pfields.put(&quot;all_allowed&quot;, all_allowed);
639         pfields.put(&quot;permissions&quot;, permissions);
640         out.writeFields();
641     }
642 
643     /*
644      * Reads in a Hashtable of PropertyPermissions and saves them in the
645      * perms field. Reads in all_allowed.
646      */

647     private void readObject(ObjectInputStream in)
648         throws IOException, ClassNotFoundException
649     {
650         // Don&#39;t call defaultReadObject()
651 
652         // Read in serialized fields
653         ObjectInputStream.GetField gfields = in.readFields();
654 
655         // Get all_allowed
656         all_allowed = gfields.get(&quot;all_allowed&quot;, false);
657 
658         // Get permissions
659         @SuppressWarnings(&quot;unchecked&quot;)
660         Hashtable&lt;String, PropertyPermission&gt; permissions =
661             (Hashtable&lt;String, PropertyPermission&gt;)gfields.get(&quot;permissions&quot;, null);
662         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
663         perms.putAll(permissions);
664     }
665 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 37 import sun.security.util.SecurityConstants;
 38 
 39 /**
 40  * This class is for property permissions.
 41  *
 42  * &lt;P&gt;
 43  * The name is the name of the property (&quot;java.home&quot;,
 44  * &quot;os.name&quot;, etc). The naming
 45  * convention follows the  hierarchical property naming convention.
 46  * Also, an asterisk
 47  * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 48  * signify a wildcard match. For example: &quot;java.*&quot; and &quot;*&quot; signify a wildcard
 49  * match, while &quot;*java&quot; and &quot;a*b&quot; do not.
 50  * &lt;P&gt;
 51  * The actions to be granted are passed to the constructor in a string containing
 52  * a list of one or more comma-separated keywords. The possible keywords are
 53  * &quot;read&quot; and &quot;write&quot;. Their meaning is defined as follows:
 54  *
 55  * &lt;DL&gt;
 56  *    &lt;DT&gt; read
<span class="line-modified"> 57  *    &lt;DD&gt; read permission. Allows {@code System.getProperty} to</span>
 58  *         be called.
 59  *    &lt;DT&gt; write
<span class="line-modified"> 60  *    &lt;DD&gt; write permission. Allows {@code System.setProperty} to</span>
 61  *         be called.
 62  * &lt;/DL&gt;
 63  * &lt;P&gt;
 64  * The actions string is converted to lowercase before processing.
 65  * &lt;P&gt;
 66  * Care should be taken before granting code permission to access
 67  * certain system properties.  For example, granting permission to
 68  * access the &quot;java.home&quot; system property gives potentially malevolent
 69  * code sensitive information about the system environment (the Java
 70  * installation directory).  Also, granting permission to access
 71  * the &quot;user.name&quot; and &quot;user.home&quot; system properties gives potentially
 72  * malevolent code sensitive information about the user environment
 73  * (the user&#39;s account name and home directory).
 74  *
 75  * @see java.security.BasicPermission
 76  * @see java.security.Permission
 77  * @see java.security.Permissions
 78  * @see java.security.PermissionCollection
 79  * @see java.lang.SecurityManager
 80  *
</pre>
<hr />
<pre>
132 
133         if (mask == NONE)
134             throw new IllegalArgumentException(&quot;invalid actions mask&quot;);
135 
136         if (getName() == null)
137             throw new NullPointerException(&quot;name can&#39;t be null&quot;);
138 
139         this.mask = mask;
140     }
141 
142     /**
143      * Creates a new PropertyPermission object with the specified name.
144      * The name is the name of the system property, and
145      * &lt;i&gt;actions&lt;/i&gt; contains a comma-separated list of the
146      * desired actions granted on the property. Possible actions are
147      * &quot;read&quot; and &quot;write&quot;.
148      *
149      * @param name the name of the PropertyPermission.
150      * @param actions the actions string.
151      *
<span class="line-modified">152      * @throws NullPointerException if {@code name} is {@code null}.</span>
<span class="line-modified">153      * @throws IllegalArgumentException if {@code name} is empty or if</span>
<span class="line-modified">154      * {@code actions} is invalid.</span>
155      */
156     public PropertyPermission(String name, String actions) {
157         super(name,actions);
158         init(getMask(actions));
159     }
160 
161     /**
162      * Creates a PropertyPermission object with the specified name and
163      * a pre-calculated mask. Avoids the overhead of re-computing the mask.
164      * Called by PropertyPermissionCollection.
165      */
166     PropertyPermission(String name, int mask) {
167         super(name, getActions(mask));
168         this.mask = mask;
169     }
170 
171     /**
172      * Checks if this PropertyPermission object &quot;implies&quot; the specified
173      * permission.
174      * &lt;P&gt;
</pre>
<hr />
<pre>
206      * @return true if obj is a PropertyPermission, and has the same name and
207      * actions as this PropertyPermission object.
208      */
209     @Override
210     public boolean equals(Object obj) {
211         if (obj == this)
212             return true;
213 
214         if (! (obj instanceof PropertyPermission))
215             return false;
216 
217         PropertyPermission that = (PropertyPermission) obj;
218 
219         return (this.mask == that.mask) &amp;&amp;
220             (this.getName().equals(that.getName()));
221     }
222 
223     /**
224      * Returns the hash code value for this object.
225      * The hash code used is the hash code of this permissions name, that is,
<span class="line-modified">226      * {@code getName().hashCode()}, where {@code getName} is</span>
227      * from the Permission superclass.
228      *
229      * @return a hash code value for this object.
230      */
231     @Override
232     public int hashCode() {
233         return this.getName().hashCode();
234     }
235 
236     /**
237      * Converts an actions String to an actions mask.
238      *
239      * @param actions the action string.
240      * @return the actions mask.
241      */
242     private static int getMask(String actions) {
243 
244         int mask = NONE;
245 
246         if (actions == null) {
</pre>
<hr />
<pre>
333      *
334      * @return the canonical string representation of the actions.
335      */
336     static String getActions(int mask) {
337         switch (mask &amp; (READ|WRITE)) {
338             case READ:
339                 return SecurityConstants.PROPERTY_READ_ACTION;
340             case WRITE:
341                 return SecurityConstants.PROPERTY_WRITE_ACTION;
342             case READ|WRITE:
343                 return SecurityConstants.PROPERTY_RW_ACTION;
344             default:
345                 return &quot;&quot;;
346         }
347     }
348 
349     /**
350      * Returns the &quot;canonical string representation&quot; of the actions.
351      * That is, this method always returns present actions in the following order:
352      * read, write. For example, if this PropertyPermission object
<span class="line-modified">353      * allows both write and read actions, a call to {@code getActions}</span>
354      * will return the string &quot;read,write&quot;.
355      *
356      * @return the canonical string representation of the actions.
357      */
358     @Override
359     public String getActions() {
360         if (actions == null)
361             actions = getActions(this.mask);
362 
363         return actions;
364     }
365 
366     /**
367      * Return the current action mask.
368      * Used by the PropertyPermissionCollection
369      *
370      * @return the actions mask.
371      */
372     int getMask() {
373         return mask;
374     }
375 
376     /**
377      * Returns a new PermissionCollection object for storing
378      * PropertyPermission objects.
379      *
380      * @return a new PermissionCollection object suitable for storing
381      * PropertyPermissions.
382      */
383     @Override
384     public PermissionCollection newPermissionCollection() {
385         return new PropertyPermissionCollection();
386     }
387 
<span class="line-modified">388     @java.io.Serial</span>
389     private static final long serialVersionUID = 885438825399942851L;
390 
391     /**
392      * WriteObject is called to save the state of the PropertyPermission
393      * to a stream. The actions are serialized, and the superclass
394      * takes care of the name.
395      */
<span class="line-added">396     @java.io.Serial</span>
397     private synchronized void writeObject(java.io.ObjectOutputStream s)
398         throws IOException
399     {
400         // Write out the actions. The superclass takes care of the name
401         // call getActions to make sure actions field is initialized
402         if (actions == null)
403             getActions();
404         s.defaultWriteObject();
405     }
406 
407     /**
408      * readObject is called to restore the state of the PropertyPermission from
409      * a stream.
410      */
<span class="line-added">411     @java.io.Serial</span>
412     private synchronized void readObject(java.io.ObjectInputStream s)
413          throws IOException, ClassNotFoundException
414     {
415         // Read in the action, then initialize the rest
416         s.defaultReadObject();
417         init(getMask(actions));
418     }
419 }
420 
421 /**
422  * A PropertyPermissionCollection stores a set of PropertyPermission
423  * permissions.
424  *
425  * @see java.security.Permission
426  * @see java.security.Permissions
427  * @see java.security.PermissionCollection
428  *
429  *
430  * @author Roland Schemers
431  *
</pre>
<hr />
<pre>
446      *
447      * @see #serialPersistentFields
448      */
449     // No sync access; OK for this to be stale.
450     private boolean all_allowed;
451 
452     /**
453      * Create an empty PropertyPermissionCollection object.
454      */
455     public PropertyPermissionCollection() {
456         perms = new ConcurrentHashMap&lt;&gt;(32);     // Capacity for default policy
457         all_allowed = false;
458     }
459 
460     /**
461      * Adds a permission to the PropertyPermissions. The key for the hash is
462      * the name.
463      *
464      * @param permission the Permission object to add.
465      *
<span class="line-modified">466      * @throws    IllegalArgumentException   if the permission is not a</span>
467      *                                       PropertyPermission
468      *
<span class="line-modified">469      * @throws    SecurityException   if this PropertyPermissionCollection</span>
470      *                                object has been marked readonly
471      */
472     @Override
473     public void add(Permission permission) {
474         if (! (permission instanceof PropertyPermission))
475             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
476                                                permission);
477         if (isReadOnly())
478             throw new SecurityException(
479                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
480 
481         PropertyPermission pp = (PropertyPermission) permission;
482         String propName = pp.getName();
483 
484         // Add permission to map if it is absent, or replace with new
485         // permission if applicable. NOTE: cannot use lambda for
486         // remappingFunction parameter until JDK-8076596 is fixed.
487         perms.merge(propName, pp,
488             new java.util.function.BiFunction&lt;&gt;() {
489                 @Override
</pre>
<hr />
<pre>
581         // at the top (all_allowed), so we just return false
582         return false;
583     }
584 
585     /**
586      * Returns an enumeration of all the PropertyPermission objects in the
587      * container.
588      *
589      * @return an enumeration of all the PropertyPermission objects.
590      */
591     @Override
592     @SuppressWarnings(&quot;unchecked&quot;)
593     public Enumeration&lt;Permission&gt; elements() {
594         /**
595          * Casting to rawtype since Enumeration&lt;PropertyPermission&gt;
596          * cannot be directly cast to Enumeration&lt;Permission&gt;
597          */
598         return (Enumeration)perms.elements();
599     }
600 
<span class="line-added">601     @java.io.Serial</span>
602     private static final long serialVersionUID = 7015263904581634791L;
603 
604     // Need to maintain serialization interoperability with earlier releases,
605     // which had the serializable field:
606     //
607     // Table of permissions.
608     //
609     // @serial
610     //
611     // private Hashtable permissions;
612     /**
613      * @serialField permissions java.util.Hashtable
614      *     A table of the PropertyPermissions.
615      * @serialField all_allowed boolean
616      *     boolean saying if &quot;*&quot; is in the collection.
617      */
618     private static final ObjectStreamField[] serialPersistentFields = {
619         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
620         new ObjectStreamField(&quot;all_allowed&quot;, Boolean.TYPE),
621     };
622 
623     /**
624      * @serialData Default fields.
625      */
626     /*
627      * Writes the contents of the perms field out as a Hashtable for
628      * serialization compatibility with earlier releases. all_allowed
629      * unchanged.
630      */
<span class="line-added">631     @java.io.Serial</span>
632     private void writeObject(ObjectOutputStream out) throws IOException {
633         // Don&#39;t call out.defaultWriteObject()
634 
635         // Copy perms into a Hashtable
636         Hashtable&lt;String, Permission&gt; permissions =
637             new Hashtable&lt;&gt;(perms.size()*2);
638         permissions.putAll(perms);
639 
640         // Write out serializable fields
641         ObjectOutputStream.PutField pfields = out.putFields();
642         pfields.put(&quot;all_allowed&quot;, all_allowed);
643         pfields.put(&quot;permissions&quot;, permissions);
644         out.writeFields();
645     }
646 
647     /*
648      * Reads in a Hashtable of PropertyPermissions and saves them in the
649      * perms field. Reads in all_allowed.
650      */
<span class="line-added">651     @java.io.Serial</span>
652     private void readObject(ObjectInputStream in)
653         throws IOException, ClassNotFoundException
654     {
655         // Don&#39;t call defaultReadObject()
656 
657         // Read in serialized fields
658         ObjectInputStream.GetField gfields = in.readFields();
659 
660         // Get all_allowed
661         all_allowed = gfields.get(&quot;all_allowed&quot;, false);
662 
663         // Get permissions
664         @SuppressWarnings(&quot;unchecked&quot;)
665         Hashtable&lt;String, PropertyPermission&gt; permissions =
666             (Hashtable&lt;String, PropertyPermission&gt;)gfields.get(&quot;permissions&quot;, null);
667         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
668         perms.putAll(permissions);
669     }
670 }
</pre>
</td>
</tr>
</table>
<center><a href="Properties.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyResourceBundle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/MessageDigest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyStoreSpi.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MessageDigestSpi.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/MessageDigest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 67  *     ...etc.
 68  * } catch (CloneNotSupportedException cnse) {
 69  *     throw new DigestException(&quot;couldn&#39;t make digest of partial content&quot;);
 70  * }
 71  * }&lt;/pre&gt;
 72  *
 73  * &lt;p&gt;Note that if a given implementation is not cloneable, it is
 74  * still possible to compute intermediate digests by instantiating
 75  * several instances, if the number of digests is known in advance.
 76  *
 77  * &lt;p&gt;Note that this class is abstract and extends from
 78  * {@code MessageDigestSpi} for historical reasons.
 79  * Application developers should only take notice of the methods defined in
 80  * this {@code MessageDigest} class; all the methods in
 81  * the superclass are intended for cryptographic service providers who wish to
 82  * supply their own implementations of message digest algorithms.
 83  *
 84  * &lt;p&gt; Every implementation of the Java platform is required to support
 85  * the following standard {@code MessageDigest} algorithms:
 86  * &lt;ul&gt;
<span class="line-removed"> 87  * &lt;li&gt;{@code MD5}&lt;/li&gt;</span>
 88  * &lt;li&gt;{@code SHA-1}&lt;/li&gt;
 89  * &lt;li&gt;{@code SHA-256}&lt;/li&gt;
 90  * &lt;/ul&gt;
 91  * These algorithms are described in the &lt;a href=
 92  * &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
 93  * MessageDigest section&lt;/a&gt; of the
 94  * Java Security Standard Algorithm Names Specification.
 95  * Consult the release documentation for your implementation to see if any
 96  * other algorithms are supported.
 97  *
 98  * @author Benjamin Renaud
 99  * @since 1.1
100  *
101  * @see DigestInputStream
102  * @see DigestOutputStream
103  */
104 
105 public abstract class MessageDigest extends MessageDigestSpi {
106 
107     private static final Debug pdebug =
</pre>
<hr />
<pre>
382      */
383     public byte[] digest() {
384         /* Resetting is the responsibility of implementors. */
385         byte[] result = engineDigest();
386         state = INITIAL;
387         return result;
388     }
389 
390     /**
391      * Completes the hash computation by performing final operations
392      * such as padding. The digest is reset after this call is made.
393      *
394      * @param buf output buffer for the computed digest
395      *
396      * @param offset offset into the output buffer to begin storing the digest
397      *
398      * @param len number of bytes within buf allotted for the digest
399      *
400      * @return the number of bytes placed into {@code buf}
401      *
<span class="line-modified">402      * @exception DigestException if an error occurs.</span>
403      */
404     public int digest(byte[] buf, int offset, int len) throws DigestException {
405         if (buf == null) {
406             throw new IllegalArgumentException(&quot;No output buffer given&quot;);
407         }
408         if (buf.length - offset &lt; len) {
409             throw new IllegalArgumentException
410                 (&quot;Output buffer too small for specified offset and length&quot;);
411         }
412         int numBytes = engineDigest(buf, offset, len);
413         state = INITIAL;
414         return numBytes;
415     }
416 
417     /**
418      * Performs a final update on the digest using the specified array
419      * of bytes, then completes the digest computation. That is, this
420      * method first calls {@link #update(byte[]) update(input)},
421      * passing the &lt;i&gt;input&lt;/i&gt; array to the {@code update} method,
422      * then calls {@link #digest() digest()}.
</pre>
<hr />
<pre>
519      */
520     public final int getDigestLength() {
521         int digestLen = engineGetDigestLength();
522         if (digestLen == 0) {
523             try {
524                 MessageDigest md = (MessageDigest)clone();
525                 byte[] digest = md.digest();
526                 return digest.length;
527             } catch (CloneNotSupportedException e) {
528                 return digestLen;
529             }
530         }
531         return digestLen;
532     }
533 
534     /**
535      * Returns a clone if the implementation is cloneable.
536      *
537      * @return a clone if the implementation is cloneable.
538      *
<span class="line-modified">539      * @exception CloneNotSupportedException if this is called on an</span>
540      * implementation that does not support {@code Cloneable}.
541      */
542     public Object clone() throws CloneNotSupportedException {
543         if (this instanceof Cloneable) {
544             return super.clone();
545         } else {
546             throw new CloneNotSupportedException();
547         }
548     }
549 
550 
551 
552 
553     /*
554      * The following class allows providers to extend from MessageDigestSpi
555      * rather than from MessageDigest. It represents a MessageDigest with an
556      * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
557      * If the provider implementation is an instance of MessageDigestSpi,
558      * the getInstance() methods above return an instance of this class, with
559      * the SPI object encapsulated.
</pre>
<hr />
<pre>
563      * been interposed in the hierarchy between the API (MessageDigest)
564      * and its original parent (Object).
565      */
566 
567     static class Delegate extends MessageDigest implements MessageDigestSpi2 {
568 
569         // The provider implementation (delegate)
570         private MessageDigestSpi digestSpi;
571 
572         // constructor
573         public Delegate(MessageDigestSpi digestSpi, String algorithm) {
574             super(algorithm);
575             this.digestSpi = digestSpi;
576         }
577 
578         /**
579          * Returns a clone if the delegate is cloneable.
580          *
581          * @return a clone if the delegate is cloneable.
582          *
<span class="line-modified">583          * @exception CloneNotSupportedException if this is called on a</span>
584          * delegate that does not support {@code Cloneable}.
585          */
586         public Object clone() throws CloneNotSupportedException {
587             if (digestSpi instanceof Cloneable) {
588                 MessageDigestSpi digestSpiClone =
589                     (MessageDigestSpi)digestSpi.clone();
590                 // Because &#39;algorithm&#39;, &#39;provider&#39;, and &#39;state&#39; are private
591                 // members of our supertype, we must perform a cast to
592                 // access them.
593                 MessageDigest that =
594                     new Delegate(digestSpiClone,
595                                  ((MessageDigest)this).algorithm);
596                 that.provider = ((MessageDigest)this).provider;
597                 that.state = ((MessageDigest)this).state;
598                 return that;
599             } else {
600                 throw new CloneNotSupportedException();
601             }
602         }
603 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 67  *     ...etc.
 68  * } catch (CloneNotSupportedException cnse) {
 69  *     throw new DigestException(&quot;couldn&#39;t make digest of partial content&quot;);
 70  * }
 71  * }&lt;/pre&gt;
 72  *
 73  * &lt;p&gt;Note that if a given implementation is not cloneable, it is
 74  * still possible to compute intermediate digests by instantiating
 75  * several instances, if the number of digests is known in advance.
 76  *
 77  * &lt;p&gt;Note that this class is abstract and extends from
 78  * {@code MessageDigestSpi} for historical reasons.
 79  * Application developers should only take notice of the methods defined in
 80  * this {@code MessageDigest} class; all the methods in
 81  * the superclass are intended for cryptographic service providers who wish to
 82  * supply their own implementations of message digest algorithms.
 83  *
 84  * &lt;p&gt; Every implementation of the Java platform is required to support
 85  * the following standard {@code MessageDigest} algorithms:
 86  * &lt;ul&gt;

 87  * &lt;li&gt;{@code SHA-1}&lt;/li&gt;
 88  * &lt;li&gt;{@code SHA-256}&lt;/li&gt;
 89  * &lt;/ul&gt;
 90  * These algorithms are described in the &lt;a href=
 91  * &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
 92  * MessageDigest section&lt;/a&gt; of the
 93  * Java Security Standard Algorithm Names Specification.
 94  * Consult the release documentation for your implementation to see if any
 95  * other algorithms are supported.
 96  *
 97  * @author Benjamin Renaud
 98  * @since 1.1
 99  *
100  * @see DigestInputStream
101  * @see DigestOutputStream
102  */
103 
104 public abstract class MessageDigest extends MessageDigestSpi {
105 
106     private static final Debug pdebug =
</pre>
<hr />
<pre>
381      */
382     public byte[] digest() {
383         /* Resetting is the responsibility of implementors. */
384         byte[] result = engineDigest();
385         state = INITIAL;
386         return result;
387     }
388 
389     /**
390      * Completes the hash computation by performing final operations
391      * such as padding. The digest is reset after this call is made.
392      *
393      * @param buf output buffer for the computed digest
394      *
395      * @param offset offset into the output buffer to begin storing the digest
396      *
397      * @param len number of bytes within buf allotted for the digest
398      *
399      * @return the number of bytes placed into {@code buf}
400      *
<span class="line-modified">401      * @throws    DigestException if an error occurs.</span>
402      */
403     public int digest(byte[] buf, int offset, int len) throws DigestException {
404         if (buf == null) {
405             throw new IllegalArgumentException(&quot;No output buffer given&quot;);
406         }
407         if (buf.length - offset &lt; len) {
408             throw new IllegalArgumentException
409                 (&quot;Output buffer too small for specified offset and length&quot;);
410         }
411         int numBytes = engineDigest(buf, offset, len);
412         state = INITIAL;
413         return numBytes;
414     }
415 
416     /**
417      * Performs a final update on the digest using the specified array
418      * of bytes, then completes the digest computation. That is, this
419      * method first calls {@link #update(byte[]) update(input)},
420      * passing the &lt;i&gt;input&lt;/i&gt; array to the {@code update} method,
421      * then calls {@link #digest() digest()}.
</pre>
<hr />
<pre>
518      */
519     public final int getDigestLength() {
520         int digestLen = engineGetDigestLength();
521         if (digestLen == 0) {
522             try {
523                 MessageDigest md = (MessageDigest)clone();
524                 byte[] digest = md.digest();
525                 return digest.length;
526             } catch (CloneNotSupportedException e) {
527                 return digestLen;
528             }
529         }
530         return digestLen;
531     }
532 
533     /**
534      * Returns a clone if the implementation is cloneable.
535      *
536      * @return a clone if the implementation is cloneable.
537      *
<span class="line-modified">538      * @throws    CloneNotSupportedException if this is called on an</span>
539      * implementation that does not support {@code Cloneable}.
540      */
541     public Object clone() throws CloneNotSupportedException {
542         if (this instanceof Cloneable) {
543             return super.clone();
544         } else {
545             throw new CloneNotSupportedException();
546         }
547     }
548 
549 
550 
551 
552     /*
553      * The following class allows providers to extend from MessageDigestSpi
554      * rather than from MessageDigest. It represents a MessageDigest with an
555      * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
556      * If the provider implementation is an instance of MessageDigestSpi,
557      * the getInstance() methods above return an instance of this class, with
558      * the SPI object encapsulated.
</pre>
<hr />
<pre>
562      * been interposed in the hierarchy between the API (MessageDigest)
563      * and its original parent (Object).
564      */
565 
566     static class Delegate extends MessageDigest implements MessageDigestSpi2 {
567 
568         // The provider implementation (delegate)
569         private MessageDigestSpi digestSpi;
570 
571         // constructor
572         public Delegate(MessageDigestSpi digestSpi, String algorithm) {
573             super(algorithm);
574             this.digestSpi = digestSpi;
575         }
576 
577         /**
578          * Returns a clone if the delegate is cloneable.
579          *
580          * @return a clone if the delegate is cloneable.
581          *
<span class="line-modified">582          * @throws    CloneNotSupportedException if this is called on a</span>
583          * delegate that does not support {@code Cloneable}.
584          */
585         public Object clone() throws CloneNotSupportedException {
586             if (digestSpi instanceof Cloneable) {
587                 MessageDigestSpi digestSpiClone =
588                     (MessageDigestSpi)digestSpi.clone();
589                 // Because &#39;algorithm&#39;, &#39;provider&#39;, and &#39;state&#39; are private
590                 // members of our supertype, we must perform a cast to
591                 // access them.
592                 MessageDigest that =
593                     new Delegate(digestSpiClone,
594                                  ((MessageDigest)this).algorithm);
595                 that.provider = ((MessageDigest)this).provider;
596                 that.state = ((MessageDigest)this).state;
597                 return that;
598             } else {
599                 throw new CloneNotSupportedException();
600             }
601         }
602 
</pre>
</td>
</tr>
</table>
<center><a href="KeyStoreSpi.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MessageDigestSpi.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
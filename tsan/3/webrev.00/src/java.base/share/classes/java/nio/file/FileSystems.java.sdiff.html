<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/file/FileSystems.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileSystemNotFoundException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Files.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/file/FileSystems.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
235     }
236 
237     /**
238      * Constructs a new file system that is identified by a {@link URI}
239      *
240      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
241      * installed} providers to locate the provider that is identified by the URI
242      * {@link URI#getScheme scheme} of the given URI. URI schemes are compared
243      * without regard to case. The exact form of the URI is highly provider
244      * dependent. If found, the provider&#39;s {@link FileSystemProvider#newFileSystem(URI,Map)
245      * newFileSystem(URI,Map)} method is invoked to construct the new file system.
246      *
247      * &lt;p&gt; Once a file system is {@link FileSystem#close closed} it is
248      * provider-dependent if the provider allows a new file system to be created
249      * with the same URI as a file system it previously created.
250      *
251      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
252      * Suppose there is a provider identified by the scheme {@code &quot;memory&quot;}
253      * installed:
254      * &lt;pre&gt;
<span class="line-modified">255      *   Map&amp;lt;String,String&amp;gt; env = new HashMap&amp;lt;&amp;gt;();</span>
<span class="line-modified">256      *   env.put(&quot;capacity&quot;, &quot;16G&quot;);</span>
<span class="line-removed">257      *   env.put(&quot;blockSize&quot;, &quot;4k&quot;);</span>
<span class="line-removed">258      *   FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;memory:///?name=logfs&quot;), env);</span>
259      * &lt;/pre&gt;
260      *
261      * @param   uri
262      *          the URI identifying the file system
263      * @param   env
264      *          a map of provider specific properties to configure the file system;
265      *          may be empty
266      *
267      * @return  a new file system
268      *
269      * @throws  IllegalArgumentException
270      *          if the pre-conditions for the {@code uri} parameter are not met,
271      *          or the {@code env} parameter does not contain properties required
272      *          by the provider, or a property value is invalid
273      * @throws  FileSystemAlreadyExistsException
274      *          if the file system has already been created
275      * @throws  ProviderNotFoundException
276      *          if a provider supporting the URI scheme is not installed
277      * @throws  IOException
278      *          if an I/O error occurs creating the file system
</pre>
<hr />
<pre>
340             }
341         }
342 
343         // if not found, use service-provider loading facility
344         if (loader != null) {
345             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
346                 .load(FileSystemProvider.class, loader);
347             for (FileSystemProvider provider : sl) {
348                 if (scheme.equalsIgnoreCase(provider.getScheme())) {
349                     try {
350                         return provider.newFileSystem(uri, env);
351                     } catch (UnsupportedOperationException uoe) {
352                     }
353                 }
354             }
355         }
356 
357         throw new ProviderNotFoundException(&quot;Provider \&quot;&quot; + scheme + &quot;\&quot; not found&quot;);
358     }
359 




















































































































360     /**
361      * Constructs a new {@code FileSystem} to access the contents of a file as a
362      * file system.
363      *
364      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
365      * systems where the contents of one or more files is treated as a file
366      * system.
367      *
368      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
369      * installed} providers. It invokes, in turn, each provider&#39;s {@link
<span class="line-modified">370      * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)} method</span>
<span class="line-modified">371      * with an empty map. If a provider returns a file system then the iteration</span>
<span class="line-modified">372      * terminates and the file system is returned. If none of the installed</span>
<span class="line-modified">373      * providers return a {@code FileSystem} then an attempt is made to locate</span>
<span class="line-modified">374      * the provider using the given class loader. If a provider returns a file</span>
<span class="line-modified">375      * system then the lookup terminates and the file system is returned.</span>

376      *
377      * @param   path
378      *          the path to the file



379      * @param   loader
380      *          the class loader to locate the provider or {@code null} to only
381      *          attempt to locate an installed provider
382      *
383      * @return  a new file system
384      *
385      * @throws  ProviderNotFoundException
386      *          if a provider supporting this file type cannot be located
387      * @throws  ServiceConfigurationError
388      *          when an error occurs while loading a service provider
389      * @throws  IOException
390      *          if an I/O error occurs
391      * @throws  SecurityException
392      *          if a security manager is installed and it denies an unspecified
393      *          permission


394      */
<span class="line-modified">395     public static FileSystem newFileSystem(Path path,</span>
396                                            ClassLoader loader)
397         throws IOException
398     {
399         if (path == null)
400             throw new NullPointerException();
<span class="line-removed">401         Map&lt;String,?&gt; env = Collections.emptyMap();</span>
<span class="line-removed">402 </span>
403         // check installed providers
404         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
405             try {
406                 return provider.newFileSystem(path, env);
407             } catch (UnsupportedOperationException uoe) {
408             }
409         }
410 
411         // if not found, use service-provider loading facility
412         if (loader != null) {
413             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
414                 .load(FileSystemProvider.class, loader);
415             for (FileSystemProvider provider: sl) {
416                 try {
417                     return provider.newFileSystem(path, env);
418                 } catch (UnsupportedOperationException uoe) {
419                 }
420             }
421         }
422 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
235     }
236 
237     /**
238      * Constructs a new file system that is identified by a {@link URI}
239      *
240      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
241      * installed} providers to locate the provider that is identified by the URI
242      * {@link URI#getScheme scheme} of the given URI. URI schemes are compared
243      * without regard to case. The exact form of the URI is highly provider
244      * dependent. If found, the provider&#39;s {@link FileSystemProvider#newFileSystem(URI,Map)
245      * newFileSystem(URI,Map)} method is invoked to construct the new file system.
246      *
247      * &lt;p&gt; Once a file system is {@link FileSystem#close closed} it is
248      * provider-dependent if the provider allows a new file system to be created
249      * with the same URI as a file system it previously created.
250      *
251      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
252      * Suppose there is a provider identified by the scheme {@code &quot;memory&quot;}
253      * installed:
254      * &lt;pre&gt;
<span class="line-modified">255      *  FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;memory:///?name=logfs&quot;),</span>
<span class="line-modified">256      *                                            Map.of(&quot;capacity&quot;, &quot;16G&quot;, &quot;blockSize&quot;, &quot;4k&quot;));</span>


257      * &lt;/pre&gt;
258      *
259      * @param   uri
260      *          the URI identifying the file system
261      * @param   env
262      *          a map of provider specific properties to configure the file system;
263      *          may be empty
264      *
265      * @return  a new file system
266      *
267      * @throws  IllegalArgumentException
268      *          if the pre-conditions for the {@code uri} parameter are not met,
269      *          or the {@code env} parameter does not contain properties required
270      *          by the provider, or a property value is invalid
271      * @throws  FileSystemAlreadyExistsException
272      *          if the file system has already been created
273      * @throws  ProviderNotFoundException
274      *          if a provider supporting the URI scheme is not installed
275      * @throws  IOException
276      *          if an I/O error occurs creating the file system
</pre>
<hr />
<pre>
338             }
339         }
340 
341         // if not found, use service-provider loading facility
342         if (loader != null) {
343             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
344                 .load(FileSystemProvider.class, loader);
345             for (FileSystemProvider provider : sl) {
346                 if (scheme.equalsIgnoreCase(provider.getScheme())) {
347                     try {
348                         return provider.newFileSystem(uri, env);
349                     } catch (UnsupportedOperationException uoe) {
350                     }
351                 }
352             }
353         }
354 
355         throw new ProviderNotFoundException(&quot;Provider \&quot;&quot; + scheme + &quot;\&quot; not found&quot;);
356     }
357 
<span class="line-added">358     /**</span>
<span class="line-added">359      * Constructs a new {@code FileSystem} to access the contents of a file as a</span>
<span class="line-added">360      * file system.</span>
<span class="line-added">361      *</span>
<span class="line-added">362      * &lt;p&gt; This method makes use of specialized providers that create pseudo file</span>
<span class="line-added">363      * systems where the contents of one or more files is treated as a file</span>
<span class="line-added">364      * system.</span>
<span class="line-added">365      *</span>
<span class="line-added">366      * &lt;p&gt; This method first attempts to locate an installed provider in exactly</span>
<span class="line-added">367      * the same manner as the {@link #newFileSystem(Path, Map, ClassLoader)</span>
<span class="line-added">368      * newFileSystem(Path, Map, ClassLoader)} method with an empty map. If none</span>
<span class="line-added">369      * of the installed providers return a {@code FileSystem} then an attempt is</span>
<span class="line-added">370      * made to locate the provider using the given class loader. If a provider</span>
<span class="line-added">371      * returns a file system then the lookup terminates and the file system is</span>
<span class="line-added">372      * returned.</span>
<span class="line-added">373      *</span>
<span class="line-added">374      * @param   path</span>
<span class="line-added">375      *          the path to the file</span>
<span class="line-added">376      * @param   loader</span>
<span class="line-added">377      *          the class loader to locate the provider or {@code null} to only</span>
<span class="line-added">378      *          attempt to locate an installed provider</span>
<span class="line-added">379      *</span>
<span class="line-added">380      * @return  a new file system</span>
<span class="line-added">381      *</span>
<span class="line-added">382      * @throws  ProviderNotFoundException</span>
<span class="line-added">383      *          if a provider supporting this file type cannot be located</span>
<span class="line-added">384      * @throws  ServiceConfigurationError</span>
<span class="line-added">385      *          when an error occurs while loading a service provider</span>
<span class="line-added">386      * @throws  IOException</span>
<span class="line-added">387      *          if an I/O error occurs</span>
<span class="line-added">388      * @throws  SecurityException</span>
<span class="line-added">389      *          if a security manager is installed and it denies an unspecified</span>
<span class="line-added">390      *          permission</span>
<span class="line-added">391      */</span>
<span class="line-added">392     public static FileSystem newFileSystem(Path path,</span>
<span class="line-added">393                                            ClassLoader loader)</span>
<span class="line-added">394         throws IOException</span>
<span class="line-added">395     {</span>
<span class="line-added">396         return newFileSystem(path, Map.of(), loader);</span>
<span class="line-added">397     }</span>
<span class="line-added">398 </span>
<span class="line-added">399     /**</span>
<span class="line-added">400      * Constructs a new {@code FileSystem} to access the contents of a file as a</span>
<span class="line-added">401      * file system.</span>
<span class="line-added">402      *</span>
<span class="line-added">403      * &lt;p&gt; This method makes use of specialized providers that create pseudo file</span>
<span class="line-added">404      * systems where the contents of one or more files is treated as a file</span>
<span class="line-added">405      * system.</span>
<span class="line-added">406      *</span>
<span class="line-added">407      * &lt;p&gt; This method first attempts to locate an installed provider in exactly</span>
<span class="line-added">408      * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)</span>
<span class="line-added">409      * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider&#39;s</span>
<span class="line-added">410      * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}</span>
<span class="line-added">411      * method is invoked to construct the new file system.</span>
<span class="line-added">412      *</span>
<span class="line-added">413      * @param   path</span>
<span class="line-added">414      *          the path to the file</span>
<span class="line-added">415      * @param   env</span>
<span class="line-added">416      *          a map of provider specific properties to configure the file system;</span>
<span class="line-added">417      *          may be empty</span>
<span class="line-added">418      *</span>
<span class="line-added">419      * @return  a new file system</span>
<span class="line-added">420      *</span>
<span class="line-added">421      * @throws  ProviderNotFoundException</span>
<span class="line-added">422      *          if a provider supporting this file type cannot be located</span>
<span class="line-added">423      * @throws  ServiceConfigurationError</span>
<span class="line-added">424      *          when an error occurs while loading a service provider</span>
<span class="line-added">425      * @throws  IOException</span>
<span class="line-added">426      *          if an I/O error occurs</span>
<span class="line-added">427      * @throws  SecurityException</span>
<span class="line-added">428      *          if a security manager is installed and it denies an unspecified</span>
<span class="line-added">429      *          permission</span>
<span class="line-added">430      *</span>
<span class="line-added">431      * @since 13</span>
<span class="line-added">432      */</span>
<span class="line-added">433     public static FileSystem newFileSystem(Path path, Map&lt;String,?&gt; env)</span>
<span class="line-added">434         throws IOException</span>
<span class="line-added">435     {</span>
<span class="line-added">436         return newFileSystem(path, env, null);</span>
<span class="line-added">437     }</span>
<span class="line-added">438 </span>
<span class="line-added">439     /**</span>
<span class="line-added">440      * Constructs a new {@code FileSystem} to access the contents of a file as a</span>
<span class="line-added">441      * file system.</span>
<span class="line-added">442      *</span>
<span class="line-added">443      * &lt;p&gt; This method makes use of specialized providers that create pseudo file</span>
<span class="line-added">444      * systems where the contents of one or more files is treated as a file</span>
<span class="line-added">445      * system.</span>
<span class="line-added">446      *</span>
<span class="line-added">447      * &lt;p&gt; This method first attempts to locate an installed provider in exactly</span>
<span class="line-added">448      * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)</span>
<span class="line-added">449      * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider&#39;s</span>
<span class="line-added">450      * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}</span>
<span class="line-added">451      * method is invoked with an empty map to construct the new file system.</span>
<span class="line-added">452      *</span>
<span class="line-added">453      * @param   path</span>
<span class="line-added">454      *          the path to the file</span>
<span class="line-added">455      *</span>
<span class="line-added">456      * @return  a new file system</span>
<span class="line-added">457      *</span>
<span class="line-added">458      * @throws  ProviderNotFoundException</span>
<span class="line-added">459      *          if a provider supporting this file type cannot be located</span>
<span class="line-added">460      * @throws  ServiceConfigurationError</span>
<span class="line-added">461      *          when an error occurs while loading a service provider</span>
<span class="line-added">462      * @throws  IOException</span>
<span class="line-added">463      *          if an I/O error occurs</span>
<span class="line-added">464      * @throws  SecurityException</span>
<span class="line-added">465      *          if a security manager is installed and it denies an unspecified</span>
<span class="line-added">466      *          permission</span>
<span class="line-added">467      *</span>
<span class="line-added">468      * @since 13</span>
<span class="line-added">469      */</span>
<span class="line-added">470     public static FileSystem newFileSystem(Path path) throws IOException {</span>
<span class="line-added">471         return newFileSystem(path, Map.of(), null);</span>
<span class="line-added">472     }</span>
<span class="line-added">473 </span>
474     /**
475      * Constructs a new {@code FileSystem} to access the contents of a file as a
476      * file system.
477      *
478      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
479      * systems where the contents of one or more files is treated as a file
480      * system.
481      *
482      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
483      * installed} providers. It invokes, in turn, each provider&#39;s {@link
<span class="line-modified">484      * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)}</span>
<span class="line-modified">485      * method. If a provider returns a file system then the iteration</span>
<span class="line-modified">486      * terminates and the file system is returned.</span>
<span class="line-modified">487      * If none of the installed providers return a {@code FileSystem} then</span>
<span class="line-modified">488      * an attempt is made to locate the provider using the given class loader.</span>
<span class="line-modified">489      * If a provider returns a file</span>
<span class="line-added">490      * system, then the lookup terminates and the file system is returned.</span>
491      *
492      * @param   path
493      *          the path to the file
<span class="line-added">494      * @param   env</span>
<span class="line-added">495      *          a map of provider specific properties to configure the file system;</span>
<span class="line-added">496      *          may be empty</span>
497      * @param   loader
498      *          the class loader to locate the provider or {@code null} to only
499      *          attempt to locate an installed provider
500      *
501      * @return  a new file system
502      *
503      * @throws  ProviderNotFoundException
504      *          if a provider supporting this file type cannot be located
505      * @throws  ServiceConfigurationError
506      *          when an error occurs while loading a service provider
507      * @throws  IOException
508      *          if an I/O error occurs
509      * @throws  SecurityException
510      *          if a security manager is installed and it denies an unspecified
511      *          permission
<span class="line-added">512      *</span>
<span class="line-added">513      * @since 13</span>
514      */
<span class="line-modified">515     public static FileSystem newFileSystem(Path path, Map&lt;String,?&gt; env,</span>
516                                            ClassLoader loader)
517         throws IOException
518     {
519         if (path == null)
520             throw new NullPointerException();


521         // check installed providers
522         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
523             try {
524                 return provider.newFileSystem(path, env);
525             } catch (UnsupportedOperationException uoe) {
526             }
527         }
528 
529         // if not found, use service-provider loading facility
530         if (loader != null) {
531             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
532                 .load(FileSystemProvider.class, loader);
533             for (FileSystemProvider provider: sl) {
534                 try {
535                     return provider.newFileSystem(path, env);
536                 } catch (UnsupportedOperationException uoe) {
537                 }
538             }
539         }
540 
</pre>
</td>
</tr>
</table>
<center><a href="FileSystemNotFoundException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Files.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DateTimeFormatter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DateTimeParseException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  68 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  69 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  70 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
  71 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
  72 import static java.time.temporal.ChronoField.YEAR;
  73 import static java.time.temporal.ChronoField.ERA;
  74 
  75 import java.lang.ref.SoftReference;
  76 import java.math.BigDecimal;
  77 import java.math.BigInteger;
  78 import java.math.RoundingMode;
  79 import java.text.ParsePosition;
  80 import java.time.DateTimeException;
  81 import java.time.Instant;
  82 import java.time.LocalDate;
  83 import java.time.LocalDateTime;
  84 import java.time.LocalTime;
  85 import java.time.ZoneId;
  86 import java.time.ZoneOffset;
  87 import java.time.chrono.ChronoLocalDate;
<span class="line-removed">  88 import java.time.chrono.ChronoLocalDateTime;</span>
  89 import java.time.chrono.Chronology;
  90 import java.time.chrono.Era;
  91 import java.time.chrono.IsoChronology;
  92 import java.time.format.DateTimeTextProvider.LocaleStore;
  93 import java.time.temporal.ChronoField;
  94 import java.time.temporal.IsoFields;
  95 import java.time.temporal.JulianFields;
  96 import java.time.temporal.TemporalAccessor;
  97 import java.time.temporal.TemporalField;
  98 import java.time.temporal.TemporalQueries;
  99 import java.time.temporal.TemporalQuery;
 100 import java.time.temporal.ValueRange;
 101 import java.time.temporal.WeekFields;
 102 import java.time.zone.ZoneRulesProvider;
 103 import java.util.AbstractMap.SimpleImmutableEntry;
 104 import java.util.ArrayList;
 105 import java.util.Arrays;
 106 import java.util.Collections;
 107 import java.util.Comparator;
 108 import java.util.HashMap;
 109 import java.util.HashSet;
 110 import java.util.Iterator;
 111 import java.util.LinkedHashMap;
 112 import java.util.List;
 113 import java.util.Locale;
 114 import java.util.Map;
 115 import java.util.Map.Entry;
 116 import java.util.Objects;
 117 import java.util.Set;
 118 import java.util.TimeZone;
 119 import java.util.concurrent.ConcurrentHashMap;
 120 import java.util.concurrent.ConcurrentMap;
 121 
 122 import sun.text.spi.JavaTimeDateTimePatternProvider;
 123 import sun.util.locale.provider.CalendarDataUtility;
 124 import sun.util.locale.provider.LocaleProviderAdapter;
<span class="line-removed"> 125 import sun.util.locale.provider.LocaleResources;</span>
 126 import sun.util.locale.provider.TimeZoneNameUtility;
 127 
 128 /**
 129  * Builder to create date-time formatters.
 130  * &lt;p&gt;
 131  * This allows a {@code DateTimeFormatter} to be created.
 132  * All date-time formatters are created ultimately using this builder.
 133  * &lt;p&gt;
 134  * The basic elements of date-time can all be added:
 135  * &lt;ul&gt;
 136  * &lt;li&gt;Value - a numeric value&lt;/li&gt;
 137  * &lt;li&gt;Fraction - a fractional value including the decimal place. Always use this when
 138  * outputting fractions to ensure that the fraction is parsed correctly&lt;/li&gt;
 139  * &lt;li&gt;Text - the textual equivalent for the value&lt;/li&gt;
 140  * &lt;li&gt;OffsetId/Offset - the {@linkplain ZoneOffset zone offset}&lt;/li&gt;
 141  * &lt;li&gt;ZoneId - the {@linkplain ZoneId time-zone} id&lt;/li&gt;
 142  * &lt;li&gt;ZoneText - the name of the time-zone&lt;/li&gt;
 143  * &lt;li&gt;ChronologyId - the {@linkplain Chronology chronology} id&lt;/li&gt;
 144  * &lt;li&gt;ChronologyText - the name of the chronology&lt;/li&gt;
 145  * &lt;li&gt;Literal - a text literal&lt;/li&gt;
</pre>
<hr />
<pre>
 291      * This method allows the case sensitivity setting of parsing to be changed.
 292      * &lt;p&gt;
 293      * Calling this method changes the state of the builder such that all
 294      * subsequent builder method calls will parse text in case insensitive mode.
 295      * See {@link #parseCaseSensitive()} for the opposite setting.
 296      * The parse case sensitive/insensitive methods may be called at any point
 297      * in the builder, thus the parser can swap between case parsing modes
 298      * multiple times during the parse.
 299      *
 300      * @return this, for chaining, not null
 301      */
 302     public DateTimeFormatterBuilder parseCaseInsensitive() {
 303         appendInternal(SettingsParser.INSENSITIVE);
 304         return this;
 305     }
 306 
 307     //-----------------------------------------------------------------------
 308     /**
 309      * Changes the parse style to be strict for the remainder of the formatter.
 310      * &lt;p&gt;
<span class="line-modified"> 311      * Parsing can be strict or lenient - by default its strict.</span>
 312      * This controls the degree of flexibility in matching the text and sign styles.
 313      * &lt;p&gt;
 314      * When used, this method changes the parsing to be strict from this point onwards.
 315      * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.
 316      * The change will remain in force until the end of the formatter that is eventually
 317      * constructed or until {@code parseLenient} is called.
 318      *
 319      * @return this, for chaining, not null
 320      */
 321     public DateTimeFormatterBuilder parseStrict() {
 322         appendInternal(SettingsParser.STRICT);
 323         return this;
 324     }
 325 
 326     /**
 327      * Changes the parse style to be lenient for the remainder of the formatter.
 328      * Note that case sensitivity is set separately to this method.
 329      * &lt;p&gt;
<span class="line-modified"> 330      * Parsing can be strict or lenient - by default its strict.</span>
 331      * This controls the degree of flexibility in matching the text and sign styles.
 332      * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.
 333      * &lt;p&gt;
 334      * When used, this method changes the parsing to be lenient from this point onwards.
 335      * The change will remain in force until the end of the formatter that is eventually
 336      * constructed or until {@code parseStrict} is called.
 337      *
 338      * @return this, for chaining, not null
 339      */
 340     public DateTimeFormatterBuilder parseLenient() {
 341         appendInternal(SettingsParser.LENIENT);
 342         return this;
 343     }
 344 
 345     //-----------------------------------------------------------------------
 346     /**
 347      * Appends a default value for a field to the formatter for use in parsing.
 348      * &lt;p&gt;
 349      * This appends an instruction to the builder to inject a default value
 350      * into the parsed result. This is especially useful in conjunction with
</pre>
<hr />
<pre>
3185                 return (effectiveMin &gt; 0 ? ~position : position);
3186             }
3187             if (decimalPoint) {
3188                 if (text.charAt(position) != context.getDecimalStyle().getDecimalSeparator()) {
3189                     // valid if whole field is optional, invalid if minimum width
3190                     return (effectiveMin &gt; 0 ? ~position : position);
3191                 }
3192                 position++;
3193             }
3194             int minEndPos = position + effectiveMin;
3195             if (minEndPos &gt; length) {
3196                 return ~position;  // need at least min width digits
3197             }
3198             int maxEndPos = Math.min(position + effectiveMax, length);
3199             int total = 0;  // can use int because we are only parsing up to 9 digits
3200             int pos = position;
3201             while (pos &lt; maxEndPos) {
3202                 char ch = text.charAt(pos++);
3203                 int digit = context.getDecimalStyle().convertToDigit(ch);
3204                 if (digit &lt; 0) {
<span class="line-modified">3205                     if (pos &lt; minEndPos) {</span>
3206                         return ~position;  // need at least min width digits
3207                     }
3208                     pos--;
3209                     break;
3210                 }
3211                 total = total * 10 + digit;
3212             }
3213             BigDecimal fraction = new BigDecimal(total).movePointLeft(pos - position);
3214             long value = convertFromFraction(fraction);
3215             return context.setParsedField(field, value, position, pos);
3216         }
3217 
3218         /**
3219          * Converts a value for this field to a fraction between 0 and 1.
3220          * &lt;p&gt;
3221          * The fractional value is between 0 (inclusive) and 1 (exclusive).
3222          * It can only be returned if the {@link java.time.temporal.TemporalField#range() value range} is fixed.
3223          * The fraction is obtained by calculation from the field range using 9 decimal
3224          * places and a rounding mode of {@link RoundingMode#FLOOR FLOOR}.
3225          * The calculation is inaccurate if the values do not run continuously from smallest to largest.
</pre>
<hr />
<pre>
3854         /**
3855          * Constructor.
3856          *
3857          * @param style  the style, not null
3858          */
3859         LocalizedOffsetIdPrinterParser(TextStyle style) {
3860             this.style = style;
3861         }
3862 
3863         private static StringBuilder appendHMS(StringBuilder buf, int t) {
3864             return buf.append((char)(t / 10 + &#39;0&#39;))
3865                       .append((char)(t % 10 + &#39;0&#39;));
3866         }
3867 
3868         @Override
3869         public boolean format(DateTimePrintContext context, StringBuilder buf) {
3870             Long offsetSecs = context.getValue(OFFSET_SECONDS);
3871             if (offsetSecs == null) {
3872                 return false;
3873             }
<span class="line-modified">3874             String gmtText = &quot;GMT&quot;;  // TODO: get localized version of &#39;GMT&#39;</span>




3875             buf.append(gmtText);
3876             int totalSecs = Math.toIntExact(offsetSecs);
3877             if (totalSecs != 0) {
3878                 int absHours = Math.abs((totalSecs / 3600) % 100);  // anything larger than 99 silently dropped
3879                 int absMinutes = Math.abs((totalSecs / 60) % 60);
3880                 int absSeconds = Math.abs(totalSecs % 60);
3881                 buf.append(totalSecs &lt; 0 ? &quot;-&quot; : &quot;+&quot;);
3882                 if (style == TextStyle.FULL) {
3883                     appendHMS(buf, absHours);
3884                     buf.append(&#39;:&#39;);
3885                     appendHMS(buf, absMinutes);
3886                     if (absSeconds != 0) {
3887                        buf.append(&#39;:&#39;);
3888                        appendHMS(buf, absSeconds);
3889                     }
3890                 } else {
3891                     if (absHours &gt;= 10) {
3892                         buf.append((char)(absHours / 10 + &#39;0&#39;));
3893                     }
3894                     buf.append((char)(absHours % 10 + &#39;0&#39;));
</pre>
<hr />
<pre>
3900                             appendHMS(buf, absSeconds);
3901                         }
3902                     }
3903                 }
3904             }
3905             return true;
3906         }
3907 
3908         int getDigit(CharSequence text, int position) {
3909             char c = text.charAt(position);
3910             if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
3911                 return -1;
3912             }
3913             return c - &#39;0&#39;;
3914         }
3915 
3916         @Override
3917         public int parse(DateTimeParseContext context, CharSequence text, int position) {
3918             int pos = position;
3919             int end = text.length();
<span class="line-modified">3920             String gmtText = &quot;GMT&quot;;  // TODO: get localized version of &#39;GMT&#39;</span>




3921             if (!context.subSequenceEquals(text, pos, gmtText, 0, gmtText.length())) {
3922                     return ~position;
3923                 }
3924             pos += gmtText.length();
3925             // parse normal plus/minus offset
3926             int negative = 0;
3927             if (pos == end) {
3928                 return context.setParsedField(OFFSET_SECONDS, 0, position, pos);
3929             }
3930             char sign = text.charAt(pos);  // IOOBE if invalid position
3931             if (sign == &#39;+&#39;) {
3932                 negative = 1;
3933             } else if (sign == &#39;-&#39;) {
3934                 negative = -1;
3935             } else {
3936                 return context.setParsedField(OFFSET_SECONDS, 0, position, pos);
3937             }
3938             pos++;
3939             int h = 0;
3940             int m = 0;
</pre>
<hr />
<pre>
4100                     zname = name;
4101                 }
4102             }
4103             buf.append(zname);
4104             return true;
4105         }
4106 
4107         // cache per instance for now
4108         private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;
4109             cachedTree = new HashMap&lt;&gt;();
4110         private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;
4111             cachedTreeCI = new HashMap&lt;&gt;();
4112 
4113         @Override
4114         protected PrefixTree getTree(DateTimeParseContext context) {
4115             if (textStyle == TextStyle.NARROW) {
4116                 return super.getTree(context);
4117             }
4118             Locale locale = context.getLocale();
4119             boolean isCaseSensitive = context.isCaseSensitive();
<span class="line-modified">4120             Set&lt;String&gt; regionIds = ZoneRulesProvider.getAvailableZoneIds();</span>

4121             int regionIdsSize = regionIds.size();
4122 
4123             Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt; cached =
4124                 isCaseSensitive ? cachedTree : cachedTreeCI;
4125 
4126             Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt; entry = null;
4127             PrefixTree tree = null;
4128             String[][] zoneStrings = null;
4129             if ((entry = cached.get(locale)) == null ||
4130                 (entry.getKey() != regionIdsSize ||
4131                 (tree = entry.getValue().get()) == null)) {
4132                 tree = PrefixTree.newTree(context);
4133                 zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
4134                 for (String[] names : zoneStrings) {
4135                     String zid = names[0];
<span class="line-modified">4136                     if (!regionIds.contains(zid)) {</span>

4137                         continue;
4138                     }
4139                     tree.add(zid, zid);    // don&#39;t convert zid -&gt; metazone
4140                     zid = ZoneName.toZid(zid, locale);
4141                     int i = textStyle == TextStyle.FULL ? 1 : 2;
4142                     for (; i &lt; names.length; i += 2) {
4143                         tree.add(names[i], zid);
4144                     }
4145                 }















4146                 // if we have a set of preferred zones, need a copy and
4147                 // add the preferred zones again to overwrite
4148                 if (preferredZones != null) {
4149                     for (String[] names : zoneStrings) {
4150                         String zid = names[0];
<span class="line-modified">4151                         if (!preferredZones.contains(zid) || !regionIds.contains(zid)) {</span>
4152                             continue;
4153                         }
4154                         int i = textStyle == TextStyle.FULL ? 1 : 2;
4155                         for (; i &lt; names.length; i += 2) {
4156                             tree.add(names[i], zid);
4157                        }
4158                     }
4159                 }
4160                 cached.put(locale, new SimpleImmutableEntry&lt;&gt;(regionIdsSize, new SoftReference&lt;&gt;(tree)));
4161             }
4162             return tree;
4163         }
4164     }
4165 
4166     //-----------------------------------------------------------------------
4167     /**
4168      * Prints or parses a zone ID.
4169      */
4170     static class ZoneIdPrinterParser implements DateTimePrinterParser {
4171         private final TemporalQuery&lt;ZoneId&gt; query;
</pre>
<hr />
<pre>
4220          * Etc/GMC although both are valid.
4221          */
4222         @Override
4223         public int parse(DateTimeParseContext context, CharSequence text, int position) {
4224             int length = text.length();
4225             if (position &gt; length) {
4226                 throw new IndexOutOfBoundsException();
4227             }
4228             if (position == length) {
4229                 return ~position;
4230             }
4231 
4232             // handle fixed time-zone IDs
4233             char nextChar = text.charAt(position);
4234             if (nextChar == &#39;+&#39; || nextChar == &#39;-&#39;) {
4235                 return parseOffsetBased(context, text, position, position, OffsetIdPrinterParser.INSTANCE_ID_Z);
4236             } else if (length &gt;= position + 2) {
4237                 char nextNextChar = text.charAt(position + 1);
4238                 if (context.charEquals(nextChar, &#39;U&#39;) &amp;&amp; context.charEquals(nextNextChar, &#39;T&#39;)) {
4239                     if (length &gt;= position + 3 &amp;&amp; context.charEquals(text.charAt(position + 2), &#39;C&#39;)) {
<span class="line-modified">4240                         return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>







4241                     }
<span class="line-removed">4242                     return parseOffsetBased(context, text, position, position + 2, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>
4243                 } else if (context.charEquals(nextChar, &#39;G&#39;) &amp;&amp; length &gt;= position + 3 &amp;&amp;
4244                         context.charEquals(nextNextChar, &#39;M&#39;) &amp;&amp; context.charEquals(text.charAt(position + 2), &#39;T&#39;)) {
4245                     if (length &gt;= position + 4 &amp;&amp; context.charEquals(text.charAt(position + 3), &#39;0&#39;)) {
4246                         context.setParsed(ZoneId.of(&quot;GMT0&quot;));
4247                         return position + 4;
4248                     }
4249                     return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);
4250                 }
4251             }
4252 
4253             // parse
4254             PrefixTree tree = getTree(context);
4255             ParsePosition ppos = new ParsePosition(position);
4256             String parsedZoneId = tree.match(text, ppos);
4257             if (parsedZoneId == null) {
4258                 if (context.charEquals(nextChar, &#39;Z&#39;)) {
4259                     context.setParsed(ZoneOffset.UTC);
4260                     return position + 1;
4261                 }
4262                 return ~position;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  68 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  69 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  70 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
  71 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
  72 import static java.time.temporal.ChronoField.YEAR;
  73 import static java.time.temporal.ChronoField.ERA;
  74 
  75 import java.lang.ref.SoftReference;
  76 import java.math.BigDecimal;
  77 import java.math.BigInteger;
  78 import java.math.RoundingMode;
  79 import java.text.ParsePosition;
  80 import java.time.DateTimeException;
  81 import java.time.Instant;
  82 import java.time.LocalDate;
  83 import java.time.LocalDateTime;
  84 import java.time.LocalTime;
  85 import java.time.ZoneId;
  86 import java.time.ZoneOffset;
  87 import java.time.chrono.ChronoLocalDate;

  88 import java.time.chrono.Chronology;
  89 import java.time.chrono.Era;
  90 import java.time.chrono.IsoChronology;
  91 import java.time.format.DateTimeTextProvider.LocaleStore;
  92 import java.time.temporal.ChronoField;
  93 import java.time.temporal.IsoFields;
  94 import java.time.temporal.JulianFields;
  95 import java.time.temporal.TemporalAccessor;
  96 import java.time.temporal.TemporalField;
  97 import java.time.temporal.TemporalQueries;
  98 import java.time.temporal.TemporalQuery;
  99 import java.time.temporal.ValueRange;
 100 import java.time.temporal.WeekFields;
 101 import java.time.zone.ZoneRulesProvider;
 102 import java.util.AbstractMap.SimpleImmutableEntry;
 103 import java.util.ArrayList;
 104 import java.util.Arrays;
 105 import java.util.Collections;
 106 import java.util.Comparator;
 107 import java.util.HashMap;
 108 import java.util.HashSet;
 109 import java.util.Iterator;
 110 import java.util.LinkedHashMap;
 111 import java.util.List;
 112 import java.util.Locale;
 113 import java.util.Map;
 114 import java.util.Map.Entry;
 115 import java.util.Objects;
 116 import java.util.Set;
 117 import java.util.TimeZone;
 118 import java.util.concurrent.ConcurrentHashMap;
 119 import java.util.concurrent.ConcurrentMap;
 120 
 121 import sun.text.spi.JavaTimeDateTimePatternProvider;
 122 import sun.util.locale.provider.CalendarDataUtility;
 123 import sun.util.locale.provider.LocaleProviderAdapter;

 124 import sun.util.locale.provider.TimeZoneNameUtility;
 125 
 126 /**
 127  * Builder to create date-time formatters.
 128  * &lt;p&gt;
 129  * This allows a {@code DateTimeFormatter} to be created.
 130  * All date-time formatters are created ultimately using this builder.
 131  * &lt;p&gt;
 132  * The basic elements of date-time can all be added:
 133  * &lt;ul&gt;
 134  * &lt;li&gt;Value - a numeric value&lt;/li&gt;
 135  * &lt;li&gt;Fraction - a fractional value including the decimal place. Always use this when
 136  * outputting fractions to ensure that the fraction is parsed correctly&lt;/li&gt;
 137  * &lt;li&gt;Text - the textual equivalent for the value&lt;/li&gt;
 138  * &lt;li&gt;OffsetId/Offset - the {@linkplain ZoneOffset zone offset}&lt;/li&gt;
 139  * &lt;li&gt;ZoneId - the {@linkplain ZoneId time-zone} id&lt;/li&gt;
 140  * &lt;li&gt;ZoneText - the name of the time-zone&lt;/li&gt;
 141  * &lt;li&gt;ChronologyId - the {@linkplain Chronology chronology} id&lt;/li&gt;
 142  * &lt;li&gt;ChronologyText - the name of the chronology&lt;/li&gt;
 143  * &lt;li&gt;Literal - a text literal&lt;/li&gt;
</pre>
<hr />
<pre>
 289      * This method allows the case sensitivity setting of parsing to be changed.
 290      * &lt;p&gt;
 291      * Calling this method changes the state of the builder such that all
 292      * subsequent builder method calls will parse text in case insensitive mode.
 293      * See {@link #parseCaseSensitive()} for the opposite setting.
 294      * The parse case sensitive/insensitive methods may be called at any point
 295      * in the builder, thus the parser can swap between case parsing modes
 296      * multiple times during the parse.
 297      *
 298      * @return this, for chaining, not null
 299      */
 300     public DateTimeFormatterBuilder parseCaseInsensitive() {
 301         appendInternal(SettingsParser.INSENSITIVE);
 302         return this;
 303     }
 304 
 305     //-----------------------------------------------------------------------
 306     /**
 307      * Changes the parse style to be strict for the remainder of the formatter.
 308      * &lt;p&gt;
<span class="line-modified"> 309      * Parsing can be strict or lenient - by default it is strict.</span>
 310      * This controls the degree of flexibility in matching the text and sign styles.
 311      * &lt;p&gt;
 312      * When used, this method changes the parsing to be strict from this point onwards.
 313      * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.
 314      * The change will remain in force until the end of the formatter that is eventually
 315      * constructed or until {@code parseLenient} is called.
 316      *
 317      * @return this, for chaining, not null
 318      */
 319     public DateTimeFormatterBuilder parseStrict() {
 320         appendInternal(SettingsParser.STRICT);
 321         return this;
 322     }
 323 
 324     /**
 325      * Changes the parse style to be lenient for the remainder of the formatter.
 326      * Note that case sensitivity is set separately to this method.
 327      * &lt;p&gt;
<span class="line-modified"> 328      * Parsing can be strict or lenient - by default it is strict.</span>
 329      * This controls the degree of flexibility in matching the text and sign styles.
 330      * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.
 331      * &lt;p&gt;
 332      * When used, this method changes the parsing to be lenient from this point onwards.
 333      * The change will remain in force until the end of the formatter that is eventually
 334      * constructed or until {@code parseStrict} is called.
 335      *
 336      * @return this, for chaining, not null
 337      */
 338     public DateTimeFormatterBuilder parseLenient() {
 339         appendInternal(SettingsParser.LENIENT);
 340         return this;
 341     }
 342 
 343     //-----------------------------------------------------------------------
 344     /**
 345      * Appends a default value for a field to the formatter for use in parsing.
 346      * &lt;p&gt;
 347      * This appends an instruction to the builder to inject a default value
 348      * into the parsed result. This is especially useful in conjunction with
</pre>
<hr />
<pre>
3183                 return (effectiveMin &gt; 0 ? ~position : position);
3184             }
3185             if (decimalPoint) {
3186                 if (text.charAt(position) != context.getDecimalStyle().getDecimalSeparator()) {
3187                     // valid if whole field is optional, invalid if minimum width
3188                     return (effectiveMin &gt; 0 ? ~position : position);
3189                 }
3190                 position++;
3191             }
3192             int minEndPos = position + effectiveMin;
3193             if (minEndPos &gt; length) {
3194                 return ~position;  // need at least min width digits
3195             }
3196             int maxEndPos = Math.min(position + effectiveMax, length);
3197             int total = 0;  // can use int because we are only parsing up to 9 digits
3198             int pos = position;
3199             while (pos &lt; maxEndPos) {
3200                 char ch = text.charAt(pos++);
3201                 int digit = context.getDecimalStyle().convertToDigit(ch);
3202                 if (digit &lt; 0) {
<span class="line-modified">3203                     if (pos &lt;= minEndPos) {</span>
3204                         return ~position;  // need at least min width digits
3205                     }
3206                     pos--;
3207                     break;
3208                 }
3209                 total = total * 10 + digit;
3210             }
3211             BigDecimal fraction = new BigDecimal(total).movePointLeft(pos - position);
3212             long value = convertFromFraction(fraction);
3213             return context.setParsedField(field, value, position, pos);
3214         }
3215 
3216         /**
3217          * Converts a value for this field to a fraction between 0 and 1.
3218          * &lt;p&gt;
3219          * The fractional value is between 0 (inclusive) and 1 (exclusive).
3220          * It can only be returned if the {@link java.time.temporal.TemporalField#range() value range} is fixed.
3221          * The fraction is obtained by calculation from the field range using 9 decimal
3222          * places and a rounding mode of {@link RoundingMode#FLOOR FLOOR}.
3223          * The calculation is inaccurate if the values do not run continuously from smallest to largest.
</pre>
<hr />
<pre>
3852         /**
3853          * Constructor.
3854          *
3855          * @param style  the style, not null
3856          */
3857         LocalizedOffsetIdPrinterParser(TextStyle style) {
3858             this.style = style;
3859         }
3860 
3861         private static StringBuilder appendHMS(StringBuilder buf, int t) {
3862             return buf.append((char)(t / 10 + &#39;0&#39;))
3863                       .append((char)(t % 10 + &#39;0&#39;));
3864         }
3865 
3866         @Override
3867         public boolean format(DateTimePrintContext context, StringBuilder buf) {
3868             Long offsetSecs = context.getValue(OFFSET_SECONDS);
3869             if (offsetSecs == null) {
3870                 return false;
3871             }
<span class="line-modified">3872             String key = &quot;timezone.gmtZeroFormat&quot;;</span>
<span class="line-added">3873             String gmtText = DateTimeTextProvider.getLocalizedResource(key, context.getLocale());</span>
<span class="line-added">3874             if (gmtText == null) {</span>
<span class="line-added">3875                 gmtText = &quot;GMT&quot;;  // Default to &quot;GMT&quot;</span>
<span class="line-added">3876             }</span>
3877             buf.append(gmtText);
3878             int totalSecs = Math.toIntExact(offsetSecs);
3879             if (totalSecs != 0) {
3880                 int absHours = Math.abs((totalSecs / 3600) % 100);  // anything larger than 99 silently dropped
3881                 int absMinutes = Math.abs((totalSecs / 60) % 60);
3882                 int absSeconds = Math.abs(totalSecs % 60);
3883                 buf.append(totalSecs &lt; 0 ? &quot;-&quot; : &quot;+&quot;);
3884                 if (style == TextStyle.FULL) {
3885                     appendHMS(buf, absHours);
3886                     buf.append(&#39;:&#39;);
3887                     appendHMS(buf, absMinutes);
3888                     if (absSeconds != 0) {
3889                        buf.append(&#39;:&#39;);
3890                        appendHMS(buf, absSeconds);
3891                     }
3892                 } else {
3893                     if (absHours &gt;= 10) {
3894                         buf.append((char)(absHours / 10 + &#39;0&#39;));
3895                     }
3896                     buf.append((char)(absHours % 10 + &#39;0&#39;));
</pre>
<hr />
<pre>
3902                             appendHMS(buf, absSeconds);
3903                         }
3904                     }
3905                 }
3906             }
3907             return true;
3908         }
3909 
3910         int getDigit(CharSequence text, int position) {
3911             char c = text.charAt(position);
3912             if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
3913                 return -1;
3914             }
3915             return c - &#39;0&#39;;
3916         }
3917 
3918         @Override
3919         public int parse(DateTimeParseContext context, CharSequence text, int position) {
3920             int pos = position;
3921             int end = text.length();
<span class="line-modified">3922             String key = &quot;timezone.gmtZeroFormat&quot;;</span>
<span class="line-added">3923             String gmtText = DateTimeTextProvider.getLocalizedResource(key, context.getLocale());</span>
<span class="line-added">3924             if (gmtText == null) {</span>
<span class="line-added">3925                 gmtText = &quot;GMT&quot;;  // Default to &quot;GMT&quot;</span>
<span class="line-added">3926             }</span>
3927             if (!context.subSequenceEquals(text, pos, gmtText, 0, gmtText.length())) {
3928                     return ~position;
3929                 }
3930             pos += gmtText.length();
3931             // parse normal plus/minus offset
3932             int negative = 0;
3933             if (pos == end) {
3934                 return context.setParsedField(OFFSET_SECONDS, 0, position, pos);
3935             }
3936             char sign = text.charAt(pos);  // IOOBE if invalid position
3937             if (sign == &#39;+&#39;) {
3938                 negative = 1;
3939             } else if (sign == &#39;-&#39;) {
3940                 negative = -1;
3941             } else {
3942                 return context.setParsedField(OFFSET_SECONDS, 0, position, pos);
3943             }
3944             pos++;
3945             int h = 0;
3946             int m = 0;
</pre>
<hr />
<pre>
4106                     zname = name;
4107                 }
4108             }
4109             buf.append(zname);
4110             return true;
4111         }
4112 
4113         // cache per instance for now
4114         private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;
4115             cachedTree = new HashMap&lt;&gt;();
4116         private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;
4117             cachedTreeCI = new HashMap&lt;&gt;();
4118 
4119         @Override
4120         protected PrefixTree getTree(DateTimeParseContext context) {
4121             if (textStyle == TextStyle.NARROW) {
4122                 return super.getTree(context);
4123             }
4124             Locale locale = context.getLocale();
4125             boolean isCaseSensitive = context.isCaseSensitive();
<span class="line-modified">4126             Set&lt;String&gt; regionIds = new HashSet&lt;&gt;(ZoneRulesProvider.getAvailableZoneIds());</span>
<span class="line-added">4127             Set&lt;String&gt; nonRegionIds = new HashSet&lt;&gt;(64);</span>
4128             int regionIdsSize = regionIds.size();
4129 
4130             Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt; cached =
4131                 isCaseSensitive ? cachedTree : cachedTreeCI;
4132 
4133             Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt; entry = null;
4134             PrefixTree tree = null;
4135             String[][] zoneStrings = null;
4136             if ((entry = cached.get(locale)) == null ||
4137                 (entry.getKey() != regionIdsSize ||
4138                 (tree = entry.getValue().get()) == null)) {
4139                 tree = PrefixTree.newTree(context);
4140                 zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
4141                 for (String[] names : zoneStrings) {
4142                     String zid = names[0];
<span class="line-modified">4143                     if (!regionIds.remove(zid)) {</span>
<span class="line-added">4144                         nonRegionIds.add(zid);</span>
4145                         continue;
4146                     }
4147                     tree.add(zid, zid);    // don&#39;t convert zid -&gt; metazone
4148                     zid = ZoneName.toZid(zid, locale);
4149                     int i = textStyle == TextStyle.FULL ? 1 : 2;
4150                     for (; i &lt; names.length; i += 2) {
4151                         tree.add(names[i], zid);
4152                     }
4153                 }
<span class="line-added">4154 </span>
<span class="line-added">4155                 // add names for provider&#39;s custom ids</span>
<span class="line-added">4156                 final PrefixTree t = tree;</span>
<span class="line-added">4157                 regionIds.stream()</span>
<span class="line-added">4158                     .filter(zid -&gt; !zid.startsWith(&quot;Etc&quot;) &amp;&amp; !zid.startsWith(&quot;GMT&quot;))</span>
<span class="line-added">4159                     .forEach(cid -&gt; {</span>
<span class="line-added">4160                         String[] cidNames = TimeZoneNameUtility.retrieveDisplayNames(cid, locale);</span>
<span class="line-added">4161                         int i = textStyle == TextStyle.FULL ? 1 : 2;</span>
<span class="line-added">4162                         for (; i &lt; cidNames.length; i += 2) {</span>
<span class="line-added">4163                             if (cidNames[i] != null &amp;&amp; !cidNames[i].isEmpty()) {</span>
<span class="line-added">4164                                 t.add(cidNames[i], cid);</span>
<span class="line-added">4165                             }</span>
<span class="line-added">4166                         }</span>
<span class="line-added">4167                     });</span>
<span class="line-added">4168 </span>
4169                 // if we have a set of preferred zones, need a copy and
4170                 // add the preferred zones again to overwrite
4171                 if (preferredZones != null) {
4172                     for (String[] names : zoneStrings) {
4173                         String zid = names[0];
<span class="line-modified">4174                         if (!preferredZones.contains(zid) || nonRegionIds.contains(zid)) {</span>
4175                             continue;
4176                         }
4177                         int i = textStyle == TextStyle.FULL ? 1 : 2;
4178                         for (; i &lt; names.length; i += 2) {
4179                             tree.add(names[i], zid);
4180                        }
4181                     }
4182                 }
4183                 cached.put(locale, new SimpleImmutableEntry&lt;&gt;(regionIdsSize, new SoftReference&lt;&gt;(tree)));
4184             }
4185             return tree;
4186         }
4187     }
4188 
4189     //-----------------------------------------------------------------------
4190     /**
4191      * Prints or parses a zone ID.
4192      */
4193     static class ZoneIdPrinterParser implements DateTimePrinterParser {
4194         private final TemporalQuery&lt;ZoneId&gt; query;
</pre>
<hr />
<pre>
4243          * Etc/GMC although both are valid.
4244          */
4245         @Override
4246         public int parse(DateTimeParseContext context, CharSequence text, int position) {
4247             int length = text.length();
4248             if (position &gt; length) {
4249                 throw new IndexOutOfBoundsException();
4250             }
4251             if (position == length) {
4252                 return ~position;
4253             }
4254 
4255             // handle fixed time-zone IDs
4256             char nextChar = text.charAt(position);
4257             if (nextChar == &#39;+&#39; || nextChar == &#39;-&#39;) {
4258                 return parseOffsetBased(context, text, position, position, OffsetIdPrinterParser.INSTANCE_ID_Z);
4259             } else if (length &gt;= position + 2) {
4260                 char nextNextChar = text.charAt(position + 1);
4261                 if (context.charEquals(nextChar, &#39;U&#39;) &amp;&amp; context.charEquals(nextNextChar, &#39;T&#39;)) {
4262                     if (length &gt;= position + 3 &amp;&amp; context.charEquals(text.charAt(position + 2), &#39;C&#39;)) {
<span class="line-modified">4263                         // There are localized zone texts that start with &quot;UTC&quot;, e.g.</span>
<span class="line-added">4264                         // &quot;UTC\u221210:00&quot; (MINUS SIGN instead of HYPHEN-MINUS) in French.</span>
<span class="line-added">4265                         // Exclude those ZoneText cases.</span>
<span class="line-added">4266                         if (!(this instanceof ZoneTextPrinterParser)) {</span>
<span class="line-added">4267                             return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>
<span class="line-added">4268                         }</span>
<span class="line-added">4269                     } else {</span>
<span class="line-added">4270                         return parseOffsetBased(context, text, position, position + 2, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>
4271                     }

4272                 } else if (context.charEquals(nextChar, &#39;G&#39;) &amp;&amp; length &gt;= position + 3 &amp;&amp;
4273                         context.charEquals(nextNextChar, &#39;M&#39;) &amp;&amp; context.charEquals(text.charAt(position + 2), &#39;T&#39;)) {
4274                     if (length &gt;= position + 4 &amp;&amp; context.charEquals(text.charAt(position + 3), &#39;0&#39;)) {
4275                         context.setParsed(ZoneId.of(&quot;GMT0&quot;));
4276                         return position + 4;
4277                     }
4278                     return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);
4279                 }
4280             }
4281 
4282             // parse
4283             PrefixTree tree = getTree(context);
4284             ParsePosition ppos = new ParsePosition(position);
4285             String parsedZoneId = tree.match(text, ppos);
4286             if (parsedZoneId == null) {
4287                 if (context.charEquals(nextChar, &#39;Z&#39;)) {
4288                     context.setParsed(ZoneOffset.UTC);
4289                     return position + 1;
4290                 }
4291                 return ~position;
</pre>
</td>
</tr>
</table>
<center><a href="DateTimeFormatter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DateTimeParseException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
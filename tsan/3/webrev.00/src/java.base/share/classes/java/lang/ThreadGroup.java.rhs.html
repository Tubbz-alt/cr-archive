<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/ThreadGroup.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.io.PrintStream;
  29 import java.util.Arrays;
  30 
  31 /**
  32  * A thread group represents a set of threads. In addition, a thread
  33  * group can also include other thread groups. The thread groups form
  34  * a tree in which every thread group except the initial thread group
  35  * has a parent.
  36  * &lt;p&gt;
  37  * A thread is allowed to access information about its own thread
  38  * group, but not to access information about its thread group&#39;s
  39  * parent thread group or any other thread groups.
  40  *
  41  * @author  unascribed
  42  * @since   1.0
  43  */
  44 /* The locking strategy for this code is to try to lock only one level of the
  45  * tree wherever possible, but otherwise to lock from the bottom up.
  46  * That is, from child thread groups to parents.
  47  * This has the advantage of limiting the number of locks that need to be held
  48  * and in particular avoids having to grab the lock for the root thread group,
  49  * (or a global lock) which would be a source of contention on a
  50  * multi-processor system with many thread groups.
  51  * This policy often leads to taking a snapshot of the state of a thread group
  52  * and working off of that snapshot, rather than holding the thread group locked
  53  * while we work on the children.
  54  */
<a name="1" id="anc1"></a><span class="line-modified">  55 public class ThreadGroup implements Thread.UncaughtExceptionHandler {</span>

  56     private final ThreadGroup parent;
  57     String name;
  58     int maxPriority;
  59     boolean destroyed;
  60     boolean daemon;
  61 
  62     int nUnstartedThreads = 0;
  63     int nthreads;
  64     Thread threads[];
  65 
  66     int ngroups;
  67     ThreadGroup groups[];
  68 
  69     /**
  70      * Creates an empty Thread group that is not in any Thread group.
  71      * This method is used to create the system Thread group.
  72      */
  73     private ThreadGroup() {     // called from C code
  74         this.name = &quot;system&quot;;
  75         this.maxPriority = Thread.MAX_PRIORITY;
  76         this.parent = null;
  77     }
  78 
  79     /**
  80      * Constructs a new thread group. The parent of this new group is
  81      * the thread group of the currently running thread.
  82      * &lt;p&gt;
  83      * The {@code checkAccess} method of the parent thread group is
  84      * called with no arguments; this may result in a security exception.
  85      *
  86      * @param   name   the name of the new thread group.
  87      * @throws  SecurityException  if the current thread cannot create a
  88      *               thread in the specified thread group.
  89      * @see     java.lang.ThreadGroup#checkAccess()
  90      * @since   1.0
  91      */
  92     public ThreadGroup(String name) {
  93         this(Thread.currentThread().getThreadGroup(), name);
  94     }
  95 
  96     /**
  97      * Creates a new thread group. The parent of this new group is the
  98      * specified thread group.
  99      * &lt;p&gt;
 100      * The {@code checkAccess} method of the parent thread group is
 101      * called with no arguments; this may result in a security exception.
 102      *
 103      * @param     parent   the parent thread group.
 104      * @param     name     the name of the new thread group.
 105      * @throws    NullPointerException  if the thread group argument is
 106      *               {@code null}.
 107      * @throws    SecurityException  if the current thread cannot create a
 108      *               thread in the specified thread group.
 109      * @see     java.lang.SecurityException
 110      * @see     java.lang.ThreadGroup#checkAccess()
 111      * @since   1.0
 112      */
 113     public ThreadGroup(ThreadGroup parent, String name) {
 114         this(checkParentAccess(parent), parent, name);
 115     }
 116 
 117     private ThreadGroup(Void unused, ThreadGroup parent, String name) {
 118         this.name = name;
 119         this.maxPriority = parent.maxPriority;
 120         this.daemon = parent.daemon;
 121         this.parent = parent;
 122         parent.add(this);
 123     }
 124 
 125     /*
 126      * @throws  NullPointerException  if the parent argument is {@code null}
 127      * @throws  SecurityException     if the current thread cannot create a
 128      *                                thread in the specified thread group.
 129      */
 130     private static Void checkParentAccess(ThreadGroup parent) {
 131         parent.checkAccess();
 132         return null;
 133     }
 134 
 135     /**
 136      * Returns the name of this thread group.
 137      *
 138      * @return  the name of this thread group.
 139      * @since   1.0
 140      */
 141     public final String getName() {
 142         return name;
 143     }
 144 
 145     /**
 146      * Returns the parent of this thread group.
 147      * &lt;p&gt;
 148      * First, if the parent is not {@code null}, the
 149      * {@code checkAccess} method of the parent thread group is
 150      * called with no arguments; this may result in a security exception.
 151      *
 152      * @return  the parent of this thread group. The top-level thread group
 153      *          is the only thread group whose parent is {@code null}.
 154      * @throws  SecurityException  if the current thread cannot modify
 155      *               this thread group.
 156      * @see        java.lang.ThreadGroup#checkAccess()
 157      * @see        java.lang.SecurityException
 158      * @see        java.lang.RuntimePermission
 159      * @since   1.0
 160      */
 161     public final ThreadGroup getParent() {
 162         if (parent != null)
 163             parent.checkAccess();
 164         return parent;
 165     }
 166 
 167     /**
 168      * Returns the maximum priority of this thread group. Threads that are
 169      * part of this group cannot have a higher priority than the maximum
 170      * priority.
 171      *
 172      * @return  the maximum priority that a thread in this thread group
 173      *          can have.
 174      * @see     #setMaxPriority
 175      * @since   1.0
 176      */
 177     public final int getMaxPriority() {
 178         return maxPriority;
 179     }
 180 
 181     /**
 182      * Tests if this thread group is a daemon thread group. A
 183      * daemon thread group is automatically destroyed when its last
 184      * thread is stopped or its last thread group is destroyed.
 185      *
 186      * @return  {@code true} if this thread group is a daemon thread group;
 187      *          {@code false} otherwise.
 188      * @since   1.0
 189      */
 190     public final boolean isDaemon() {
 191         return daemon;
 192     }
 193 
 194     /**
 195      * Tests if this thread group has been destroyed.
 196      *
 197      * @return  true if this object is destroyed
 198      * @since   1.1
 199      */
 200     public synchronized boolean isDestroyed() {
 201         return destroyed;
 202     }
 203 
 204     /**
 205      * Changes the daemon status of this thread group.
 206      * &lt;p&gt;
 207      * First, the {@code checkAccess} method of this thread group is
 208      * called with no arguments; this may result in a security exception.
 209      * &lt;p&gt;
 210      * A daemon thread group is automatically destroyed when its last
 211      * thread is stopped or its last thread group is destroyed.
 212      *
 213      * @param      daemon   if {@code true}, marks this thread group as
 214      *                      a daemon thread group; otherwise, marks this
 215      *                      thread group as normal.
 216      * @throws     SecurityException  if the current thread cannot modify
 217      *               this thread group.
 218      * @see        java.lang.SecurityException
 219      * @see        java.lang.ThreadGroup#checkAccess()
 220      * @since      1.0
 221      */
 222     public final void setDaemon(boolean daemon) {
 223         checkAccess();
 224         this.daemon = daemon;
 225     }
 226 
 227     /**
 228      * Sets the maximum priority of the group. Threads in the thread
 229      * group that already have a higher priority are not affected.
 230      * &lt;p&gt;
 231      * First, the {@code checkAccess} method of this thread group is
 232      * called with no arguments; this may result in a security exception.
 233      * &lt;p&gt;
 234      * If the {@code pri} argument is less than
 235      * {@link Thread#MIN_PRIORITY} or greater than
 236      * {@link Thread#MAX_PRIORITY}, the maximum priority of the group
 237      * remains unchanged.
 238      * &lt;p&gt;
 239      * Otherwise, the priority of this ThreadGroup object is set to the
 240      * smaller of the specified {@code pri} and the maximum permitted
 241      * priority of the parent of this thread group. (If this thread group
 242      * is the system thread group, which has no parent, then its maximum
 243      * priority is simply set to {@code pri}.) Then this method is
 244      * called recursively, with {@code pri} as its argument, for
 245      * every thread group that belongs to this thread group.
 246      *
 247      * @param      pri   the new priority of the thread group.
 248      * @throws     SecurityException  if the current thread cannot modify
 249      *               this thread group.
 250      * @see        #getMaxPriority
 251      * @see        java.lang.SecurityException
 252      * @see        java.lang.ThreadGroup#checkAccess()
 253      * @since      1.0
 254      */
 255     public final void setMaxPriority(int pri) {
 256         int ngroupsSnapshot;
 257         ThreadGroup[] groupsSnapshot;
 258         synchronized (this) {
 259             checkAccess();
 260             if (pri &lt; Thread.MIN_PRIORITY || pri &gt; Thread.MAX_PRIORITY) {
 261                 return;
 262             }
 263             maxPriority = (parent != null) ? Math.min(pri, parent.maxPriority) : pri;
 264             ngroupsSnapshot = ngroups;
 265             if (groups != null) {
 266                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 267             } else {
 268                 groupsSnapshot = null;
 269             }
 270         }
 271         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 272             groupsSnapshot[i].setMaxPriority(pri);
 273         }
 274     }
 275 
 276     /**
 277      * Tests if this thread group is either the thread group
 278      * argument or one of its ancestor thread groups.
 279      *
 280      * @param   g   a thread group.
 281      * @return  {@code true} if this thread group is the thread group
 282      *          argument or one of its ancestor thread groups;
 283      *          {@code false} otherwise.
 284      * @since   1.0
 285      */
 286     public final boolean parentOf(ThreadGroup g) {
 287         for (; g != null ; g = g.parent) {
 288             if (g == this) {
 289                 return true;
 290             }
 291         }
 292         return false;
 293     }
 294 
 295     /**
 296      * Determines if the currently running thread has permission to
 297      * modify this thread group.
 298      * &lt;p&gt;
 299      * If there is a security manager, its {@code checkAccess} method
 300      * is called with this thread group as its argument. This may result
 301      * in throwing a {@code SecurityException}.
 302      *
 303      * @throws     SecurityException  if the current thread is not allowed to
 304      *               access this thread group.
 305      * @see        java.lang.SecurityManager#checkAccess(java.lang.ThreadGroup)
 306      * @since      1.0
 307      */
 308     public final void checkAccess() {
 309         SecurityManager security = System.getSecurityManager();
 310         if (security != null) {
 311             security.checkAccess(this);
 312         }
 313     }
 314 
 315     /**
 316      * Returns an estimate of the number of active threads in this thread
 317      * group and its subgroups. Recursively iterates over all subgroups in
 318      * this thread group.
 319      *
 320      * &lt;p&gt; The value returned is only an estimate because the number of
 321      * threads may change dynamically while this method traverses internal
 322      * data structures, and might be affected by the presence of certain
 323      * system threads. This method is intended primarily for debugging
 324      * and monitoring purposes.
 325      *
 326      * @return  an estimate of the number of active threads in this thread
 327      *          group and in any other thread group that has this thread
 328      *          group as an ancestor
 329      *
 330      * @since   1.0
 331      */
 332     public int activeCount() {
 333         int result;
 334         // Snapshot sub-group data so we don&#39;t hold this lock
 335         // while our children are computing.
 336         int ngroupsSnapshot;
 337         ThreadGroup[] groupsSnapshot;
 338         synchronized (this) {
 339             if (destroyed) {
 340                 return 0;
 341             }
 342             result = nthreads;
 343             ngroupsSnapshot = ngroups;
 344             if (groups != null) {
 345                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 346             } else {
 347                 groupsSnapshot = null;
 348             }
 349         }
 350         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 351             result += groupsSnapshot[i].activeCount();
 352         }
 353         return result;
 354     }
 355 
 356     /**
 357      * Copies into the specified array every active thread in this
 358      * thread group and its subgroups.
 359      *
 360      * &lt;p&gt; An invocation of this method behaves in exactly the same
 361      * way as the invocation
 362      *
 363      * &lt;blockquote&gt;
 364      * {@linkplain #enumerate(Thread[], boolean) enumerate}{@code (list, true)}
 365      * &lt;/blockquote&gt;
 366      *
 367      * @param  list
 368      *         an array into which to put the list of threads
 369      *
 370      * @return  the number of threads put into the array
 371      *
 372      * @throws  SecurityException
 373      *          if {@linkplain #checkAccess checkAccess} determines that
 374      *          the current thread cannot access this thread group
 375      *
 376      * @since   1.0
 377      */
 378     public int enumerate(Thread list[]) {
 379         checkAccess();
 380         return enumerate(list, 0, true);
 381     }
 382 
 383     /**
 384      * Copies into the specified array every active thread in this
 385      * thread group. If {@code recurse} is {@code true},
 386      * this method recursively enumerates all subgroups of this
 387      * thread group and references to every active thread in these
 388      * subgroups are also included. If the array is too short to
 389      * hold all the threads, the extra threads are silently ignored.
 390      *
 391      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
 392      * method to get an estimate of how big the array should be, however
 393      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
 394      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
 395      * thread in this thread group, the caller should verify that the returned
 396      * int value is strictly less than the length of {@code list}.
 397      *
 398      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
 399      * that the method only be used for debugging and monitoring purposes.
 400      *
 401      * @param  list
 402      *         an array into which to put the list of threads
 403      *
 404      * @param  recurse
 405      *         if {@code true}, recursively enumerate all subgroups of this
 406      *         thread group
 407      *
 408      * @return  the number of threads put into the array
 409      *
 410      * @throws  SecurityException
 411      *          if {@linkplain #checkAccess checkAccess} determines that
 412      *          the current thread cannot access this thread group
 413      *
 414      * @since   1.0
 415      */
 416     public int enumerate(Thread list[], boolean recurse) {
 417         checkAccess();
 418         return enumerate(list, 0, recurse);
 419     }
 420 
 421     private int enumerate(Thread list[], int n, boolean recurse) {
 422         int ngroupsSnapshot = 0;
 423         ThreadGroup[] groupsSnapshot = null;
 424         synchronized (this) {
 425             if (destroyed) {
 426                 return n;
 427             }
 428             int nt = nthreads;
 429             if (nt &gt; list.length - n) {
 430                 nt = list.length - n;
 431             }
 432             for (int i = 0; i &lt; nt; i++) {
 433                 if (threads[i].isAlive()) {
 434                     list[n++] = threads[i];
 435                 }
 436             }
 437             if (recurse) {
 438                 ngroupsSnapshot = ngroups;
 439                 if (groups != null) {
 440                     groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 441                 } else {
 442                     groupsSnapshot = null;
 443                 }
 444             }
 445         }
 446         if (recurse) {
 447             for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 448                 n = groupsSnapshot[i].enumerate(list, n, true);
 449             }
 450         }
 451         return n;
 452     }
 453 
 454     /**
 455      * Returns an estimate of the number of active groups in this
 456      * thread group and its subgroups. Recursively iterates over
 457      * all subgroups in this thread group.
 458      *
 459      * &lt;p&gt; The value returned is only an estimate because the number of
 460      * thread groups may change dynamically while this method traverses
 461      * internal data structures. This method is intended primarily for
 462      * debugging and monitoring purposes.
 463      *
 464      * @return  the number of active thread groups with this thread group as
 465      *          an ancestor
 466      *
 467      * @since   1.0
 468      */
 469     public int activeGroupCount() {
 470         int ngroupsSnapshot;
 471         ThreadGroup[] groupsSnapshot;
 472         synchronized (this) {
 473             if (destroyed) {
 474                 return 0;
 475             }
 476             ngroupsSnapshot = ngroups;
 477             if (groups != null) {
 478                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 479             } else {
 480                 groupsSnapshot = null;
 481             }
 482         }
 483         int n = ngroupsSnapshot;
 484         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 485             n += groupsSnapshot[i].activeGroupCount();
 486         }
 487         return n;
 488     }
 489 
 490     /**
 491      * Copies into the specified array references to every active
 492      * subgroup in this thread group and its subgroups.
 493      *
 494      * &lt;p&gt; An invocation of this method behaves in exactly the same
 495      * way as the invocation
 496      *
 497      * &lt;blockquote&gt;
 498      * {@linkplain #enumerate(ThreadGroup[], boolean) enumerate}{@code (list, true)}
 499      * &lt;/blockquote&gt;
 500      *
 501      * @param  list
 502      *         an array into which to put the list of thread groups
 503      *
 504      * @return  the number of thread groups put into the array
 505      *
 506      * @throws  SecurityException
 507      *          if {@linkplain #checkAccess checkAccess} determines that
 508      *          the current thread cannot access this thread group
 509      *
 510      * @since   1.0
 511      */
 512     public int enumerate(ThreadGroup list[]) {
 513         checkAccess();
 514         return enumerate(list, 0, true);
 515     }
 516 
 517     /**
 518      * Copies into the specified array references to every active
 519      * subgroup in this thread group. If {@code recurse} is
 520      * {@code true}, this method recursively enumerates all subgroups of this
 521      * thread group and references to every active thread group in these
 522      * subgroups are also included.
 523      *
 524      * &lt;p&gt; An application might use the
 525      * {@linkplain #activeGroupCount activeGroupCount} method to
 526      * get an estimate of how big the array should be, however &lt;i&gt;if the
 527      * array is too short to hold all the thread groups, the extra thread
 528      * groups are silently ignored.&lt;/i&gt;  If it is critical to obtain every
 529      * active subgroup in this thread group, the caller should verify that
 530      * the returned int value is strictly less than the length of
 531      * {@code list}.
 532      *
 533      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
 534      * that the method only be used for debugging and monitoring purposes.
 535      *
 536      * @param  list
 537      *         an array into which to put the list of thread groups
 538      *
 539      * @param  recurse
 540      *         if {@code true}, recursively enumerate all subgroups
 541      *
 542      * @return  the number of thread groups put into the array
 543      *
 544      * @throws  SecurityException
 545      *          if {@linkplain #checkAccess checkAccess} determines that
 546      *          the current thread cannot access this thread group
 547      *
 548      * @since   1.0
 549      */
 550     public int enumerate(ThreadGroup list[], boolean recurse) {
 551         checkAccess();
 552         return enumerate(list, 0, recurse);
 553     }
 554 
 555     private int enumerate(ThreadGroup list[], int n, boolean recurse) {
 556         int ngroupsSnapshot = 0;
 557         ThreadGroup[] groupsSnapshot = null;
 558         synchronized (this) {
 559             if (destroyed) {
 560                 return n;
 561             }
 562             int ng = ngroups;
 563             if (ng &gt; list.length - n) {
 564                 ng = list.length - n;
 565             }
 566             if (ng &gt; 0) {
 567                 System.arraycopy(groups, 0, list, n, ng);
 568                 n += ng;
 569             }
 570             if (recurse) {
 571                 ngroupsSnapshot = ngroups;
 572                 if (groups != null) {
 573                     groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 574                 } else {
 575                     groupsSnapshot = null;
 576                 }
 577             }
 578         }
 579         if (recurse) {
 580             for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 581                 n = groupsSnapshot[i].enumerate(list, n, true);
 582             }
 583         }
 584         return n;
 585     }
 586 
 587     /**
 588      * Stops all threads in this thread group.
 589      * &lt;p&gt;
 590      * First, the {@code checkAccess} method of this thread group is
 591      * called with no arguments; this may result in a security exception.
 592      * &lt;p&gt;
 593      * This method then calls the {@code stop} method on all the
 594      * threads in this thread group and in all of its subgroups.
 595      *
 596      * @throws     SecurityException  if the current thread is not allowed
 597      *               to access this thread group or any of the threads in
 598      *               the thread group.
 599      * @see        java.lang.SecurityException
 600      * @see        java.lang.Thread#stop()
 601      * @see        java.lang.ThreadGroup#checkAccess()
 602      * @since      1.0
 603      * @deprecated    This method is inherently unsafe.  See
 604      *     {@link Thread#stop} for details.
 605      */
 606     @Deprecated(since=&quot;1.2&quot;)
 607     public final void stop() {
 608         if (stopOrSuspend(false))
 609             Thread.currentThread().stop();
 610     }
 611 
 612     /**
 613      * Interrupts all threads in this thread group.
 614      * &lt;p&gt;
 615      * First, the {@code checkAccess} method of this thread group is
 616      * called with no arguments; this may result in a security exception.
 617      * &lt;p&gt;
 618      * This method then calls the {@code interrupt} method on all the
 619      * threads in this thread group and in all of its subgroups.
 620      *
 621      * @throws     SecurityException  if the current thread is not allowed
 622      *               to access this thread group or any of the threads in
 623      *               the thread group.
 624      * @see        java.lang.Thread#interrupt()
 625      * @see        java.lang.SecurityException
 626      * @see        java.lang.ThreadGroup#checkAccess()
 627      * @since      1.2
 628      */
 629     public final void interrupt() {
 630         int ngroupsSnapshot;
 631         ThreadGroup[] groupsSnapshot;
 632         synchronized (this) {
 633             checkAccess();
 634             for (int i = 0 ; i &lt; nthreads ; i++) {
 635                 threads[i].interrupt();
 636             }
 637             ngroupsSnapshot = ngroups;
 638             if (groups != null) {
 639                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 640             } else {
 641                 groupsSnapshot = null;
 642             }
 643         }
 644         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 645             groupsSnapshot[i].interrupt();
 646         }
 647     }
 648 
 649     /**
 650      * Suspends all threads in this thread group.
 651      * &lt;p&gt;
 652      * First, the {@code checkAccess} method of this thread group is
 653      * called with no arguments; this may result in a security exception.
 654      * &lt;p&gt;
 655      * This method then calls the {@code suspend} method on all the
 656      * threads in this thread group and in all of its subgroups.
 657      *
 658      * @throws     SecurityException  if the current thread is not allowed
 659      *               to access this thread group or any of the threads in
 660      *               the thread group.
 661      * @see        java.lang.Thread#suspend()
 662      * @see        java.lang.SecurityException
 663      * @see        java.lang.ThreadGroup#checkAccess()
 664      * @since      1.0
 665      * @deprecated    This method is inherently deadlock-prone.  See
 666      *     {@link Thread#suspend} for details.
 667      */
<a name="2" id="anc2"></a><span class="line-modified"> 668     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
<span class="line-modified"> 669     @SuppressWarnings(&quot;removal&quot;)</span>
 670     public final void suspend() {
 671         if (stopOrSuspend(true))
 672             Thread.currentThread().suspend();
 673     }
 674 
 675     /**
 676      * Helper method: recursively stops or suspends (as directed by the
 677      * boolean argument) all of the threads in this thread group and its
 678      * subgroups, except the current thread.  This method returns true
 679      * if (and only if) the current thread is found to be in this thread
 680      * group or one of its subgroups.
 681      */
<a name="3" id="anc3"></a><span class="line-modified"> 682     @SuppressWarnings({&quot;deprecation&quot;, &quot;removal&quot;})</span>
 683     private boolean stopOrSuspend(boolean suspend) {
 684         boolean suicide = false;
 685         Thread us = Thread.currentThread();
 686         int ngroupsSnapshot;
 687         ThreadGroup[] groupsSnapshot = null;
 688         synchronized (this) {
 689             checkAccess();
 690             for (int i = 0 ; i &lt; nthreads ; i++) {
 691                 if (threads[i]==us)
 692                     suicide = true;
 693                 else if (suspend)
 694                     threads[i].suspend();
 695                 else
 696                     threads[i].stop();
 697             }
 698 
 699             ngroupsSnapshot = ngroups;
 700             if (groups != null) {
 701                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 702             }
 703         }
 704         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++)
 705             suicide = groupsSnapshot[i].stopOrSuspend(suspend) || suicide;
 706 
 707         return suicide;
 708     }
 709 
 710     /**
 711      * Resumes all threads in this thread group.
 712      * &lt;p&gt;
 713      * First, the {@code checkAccess} method of this thread group is
 714      * called with no arguments; this may result in a security exception.
 715      * &lt;p&gt;
 716      * This method then calls the {@code resume} method on all the
 717      * threads in this thread group and in all of its sub groups.
 718      *
 719      * @throws     SecurityException  if the current thread is not allowed to
 720      *               access this thread group or any of the threads in the
 721      *               thread group.
 722      * @see        java.lang.SecurityException
 723      * @see        java.lang.Thread#resume()
 724      * @see        java.lang.ThreadGroup#checkAccess()
 725      * @since      1.0
 726      * @deprecated    This method is used solely in conjunction with
 727      *       {@code Thread.suspend} and {@code ThreadGroup.suspend},
 728      *       both of which have been deprecated, as they are inherently
 729      *       deadlock-prone.  See {@link Thread#suspend} for details.
 730      */
<a name="4" id="anc4"></a><span class="line-modified"> 731     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
<span class="line-modified"> 732     @SuppressWarnings(&quot;removal&quot;)</span>
 733     public final void resume() {
 734         int ngroupsSnapshot;
 735         ThreadGroup[] groupsSnapshot;
 736         synchronized (this) {
 737             checkAccess();
 738             for (int i = 0 ; i &lt; nthreads ; i++) {
 739                 threads[i].resume();
 740             }
 741             ngroupsSnapshot = ngroups;
 742             if (groups != null) {
 743                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 744             } else {
 745                 groupsSnapshot = null;
 746             }
 747         }
 748         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 749             groupsSnapshot[i].resume();
 750         }
 751     }
 752 
 753     /**
 754      * Destroys this thread group and all of its subgroups. This thread
 755      * group must be empty, indicating that all threads that had been in
 756      * this thread group have since stopped.
 757      * &lt;p&gt;
 758      * First, the {@code checkAccess} method of this thread group is
 759      * called with no arguments; this may result in a security exception.
 760      *
 761      * @throws     IllegalThreadStateException  if the thread group is not
 762      *               empty or if the thread group has already been destroyed.
 763      * @throws     SecurityException  if the current thread cannot modify this
 764      *               thread group.
 765      * @see        java.lang.ThreadGroup#checkAccess()
 766      * @since      1.0
 767      */
 768     public final void destroy() {
 769         int ngroupsSnapshot;
 770         ThreadGroup[] groupsSnapshot;
 771         synchronized (this) {
 772             checkAccess();
 773             if (destroyed || (nthreads &gt; 0)) {
 774                 throw new IllegalThreadStateException();
 775             }
 776             ngroupsSnapshot = ngroups;
 777             if (groups != null) {
 778                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 779             } else {
 780                 groupsSnapshot = null;
 781             }
 782             if (parent != null) {
 783                 destroyed = true;
 784                 ngroups = 0;
 785                 groups = null;
 786                 nthreads = 0;
 787                 threads = null;
 788             }
 789         }
 790         for (int i = 0 ; i &lt; ngroupsSnapshot ; i += 1) {
 791             groupsSnapshot[i].destroy();
 792         }
 793         if (parent != null) {
 794             parent.remove(this);
 795         }
 796     }
 797 
 798     /**
 799      * Adds the specified Thread group to this group.
 800      * @param g the specified Thread group to be added
 801      * @throws  IllegalThreadStateException If the Thread group has been destroyed.
 802      */
 803     private final void add(ThreadGroup g){
 804         synchronized (this) {
 805             if (destroyed) {
 806                 throw new IllegalThreadStateException();
 807             }
 808             if (groups == null) {
 809                 groups = new ThreadGroup[4];
 810             } else if (ngroups == groups.length) {
 811                 groups = Arrays.copyOf(groups, ngroups * 2);
 812             }
 813             groups[ngroups] = g;
 814 
 815             // This is done last so it doesn&#39;t matter in case the
 816             // thread is killed
 817             ngroups++;
 818         }
 819     }
 820 
 821     /**
 822      * Removes the specified Thread group from this group.
 823      * @param g the Thread group to be removed
 824      * @return if this Thread has already been destroyed.
 825      */
 826     private void remove(ThreadGroup g) {
 827         synchronized (this) {
 828             if (destroyed) {
 829                 return;
 830             }
 831             for (int i = 0 ; i &lt; ngroups ; i++) {
 832                 if (groups[i] == g) {
 833                     ngroups -= 1;
 834                     System.arraycopy(groups, i + 1, groups, i, ngroups - i);
 835                     // Zap dangling reference to the dead group so that
 836                     // the garbage collector will collect it.
 837                     groups[ngroups] = null;
 838                     break;
 839                 }
 840             }
 841             if (nthreads == 0) {
 842                 notifyAll();
 843             }
 844             if (daemon &amp;&amp; (nthreads == 0) &amp;&amp;
 845                 (nUnstartedThreads == 0) &amp;&amp; (ngroups == 0))
 846             {
 847                 destroy();
 848             }
 849         }
 850     }
 851 
 852 
 853     /**
 854      * Increments the count of unstarted threads in the thread group.
 855      * Unstarted threads are not added to the thread group so that they
 856      * can be collected if they are never started, but they must be
 857      * counted so that daemon thread groups with unstarted threads in
 858      * them are not destroyed.
 859      */
 860     void addUnstarted() {
 861         synchronized(this) {
 862             if (destroyed) {
 863                 throw new IllegalThreadStateException();
 864             }
 865             nUnstartedThreads++;
 866         }
 867     }
 868 
 869     /**
 870      * Adds the specified thread to this thread group.
 871      *
 872      * &lt;p&gt; Note: This method is called from both library code
 873      * and the Virtual Machine. It is called from VM to add
 874      * certain system threads to the system thread group.
 875      *
 876      * @param  t
 877      *         the Thread to be added
 878      *
 879      * @throws IllegalThreadStateException
 880      *          if the Thread group has been destroyed
 881      */
 882     void add(Thread t) {
 883         synchronized (this) {
 884             if (destroyed) {
 885                 throw new IllegalThreadStateException();
 886             }
 887             if (threads == null) {
 888                 threads = new Thread[4];
 889             } else if (nthreads == threads.length) {
 890                 threads = Arrays.copyOf(threads, nthreads * 2);
 891             }
 892             threads[nthreads] = t;
 893 
 894             // This is done last so it doesn&#39;t matter in case the
 895             // thread is killed
 896             nthreads++;
 897 
 898             // The thread is now a fully fledged member of the group, even
 899             // though it may, or may not, have been started yet. It will prevent
 900             // the group from being destroyed so the unstarted Threads count is
 901             // decremented.
 902             nUnstartedThreads--;
 903         }
 904     }
 905 
 906     /**
 907      * Notifies the group that the thread {@code t} has failed
 908      * an attempt to start.
 909      *
 910      * &lt;p&gt; The state of this thread group is rolled back as if the
 911      * attempt to start the thread has never occurred. The thread is again
 912      * considered an unstarted member of the thread group, and a subsequent
 913      * attempt to start the thread is permitted.
 914      *
 915      * @param  t
 916      *         the Thread whose start method was invoked
 917      */
 918     void threadStartFailed(Thread t) {
 919         synchronized(this) {
 920             remove(t);
 921             nUnstartedThreads++;
 922         }
 923     }
 924 
 925     /**
 926      * Notifies the group that the thread {@code t} has terminated.
 927      *
 928      * &lt;p&gt; Destroy the group if all of the following conditions are
 929      * true: this is a daemon thread group; there are no more alive
 930      * or unstarted threads in the group; there are no subgroups in
 931      * this thread group.
 932      *
 933      * @param  t
 934      *         the Thread that has terminated
 935      */
 936     void threadTerminated(Thread t) {
 937         synchronized (this) {
 938             remove(t);
 939 
 940             if (nthreads == 0) {
 941                 notifyAll();
 942             }
 943             if (daemon &amp;&amp; (nthreads == 0) &amp;&amp;
 944                 (nUnstartedThreads == 0) &amp;&amp; (ngroups == 0))
 945             {
 946                 destroy();
 947             }
 948         }
 949     }
 950 
 951     /**
 952      * Removes the specified Thread from this group. Invoking this method
 953      * on a thread group that has been destroyed has no effect.
 954      *
 955      * @param  t
 956      *         the Thread to be removed
 957      */
 958     private void remove(Thread t) {
 959         synchronized (this) {
 960             if (destroyed) {
 961                 return;
 962             }
 963             for (int i = 0 ; i &lt; nthreads ; i++) {
 964                 if (threads[i] == t) {
 965                     System.arraycopy(threads, i + 1, threads, i, --nthreads - i);
 966                     // Zap dangling reference to the dead thread so that
 967                     // the garbage collector will collect it.
 968                     threads[nthreads] = null;
 969                     break;
 970                 }
 971             }
 972         }
 973     }
 974 
 975     /**
 976      * Prints information about this thread group to the standard
 977      * output. This method is useful only for debugging.
 978      *
 979      * @since   1.0
 980      */
 981     public void list() {
 982         list(System.out, 0);
 983     }
 984     void list(PrintStream out, int indent) {
 985         int ngroupsSnapshot;
 986         ThreadGroup[] groupsSnapshot;
 987         synchronized (this) {
 988             for (int j = 0 ; j &lt; indent ; j++) {
 989                 out.print(&quot; &quot;);
 990             }
 991             out.println(this);
 992             indent += 4;
 993             for (int i = 0 ; i &lt; nthreads ; i++) {
 994                 for (int j = 0 ; j &lt; indent ; j++) {
 995                     out.print(&quot; &quot;);
 996                 }
 997                 out.println(threads[i]);
 998             }
 999             ngroupsSnapshot = ngroups;
1000             if (groups != null) {
1001                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
1002             } else {
1003                 groupsSnapshot = null;
1004             }
1005         }
1006         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
1007             groupsSnapshot[i].list(out, indent);
1008         }
1009     }
1010 
1011     /**
1012      * Called by the Java Virtual Machine when a thread in this
1013      * thread group stops because of an uncaught exception, and the thread
1014      * does not have a specific {@link Thread.UncaughtExceptionHandler}
1015      * installed.
1016      * &lt;p&gt;
1017      * The {@code uncaughtException} method of
1018      * {@code ThreadGroup} does the following:
1019      * &lt;ul&gt;
1020      * &lt;li&gt;If this thread group has a parent thread group, the
1021      *     {@code uncaughtException} method of that parent is called
1022      *     with the same two arguments.
1023      * &lt;li&gt;Otherwise, this method checks to see if there is a
1024      *     {@linkplain Thread#getDefaultUncaughtExceptionHandler default
1025      *     uncaught exception handler} installed, and if so, its
1026      *     {@code uncaughtException} method is called with the same
1027      *     two arguments.
1028      * &lt;li&gt;Otherwise, this method determines if the {@code Throwable}
1029      *     argument is an instance of {@link ThreadDeath}. If so, nothing
1030      *     special is done. Otherwise, a message containing the
1031      *     thread&#39;s name, as returned from the thread&#39;s {@link
1032      *     Thread#getName getName} method, and a stack backtrace,
1033      *     using the {@code Throwable}&#39;s {@link
1034      *     Throwable#printStackTrace printStackTrace} method, is
1035      *     printed to the {@linkplain System#err standard error stream}.
1036      * &lt;/ul&gt;
1037      * &lt;p&gt;
1038      * Applications can override this method in subclasses of
1039      * {@code ThreadGroup} to provide alternative handling of
1040      * uncaught exceptions.
1041      *
1042      * @param   t   the thread that is about to exit.
1043      * @param   e   the uncaught exception.
1044      * @since   1.0
1045      */
1046     public void uncaughtException(Thread t, Throwable e) {
1047         if (parent != null) {
1048             parent.uncaughtException(t, e);
1049         } else {
1050             Thread.UncaughtExceptionHandler ueh =
1051                 Thread.getDefaultUncaughtExceptionHandler();
1052             if (ueh != null) {
1053                 ueh.uncaughtException(t, e);
1054             } else if (!(e instanceof ThreadDeath)) {
1055                 System.err.print(&quot;Exception in thread \&quot;&quot;
1056                                  + t.getName() + &quot;\&quot; &quot;);
1057                 e.printStackTrace(System.err);
1058             }
1059         }
1060     }
1061 
1062     /**
1063      * Used by VM to control lowmem implicit suspension.
1064      *
1065      * @param b boolean to allow or disallow suspension
1066      * @return true on success
1067      * @since   1.1
1068      * @deprecated The definition of this call depends on {@link #suspend},
1069      *             which is deprecated.  Further, the behavior of this call
1070      *             was never specified.
1071      */
<a name="5" id="anc5"></a><span class="line-modified">1072     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
1073     public boolean allowThreadSuspension(boolean b) {
1074         return true;
1075     }
1076 
1077     /**
1078      * Returns a string representation of this Thread group.
1079      *
1080      * @return  a string representation of this thread group.
1081      * @since   1.0
1082      */
1083     public String toString() {
1084         return getClass().getName() + &quot;[name=&quot; + getName() + &quot;,maxpri=&quot; + maxPriority + &quot;]&quot;;
1085     }
1086 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
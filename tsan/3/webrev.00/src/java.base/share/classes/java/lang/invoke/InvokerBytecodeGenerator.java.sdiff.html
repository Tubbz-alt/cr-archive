<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClassLambdaMetafactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Invokers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 106         int p = invokerName.indexOf(&#39;.&#39;);
 107         if (p &gt; -1) {
 108             className = invokerName.substring(0, p);
 109             invokerName = invokerName.substring(p + 1);
 110         }
 111         if (DUMP_CLASS_FILES) {
 112             className = makeDumpableClassName(className);
 113         }
 114         this.className  = className;
 115         this.lambdaForm = lambdaForm;
 116         this.invokerName = invokerName;
 117         this.invokerType = invokerType;
 118         this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots
 119         this.localClasses = new Class&lt;?&gt;[localsMapSize+1];
 120     }
 121 
 122     /** For generating LambdaForm interpreter entry points. */
 123     private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
 124         this(null, invokerType.parameterCount(),
 125              className, invokerName, invokerType);

 126         // Create an array to map name indexes to locals indexes.
<span class="line-modified"> 127         for (int i = 0; i &lt; localsMap.length; i++) {</span>
<span class="line-modified"> 128             localsMap[i] = invokerType.parameterSlotCount() - invokerType.parameterSlotDepth(i);</span>



 129         }
 130     }
 131 
 132     /** For generating customized code for a single LambdaForm. */
 133     private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {
 134         this(className, form.lambdaName(), form, invokerType);
 135     }
 136 
 137     /** For generating customized code for a single LambdaForm. */
 138     InvokerBytecodeGenerator(String className, String invokerName,
 139             LambdaForm form, MethodType invokerType) {
 140         this(form, form.names.length,
 141              className, invokerName, invokerType);
 142         // Create an array to map name indexes to locals indexes.
 143         Name[] names = form.names;
 144         for (int i = 0, index = 0; i &lt; localsMap.length; i++) {
 145             localsMap[i] = index;
 146             if (i &lt; names.length) {
 147                 BasicType type = names[i].type();
 148                 index += type.basicTypeSlots();
</pre>
<hr />
<pre>
1147     }
1148 
1149     /**
1150       * Emit bytecode for the guardWithCatch idiom.
1151       *
1152       * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithCatch):
1153       * &lt;blockquote&gt;&lt;pre&gt;{@code
1154       *  guardWithCatch=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L,a6:L,a7:L)=&gt;{
1155       *    t8:L=MethodHandle.invokeBasic(a4:L,a6:L,a7:L);
1156       *    t9:L=MethodHandleImpl.guardWithCatch(a1:L,a2:L,a3:L,t8:L);
1157       *   t10:I=MethodHandle.invokeBasic(a5:L,t9:L);t10:I}
1158       * }&lt;/pre&gt;&lt;/blockquote&gt;
1159       *
1160       * It is compiled into bytecode equivalent of the following code:
1161       * &lt;blockquote&gt;&lt;pre&gt;{@code
1162       *  try {
1163       *      return a1.invokeBasic(a6, a7);
1164       *  } catch (Throwable e) {
1165       *      if (!a2.isInstance(e)) throw e;
1166       *      return a3.invokeBasic(ex, a6, a7);
<span class="line-modified">1167       *  }}</span>
1168       */
1169     private Name emitGuardWithCatch(int pos) {
1170         Name args    = lambdaForm.names[pos];
1171         Name invoker = lambdaForm.names[pos+1];
1172         Name result  = lambdaForm.names[pos+2];
1173 
1174         Label L_startBlock = new Label();
1175         Label L_endBlock = new Label();
1176         Label L_handler = new Label();
1177         Label L_done = new Label();
1178 
1179         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1180         MethodType type = args.function.resolvedHandle().type()
1181                               .dropParameterTypes(0,1)
1182                               .changeReturnType(returnType);
1183 
1184         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, &quot;java/lang/Throwable&quot;);
1185 
1186         // Normal case
1187         mv.visitLabel(L_startBlock);
</pre>
<hr />
<pre>
1242      * Object r;
1243      * try {
1244      *     r = a1.invokeBasic(a5);
1245      * } catch (Throwable thrown) {
1246      *     t = thrown;
1247      *     throw t;
1248      * } finally {
1249      *     r = a2.invokeBasic(t, r, a5);
1250      * }
1251      * return r;
1252      * }&lt;/pre&gt;&lt;/blockquote&gt;
1253      * &lt;p&gt;
1254      * Specifically, the bytecode will have the following form (the stack effects are given for the beginnings of
1255      * blocks, and for the situations after executing the given instruction - the code will have a slightly different
1256      * shape if the return type is {@code void}):
1257      * &lt;blockquote&gt;&lt;pre&gt;{@code
1258      * TRY:                 (--)
1259      *                      load target                             (-- target)
1260      *                      load args                               (-- args... target)
1261      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (depends)
<span class="line-modified">1262      * FINALLY_NORMAL:      (-- r)</span>
<span class="line-modified">1263      *                      load cleanup                            (-- cleanup r)</span>
<span class="line-modified">1264      *                      SWAP                                    (-- r cleanup)</span>
<span class="line-modified">1265      *                      ACONST_NULL                             (-- t r cleanup)</span>
<span class="line-modified">1266      *                      SWAP                                    (-- r t cleanup)</span>
<span class="line-modified">1267      *                      load args                               (-- args... r t cleanup)</span>
<span class="line-modified">1268      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r)</span>
1269      *                      GOTO DONE
1270      * CATCH:               (-- t)
1271      *                      DUP                                     (-- t t)
1272      * FINALLY_EXCEPTIONAL: (-- t t)
1273      *                      load cleanup                            (-- cleanup t t)
1274      *                      SWAP                                    (-- t cleanup t)
<span class="line-modified">1275      *                      load default for r                      (-- r t cleanup t)</span>
<span class="line-modified">1276      *                      load args                               (-- args... r t cleanup t)</span>
<span class="line-modified">1277      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r t)</span>
<span class="line-modified">1278      *                      POP                                     (-- t)</span>
1279      *                      ATHROW
1280      * DONE:                (-- r)
1281      * }&lt;/pre&gt;&lt;/blockquote&gt;

1282      */
1283     private Name emitTryFinally(int pos) {
1284         Name args    = lambdaForm.names[pos];
1285         Name invoker = lambdaForm.names[pos+1];
1286         Name result  = lambdaForm.names[pos+2];
1287 
1288         Label lFrom = new Label();
1289         Label lTo = new Label();
1290         Label lCatch = new Label();
1291         Label lDone = new Label();
1292 
1293         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();

1294         boolean isNonVoid = returnType != void.class;

1295         MethodType type = args.function.resolvedHandle().type()
1296                 .dropParameterTypes(0,1)
1297                 .changeReturnType(returnType);
1298         MethodType cleanupType = type.insertParameterTypes(0, Throwable.class);
1299         if (isNonVoid) {
1300             cleanupType = cleanupType.insertParameterTypes(1, returnType);
1301         }
1302         String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();
1303 
1304         // exception handler table
1305         mv.visitTryCatchBlock(lFrom, lTo, lCatch, &quot;java/lang/Throwable&quot;);
1306 
1307         // TRY:
1308         mv.visitLabel(lFrom);
1309         emitPushArgument(invoker, 0); // load target
1310         emitPushArguments(args, 1); // load args (skip 0: method handle)
1311         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
1312         mv.visitLabel(lTo);
1313 
1314         // FINALLY_NORMAL:
<span class="line-modified">1315         emitPushArgument(invoker, 1); // load cleanup</span>
1316         if (isNonVoid) {
<span class="line-modified">1317             mv.visitInsn(Opcodes.SWAP);</span>
1318         }

1319         mv.visitInsn(Opcodes.ACONST_NULL);
1320         if (isNonVoid) {
<span class="line-modified">1321             mv.visitInsn(Opcodes.SWAP);</span>
1322         }
1323         emitPushArguments(args, 1); // load args (skip 0: method handle)
1324         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1325         mv.visitJumpInsn(Opcodes.GOTO, lDone);
1326 
1327         // CATCH:
1328         mv.visitLabel(lCatch);
1329         mv.visitInsn(Opcodes.DUP);
1330 
1331         // FINALLY_EXCEPTIONAL:
1332         emitPushArgument(invoker, 1); // load cleanup
1333         mv.visitInsn(Opcodes.SWAP);
1334         if (isNonVoid) {
1335             emitZero(BasicType.basicType(returnType)); // load default for result
1336         }
1337         emitPushArguments(args, 1); // load args (skip 0: method handle)
1338         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1339         if (isNonVoid) {
<span class="line-modified">1340             mv.visitInsn(Opcodes.POP);</span>
1341         }
1342         mv.visitInsn(Opcodes.ATHROW);
1343 
1344         // DONE:
1345         mv.visitLabel(lDone);
1346 
1347         return result;
1348     }
1349 


















1350     /**
1351      * Emit bytecode for the loop idiom.
1352      * &lt;p&gt;
1353      * The pattern looks like (Cf. MethodHandleImpl.loop):
1354      * &lt;blockquote&gt;&lt;pre&gt;{@code
1355      * // a0: BMH
1356      * // a1: LoopClauses (containing an array of arrays: inits, steps, preds, finis)
1357      * // a2: box, a3: unbox
1358      * // a4 (and following): arguments
1359      * loop=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L)=&gt;{
1360      *   t5:L=MethodHandle.invokeBasic(a2:L,a4:L);          // box the arguments into an Object[]
1361      *   t6:L=MethodHandleImpl.loop(bt:L,a1:L,t5:L);        // call the loop executor (with supplied types in bt)
1362      *   t7:L=MethodHandle.invokeBasic(a3:L,t6:L);t7:L}     // unbox the result; return the result
1363      * }&lt;/pre&gt;&lt;/blockquote&gt;
1364      * &lt;p&gt;
1365      * It is compiled into bytecode equivalent to the code seen in {@link MethodHandleImpl#loop(BasicType[],
1366      * MethodHandleImpl.LoopClauses, Object...)}, with the difference that no arrays
1367      * will be used for local state storage. Instead, the local state will be mapped to actual stack slots.
1368      * &lt;p&gt;
1369      * Bytecode generation applies an unrolling scheme to enable better bytecode generation regarding local state type
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 106         int p = invokerName.indexOf(&#39;.&#39;);
 107         if (p &gt; -1) {
 108             className = invokerName.substring(0, p);
 109             invokerName = invokerName.substring(p + 1);
 110         }
 111         if (DUMP_CLASS_FILES) {
 112             className = makeDumpableClassName(className);
 113         }
 114         this.className  = className;
 115         this.lambdaForm = lambdaForm;
 116         this.invokerName = invokerName;
 117         this.invokerType = invokerType;
 118         this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots
 119         this.localClasses = new Class&lt;?&gt;[localsMapSize+1];
 120     }
 121 
 122     /** For generating LambdaForm interpreter entry points. */
 123     private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
 124         this(null, invokerType.parameterCount(),
 125              className, invokerName, invokerType);
<span class="line-added"> 126         MethodType mt = invokerType.erase();</span>
 127         // Create an array to map name indexes to locals indexes.
<span class="line-modified"> 128         localsMap[0] = 0; // localsMap has at least one element</span>
<span class="line-modified"> 129         for (int i = 1, index = 0; i &lt; localsMap.length; i++) {</span>
<span class="line-added"> 130             Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));</span>
<span class="line-added"> 131             index += w.stackSlots();</span>
<span class="line-added"> 132             localsMap[i] = index;</span>
 133         }
 134     }
 135 
 136     /** For generating customized code for a single LambdaForm. */
 137     private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {
 138         this(className, form.lambdaName(), form, invokerType);
 139     }
 140 
 141     /** For generating customized code for a single LambdaForm. */
 142     InvokerBytecodeGenerator(String className, String invokerName,
 143             LambdaForm form, MethodType invokerType) {
 144         this(form, form.names.length,
 145              className, invokerName, invokerType);
 146         // Create an array to map name indexes to locals indexes.
 147         Name[] names = form.names;
 148         for (int i = 0, index = 0; i &lt; localsMap.length; i++) {
 149             localsMap[i] = index;
 150             if (i &lt; names.length) {
 151                 BasicType type = names[i].type();
 152                 index += type.basicTypeSlots();
</pre>
<hr />
<pre>
1151     }
1152 
1153     /**
1154       * Emit bytecode for the guardWithCatch idiom.
1155       *
1156       * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithCatch):
1157       * &lt;blockquote&gt;&lt;pre&gt;{@code
1158       *  guardWithCatch=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L,a6:L,a7:L)=&gt;{
1159       *    t8:L=MethodHandle.invokeBasic(a4:L,a6:L,a7:L);
1160       *    t9:L=MethodHandleImpl.guardWithCatch(a1:L,a2:L,a3:L,t8:L);
1161       *   t10:I=MethodHandle.invokeBasic(a5:L,t9:L);t10:I}
1162       * }&lt;/pre&gt;&lt;/blockquote&gt;
1163       *
1164       * It is compiled into bytecode equivalent of the following code:
1165       * &lt;blockquote&gt;&lt;pre&gt;{@code
1166       *  try {
1167       *      return a1.invokeBasic(a6, a7);
1168       *  } catch (Throwable e) {
1169       *      if (!a2.isInstance(e)) throw e;
1170       *      return a3.invokeBasic(ex, a6, a7);
<span class="line-modified">1171       *  }}&lt;/pre&gt;&lt;/blockquote&gt;</span>
1172       */
1173     private Name emitGuardWithCatch(int pos) {
1174         Name args    = lambdaForm.names[pos];
1175         Name invoker = lambdaForm.names[pos+1];
1176         Name result  = lambdaForm.names[pos+2];
1177 
1178         Label L_startBlock = new Label();
1179         Label L_endBlock = new Label();
1180         Label L_handler = new Label();
1181         Label L_done = new Label();
1182 
1183         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1184         MethodType type = args.function.resolvedHandle().type()
1185                               .dropParameterTypes(0,1)
1186                               .changeReturnType(returnType);
1187 
1188         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, &quot;java/lang/Throwable&quot;);
1189 
1190         // Normal case
1191         mv.visitLabel(L_startBlock);
</pre>
<hr />
<pre>
1246      * Object r;
1247      * try {
1248      *     r = a1.invokeBasic(a5);
1249      * } catch (Throwable thrown) {
1250      *     t = thrown;
1251      *     throw t;
1252      * } finally {
1253      *     r = a2.invokeBasic(t, r, a5);
1254      * }
1255      * return r;
1256      * }&lt;/pre&gt;&lt;/blockquote&gt;
1257      * &lt;p&gt;
1258      * Specifically, the bytecode will have the following form (the stack effects are given for the beginnings of
1259      * blocks, and for the situations after executing the given instruction - the code will have a slightly different
1260      * shape if the return type is {@code void}):
1261      * &lt;blockquote&gt;&lt;pre&gt;{@code
1262      * TRY:                 (--)
1263      *                      load target                             (-- target)
1264      *                      load args                               (-- args... target)
1265      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (depends)
<span class="line-modified">1266      * FINALLY_NORMAL:      (-- r_2nd* r)</span>
<span class="line-modified">1267      *                      store returned value                    (--)</span>
<span class="line-modified">1268      *                      load cleanup                            (-- cleanup)</span>
<span class="line-modified">1269      *                      ACONST_NULL                             (-- t cleanup)</span>
<span class="line-modified">1270      *                      load returned value                     (-- r_2nd* r t cleanup)</span>
<span class="line-modified">1271      *                      load args                               (-- args... r_2nd* r t cleanup)</span>
<span class="line-modified">1272      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r)</span>
1273      *                      GOTO DONE
1274      * CATCH:               (-- t)
1275      *                      DUP                                     (-- t t)
1276      * FINALLY_EXCEPTIONAL: (-- t t)
1277      *                      load cleanup                            (-- cleanup t t)
1278      *                      SWAP                                    (-- t cleanup t)
<span class="line-modified">1279      *                      load default for r                      (-- r_2nd* r t cleanup t)</span>
<span class="line-modified">1280      *                      load args                               (-- args... r_2nd* r t cleanup t)</span>
<span class="line-modified">1281      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r t)</span>
<span class="line-modified">1282      *                      POP/POP2*                               (-- t)</span>
1283      *                      ATHROW
1284      * DONE:                (-- r)
1285      * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-added">1286      * * = depends on whether the return type takes up 2 stack slots.</span>
1287      */
1288     private Name emitTryFinally(int pos) {
1289         Name args    = lambdaForm.names[pos];
1290         Name invoker = lambdaForm.names[pos+1];
1291         Name result  = lambdaForm.names[pos+2];
1292 
1293         Label lFrom = new Label();
1294         Label lTo = new Label();
1295         Label lCatch = new Label();
1296         Label lDone = new Label();
1297 
1298         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
<span class="line-added">1299         BasicType basicReturnType = BasicType.basicType(returnType);</span>
1300         boolean isNonVoid = returnType != void.class;
<span class="line-added">1301 </span>
1302         MethodType type = args.function.resolvedHandle().type()
1303                 .dropParameterTypes(0,1)
1304                 .changeReturnType(returnType);
1305         MethodType cleanupType = type.insertParameterTypes(0, Throwable.class);
1306         if (isNonVoid) {
1307             cleanupType = cleanupType.insertParameterTypes(1, returnType);
1308         }
1309         String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();
1310 
1311         // exception handler table
1312         mv.visitTryCatchBlock(lFrom, lTo, lCatch, &quot;java/lang/Throwable&quot;);
1313 
1314         // TRY:
1315         mv.visitLabel(lFrom);
1316         emitPushArgument(invoker, 0); // load target
1317         emitPushArguments(args, 1); // load args (skip 0: method handle)
1318         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
1319         mv.visitLabel(lTo);
1320 
1321         // FINALLY_NORMAL:
<span class="line-modified">1322         int index = extendLocalsMap(new Class&lt;?&gt;[]{ returnType });</span>
1323         if (isNonVoid) {
<span class="line-modified">1324             emitStoreInsn(basicReturnType, index);</span>
1325         }
<span class="line-added">1326         emitPushArgument(invoker, 1); // load cleanup</span>
1327         mv.visitInsn(Opcodes.ACONST_NULL);
1328         if (isNonVoid) {
<span class="line-modified">1329             emitLoadInsn(basicReturnType, index);</span>
1330         }
1331         emitPushArguments(args, 1); // load args (skip 0: method handle)
1332         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1333         mv.visitJumpInsn(Opcodes.GOTO, lDone);
1334 
1335         // CATCH:
1336         mv.visitLabel(lCatch);
1337         mv.visitInsn(Opcodes.DUP);
1338 
1339         // FINALLY_EXCEPTIONAL:
1340         emitPushArgument(invoker, 1); // load cleanup
1341         mv.visitInsn(Opcodes.SWAP);
1342         if (isNonVoid) {
1343             emitZero(BasicType.basicType(returnType)); // load default for result
1344         }
1345         emitPushArguments(args, 1); // load args (skip 0: method handle)
1346         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1347         if (isNonVoid) {
<span class="line-modified">1348             emitPopInsn(basicReturnType);</span>
1349         }
1350         mv.visitInsn(Opcodes.ATHROW);
1351 
1352         // DONE:
1353         mv.visitLabel(lDone);
1354 
1355         return result;
1356     }
1357 
<span class="line-added">1358     private void emitPopInsn(BasicType type) {</span>
<span class="line-added">1359         mv.visitInsn(popInsnOpcode(type));</span>
<span class="line-added">1360     }</span>
<span class="line-added">1361 </span>
<span class="line-added">1362     private static int popInsnOpcode(BasicType type) {</span>
<span class="line-added">1363         switch (type) {</span>
<span class="line-added">1364             case I_TYPE:</span>
<span class="line-added">1365             case F_TYPE:</span>
<span class="line-added">1366             case L_TYPE:</span>
<span class="line-added">1367                 return Opcodes.POP;</span>
<span class="line-added">1368             case J_TYPE:</span>
<span class="line-added">1369             case D_TYPE:</span>
<span class="line-added">1370                 return Opcodes.POP2;</span>
<span class="line-added">1371             default:</span>
<span class="line-added">1372                 throw new InternalError(&quot;unknown type: &quot; + type);</span>
<span class="line-added">1373         }</span>
<span class="line-added">1374     }</span>
<span class="line-added">1375 </span>
1376     /**
1377      * Emit bytecode for the loop idiom.
1378      * &lt;p&gt;
1379      * The pattern looks like (Cf. MethodHandleImpl.loop):
1380      * &lt;blockquote&gt;&lt;pre&gt;{@code
1381      * // a0: BMH
1382      * // a1: LoopClauses (containing an array of arrays: inits, steps, preds, finis)
1383      * // a2: box, a3: unbox
1384      * // a4 (and following): arguments
1385      * loop=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L)=&gt;{
1386      *   t5:L=MethodHandle.invokeBasic(a2:L,a4:L);          // box the arguments into an Object[]
1387      *   t6:L=MethodHandleImpl.loop(bt:L,a1:L,t5:L);        // call the loop executor (with supplied types in bt)
1388      *   t7:L=MethodHandle.invokeBasic(a3:L,t6:L);t7:L}     // unbox the result; return the result
1389      * }&lt;/pre&gt;&lt;/blockquote&gt;
1390      * &lt;p&gt;
1391      * It is compiled into bytecode equivalent to the code seen in {@link MethodHandleImpl#loop(BasicType[],
1392      * MethodHandleImpl.LoopClauses, Object...)}, with the difference that no arrays
1393      * will be used for local state storage. Instead, the local state will be mapped to actual stack slots.
1394      * &lt;p&gt;
1395      * Bytecode generation applies an unrolling scheme to enable better bytecode generation regarding local state type
</pre>
</td>
</tr>
</table>
<center><a href="InnerClassLambdaMetafactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Invokers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
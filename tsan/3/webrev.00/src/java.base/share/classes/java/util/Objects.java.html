<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/Objects.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import jdk.internal.util.Preconditions;
 29 import jdk.internal.vm.annotation.ForceInline;
 30 
 31 import java.util.function.Supplier;
 32 
 33 /**
 34  * This class consists of {@code static} utility methods for operating
 35  * on objects, or checking certain conditions before operation.  These utilities
 36  * include {@code null}-safe or {@code null}-tolerant methods for computing the
 37  * hash code of an object, returning a string for an object, comparing two
 38  * objects, and checking if indexes or sub-range values are out of bounds.
 39  *
 40  * @apiNote
 41  * Static methods such as {@link Objects#checkIndex},
 42  * {@link Objects#checkFromToIndex}, and {@link Objects#checkFromIndexSize} are
 43  * provided for the convenience of checking if values corresponding to indexes
 44  * and sub-ranges are out of bounds.
 45  * Variations of these static methods support customization of the runtime
 46  * exception, and corresponding exception detail message, that is thrown when
 47  * values are out of bounds.  Such methods accept a functional interface
 48  * argument, instances of {@code BiFunction}, that maps out-of-bound values to a
 49  * runtime exception.  Care should be taken when using such methods in
 50  * combination with an argument that is a lambda expression, method reference or
 51  * class that capture values.  In such cases the cost of capture, related to
 52  * functional interface allocation, may exceed the cost of checking bounds.
 53  *
 54  * @since 1.7
 55  */
 56 public final class Objects {
 57     private Objects() {
 58         throw new AssertionError(&quot;No java.util.Objects instances for you!&quot;);
 59     }
 60 
 61     /**
 62      * Returns {@code true} if the arguments are equal to each other
 63      * and {@code false} otherwise.
 64      * Consequently, if both arguments are {@code null}, {@code true}
 65      * is returned.  Otherwise, if the first argument is not {@code
 66      * null}, equality is determined by calling the {@link
 67      * Object#equals equals} method of the first argument with the
 68      * second argument of this method. Otherwise, {@code false} is
 69      * returned.
 70      *
 71      * @param a an object
 72      * @param b an object to be compared with {@code a} for equality
 73      * @return {@code true} if the arguments are equal to each other
 74      * and {@code false} otherwise
 75      * @see Object#equals(Object)
 76      */
 77     public static boolean equals(Object a, Object b) {
 78         return (a == b) || (a != null &amp;&amp; a.equals(b));
 79     }
 80 
 81    /**
 82     * Returns {@code true} if the arguments are deeply equal to each other
 83     * and {@code false} otherwise.
 84     *
 85     * Two {@code null} values are deeply equal.  If both arguments are
 86     * arrays, the algorithm in {@link Arrays#deepEquals(Object[],
 87     * Object[]) Arrays.deepEquals} is used to determine equality.
 88     * Otherwise, equality is determined by using the {@link
 89     * Object#equals equals} method of the first argument.
 90     *
 91     * @param a an object
 92     * @param b an object to be compared with {@code a} for deep equality
 93     * @return {@code true} if the arguments are deeply equal to each other
 94     * and {@code false} otherwise
 95     * @see Arrays#deepEquals(Object[], Object[])
 96     * @see Objects#equals(Object, Object)
 97     */
 98     public static boolean deepEquals(Object a, Object b) {
 99         if (a == b)
100             return true;
101         else if (a == null || b == null)
102             return false;
103         else
104             return Arrays.deepEquals0(a, b);
105     }
106 
107     /**
108      * Returns the hash code of a non-{@code null} argument and 0 for
109      * a {@code null} argument.
110      *
111      * @param o an object
112      * @return the hash code of a non-{@code null} argument and 0 for
113      * a {@code null} argument
114      * @see Object#hashCode
115      */
116     public static int hashCode(Object o) {
117         return o != null ? o.hashCode() : 0;
118     }
119 
120    /**
121     * Generates a hash code for a sequence of input values. The hash
122     * code is generated as if all the input values were placed into an
123     * array, and that array were hashed by calling {@link
124     * Arrays#hashCode(Object[])}.
125     *
126     * &lt;p&gt;This method is useful for implementing {@link
127     * Object#hashCode()} on objects containing multiple fields. For
128     * example, if an object that has three fields, {@code x}, {@code
129     * y}, and {@code z}, one could write:
130     *
131     * &lt;blockquote&gt;&lt;pre&gt;
132     * &amp;#064;Override public int hashCode() {
133     *     return Objects.hash(x, y, z);
134     * }
135     * &lt;/pre&gt;&lt;/blockquote&gt;
136     *
137     * &lt;b&gt;Warning: When a single object reference is supplied, the returned
138     * value does not equal the hash code of that object reference.&lt;/b&gt; This
139     * value can be computed by calling {@link #hashCode(Object)}.
140     *
141     * @param values the values to be hashed
142     * @return a hash value of the sequence of input values
143     * @see Arrays#hashCode(Object[])
144     * @see List#hashCode
145     */
146     public static int hash(Object... values) {
147         return Arrays.hashCode(values);
148     }
149 
150     /**
151      * Returns the result of calling {@code toString} for a non-{@code
152      * null} argument and {@code &quot;null&quot;} for a {@code null} argument.
153      *
154      * @param o an object
155      * @return the result of calling {@code toString} for a non-{@code
156      * null} argument and {@code &quot;null&quot;} for a {@code null} argument
157      * @see Object#toString
158      * @see String#valueOf(Object)
159      */
160     public static String toString(Object o) {
161         return String.valueOf(o);
162     }
163 
164     /**
165      * Returns the result of calling {@code toString} on the first
166      * argument if the first argument is not {@code null} and returns
167      * the second argument otherwise.
168      *
169      * @param o an object
170      * @param nullDefault string to return if the first argument is
171      *        {@code null}
172      * @return the result of calling {@code toString} on the first
173      * argument if it is not {@code null} and the second argument
174      * otherwise.
175      * @see Objects#toString(Object)
176      */
177     public static String toString(Object o, String nullDefault) {
178         return (o != null) ? o.toString() : nullDefault;
179     }
180 
181     /**
182      * Returns 0 if the arguments are identical and {@code
183      * c.compare(a, b)} otherwise.
184      * Consequently, if both arguments are {@code null} 0
185      * is returned.
186      *
187      * &lt;p&gt;Note that if one of the arguments is {@code null}, a {@code
188      * NullPointerException} may or may not be thrown depending on
189      * what ordering policy, if any, the {@link Comparator Comparator}
190      * chooses to have for {@code null} values.
191      *
192      * @param &lt;T&gt; the type of the objects being compared
193      * @param a an object
194      * @param b an object to be compared with {@code a}
195      * @param c the {@code Comparator} to compare the first two arguments
196      * @return 0 if the arguments are identical and {@code
197      * c.compare(a, b)} otherwise.
198      * @see Comparable
199      * @see Comparator
200      */
201     public static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c) {
202         return (a == b) ? 0 :  c.compare(a, b);
203     }
204 
205     /**
206      * Checks that the specified object reference is not {@code null}. This
207      * method is designed primarily for doing parameter validation in methods
208      * and constructors, as demonstrated below:
209      * &lt;blockquote&gt;&lt;pre&gt;
210      * public Foo(Bar bar) {
211      *     this.bar = Objects.requireNonNull(bar);
212      * }
213      * &lt;/pre&gt;&lt;/blockquote&gt;
214      *
215      * @param obj the object reference to check for nullity
216      * @param &lt;T&gt; the type of the reference
217      * @return {@code obj} if not {@code null}
218      * @throws NullPointerException if {@code obj} is {@code null}
219      */
220     public static &lt;T&gt; T requireNonNull(T obj) {
221         if (obj == null)
222             throw new NullPointerException();
223         return obj;
224     }
225 
226     /**
227      * Checks that the specified object reference is not {@code null} and
228      * throws a customized {@link NullPointerException} if it is. This method
229      * is designed primarily for doing parameter validation in methods and
230      * constructors with multiple parameters, as demonstrated below:
231      * &lt;blockquote&gt;&lt;pre&gt;
232      * public Foo(Bar bar, Baz baz) {
233      *     this.bar = Objects.requireNonNull(bar, &quot;bar must not be null&quot;);
234      *     this.baz = Objects.requireNonNull(baz, &quot;baz must not be null&quot;);
235      * }
236      * &lt;/pre&gt;&lt;/blockquote&gt;
237      *
238      * @param obj     the object reference to check for nullity
239      * @param message detail message to be used in the event that a {@code
240      *                NullPointerException} is thrown
241      * @param &lt;T&gt; the type of the reference
242      * @return {@code obj} if not {@code null}
243      * @throws NullPointerException if {@code obj} is {@code null}
244      */
245     public static &lt;T&gt; T requireNonNull(T obj, String message) {
246         if (obj == null)
247             throw new NullPointerException(message);
248         return obj;
249     }
250 
251     /**
252      * Returns {@code true} if the provided reference is {@code null} otherwise
253      * returns {@code false}.
254      *
255      * @apiNote This method exists to be used as a
256      * {@link java.util.function.Predicate}, {@code filter(Objects::isNull)}
257      *
258      * @param obj a reference to be checked against {@code null}
259      * @return {@code true} if the provided reference is {@code null} otherwise
260      * {@code false}
261      *
262      * @see java.util.function.Predicate
263      * @since 1.8
264      */
265     public static boolean isNull(Object obj) {
266         return obj == null;
267     }
268 
269     /**
270      * Returns {@code true} if the provided reference is non-{@code null}
271      * otherwise returns {@code false}.
272      *
273      * @apiNote This method exists to be used as a
274      * {@link java.util.function.Predicate}, {@code filter(Objects::nonNull)}
275      *
276      * @param obj a reference to be checked against {@code null}
277      * @return {@code true} if the provided reference is non-{@code null}
278      * otherwise {@code false}
279      *
280      * @see java.util.function.Predicate
281      * @since 1.8
282      */
283     public static boolean nonNull(Object obj) {
284         return obj != null;
285     }
286 
287     /**
288      * Returns the first argument if it is non-{@code null} and
289      * otherwise returns the non-{@code null} second argument.
290      *
291      * @param obj an object
292      * @param defaultObj a non-{@code null} object to return if the first argument
293      *                   is {@code null}
294      * @param &lt;T&gt; the type of the reference
295      * @return the first argument if it is non-{@code null} and
296      *        otherwise the second argument if it is non-{@code null}
297      * @throws NullPointerException if both {@code obj} is null and
298      *        {@code defaultObj} is {@code null}
299      * @since 9
300      */
301     public static &lt;T&gt; T requireNonNullElse(T obj, T defaultObj) {
302         return (obj != null) ? obj : requireNonNull(defaultObj, &quot;defaultObj&quot;);
303     }
304 
305     /**
306      * Returns the first argument if it is non-{@code null} and otherwise
307      * returns the non-{@code null} value of {@code supplier.get()}.
308      *
309      * @param obj an object
310      * @param supplier of a non-{@code null} object to return if the first argument
311      *                 is {@code null}
312      * @param &lt;T&gt; the type of the first argument and return type
313      * @return the first argument if it is non-{@code null} and otherwise
314      *         the value from {@code supplier.get()} if it is non-{@code null}
315      * @throws NullPointerException if both {@code obj} is null and
316      *        either the {@code supplier} is {@code null} or
317      *        the {@code supplier.get()} value is {@code null}
318      * @since 9
319      */
320     public static &lt;T&gt; T requireNonNullElseGet(T obj, Supplier&lt;? extends T&gt; supplier) {
321         return (obj != null) ? obj
322                 : requireNonNull(requireNonNull(supplier, &quot;supplier&quot;).get(), &quot;supplier.get()&quot;);
323     }
324 
325     /**
326      * Checks that the specified object reference is not {@code null} and
327      * throws a customized {@link NullPointerException} if it is.
328      *
329      * &lt;p&gt;Unlike the method {@link #requireNonNull(Object, String)},
330      * this method allows creation of the message to be deferred until
331      * after the null check is made. While this may confer a
332      * performance advantage in the non-null case, when deciding to
333      * call this method care should be taken that the costs of
334      * creating the message supplier are less than the cost of just
335      * creating the string message directly.
336      *
337      * @param obj     the object reference to check for nullity
338      * @param messageSupplier supplier of the detail message to be
339      * used in the event that a {@code NullPointerException} is thrown
340      * @param &lt;T&gt; the type of the reference
341      * @return {@code obj} if not {@code null}
342      * @throws NullPointerException if {@code obj} is {@code null}
343      * @since 1.8
344      */
345     public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) {
346         if (obj == null)
347             throw new NullPointerException(messageSupplier == null ?
348                                            null : messageSupplier.get());
349         return obj;
350     }
351 
352     /**
353      * Checks if the {@code index} is within the bounds of the range from
354      * {@code 0} (inclusive) to {@code length} (exclusive).
355      *
356      * &lt;p&gt;The {@code index} is defined to be out of bounds if any of the
357      * following inequalities is true:
358      * &lt;ul&gt;
359      *  &lt;li&gt;{@code index &lt; 0}&lt;/li&gt;
360      *  &lt;li&gt;{@code index &gt;= length}&lt;/li&gt;
361      *  &lt;li&gt;{@code length &lt; 0}, which is implied from the former inequalities&lt;/li&gt;
362      * &lt;/ul&gt;
363      *
364      * @param index the index
365      * @param length the upper-bound (exclusive) of the range
366      * @return {@code index} if it is within bounds of the range
367      * @throws IndexOutOfBoundsException if the {@code index} is out of bounds
368      * @since 9
369      */
370     @ForceInline
371     public static
372     int checkIndex(int index, int length) {
373         return Preconditions.checkIndex(index, length, null);
374     }
375 
376     /**
377      * Checks if the sub-range from {@code fromIndex} (inclusive) to
378      * {@code toIndex} (exclusive) is within the bounds of range from {@code 0}
379      * (inclusive) to {@code length} (exclusive).
380      *
381      * &lt;p&gt;The sub-range is defined to be out of bounds if any of the following
382      * inequalities is true:
383      * &lt;ul&gt;
384      *  &lt;li&gt;{@code fromIndex &lt; 0}&lt;/li&gt;
385      *  &lt;li&gt;{@code fromIndex &gt; toIndex}&lt;/li&gt;
386      *  &lt;li&gt;{@code toIndex &gt; length}&lt;/li&gt;
387      *  &lt;li&gt;{@code length &lt; 0}, which is implied from the former inequalities&lt;/li&gt;
388      * &lt;/ul&gt;
389      *
390      * @param fromIndex the lower-bound (inclusive) of the sub-range
391      * @param toIndex the upper-bound (exclusive) of the sub-range
392      * @param length the upper-bound (exclusive) the range
393      * @return {@code fromIndex} if the sub-range within bounds of the range
394      * @throws IndexOutOfBoundsException if the sub-range is out of bounds
395      * @since 9
396      */
397     public static
398     int checkFromToIndex(int fromIndex, int toIndex, int length) {
399         return Preconditions.checkFromToIndex(fromIndex, toIndex, length, null);
400     }
401 
402     /**
403      * Checks if the sub-range from {@code fromIndex} (inclusive) to
404      * {@code fromIndex + size} (exclusive) is within the bounds of range from
405      * {@code 0} (inclusive) to {@code length} (exclusive).
406      *
407      * &lt;p&gt;The sub-range is defined to be out of bounds if any of the following
408      * inequalities is true:
409      * &lt;ul&gt;
410      *  &lt;li&gt;{@code fromIndex &lt; 0}&lt;/li&gt;
411      *  &lt;li&gt;{@code size &lt; 0}&lt;/li&gt;
412      *  &lt;li&gt;{@code fromIndex + size &gt; length}, taking into account integer overflow&lt;/li&gt;
413      *  &lt;li&gt;{@code length &lt; 0}, which is implied from the former inequalities&lt;/li&gt;
414      * &lt;/ul&gt;
415      *
416      * @param fromIndex the lower-bound (inclusive) of the sub-interval
417      * @param size the size of the sub-range
418      * @param length the upper-bound (exclusive) of the range
419      * @return {@code fromIndex} if the sub-range within bounds of the range
420      * @throws IndexOutOfBoundsException if the sub-range is out of bounds
421      * @since 9
422      */
423     public static
424     int checkFromIndexSize(int fromIndex, int size, int length) {
425         return Preconditions.checkFromIndexSize(fromIndex, size, length, null);
426     }
427 
428 }
    </pre>
  </body>
</html>
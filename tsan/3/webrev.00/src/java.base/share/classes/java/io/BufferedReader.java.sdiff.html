<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/BufferedReader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="BufferedOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BufferedWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/BufferedReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 78     private static final int UNMARKED = -1;
 79     private int markedChar = UNMARKED;
 80     private int readAheadLimit = 0; /* Valid only when markedChar &gt; 0 */
 81 
 82     /** If the next character is a line feed, skip it */
 83     private boolean skipLF = false;
 84 
 85     /** The skipLF flag when the mark was set */
 86     private boolean markedSkipLF = false;
 87 
 88     private static int defaultCharBufferSize = 8192;
 89     private static int defaultExpectedLineLength = 80;
 90 
 91     /**
 92      * Creates a buffering character-input stream that uses an input buffer of
 93      * the specified size.
 94      *
 95      * @param  in   A Reader
 96      * @param  sz   Input-buffer size
 97      *
<span class="line-modified"> 98      * @exception  IllegalArgumentException  If {@code sz &lt;= 0}</span>
 99      */
100     public BufferedReader(Reader in, int sz) {
101         super(in);
102         if (sz &lt;= 0)
103             throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
104         this.in = in;
105         cb = new char[sz];
106         nextChar = nChars = 0;
107     }
108 
109     /**
110      * Creates a buffering character-input stream that uses a default-sized
111      * input buffer.
112      *
113      * @param  in   A Reader
114      */
115     public BufferedReader(Reader in) {
116         this(in, defaultCharBufferSize);
117     }
118 
</pre>
<hr />
<pre>
155                 nextChar = nChars = delta;
156             }
157         }
158 
159         int n;
160         do {
161             n = in.read(cb, dst, cb.length - dst);
162         } while (n == 0);
163         if (n &gt; 0) {
164             nChars = dst + n;
165             nextChar = dst;
166         }
167     }
168 
169     /**
170      * Reads a single character.
171      *
172      * @return The character read, as an integer in the range
173      *         0 to 65535 ({@code 0x00-0xffff}), or -1 if the
174      *         end of the stream has been reached
<span class="line-modified">175      * @exception  IOException  If an I/O error occurs</span>
176      */
177     public int read() throws IOException {
178         synchronized (lock) {
179             ensureOpen();
180             for (;;) {
181                 if (nextChar &gt;= nChars) {
182                     fill();
183                     if (nextChar &gt;= nChars)
184                         return -1;
185                 }
186                 if (skipLF) {
187                     skipLF = false;
188                     if (cb[nextChar] == &#39;\n&#39;) {
189                         nextChar++;
190                         continue;
191                     }
192                 }
193                 return cb[nextChar++];
194             }
195         }
</pre>
<hr />
<pre>
218                 nextChar++;
219                 if (nextChar &gt;= nChars)
220                     fill();
221                 if (nextChar &gt;= nChars)
222                     return -1;
223             }
224         }
225         int n = Math.min(len, nChars - nextChar);
226         System.arraycopy(cb, nextChar, cbuf, off, n);
227         nextChar += n;
228         return n;
229     }
230 
231     /**
232      * Reads characters into a portion of an array.
233      *
234      * &lt;p&gt; This method implements the general contract of the corresponding
235      * &lt;code&gt;{@link Reader#read(char[], int, int) read}&lt;/code&gt; method of the
236      * &lt;code&gt;{@link Reader}&lt;/code&gt; class.  As an additional convenience, it
237      * attempts to read as many characters as possible by repeatedly invoking
<span class="line-modified">238      * the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This iterated</span>
<span class="line-modified">239      * &lt;code&gt;read&lt;/code&gt; continues until one of the following conditions becomes</span>
240      * true: &lt;ul&gt;
241      *
242      *   &lt;li&gt; The specified number of characters have been read,
243      *
<span class="line-modified">244      *   &lt;li&gt; The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns</span>
<span class="line-modified">245      *   &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or</span>
246      *
<span class="line-modified">247      *   &lt;li&gt; The &lt;code&gt;ready&lt;/code&gt; method of the underlying stream</span>
<span class="line-modified">248      *   returns &lt;code&gt;false&lt;/code&gt;, indicating that further input requests</span>
249      *   would block.
250      *
<span class="line-modified">251      * &lt;/ul&gt; If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns</span>
<span class="line-modified">252      * &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns</span>
<span class="line-modified">253      * &lt;code&gt;-1&lt;/code&gt;.  Otherwise this method returns the number of characters</span>
254      * actually read.
255      *
256      * &lt;p&gt; Subclasses of this class are encouraged, but not required, to
257      * attempt to read as many characters as possible in the same fashion.
258      *
259      * &lt;p&gt; Ordinarily this method takes characters from this stream&#39;s character
260      * buffer, filling it from the underlying stream as necessary.  If,
261      * however, the buffer is empty, the mark is not valid, and the requested
262      * length is at least as large as the buffer, then this method will read
263      * characters directly from the underlying stream into the given array.
<span class="line-modified">264      * Thus redundant &lt;code&gt;BufferedReader&lt;/code&gt;s will not copy data</span>
265      * unnecessarily.
266      *
267      * @param      cbuf  Destination buffer
268      * @param      off   Offset at which to start storing characters
269      * @param      len   Maximum number of characters to read
270      *
271      * @return     The number of characters read, or -1 if the end of the
272      *             stream has been reached
273      *
<span class="line-modified">274      * @exception  IOException  If an I/O error occurs</span>
<span class="line-modified">275      * @exception  IndexOutOfBoundsException {@inheritDoc}</span>
276      */
277     public int read(char cbuf[], int off, int len) throws IOException {
278         synchronized (lock) {
279             ensureOpen();
280             if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||
281                 ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) {
282                 throw new IndexOutOfBoundsException();
283             } else if (len == 0) {
284                 return 0;
285             }
286 
287             int n = read1(cbuf, off, len);
288             if (n &lt;= 0) return n;
289             while ((n &lt; len) &amp;&amp; in.ready()) {
290                 int n1 = read1(cbuf, off + n, len - n);
291                 if (n1 &lt;= 0) break;
292                 n += n1;
293             }
294             return n;
295         }
296     }
297 
298     /**
299      * Reads a line of text.  A line is considered to be terminated by any one
300      * of a line feed (&#39;\n&#39;), a carriage return (&#39;\r&#39;), a carriage return
301      * followed immediately by a line feed, or by reaching the end-of-file
302      * (EOF).
303      *
304      * @param      ignoreLF  If true, the next &#39;\n&#39; will be skipped
305      *
306      * @return     A String containing the contents of the line, not including
307      *             any line-termination characters, or null if the end of the
308      *             stream has been reached without reading any characters
309      *
310      * @see        java.io.LineNumberReader#readLine()
311      *
<span class="line-modified">312      * @exception  IOException  If an I/O error occurs</span>
313      */
314     String readLine(boolean ignoreLF) throws IOException {
<span class="line-modified">315         StringBuffer s = null;</span>
316         int startChar;
317 
318         synchronized (lock) {
319             ensureOpen();
320             boolean omitLF = ignoreLF || skipLF;
321 
322         bufferLoop:
323             for (;;) {
324 
325                 if (nextChar &gt;= nChars)
326                     fill();
327                 if (nextChar &gt;= nChars) { /* EOF */
328                     if (s != null &amp;&amp; s.length() &gt; 0)
329                         return s.toString();
330                     else
331                         return null;
332                 }
333                 boolean eol = false;
334                 char c = 0;
335                 int i;
</pre>
<hr />
<pre>
351 
352                 startChar = nextChar;
353                 nextChar = i;
354 
355                 if (eol) {
356                     String str;
357                     if (s == null) {
358                         str = new String(cb, startChar, i - startChar);
359                     } else {
360                         s.append(cb, startChar, i - startChar);
361                         str = s.toString();
362                     }
363                     nextChar++;
364                     if (c == &#39;\r&#39;) {
365                         skipLF = true;
366                     }
367                     return str;
368                 }
369 
370                 if (s == null)
<span class="line-modified">371                     s = new StringBuffer(defaultExpectedLineLength);</span>
372                 s.append(cb, startChar, i - startChar);
373             }
374         }
375     }
376 
377     /**
378      * Reads a line of text.  A line is considered to be terminated by any one
379      * of a line feed (&#39;\n&#39;), a carriage return (&#39;\r&#39;), a carriage return
380      * followed immediately by a line feed, or by reaching the end-of-file
381      * (EOF).
382      *
383      * @return     A String containing the contents of the line, not including
384      *             any line-termination characters, or null if the end of the
385      *             stream has been reached without reading any characters
386      *
<span class="line-modified">387      * @exception  IOException  If an I/O error occurs</span>
388      *
389      * @see java.nio.file.Files#readAllLines
390      */
391     public String readLine() throws IOException {
392         return readLine(false);
393     }
394 
395     /**
396      * Skips characters.
397      *
398      * @param  n  The number of characters to skip
399      *
400      * @return    The number of characters actually skipped
401      *
<span class="line-modified">402      * @exception  IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</span>
<span class="line-modified">403      * @exception  IOException  If an I/O error occurs</span>
404      */
405     public long skip(long n) throws IOException {
406         if (n &lt; 0L) {
407             throw new IllegalArgumentException(&quot;skip value is negative&quot;);
408         }
409         synchronized (lock) {
410             ensureOpen();
411             long r = n;
412             while (r &gt; 0) {
413                 if (nextChar &gt;= nChars)
414                     fill();
415                 if (nextChar &gt;= nChars) /* EOF */
416                     break;
417                 if (skipLF) {
418                     skipLF = false;
419                     if (cb[nextChar] == &#39;\n&#39;) {
420                         nextChar++;
421                     }
422                 }
423                 long d = nChars - nextChar;
424                 if (r &lt;= d) {
425                     nextChar += r;
426                     r = 0;
427                     break;
428                 }
429                 else {
430                     r -= d;
431                     nextChar = nChars;
432                 }
433             }
434             return n - r;
435         }
436     }
437 
438     /**
439      * Tells whether this stream is ready to be read.  A buffered character
440      * stream is ready if the buffer is not empty, or if the underlying
441      * character stream is ready.
442      *
<span class="line-modified">443      * @exception  IOException  If an I/O error occurs</span>
444      */
445     public boolean ready() throws IOException {
446         synchronized (lock) {
447             ensureOpen();
448 
449             /*
450              * If newline needs to be skipped and the next char to be read
451              * is a newline character, then just skip it right away.
452              */
453             if (skipLF) {
454                 /* Note that in.ready() will return true if and only if the next
455                  * read on the stream will not block.
456                  */
457                 if (nextChar &gt;= nChars &amp;&amp; in.ready()) {
458                     fill();
459                 }
460                 if (nextChar &lt; nChars) {
461                     if (cb[nextChar] == &#39;\n&#39;)
462                         nextChar++;
463                     skipLF = false;
</pre>
<hr />
<pre>
470     /**
471      * Tells whether this stream supports the mark() operation, which it does.
472      */
473     public boolean markSupported() {
474         return true;
475     }
476 
477     /**
478      * Marks the present position in the stream.  Subsequent calls to reset()
479      * will attempt to reposition the stream to this point.
480      *
481      * @param readAheadLimit   Limit on the number of characters that may be
482      *                         read while still preserving the mark. An attempt
483      *                         to reset the stream after reading characters
484      *                         up to this limit or beyond may fail.
485      *                         A limit value larger than the size of the input
486      *                         buffer will cause a new buffer to be allocated
487      *                         whose size is no smaller than limit.
488      *                         Therefore large values should be used with care.
489      *
<span class="line-modified">490      * @exception  IllegalArgumentException  If {@code readAheadLimit &lt; 0}</span>
<span class="line-modified">491      * @exception  IOException  If an I/O error occurs</span>
492      */
493     public void mark(int readAheadLimit) throws IOException {
494         if (readAheadLimit &lt; 0) {
495             throw new IllegalArgumentException(&quot;Read-ahead limit &lt; 0&quot;);
496         }
497         synchronized (lock) {
498             ensureOpen();
499             this.readAheadLimit = readAheadLimit;
500             markedChar = nextChar;
501             markedSkipLF = skipLF;
502         }
503     }
504 
505     /**
506      * Resets the stream to the most recent mark.
507      *
<span class="line-modified">508      * @exception  IOException  If the stream has never been marked,</span>
509      *                          or if the mark has been invalidated
510      */
511     public void reset() throws IOException {
512         synchronized (lock) {
513             ensureOpen();
514             if (markedChar &lt; 0)
515                 throw new IOException((markedChar == INVALIDATED)
516                                       ? &quot;Mark invalid&quot;
517                                       : &quot;Stream not marked&quot;);
518             nextChar = markedChar;
519             skipLF = markedSkipLF;
520         }
521     }
522 
523     public void close() throws IOException {
524         synchronized (lock) {
525             if (in == null)
526                 return;
527             try {
528                 in.close();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 78     private static final int UNMARKED = -1;
 79     private int markedChar = UNMARKED;
 80     private int readAheadLimit = 0; /* Valid only when markedChar &gt; 0 */
 81 
 82     /** If the next character is a line feed, skip it */
 83     private boolean skipLF = false;
 84 
 85     /** The skipLF flag when the mark was set */
 86     private boolean markedSkipLF = false;
 87 
 88     private static int defaultCharBufferSize = 8192;
 89     private static int defaultExpectedLineLength = 80;
 90 
 91     /**
 92      * Creates a buffering character-input stream that uses an input buffer of
 93      * the specified size.
 94      *
 95      * @param  in   A Reader
 96      * @param  sz   Input-buffer size
 97      *
<span class="line-modified"> 98      * @throws IllegalArgumentException  If {@code sz &lt;= 0}</span>
 99      */
100     public BufferedReader(Reader in, int sz) {
101         super(in);
102         if (sz &lt;= 0)
103             throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
104         this.in = in;
105         cb = new char[sz];
106         nextChar = nChars = 0;
107     }
108 
109     /**
110      * Creates a buffering character-input stream that uses a default-sized
111      * input buffer.
112      *
113      * @param  in   A Reader
114      */
115     public BufferedReader(Reader in) {
116         this(in, defaultCharBufferSize);
117     }
118 
</pre>
<hr />
<pre>
155                 nextChar = nChars = delta;
156             }
157         }
158 
159         int n;
160         do {
161             n = in.read(cb, dst, cb.length - dst);
162         } while (n == 0);
163         if (n &gt; 0) {
164             nChars = dst + n;
165             nextChar = dst;
166         }
167     }
168 
169     /**
170      * Reads a single character.
171      *
172      * @return The character read, as an integer in the range
173      *         0 to 65535 ({@code 0x00-0xffff}), or -1 if the
174      *         end of the stream has been reached
<span class="line-modified">175      * @throws     IOException  If an I/O error occurs</span>
176      */
177     public int read() throws IOException {
178         synchronized (lock) {
179             ensureOpen();
180             for (;;) {
181                 if (nextChar &gt;= nChars) {
182                     fill();
183                     if (nextChar &gt;= nChars)
184                         return -1;
185                 }
186                 if (skipLF) {
187                     skipLF = false;
188                     if (cb[nextChar] == &#39;\n&#39;) {
189                         nextChar++;
190                         continue;
191                     }
192                 }
193                 return cb[nextChar++];
194             }
195         }
</pre>
<hr />
<pre>
218                 nextChar++;
219                 if (nextChar &gt;= nChars)
220                     fill();
221                 if (nextChar &gt;= nChars)
222                     return -1;
223             }
224         }
225         int n = Math.min(len, nChars - nextChar);
226         System.arraycopy(cb, nextChar, cbuf, off, n);
227         nextChar += n;
228         return n;
229     }
230 
231     /**
232      * Reads characters into a portion of an array.
233      *
234      * &lt;p&gt; This method implements the general contract of the corresponding
235      * &lt;code&gt;{@link Reader#read(char[], int, int) read}&lt;/code&gt; method of the
236      * &lt;code&gt;{@link Reader}&lt;/code&gt; class.  As an additional convenience, it
237      * attempts to read as many characters as possible by repeatedly invoking
<span class="line-modified">238      * the {@code read} method of the underlying stream.  This iterated</span>
<span class="line-modified">239      * {@code read} continues until one of the following conditions becomes</span>
240      * true: &lt;ul&gt;
241      *
242      *   &lt;li&gt; The specified number of characters have been read,
243      *
<span class="line-modified">244      *   &lt;li&gt; The {@code read} method of the underlying stream returns</span>
<span class="line-modified">245      *   {@code -1}, indicating end-of-file, or</span>
246      *
<span class="line-modified">247      *   &lt;li&gt; The {@code ready} method of the underlying stream</span>
<span class="line-modified">248      *   returns {@code false}, indicating that further input requests</span>
249      *   would block.
250      *
<span class="line-modified">251      * &lt;/ul&gt; If the first {@code read} on the underlying stream returns</span>
<span class="line-modified">252      * {@code -1} to indicate end-of-file then this method returns</span>
<span class="line-modified">253      * {@code -1}.  Otherwise this method returns the number of characters</span>
254      * actually read.
255      *
256      * &lt;p&gt; Subclasses of this class are encouraged, but not required, to
257      * attempt to read as many characters as possible in the same fashion.
258      *
259      * &lt;p&gt; Ordinarily this method takes characters from this stream&#39;s character
260      * buffer, filling it from the underlying stream as necessary.  If,
261      * however, the buffer is empty, the mark is not valid, and the requested
262      * length is at least as large as the buffer, then this method will read
263      * characters directly from the underlying stream into the given array.
<span class="line-modified">264      * Thus redundant {@code BufferedReader}s will not copy data</span>
265      * unnecessarily.
266      *
267      * @param      cbuf  Destination buffer
268      * @param      off   Offset at which to start storing characters
269      * @param      len   Maximum number of characters to read
270      *
271      * @return     The number of characters read, or -1 if the end of the
272      *             stream has been reached
273      *
<span class="line-modified">274      * @throws     IOException  If an I/O error occurs</span>
<span class="line-modified">275      * @throws     IndexOutOfBoundsException {@inheritDoc}</span>
276      */
277     public int read(char cbuf[], int off, int len) throws IOException {
278         synchronized (lock) {
279             ensureOpen();
280             if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||
281                 ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) {
282                 throw new IndexOutOfBoundsException();
283             } else if (len == 0) {
284                 return 0;
285             }
286 
287             int n = read1(cbuf, off, len);
288             if (n &lt;= 0) return n;
289             while ((n &lt; len) &amp;&amp; in.ready()) {
290                 int n1 = read1(cbuf, off + n, len - n);
291                 if (n1 &lt;= 0) break;
292                 n += n1;
293             }
294             return n;
295         }
296     }
297 
298     /**
299      * Reads a line of text.  A line is considered to be terminated by any one
300      * of a line feed (&#39;\n&#39;), a carriage return (&#39;\r&#39;), a carriage return
301      * followed immediately by a line feed, or by reaching the end-of-file
302      * (EOF).
303      *
304      * @param      ignoreLF  If true, the next &#39;\n&#39; will be skipped
305      *
306      * @return     A String containing the contents of the line, not including
307      *             any line-termination characters, or null if the end of the
308      *             stream has been reached without reading any characters
309      *
310      * @see        java.io.LineNumberReader#readLine()
311      *
<span class="line-modified">312      * @throws     IOException  If an I/O error occurs</span>
313      */
314     String readLine(boolean ignoreLF) throws IOException {
<span class="line-modified">315         StringBuilder s = null;</span>
316         int startChar;
317 
318         synchronized (lock) {
319             ensureOpen();
320             boolean omitLF = ignoreLF || skipLF;
321 
322         bufferLoop:
323             for (;;) {
324 
325                 if (nextChar &gt;= nChars)
326                     fill();
327                 if (nextChar &gt;= nChars) { /* EOF */
328                     if (s != null &amp;&amp; s.length() &gt; 0)
329                         return s.toString();
330                     else
331                         return null;
332                 }
333                 boolean eol = false;
334                 char c = 0;
335                 int i;
</pre>
<hr />
<pre>
351 
352                 startChar = nextChar;
353                 nextChar = i;
354 
355                 if (eol) {
356                     String str;
357                     if (s == null) {
358                         str = new String(cb, startChar, i - startChar);
359                     } else {
360                         s.append(cb, startChar, i - startChar);
361                         str = s.toString();
362                     }
363                     nextChar++;
364                     if (c == &#39;\r&#39;) {
365                         skipLF = true;
366                     }
367                     return str;
368                 }
369 
370                 if (s == null)
<span class="line-modified">371                     s = new StringBuilder(defaultExpectedLineLength);</span>
372                 s.append(cb, startChar, i - startChar);
373             }
374         }
375     }
376 
377     /**
378      * Reads a line of text.  A line is considered to be terminated by any one
379      * of a line feed (&#39;\n&#39;), a carriage return (&#39;\r&#39;), a carriage return
380      * followed immediately by a line feed, or by reaching the end-of-file
381      * (EOF).
382      *
383      * @return     A String containing the contents of the line, not including
384      *             any line-termination characters, or null if the end of the
385      *             stream has been reached without reading any characters
386      *
<span class="line-modified">387      * @throws     IOException  If an I/O error occurs</span>
388      *
389      * @see java.nio.file.Files#readAllLines
390      */
391     public String readLine() throws IOException {
392         return readLine(false);
393     }
394 
395     /**
396      * Skips characters.
397      *
398      * @param  n  The number of characters to skip
399      *
400      * @return    The number of characters actually skipped
401      *
<span class="line-modified">402      * @throws     IllegalArgumentException  If {@code n} is negative.</span>
<span class="line-modified">403      * @throws     IOException  If an I/O error occurs</span>
404      */
405     public long skip(long n) throws IOException {
406         if (n &lt; 0L) {
407             throw new IllegalArgumentException(&quot;skip value is negative&quot;);
408         }
409         synchronized (lock) {
410             ensureOpen();
411             long r = n;
412             while (r &gt; 0) {
413                 if (nextChar &gt;= nChars)
414                     fill();
415                 if (nextChar &gt;= nChars) /* EOF */
416                     break;
417                 if (skipLF) {
418                     skipLF = false;
419                     if (cb[nextChar] == &#39;\n&#39;) {
420                         nextChar++;
421                     }
422                 }
423                 long d = nChars - nextChar;
424                 if (r &lt;= d) {
425                     nextChar += r;
426                     r = 0;
427                     break;
428                 }
429                 else {
430                     r -= d;
431                     nextChar = nChars;
432                 }
433             }
434             return n - r;
435         }
436     }
437 
438     /**
439      * Tells whether this stream is ready to be read.  A buffered character
440      * stream is ready if the buffer is not empty, or if the underlying
441      * character stream is ready.
442      *
<span class="line-modified">443      * @throws     IOException  If an I/O error occurs</span>
444      */
445     public boolean ready() throws IOException {
446         synchronized (lock) {
447             ensureOpen();
448 
449             /*
450              * If newline needs to be skipped and the next char to be read
451              * is a newline character, then just skip it right away.
452              */
453             if (skipLF) {
454                 /* Note that in.ready() will return true if and only if the next
455                  * read on the stream will not block.
456                  */
457                 if (nextChar &gt;= nChars &amp;&amp; in.ready()) {
458                     fill();
459                 }
460                 if (nextChar &lt; nChars) {
461                     if (cb[nextChar] == &#39;\n&#39;)
462                         nextChar++;
463                     skipLF = false;
</pre>
<hr />
<pre>
470     /**
471      * Tells whether this stream supports the mark() operation, which it does.
472      */
473     public boolean markSupported() {
474         return true;
475     }
476 
477     /**
478      * Marks the present position in the stream.  Subsequent calls to reset()
479      * will attempt to reposition the stream to this point.
480      *
481      * @param readAheadLimit   Limit on the number of characters that may be
482      *                         read while still preserving the mark. An attempt
483      *                         to reset the stream after reading characters
484      *                         up to this limit or beyond may fail.
485      *                         A limit value larger than the size of the input
486      *                         buffer will cause a new buffer to be allocated
487      *                         whose size is no smaller than limit.
488      *                         Therefore large values should be used with care.
489      *
<span class="line-modified">490      * @throws     IllegalArgumentException  If {@code readAheadLimit &lt; 0}</span>
<span class="line-modified">491      * @throws     IOException  If an I/O error occurs</span>
492      */
493     public void mark(int readAheadLimit) throws IOException {
494         if (readAheadLimit &lt; 0) {
495             throw new IllegalArgumentException(&quot;Read-ahead limit &lt; 0&quot;);
496         }
497         synchronized (lock) {
498             ensureOpen();
499             this.readAheadLimit = readAheadLimit;
500             markedChar = nextChar;
501             markedSkipLF = skipLF;
502         }
503     }
504 
505     /**
506      * Resets the stream to the most recent mark.
507      *
<span class="line-modified">508      * @throws     IOException  If the stream has never been marked,</span>
509      *                          or if the mark has been invalidated
510      */
511     public void reset() throws IOException {
512         synchronized (lock) {
513             ensureOpen();
514             if (markedChar &lt; 0)
515                 throw new IOException((markedChar == INVALIDATED)
516                                       ? &quot;Mark invalid&quot;
517                                       : &quot;Stream not marked&quot;);
518             nextChar = markedChar;
519             skipLF = markedSkipLF;
520         }
521     }
522 
523     public void close() throws IOException {
524         synchronized (lock) {
525             if (in == null)
526                 return;
527             try {
528                 in.close();
</pre>
</td>
</tr>
</table>
<center><a href="BufferedOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BufferedWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
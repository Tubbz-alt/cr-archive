<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/EnumMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="EmptyStackException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EnumSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/EnumMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
737     }
738 
739     /**
740      * Throws an exception if e is not of the correct type for this enum set.
741      */
742     private void typeCheck(K key) {
743         Class&lt;?&gt; keyClass = key.getClass();
744         if (keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)
745             throw new ClassCastException(keyClass + &quot; != &quot; + keyType);
746     }
747 
748     /**
749      * Returns all of the values comprising K.
750      * The result is uncloned, cached, and shared by all callers.
751      */
752     private static &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) {
753         return SharedSecrets.getJavaLangAccess()
754                                         .getEnumConstantsShared(keyType);
755     }
756 

757     private static final long serialVersionUID = 458661240069192865L;
758 
759     /**
760      * Save the state of the {@code EnumMap} instance to a stream (i.e.,
761      * serialize it).
762      *
763      * @serialData The &lt;i&gt;size&lt;/i&gt; of the enum map (the number of key-value
764      *             mappings) is emitted (int), followed by the key (Object)
765      *             and value (Object) for each key-value mapping represented
766      *             by the enum map.
767      */

768     private void writeObject(java.io.ObjectOutputStream s)
769         throws java.io.IOException
770     {
771         // Write out the key type and any hidden stuff
772         s.defaultWriteObject();
773 
774         // Write out size (number of Mappings)
775         s.writeInt(size);
776 
777         // Write out keys and values (alternating)
778         int entriesToBeWritten = size;
779         for (int i = 0; entriesToBeWritten &gt; 0; i++) {
780             if (null != vals[i]) {
781                 s.writeObject(keyUniverse[i]);
782                 s.writeObject(unmaskNull(vals[i]));
783                 entriesToBeWritten--;
784             }
785         }
786     }
787 
788     /**
789      * Reconstitute the {@code EnumMap} instance from a stream (i.e.,
790      * deserialize it).
791      */
792     @SuppressWarnings(&quot;unchecked&quot;)

793     private void readObject(java.io.ObjectInputStream s)
794         throws java.io.IOException, ClassNotFoundException
795     {
796         // Read in the key type and any hidden stuff
797         s.defaultReadObject();
798 
799         keyUniverse = getKeyUniverse(keyType);
800         vals = new Object[keyUniverse.length];
801 
802         // Read in size (number of Mappings)
803         int size = s.readInt();
804 
805         // Read the keys and values, and put the mappings in the HashMap
806         for (int i = 0; i &lt; size; i++) {
807             K key = (K) s.readObject();
808             V value = (V) s.readObject();
809             put(key, value);
810         }
811     }
812 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
737     }
738 
739     /**
740      * Throws an exception if e is not of the correct type for this enum set.
741      */
742     private void typeCheck(K key) {
743         Class&lt;?&gt; keyClass = key.getClass();
744         if (keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)
745             throw new ClassCastException(keyClass + &quot; != &quot; + keyType);
746     }
747 
748     /**
749      * Returns all of the values comprising K.
750      * The result is uncloned, cached, and shared by all callers.
751      */
752     private static &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) {
753         return SharedSecrets.getJavaLangAccess()
754                                         .getEnumConstantsShared(keyType);
755     }
756 
<span class="line-added">757     @java.io.Serial</span>
758     private static final long serialVersionUID = 458661240069192865L;
759 
760     /**
761      * Save the state of the {@code EnumMap} instance to a stream (i.e.,
762      * serialize it).
763      *
764      * @serialData The &lt;i&gt;size&lt;/i&gt; of the enum map (the number of key-value
765      *             mappings) is emitted (int), followed by the key (Object)
766      *             and value (Object) for each key-value mapping represented
767      *             by the enum map.
768      */
<span class="line-added">769     @java.io.Serial</span>
770     private void writeObject(java.io.ObjectOutputStream s)
771         throws java.io.IOException
772     {
773         // Write out the key type and any hidden stuff
774         s.defaultWriteObject();
775 
776         // Write out size (number of Mappings)
777         s.writeInt(size);
778 
779         // Write out keys and values (alternating)
780         int entriesToBeWritten = size;
781         for (int i = 0; entriesToBeWritten &gt; 0; i++) {
782             if (null != vals[i]) {
783                 s.writeObject(keyUniverse[i]);
784                 s.writeObject(unmaskNull(vals[i]));
785                 entriesToBeWritten--;
786             }
787         }
788     }
789 
790     /**
791      * Reconstitute the {@code EnumMap} instance from a stream (i.e.,
792      * deserialize it).
793      */
794     @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-added">795     @java.io.Serial</span>
796     private void readObject(java.io.ObjectInputStream s)
797         throws java.io.IOException, ClassNotFoundException
798     {
799         // Read in the key type and any hidden stuff
800         s.defaultReadObject();
801 
802         keyUniverse = getKeyUniverse(keyType);
803         vals = new Object[keyUniverse.length];
804 
805         // Read in size (number of Mappings)
806         int size = s.readInt();
807 
808         // Read the keys and values, and put the mappings in the HashMap
809         for (int i = 0; i &lt; size; i++) {
810             K key = (K) s.readObject();
811             V value = (V) s.readObject();
812             put(key, value);
813         }
814     }
815 }
</pre>
</td>
</tr>
</table>
<center><a href="EmptyStackException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EnumSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
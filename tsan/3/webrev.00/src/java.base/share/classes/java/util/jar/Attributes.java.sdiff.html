<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/jar/Attributes.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../doc-files/coll-designfaq.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JarEntry.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/jar/Attributes.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.jar;
 27 
 28 import java.io.DataOutputStream;
 29 import java.io.IOException;
 30 import java.util.Collection;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 import java.util.Objects;
 35 import java.util.Set;
 36 
<span class="line-modified"> 37 import sun.util.logging.PlatformLogger;</span>

 38 
<span class="line-modified"> 39 import static java.nio.charset.StandardCharsets.UTF_8;</span>

 40 
 41 /**
 42  * The Attributes class maps Manifest attribute names to associated string
 43  * values. Valid attribute names are case-insensitive, are restricted to
 44  * the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70
 45  * characters in length. There must be a colon and a SPACE after the name;
 46  * the combined length will not exceed 72 characters.
 47  * Attribute values can contain any characters and
 48  * will be UTF8-encoded when written to the output stream.  See the
 49  * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt;
 50  * for more information about valid attribute names and values.
 51  *
 52  * &lt;p&gt;This map and its views have a predictable iteration order, namely the
 53  * order that keys were inserted into the map, as with {@link LinkedHashMap}.
 54  *
 55  * @author  David Connelly
 56  * @see     Manifest
 57  * @since   1.2
 58  */
 59 public class Attributes implements Map&lt;Object,Object&gt;, Cloneable {
</pre>
<hr />
<pre>
129      * &lt;pre&gt;
130      *     return (String)get(name);
131      * &lt;/pre&gt;
132      *
133      * @param name the Attributes.Name object
134      * @return the String value of the specified Attribute.Name, or null if
135      *         not found.
136      */
137     public String getValue(Name name) {
138         return (String)get(name);
139     }
140 
141     /**
142      * Associates the specified value with the specified attribute name
143      * (key) in this Map. If the Map previously contained a mapping for
144      * the attribute name, the old value is replaced.
145      *
146      * @param name the attribute name
147      * @param value the attribute value
148      * @return the previous value of the attribute, or null if none
<span class="line-modified">149      * @exception ClassCastException if the name is not a Attributes.Name</span>
150      *            or the value is not a String
151      */
152     public Object put(Object name, Object value) {
153         return map.put((Attributes.Name)name, (String)value);
154     }
155 
156     /**
157      * Associates the specified value with the specified attribute name,
158      * specified as a String. The attributes name is case-insensitive.
159      * If the Map previously contained a mapping for the attribute name,
160      * the old value is replaced.
161      * &lt;p&gt;
162      * This method is defined as:
163      * &lt;pre&gt;
164      *      return (String)put(new Attributes.Name(name), value);
165      * &lt;/pre&gt;
166      *
167      * @param name the attribute name as a string
168      * @param value the attribute value
169      * @return the previous value of the attribute, or null if none
<span class="line-modified">170      * @exception IllegalArgumentException if the attribute name is invalid</span>
171      */
172     public String putValue(String name, String value) {
173         return (String)put(Name.of(name), value);
174     }
175 
176     /**
177      * Removes the attribute with the specified name (key) from this Map.
178      * Returns the previous attribute value, or null if none.
179      *
180      * @param name attribute name
181      * @return the previous value of the attribute, or null if none
182      */
183     public Object remove(Object name) {
184         return map.remove(name);
185     }
186 
187     /**
188      * Returns true if this Map maps one or more attribute names (keys)
189      * to the specified value.
190      *
</pre>
<hr />
<pre>
194      */
195     public boolean containsValue(Object value) {
196         return map.containsValue(value);
197     }
198 
199     /**
200      * Returns true if this Map contains the specified attribute name (key).
201      *
202      * @param name the attribute name
203      * @return true if this Map contains the specified attribute name
204      */
205     public boolean containsKey(Object name) {
206         return map.containsKey(name);
207     }
208 
209     /**
210      * Copies all of the attribute name-value mappings from the specified
211      * Attributes to this Map. Duplicate mappings will be replaced.
212      *
213      * @param attr the Attributes to be stored in this map
<span class="line-modified">214      * @exception ClassCastException if attr is not an Attributes</span>
215      */
216     public void putAll(Map&lt;?,?&gt; attr) {
217         // ## javac bug?
218         if (!Attributes.class.isInstance(attr))
219             throw new ClassCastException();
220         for (Map.Entry&lt;?,?&gt; me : (attr).entrySet())
221             put(me.getKey(), me.getValue());
222     }
223 
224     /**
225      * Removes all attributes from this Map.
226      */
227     public void clear() {
228         map.clear();
229     }
230 
231     /**
232      * Returns the number of attributes in this Map.
233      */
234     public int size() {
</pre>
<hr />
<pre>
318      * make sure to write out the MANIFEST_VERSION or SIGNATURE_VERSION
319      * attributes first.
320      *
321      * XXX Need to handle UTF8 values and break up lines longer than 72 bytes
322      */
323     void writeMain(DataOutputStream out) throws IOException {
324         StringBuilder buffer = new StringBuilder(72);
325 
326         // write out the *-Version header first, if it exists
327         String vername = Name.MANIFEST_VERSION.toString();
328         String version = getValue(vername);
329         if (version == null) {
330             vername = Name.SIGNATURE_VERSION.toString();
331             version = getValue(vername);
332         }
333 
334         if (version != null) {
335             buffer.append(vername);
336             buffer.append(&quot;: &quot;);
337             buffer.append(version);
<span class="line-modified">338             out.write(buffer.toString().getBytes(UTF_8));</span>
339             Manifest.println(out);
340         }
341 
342         // write out all attributes except for the version
343         // we wrote out earlier
344         for (Entry&lt;Object, Object&gt; e : entrySet()) {
345             String name = ((Name) e.getKey()).toString();
346             if ((version != null) &amp;&amp; !(name.equalsIgnoreCase(vername))) {
347                 buffer.setLength(0);
348                 buffer.append(name);
349                 buffer.append(&quot;: &quot;);
350                 buffer.append(e.getValue());
351                 Manifest.println72(out, buffer.toString());
352             }
353         }
354 
355         Manifest.println(out); // empty line after main attributes section
356     }
357 
358     /*
</pre>
<hr />
<pre>
380                 --len;
381             }
382             if (len == 0) {
383                 break;
384             }
385             int i = 0;
386             if (lbuf[0] == &#39; &#39;) {
387                 // continuation of previous line
388                 if (name == null) {
389                     throw new IOException(&quot;misplaced continuation line (&quot;
390                                 + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
391                 }
392                 lineContinued = true;
393                 byte[] buf = new byte[lastline.length + len - 1];
394                 System.arraycopy(lastline, 0, buf, 0, lastline.length);
395                 System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);
396                 if (is.peek() == &#39; &#39;) {
397                     lastline = buf;
398                     continue;
399                 }
<span class="line-modified">400                 value = new String(buf, 0, buf.length, UTF_8);</span>
401                 lastline = null;
402             } else {
403                 while (lbuf[i++] != &#39;:&#39;) {
404                     if (i &gt;= len) {
405                         throw new IOException(&quot;invalid header field (&quot;
406                                     + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
407                     }
408                 }
409                 if (lbuf[i++] != &#39; &#39;) {
410                     throw new IOException(&quot;invalid header field (&quot;
411                                 + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
412                 }
<span class="line-modified">413                 name = new String(lbuf, 0, i - 2, UTF_8);</span>
414                 if (is.peek() == &#39; &#39;) {
415                     lastline = new byte[len - i];
416                     System.arraycopy(lbuf, i, lastline, 0, len - i);
417                     continue;
418                 }
<span class="line-modified">419                 value = new String(lbuf, i, len - i, UTF_8);</span>
420             }
421             try {
422                 if ((putValue(name, value) != null) &amp;&amp; (!lineContinued)) {
423                     PlatformLogger.getLogger(&quot;java.util.jar&quot;).warning(
424                                      &quot;Duplicate name in Manifest: &quot; + name
425                                      + &quot;.\n&quot;
426                                      + &quot;Ensure that the manifest does not &quot;
427                                      + &quot;have duplicate entries, and\n&quot;
428                                      + &quot;that blank lines separate &quot;
429                                      + &quot;individual sections in both your\n&quot;
430                                      + &quot;manifest and in the META-INF/MANIFEST.MF &quot;
431                                      + &quot;entry in the jar file.&quot;);
432                 }
433             } catch (IllegalArgumentException e) {
434                 throw new IOException(&quot;invalid header field name: &quot; + name
435                             + &quot; (&quot; + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
436             }
437         }
438         return lineNumber;
439     }
440 
441     /**
442      * The Attributes.Name class represents an attribute name stored in
443      * this Map. Valid attribute names are case-insensitive, are restricted
444      * to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed
445      * 70 characters in length. Attribute values can contain any characters
446      * and will be UTF8-encoded when written to the output stream.  See the
447      * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt;
448      * for more information about valid attribute names and values.
449      */
450     public static class Name {
451         private final String name;
452         private final int hashCode;
453 
454         /**
455          * Avoid allocation for common Names
456          */
<span class="line-modified">457         private static final Map&lt;String, Name&gt; KNOWN_NAMES;</span>
458 
459         static final Name of(String name) {
460             Name n = KNOWN_NAMES.get(name);
461             if (n != null) {
462                 return n;
463             }
464             return new Name(name);
465         }
466 
467         /**
468          * Constructs a new attribute name using the given string name.
469          *
470          * @param name the attribute string name
<span class="line-modified">471          * @exception IllegalArgumentException if the attribute name was</span>
472          *            invalid
<span class="line-modified">473          * @exception NullPointerException if the attribute name was null</span>
474          */
475         public Name(String name) {
476             this.hashCode = hash(name);
477             this.name = name.intern();
478         }
479 
480         // Checks the string is valid
481         private final int hash(String name) {
482             Objects.requireNonNull(name, &quot;name&quot;);
483             int len = name.length();
484             if (len &gt; 70 || len == 0) {
485                 throw new IllegalArgumentException(name);
486             }
487             // Calculate hash code case insensitively
488             int h = 0;
489             for (int i = 0; i &lt; len; i++) {
490                 char c = name.charAt(i);
491                 if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
492                     // hashcode must be identical for upper and lower case
493                     h = h * 31 + (c - 0x20);
</pre>
<hr />
<pre>
524          * Computes the hash value for this attribute name.
525          */
526         public int hashCode() {
527             return hashCode;
528         }
529 
530         /**
531          * Returns the attribute name as a String.
532          */
533         public String toString() {
534             return name;
535         }
536 
537         /**
538          * {@code Name} object for {@code Manifest-Version}
539          * manifest attribute. This attribute indicates the version number
540          * of the manifest standard to which a JAR file&#39;s manifest conforms.
541          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#jar-manifest&quot;&gt;
542          *      Manifest and Signature Specification&lt;/a&gt;
543          */
<span class="line-modified">544         public static final Name MANIFEST_VERSION = new Name(&quot;Manifest-Version&quot;);</span>
545 
546         /**
547          * {@code Name} object for {@code Signature-Version}
548          * manifest attribute used when signing JAR files.
549          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#jar-manifest&quot;&gt;
550          *      Manifest and Signature Specification&lt;/a&gt;
551          */
<span class="line-modified">552         public static final Name SIGNATURE_VERSION = new Name(&quot;Signature-Version&quot;);</span>
553 
554         /**
555          * {@code Name} object for {@code Content-Type}
556          * manifest attribute.
557          */
<span class="line-modified">558         public static final Name CONTENT_TYPE = new Name(&quot;Content-Type&quot;);</span>
559 
560         /**
561          * {@code Name} object for {@code Class-Path}
562          * manifest attribute.
563          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#class-path-attribute&quot;&gt;
564          *      JAR file specification&lt;/a&gt;
565          */
<span class="line-modified">566         public static final Name CLASS_PATH = new Name(&quot;Class-Path&quot;);</span>
567 
568         /**
569          * {@code Name} object for {@code Main-Class} manifest
570          * attribute used for launching applications packaged in JAR files.
571          * The {@code Main-Class} attribute is used in conjunction
572          * with the {@code -jar} command-line option of the
573          * {@code java} application launcher.
574          */
<span class="line-modified">575         public static final Name MAIN_CLASS = new Name(&quot;Main-Class&quot;);</span>
576 
577         /**
578          * {@code Name} object for {@code Sealed} manifest attribute
579          * used for sealing.
580          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
581          *      Package Sealing&lt;/a&gt;
582          */
<span class="line-modified">583         public static final Name SEALED = new Name(&quot;Sealed&quot;);</span>
584 
585         /**
586          * {@code Name} object for {@code Extension-List} manifest attribute
587          * used for the extension mechanism that is no longer supported.
588          */
<span class="line-modified">589         public static final Name EXTENSION_LIST = new Name(&quot;Extension-List&quot;);</span>
590 
591         /**
592          * {@code Name} object for {@code Extension-Name} manifest attribute.
593          * used for the extension mechanism that is no longer supported.
594          */
<span class="line-modified">595         public static final Name EXTENSION_NAME = new Name(&quot;Extension-Name&quot;);</span>
596 
597         /**
598          * {@code Name} object for {@code Extension-Installation} manifest attribute.
599          *
600          * @deprecated Extension mechanism is no longer supported.
601          */
602         @Deprecated
<span class="line-modified">603         public static final Name EXTENSION_INSTALLATION = new Name(&quot;Extension-Installation&quot;);</span>
604 
605         /**
606          * {@code Name} object for {@code Implementation-Title}
607          * manifest attribute used for package versioning.
608          */
<span class="line-modified">609         public static final Name IMPLEMENTATION_TITLE = new Name(&quot;Implementation-Title&quot;);</span>
610 
611         /**
612          * {@code Name} object for {@code Implementation-Version}
613          * manifest attribute used for package versioning.
614          */
<span class="line-modified">615         public static final Name IMPLEMENTATION_VERSION = new Name(&quot;Implementation-Version&quot;);</span>
616 
617         /**
618          * {@code Name} object for {@code Implementation-Vendor}
619          * manifest attribute used for package versioning.
620          */
<span class="line-modified">621         public static final Name IMPLEMENTATION_VENDOR = new Name(&quot;Implementation-Vendor&quot;);</span>
622 
623         /**
624          * {@code Name} object for {@code Implementation-Vendor-Id}
625          * manifest attribute.
626          *
627          * @deprecated Extension mechanism is no longer supported.
628          */
629         @Deprecated
<span class="line-modified">630         public static final Name IMPLEMENTATION_VENDOR_ID = new Name(&quot;Implementation-Vendor-Id&quot;);</span>
631 
632         /**
633          * {@code Name} object for {@code Implementation-URL}
634          * manifest attribute.
635          *
636          * @deprecated Extension mechanism is no longer supported.
637          */
638         @Deprecated
<span class="line-modified">639         public static final Name IMPLEMENTATION_URL = new Name(&quot;Implementation-URL&quot;);</span>
640 
641         /**
642          * {@code Name} object for {@code Specification-Title}
643          * manifest attribute used for package versioning.
644          */
<span class="line-modified">645         public static final Name SPECIFICATION_TITLE = new Name(&quot;Specification-Title&quot;);</span>
646 
647         /**
648          * {@code Name} object for {@code Specification-Version}
649          * manifest attribute used for package versioning.
650          */
<span class="line-modified">651         public static final Name SPECIFICATION_VERSION = new Name(&quot;Specification-Version&quot;);</span>
652 
653         /**
654          * {@code Name} object for {@code Specification-Vendor}
655          * manifest attribute used for package versioning.
656          */
<span class="line-modified">657         public static final Name SPECIFICATION_VENDOR = new Name(&quot;Specification-Vendor&quot;);</span>
658 
659         /**
660          * {@code Name} object for {@code Multi-Release}
661          * manifest attribute that indicates this is a multi-release JAR file.
662          *
663          * @since   9
664          */
<span class="line-modified">665         public static final Name MULTI_RELEASE = new Name(&quot;Multi-Release&quot;);</span>
666 
667         private static void addName(Map&lt;String, Name&gt; names, Name name) {
668             names.put(name.name, name);
669         }
670 
671         static {
<span class="line-modified">672             var names = new HashMap&lt;String, Name&gt;(64);</span>
<span class="line-modified">673             addName(names, MANIFEST_VERSION);</span>
<span class="line-modified">674             addName(names, SIGNATURE_VERSION);</span>
<span class="line-modified">675             addName(names, CONTENT_TYPE);</span>
<span class="line-modified">676             addName(names, CLASS_PATH);</span>
<span class="line-modified">677             addName(names, MAIN_CLASS);</span>
<span class="line-modified">678             addName(names, SEALED);</span>
<span class="line-modified">679             addName(names, EXTENSION_LIST);</span>
<span class="line-modified">680             addName(names, EXTENSION_NAME);</span>
<span class="line-modified">681             addName(names, IMPLEMENTATION_TITLE);</span>
<span class="line-modified">682             addName(names, IMPLEMENTATION_VERSION);</span>
<span class="line-modified">683             addName(names, IMPLEMENTATION_VENDOR);</span>
<span class="line-modified">684             addName(names, SPECIFICATION_TITLE);</span>
<span class="line-modified">685             addName(names, SPECIFICATION_VERSION);</span>
<span class="line-modified">686             addName(names, SPECIFICATION_VENDOR);</span>
<span class="line-modified">687             addName(names, MULTI_RELEASE);</span>
<span class="line-modified">688 </span>
<span class="line-modified">689             // Common attributes used in MANIFEST.MF et.al; adding these has a</span>
<span class="line-modified">690             // small footprint cost, but is likely to be quickly paid for by</span>
<span class="line-modified">691             // reducing allocation when reading and parsing typical manifests</span>
<span class="line-modified">692             addName(names, new Name(&quot;Add-Exports&quot;));</span>
<span class="line-modified">693             addName(names, new Name(&quot;Add-Opens&quot;));</span>
<span class="line-modified">694             addName(names, new Name(&quot;Ant-Version&quot;));</span>
<span class="line-modified">695             addName(names, new Name(&quot;Archiver-Version&quot;));</span>
<span class="line-modified">696             addName(names, new Name(&quot;Build-Jdk&quot;));</span>
<span class="line-modified">697             addName(names, new Name(&quot;Built-By&quot;));</span>
<span class="line-modified">698             addName(names, new Name(&quot;Bnd-LastModified&quot;));</span>
<span class="line-modified">699             addName(names, new Name(&quot;Bundle-Description&quot;));</span>
<span class="line-modified">700             addName(names, new Name(&quot;Bundle-DocURL&quot;));</span>
<span class="line-modified">701             addName(names, new Name(&quot;Bundle-License&quot;));</span>
<span class="line-modified">702             addName(names, new Name(&quot;Bundle-ManifestVersion&quot;));</span>
<span class="line-modified">703             addName(names, new Name(&quot;Bundle-Name&quot;));</span>
<span class="line-modified">704             addName(names, new Name(&quot;Bundle-Vendor&quot;));</span>
<span class="line-modified">705             addName(names, new Name(&quot;Bundle-Version&quot;));</span>
<span class="line-modified">706             addName(names, new Name(&quot;Bundle-SymbolicName&quot;));</span>
<span class="line-modified">707             addName(names, new Name(&quot;Created-By&quot;));</span>
<span class="line-modified">708             addName(names, new Name(&quot;Export-Package&quot;));</span>
<span class="line-modified">709             addName(names, new Name(&quot;Import-Package&quot;));</span>
<span class="line-modified">710             addName(names, new Name(&quot;Name&quot;));</span>
<span class="line-modified">711             addName(names, new Name(&quot;SHA1-Digest&quot;));</span>
<span class="line-modified">712             addName(names, new Name(&quot;X-Compile-Source-JDK&quot;));</span>
<span class="line-modified">713             addName(names, new Name(&quot;X-Compile-Target-JDK&quot;));</span>
<span class="line-modified">714             KNOWN_NAMES = names;</span>






































715         }
716     }
717 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.jar;
 27 
 28 import java.io.DataOutputStream;
 29 import java.io.IOException;
 30 import java.util.Collection;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 import java.util.Objects;
 35 import java.util.Set;
 36 
<span class="line-modified"> 37 import jdk.internal.misc.VM;</span>
<span class="line-added"> 38 import jdk.internal.vm.annotation.Stable;</span>
 39 
<span class="line-modified"> 40 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 41 import sun.util.logging.PlatformLogger;</span>
 42 
 43 /**
 44  * The Attributes class maps Manifest attribute names to associated string
 45  * values. Valid attribute names are case-insensitive, are restricted to
 46  * the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70
 47  * characters in length. There must be a colon and a SPACE after the name;
 48  * the combined length will not exceed 72 characters.
 49  * Attribute values can contain any characters and
 50  * will be UTF8-encoded when written to the output stream.  See the
 51  * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt;
 52  * for more information about valid attribute names and values.
 53  *
 54  * &lt;p&gt;This map and its views have a predictable iteration order, namely the
 55  * order that keys were inserted into the map, as with {@link LinkedHashMap}.
 56  *
 57  * @author  David Connelly
 58  * @see     Manifest
 59  * @since   1.2
 60  */
 61 public class Attributes implements Map&lt;Object,Object&gt;, Cloneable {
</pre>
<hr />
<pre>
131      * &lt;pre&gt;
132      *     return (String)get(name);
133      * &lt;/pre&gt;
134      *
135      * @param name the Attributes.Name object
136      * @return the String value of the specified Attribute.Name, or null if
137      *         not found.
138      */
139     public String getValue(Name name) {
140         return (String)get(name);
141     }
142 
143     /**
144      * Associates the specified value with the specified attribute name
145      * (key) in this Map. If the Map previously contained a mapping for
146      * the attribute name, the old value is replaced.
147      *
148      * @param name the attribute name
149      * @param value the attribute value
150      * @return the previous value of the attribute, or null if none
<span class="line-modified">151      * @throws    ClassCastException if the name is not a Attributes.Name</span>
152      *            or the value is not a String
153      */
154     public Object put(Object name, Object value) {
155         return map.put((Attributes.Name)name, (String)value);
156     }
157 
158     /**
159      * Associates the specified value with the specified attribute name,
160      * specified as a String. The attributes name is case-insensitive.
161      * If the Map previously contained a mapping for the attribute name,
162      * the old value is replaced.
163      * &lt;p&gt;
164      * This method is defined as:
165      * &lt;pre&gt;
166      *      return (String)put(new Attributes.Name(name), value);
167      * &lt;/pre&gt;
168      *
169      * @param name the attribute name as a string
170      * @param value the attribute value
171      * @return the previous value of the attribute, or null if none
<span class="line-modified">172      * @throws    IllegalArgumentException if the attribute name is invalid</span>
173      */
174     public String putValue(String name, String value) {
175         return (String)put(Name.of(name), value);
176     }
177 
178     /**
179      * Removes the attribute with the specified name (key) from this Map.
180      * Returns the previous attribute value, or null if none.
181      *
182      * @param name attribute name
183      * @return the previous value of the attribute, or null if none
184      */
185     public Object remove(Object name) {
186         return map.remove(name);
187     }
188 
189     /**
190      * Returns true if this Map maps one or more attribute names (keys)
191      * to the specified value.
192      *
</pre>
<hr />
<pre>
196      */
197     public boolean containsValue(Object value) {
198         return map.containsValue(value);
199     }
200 
201     /**
202      * Returns true if this Map contains the specified attribute name (key).
203      *
204      * @param name the attribute name
205      * @return true if this Map contains the specified attribute name
206      */
207     public boolean containsKey(Object name) {
208         return map.containsKey(name);
209     }
210 
211     /**
212      * Copies all of the attribute name-value mappings from the specified
213      * Attributes to this Map. Duplicate mappings will be replaced.
214      *
215      * @param attr the Attributes to be stored in this map
<span class="line-modified">216      * @throws    ClassCastException if attr is not an Attributes</span>
217      */
218     public void putAll(Map&lt;?,?&gt; attr) {
219         // ## javac bug?
220         if (!Attributes.class.isInstance(attr))
221             throw new ClassCastException();
222         for (Map.Entry&lt;?,?&gt; me : (attr).entrySet())
223             put(me.getKey(), me.getValue());
224     }
225 
226     /**
227      * Removes all attributes from this Map.
228      */
229     public void clear() {
230         map.clear();
231     }
232 
233     /**
234      * Returns the number of attributes in this Map.
235      */
236     public int size() {
</pre>
<hr />
<pre>
320      * make sure to write out the MANIFEST_VERSION or SIGNATURE_VERSION
321      * attributes first.
322      *
323      * XXX Need to handle UTF8 values and break up lines longer than 72 bytes
324      */
325     void writeMain(DataOutputStream out) throws IOException {
326         StringBuilder buffer = new StringBuilder(72);
327 
328         // write out the *-Version header first, if it exists
329         String vername = Name.MANIFEST_VERSION.toString();
330         String version = getValue(vername);
331         if (version == null) {
332             vername = Name.SIGNATURE_VERSION.toString();
333             version = getValue(vername);
334         }
335 
336         if (version != null) {
337             buffer.append(vername);
338             buffer.append(&quot;: &quot;);
339             buffer.append(version);
<span class="line-modified">340             out.write(buffer.toString().getBytes(UTF_8.INSTANCE));</span>
341             Manifest.println(out);
342         }
343 
344         // write out all attributes except for the version
345         // we wrote out earlier
346         for (Entry&lt;Object, Object&gt; e : entrySet()) {
347             String name = ((Name) e.getKey()).toString();
348             if ((version != null) &amp;&amp; !(name.equalsIgnoreCase(vername))) {
349                 buffer.setLength(0);
350                 buffer.append(name);
351                 buffer.append(&quot;: &quot;);
352                 buffer.append(e.getValue());
353                 Manifest.println72(out, buffer.toString());
354             }
355         }
356 
357         Manifest.println(out); // empty line after main attributes section
358     }
359 
360     /*
</pre>
<hr />
<pre>
382                 --len;
383             }
384             if (len == 0) {
385                 break;
386             }
387             int i = 0;
388             if (lbuf[0] == &#39; &#39;) {
389                 // continuation of previous line
390                 if (name == null) {
391                     throw new IOException(&quot;misplaced continuation line (&quot;
392                                 + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
393                 }
394                 lineContinued = true;
395                 byte[] buf = new byte[lastline.length + len - 1];
396                 System.arraycopy(lastline, 0, buf, 0, lastline.length);
397                 System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);
398                 if (is.peek() == &#39; &#39;) {
399                     lastline = buf;
400                     continue;
401                 }
<span class="line-modified">402                 value = new String(buf, 0, buf.length, UTF_8.INSTANCE);</span>
403                 lastline = null;
404             } else {
405                 while (lbuf[i++] != &#39;:&#39;) {
406                     if (i &gt;= len) {
407                         throw new IOException(&quot;invalid header field (&quot;
408                                     + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
409                     }
410                 }
411                 if (lbuf[i++] != &#39; &#39;) {
412                     throw new IOException(&quot;invalid header field (&quot;
413                                 + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
414                 }
<span class="line-modified">415                 name = new String(lbuf, 0, i - 2, UTF_8.INSTANCE);</span>
416                 if (is.peek() == &#39; &#39;) {
417                     lastline = new byte[len - i];
418                     System.arraycopy(lbuf, i, lastline, 0, len - i);
419                     continue;
420                 }
<span class="line-modified">421                 value = new String(lbuf, i, len - i, UTF_8.INSTANCE);</span>
422             }
423             try {
424                 if ((putValue(name, value) != null) &amp;&amp; (!lineContinued)) {
425                     PlatformLogger.getLogger(&quot;java.util.jar&quot;).warning(
426                                      &quot;Duplicate name in Manifest: &quot; + name
427                                      + &quot;.\n&quot;
428                                      + &quot;Ensure that the manifest does not &quot;
429                                      + &quot;have duplicate entries, and\n&quot;
430                                      + &quot;that blank lines separate &quot;
431                                      + &quot;individual sections in both your\n&quot;
432                                      + &quot;manifest and in the META-INF/MANIFEST.MF &quot;
433                                      + &quot;entry in the jar file.&quot;);
434                 }
435             } catch (IllegalArgumentException e) {
436                 throw new IOException(&quot;invalid header field name: &quot; + name
437                             + &quot; (&quot; + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
438             }
439         }
440         return lineNumber;
441     }
442 
443     /**
444      * The Attributes.Name class represents an attribute name stored in
445      * this Map. Valid attribute names are case-insensitive, are restricted
446      * to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed
447      * 70 characters in length. Attribute values can contain any characters
448      * and will be UTF8-encoded when written to the output stream.  See the
449      * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt;
450      * for more information about valid attribute names and values.
451      */
452     public static class Name {
453         private final String name;
454         private final int hashCode;
455 
456         /**
457          * Avoid allocation for common Names
458          */
<span class="line-modified">459         private static @Stable Map&lt;String, Name&gt; KNOWN_NAMES;</span>
460 
461         static final Name of(String name) {
462             Name n = KNOWN_NAMES.get(name);
463             if (n != null) {
464                 return n;
465             }
466             return new Name(name);
467         }
468 
469         /**
470          * Constructs a new attribute name using the given string name.
471          *
472          * @param name the attribute string name
<span class="line-modified">473          * @throws    IllegalArgumentException if the attribute name was</span>
474          *            invalid
<span class="line-modified">475          * @throws    NullPointerException if the attribute name was null</span>
476          */
477         public Name(String name) {
478             this.hashCode = hash(name);
479             this.name = name.intern();
480         }
481 
482         // Checks the string is valid
483         private final int hash(String name) {
484             Objects.requireNonNull(name, &quot;name&quot;);
485             int len = name.length();
486             if (len &gt; 70 || len == 0) {
487                 throw new IllegalArgumentException(name);
488             }
489             // Calculate hash code case insensitively
490             int h = 0;
491             for (int i = 0; i &lt; len; i++) {
492                 char c = name.charAt(i);
493                 if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
494                     // hashcode must be identical for upper and lower case
495                     h = h * 31 + (c - 0x20);
</pre>
<hr />
<pre>
526          * Computes the hash value for this attribute name.
527          */
528         public int hashCode() {
529             return hashCode;
530         }
531 
532         /**
533          * Returns the attribute name as a String.
534          */
535         public String toString() {
536             return name;
537         }
538 
539         /**
540          * {@code Name} object for {@code Manifest-Version}
541          * manifest attribute. This attribute indicates the version number
542          * of the manifest standard to which a JAR file&#39;s manifest conforms.
543          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#jar-manifest&quot;&gt;
544          *      Manifest and Signature Specification&lt;/a&gt;
545          */
<span class="line-modified">546         public static final Name MANIFEST_VERSION;</span>
547 
548         /**
549          * {@code Name} object for {@code Signature-Version}
550          * manifest attribute used when signing JAR files.
551          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#jar-manifest&quot;&gt;
552          *      Manifest and Signature Specification&lt;/a&gt;
553          */
<span class="line-modified">554         public static final Name SIGNATURE_VERSION;</span>
555 
556         /**
557          * {@code Name} object for {@code Content-Type}
558          * manifest attribute.
559          */
<span class="line-modified">560         public static final Name CONTENT_TYPE;</span>
561 
562         /**
563          * {@code Name} object for {@code Class-Path}
564          * manifest attribute.
565          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#class-path-attribute&quot;&gt;
566          *      JAR file specification&lt;/a&gt;
567          */
<span class="line-modified">568         public static final Name CLASS_PATH;</span>
569 
570         /**
571          * {@code Name} object for {@code Main-Class} manifest
572          * attribute used for launching applications packaged in JAR files.
573          * The {@code Main-Class} attribute is used in conjunction
574          * with the {@code -jar} command-line option of the
575          * {@code java} application launcher.
576          */
<span class="line-modified">577         public static final Name MAIN_CLASS;</span>
578 
579         /**
580          * {@code Name} object for {@code Sealed} manifest attribute
581          * used for sealing.
582          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
583          *      Package Sealing&lt;/a&gt;
584          */
<span class="line-modified">585         public static final Name SEALED;</span>
586 
587         /**
588          * {@code Name} object for {@code Extension-List} manifest attribute
589          * used for the extension mechanism that is no longer supported.
590          */
<span class="line-modified">591         public static final Name EXTENSION_LIST;</span>
592 
593         /**
594          * {@code Name} object for {@code Extension-Name} manifest attribute.
595          * used for the extension mechanism that is no longer supported.
596          */
<span class="line-modified">597         public static final Name EXTENSION_NAME;</span>
598 
599         /**
600          * {@code Name} object for {@code Extension-Installation} manifest attribute.
601          *
602          * @deprecated Extension mechanism is no longer supported.
603          */
604         @Deprecated
<span class="line-modified">605         public static final Name EXTENSION_INSTALLATION;</span>
606 
607         /**
608          * {@code Name} object for {@code Implementation-Title}
609          * manifest attribute used for package versioning.
610          */
<span class="line-modified">611         public static final Name IMPLEMENTATION_TITLE;</span>
612 
613         /**
614          * {@code Name} object for {@code Implementation-Version}
615          * manifest attribute used for package versioning.
616          */
<span class="line-modified">617         public static final Name IMPLEMENTATION_VERSION;</span>
618 
619         /**
620          * {@code Name} object for {@code Implementation-Vendor}
621          * manifest attribute used for package versioning.
622          */
<span class="line-modified">623         public static final Name IMPLEMENTATION_VENDOR;</span>
624 
625         /**
626          * {@code Name} object for {@code Implementation-Vendor-Id}
627          * manifest attribute.
628          *
629          * @deprecated Extension mechanism is no longer supported.
630          */
631         @Deprecated
<span class="line-modified">632         public static final Name IMPLEMENTATION_VENDOR_ID;</span>
633 
634         /**
635          * {@code Name} object for {@code Implementation-URL}
636          * manifest attribute.
637          *
638          * @deprecated Extension mechanism is no longer supported.
639          */
640         @Deprecated
<span class="line-modified">641         public static final Name IMPLEMENTATION_URL;</span>
642 
643         /**
644          * {@code Name} object for {@code Specification-Title}
645          * manifest attribute used for package versioning.
646          */
<span class="line-modified">647         public static final Name SPECIFICATION_TITLE;</span>
648 
649         /**
650          * {@code Name} object for {@code Specification-Version}
651          * manifest attribute used for package versioning.
652          */
<span class="line-modified">653         public static final Name SPECIFICATION_VERSION;</span>
654 
655         /**
656          * {@code Name} object for {@code Specification-Vendor}
657          * manifest attribute used for package versioning.
658          */
<span class="line-modified">659         public static final Name SPECIFICATION_VENDOR;</span>
660 
661         /**
662          * {@code Name} object for {@code Multi-Release}
663          * manifest attribute that indicates this is a multi-release JAR file.
664          *
665          * @since   9
666          */
<span class="line-modified">667         public static final Name MULTI_RELEASE;</span>
668 
669         private static void addName(Map&lt;String, Name&gt; names, Name name) {
670             names.put(name.name, name);
671         }
672 
673         static {
<span class="line-modified">674 </span>
<span class="line-modified">675             VM.initializeFromArchive(Attributes.Name.class);</span>
<span class="line-modified">676 </span>
<span class="line-modified">677             if (KNOWN_NAMES == null) {</span>
<span class="line-modified">678                 MANIFEST_VERSION = new Name(&quot;Manifest-Version&quot;);</span>
<span class="line-modified">679                 SIGNATURE_VERSION = new Name(&quot;Signature-Version&quot;);</span>
<span class="line-modified">680                 CONTENT_TYPE = new Name(&quot;Content-Type&quot;);</span>
<span class="line-modified">681                 CLASS_PATH = new Name(&quot;Class-Path&quot;);</span>
<span class="line-modified">682                 MAIN_CLASS = new Name(&quot;Main-Class&quot;);</span>
<span class="line-modified">683                 SEALED = new Name(&quot;Sealed&quot;);</span>
<span class="line-modified">684                 EXTENSION_LIST = new Name(&quot;Extension-List&quot;);</span>
<span class="line-modified">685                 EXTENSION_NAME = new Name(&quot;Extension-Name&quot;);</span>
<span class="line-modified">686                 EXTENSION_INSTALLATION = new Name(&quot;Extension-Installation&quot;);</span>
<span class="line-modified">687                 IMPLEMENTATION_TITLE = new Name(&quot;Implementation-Title&quot;);</span>
<span class="line-modified">688                 IMPLEMENTATION_VERSION = new Name(&quot;Implementation-Version&quot;);</span>
<span class="line-modified">689                 IMPLEMENTATION_VENDOR = new Name(&quot;Implementation-Vendor&quot;);</span>
<span class="line-modified">690                 IMPLEMENTATION_VENDOR_ID = new Name(&quot;Implementation-Vendor-Id&quot;);</span>
<span class="line-modified">691                 IMPLEMENTATION_URL = new Name(&quot;Implementation-URL&quot;);</span>
<span class="line-modified">692                 SPECIFICATION_TITLE = new Name(&quot;Specification-Title&quot;);</span>
<span class="line-modified">693                 SPECIFICATION_VERSION = new Name(&quot;Specification-Version&quot;);</span>
<span class="line-modified">694                 SPECIFICATION_VENDOR = new Name(&quot;Specification-Vendor&quot;);</span>
<span class="line-modified">695                 MULTI_RELEASE = new Name(&quot;Multi-Release&quot;);</span>
<span class="line-modified">696 </span>
<span class="line-modified">697                 var names = new HashMap&lt;String, Name&gt;(64);</span>
<span class="line-modified">698                 addName(names, MANIFEST_VERSION);</span>
<span class="line-modified">699                 addName(names, SIGNATURE_VERSION);</span>
<span class="line-modified">700                 addName(names, CONTENT_TYPE);</span>
<span class="line-modified">701                 addName(names, CLASS_PATH);</span>
<span class="line-modified">702                 addName(names, MAIN_CLASS);</span>
<span class="line-modified">703                 addName(names, SEALED);</span>
<span class="line-modified">704                 addName(names, EXTENSION_LIST);</span>
<span class="line-modified">705                 addName(names, EXTENSION_NAME);</span>
<span class="line-modified">706                 addName(names, EXTENSION_INSTALLATION);</span>
<span class="line-modified">707                 addName(names, IMPLEMENTATION_TITLE);</span>
<span class="line-modified">708                 addName(names, IMPLEMENTATION_VERSION);</span>
<span class="line-modified">709                 addName(names, IMPLEMENTATION_VENDOR);</span>
<span class="line-modified">710                 addName(names, IMPLEMENTATION_VENDOR_ID);</span>
<span class="line-modified">711                 addName(names, IMPLEMENTATION_URL);</span>
<span class="line-modified">712                 addName(names, SPECIFICATION_TITLE);</span>
<span class="line-modified">713                 addName(names, SPECIFICATION_VERSION);</span>
<span class="line-modified">714                 addName(names, SPECIFICATION_VENDOR);</span>
<span class="line-modified">715                 addName(names, MULTI_RELEASE);</span>
<span class="line-modified">716 </span>
<span class="line-added">717                 // Common attributes used in MANIFEST.MF et.al; adding these has a</span>
<span class="line-added">718                 // small footprint cost, but is likely to be quickly paid for by</span>
<span class="line-added">719                 // reducing allocation when reading and parsing typical manifests</span>
<span class="line-added">720 </span>
<span class="line-added">721                 // JDK internal attributes</span>
<span class="line-added">722                 addName(names, new Name(&quot;Add-Exports&quot;));</span>
<span class="line-added">723                 addName(names, new Name(&quot;Add-Opens&quot;));</span>
<span class="line-added">724                 // LauncherHelper attributes</span>
<span class="line-added">725                 addName(names, new Name(&quot;Launcher-Agent-Class&quot;));</span>
<span class="line-added">726                 addName(names, new Name(&quot;JavaFX-Application-Class&quot;));</span>
<span class="line-added">727                 // jarsigner attributes</span>
<span class="line-added">728                 addName(names, new Name(&quot;Name&quot;));</span>
<span class="line-added">729                 addName(names, new Name(&quot;Created-By&quot;));</span>
<span class="line-added">730                 addName(names, new Name(&quot;SHA1-Digest&quot;));</span>
<span class="line-added">731                 addName(names, new Name(&quot;SHA-256-Digest&quot;));</span>
<span class="line-added">732                 KNOWN_NAMES = Map.copyOf(names);</span>
<span class="line-added">733             } else {</span>
<span class="line-added">734                 // Even if KNOWN_NAMES was read from archive, we still need</span>
<span class="line-added">735                 // to initialize the public constants</span>
<span class="line-added">736                 MANIFEST_VERSION = KNOWN_NAMES.get(&quot;Manifest-Version&quot;);</span>
<span class="line-added">737                 SIGNATURE_VERSION = KNOWN_NAMES.get(&quot;Signature-Version&quot;);</span>
<span class="line-added">738                 CONTENT_TYPE = KNOWN_NAMES.get(&quot;Content-Type&quot;);</span>
<span class="line-added">739                 CLASS_PATH = KNOWN_NAMES.get(&quot;Class-Path&quot;);</span>
<span class="line-added">740                 MAIN_CLASS = KNOWN_NAMES.get(&quot;Main-Class&quot;);</span>
<span class="line-added">741                 SEALED = KNOWN_NAMES.get(&quot;Sealed&quot;);</span>
<span class="line-added">742                 EXTENSION_LIST = KNOWN_NAMES.get(&quot;Extension-List&quot;);</span>
<span class="line-added">743                 EXTENSION_NAME = KNOWN_NAMES.get(&quot;Extension-Name&quot;);</span>
<span class="line-added">744                 EXTENSION_INSTALLATION = KNOWN_NAMES.get(&quot;Extension-Installation&quot;);</span>
<span class="line-added">745                 IMPLEMENTATION_TITLE = KNOWN_NAMES.get(&quot;Implementation-Title&quot;);</span>
<span class="line-added">746                 IMPLEMENTATION_VERSION = KNOWN_NAMES.get(&quot;Implementation-Version&quot;);</span>
<span class="line-added">747                 IMPLEMENTATION_VENDOR = KNOWN_NAMES.get(&quot;Implementation-Vendor&quot;);</span>
<span class="line-added">748                 IMPLEMENTATION_VENDOR_ID = KNOWN_NAMES.get(&quot;Implementation-Vendor-Id&quot;);</span>
<span class="line-added">749                 IMPLEMENTATION_URL = KNOWN_NAMES.get(&quot;Implementation-URL&quot;);</span>
<span class="line-added">750                 SPECIFICATION_TITLE = KNOWN_NAMES.get(&quot;Specification-Title&quot;);</span>
<span class="line-added">751                 SPECIFICATION_VERSION = KNOWN_NAMES.get(&quot;Specification-Version&quot;);</span>
<span class="line-added">752                 SPECIFICATION_VENDOR = KNOWN_NAMES.get(&quot;Specification-Vendor&quot;);</span>
<span class="line-added">753                 MULTI_RELEASE = KNOWN_NAMES.get(&quot;Multi-Release&quot;);</span>
<span class="line-added">754             }</span>
755         }
756     }
757 }
</pre>
</td>
</tr>
</table>
<center><a href="../doc-files/coll-designfaq.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JarEntry.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/channels/DatagramChannel.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio.channels;
 27 
 28 import java.io.IOException;
 29 import java.net.ProtocolFamily;
 30 import java.net.DatagramSocket;
 31 import java.net.SocketOption;
 32 import java.net.SocketAddress;
 33 import java.nio.ByteBuffer;
 34 import java.nio.channels.spi.AbstractSelectableChannel;
 35 import java.nio.channels.spi.SelectorProvider;
 36 
 37 /**
 38  * A selectable channel for datagram-oriented sockets.
 39  *
 40  * &lt;p&gt; A datagram channel is created by invoking one of the {@link #open open} methods
 41  * of this class. It is not possible to create a channel for an arbitrary,
 42  * pre-existing datagram socket. A newly-created datagram channel is open but not
 43  * connected. A datagram channel need not be connected in order for the {@link #send
 44  * send} and {@link #receive receive} methods to be used.  A datagram channel may be
 45  * connected, by invoking its {@link #connect connect} method, in order to
 46  * avoid the overhead of the security checks are otherwise performed as part of
 47  * every send and receive operation.  A datagram channel must be connected in
 48  * order to use the {@link #read(java.nio.ByteBuffer) read} and {@link
 49  * #write(java.nio.ByteBuffer) write} methods, since those methods do not
 50  * accept or return socket addresses.
 51  *
 52  * &lt;p&gt; Once connected, a datagram channel remains connected until it is
 53  * disconnected or closed.  Whether or not a datagram channel is connected may
 54  * be determined by invoking its {@link #isConnected isConnected} method.
 55  *
 56  * &lt;p&gt; Socket options are configured using the {@link #setOption(SocketOption,Object)
 57  * setOption} method. A datagram channel to an Internet Protocol socket supports
 58  * the following options:
 59  * &lt;blockquote&gt;
 60  * &lt;table class=&quot;striped&quot;&gt;
 61  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;
 62  * &lt;thead&gt;
 63  *   &lt;tr&gt;
 64  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;
 65  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 66  *   &lt;/tr&gt;
 67  * &lt;/thead&gt;
 68  * &lt;tbody&gt;
 69  *   &lt;tr&gt;
 70  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;
 71  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;
 72  *   &lt;/tr&gt;
 73  *   &lt;tr&gt;
 74  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;
 75  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;
 76  *   &lt;/tr&gt;
 77  *   &lt;tr&gt;
 78  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;
 79  *     &lt;td&gt; Re-use address &lt;/td&gt;
 80  *   &lt;/tr&gt;
 81  *   &lt;tr&gt;
 82  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_BROADCAST SO_BROADCAST} &lt;/th&gt;
 83  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;
 84  *   &lt;/tr&gt;
 85  *   &lt;tr&gt;
 86  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;
 87  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;
 88  *   &lt;/tr&gt;
 89  *   &lt;tr&gt;
 90  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} &lt;/th&gt;
 91  *     &lt;td&gt; The network interface for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
 92  *   &lt;/tr&gt;
 93  *   &lt;tr&gt;
 94  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL
 95  *       IP_MULTICAST_TTL} &lt;/th&gt;
 96  *     &lt;td&gt; The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast
 97  *       datagrams &lt;/td&gt;
 98  *   &lt;/tr&gt;
 99  *   &lt;tr&gt;
100  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP
101  *       IP_MULTICAST_LOOP} &lt;/th&gt;
102  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
103  *   &lt;/tr&gt;
104  * &lt;/tbody&gt;
105  * &lt;/table&gt;
106  * &lt;/blockquote&gt;
107  * Additional (implementation specific) options may also be supported.
108  *
109  * &lt;p&gt; Datagram channels are safe for use by multiple concurrent threads.  They
110  * support concurrent reading and writing, though at most one thread may be
111  * reading and at most one thread may be writing at any given time.  &lt;/p&gt;
112  *
113  * @author Mark Reinhold
114  * @author JSR-51 Expert Group
115  * @since 1.4
116  */
117 
118 public abstract class DatagramChannel
119     extends AbstractSelectableChannel
120     implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel
121 {
122 
123     /**
124      * Initializes a new instance of this class.
125      *
126      * @param  provider
127      *         The provider that created this channel
128      */
129     protected DatagramChannel(SelectorProvider provider) {
130         super(provider);
131     }
132 
133     /**
134      * Opens a datagram channel.
135      *
136      * &lt;p&gt; The new channel is created by invoking the {@link
137      * java.nio.channels.spi.SelectorProvider#openDatagramChannel()
138      * openDatagramChannel} method of the system-wide default {@link
139      * java.nio.channels.spi.SelectorProvider} object.  The channel will not be
140      * connected.
141      *
142      * &lt;p&gt; The {@link ProtocolFamily ProtocolFamily} of the channel&#39;s socket
143      * is platform (and possibly configuration) dependent and therefore unspecified.
144      * The {@link #open(ProtocolFamily) open} allows the protocol family to be
145      * selected when opening a datagram channel, and should be used to open
146      * datagram channels that are intended for Internet Protocol multicasting.
147      *
148      * @return  A new datagram channel
149      *
150      * @throws  IOException
151      *          If an I/O error occurs
152      */
153     public static DatagramChannel open() throws IOException {
154         return SelectorProvider.provider().openDatagramChannel();
155     }
156 
157     /**
158      * Opens a datagram channel.
159      *
160      * &lt;p&gt; The {@code family} parameter is used to specify the {@link
161      * ProtocolFamily}. If the datagram channel is to be used for IP multicasting
162      * then this should correspond to the address type of the multicast groups
163      * that this channel will join.
164      *
165      * &lt;p&gt; The new channel is created by invoking the {@link
166      * java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)
167      * openDatagramChannel} method of the system-wide default {@link
168      * java.nio.channels.spi.SelectorProvider} object.  The channel will not be
169      * connected.
170      *
171      * @param   family
172      *          The protocol family
173      *
174      * @return  A new datagram channel
175      *
176      * @throws  UnsupportedOperationException
177      *          If the specified protocol family is not supported. For example,
178      *          suppose the parameter is specified as {@link
179      *          java.net.StandardProtocolFamily#INET6 StandardProtocolFamily.INET6}
180      *          but IPv6 is not enabled on the platform.
181      * @throws  IOException
182      *          If an I/O error occurs
183      *
184      * @since   1.7
185      */
186     public static DatagramChannel open(ProtocolFamily family) throws IOException {
187         return SelectorProvider.provider().openDatagramChannel(family);
188     }
189 
190     /**
191      * Returns an operation set identifying this channel&#39;s supported
192      * operations.
193      *
194      * &lt;p&gt; Datagram channels support reading and writing, so this method
195      * returns {@code (}{@link SelectionKey#OP_READ} {@code |}&amp;nbsp;{@link
196      * SelectionKey#OP_WRITE}{@code )}.
197      *
198      * @return  The valid-operation set
199      */
200     public final int validOps() {
201         return (SelectionKey.OP_READ
202                 | SelectionKey.OP_WRITE);
203     }
204 
205 
206     // -- Socket-specific operations --
207 
208     /**
209      * @throws  AlreadyBoundException               {@inheritDoc}
210      * @throws  UnsupportedAddressTypeException     {@inheritDoc}
211      * @throws  ClosedChannelException              {@inheritDoc}
212      * @throws  IOException                         {@inheritDoc}
213      * @throws  SecurityException
214      *          If a security manager has been installed and its {@link
215      *          SecurityManager#checkListen checkListen} method denies the
216      *          operation
217      *
218      * @since 1.7
219      */
220     public abstract DatagramChannel bind(SocketAddress local)
221         throws IOException;
222 
223     /**
224      * @throws  UnsupportedOperationException           {@inheritDoc}
225      * @throws  IllegalArgumentException                {@inheritDoc}
226      * @throws  ClosedChannelException                  {@inheritDoc}
227      * @throws  IOException                             {@inheritDoc}
228      *
229      * @since 1.7
230      */
231     public abstract &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
232         throws IOException;
233 
234     /**
235      * Retrieves a datagram socket associated with this channel.
236      *
<a name="2" id="anc2"></a><span class="line-removed">237      * &lt;p&gt; The returned object will not declare any public methods that are not</span>
<span class="line-removed">238      * declared in the {@link java.net.DatagramSocket} class.  &lt;/p&gt;</span>
<span class="line-removed">239      *</span>
240      * @return  A datagram socket associated with this channel
241      */
242     public abstract DatagramSocket socket();
243 
244     /**
245      * Tells whether or not this channel&#39;s socket is connected.
246      *
247      * @return  {@code true} if, and only if, this channel&#39;s socket
248      *          is {@link #isOpen open} and connected
249      */
250     public abstract boolean isConnected();
251 
252     /**
253      * Connects this channel&#39;s socket.
254      *
255      * &lt;p&gt; The channel&#39;s socket is configured so that it only receives
256      * datagrams from, and sends datagrams to, the given remote &lt;i&gt;peer&lt;/i&gt;
257      * address.  Once connected, datagrams may not be received from or sent to
<a name="3" id="anc3"></a><span class="line-modified">258      * any other address.  A datagram socket remains connected until it is</span>
<span class="line-modified">259      * explicitly disconnected or until it is closed.</span>



260      *
261      * &lt;p&gt; This method performs exactly the same security checks as the {@link
262      * java.net.DatagramSocket#connect connect} method of the {@link
263      * java.net.DatagramSocket} class.  That is, if a security manager has been
264      * installed then this method verifies that its {@link
265      * java.lang.SecurityManager#checkAccept checkAccept} and {@link
266      * java.lang.SecurityManager#checkConnect checkConnect} methods permit
267      * datagrams to be received from and sent to, respectively, the given
<a name="4" id="anc4"></a><span class="line-modified">268      * remote address.</span>



269      *
<a name="5" id="anc5"></a><span class="line-modified">270      * &lt;p&gt; This method may be invoked at any time.  It will not have any effect</span>
<span class="line-modified">271      * on read or write operations that are already in progress at the moment</span>
<span class="line-modified">272      * that it is invoked. If this channel&#39;s socket is not bound then this method</span>
<span class="line-modified">273      * will first cause the socket to be bound to an address that is assigned</span>

274      * automatically, as if invoking the {@link #bind bind} method with a
<a name="6" id="anc6"></a><span class="line-modified">275      * parameter of {@code null}. &lt;/p&gt;</span>
276      *
277      * @param  remote
278      *         The remote address to which this channel is to be connected
279      *
280      * @return  This datagram channel
281      *
282      * @throws  AlreadyConnectedException
283      *          If this channel is already connected
284      *
285      * @throws  ClosedChannelException
286      *          If this channel is closed
287      *
288      * @throws  AsynchronousCloseException
289      *          If another thread closes this channel
290      *          while the connect operation is in progress
291      *
292      * @throws  ClosedByInterruptException
293      *          If another thread interrupts the current thread
294      *          while the connect operation is in progress, thereby
295      *          closing the channel and setting the current thread&#39;s
296      *          interrupt status
297      *
298      * @throws  UnresolvedAddressException
299      *          If the given remote address is not fully resolved
300      *
301      * @throws  UnsupportedAddressTypeException
302      *          If the type of the given remote address is not supported
303      *
304      * @throws  SecurityException
<a name="7" id="anc7"></a><span class="line-modified">305      *          If a security manager has been installed</span>
<span class="line-modified">306      *          and it does not permit access to the given remote address</span>


307      *
308      * @throws  IOException
309      *          If some other I/O error occurs
310      */
311     public abstract DatagramChannel connect(SocketAddress remote)
312         throws IOException;
313 
314     /**
315      * Disconnects this channel&#39;s socket.
316      *
317      * &lt;p&gt; The channel&#39;s socket is configured so that it can receive datagrams
318      * from, and sends datagrams to, any remote address so long as the security
319      * manager, if installed, permits it.
320      *
<a name="8" id="anc8"></a><span class="line-modified">321      * &lt;p&gt; This method may be invoked at any time.  It will not have any effect</span>
<span class="line-modified">322      * on read or write operations that are already in progress at the moment</span>
<span class="line-modified">323      * that it is invoked.</span>

324      *
325      * &lt;p&gt; If this channel&#39;s socket is not connected, or if the channel is
326      * closed, then invoking this method has no effect.  &lt;/p&gt;
327      *
<a name="9" id="anc9"></a>



328      * @return  This datagram channel
329      *
330      * @throws  IOException
331      *          If some other I/O error occurs
332      */
333     public abstract DatagramChannel disconnect() throws IOException;
334 
335     /**
336      * Returns the remote address to which this channel&#39;s socket is connected.
337      *
338      * @return  The remote address; {@code null} if the channel&#39;s socket is not
339      *          connected
340      *
341      * @throws  ClosedChannelException
342      *          If the channel is closed
343      * @throws  IOException
344      *          If an I/O error occurs
345      *
346      * @since 1.7
347      */
348     public abstract SocketAddress getRemoteAddress() throws IOException;
349 
350     /**
351      * Receives a datagram via this channel.
352      *
353      * &lt;p&gt; If a datagram is immediately available, or if this channel is in
354      * blocking mode and one eventually becomes available, then the datagram is
355      * copied into the given byte buffer and its source address is returned.
356      * If this channel is in non-blocking mode and a datagram is not
357      * immediately available then this method immediately returns
358      * {@code null}.
359      *
360      * &lt;p&gt; The datagram is transferred into the given byte buffer starting at
361      * its current position, as if by a regular {@link
362      * ReadableByteChannel#read(java.nio.ByteBuffer) read} operation.  If there
363      * are fewer bytes remaining in the buffer than are required to hold the
364      * datagram then the remainder of the datagram is silently discarded.
365      *
366      * &lt;p&gt; This method performs exactly the same security checks as the {@link
367      * java.net.DatagramSocket#receive receive} method of the {@link
368      * java.net.DatagramSocket} class.  That is, if the socket is not connected
369      * to a specific remote address and a security manager has been installed
370      * then for each datagram received this method verifies that the source&#39;s
371      * address and port number are permitted by the security manager&#39;s {@link
<a name="10" id="anc10"></a><span class="line-modified">372      * java.lang.SecurityManager#checkAccept checkAccept} method.  The overhead</span>
<span class="line-modified">373      * of this security check can be avoided by first connecting the socket via</span>
<span class="line-modified">374      * the {@link #connect connect} method.</span>

375      *
376      * &lt;p&gt; This method may be invoked at any time.  If another thread has
377      * already initiated a read operation upon this channel, however, then an
378      * invocation of this method will block until the first operation is
379      * complete. If this channel&#39;s socket is not bound then this method will
380      * first cause the socket to be bound to an address that is assigned
381      * automatically, as if invoking the {@link #bind bind} method with a
382      * parameter of {@code null}. &lt;/p&gt;
383      *
384      * @param  dst
385      *         The buffer into which the datagram is to be transferred
386      *
387      * @return  The datagram&#39;s source address,
388      *          or {@code null} if this channel is in non-blocking mode
389      *          and no datagram was immediately available
390      *
<a name="11" id="anc11"></a>


391      * @throws  ClosedChannelException
392      *          If this channel is closed
393      *
394      * @throws  AsynchronousCloseException
395      *          If another thread closes this channel
396      *          while the read operation is in progress
397      *
398      * @throws  ClosedByInterruptException
399      *          If another thread interrupts the current thread
400      *          while the read operation is in progress, thereby
401      *          closing the channel and setting the current thread&#39;s
402      *          interrupt status
403      *
404      * @throws  SecurityException
<a name="12" id="anc12"></a><span class="line-modified">405      *          If a security manager has been installed</span>
<span class="line-modified">406      *          and it does not permit datagrams to be accepted</span>
<span class="line-modified">407      *          from the datagram&#39;s sender</span>
408      *
409      * @throws  IOException
410      *          If some other I/O error occurs
411      */
412     public abstract SocketAddress receive(ByteBuffer dst) throws IOException;
413 
414     /**
415      * Sends a datagram via this channel.
416      *
417      * &lt;p&gt; If this channel is in non-blocking mode and there is sufficient room
418      * in the underlying output buffer, or if this channel is in blocking mode
419      * and sufficient room becomes available, then the remaining bytes in the
420      * given buffer are transmitted as a single datagram to the given target
421      * address.
422      *
423      * &lt;p&gt; The datagram is transferred from the byte buffer as if by a regular
424      * {@link WritableByteChannel#write(java.nio.ByteBuffer) write} operation.
425      *
426      * &lt;p&gt; This method performs exactly the same security checks as the {@link
427      * java.net.DatagramSocket#send send} method of the {@link
428      * java.net.DatagramSocket} class.  That is, if the socket is not connected
429      * to a specific remote address and a security manager has been installed
430      * then for each datagram sent this method verifies that the target address
431      * and port number are permitted by the security manager&#39;s {@link
432      * java.lang.SecurityManager#checkConnect checkConnect} method.  The
433      * overhead of this security check can be avoided by first connecting the
434      * socket via the {@link #connect connect} method.
435      *
436      * &lt;p&gt; This method may be invoked at any time.  If another thread has
437      * already initiated a write operation upon this channel, however, then an
438      * invocation of this method will block until the first operation is
439      * complete. If this channel&#39;s socket is not bound then this method will
440      * first cause the socket to be bound to an address that is assigned
441      * automatically, as if by invoking the {@link #bind bind} method with a
442      * parameter of {@code null}. &lt;/p&gt;
443      *
444      * @param  src
445      *         The buffer containing the datagram to be sent
446      *
447      * @param  target
448      *         The address to which the datagram is to be sent
449      *
450      * @return   The number of bytes sent, which will be either the number
451      *           of bytes that were remaining in the source buffer when this
452      *           method was invoked or, if this channel is non-blocking, may be
453      *           zero if there was insufficient room for the datagram in the
454      *           underlying output buffer
455      *
456      * @throws  AlreadyConnectedException
457      *          If this channel is connected to a different address
458      *          from that specified by {@code target}
459      *
460      * @throws  ClosedChannelException
461      *          If this channel is closed
462      *
463      * @throws  AsynchronousCloseException
464      *          If another thread closes this channel
465      *          while the read operation is in progress
466      *
467      * @throws  ClosedByInterruptException
468      *          If another thread interrupts the current thread
469      *          while the read operation is in progress, thereby
470      *          closing the channel and setting the current thread&#39;s
471      *          interrupt status
472      *
473      * @throws  UnresolvedAddressException
474      *          If the given remote address is not fully resolved
475      *
476      * @throws  UnsupportedAddressTypeException
477      *          If the type of the given remote address is not supported
478      *
479      * @throws  SecurityException
<a name="13" id="anc13"></a><span class="line-modified">480      *          If a security manager has been installed</span>
<span class="line-modified">481      *          and it does not permit datagrams to be sent</span>
<span class="line-modified">482      *          to the given address</span>

483      *
484      * @throws  IOException
485      *          If some other I/O error occurs
486      */
487     public abstract int send(ByteBuffer src, SocketAddress target)
488         throws IOException;
489 
490 
491     // -- ByteChannel operations --
492 
493     /**
494      * Reads a datagram from this channel.
495      *
496      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
497      * connected, and it only accepts datagrams from the socket&#39;s peer.  If
498      * there are more bytes in the datagram than remain in the given buffer
499      * then the remainder of the datagram is silently discarded.  Otherwise
500      * this method behaves exactly as specified in the {@link
501      * ReadableByteChannel} interface.  &lt;/p&gt;
502      *
503      * @throws  NotYetConnectedException
504      *          If this channel&#39;s socket is not connected
505      */
506     public abstract int read(ByteBuffer dst) throws IOException;
507 
508     /**
509      * Reads a datagram from this channel.
510      *
511      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
512      * connected, and it only accepts datagrams from the socket&#39;s peer.  If
513      * there are more bytes in the datagram than remain in the given buffers
514      * then the remainder of the datagram is silently discarded.  Otherwise
515      * this method behaves exactly as specified in the {@link
516      * ScatteringByteChannel} interface.  &lt;/p&gt;
517      *
518      * @throws  NotYetConnectedException
519      *          If this channel&#39;s socket is not connected
520      */
521     public abstract long read(ByteBuffer[] dsts, int offset, int length)
522         throws IOException;
523 
524     /**
525      * Reads a datagram from this channel.
526      *
527      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
528      * connected, and it only accepts datagrams from the socket&#39;s peer.  If
529      * there are more bytes in the datagram than remain in the given buffers
530      * then the remainder of the datagram is silently discarded.  Otherwise
531      * this method behaves exactly as specified in the {@link
532      * ScatteringByteChannel} interface.  &lt;/p&gt;
533      *
534      * @throws  NotYetConnectedException
535      *          If this channel&#39;s socket is not connected
536      */
537     public final long read(ByteBuffer[] dsts) throws IOException {
538         return read(dsts, 0, dsts.length);
539     }
540 
541     /**
542      * Writes a datagram to this channel.
543      *
544      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
545      * connected, in which case it sends datagrams directly to the socket&#39;s
546      * peer.  Otherwise it behaves exactly as specified in the {@link
547      * WritableByteChannel} interface.  &lt;/p&gt;
548      *
549      * @throws  NotYetConnectedException
550      *          If this channel&#39;s socket is not connected
551      */
552     public abstract int write(ByteBuffer src) throws IOException;
553 
554     /**
555      * Writes a datagram to this channel.
556      *
557      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
558      * connected, in which case it sends datagrams directly to the socket&#39;s
559      * peer.  Otherwise it behaves exactly as specified in the {@link
560      * GatheringByteChannel} interface.  &lt;/p&gt;
561      *
562      * @return   The number of bytes sent, which will be either the number
563      *           of bytes that were remaining in the source buffer when this
564      *           method was invoked or, if this channel is non-blocking, may be
565      *           zero if there was insufficient room for the datagram in the
566      *           underlying output buffer
567      *
568      * @throws  NotYetConnectedException
569      *          If this channel&#39;s socket is not connected
570      */
571     public abstract long write(ByteBuffer[] srcs, int offset, int length)
572         throws IOException;
573 
574     /**
575      * Writes a datagram to this channel.
576      *
577      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
578      * connected, in which case it sends datagrams directly to the socket&#39;s
579      * peer.  Otherwise it behaves exactly as specified in the {@link
580      * GatheringByteChannel} interface.  &lt;/p&gt;
581      *
582      * @return   The number of bytes sent, which will be either the number
583      *           of bytes that were remaining in the source buffer when this
584      *           method was invoked or, if this channel is non-blocking, may be
585      *           zero if there was insufficient room for the datagram in the
586      *           underlying output buffer
587      *
588      * @throws  NotYetConnectedException
589      *          If this channel&#39;s socket is not connected
590      */
591     public final long write(ByteBuffer[] srcs) throws IOException {
592         return write(srcs, 0, srcs.length);
593     }
594 
595     /**
596      * {@inheritDoc}
597      * &lt;p&gt;
598      * If there is a security manager set, its {@code checkConnect} method is
599      * called with the local address and {@code -1} as its arguments to see
600      * if the operation is allowed. If the operation is not allowed,
601      * a {@code SocketAddress} representing the
602      * {@link java.net.InetAddress#getLoopbackAddress loopback} address and the
603      * local port of the channel&#39;s socket is returned.
604      *
605      * @return  The {@code SocketAddress} that the socket is bound to, or the
606      *          {@code SocketAddress} representing the loopback address if
607      *          denied by the security manager, or {@code null} if the
608      *          channel&#39;s socket is not bound
609      *
610      * @throws  ClosedChannelException     {@inheritDoc}
611      * @throws  IOException                {@inheritDoc}
612      */
613     @Override
614     public abstract SocketAddress getLocalAddress() throws IOException;
615 
616 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
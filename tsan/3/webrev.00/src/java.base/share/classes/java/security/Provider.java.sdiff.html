<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/Provider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PrivilegedActionException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ProviderException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/Provider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  91  * The mechanism for configuring and installing security providers is
  92  * implementation-specific.
  93  *
  94  * @implNote
  95  * The JDK implementation supports static registration of the security
  96  * providers via the {@code conf/security/java.security} file in the Java
  97  * installation directory. These providers are automatically installed by
  98  * the JDK runtime, see {@extLink security_guide_jca_provider
  99  * The Provider Class}
 100  * in the Java Cryptography Architecture (JCA) Reference Guide
 101  * for information about how a particular type of provider, the cryptographic
 102  * service provider, works and is installed.
 103  *
 104  * @author Benjamin Renaud
 105  * @author Andreas Sterbenz
 106  * @since 1.1
 107  */
 108 public abstract class Provider extends Properties {
 109 
 110     // Declare serialVersionUID to be compatible with JDK1.1

 111     private static final long serialVersionUID = -4298000515446427739L;
 112 
 113     private static final sun.security.util.Debug debug =
 114         sun.security.util.Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 115 
 116     /**
 117      * The provider name.
 118      *
 119      * @serial
 120      */
 121     private String name;
 122 
 123     /**
 124      * A description of the provider and its services.
 125      *
 126      * @serial
 127      */
 128     private String info;
 129 
 130     /**
</pre>
<hr />
<pre>
 385      * @throws  SecurityException
 386      *          if a security manager exists and its {@link
 387      *          java.lang.SecurityManager#checkSecurityAccess} method
 388      *          denies access to clear this provider
 389      *
 390      * @since 1.2
 391      */
 392     @Override
 393     public synchronized void clear() {
 394         check(&quot;clearProviderProperties.&quot;+name);
 395         if (debug != null) {
 396             debug.println(&quot;Remove &quot; + name + &quot; provider properties&quot;);
 397         }
 398         implClear();
 399     }
 400 
 401     /**
 402      * Reads a property list (key and element pairs) from the input stream.
 403      *
 404      * @param inStream the input stream.
<span class="line-modified"> 405      * @exception IOException if an error occurred when reading from the</span>
 406      *               input stream.
 407      * @see java.util.Properties#load
 408      */
 409     @Override
 410     public synchronized void load(InputStream inStream) throws IOException {
 411         check(&quot;putProviderProperty.&quot;+name);
 412         if (debug != null) {
 413             debug.println(&quot;Load &quot; + name + &quot; provider properties&quot;);
 414         }
 415         Properties tempProperties = new Properties();
 416         tempProperties.load(inStream);
 417         implPutAll(tempProperties);
 418     }
 419 
 420     /**
 421      * Copies all of the mappings from the specified Map to this provider.
 422      * These mappings will replace any properties that this provider had
 423      * for any of the keys currently in the specified Map.
 424      *
 425      * @since 1.2
</pre>
<hr />
<pre>
 873     // this is to ensure that equals() and hashCode() do not incorrectly
 874     // report to different provider objects as the same
 875     private void putId() {
 876         // note: name and info may be null
 877         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 878         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 879         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 880         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 881     }
 882 
 883    /**
 884     * Reads the {@code ObjectInputStream} for the default serializable fields.
 885     * If the serialized field {@code versionStr} is found in the STREAM FIELDS,
 886     * its String value will be used to populate both the version string and
 887     * version number. If {@code versionStr} is not found, but {@code version}
 888     * is, then its double value will be used to populate both fields.
 889     *
 890     * @param in the {@code ObjectInputStream} to read
 891     * @serial
 892     */

 893     private void readObject(ObjectInputStream in)
 894                 throws IOException, ClassNotFoundException {
 895         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 896         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 897             copy.put(entry.getKey(), entry.getValue());
 898         }
 899         defaults = null;
 900         in.defaultReadObject();
 901         if (this.versionStr == null) {
 902             // set versionStr based on version when not found in serialized bytes
 903             this.versionStr = Double.toString(this.version);
 904         } else {
 905             // otherwise, set version based on versionStr
 906             this.version = parseVersionStr(this.versionStr);
 907         }
 908         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 909         implClear();
 910         initialized = true;
 911         putAll(copy);
 912     }
</pre>
<hr />
<pre>
1236      *
1237      * @since 1.5
1238      */
1239     public Service getService(String type, String algorithm) {
1240         checkInitialized();
1241 
1242         // avoid allocating a new ServiceKey object if possible
1243         ServiceKey key = previousKey;
1244         if (key.matches(type, algorithm) == false) {
1245             key = new ServiceKey(type, algorithm, false);
1246             previousKey = key;
1247         }
1248         if (!serviceMap.isEmpty()) {
1249             Service s = serviceMap.get(key);
1250             if (s != null) {
1251                 return s;
1252             }
1253         }
1254         synchronized (this) {
1255             ensureLegacyParsed();
<span class="line-modified">1256         }</span>
<span class="line-modified">1257         if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {</span>
<span class="line-modified">1258             return legacyMap.get(key);</span>
1259         }
1260         return null;
1261     }
1262 
1263     // ServiceKey from previous getService() call
1264     // by re-using it if possible we avoid allocating a new object
1265     // and the toUpperCase() call.
1266     // re-use will occur e.g. as the framework traverses the provider
1267     // list and queries each provider with the same values until it finds
1268     // a matching service
1269     private static volatile ServiceKey previousKey =
1270                                             new ServiceKey(&quot;&quot;, &quot;&quot;, false);
1271 
1272     /**
1273      * Get an unmodifiable Set of all services supported by
1274      * this Provider.
1275      *
1276      * @return an unmodifiable Set of all services supported by
1277      * this Provider
1278      *
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  91  * The mechanism for configuring and installing security providers is
  92  * implementation-specific.
  93  *
  94  * @implNote
  95  * The JDK implementation supports static registration of the security
  96  * providers via the {@code conf/security/java.security} file in the Java
  97  * installation directory. These providers are automatically installed by
  98  * the JDK runtime, see {@extLink security_guide_jca_provider
  99  * The Provider Class}
 100  * in the Java Cryptography Architecture (JCA) Reference Guide
 101  * for information about how a particular type of provider, the cryptographic
 102  * service provider, works and is installed.
 103  *
 104  * @author Benjamin Renaud
 105  * @author Andreas Sterbenz
 106  * @since 1.1
 107  */
 108 public abstract class Provider extends Properties {
 109 
 110     // Declare serialVersionUID to be compatible with JDK1.1
<span class="line-added"> 111     @java.io.Serial</span>
 112     private static final long serialVersionUID = -4298000515446427739L;
 113 
 114     private static final sun.security.util.Debug debug =
 115         sun.security.util.Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 116 
 117     /**
 118      * The provider name.
 119      *
 120      * @serial
 121      */
 122     private String name;
 123 
 124     /**
 125      * A description of the provider and its services.
 126      *
 127      * @serial
 128      */
 129     private String info;
 130 
 131     /**
</pre>
<hr />
<pre>
 386      * @throws  SecurityException
 387      *          if a security manager exists and its {@link
 388      *          java.lang.SecurityManager#checkSecurityAccess} method
 389      *          denies access to clear this provider
 390      *
 391      * @since 1.2
 392      */
 393     @Override
 394     public synchronized void clear() {
 395         check(&quot;clearProviderProperties.&quot;+name);
 396         if (debug != null) {
 397             debug.println(&quot;Remove &quot; + name + &quot; provider properties&quot;);
 398         }
 399         implClear();
 400     }
 401 
 402     /**
 403      * Reads a property list (key and element pairs) from the input stream.
 404      *
 405      * @param inStream the input stream.
<span class="line-modified"> 406      * @throws    IOException if an error occurred when reading from the</span>
 407      *               input stream.
 408      * @see java.util.Properties#load
 409      */
 410     @Override
 411     public synchronized void load(InputStream inStream) throws IOException {
 412         check(&quot;putProviderProperty.&quot;+name);
 413         if (debug != null) {
 414             debug.println(&quot;Load &quot; + name + &quot; provider properties&quot;);
 415         }
 416         Properties tempProperties = new Properties();
 417         tempProperties.load(inStream);
 418         implPutAll(tempProperties);
 419     }
 420 
 421     /**
 422      * Copies all of the mappings from the specified Map to this provider.
 423      * These mappings will replace any properties that this provider had
 424      * for any of the keys currently in the specified Map.
 425      *
 426      * @since 1.2
</pre>
<hr />
<pre>
 874     // this is to ensure that equals() and hashCode() do not incorrectly
 875     // report to different provider objects as the same
 876     private void putId() {
 877         // note: name and info may be null
 878         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 879         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 880         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 881         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 882     }
 883 
 884    /**
 885     * Reads the {@code ObjectInputStream} for the default serializable fields.
 886     * If the serialized field {@code versionStr} is found in the STREAM FIELDS,
 887     * its String value will be used to populate both the version string and
 888     * version number. If {@code versionStr} is not found, but {@code version}
 889     * is, then its double value will be used to populate both fields.
 890     *
 891     * @param in the {@code ObjectInputStream} to read
 892     * @serial
 893     */
<span class="line-added"> 894     @java.io.Serial</span>
 895     private void readObject(ObjectInputStream in)
 896                 throws IOException, ClassNotFoundException {
 897         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 898         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 899             copy.put(entry.getKey(), entry.getValue());
 900         }
 901         defaults = null;
 902         in.defaultReadObject();
 903         if (this.versionStr == null) {
 904             // set versionStr based on version when not found in serialized bytes
 905             this.versionStr = Double.toString(this.version);
 906         } else {
 907             // otherwise, set version based on versionStr
 908             this.version = parseVersionStr(this.versionStr);
 909         }
 910         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 911         implClear();
 912         initialized = true;
 913         putAll(copy);
 914     }
</pre>
<hr />
<pre>
1238      *
1239      * @since 1.5
1240      */
1241     public Service getService(String type, String algorithm) {
1242         checkInitialized();
1243 
1244         // avoid allocating a new ServiceKey object if possible
1245         ServiceKey key = previousKey;
1246         if (key.matches(type, algorithm) == false) {
1247             key = new ServiceKey(type, algorithm, false);
1248             previousKey = key;
1249         }
1250         if (!serviceMap.isEmpty()) {
1251             Service s = serviceMap.get(key);
1252             if (s != null) {
1253                 return s;
1254             }
1255         }
1256         synchronized (this) {
1257             ensureLegacyParsed();
<span class="line-modified">1258             if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {</span>
<span class="line-modified">1259                 return legacyMap.get(key);</span>
<span class="line-modified">1260             }</span>
1261         }
1262         return null;
1263     }
1264 
1265     // ServiceKey from previous getService() call
1266     // by re-using it if possible we avoid allocating a new object
1267     // and the toUpperCase() call.
1268     // re-use will occur e.g. as the framework traverses the provider
1269     // list and queries each provider with the same values until it finds
1270     // a matching service
1271     private static volatile ServiceKey previousKey =
1272                                             new ServiceKey(&quot;&quot;, &quot;&quot;, false);
1273 
1274     /**
1275      * Get an unmodifiable Set of all services supported by
1276      * this Provider.
1277      *
1278      * @return an unmodifiable Set of all services supported by
1279      * this Provider
1280      *
</pre>
</td>
</tr>
</table>
<center><a href="PrivilegedActionException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ProviderException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
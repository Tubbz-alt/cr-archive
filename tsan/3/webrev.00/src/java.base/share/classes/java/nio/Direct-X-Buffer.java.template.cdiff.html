<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Direct-X-Buffer-bin.java.template.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Heap-X-Buffer.java.template.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  package java.nio;
  
  import java.io.FileDescriptor;
  import java.lang.ref.Reference;
  import java.util.Objects;
<span class="line-added">+ import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  import jdk.internal.misc.VM;
  import jdk.internal.ref.Cleaner;
  import sun.nio.ch.DirectBuffer;
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,11 ***</span>
  
      // Primary constructor
      //
      Direct$Type$Buffer$RW$(int cap) {                   // package-private
  #if[rw]
<span class="line-modified">!         super(-1, 0, cap, cap);</span>
          boolean pa = VM.isDirectMemoryPageAligned();
          int ps = Bits.pageSize();
          long size = Math.max(1L, (long)cap + (pa ? ps : 0));
          Bits.reserveMemory(size, cap);
  
<span class="line-new-header">--- 111,11 ---</span>
  
      // Primary constructor
      //
      Direct$Type$Buffer$RW$(int cap) {                   // package-private
  #if[rw]
<span class="line-modified">!         super(-1, 0, cap, cap, null);</span>
          boolean pa = VM.isDirectMemoryPageAligned();
          int ps = Bits.pageSize();
          long size = Math.max(1L, (long)cap + (pa ? ps : 0));
          Bits.reserveMemory(size, cap);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,22 ***</span>
  #if[rw]
  
      // Invoked to construct a direct ByteBuffer referring to the block of
      // memory. A given arbitrary object may also be attached to the buffer.
      //
<span class="line-modified">!     Direct$Type$Buffer(long addr, int cap, Object ob) {</span>
<span class="line-modified">!         super(-1, 0, cap, cap);</span>
          address = addr;
          cleaner = null;
          att = ob;
      }
  
  
      // Invoked only by JNI: NewDirectByteBuffer(void*, long)
      //
      private Direct$Type$Buffer(long addr, int cap) {
<span class="line-modified">!         super(-1, 0, cap, cap);</span>
          address = addr;
          cleaner = null;
          att = null;
      }
  
<span class="line-new-header">--- 144,22 ---</span>
  #if[rw]
  
      // Invoked to construct a direct ByteBuffer referring to the block of
      // memory. A given arbitrary object may also be attached to the buffer.
      //
<span class="line-modified">!     Direct$Type$Buffer(long addr, int cap, Object ob, MemorySegmentProxy segment) {</span>
<span class="line-modified">!         super(-1, 0, cap, cap, segment);</span>
          address = addr;
          cleaner = null;
          att = ob;
      }
  
  
      // Invoked only by JNI: NewDirectByteBuffer(void*, long)
      //
      private Direct$Type$Buffer(long addr, int cap) {
<span class="line-modified">!         super(-1, 0, cap, cap, null);</span>
          address = addr;
          cleaner = null;
          att = null;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,41 ***</span>
  
      // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
      //
      protected Direct$Type$Buffer$RW$(int cap, long addr,
                                       FileDescriptor fd,
<span class="line-modified">!                                      Runnable unmapper)</span>
      {
  #if[rw]
<span class="line-modified">!         super(-1, 0, cap, cap, fd);</span>
          address = addr;
          cleaner = Cleaner.create(this, unmapper);
          att = null;
  #else[rw]
<span class="line-modified">!         super(cap, addr, fd, unmapper);</span>
          this.isReadOnly = true;
  #end[rw]
      }
  
  #end[byte]
  
      // For duplicates and slices
      //
      Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private
                                 int mark, int pos, int lim, int cap,
<span class="line-modified">!                                int off)</span>
      {
  #if[rw]
<span class="line-modified">!         super(mark, pos, lim, cap);</span>
          address = db.address() + off;
  #if[byte]
          cleaner = null;
  #end[byte]
          Object attachment = db.attachment();
          att = (attachment == null ? db : attachment);
  #else[rw]
<span class="line-modified">!         super(db, mark, pos, lim, cap, off);</span>
          this.isReadOnly = true;
  #end[rw]
      }
  
      @Override
<span class="line-new-header">--- 167,42 ---</span>
  
      // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
      //
      protected Direct$Type$Buffer$RW$(int cap, long addr,
                                       FileDescriptor fd,
<span class="line-modified">!                                      Runnable unmapper,</span>
<span class="line-added">+                                      boolean isSync, MemorySegmentProxy segment)</span>
      {
  #if[rw]
<span class="line-modified">!         super(-1, 0, cap, cap, fd, isSync, segment);</span>
          address = addr;
          cleaner = Cleaner.create(this, unmapper);
          att = null;
  #else[rw]
<span class="line-modified">!         super(cap, addr, fd, unmapper, isSync, segment);</span>
          this.isReadOnly = true;
  #end[rw]
      }
  
  #end[byte]
  
      // For duplicates and slices
      //
      Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private
                                 int mark, int pos, int lim, int cap,
<span class="line-modified">!                                int off, MemorySegmentProxy segment)</span>
      {
  #if[rw]
<span class="line-modified">!         super(mark, pos, lim, cap, segment);</span>
          address = db.address() + off;
  #if[byte]
          cleaner = null;
  #end[byte]
          Object attachment = db.attachment();
          att = (attachment == null ? db : attachment);
  #else[rw]
<span class="line-modified">!         super(db, mark, pos, lim, cap, off, segment);</span>
          this.isReadOnly = true;
  #end[rw]
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,41 ***</span>
          int lim = this.limit();
          assert (pos &lt;= lim);
          int rem = (pos &lt;= lim ? lim - pos : 0);
          int off = (pos &lt;&lt; $LG_BYTES_PER_VALUE$);
          assert (off &gt;= 0);
<span class="line-modified">!         return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off);</span>
      }
  
      @Override
      public $Type$Buffer slice(int index, int length) {
          Objects.checkFromIndexSize(index, length, limit());
          return new Direct$Type$Buffer$RW$$BO$(this,
                                                -1,
                                                0,
                                                length,
                                                length,
<span class="line-modified">!                                               index);</span>
      }
  
      public $Type$Buffer duplicate() {
          return new Direct$Type$Buffer$RW$$BO$(this,
                                                this.markValue(),
                                                this.position(),
                                                this.limit(),
                                                this.capacity(),
<span class="line-modified">!                                               0);</span>
      }
  
      public $Type$Buffer asReadOnlyBuffer() {
  #if[rw]
          return new Direct$Type$BufferR$BO$(this,
                                             this.markValue(),
                                             this.position(),
                                             this.limit(),
                                             this.capacity(),
<span class="line-modified">!                                            0);</span>
  #else[rw]
          return duplicate();
  #end[rw]
      }
  
<span class="line-new-header">--- 215,41 ---</span>
          int lim = this.limit();
          assert (pos &lt;= lim);
          int rem = (pos &lt;= lim ? lim - pos : 0);
          int off = (pos &lt;&lt; $LG_BYTES_PER_VALUE$);
          assert (off &gt;= 0);
<span class="line-modified">!         return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off, segment);</span>
      }
  
      @Override
      public $Type$Buffer slice(int index, int length) {
          Objects.checkFromIndexSize(index, length, limit());
          return new Direct$Type$Buffer$RW$$BO$(this,
                                                -1,
                                                0,
                                                length,
                                                length,
<span class="line-modified">!                                               index, segment);</span>
      }
  
      public $Type$Buffer duplicate() {
          return new Direct$Type$Buffer$RW$$BO$(this,
                                                this.markValue(),
                                                this.position(),
                                                this.limit(),
                                                this.capacity(),
<span class="line-modified">!                                               0, segment);</span>
      }
  
      public $Type$Buffer asReadOnlyBuffer() {
  #if[rw]
          return new Direct$Type$BufferR$BO$(this,
                                             this.markValue(),
                                             this.position(),
                                             this.limit(),
                                             this.capacity(),
<span class="line-modified">!                                            0, segment);</span>
  #else[rw]
          return duplicate();
  #end[rw]
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,18 ***</span>
<span class="line-new-header">--- 263,20 ---</span>
          return address + ((long)i &lt;&lt; $LG_BYTES_PER_VALUE$);
      }
  
      public $type$ get() {
          try {
<span class="line-added">+             checkSegment();</span>
              return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));
          } finally {
              Reference.reachabilityFence(this);
          }
      }
  
      public $type$ get(int i) {
          try {
<span class="line-added">+             checkSegment();</span>
              return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));
          } finally {
              Reference.reachabilityFence(this);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,12 ***</span>
      }
  #end[streamableType]
  
      public $Type$Buffer get($type$[] dst, int offset, int length) {
  #if[rw]
          if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
<span class="line-modified">!             checkBounds(offset, length, dst.length);</span>
              int pos = position();
              int lim = limit();
              assert (pos &lt;= lim);
              int rem = (pos &lt;= lim ? lim - pos : 0);
              if (length &gt; rem)
<span class="line-new-header">--- 291,13 ---</span>
      }
  #end[streamableType]
  
      public $Type$Buffer get($type$[] dst, int offset, int length) {
  #if[rw]
<span class="line-added">+         checkSegment();</span>
          if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
<span class="line-modified">!             Objects.checkFromIndexSize(offset, length, dst.length);</span>
              int pos = position();
              int lim = limit();
              assert (pos &lt;= lim);
              int rem = (pos &lt;= lim ? lim - pos : 0);
              if (length &gt; rem)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,10 ***</span>
<span class="line-new-header">--- 333,11 ---</span>
  #end[rw]
      }
  
      public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
  #if[rw]
<span class="line-added">+         checkSegment();</span>
          if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
              Objects.checkFromIndexSize(index, length, limit());
              Objects.checkFromIndexSize(offset, length, dst.length);
  
              long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,10 ***</span>
<span class="line-new-header">--- 371,11 ---</span>
  #end[rw]
  
      public $Type$Buffer put($type$ x) {
  #if[rw]
          try {
<span class="line-added">+             checkSegment();</span>
              UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));
          } finally {
              Reference.reachabilityFence(this);
          }
          return this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,10 ***</span>
<span class="line-new-header">--- 385,11 ---</span>
      }
  
      public $Type$Buffer put(int i, $type$ x) {
  #if[rw]
          try {
<span class="line-added">+             checkSegment();</span>
              UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));
          } finally {
              Reference.reachabilityFence(this);
          }
          return this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,10 ***</span>
<span class="line-new-header">--- 398,11 ---</span>
  #end[rw]
      }
  
      public $Type$Buffer put($Type$Buffer src) {
  #if[rw]
<span class="line-added">+         checkSegment();</span>
          if (src instanceof Direct$Type$Buffer$BO$) {
              if (src == this)
                  throw createSameBufferException();
              Direct$Type$Buffer$RW$$BO$ sb = (Direct$Type$Buffer$RW$$BO$)src;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,12 ***</span>
  #end[rw]
      }
  
      public $Type$Buffer put($type$[] src, int offset, int length) {
  #if[rw]
          if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
<span class="line-modified">!             checkBounds(offset, length, src.length);</span>
              int pos = position();
              int lim = limit();
              assert (pos &lt;= lim);
              int rem = (pos &lt;= lim ? lim - pos : 0);
              if (length &gt; rem)
<span class="line-new-header">--- 445,13 ---</span>
  #end[rw]
      }
  
      public $Type$Buffer put($type$[] src, int offset, int length) {
  #if[rw]
<span class="line-added">+         checkSegment();</span>
          if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
<span class="line-modified">!             Objects.checkFromIndexSize(offset, length, src.length);</span>
              int pos = position();
              int lim = limit();
              assert (pos &lt;= lim);
              int rem = (pos &lt;= lim ? lim - pos : 0);
              if (length &gt; rem)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,10 ***</span>
<span class="line-new-header">--- 487,11 ---</span>
  #end[rw]
      }
  
      public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
  #if[rw]
<span class="line-added">+         checkSegment();</span>
          if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
              Objects.checkFromIndexSize(index, length, limit());
              Objects.checkFromIndexSize(offset, length, src.length);
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,12 ***</span>
  
  
  #if[char]
  
      public String toString(int start, int end) {
<span class="line-modified">!         if ((end &gt; limit()) || (start &gt; end))</span>
<span class="line-removed">-             throw new IndexOutOfBoundsException();</span>
          try {
              int len = end - start;
              char[] ca = new char[len];
              CharBuffer cb = CharBuffer.wrap(ca);
              CharBuffer db = this.duplicate();
<span class="line-new-header">--- 554,11 ---</span>
  
  
  #if[char]
  
      public String toString(int start, int end) {
<span class="line-modified">!         Objects.checkFromToIndex(start, end, limit());</span>
          try {
              int len = end - start;
              char[] ca = new char[len];
              CharBuffer cb = CharBuffer.wrap(ca);
              CharBuffer db = this.duplicate();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,18 ***</span>
          int lim = limit();
          assert (pos &lt;= lim);
          pos = (pos &lt;= lim ? pos : lim);
          int len = lim - pos;
  
<span class="line-modified">!         if ((start &lt; 0) || (end &gt; len) || (start &gt; end))</span>
<span class="line-removed">-             throw new IndexOutOfBoundsException();</span>
          return new DirectCharBuffer$RW$$BO$(this,
                                              -1,
                                              pos + start,
                                              pos + end,
                                              capacity(),
<span class="line-modified">!                                             offset);</span>
      }
  
  #end[char]
  
  
<span class="line-new-header">--- 579,17 ---</span>
          int lim = limit();
          assert (pos &lt;= lim);
          pos = (pos &lt;= lim ? pos : lim);
          int len = lim - pos;
  
<span class="line-modified">!         Objects.checkFromToIndex(start, end, len);</span>
          return new DirectCharBuffer$RW$$BO$(this,
                                              -1,
                                              pos + start,
                                              pos + end,
                                              capacity(),
<span class="line-modified">!                                             offset, segment);</span>
      }
  
  #end[char]
  
  
</pre>
<center><a href="Direct-X-Buffer-bin.java.template.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Heap-X-Buffer.java.template.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
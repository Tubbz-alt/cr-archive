<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/format/DateTimeFormatter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time.format;
  63 
  64 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
  65 import static java.time.temporal.ChronoField.DAY_OF_WEEK;
  66 import static java.time.temporal.ChronoField.DAY_OF_YEAR;
  67 import static java.time.temporal.ChronoField.HOUR_OF_DAY;
  68 import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
  69 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  70 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  71 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
  72 import static java.time.temporal.ChronoField.YEAR;
  73 
  74 import java.io.IOException;
  75 import java.text.FieldPosition;
  76 import java.text.Format;
  77 import java.text.ParseException;
  78 import java.text.ParsePosition;
  79 import java.time.DateTimeException;
  80 import java.time.Period;
  81 import java.time.ZoneId;
  82 import java.time.ZoneOffset;
  83 import java.time.chrono.ChronoLocalDateTime;
  84 import java.time.chrono.Chronology;
  85 import java.time.chrono.IsoChronology;
  86 import java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;
  87 import java.time.temporal.ChronoField;
  88 import java.time.temporal.IsoFields;
  89 import java.time.temporal.TemporalAccessor;
  90 import java.time.temporal.TemporalField;
  91 import java.time.temporal.TemporalQuery;
  92 import java.util.Arrays;
  93 import java.util.Collections;
  94 import java.util.HashMap;
  95 import java.util.HashSet;
  96 import java.util.Locale;
  97 import java.util.Map;
  98 import java.util.Objects;
  99 import java.util.Set;
 100 import sun.util.locale.provider.TimeZoneNameUtility;
 101 
 102 /**
 103  * Formatter for printing and parsing date-time objects.
 104  * &lt;p&gt;
 105  * This class provides the main application entry point for printing and parsing
 106  * and provides common implementations of {@code DateTimeFormatter}:
 107  * &lt;ul&gt;
 108  * &lt;li&gt;Using predefined constants, such as {@link #ISO_LOCAL_DATE}&lt;/li&gt;
 109  * &lt;li&gt;Using pattern letters, such as {@code uuuu-MMM-dd}&lt;/li&gt;
 110  * &lt;li&gt;Using localized styles, such as {@code long} or {@code medium}&lt;/li&gt;
 111  * &lt;/ul&gt;
 112  * &lt;p&gt;
 113  * More complex formatters are provided by
 114  * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.
 115  *
 116  * &lt;p&gt;
 117  * The main date-time classes provide two methods - one for formatting,
 118  * {@code format(DateTimeFormatter formatter)}, and one for parsing,
 119  * {@code parse(CharSequence text, DateTimeFormatter formatter)}.
 120  * &lt;p&gt;For example:
 121  * &lt;blockquote&gt;&lt;pre&gt;
 122  *  LocalDate date = LocalDate.now();
 123  *  String text = date.format(formatter);
 124  *  LocalDate parsedDate = LocalDate.parse(text, formatter);
 125  * &lt;/pre&gt;&lt;/blockquote&gt;
 126  * &lt;p&gt;
 127  * In addition to the format, formatters can be created with desired Locale,
 128  * Chronology, ZoneId, and DecimalStyle.
 129  * &lt;p&gt;
 130  * The {@link #withLocale withLocale} method returns a new formatter that
 131  * overrides the locale. The locale affects some aspects of formatting and
 132  * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a
 133  * formatter that uses the locale specific date format.
 134  * &lt;p&gt;
 135  * The {@link #withChronology withChronology} method returns a new formatter
 136  * that overrides the chronology. If overridden, the date-time value is
 137  * converted to the chronology before formatting. During parsing the date-time
 138  * value is converted to the chronology before it is returned.
 139  * &lt;p&gt;
 140  * The {@link #withZone withZone} method returns a new formatter that overrides
 141  * the zone. If overridden, the date-time value is converted to a ZonedDateTime
 142  * with the requested ZoneId before formatting. During parsing the ZoneId is
 143  * applied before the value is returned.
 144  * &lt;p&gt;
 145  * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that
 146  * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for
 147  * formatting and parsing.
 148  * &lt;p&gt;
 149  * Some applications may need to use the older {@link Format java.text.Format}
 150  * class for formatting. The {@link #toFormat()} method returns an
 151  * implementation of {@code java.text.Format}.
 152  *
<a name="2" id="anc2"></a><span class="line-modified"> 153  * &lt;h3 id=&quot;predefined&quot;&gt;Predefined Formatters&lt;/h3&gt;</span>
 154  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 155  * &lt;caption&gt;Predefined Formatters&lt;/caption&gt;
 156  * &lt;thead&gt;
 157  * &lt;tr&gt;
 158  * &lt;th scope=&quot;col&quot;&gt;Formatter&lt;/th&gt;
 159  * &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 160  * &lt;th scope=&quot;col&quot;&gt;Example&lt;/th&gt;
 161  * &lt;/tr&gt;
 162  * &lt;/thead&gt;
 163  * &lt;tbody&gt;
 164  * &lt;tr&gt;
 165  * &lt;th scope=&quot;row&quot;&gt;{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} &lt;/th&gt;
 166  * &lt;td&gt; Formatter with date style from the locale &lt;/td&gt;
 167  * &lt;td&gt; &#39;2011-12-03&#39;&lt;/td&gt;
 168  * &lt;/tr&gt;
 169  * &lt;tr&gt;
 170  * &lt;th scope=&quot;row&quot;&gt; {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} &lt;/th&gt;
 171  * &lt;td&gt; Formatter with time style from the locale &lt;/td&gt;
 172  * &lt;td&gt; &#39;10:15:30&#39;&lt;/td&gt;
 173  * &lt;/tr&gt;
 174  * &lt;tr&gt;
 175  * &lt;th scope=&quot;row&quot;&gt; {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} &lt;/th&gt;
 176  * &lt;td&gt; Formatter with a style for date and time from the locale&lt;/td&gt;
 177  * &lt;td&gt; &#39;3 Jun 2008 11:05:30&#39;&lt;/td&gt;
 178  * &lt;/tr&gt;
 179  * &lt;tr&gt;
 180  * &lt;th scope=&quot;row&quot;&gt; {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}
 181  * &lt;/th&gt;
 182  * &lt;td&gt; Formatter with date and time styles from the locale &lt;/td&gt;
 183  * &lt;td&gt; &#39;3 Jun 2008 11:05&#39;&lt;/td&gt;
 184  * &lt;/tr&gt;
 185  * &lt;tr&gt;
 186  * &lt;th scope=&quot;row&quot;&gt; {@link #BASIC_ISO_DATE}&lt;/th&gt;
 187  * &lt;td&gt;Basic ISO date &lt;/td&gt; &lt;td&gt;&#39;20111203&#39;&lt;/td&gt;
 188  * &lt;/tr&gt;
 189  * &lt;tr&gt;
 190  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_LOCAL_DATE}&lt;/th&gt;
 191  * &lt;td&gt; ISO Local Date &lt;/td&gt;
 192  * &lt;td&gt;&#39;2011-12-03&#39;&lt;/td&gt;
 193  * &lt;/tr&gt;
 194  * &lt;tr&gt;
 195  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_OFFSET_DATE}&lt;/th&gt;
 196  * &lt;td&gt; ISO Date with offset &lt;/td&gt;
 197  * &lt;td&gt;&#39;2011-12-03+01:00&#39;&lt;/td&gt;
 198  * &lt;/tr&gt;
 199  * &lt;tr&gt;
 200  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_DATE}&lt;/th&gt;
 201  * &lt;td&gt; ISO Date with or without offset &lt;/td&gt;
 202  * &lt;td&gt; &#39;2011-12-03+01:00&#39;; &#39;2011-12-03&#39;&lt;/td&gt;
 203  * &lt;/tr&gt;
 204  * &lt;tr&gt;
 205  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_LOCAL_TIME}&lt;/th&gt;
 206  * &lt;td&gt; Time without offset &lt;/td&gt;
 207  * &lt;td&gt;&#39;10:15:30&#39;&lt;/td&gt;
 208  * &lt;/tr&gt;
 209  * &lt;tr&gt;
 210  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_OFFSET_TIME}&lt;/th&gt;
 211  * &lt;td&gt; Time with offset &lt;/td&gt;
 212  * &lt;td&gt;&#39;10:15:30+01:00&#39;&lt;/td&gt;
 213  * &lt;/tr&gt;
 214  * &lt;tr&gt;
 215  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_TIME}&lt;/th&gt;
 216  * &lt;td&gt; Time with or without offset &lt;/td&gt;
 217  * &lt;td&gt;&#39;10:15:30+01:00&#39;; &#39;10:15:30&#39;&lt;/td&gt;
 218  * &lt;/tr&gt;
 219  * &lt;tr&gt;
 220  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_LOCAL_DATE_TIME}&lt;/th&gt;
 221  * &lt;td&gt; ISO Local Date and Time &lt;/td&gt;
 222  * &lt;td&gt;&#39;2011-12-03T10:15:30&#39;&lt;/td&gt;
 223  * &lt;/tr&gt;
 224  * &lt;tr&gt;
 225  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_OFFSET_DATE_TIME}&lt;/th&gt;
 226  * &lt;td&gt; Date Time with Offset
 227  * &lt;/td&gt;&lt;td&gt;&#39;2011-12-03T10:15:30+01:00&#39;&lt;/td&gt;
 228  * &lt;/tr&gt;
 229  * &lt;tr&gt;
 230  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_ZONED_DATE_TIME}&lt;/th&gt;
 231  * &lt;td&gt; Zoned Date Time &lt;/td&gt;
 232  * &lt;td&gt;&#39;2011-12-03T10:15:30+01:00[Europe/Paris]&#39;&lt;/td&gt;
 233  * &lt;/tr&gt;
 234  * &lt;tr&gt;
 235  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_DATE_TIME}&lt;/th&gt;
 236  * &lt;td&gt; Date and time with ZoneId &lt;/td&gt;
 237  * &lt;td&gt;&#39;2011-12-03T10:15:30+01:00[Europe/Paris]&#39;&lt;/td&gt;
 238  * &lt;/tr&gt;
 239  * &lt;tr&gt;
 240  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_ORDINAL_DATE}&lt;/th&gt;
 241  * &lt;td&gt; Year and day of year &lt;/td&gt;
 242  * &lt;td&gt;&#39;2012-337&#39;&lt;/td&gt;
 243  * &lt;/tr&gt;
 244  * &lt;tr&gt;
 245  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_WEEK_DATE}&lt;/th&gt;
 246  * &lt;td&gt; Year and Week &lt;/td&gt;
 247  * &lt;td&gt;&#39;2012-W48-6&#39;&lt;/td&gt;&lt;/tr&gt;
 248  * &lt;tr&gt;
 249  * &lt;th scope=&quot;row&quot;&gt; {@link #ISO_INSTANT}&lt;/th&gt;
 250  * &lt;td&gt; Date and Time of an Instant &lt;/td&gt;
 251  * &lt;td&gt;&#39;2011-12-03T10:15:30Z&#39; &lt;/td&gt;
 252  * &lt;/tr&gt;
 253  * &lt;tr&gt;
 254  * &lt;th scope=&quot;row&quot;&gt; {@link #RFC_1123_DATE_TIME}&lt;/th&gt;
 255  * &lt;td&gt; RFC 1123 / RFC 822 &lt;/td&gt;
 256  * &lt;td&gt;&#39;Tue, 3 Jun 2008 11:05:30 GMT&#39;&lt;/td&gt;
 257  * &lt;/tr&gt;
 258  * &lt;/tbody&gt;
 259  * &lt;/table&gt;
 260  *
<a name="3" id="anc3"></a><span class="line-modified"> 261  * &lt;h3 id=&quot;patterns&quot;&gt;Patterns for Formatting and Parsing&lt;/h3&gt;</span>
 262  * Patterns are based on a simple sequence of letters and symbols.
 263  * A pattern is used to create a Formatter using the
 264  * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.
 265  * For example,
 266  * {@code &quot;d MMM uuuu&quot;} will format 2011-12-03 as &#39;3&amp;nbsp;Dec&amp;nbsp;2011&#39;.
 267  * A formatter created from a pattern can be used as many times as necessary,
 268  * it is immutable and is thread-safe.
 269  * &lt;p&gt;
 270  * For example:
 271  * &lt;blockquote&gt;&lt;pre&gt;
 272  *  LocalDate date = LocalDate.now();
 273  *  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);
 274  *  String text = date.format(formatter);
 275  *  LocalDate parsedDate = LocalDate.parse(text, formatter);
 276  * &lt;/pre&gt;&lt;/blockquote&gt;
 277  * &lt;p&gt;
 278  * All letters &#39;A&#39; to &#39;Z&#39; and &#39;a&#39; to &#39;z&#39; are reserved as pattern letters. The
 279  * following pattern letters are defined:
 280  * &lt;table class=&quot;striped&quot;&gt;
 281  * &lt;caption&gt;Pattern Letters and Symbols&lt;/caption&gt;
 282  * &lt;thead&gt;
 283  *  &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Symbol&lt;/th&gt;   &lt;th scope=&quot;col&quot;&gt;Meaning&lt;/th&gt;         &lt;th scope=&quot;col&quot;&gt;Presentation&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Examples&lt;/th&gt;
 284  * &lt;/thead&gt;
 285  * &lt;tbody&gt;
 286  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;G&lt;/th&gt;       &lt;td&gt;era&lt;/td&gt;                         &lt;td&gt;text&lt;/td&gt;              &lt;td&gt;AD; Anno Domini; A&lt;/td&gt;
 287  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;u&lt;/th&gt;       &lt;td&gt;year&lt;/td&gt;                        &lt;td&gt;year&lt;/td&gt;              &lt;td&gt;2004; 04&lt;/td&gt;
 288  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;y&lt;/th&gt;       &lt;td&gt;year-of-era&lt;/td&gt;                 &lt;td&gt;year&lt;/td&gt;              &lt;td&gt;2004; 04&lt;/td&gt;
 289  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;D&lt;/th&gt;       &lt;td&gt;day-of-year&lt;/td&gt;                 &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;189&lt;/td&gt;
 290  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;M/L&lt;/th&gt;     &lt;td&gt;month-of-year&lt;/td&gt;               &lt;td&gt;number/text&lt;/td&gt;       &lt;td&gt;7; 07; Jul; July; J&lt;/td&gt;
 291  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;d&lt;/th&gt;       &lt;td&gt;day-of-month&lt;/td&gt;                &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;10&lt;/td&gt;
 292  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;g&lt;/th&gt;       &lt;td&gt;modified-julian-day&lt;/td&gt;         &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;2451334&lt;/td&gt;
 293  *
 294  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Q/q&lt;/th&gt;     &lt;td&gt;quarter-of-year&lt;/td&gt;             &lt;td&gt;number/text&lt;/td&gt;       &lt;td&gt;3; 03; Q3; 3rd quarter&lt;/td&gt;
 295  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Y&lt;/th&gt;       &lt;td&gt;week-based-year&lt;/td&gt;             &lt;td&gt;year&lt;/td&gt;              &lt;td&gt;1996; 96&lt;/td&gt;
 296  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;w&lt;/th&gt;       &lt;td&gt;week-of-week-based-year&lt;/td&gt;     &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;27&lt;/td&gt;
 297  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;W&lt;/th&gt;       &lt;td&gt;week-of-month&lt;/td&gt;               &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;4&lt;/td&gt;
 298  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;E&lt;/th&gt;       &lt;td&gt;day-of-week&lt;/td&gt;                 &lt;td&gt;text&lt;/td&gt;              &lt;td&gt;Tue; Tuesday; T&lt;/td&gt;
 299  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;e/c&lt;/th&gt;     &lt;td&gt;localized day-of-week&lt;/td&gt;       &lt;td&gt;number/text&lt;/td&gt;       &lt;td&gt;2; 02; Tue; Tuesday; T&lt;/td&gt;
 300  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;F&lt;/th&gt;       &lt;td&gt;day-of-week-in-month&lt;/td&gt;        &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;3&lt;/td&gt;
 301  *
 302  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;a&lt;/th&gt;       &lt;td&gt;am-pm-of-day&lt;/td&gt;                &lt;td&gt;text&lt;/td&gt;              &lt;td&gt;PM&lt;/td&gt;
 303  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;h&lt;/th&gt;       &lt;td&gt;clock-hour-of-am-pm (1-12)&lt;/td&gt;  &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;12&lt;/td&gt;
 304  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;K&lt;/th&gt;       &lt;td&gt;hour-of-am-pm (0-11)&lt;/td&gt;        &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;0&lt;/td&gt;
 305  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;k&lt;/th&gt;       &lt;td&gt;clock-hour-of-day (1-24)&lt;/td&gt;    &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;24&lt;/td&gt;
 306  *
 307  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;H&lt;/th&gt;       &lt;td&gt;hour-of-day (0-23)&lt;/td&gt;          &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;0&lt;/td&gt;
 308  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;m&lt;/th&gt;       &lt;td&gt;minute-of-hour&lt;/td&gt;              &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;30&lt;/td&gt;
 309  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;s&lt;/th&gt;       &lt;td&gt;second-of-minute&lt;/td&gt;            &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;55&lt;/td&gt;
 310  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;S&lt;/th&gt;       &lt;td&gt;fraction-of-second&lt;/td&gt;          &lt;td&gt;fraction&lt;/td&gt;          &lt;td&gt;978&lt;/td&gt;
 311  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;A&lt;/th&gt;       &lt;td&gt;milli-of-day&lt;/td&gt;                &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;1234&lt;/td&gt;
 312  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;n&lt;/th&gt;       &lt;td&gt;nano-of-second&lt;/td&gt;              &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;987654321&lt;/td&gt;
 313  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;N&lt;/th&gt;       &lt;td&gt;nano-of-day&lt;/td&gt;                 &lt;td&gt;number&lt;/td&gt;            &lt;td&gt;1234000000&lt;/td&gt;
 314  *
 315  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;V&lt;/th&gt;       &lt;td&gt;time-zone ID&lt;/td&gt;                &lt;td&gt;zone-id&lt;/td&gt;           &lt;td&gt;America/Los_Angeles; Z; -08:30&lt;/td&gt;
 316  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;v&lt;/th&gt;       &lt;td&gt;generic time-zone name&lt;/td&gt;      &lt;td&gt;zone-name&lt;/td&gt;         &lt;td&gt;Pacific Time; PT&lt;/td&gt;
 317  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;z&lt;/th&gt;       &lt;td&gt;time-zone name&lt;/td&gt;              &lt;td&gt;zone-name&lt;/td&gt;         &lt;td&gt;Pacific Standard Time; PST&lt;/td&gt;
 318  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;O&lt;/th&gt;       &lt;td&gt;localized zone-offset&lt;/td&gt;       &lt;td&gt;offset-O&lt;/td&gt;          &lt;td&gt;GMT+8; GMT+08:00; UTC-08:00&lt;/td&gt;
 319  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;X&lt;/th&gt;       &lt;td&gt;zone-offset &#39;Z&#39; for zero&lt;/td&gt;    &lt;td&gt;offset-X&lt;/td&gt;          &lt;td&gt;Z; -08; -0830; -08:30; -083015; -08:30:15&lt;/td&gt;
 320  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;x&lt;/th&gt;       &lt;td&gt;zone-offset&lt;/td&gt;                 &lt;td&gt;offset-x&lt;/td&gt;          &lt;td&gt;+0000; -08; -0830; -08:30; -083015; -08:30:15&lt;/td&gt;
 321  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Z&lt;/th&gt;       &lt;td&gt;zone-offset&lt;/td&gt;                 &lt;td&gt;offset-Z&lt;/td&gt;          &lt;td&gt;+0000; -0800; -08:00&lt;/td&gt;
 322  *
 323  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;p&lt;/th&gt;       &lt;td&gt;pad next&lt;/td&gt;                    &lt;td&gt;pad modifier&lt;/td&gt;      &lt;td&gt;1&lt;/td&gt;
 324  *
 325  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&#39;&lt;/th&gt;       &lt;td&gt;escape for text&lt;/td&gt;             &lt;td&gt;delimiter&lt;/td&gt;         &lt;td&gt;&lt;/td&gt;
 326  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&#39;&#39;&lt;/th&gt;      &lt;td&gt;single quote&lt;/td&gt;                &lt;td&gt;literal&lt;/td&gt;           &lt;td&gt;&#39;&lt;/td&gt;
 327  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;[&lt;/th&gt;       &lt;td&gt;optional section start&lt;/td&gt;      &lt;td&gt;&lt;/td&gt;                  &lt;td&gt;&lt;/td&gt;
 328  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;]&lt;/th&gt;       &lt;td&gt;optional section end&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;                  &lt;td&gt;&lt;/td&gt;
 329  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;#&lt;/th&gt;       &lt;td&gt;reserved for future use&lt;/td&gt;     &lt;td&gt;&lt;/td&gt;                  &lt;td&gt;&lt;/td&gt;
 330  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{&lt;/th&gt;       &lt;td&gt;reserved for future use&lt;/td&gt;     &lt;td&gt;&lt;/td&gt;                  &lt;td&gt;&lt;/td&gt;
 331  *   &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;}&lt;/th&gt;       &lt;td&gt;reserved for future use&lt;/td&gt;     &lt;td&gt;&lt;/td&gt;                  &lt;td&gt;&lt;/td&gt;
 332  * &lt;/tbody&gt;
 333  * &lt;/table&gt;
 334  * &lt;p&gt;
 335  * The count of pattern letters determines the format.
 336  * &lt;p&gt;
 337  * &lt;b&gt;Text&lt;/b&gt;: The text style is determined based on the number of pattern
 338  * letters used. Less than 4 pattern letters will use the
 339  * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the
 340  * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the
 341  * {@link TextStyle#NARROW narrow form}.
 342  * Pattern letters &#39;L&#39;, &#39;c&#39;, and &#39;q&#39; specify the stand-alone form of the text styles.
 343  * &lt;p&gt;
 344  * &lt;b&gt;Number&lt;/b&gt;: If the count of letters is one, then the value is output using
 345  * the minimum number of digits and without padding. Otherwise, the count of digits
 346  * is used as the width of the output field, with the value zero-padded as necessary.
 347  * The following pattern letters have constraints on the count of letters.
 348  * Only one letter of &#39;c&#39; and &#39;F&#39; can be specified.
 349  * Up to two letters of &#39;d&#39;, &#39;H&#39;, &#39;h&#39;, &#39;K&#39;, &#39;k&#39;, &#39;m&#39;, and &#39;s&#39; can be specified.
 350  * Up to three letters of &#39;D&#39; can be specified.
 351  * &lt;p&gt;
 352  * &lt;b&gt;Number/Text&lt;/b&gt;: If the count of pattern letters is 3 or greater, use the
 353  * Text rules above. Otherwise use the Number rules above.
 354  * &lt;p&gt;
 355  * &lt;b&gt;Fraction&lt;/b&gt;: Outputs the nano-of-second field as a fraction-of-second.
 356  * The nano-of-second value has nine digits, thus the count of pattern letters
 357  * is from 1 to 9. If it is less than 9, then the nano-of-second value is
 358  * truncated, with only the most significant digits being output.
 359  * &lt;p&gt;
 360  * &lt;b&gt;Year&lt;/b&gt;: The count of letters determines the minimum field width below
 361  * which padding is used. If the count of letters is two, then a
 362  * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is
 363  * used. For printing, this outputs the rightmost two digits. For parsing, this
 364  * will parse using the base value of 2000, resulting in a year within the range
 365  * 2000 to 2099 inclusive. If the count of letters is less than four (but not
 366  * two), then the sign is only output for negative years as per
 367  * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is
 368  * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.
 369  * &lt;p&gt;
 370  * &lt;b&gt;ZoneId&lt;/b&gt;: This outputs the time-zone ID, such as &#39;Europe/Paris&#39;. If the
 371  * count of letters is two, then the time-zone ID is output. Any other count of
 372  * letters throws {@code IllegalArgumentException}.
 373  * &lt;p&gt;
 374  * &lt;b&gt;Zone names&lt;/b&gt;: This outputs the display name of the time-zone ID. If the
 375  * pattern letter is &#39;z&#39; the output is the daylight savings aware zone name.
 376  * If there is insufficient information to determine whether DST applies,
 377  * the name ignoring daylight savings time will be used.
 378  * If the count of letters is one, two or three, then the short name is output.
 379  * If the count of letters is four, then the full name is output.
 380  * Five or more letters throws {@code IllegalArgumentException}.
 381  * &lt;p&gt;
 382  * If the pattern letter is &#39;v&#39; the output provides the zone name ignoring
 383  * daylight savings time. If the count of letters is one, then the short name is output.
 384  * If the count of letters is four, then the full name is output.
 385  * Two, three and five or more letters throw {@code IllegalArgumentException}.
 386  * &lt;p&gt;
 387  * &lt;b&gt;Offset X and x&lt;/b&gt;: This formats the offset based on the number of pattern
 388  * letters. One letter outputs just the hour, such as &#39;+01&#39;, unless the minute
 389  * is non-zero in which case the minute is also output, such as &#39;+0130&#39;. Two
 390  * letters outputs the hour and minute, without a colon, such as &#39;+0130&#39;. Three
 391  * letters outputs the hour and minute, with a colon, such as &#39;+01:30&#39;. Four
 392  * letters outputs the hour and minute and optional second, without a colon,
 393  * such as &#39;+013015&#39;. Five letters outputs the hour and minute and optional
 394  * second, with a colon, such as &#39;+01:30:15&#39;. Six or more letters throws
 395  * {@code IllegalArgumentException}. Pattern letter &#39;X&#39; (upper case) will output
 396  * &#39;Z&#39; when the offset to be output would be zero, whereas pattern letter &#39;x&#39;
 397  * (lower case) will output &#39;+00&#39;, &#39;+0000&#39;, or &#39;+00:00&#39;.
 398  * &lt;p&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 399  * &lt;b&gt;Offset O&lt;/b&gt;: This formats the localized offset based on the number of</span>
<span class="line-modified"> 400  * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}</span>
<span class="line-modified"> 401  * form of the localized offset, which is localized offset text, such as &#39;GMT&#39;,</span>
<span class="line-modified"> 402  * with hour without leading zero, optional 2-digit minute and second if</span>
<span class="line-modified"> 403  * non-zero, and colon, for example &#39;GMT+8&#39;. Four letters outputs the</span>
<span class="line-modified"> 404  * {@linkplain TextStyle#FULL full} form, which is localized offset text,</span>
<span class="line-modified"> 405  * such as &#39;GMT, with 2-digit hour and minute field, optional second field</span>
<span class="line-modified"> 406  * if non-zero, and colon, for example &#39;GMT+08:00&#39;. Any other count of letters</span>
<span class="line-modified"> 407  * throws {@code IllegalArgumentException}.</span>

 408  * &lt;p&gt;
 409  * &lt;b&gt;Offset Z&lt;/b&gt;: This formats the offset based on the number of pattern
 410  * letters. One, two or three letters outputs the hour and minute, without a
 411  * colon, such as &#39;+0130&#39;. The output will be &#39;+0000&#39; when the offset is zero.
 412  * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized
 413  * offset, equivalent to four letters of Offset-O. The output will be the
 414  * corresponding localized offset text if the offset is zero. Five
 415  * letters outputs the hour, minute, with optional second if non-zero, with
 416  * colon. It outputs &#39;Z&#39; if the offset is zero.
 417  * Six or more letters throws {@code IllegalArgumentException}.
 418  * &lt;p&gt;
 419  * &lt;b&gt;Optional section&lt;/b&gt;: The optional section markers work exactly like
 420  * calling {@link DateTimeFormatterBuilder#optionalStart()} and
 421  * {@link DateTimeFormatterBuilder#optionalEnd()}.
 422  * &lt;p&gt;
 423  * &lt;b&gt;Pad modifier&lt;/b&gt;: Modifies the pattern that immediately follows to be
 424  * padded with spaces. The pad width is determined by the number of pattern
 425  * letters. This is the same as calling
 426  * {@link DateTimeFormatterBuilder#padNext(int)}.
 427  * &lt;p&gt;
 428  * For example, &#39;ppH&#39; outputs the hour-of-day padded on the left with spaces to
 429  * a width of 2.
 430  * &lt;p&gt;
 431  * Any unrecognized letter is an error. Any non-letter character, other than
 432  * &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;#&#39; and the single quote will be output directly.
 433  * Despite this, it is recommended to use single quotes around all characters
 434  * that you want to output directly to ensure that future changes do not break
 435  * your application.
 436  *
<a name="5" id="anc5"></a><span class="line-modified"> 437  * &lt;h3 id=&quot;resolving&quot;&gt;Resolving&lt;/h3&gt;</span>
 438  * Parsing is implemented as a two-phase operation.
 439  * First, the text is parsed using the layout defined by the formatter, producing
 440  * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
 441  * Second, the parsed data is &lt;em&gt;resolved&lt;/em&gt;, by validating, combining and
 442  * simplifying the various fields into more useful ones.
 443  * &lt;p&gt;
 444  * Five parsing methods are supplied by this class.
 445  * Four of these perform both the parse and resolve phases.
 446  * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},
 447  * only performs the first phase, leaving the result unresolved.
 448  * As such, it is essentially a low-level operation.
 449  * &lt;p&gt;
 450  * The resolve phase is controlled by two parameters, set on this class.
 451  * &lt;p&gt;
 452  * The {@link ResolverStyle} is an enum that offers three different approaches,
 453  * strict, smart and lenient. The smart option is the default.
 454  * It can be set using {@link #withResolverStyle(ResolverStyle)}.
 455  * &lt;p&gt;
 456  * The {@link #withResolverFields(TemporalField...)} parameter allows the
 457  * set of fields that will be resolved to be filtered before resolving starts.
 458  * For example, if the formatter has parsed a year, month, day-of-month
 459  * and day-of-year, then there are two approaches to resolve a date:
 460  * (year + month + day-of-month) and (year + day-of-year).
 461  * The resolver fields allows one of the two approaches to be selected.
 462  * If no resolver fields are set then both approaches must result in the same date.
 463  * &lt;p&gt;
 464  * Resolving separate fields to form a complete date and time is a complex
 465  * process with behaviour distributed across a number of classes.
 466  * It follows these steps:
 467  * &lt;ol&gt;
 468  * &lt;li&gt;The chronology is determined.
 469  * The chronology of the result is either the chronology that was parsed,
 470  * or if no chronology was parsed, it is the chronology set on this class,
 471  * or if that is null, it is {@code IsoChronology}.
 472  * &lt;li&gt;The {@code ChronoField} date fields are resolved.
 473  * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.
 474  * Documentation about field resolution is located in the implementation
 475  * of {@code Chronology}.
 476  * &lt;li&gt;The {@code ChronoField} time fields are resolved.
 477  * This is documented on {@link ChronoField} and is the same for all chronologies.
 478  * &lt;li&gt;Any fields that are not {@code ChronoField} are processed.
 479  * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.
 480  * Documentation about field resolution is located in the implementation
 481  * of {@code TemporalField}.
 482  * &lt;li&gt;The {@code ChronoField} date and time fields are re-resolved.
 483  * This allows fields in step four to produce {@code ChronoField} values
 484  * and have them be processed into dates and times.
 485  * &lt;li&gt;A {@code LocalTime} is formed if there is at least an hour-of-day available.
 486  * This involves providing default values for minute, second and fraction of second.
 487  * &lt;li&gt;Any remaining unresolved fields are cross-checked against any
 488  * date and/or time that was resolved. Thus, an earlier stage would resolve
 489  * (year + month + day-of-month) to a date, and this stage would check that
 490  * day-of-week was valid for the date.
 491  * &lt;li&gt;If an {@linkplain #parsedExcessDays() excess number of days}
 492  * was parsed then it is added to the date if a date is available.
 493  * &lt;li&gt; If a second-based field is present, but {@code LocalTime} was not parsed,
 494  * then the resolver ensures that milli, micro and nano second values are
 495  * available to meet the contract of {@link ChronoField}.
 496  * These will be set to zero if missing.
 497  * &lt;li&gt;If both date and time were parsed and either an offset or zone is present,
 498  * the field {@link ChronoField#INSTANT_SECONDS} is created.
 499  * If an offset was parsed then the offset will be combined with the
 500  * {@code LocalDateTime} to form the instant, with any zone ignored.
 501  * If a {@code ZoneId} was parsed without an offset then the zone will be
 502  * combined with the {@code LocalDateTime} to form the instant using the rules
 503  * of {@link ChronoLocalDateTime#atZone(ZoneId)}.
 504  * &lt;/ol&gt;
 505  *
 506  * @implSpec
 507  * This class is immutable and thread-safe.
 508  *
 509  * @since 1.8
 510  */
 511 public final class DateTimeFormatter {
 512 
 513     /**
 514      * The printer and/or parser to use, not null.
 515      */
 516     private final CompositePrinterParser printerParser;
 517     /**
 518      * The locale to use for formatting, not null.
 519      */
 520     private final Locale locale;
 521     /**
 522      * The symbols to use for formatting, not null.
 523      */
 524     private final DecimalStyle decimalStyle;
 525     /**
 526      * The resolver style to use, not null.
 527      */
 528     private final ResolverStyle resolverStyle;
 529     /**
 530      * The fields to use in resolving, null for all fields.
 531      */
 532     private final Set&lt;TemporalField&gt; resolverFields;
 533     /**
 534      * The chronology to use for formatting, null for no override.
 535      */
 536     private final Chronology chrono;
 537     /**
 538      * The zone to use for formatting, null for no override.
 539      */
 540     private final ZoneId zone;
 541 
 542     //-----------------------------------------------------------------------
 543     /**
 544      * Creates a formatter using the specified pattern.
 545      * &lt;p&gt;
 546      * This method will create a formatter based on a simple
 547      * &lt;a href=&quot;#patterns&quot;&gt;pattern of letters and symbols&lt;/a&gt;
 548      * as described in the class documentation.
 549      * For example, {@code d MMM uuuu} will format 2011-12-03 as &#39;3 Dec 2011&#39;.
 550      * &lt;p&gt;
 551      * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
 552      * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.
 553      * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.
 554      * &lt;p&gt;
 555      * The returned formatter has no override chronology or zone.
 556      * It uses {@link ResolverStyle#SMART SMART} resolver style.
 557      *
 558      * @param pattern  the pattern to use, not null
 559      * @return the formatter based on the pattern, not null
 560      * @throws IllegalArgumentException if the pattern is invalid
 561      * @see DateTimeFormatterBuilder#appendPattern(String)
 562      */
 563     public static DateTimeFormatter ofPattern(String pattern) {
 564         return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
 565     }
 566 
 567     /**
 568      * Creates a formatter using the specified pattern and locale.
 569      * &lt;p&gt;
 570      * This method will create a formatter based on a simple
 571      * &lt;a href=&quot;#patterns&quot;&gt;pattern of letters and symbols&lt;/a&gt;
 572      * as described in the class documentation.
 573      * For example, {@code d MMM uuuu} will format 2011-12-03 as &#39;3 Dec 2011&#39;.
 574      * &lt;p&gt;
 575      * The formatter will use the specified locale.
 576      * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.
 577      * &lt;p&gt;
 578      * The returned formatter has no override chronology or zone.
 579      * It uses {@link ResolverStyle#SMART SMART} resolver style.
 580      *
 581      * @param pattern  the pattern to use, not null
 582      * @param locale  the locale to use, not null
 583      * @return the formatter based on the pattern, not null
 584      * @throws IllegalArgumentException if the pattern is invalid
 585      * @see DateTimeFormatterBuilder#appendPattern(String)
 586      */
 587     public static DateTimeFormatter ofPattern(String pattern, Locale locale) {
 588         return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);
 589     }
 590 
 591     //-----------------------------------------------------------------------
 592     /**
 593      * Returns a locale specific date format for the ISO chronology.
 594      * &lt;p&gt;
 595      * This returns a formatter that will format or parse a date.
 596      * The exact format pattern used varies by locale.
 597      * &lt;p&gt;
 598      * The locale is determined from the formatter. The formatter returned directly by
 599      * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
 600      * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
 601      * on the result of this method.
 602      * &lt;p&gt;
 603      * Note that the localized pattern is looked up lazily.
 604      * This {@code DateTimeFormatter} holds the style required and the locale,
 605      * looking up the pattern required on demand.
 606      * &lt;p&gt;
 607      * The returned formatter has a chronology of ISO set to ensure dates in
 608      * other calendar systems are correctly converted.
 609      * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
 610      *
 611      * @param dateStyle  the formatter style to obtain, not null
 612      * @return the date formatter, not null
 613      */
 614     public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {
 615         Objects.requireNonNull(dateStyle, &quot;dateStyle&quot;);
 616         return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)
 617                 .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);
 618     }
 619 
 620     /**
 621      * Returns a locale specific time format for the ISO chronology.
 622      * &lt;p&gt;
 623      * This returns a formatter that will format or parse a time.
 624      * The exact format pattern used varies by locale.
 625      * &lt;p&gt;
 626      * The locale is determined from the formatter. The formatter returned directly by
 627      * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
 628      * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
 629      * on the result of this method.
 630      * &lt;p&gt;
 631      * Note that the localized pattern is looked up lazily.
 632      * This {@code DateTimeFormatter} holds the style required and the locale,
 633      * looking up the pattern required on demand.
 634      * &lt;p&gt;
 635      * The returned formatter has a chronology of ISO set to ensure dates in
 636      * other calendar systems are correctly converted.
 637      * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
 638      * The {@code FULL} and {@code LONG} styles typically require a time-zone.
 639      * When formatting using these styles, a {@code ZoneId} must be available,
 640      * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.
 641      *
 642      * @param timeStyle  the formatter style to obtain, not null
 643      * @return the time formatter, not null
 644      */
 645     public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {
 646         Objects.requireNonNull(timeStyle, &quot;timeStyle&quot;);
 647         return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)
 648                 .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);
 649     }
 650 
 651     /**
 652      * Returns a locale specific date-time formatter for the ISO chronology.
 653      * &lt;p&gt;
 654      * This returns a formatter that will format or parse a date-time.
 655      * The exact format pattern used varies by locale.
 656      * &lt;p&gt;
 657      * The locale is determined from the formatter. The formatter returned directly by
 658      * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
 659      * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
 660      * on the result of this method.
 661      * &lt;p&gt;
 662      * Note that the localized pattern is looked up lazily.
 663      * This {@code DateTimeFormatter} holds the style required and the locale,
 664      * looking up the pattern required on demand.
 665      * &lt;p&gt;
 666      * The returned formatter has a chronology of ISO set to ensure dates in
 667      * other calendar systems are correctly converted.
 668      * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
 669      * The {@code FULL} and {@code LONG} styles typically require a time-zone.
 670      * When formatting using these styles, a {@code ZoneId} must be available,
 671      * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.
 672      *
 673      * @param dateTimeStyle  the formatter style to obtain, not null
 674      * @return the date-time formatter, not null
 675      */
 676     public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {
 677         Objects.requireNonNull(dateTimeStyle, &quot;dateTimeStyle&quot;);
 678         return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)
 679                 .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);
 680     }
 681 
 682     /**
 683      * Returns a locale specific date and time format for the ISO chronology.
 684      * &lt;p&gt;
 685      * This returns a formatter that will format or parse a date-time.
 686      * The exact format pattern used varies by locale.
 687      * &lt;p&gt;
 688      * The locale is determined from the formatter. The formatter returned directly by
 689      * this method will use the {@link Locale#getDefault() default FORMAT locale}.
 690      * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
 691      * on the result of this method.
 692      * &lt;p&gt;
 693      * Note that the localized pattern is looked up lazily.
 694      * This {@code DateTimeFormatter} holds the style required and the locale,
 695      * looking up the pattern required on demand.
 696      * &lt;p&gt;
 697      * The returned formatter has a chronology of ISO set to ensure dates in
 698      * other calendar systems are correctly converted.
 699      * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
 700      * The {@code FULL} and {@code LONG} styles typically require a time-zone.
 701      * When formatting using these styles, a {@code ZoneId} must be available,
 702      * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.
 703      *
 704      * @param dateStyle  the date formatter style to obtain, not null
 705      * @param timeStyle  the time formatter style to obtain, not null
 706      * @return the date, time or date-time formatter, not null
 707      */
 708     public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {
 709         Objects.requireNonNull(dateStyle, &quot;dateStyle&quot;);
 710         Objects.requireNonNull(timeStyle, &quot;timeStyle&quot;);
 711         return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)
 712                 .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);
 713     }
 714 
 715     //-----------------------------------------------------------------------
 716     /**
 717      * The ISO date formatter that formats or parses a date without an
 718      * offset, such as &#39;2011-12-03&#39;.
 719      * &lt;p&gt;
 720      * This returns an immutable formatter capable of formatting and parsing
 721      * the ISO-8601 extended local date format.
 722      * The format consists of:
 723      * &lt;ul&gt;
 724      * &lt;li&gt;Four digits or more for the {@link ChronoField#YEAR year}.
 725      * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
 726      * Years outside that range will have a prefixed positive or negative symbol.
 727      * &lt;li&gt;A dash
 728      * &lt;li&gt;Two digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.
 729      *  This is pre-padded by zero to ensure two digits.
 730      * &lt;li&gt;A dash
 731      * &lt;li&gt;Two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
 732      *  This is pre-padded by zero to ensure two digits.
 733      * &lt;/ul&gt;
 734      * &lt;p&gt;
 735      * The returned formatter has a chronology of ISO set to ensure dates in
 736      * other calendar systems are correctly converted.
 737      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 738      */
 739     public static final DateTimeFormatter ISO_LOCAL_DATE;
 740     static {
 741         ISO_LOCAL_DATE = new DateTimeFormatterBuilder()
 742                 .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
 743                 .appendLiteral(&#39;-&#39;)
 744                 .appendValue(MONTH_OF_YEAR, 2)
 745                 .appendLiteral(&#39;-&#39;)
 746                 .appendValue(DAY_OF_MONTH, 2)
 747                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
 748     }
 749 
 750     //-----------------------------------------------------------------------
 751     /**
 752      * The ISO date formatter that formats or parses a date with an
 753      * offset, such as &#39;2011-12-03+01:00&#39;.
 754      * &lt;p&gt;
 755      * This returns an immutable formatter capable of formatting and parsing
 756      * the ISO-8601 extended offset date format.
 757      * The format consists of:
 758      * &lt;ul&gt;
 759      * &lt;li&gt;The {@link #ISO_LOCAL_DATE}
 760      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
 761      *  they will be handled even though this is not part of the ISO-8601 standard.
 762      *  Parsing is case insensitive.
 763      * &lt;/ul&gt;
 764      * &lt;p&gt;
 765      * The returned formatter has a chronology of ISO set to ensure dates in
 766      * other calendar systems are correctly converted.
 767      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 768      */
 769     public static final DateTimeFormatter ISO_OFFSET_DATE;
 770     static {
 771         ISO_OFFSET_DATE = new DateTimeFormatterBuilder()
 772                 .parseCaseInsensitive()
 773                 .append(ISO_LOCAL_DATE)
 774                 .appendOffsetId()
 775                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
 776     }
 777 
 778     //-----------------------------------------------------------------------
 779     /**
 780      * The ISO date formatter that formats or parses a date with the
 781      * offset if available, such as &#39;2011-12-03&#39; or &#39;2011-12-03+01:00&#39;.
 782      * &lt;p&gt;
 783      * This returns an immutable formatter capable of formatting and parsing
 784      * the ISO-8601 extended date format.
 785      * The format consists of:
 786      * &lt;ul&gt;
 787      * &lt;li&gt;The {@link #ISO_LOCAL_DATE}
 788      * &lt;li&gt;If the offset is not available then the format is complete.
 789      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
 790      *  they will be handled even though this is not part of the ISO-8601 standard.
 791      *  Parsing is case insensitive.
 792      * &lt;/ul&gt;
 793      * &lt;p&gt;
 794      * As this formatter has an optional element, it may be necessary to parse using
 795      * {@link DateTimeFormatter#parseBest}.
 796      * &lt;p&gt;
 797      * The returned formatter has a chronology of ISO set to ensure dates in
 798      * other calendar systems are correctly converted.
 799      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 800      */
 801     public static final DateTimeFormatter ISO_DATE;
 802     static {
 803         ISO_DATE = new DateTimeFormatterBuilder()
 804                 .parseCaseInsensitive()
 805                 .append(ISO_LOCAL_DATE)
 806                 .optionalStart()
 807                 .appendOffsetId()
 808                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
 809     }
 810 
 811     //-----------------------------------------------------------------------
 812     /**
 813      * The ISO time formatter that formats or parses a time without an
 814      * offset, such as &#39;10:15&#39; or &#39;10:15:30&#39;.
 815      * &lt;p&gt;
 816      * This returns an immutable formatter capable of formatting and parsing
 817      * the ISO-8601 extended local time format.
 818      * The format consists of:
 819      * &lt;ul&gt;
 820      * &lt;li&gt;Two digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.
 821      *  This is pre-padded by zero to ensure two digits.
 822      * &lt;li&gt;A colon
 823      * &lt;li&gt;Two digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.
 824      *  This is pre-padded by zero to ensure two digits.
 825      * &lt;li&gt;If the second-of-minute is not available then the format is complete.
 826      * &lt;li&gt;A colon
 827      * &lt;li&gt;Two digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.
 828      *  This is pre-padded by zero to ensure two digits.
 829      * &lt;li&gt;If the nano-of-second is zero or not available then the format is complete.
 830      * &lt;li&gt;A decimal point
 831      * &lt;li&gt;One to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.
 832      *  As many digits will be output as required.
 833      * &lt;/ul&gt;
 834      * &lt;p&gt;
 835      * The returned formatter has no override chronology or zone.
 836      * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 837      */
 838     public static final DateTimeFormatter ISO_LOCAL_TIME;
 839     static {
 840         ISO_LOCAL_TIME = new DateTimeFormatterBuilder()
 841                 .appendValue(HOUR_OF_DAY, 2)
 842                 .appendLiteral(&#39;:&#39;)
 843                 .appendValue(MINUTE_OF_HOUR, 2)
 844                 .optionalStart()
 845                 .appendLiteral(&#39;:&#39;)
 846                 .appendValue(SECOND_OF_MINUTE, 2)
 847                 .optionalStart()
 848                 .appendFraction(NANO_OF_SECOND, 0, 9, true)
 849                 .toFormatter(ResolverStyle.STRICT, null);
 850     }
 851 
 852     //-----------------------------------------------------------------------
 853     /**
 854      * The ISO time formatter that formats or parses a time with an
 855      * offset, such as &#39;10:15+01:00&#39; or &#39;10:15:30+01:00&#39;.
 856      * &lt;p&gt;
 857      * This returns an immutable formatter capable of formatting and parsing
 858      * the ISO-8601 extended offset time format.
 859      * The format consists of:
 860      * &lt;ul&gt;
 861      * &lt;li&gt;The {@link #ISO_LOCAL_TIME}
 862      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
 863      *  they will be handled even though this is not part of the ISO-8601 standard.
 864      *  Parsing is case insensitive.
 865      * &lt;/ul&gt;
 866      * &lt;p&gt;
 867      * The returned formatter has no override chronology or zone.
 868      * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 869      */
 870     public static final DateTimeFormatter ISO_OFFSET_TIME;
 871     static {
 872         ISO_OFFSET_TIME = new DateTimeFormatterBuilder()
 873                 .parseCaseInsensitive()
 874                 .append(ISO_LOCAL_TIME)
 875                 .appendOffsetId()
 876                 .toFormatter(ResolverStyle.STRICT, null);
 877     }
 878 
 879     //-----------------------------------------------------------------------
 880     /**
 881      * The ISO time formatter that formats or parses a time, with the
 882      * offset if available, such as &#39;10:15&#39;, &#39;10:15:30&#39; or &#39;10:15:30+01:00&#39;.
 883      * &lt;p&gt;
 884      * This returns an immutable formatter capable of formatting and parsing
 885      * the ISO-8601 extended offset time format.
 886      * The format consists of:
 887      * &lt;ul&gt;
 888      * &lt;li&gt;The {@link #ISO_LOCAL_TIME}
 889      * &lt;li&gt;If the offset is not available then the format is complete.
 890      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
 891      *  they will be handled even though this is not part of the ISO-8601 standard.
 892      *  Parsing is case insensitive.
 893      * &lt;/ul&gt;
 894      * &lt;p&gt;
 895      * As this formatter has an optional element, it may be necessary to parse using
 896      * {@link DateTimeFormatter#parseBest}.
 897      * &lt;p&gt;
 898      * The returned formatter has no override chronology or zone.
 899      * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 900      */
 901     public static final DateTimeFormatter ISO_TIME;
 902     static {
 903         ISO_TIME = new DateTimeFormatterBuilder()
 904                 .parseCaseInsensitive()
 905                 .append(ISO_LOCAL_TIME)
 906                 .optionalStart()
 907                 .appendOffsetId()
 908                 .toFormatter(ResolverStyle.STRICT, null);
 909     }
 910 
 911     //-----------------------------------------------------------------------
 912     /**
 913      * The ISO date-time formatter that formats or parses a date-time without
 914      * an offset, such as &#39;2011-12-03T10:15:30&#39;.
 915      * &lt;p&gt;
 916      * This returns an immutable formatter capable of formatting and parsing
 917      * the ISO-8601 extended offset date-time format.
 918      * The format consists of:
 919      * &lt;ul&gt;
 920      * &lt;li&gt;The {@link #ISO_LOCAL_DATE}
 921      * &lt;li&gt;The letter &#39;T&#39;. Parsing is case insensitive.
 922      * &lt;li&gt;The {@link #ISO_LOCAL_TIME}
 923      * &lt;/ul&gt;
 924      * &lt;p&gt;
 925      * The returned formatter has a chronology of ISO set to ensure dates in
 926      * other calendar systems are correctly converted.
 927      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 928      */
 929     public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;
 930     static {
 931         ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder()
 932                 .parseCaseInsensitive()
 933                 .append(ISO_LOCAL_DATE)
 934                 .appendLiteral(&#39;T&#39;)
 935                 .append(ISO_LOCAL_TIME)
 936                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
 937     }
 938 
 939     //-----------------------------------------------------------------------
 940     /**
 941      * The ISO date-time formatter that formats or parses a date-time with an
 942      * offset, such as &#39;2011-12-03T10:15:30+01:00&#39;.
 943      * &lt;p&gt;
 944      * This returns an immutable formatter capable of formatting and parsing
 945      * the ISO-8601 extended offset date-time format.
 946      * The format consists of:
 947      * &lt;ul&gt;
 948      * &lt;li&gt;The {@link #ISO_LOCAL_DATE_TIME}
 949      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
 950      *  they will be handled even though this is not part of the ISO-8601 standard.
 951      *  The offset parsing is lenient, which allows the minutes and seconds to be optional.
 952      *  Parsing is case insensitive.
 953      * &lt;/ul&gt;
 954      * &lt;p&gt;
 955      * The returned formatter has a chronology of ISO set to ensure dates in
 956      * other calendar systems are correctly converted.
 957      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 958      */
 959     public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;
 960     static {
 961         ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder()
 962                 .parseCaseInsensitive()
 963                 .append(ISO_LOCAL_DATE_TIME)
 964                 .parseLenient()
 965                 .appendOffsetId()
 966                 .parseStrict()
 967                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
 968     }
 969 
 970     //-----------------------------------------------------------------------
 971     /**
 972      * The ISO-like date-time formatter that formats or parses a date-time with
 973      * offset and zone, such as &#39;2011-12-03T10:15:30+01:00[Europe/Paris]&#39;.
 974      * &lt;p&gt;
 975      * This returns an immutable formatter capable of formatting and parsing
 976      * a format that extends the ISO-8601 extended offset date-time format
 977      * to add the time-zone.
 978      * The section in square brackets is not part of the ISO-8601 standard.
 979      * The format consists of:
 980      * &lt;ul&gt;
 981      * &lt;li&gt;The {@link #ISO_OFFSET_DATE_TIME}
 982      * &lt;li&gt;If the zone ID is not available or is a {@code ZoneOffset} then the format is complete.
 983      * &lt;li&gt;An open square bracket &#39;[&#39;.
 984      * &lt;li&gt;The {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.
 985      *  Parsing is case sensitive.
 986      * &lt;li&gt;A close square bracket &#39;]&#39;.
 987      * &lt;/ul&gt;
 988      * &lt;p&gt;
 989      * The returned formatter has a chronology of ISO set to ensure dates in
 990      * other calendar systems are correctly converted.
 991      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
 992      */
 993     public static final DateTimeFormatter ISO_ZONED_DATE_TIME;
 994     static {
 995         ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder()
 996                 .append(ISO_OFFSET_DATE_TIME)
 997                 .optionalStart()
 998                 .appendLiteral(&#39;[&#39;)
 999                 .parseCaseSensitive()
1000                 .appendZoneRegionId()
1001                 .appendLiteral(&#39;]&#39;)
1002                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
1003     }
1004 
1005     //-----------------------------------------------------------------------
1006     /**
1007      * The ISO-like date-time formatter that formats or parses a date-time with
1008      * the offset and zone if available, such as &#39;2011-12-03T10:15:30&#39;,
1009      * &#39;2011-12-03T10:15:30+01:00&#39; or &#39;2011-12-03T10:15:30+01:00[Europe/Paris]&#39;.
1010      * &lt;p&gt;
1011      * This returns an immutable formatter capable of formatting and parsing
1012      * the ISO-8601 extended local or offset date-time format, as well as the
1013      * extended non-ISO form specifying the time-zone.
1014      * The format consists of:
1015      * &lt;ul&gt;
1016      * &lt;li&gt;The {@link #ISO_LOCAL_DATE_TIME}
1017      * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
1018      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
1019      *  they will be handled even though this is not part of the ISO-8601 standard.
1020      * &lt;li&gt;If the zone ID is not available or is a {@code ZoneOffset} then the format is complete.
1021      * &lt;li&gt;An open square bracket &#39;[&#39;.
1022      * &lt;li&gt;The {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.
1023      *  Parsing is case sensitive.
1024      * &lt;li&gt;A close square bracket &#39;]&#39;.
1025      * &lt;/ul&gt;
1026      * &lt;p&gt;
1027      * As this formatter has an optional element, it may be necessary to parse using
1028      * {@link DateTimeFormatter#parseBest}.
1029      * &lt;p&gt;
1030      * The returned formatter has a chronology of ISO set to ensure dates in
1031      * other calendar systems are correctly converted.
1032      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
1033      */
1034     public static final DateTimeFormatter ISO_DATE_TIME;
1035     static {
1036         ISO_DATE_TIME = new DateTimeFormatterBuilder()
1037                 .append(ISO_LOCAL_DATE_TIME)
1038                 .optionalStart()
1039                 .appendOffsetId()
1040                 .optionalStart()
1041                 .appendLiteral(&#39;[&#39;)
1042                 .parseCaseSensitive()
1043                 .appendZoneRegionId()
1044                 .appendLiteral(&#39;]&#39;)
1045                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
1046     }
1047 
1048     //-----------------------------------------------------------------------
1049     /**
1050      * The ISO date formatter that formats or parses the ordinal date
1051      * without an offset, such as &#39;2012-337&#39;.
1052      * &lt;p&gt;
1053      * This returns an immutable formatter capable of formatting and parsing
1054      * the ISO-8601 extended ordinal date format.
1055      * The format consists of:
1056      * &lt;ul&gt;
1057      * &lt;li&gt;Four digits or more for the {@link ChronoField#YEAR year}.
1058      * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
1059      * Years outside that range will have a prefixed positive or negative symbol.
1060      * &lt;li&gt;A dash
1061      * &lt;li&gt;Three digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.
1062      *  This is pre-padded by zero to ensure three digits.
1063      * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
1064      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
1065      *  they will be handled even though this is not part of the ISO-8601 standard.
1066      *  Parsing is case insensitive.
1067      * &lt;/ul&gt;
1068      * &lt;p&gt;
1069      * As this formatter has an optional element, it may be necessary to parse using
1070      * {@link DateTimeFormatter#parseBest}.
1071      * &lt;p&gt;
1072      * The returned formatter has a chronology of ISO set to ensure dates in
1073      * other calendar systems are correctly converted.
1074      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
1075      */
1076     public static final DateTimeFormatter ISO_ORDINAL_DATE;
1077     static {
1078         ISO_ORDINAL_DATE = new DateTimeFormatterBuilder()
1079                 .parseCaseInsensitive()
1080                 .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
1081                 .appendLiteral(&#39;-&#39;)
1082                 .appendValue(DAY_OF_YEAR, 3)
1083                 .optionalStart()
1084                 .appendOffsetId()
1085                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
1086     }
1087 
1088     //-----------------------------------------------------------------------
1089     /**
1090      * The ISO date formatter that formats or parses the week-based date
1091      * without an offset, such as &#39;2012-W48-6&#39;.
1092      * &lt;p&gt;
1093      * This returns an immutable formatter capable of formatting and parsing
1094      * the ISO-8601 extended week-based date format.
1095      * The format consists of:
1096      * &lt;ul&gt;
1097      * &lt;li&gt;Four digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.
1098      * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
1099      * Years outside that range will have a prefixed positive or negative symbol.
1100      * &lt;li&gt;A dash
1101      * &lt;li&gt;The letter &#39;W&#39;. Parsing is case insensitive.
1102      * &lt;li&gt;Two digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.
1103      *  This is pre-padded by zero to ensure three digits.
1104      * &lt;li&gt;A dash
1105      * &lt;li&gt;One digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.
1106      *  The value run from Monday (1) to Sunday (7).
1107      * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
1108      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
1109      *  they will be handled even though this is not part of the ISO-8601 standard.
1110      *  Parsing is case insensitive.
1111      * &lt;/ul&gt;
1112      * &lt;p&gt;
1113      * As this formatter has an optional element, it may be necessary to parse using
1114      * {@link DateTimeFormatter#parseBest}.
1115      * &lt;p&gt;
1116      * The returned formatter has a chronology of ISO set to ensure dates in
1117      * other calendar systems are correctly converted.
1118      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
1119      */
1120     public static final DateTimeFormatter ISO_WEEK_DATE;
1121     static {
1122         ISO_WEEK_DATE = new DateTimeFormatterBuilder()
1123                 .parseCaseInsensitive()
1124                 .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
1125                 .appendLiteral(&quot;-W&quot;)
1126                 .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)
1127                 .appendLiteral(&#39;-&#39;)
1128                 .appendValue(DAY_OF_WEEK, 1)
1129                 .optionalStart()
1130                 .appendOffsetId()
1131                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
1132     }
1133 
1134     //-----------------------------------------------------------------------
1135     /**
1136      * The ISO instant formatter that formats or parses an instant in UTC,
1137      * such as &#39;2011-12-03T10:15:30Z&#39;.
1138      * &lt;p&gt;
1139      * This returns an immutable formatter capable of formatting and parsing
1140      * the ISO-8601 instant format.
1141      * When formatting, the instant will always be suffixed by &#39;Z&#39; to indicate UTC.
1142      * The second-of-minute is always output.
1143      * The nano-of-second outputs zero, three, six or nine digits as necessary.
1144      * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}
1145      * will be used to parse the offset, converting the instant to UTC as necessary.
1146      * The time to at least the seconds field is required.
1147      * Fractional seconds from zero to nine are parsed.
1148      * The localized decimal style is not used.
1149      * &lt;p&gt;
1150      * This is a special case formatter intended to allow a human readable form
1151      * of an {@link java.time.Instant}. The {@code Instant} class is designed to
1152      * only represent a point in time and internally stores a value in nanoseconds
1153      * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be
1154      * formatted as a date or time without providing some form of time-zone.
1155      * This formatter allows the {@code Instant} to be formatted, by providing
1156      * a suitable conversion using {@code ZoneOffset.UTC}.
1157      * &lt;p&gt;
1158      * The format consists of:
1159      * &lt;ul&gt;
1160      * &lt;li&gt;The {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from
1161      *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}
1162      *  using the {@code UTC} offset. Parsing is case insensitive.
1163      * &lt;/ul&gt;
1164      * &lt;p&gt;
1165      * The returned formatter has no override chronology or zone.
1166      * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
1167      */
1168     public static final DateTimeFormatter ISO_INSTANT;
1169     static {
1170         ISO_INSTANT = new DateTimeFormatterBuilder()
1171                 .parseCaseInsensitive()
1172                 .appendInstant()
1173                 .toFormatter(ResolverStyle.STRICT, null);
1174     }
1175 
1176     //-----------------------------------------------------------------------
1177     /**
1178      * The ISO date formatter that formats or parses a date without an
1179      * offset, such as &#39;20111203&#39;.
1180      * &lt;p&gt;
1181      * This returns an immutable formatter capable of formatting and parsing
1182      * the ISO-8601 basic local date format.
1183      * The format consists of:
1184      * &lt;ul&gt;
1185      * &lt;li&gt;Four digits for the {@link ChronoField#YEAR year}.
1186      *  Only years in the range 0000 to 9999 are supported.
1187      * &lt;li&gt;Two digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.
1188      *  This is pre-padded by zero to ensure two digits.
1189      * &lt;li&gt;Two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
1190      *  This is pre-padded by zero to ensure two digits.
1191      * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
1192      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID} without colons. If the offset has
1193      *  seconds then they will be handled even though this is not part of the ISO-8601 standard.
1194      *  The offset parsing is lenient, which allows the minutes and seconds to be optional.
1195      *  Parsing is case insensitive.
1196      * &lt;/ul&gt;
1197      * &lt;p&gt;
1198      * As this formatter has an optional element, it may be necessary to parse using
1199      * {@link DateTimeFormatter#parseBest}.
1200      * &lt;p&gt;
1201      * The returned formatter has a chronology of ISO set to ensure dates in
1202      * other calendar systems are correctly converted.
1203      * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
1204      */
1205     public static final DateTimeFormatter BASIC_ISO_DATE;
1206     static {
1207         BASIC_ISO_DATE = new DateTimeFormatterBuilder()
1208                 .parseCaseInsensitive()
1209                 .appendValue(YEAR, 4)
1210                 .appendValue(MONTH_OF_YEAR, 2)
1211                 .appendValue(DAY_OF_MONTH, 2)
1212                 .optionalStart()
1213                 .parseLenient()
1214                 .appendOffset(&quot;+HHMMss&quot;, &quot;Z&quot;)
1215                 .parseStrict()
1216                 .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);
1217     }
1218 
1219     //-----------------------------------------------------------------------
1220     /**
1221      * The RFC-1123 date-time formatter, such as &#39;Tue, 3 Jun 2008 11:05:30 GMT&#39;.
1222      * &lt;p&gt;
1223      * This returns an immutable formatter capable of formatting and parsing
1224      * most of the RFC-1123 format.
1225      * RFC-1123 updates RFC-822 changing the year from two digits to four.
1226      * This implementation requires a four digit year.
1227      * This implementation also does not handle North American or military zone
1228      * names, only &#39;GMT&#39; and offset amounts.
1229      * &lt;p&gt;
1230      * The format consists of:
1231      * &lt;ul&gt;
1232      * &lt;li&gt;If the day-of-week is not available to format or parse then jump to day-of-month.
1233      * &lt;li&gt;Three letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.
1234      * &lt;li&gt;A comma
1235      * &lt;li&gt;A space
1236      * &lt;li&gt;One or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
1237      * &lt;li&gt;A space
1238      * &lt;li&gt;Three letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.
1239      * &lt;li&gt;A space
1240      * &lt;li&gt;Four digits for the {@link ChronoField#YEAR year}.
1241      *  Only years in the range 0000 to 9999 are supported.
1242      * &lt;li&gt;A space
1243      * &lt;li&gt;Two digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.
1244      *  This is pre-padded by zero to ensure two digits.
1245      * &lt;li&gt;A colon
1246      * &lt;li&gt;Two digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.
1247      *  This is pre-padded by zero to ensure two digits.
1248      * &lt;li&gt;If the second-of-minute is not available then jump to the next space.
1249      * &lt;li&gt;A colon
1250      * &lt;li&gt;Two digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.
1251      *  This is pre-padded by zero to ensure two digits.
1252      * &lt;li&gt;A space
1253      * &lt;li&gt;The {@link ZoneOffset#getId() offset ID} without colons or seconds.
1254      *  An offset of zero uses &quot;GMT&quot;. North American zone names and military zone names are not handled.
1255      * &lt;/ul&gt;
1256      * &lt;p&gt;
1257      * Parsing is case insensitive.
1258      * &lt;p&gt;
1259      * The returned formatter has a chronology of ISO set to ensure dates in
1260      * other calendar systems are correctly converted.
1261      * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
1262      */
1263     public static final DateTimeFormatter RFC_1123_DATE_TIME;
1264     static {
1265         // manually code maps to ensure correct data always used
1266         // (locale data can be changed by application code)
1267         Map&lt;Long, String&gt; dow = new HashMap&lt;&gt;();
1268         dow.put(1L, &quot;Mon&quot;);
1269         dow.put(2L, &quot;Tue&quot;);
1270         dow.put(3L, &quot;Wed&quot;);
1271         dow.put(4L, &quot;Thu&quot;);
1272         dow.put(5L, &quot;Fri&quot;);
1273         dow.put(6L, &quot;Sat&quot;);
1274         dow.put(7L, &quot;Sun&quot;);
1275         Map&lt;Long, String&gt; moy = new HashMap&lt;&gt;();
1276         moy.put(1L, &quot;Jan&quot;);
1277         moy.put(2L, &quot;Feb&quot;);
1278         moy.put(3L, &quot;Mar&quot;);
1279         moy.put(4L, &quot;Apr&quot;);
1280         moy.put(5L, &quot;May&quot;);
1281         moy.put(6L, &quot;Jun&quot;);
1282         moy.put(7L, &quot;Jul&quot;);
1283         moy.put(8L, &quot;Aug&quot;);
1284         moy.put(9L, &quot;Sep&quot;);
1285         moy.put(10L, &quot;Oct&quot;);
1286         moy.put(11L, &quot;Nov&quot;);
1287         moy.put(12L, &quot;Dec&quot;);
1288         RFC_1123_DATE_TIME = new DateTimeFormatterBuilder()
1289                 .parseCaseInsensitive()
1290                 .parseLenient()
1291                 .optionalStart()
1292                 .appendText(DAY_OF_WEEK, dow)
1293                 .appendLiteral(&quot;, &quot;)
1294                 .optionalEnd()
1295                 .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)
1296                 .appendLiteral(&#39; &#39;)
1297                 .appendText(MONTH_OF_YEAR, moy)
1298                 .appendLiteral(&#39; &#39;)
1299                 .appendValue(YEAR, 4)  // 2 digit year not handled
1300                 .appendLiteral(&#39; &#39;)
1301                 .appendValue(HOUR_OF_DAY, 2)
1302                 .appendLiteral(&#39;:&#39;)
1303                 .appendValue(MINUTE_OF_HOUR, 2)
1304                 .optionalStart()
1305                 .appendLiteral(&#39;:&#39;)
1306                 .appendValue(SECOND_OF_MINUTE, 2)
1307                 .optionalEnd()
1308                 .appendLiteral(&#39; &#39;)
1309                 .appendOffset(&quot;+HHMM&quot;, &quot;GMT&quot;)  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT
1310                 .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);
1311     }
1312 
1313     //-----------------------------------------------------------------------
1314     /**
1315      * A query that provides access to the excess days that were parsed.
1316      * &lt;p&gt;
1317      * This returns a singleton {@linkplain TemporalQuery query} that provides
1318      * access to additional information from the parse. The query always returns
1319      * a non-null period, with a zero period returned instead of null.
1320      * &lt;p&gt;
1321      * There are two situations where this query may return a non-zero period.
1322      * &lt;ul&gt;
1323      * &lt;li&gt;If the {@code ResolverStyle} is {@code LENIENT} and a time is parsed
1324      *  without a date, then the complete result of the parse consists of a
1325      *  {@code LocalTime} and an excess {@code Period} in days.
1326      *
1327      * &lt;li&gt;If the {@code ResolverStyle} is {@code SMART} and a time is parsed
1328      *  without a date where the time is 24:00:00, then the complete result of
1329      *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess
1330      *  {@code Period} of one day.
1331      * &lt;/ul&gt;
1332      * &lt;p&gt;
1333      * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}
1334      * is parsed, then the excess days are added to the date part.
1335      * As a result, this query will return a zero period.
1336      * &lt;p&gt;
1337      * The {@code SMART} behaviour handles the common &quot;end of day&quot; 24:00 value.
1338      * Processing in {@code LENIENT} mode also produces the same result:
1339      * &lt;pre&gt;
1340      *  Text to parse        Parsed object                         Excess days
1341      *  &quot;2012-12-03T00:00&quot;   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
1342      *  &quot;2012-12-03T24:00&quot;   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
1343      *  &quot;00:00&quot;              LocalTime.of(0, 0)                    ZERO
1344      *  &quot;24:00&quot;              LocalTime.of(0, 0)                    Period.ofDays(1)
1345      * &lt;/pre&gt;
1346      * The query can be used as follows:
1347      * &lt;pre&gt;
1348      *  TemporalAccessor parsed = formatter.parse(str);
1349      *  LocalTime time = parsed.query(LocalTime::from);
1350      *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());
1351      * &lt;/pre&gt;
1352      * @return a query that provides access to the excess days that were parsed
1353      */
1354     public static final TemporalQuery&lt;Period&gt; parsedExcessDays() {
1355         return PARSED_EXCESS_DAYS;
1356     }
1357     private static final TemporalQuery&lt;Period&gt; PARSED_EXCESS_DAYS = t -&gt; {
1358         if (t instanceof Parsed) {
1359             return ((Parsed) t).excessDays;
1360         } else {
1361             return Period.ZERO;
1362         }
1363     };
1364 
1365     /**
1366      * A query that provides access to whether a leap-second was parsed.
1367      * &lt;p&gt;
1368      * This returns a singleton {@linkplain TemporalQuery query} that provides
1369      * access to additional information from the parse. The query always returns
1370      * a non-null boolean, true if parsing saw a leap-second, false if not.
1371      * &lt;p&gt;
1372      * Instant parsing handles the special &quot;leap second&quot; time of &#39;23:59:60&#39;.
1373      * Leap seconds occur at &#39;23:59:60&#39; in the UTC time-zone, but at other
1374      * local times in different time-zones. To avoid this potential ambiguity,
1375      * the handling of leap-seconds is limited to
1376      * {@link DateTimeFormatterBuilder#appendInstant()}, as that method
1377      * always parses the instant with the UTC zone offset.
1378      * &lt;p&gt;
1379      * If the time &#39;23:59:60&#39; is received, then a simple conversion is applied,
1380      * replacing the second-of-minute of 60 with 59. This query can be used
1381      * on the parse result to determine if the leap-second adjustment was made.
1382      * The query will return {@code true} if it did adjust to remove the
1383      * leap-second, and {@code false} if not. Note that applying a leap-second
1384      * smoothing mechanism, such as UTC-SLS, is the responsibility of the
1385      * application, as follows:
1386      * &lt;pre&gt;
1387      *  TemporalAccessor parsed = formatter.parse(str);
1388      *  Instant instant = parsed.query(Instant::from);
1389      *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
1390      *    // validate leap-second is correct and apply correct smoothing
1391      *  }
1392      * &lt;/pre&gt;
1393      * @return a query that provides access to whether a leap-second was parsed
1394      */
1395     public static final TemporalQuery&lt;Boolean&gt; parsedLeapSecond() {
1396         return PARSED_LEAP_SECOND;
1397     }
1398     private static final TemporalQuery&lt;Boolean&gt; PARSED_LEAP_SECOND = t -&gt; {
1399         if (t instanceof Parsed) {
1400             return ((Parsed) t).leapSecond;
1401         } else {
1402             return Boolean.FALSE;
1403         }
1404     };
1405 
1406     //-----------------------------------------------------------------------
1407     /**
1408      * Constructor.
1409      *
1410      * @param printerParser  the printer/parser to use, not null
1411      * @param locale  the locale to use, not null
1412      * @param decimalStyle  the DecimalStyle to use, not null
1413      * @param resolverStyle  the resolver style to use, not null
1414      * @param resolverFields  the fields to use during resolving, null for all fields
1415      * @param chrono  the chronology to use, null for no override
1416      * @param zone  the zone to use, null for no override
1417      */
1418     DateTimeFormatter(CompositePrinterParser printerParser,
1419             Locale locale, DecimalStyle decimalStyle,
1420             ResolverStyle resolverStyle, Set&lt;TemporalField&gt; resolverFields,
1421             Chronology chrono, ZoneId zone) {
1422         this.printerParser = Objects.requireNonNull(printerParser, &quot;printerParser&quot;);
1423         this.resolverFields = resolverFields;
1424         this.locale = Objects.requireNonNull(locale, &quot;locale&quot;);
1425         this.decimalStyle = Objects.requireNonNull(decimalStyle, &quot;decimalStyle&quot;);
1426         this.resolverStyle = Objects.requireNonNull(resolverStyle, &quot;resolverStyle&quot;);
1427         this.chrono = chrono;
1428         this.zone = zone;
1429     }
1430 
1431     //-----------------------------------------------------------------------
1432     /**
1433      * Gets the locale to be used during formatting.
1434      * &lt;p&gt;
1435      * This is used to lookup any part of the formatter needing specific
1436      * localization, such as the text or localized pattern.
1437      *
1438      * @return the locale of this formatter, not null
1439      */
1440     public Locale getLocale() {
1441         return locale;
1442     }
1443 
1444     /**
1445      * Returns a copy of this formatter with a new locale.
1446      * &lt;p&gt;
1447      * This is used to lookup any part of the formatter needing specific
1448      * localization, such as the text or localized pattern.
1449      * &lt;p&gt;
1450      * The locale is stored as passed in, without further processing.
1451      * If the locale has &lt;a href=&quot;../../util/Locale.html#def_locale_extension&quot;&gt;
1452      * Unicode extensions&lt;/a&gt;, they may be used later in text
1453      * processing. To set the chronology, time-zone and decimal style from
1454      * unicode extensions, see {@link #localizedBy localizedBy()}.
1455      * &lt;p&gt;
1456      * This instance is immutable and unaffected by this method call.
1457      *
1458      * @param locale  the new locale, not null
1459      * @return a formatter based on this formatter with the requested locale, not null
1460      * @see #localizedBy(Locale)
1461      */
1462     public DateTimeFormatter withLocale(Locale locale) {
1463         if (this.locale.equals(locale)) {
1464             return this;
1465         }
1466         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);
1467     }
1468 
1469     /**
1470      * Returns a copy of this formatter with localized values of the locale,
1471      * calendar, region, decimal style and/or timezone, that supercede values in
1472      * this formatter.
1473      * &lt;p&gt;
1474      * This is used to lookup any part of the formatter needing specific
1475      * localization, such as the text or localized pattern. If the locale contains the
1476      * &quot;ca&quot; (calendar), &quot;nu&quot; (numbering system), &quot;rg&quot; (region override), and/or
1477      * &quot;tz&quot; (timezone)
1478      * &lt;a href=&quot;../../util/Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
1479      * the chronology, numbering system and/or the zone are overridden. If both &quot;ca&quot;
1480      * and &quot;rg&quot; are specified, the chronology from the &quot;ca&quot; extension supersedes the
1481      * implicit one from the &quot;rg&quot; extension. Same is true for the &quot;nu&quot; extension.
1482      * &lt;p&gt;
1483      * Unlike the {@link #withLocale withLocale} method, the call to this method may
1484      * produce a different formatter depending on the order of method chaining with
1485      * other withXXXX() methods.
1486      * &lt;p&gt;
1487      * This instance is immutable and unaffected by this method call.
1488      *
1489      * @param locale  the locale, not null
1490      * @return a formatter based on this formatter with localized values of
1491      *      the calendar, decimal style and/or timezone, that supercede values in this
1492      *      formatter.
1493      * @see #withLocale(Locale)
1494      * @since 10
1495      */
1496     public DateTimeFormatter localizedBy(Locale locale) {
1497         if (this.locale.equals(locale)) {
1498             return this;
1499         }
1500 
1501         // Check for decimalStyle/chronology/timezone in locale object
1502         Chronology c = locale.getUnicodeLocaleType(&quot;ca&quot;) != null ?
1503                        Chronology.ofLocale(locale) : chrono;
1504         DecimalStyle ds = locale.getUnicodeLocaleType(&quot;nu&quot;) != null ?
1505                        DecimalStyle.of(locale) : decimalStyle;
1506         String tzType = locale.getUnicodeLocaleType(&quot;tz&quot;);
1507         ZoneId z  = tzType != null ?
1508                     TimeZoneNameUtility.convertLDMLShortID(tzType)
1509                         .map(ZoneId::of)
1510                         .orElse(zone) :
1511                     zone;
1512         return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);
1513     }
1514 
1515     //-----------------------------------------------------------------------
1516     /**
1517      * Gets the DecimalStyle to be used during formatting.
1518      *
1519      * @return the locale of this formatter, not null
1520      */
1521     public DecimalStyle getDecimalStyle() {
1522         return decimalStyle;
1523     }
1524 
1525     /**
1526      * Returns a copy of this formatter with a new DecimalStyle.
1527      * &lt;p&gt;
1528      * This instance is immutable and unaffected by this method call.
1529      *
1530      * @param decimalStyle  the new DecimalStyle, not null
1531      * @return a formatter based on this formatter with the requested DecimalStyle, not null
1532      */
1533     public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {
1534         if (this.decimalStyle.equals(decimalStyle)) {
1535             return this;
1536         }
1537         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);
1538     }
1539 
1540     //-----------------------------------------------------------------------
1541     /**
1542      * Gets the overriding chronology to be used during formatting.
1543      * &lt;p&gt;
1544      * This returns the override chronology, used to convert dates.
1545      * By default, a formatter has no override chronology, returning null.
1546      * See {@link #withChronology(Chronology)} for more details on overriding.
1547      *
1548      * @return the override chronology of this formatter, null if no override
1549      */
1550     public Chronology getChronology() {
1551         return chrono;
1552     }
1553 
1554     /**
1555      * Returns a copy of this formatter with a new override chronology.
1556      * &lt;p&gt;
1557      * This returns a formatter with similar state to this formatter but
1558      * with the override chronology set.
1559      * By default, a formatter has no override chronology, returning null.
1560      * &lt;p&gt;
1561      * If an override is added, then any date that is formatted or parsed will be affected.
1562      * &lt;p&gt;
1563      * When formatting, if the temporal object contains a date, then it will
1564      * be converted to a date in the override chronology.
1565      * Whether the temporal contains a date is determined by querying the
1566      * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.
1567      * Any time or zone will be retained unaltered unless overridden.
1568      * &lt;p&gt;
1569      * If the temporal object does not contain a date, but does contain one
1570      * or more {@code ChronoField} date fields, then a {@code DateTimeException}
1571      * is thrown. In all other cases, the override chronology is added to the temporal,
1572      * replacing any previous chronology, but without changing the date/time.
1573      * &lt;p&gt;
1574      * When parsing, there are two distinct cases to consider.
1575      * If a chronology has been parsed directly from the text, perhaps because
1576      * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then
1577      * this override chronology has no effect.
1578      * If no zone has been parsed, then this override chronology will be used
1579      * to interpret the {@code ChronoField} values into a date according to the
1580      * date resolving rules of the chronology.
1581      * &lt;p&gt;
1582      * This instance is immutable and unaffected by this method call.
1583      *
1584      * @param chrono  the new chronology, null if no override
1585      * @return a formatter based on this formatter with the requested override chronology, not null
1586      */
1587     public DateTimeFormatter withChronology(Chronology chrono) {
1588         if (Objects.equals(this.chrono, chrono)) {
1589             return this;
1590         }
1591         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);
1592     }
1593 
1594     //-----------------------------------------------------------------------
1595     /**
1596      * Gets the overriding zone to be used during formatting.
1597      * &lt;p&gt;
1598      * This returns the override zone, used to convert instants.
1599      * By default, a formatter has no override zone, returning null.
1600      * See {@link #withZone(ZoneId)} for more details on overriding.
1601      *
1602      * @return the override zone of this formatter, null if no override
1603      */
1604     public ZoneId getZone() {
1605         return zone;
1606     }
1607 
1608     /**
1609      * Returns a copy of this formatter with a new override zone.
1610      * &lt;p&gt;
1611      * This returns a formatter with similar state to this formatter but
1612      * with the override zone set.
1613      * By default, a formatter has no override zone, returning null.
1614      * &lt;p&gt;
1615      * If an override is added, then any instant that is formatted or parsed will be affected.
1616      * &lt;p&gt;
1617      * When formatting, if the temporal object contains an instant, then it will
1618      * be converted to a zoned date-time using the override zone.
1619      * Whether the temporal is an instant is determined by querying the
1620      * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.
1621      * If the input has a chronology then it will be retained unless overridden.
1622      * If the input does not have a chronology, such as {@code Instant}, then
1623      * the ISO chronology will be used.
1624      * &lt;p&gt;
1625      * If the temporal object does not contain an instant, but does contain
1626      * an offset then an additional check is made. If the normalized override
1627      * zone is an offset that differs from the offset of the temporal, then
1628      * a {@code DateTimeException} is thrown. In all other cases, the override
1629      * zone is added to the temporal, replacing any previous zone, but without
1630      * changing the date/time.
1631      * &lt;p&gt;
1632      * When parsing, there are two distinct cases to consider.
1633      * If a zone has been parsed directly from the text, perhaps because
1634      * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then
1635      * this override zone has no effect.
1636      * If no zone has been parsed, then this override zone will be included in
1637      * the result of the parse where it can be used to build instants and date-times.
1638      * &lt;p&gt;
1639      * This instance is immutable and unaffected by this method call.
1640      *
1641      * @param zone  the new override zone, null if no override
1642      * @return a formatter based on this formatter with the requested override zone, not null
1643      */
1644     public DateTimeFormatter withZone(ZoneId zone) {
1645         if (Objects.equals(this.zone, zone)) {
1646             return this;
1647         }
1648         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);
1649     }
1650 
1651     //-----------------------------------------------------------------------
1652     /**
1653      * Gets the resolver style to use during parsing.
1654      * &lt;p&gt;
1655      * This returns the resolver style, used during the second phase of parsing
1656      * when fields are resolved into dates and times.
1657      * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.
1658      * See {@link #withResolverStyle(ResolverStyle)} for more details.
1659      *
1660      * @return the resolver style of this formatter, not null
1661      */
1662     public ResolverStyle getResolverStyle() {
1663         return resolverStyle;
1664     }
1665 
1666     /**
1667      * Returns a copy of this formatter with a new resolver style.
1668      * &lt;p&gt;
1669      * This returns a formatter with similar state to this formatter but
1670      * with the resolver style set. By default, a formatter has the
1671      * {@link ResolverStyle#SMART SMART} resolver style.
1672      * &lt;p&gt;
1673      * Changing the resolver style only has an effect during parsing.
1674      * Parsing a text string occurs in two phases.
1675      * Phase 1 is a basic text parse according to the fields added to the builder.
1676      * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
1677      * The resolver style is used to control how phase 2, resolving, happens.
1678      * See {@code ResolverStyle} for more information on the options available.
1679      * &lt;p&gt;
1680      * This instance is immutable and unaffected by this method call.
1681      *
1682      * @param resolverStyle  the new resolver style, not null
1683      * @return a formatter based on this formatter with the requested resolver style, not null
1684      */
1685     public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {
1686         Objects.requireNonNull(resolverStyle, &quot;resolverStyle&quot;);
1687         if (Objects.equals(this.resolverStyle, resolverStyle)) {
1688             return this;
1689         }
1690         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);
1691     }
1692 
1693     //-----------------------------------------------------------------------
1694     /**
1695      * Gets the resolver fields to use during parsing.
1696      * &lt;p&gt;
1697      * This returns the resolver fields, used during the second phase of parsing
1698      * when fields are resolved into dates and times.
1699      * By default, a formatter has no resolver fields, and thus returns null.
1700      * See {@link #withResolverFields(Set)} for more details.
1701      *
1702      * @return the immutable set of resolver fields of this formatter, null if no fields
1703      */
1704     public Set&lt;TemporalField&gt; getResolverFields() {
1705         return resolverFields;
1706     }
1707 
1708     /**
1709      * Returns a copy of this formatter with a new set of resolver fields.
1710      * &lt;p&gt;
1711      * This returns a formatter with similar state to this formatter but with
1712      * the resolver fields set. By default, a formatter has no resolver fields.
1713      * &lt;p&gt;
1714      * Changing the resolver fields only has an effect during parsing.
1715      * Parsing a text string occurs in two phases.
1716      * Phase 1 is a basic text parse according to the fields added to the builder.
1717      * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
1718      * The resolver fields are used to filter the field-value pairs between phase 1 and 2.
1719      * &lt;p&gt;
1720      * This can be used to select between two or more ways that a date or time might
1721      * be resolved. For example, if the formatter consists of year, month, day-of-month
1722      * and day-of-year, then there are two ways to resolve a date.
1723      * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and
1724      * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is
1725      * resolved using the year and day-of-year, effectively meaning that the month
1726      * and day-of-month are ignored during the resolving phase.
1727      * &lt;p&gt;
1728      * In a similar manner, this method can be used to ignore secondary fields that
1729      * would otherwise be cross-checked. For example, if the formatter consists of year,
1730      * month, day-of-month and day-of-week, then there is only one way to resolve a
1731      * date, but the parsed value for day-of-week will be cross-checked against the
1732      * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},
1733      * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
1734      * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is
1735      * resolved correctly, but without any cross-check for the day-of-week.
1736      * &lt;p&gt;
1737      * In implementation terms, this method behaves as follows. The result of the
1738      * parsing phase can be considered to be a map of field to value. The behavior
1739      * of this method is to cause that map to be filtered between phase 1 and 2,
1740      * removing all fields other than those specified as arguments to this method.
1741      * &lt;p&gt;
1742      * This instance is immutable and unaffected by this method call.
1743      *
1744      * @param resolverFields  the new set of resolver fields, null if no fields
1745      * @return a formatter based on this formatter with the requested resolver style, not null
1746      */
1747     public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {
1748         Set&lt;TemporalField&gt; fields = null;
1749         if (resolverFields != null) {
1750             // Set.of cannot be used because it is hostile to nulls and duplicate elements
1751             fields = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(resolverFields)));
1752         }
1753         if (Objects.equals(this.resolverFields, fields)) {
1754             return this;
1755         }
1756         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);
1757     }
1758 
1759     /**
1760      * Returns a copy of this formatter with a new set of resolver fields.
1761      * &lt;p&gt;
1762      * This returns a formatter with similar state to this formatter but with
1763      * the resolver fields set. By default, a formatter has no resolver fields.
1764      * &lt;p&gt;
1765      * Changing the resolver fields only has an effect during parsing.
1766      * Parsing a text string occurs in two phases.
1767      * Phase 1 is a basic text parse according to the fields added to the builder.
1768      * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
1769      * The resolver fields are used to filter the field-value pairs between phase 1 and 2.
1770      * &lt;p&gt;
1771      * This can be used to select between two or more ways that a date or time might
1772      * be resolved. For example, if the formatter consists of year, month, day-of-month
1773      * and day-of-year, then there are two ways to resolve a date.
1774      * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and
1775      * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is
1776      * resolved using the year and day-of-year, effectively meaning that the month
1777      * and day-of-month are ignored during the resolving phase.
1778      * &lt;p&gt;
1779      * In a similar manner, this method can be used to ignore secondary fields that
1780      * would otherwise be cross-checked. For example, if the formatter consists of year,
1781      * month, day-of-month and day-of-week, then there is only one way to resolve a
1782      * date, but the parsed value for day-of-week will be cross-checked against the
1783      * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},
1784      * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
1785      * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is
1786      * resolved correctly, but without any cross-check for the day-of-week.
1787      * &lt;p&gt;
1788      * In implementation terms, this method behaves as follows. The result of the
1789      * parsing phase can be considered to be a map of field to value. The behavior
1790      * of this method is to cause that map to be filtered between phase 1 and 2,
1791      * removing all fields other than those specified as arguments to this method.
1792      * &lt;p&gt;
1793      * This instance is immutable and unaffected by this method call.
1794      *
1795      * @param resolverFields  the new set of resolver fields, null if no fields
1796      * @return a formatter based on this formatter with the requested resolver style, not null
1797      */
1798     public DateTimeFormatter withResolverFields(Set&lt;TemporalField&gt; resolverFields) {
1799         if (Objects.equals(this.resolverFields, resolverFields)) {
1800             return this;
1801         }
1802         if (resolverFields != null) {
1803             resolverFields = Collections.unmodifiableSet(new HashSet&lt;&gt;(resolverFields));
1804         }
1805         return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);
1806     }
1807 
1808     //-----------------------------------------------------------------------
1809     /**
1810      * Formats a date-time object using this formatter.
1811      * &lt;p&gt;
1812      * This formats the date-time to a String using the rules of the formatter.
1813      *
1814      * @param temporal  the temporal object to format, not null
1815      * @return the formatted string, not null
1816      * @throws DateTimeException if an error occurs during formatting
1817      */
1818     public String format(TemporalAccessor temporal) {
1819         StringBuilder buf = new StringBuilder(32);
1820         formatTo(temporal, buf);
1821         return buf.toString();
1822     }
1823 
1824     //-----------------------------------------------------------------------
1825     /**
1826      * Formats a date-time object to an {@code Appendable} using this formatter.
1827      * &lt;p&gt;
1828      * This outputs the formatted date-time to the specified destination.
1829      * {@link Appendable} is a general purpose interface that is implemented by all
1830      * key character output classes including {@code StringBuffer}, {@code StringBuilder},
1831      * {@code PrintStream} and {@code Writer}.
1832      * &lt;p&gt;
1833      * Although {@code Appendable} methods throw an {@code IOException}, this method does not.
1834      * Instead, any {@code IOException} is wrapped in a runtime exception.
1835      *
1836      * @param temporal  the temporal object to format, not null
1837      * @param appendable  the appendable to format to, not null
1838      * @throws DateTimeException if an error occurs during formatting
1839      */
1840     public void formatTo(TemporalAccessor temporal, Appendable appendable) {
1841         Objects.requireNonNull(temporal, &quot;temporal&quot;);
1842         Objects.requireNonNull(appendable, &quot;appendable&quot;);
1843         try {
1844             DateTimePrintContext context = new DateTimePrintContext(temporal, this);
1845             if (appendable instanceof StringBuilder) {
1846                 printerParser.format(context, (StringBuilder) appendable);
1847             } else {
1848                 // buffer output to avoid writing to appendable in case of error
1849                 StringBuilder buf = new StringBuilder(32);
1850                 printerParser.format(context, buf);
1851                 appendable.append(buf);
1852             }
1853         } catch (IOException ex) {
1854             throw new DateTimeException(ex.getMessage(), ex);
1855         }
1856     }
1857 
1858     //-----------------------------------------------------------------------
1859     /**
1860      * Fully parses the text producing a temporal object.
1861      * &lt;p&gt;
1862      * This parses the entire text producing a temporal object.
1863      * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.
1864      * The result of this method is {@code TemporalAccessor} which has been resolved,
1865      * applying basic validation checks to help ensure a valid date-time.
1866      * &lt;p&gt;
1867      * If the parse completes without reading the entire length of the text,
1868      * or a problem occurs during parsing or merging, then an exception is thrown.
1869      *
1870      * @param text  the text to parse, not null
1871      * @return the parsed temporal object, not null
1872      * @throws DateTimeParseException if unable to parse the requested result
1873      */
1874     public TemporalAccessor parse(CharSequence text) {
1875         Objects.requireNonNull(text, &quot;text&quot;);
1876         try {
1877             return parseResolved0(text, null);
1878         } catch (DateTimeParseException ex) {
1879             throw ex;
1880         } catch (RuntimeException ex) {
1881             throw createError(text, ex);
1882         }
1883     }
1884 
1885     /**
1886      * Parses the text using this formatter, providing control over the text position.
1887      * &lt;p&gt;
1888      * This parses the text without requiring the parse to start from the beginning
1889      * of the string or finish at the end.
1890      * The result of this method is {@code TemporalAccessor} which has been resolved,
1891      * applying basic validation checks to help ensure a valid date-time.
1892      * &lt;p&gt;
1893      * The text will be parsed from the specified start {@code ParsePosition}.
1894      * The entire length of the text does not have to be parsed, the {@code ParsePosition}
1895      * will be updated with the index at the end of parsing.
1896      * &lt;p&gt;
1897      * The operation of this method is slightly different to similar methods using
1898      * {@code ParsePosition} on {@code java.text.Format}. That class will return
1899      * errors using the error index on the {@code ParsePosition}. By contrast, this
1900      * method will throw a {@link DateTimeParseException} if an error occurs, with
1901      * the exception containing the error index.
1902      * This change in behavior is necessary due to the increased complexity of
1903      * parsing and resolving dates/times in this API.
1904      * &lt;p&gt;
1905      * If the formatter parses the same field more than once with different values,
1906      * the result will be an error.
1907      *
1908      * @param text  the text to parse, not null
1909      * @param position  the position to parse from, updated with length parsed
1910      *  and the index of any error, not null
1911      * @return the parsed temporal object, not null
1912      * @throws DateTimeParseException if unable to parse the requested result
1913      * @throws IndexOutOfBoundsException if the position is invalid
1914      */
1915     public TemporalAccessor parse(CharSequence text, ParsePosition position) {
1916         Objects.requireNonNull(text, &quot;text&quot;);
1917         Objects.requireNonNull(position, &quot;position&quot;);
1918         try {
1919             return parseResolved0(text, position);
1920         } catch (DateTimeParseException | IndexOutOfBoundsException ex) {
1921             throw ex;
1922         } catch (RuntimeException ex) {
1923             throw createError(text, ex);
1924         }
1925     }
1926 
1927     //-----------------------------------------------------------------------
1928     /**
1929      * Fully parses the text producing an object of the specified type.
1930      * &lt;p&gt;
1931      * Most applications should use this method for parsing.
1932      * It parses the entire text to produce the required date-time.
1933      * The query is typically a method reference to a {@code from(TemporalAccessor)} method.
1934      * For example:
1935      * &lt;pre&gt;
1936      *  LocalDateTime dt = parser.parse(str, LocalDateTime::from);
1937      * &lt;/pre&gt;
1938      * If the parse completes without reading the entire length of the text,
1939      * or a problem occurs during parsing or merging, then an exception is thrown.
1940      *
1941      * @param &lt;T&gt; the type of the parsed date-time
1942      * @param text  the text to parse, not null
1943      * @param query  the query defining the type to parse to, not null
1944      * @return the parsed date-time, not null
1945      * @throws DateTimeParseException if unable to parse the requested result
1946      */
1947     public &lt;T&gt; T parse(CharSequence text, TemporalQuery&lt;T&gt; query) {
1948         Objects.requireNonNull(text, &quot;text&quot;);
1949         Objects.requireNonNull(query, &quot;query&quot;);
1950         try {
1951             return parseResolved0(text, null).query(query);
1952         } catch (DateTimeParseException ex) {
1953             throw ex;
1954         } catch (RuntimeException ex) {
1955             throw createError(text, ex);
1956         }
1957     }
1958 
1959     /**
1960      * Fully parses the text producing an object of one of the specified types.
1961      * &lt;p&gt;
1962      * This parse method is convenient for use when the parser can handle optional elements.
1963      * For example, a pattern of &#39;uuuu-MM-dd HH.mm[ VV]&#39; can be fully parsed to a {@code ZonedDateTime},
1964      * or partially parsed to a {@code LocalDateTime}.
1965      * The queries must be specified in order, starting from the best matching full-parse option
1966      * and ending with the worst matching minimal parse option.
1967      * The query is typically a method reference to a {@code from(TemporalAccessor)} method.
1968      * &lt;p&gt;
1969      * The result is associated with the first type that successfully parses.
1970      * Normally, applications will use {@code instanceof} to check the result.
1971      * For example:
1972      * &lt;pre&gt;
1973      *  TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
1974      *  if (dt instanceof ZonedDateTime) {
1975      *   ...
1976      *  } else {
1977      *   ...
1978      *  }
1979      * &lt;/pre&gt;
1980      * If the parse completes without reading the entire length of the text,
1981      * or a problem occurs during parsing or merging, then an exception is thrown.
1982      *
1983      * @param text  the text to parse, not null
1984      * @param queries  the queries defining the types to attempt to parse to,
1985      *  must implement {@code TemporalAccessor}, not null
1986      * @return the parsed date-time, not null
1987      * @throws IllegalArgumentException if less than 2 types are specified
1988      * @throws DateTimeParseException if unable to parse the requested result
1989      */
1990     public TemporalAccessor parseBest(CharSequence text, TemporalQuery&lt;?&gt;... queries) {
1991         Objects.requireNonNull(text, &quot;text&quot;);
1992         Objects.requireNonNull(queries, &quot;queries&quot;);
1993         if (queries.length &lt; 2) {
1994             throw new IllegalArgumentException(&quot;At least two queries must be specified&quot;);
1995         }
1996         try {
1997             TemporalAccessor resolved = parseResolved0(text, null);
1998             for (TemporalQuery&lt;?&gt; query : queries) {
1999                 try {
2000                     return (TemporalAccessor) resolved.query(query);
2001                 } catch (RuntimeException ex) {
2002                     // continue
2003                 }
2004             }
2005             throw new DateTimeException(&quot;Unable to convert parsed text using any of the specified queries&quot;);
2006         } catch (DateTimeParseException ex) {
2007             throw ex;
2008         } catch (RuntimeException ex) {
2009             throw createError(text, ex);
2010         }
2011     }
2012 
2013     private DateTimeParseException createError(CharSequence text, RuntimeException ex) {
2014         String abbr;
2015         if (text.length() &gt; 64) {
2016             abbr = text.subSequence(0, 64).toString() + &quot;...&quot;;
2017         } else {
2018             abbr = text.toString();
2019         }
2020         return new DateTimeParseException(&quot;Text &#39;&quot; + abbr + &quot;&#39; could not be parsed: &quot; + ex.getMessage(), text, 0, ex);
2021     }
2022 
2023     //-----------------------------------------------------------------------
2024     /**
2025      * Parses and resolves the specified text.
2026      * &lt;p&gt;
2027      * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.
2028      *
2029      * @param text  the text to parse, not null
2030      * @param position  the position to parse from, updated with length parsed
2031      *  and the index of any error, null if parsing whole string
2032      * @return the resolved result of the parse, not null
2033      * @throws DateTimeParseException if the parse fails
2034      * @throws DateTimeException if an error occurs while resolving the date or time
2035      * @throws IndexOutOfBoundsException if the position is invalid
2036      */
2037     private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {
2038         ParsePosition pos = (position != null ? position : new ParsePosition(0));
2039         DateTimeParseContext context = parseUnresolved0(text, pos);
2040         if (context == null || pos.getErrorIndex() &gt;= 0 || (position == null &amp;&amp; pos.getIndex() &lt; text.length())) {
2041             String abbr;
2042             if (text.length() &gt; 64) {
2043                 abbr = text.subSequence(0, 64).toString() + &quot;...&quot;;
2044             } else {
2045                 abbr = text.toString();
2046             }
2047             if (pos.getErrorIndex() &gt;= 0) {
2048                 throw new DateTimeParseException(&quot;Text &#39;&quot; + abbr + &quot;&#39; could not be parsed at index &quot; +
2049                         pos.getErrorIndex(), text, pos.getErrorIndex());
2050             } else {
2051                 throw new DateTimeParseException(&quot;Text &#39;&quot; + abbr + &quot;&#39; could not be parsed, unparsed text found at index &quot; +
2052                         pos.getIndex(), text, pos.getIndex());
2053             }
2054         }
2055         return context.toResolved(resolverStyle, resolverFields);
2056     }
2057 
2058     /**
2059      * Parses the text using this formatter, without resolving the result, intended
2060      * for advanced use cases.
2061      * &lt;p&gt;
2062      * Parsing is implemented as a two-phase operation.
2063      * First, the text is parsed using the layout defined by the formatter, producing
2064      * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
2065      * Second, the parsed data is &lt;em&gt;resolved&lt;/em&gt;, by validating, combining and
2066      * simplifying the various fields into more useful ones.
2067      * This method performs the parsing stage but not the resolving stage.
2068      * &lt;p&gt;
2069      * The result of this method is {@code TemporalAccessor} which represents the
2070      * data as seen in the input. Values are not validated, thus parsing a date string
2071      * of &#39;2012-00-65&#39; would result in a temporal with three fields - year of &#39;2012&#39;,
2072      * month of &#39;0&#39; and day-of-month of &#39;65&#39;.
2073      * &lt;p&gt;
2074      * The text will be parsed from the specified start {@code ParsePosition}.
2075      * The entire length of the text does not have to be parsed, the {@code ParsePosition}
2076      * will be updated with the index at the end of parsing.
2077      * &lt;p&gt;
2078      * Errors are returned using the error index field of the {@code ParsePosition}
2079      * instead of {@code DateTimeParseException}.
2080      * The returned error index will be set to an index indicative of the error.
2081      * Callers must check for errors before using the result.
2082      * &lt;p&gt;
2083      * If the formatter parses the same field more than once with different values,
2084      * the result will be an error.
2085      * &lt;p&gt;
2086      * This method is intended for advanced use cases that need access to the
2087      * internal state during parsing. Typical application code should use
2088      * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.
2089      *
2090      * @param text  the text to parse, not null
2091      * @param position  the position to parse from, updated with length parsed
2092      *  and the index of any error, not null
2093      * @return the parsed text, null if the parse results in an error
2094      * @throws DateTimeException if some problem occurs during parsing
2095      * @throws IndexOutOfBoundsException if the position is invalid
2096      */
2097     public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {
2098         DateTimeParseContext context = parseUnresolved0(text, position);
2099         if (context == null) {
2100             return null;
2101         }
2102         return context.toUnresolved();
2103     }
2104 
2105     private DateTimeParseContext parseUnresolved0(CharSequence text, ParsePosition position) {
2106         Objects.requireNonNull(text, &quot;text&quot;);
2107         Objects.requireNonNull(position, &quot;position&quot;);
2108         DateTimeParseContext context = new DateTimeParseContext(this);
2109         int pos = position.getIndex();
2110         pos = printerParser.parse(context, text, pos);
2111         if (pos &lt; 0) {
2112             position.setErrorIndex(~pos);  // index not updated from input
2113             return null;
2114         }
2115         position.setIndex(pos);  // errorIndex not updated from input
2116         return context;
2117     }
2118 
2119     //-----------------------------------------------------------------------
2120     /**
2121      * Returns the formatter as a composite printer parser.
2122      *
2123      * @param optional  whether the printer/parser should be optional
2124      * @return the printer/parser, not null
2125      */
2126     CompositePrinterParser toPrinterParser(boolean optional) {
2127         return printerParser.withOptional(optional);
2128     }
2129 
2130     /**
2131      * Returns this formatter as a {@code java.text.Format} instance.
2132      * &lt;p&gt;
2133      * The returned {@link Format} instance will format any {@link TemporalAccessor}
2134      * and parses to a resolved {@link TemporalAccessor}.
2135      * &lt;p&gt;
2136      * Exceptions will follow the definitions of {@code Format}, see those methods
2137      * for details about {@code IllegalArgumentException} during formatting and
2138      * {@code ParseException} or null during parsing.
2139      * The format does not support attributing of the returned format string.
2140      *
2141      * @return this formatter as a classic format instance, not null
2142      */
2143     public Format toFormat() {
2144         return new ClassicFormat(this, null);
2145     }
2146 
2147     /**
2148      * Returns this formatter as a {@code java.text.Format} instance that will
2149      * parse using the specified query.
2150      * &lt;p&gt;
2151      * The returned {@link Format} instance will format any {@link TemporalAccessor}
2152      * and parses to the type specified.
2153      * The type must be one that is supported by {@link #parse}.
2154      * &lt;p&gt;
2155      * Exceptions will follow the definitions of {@code Format}, see those methods
2156      * for details about {@code IllegalArgumentException} during formatting and
2157      * {@code ParseException} or null during parsing.
2158      * The format does not support attributing of the returned format string.
2159      *
2160      * @param parseQuery  the query defining the type to parse to, not null
2161      * @return this formatter as a classic format instance, not null
2162      */
2163     public Format toFormat(TemporalQuery&lt;?&gt; parseQuery) {
2164         Objects.requireNonNull(parseQuery, &quot;parseQuery&quot;);
2165         return new ClassicFormat(this, parseQuery);
2166     }
2167 
2168     //-----------------------------------------------------------------------
2169     /**
2170      * Returns a description of the underlying formatters.
2171      *
2172      * @return a description of this formatter, not null
2173      */
2174     @Override
2175     public String toString() {
2176         String pattern = printerParser.toString();
2177         pattern = pattern.startsWith(&quot;[&quot;) ? pattern : pattern.substring(1, pattern.length() - 1);
2178         return pattern;
2179         // TODO: Fix tests to not depend on toString()
2180 //        return &quot;DateTimeFormatter[&quot; + locale +
2181 //                (chrono != null ? &quot;,&quot; + chrono : &quot;&quot;) +
2182 //                (zone != null ? &quot;,&quot; + zone : &quot;&quot;) +
2183 //                pattern + &quot;]&quot;;
2184     }
2185 
2186     //-----------------------------------------------------------------------
2187     /**
2188      * Implements the classic Java Format API.
2189      * @serial exclude
2190      */
2191     @SuppressWarnings(&quot;serial&quot;)  // not actually serializable
2192     static class ClassicFormat extends Format {
2193         /** The formatter. */
2194         private final DateTimeFormatter formatter;
2195         /** The type to be parsed. */
2196         private final TemporalQuery&lt;?&gt; parseType;
2197         /** Constructor. */
2198         public ClassicFormat(DateTimeFormatter formatter, TemporalQuery&lt;?&gt; parseType) {
2199             this.formatter = formatter;
2200             this.parseType = parseType;
2201         }
2202 
2203         @Override
2204         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
2205             Objects.requireNonNull(obj, &quot;obj&quot;);
2206             Objects.requireNonNull(toAppendTo, &quot;toAppendTo&quot;);
2207             Objects.requireNonNull(pos, &quot;pos&quot;);
2208             if (obj instanceof TemporalAccessor == false) {
2209                 throw new IllegalArgumentException(&quot;Format target must implement TemporalAccessor&quot;);
2210             }
2211             pos.setBeginIndex(0);
2212             pos.setEndIndex(0);
2213             try {
2214                 formatter.formatTo((TemporalAccessor) obj, toAppendTo);
2215             } catch (RuntimeException ex) {
2216                 throw new IllegalArgumentException(ex.getMessage(), ex);
2217             }
2218             return toAppendTo;
2219         }
2220         @Override
2221         public Object parseObject(String text) throws ParseException {
2222             Objects.requireNonNull(text, &quot;text&quot;);
2223             try {
2224                 if (parseType == null) {
2225                     return formatter.parseResolved0(text, null);
2226                 }
2227                 return formatter.parse(text, parseType);
2228             } catch (DateTimeParseException ex) {
2229                 throw new ParseException(ex.getMessage(), ex.getErrorIndex());
2230             } catch (RuntimeException ex) {
2231                 throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);
2232             }
2233         }
2234         @Override
2235         public Object parseObject(String text, ParsePosition pos) {
2236             Objects.requireNonNull(text, &quot;text&quot;);
2237             DateTimeParseContext context;
2238             try {
2239                 context = formatter.parseUnresolved0(text, pos);
2240             } catch (IndexOutOfBoundsException ex) {
2241                 if (pos.getErrorIndex() &lt; 0) {
2242                     pos.setErrorIndex(0);
2243                 }
2244                 return null;
2245             }
2246             if (context == null) {
2247                 if (pos.getErrorIndex() &lt; 0) {
2248                     pos.setErrorIndex(0);
2249                 }
2250                 return null;
2251             }
2252             try {
2253                 TemporalAccessor resolved = context.toResolved(formatter.resolverStyle, formatter.resolverFields);
2254                 if (parseType == null) {
2255                     return resolved;
2256                 }
2257                 return resolved.query(parseType);
2258             } catch (RuntimeException ex) {
2259                 pos.setErrorIndex(0);
2260                 return null;
2261             }
2262         }
2263     }
2264 
2265 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
diff a/src/java.base/share/classes/java/text/ChoiceFormat.java b/src/java.base/share/classes/java/text/ChoiceFormat.java
--- a/src/java.base/share/classes/java/text/ChoiceFormat.java
+++ b/src/java.base/share/classes/java/text/ChoiceFormat.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -42,12 +42,12 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.util.Arrays;
 
 /**
- * A <code>ChoiceFormat</code> allows you to attach a format to a range of numbers.
- * It is generally used in a <code>MessageFormat</code> for handling plurals.
+ * A {@code ChoiceFormat} allows you to attach a format to a range of numbers.
+ * It is generally used in a {@code MessageFormat} for handling plurals.
  * The choice is specified with an ascending list of doubles, where each item
  * specifies a half-open interval up to the next item:
  * <blockquote>
  * <pre>
  * X matches j if and only if limit[j] &le; X &lt; limit[j+1]
@@ -58,29 +58,29 @@
  * in ascending order, the results of formatting will be incorrect.  ChoiceFormat
  * also accepts <code>&#92;u221E</code> as equivalent to infinity(INF).
  *
  * <p>
  * <strong>Note:</strong>
- * <code>ChoiceFormat</code> differs from the other <code>Format</code>
- * classes in that you create a <code>ChoiceFormat</code> object with a
- * constructor (not with a <code>getInstance</code> style factory
- * method). The factory methods aren't necessary because <code>ChoiceFormat</code>
+ * {@code ChoiceFormat} differs from the other {@code Format}
+ * classes in that you create a {@code ChoiceFormat} object with a
+ * constructor (not with a {@code getInstance} style factory
+ * method). The factory methods aren't necessary because {@code ChoiceFormat}
  * doesn't require any complex setup for a given locale. In fact,
- * <code>ChoiceFormat</code> doesn't implement any locale specific behavior.
+ * {@code ChoiceFormat} doesn't implement any locale specific behavior.
  *
  * <p>
- * When creating a <code>ChoiceFormat</code>, you must specify an array of formats
+ * When creating a {@code ChoiceFormat}, you must specify an array of formats
  * and an array of limits. The length of these arrays must be the same.
  * For example,
  * <ul>
  * <li>
  *     <em>limits</em> = {1,2,3,4,5,6,7}<br>
  *     <em>formats</em> = {"Sun","Mon","Tue","Wed","Thur","Fri","Sat"}
  * <li>
  *     <em>limits</em> = {0, 1, ChoiceFormat.nextDouble(1)}<br>
  *     <em>formats</em> = {"no files", "one file", "many files"}<br>
- *     (<code>nextDouble</code> can be used to get the next higher double, to
+ *     ({@code nextDouble} can be used to get the next higher double, to
  *     make the half-open interval.)
  * </ul>
  *
  * <p>
  * Here is a simple example that shows formatting and parsing:
@@ -149,11 +149,11 @@
  * Format with NaN : is negative
  * Format with +INF : is more than 2.
  * }</pre>
  * </blockquote>
  *
- * <h3><a id="synchronization">Synchronization</a></h3>
+ * <h2><a id="synchronization">Synchronization</a></h2>
  *
  * <p>
  * Choice formats are not synchronized.
  * It is recommended to create separate format instances for each thread.
  * If multiple threads access a format concurrently, it must be synchronized
@@ -166,16 +166,17 @@
  * @since 1.1
  */
 public class ChoiceFormat extends NumberFormat {
 
     // Proclaim serial compatibility with 1.1 FCS
+    @java.io.Serial
     private static final long serialVersionUID = 1795184449645032964L;
 
     /**
      * Sets the pattern.
      * @param newPattern See the class description.
-     * @exception NullPointerException if {@code newPattern}
+     * @throws    NullPointerException if {@code newPattern}
      *            is {@code null}
      */
     public void applyPattern(String newPattern) {
         StringBuffer[] segments = new StringBuffer[2];
         for (int i = 0; i < segments.length; ++i) {
@@ -310,11 +311,11 @@
 
     /**
      * Constructs with limits and corresponding formats based on the pattern.
      *
      * @param newPattern the new pattern string
-     * @exception NullPointerException if {@code newPattern} is
+     * @throws    NullPointerException if {@code newPattern} is
      *            {@code null}
      * @see #applyPattern
      */
     public ChoiceFormat(String newPattern)  {
         applyPattern(newPattern);
@@ -323,11 +324,11 @@
     /**
      * Constructs with the limits and the corresponding formats.
      *
      * @param limits limits in ascending order
      * @param formats corresponding format strings
-     * @exception NullPointerException if {@code limits} or {@code formats}
+     * @throws    NullPointerException if {@code limits} or {@code formats}
      *            is {@code null}
      * @see #setChoices
      */
     public ChoiceFormat(double[] limits, String[] formats) {
         setChoices(limits, formats);
@@ -344,11 +345,11 @@
      * @param formats are the formats you want to use for each limit.
      * They can be either Format objects or Strings.
      * When formatting with object Y,
      * if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
      * is called. Otherwise Y.toString() is called.
-     * @exception NullPointerException if {@code limits} or
+     * @throws    NullPointerException if {@code limits} or
      *            {@code formats} is {@code null}
      */
     public void setChoices(double[] limits, String formats[]) {
         if (limits.length != formats.length) {
             throw new IllegalArgumentException(
@@ -378,11 +379,11 @@
 
     // Overrides
 
     /**
      * Specialization of format. This method really calls
-     * <code>format(double, StringBuffer, FieldPosition)</code>
+     * {@code format(double, StringBuffer, FieldPosition)}
      * thus the range of longs that are supported is only equal to
      * the range that can be stored by double. This will never be
      * a practical limitation.
      */
     public StringBuffer format(long number, StringBuffer toAppendTo,
@@ -393,11 +394,11 @@
     /**
      * Returns pattern with formatted double.
      * @param number number to be formatted and substituted.
      * @param toAppendTo where text is appended.
      * @param status ignore no useful status is returned.
-     * @exception NullPointerException if {@code toAppendTo}
+     * @throws    NullPointerException if {@code toAppendTo}
      *            is {@code null}
      */
    public StringBuffer format(double number, StringBuffer toAppendTo,
                                FieldPosition status) {
         // find the number
@@ -423,11 +424,11 @@
      * occurred, status.index is set to the first unparsed character
      * in the source text.  On exit, if an error did occur,
      * status.index is unchanged and status.errorIndex is set to the
      * first index of the character that caused the parse to fail.
      * @return A Number representing the value of the number parsed.
-     * @exception NullPointerException if {@code status} is {@code null}
+     * @throws    NullPointerException if {@code status} is {@code null}
      *            or if {@code text} is {@code null} and the list of
      *            choice strings is not empty.
      */
     public Number parse(String text, ParsePosition status) {
         // find the best number (defined as the one with the longest parse)
@@ -526,10 +527,11 @@
     /**
      * After reading an object from the input stream, do a simple verification
      * to maintain class invariants.
      * @throws InvalidObjectException if the objects read from the stream is invalid.
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
         in.defaultReadObject();
         if (choiceLimits.length != choiceFormats.length) {
             throw new InvalidObjectException(
                     "limits and format arrays of different length.");
@@ -538,20 +540,20 @@
 
     // ===============privates===========================
 
     /**
      * A list of lower bounds for the choices.  The formatter will return
-     * <code>choiceFormats[i]</code> if the number being formatted is greater than or equal to
-     * <code>choiceLimits[i]</code> and less than <code>choiceLimits[i+1]</code>.
+     * {@code choiceFormats[i]} if the number being formatted is greater than or equal to
+     * {@code choiceLimits[i]} and less than {@code choiceLimits[i+1]}.
      * @serial
      */
     private double[] choiceLimits;
 
     /**
      * A list of choice strings.  The formatter will return
-     * <code>choiceFormats[i]</code> if the number being formatted is greater than or equal to
-     * <code>choiceLimits[i]</code> and less than <code>choiceLimits[i+1]</code>.
+     * {@code choiceFormats[i]} if the number being formatted is greater than or equal to
+     * {@code choiceLimits[i]} and less than {@code choiceLimits[i+1]}.
      * @serial
      */
     private String[] choiceFormats;
 
     /**

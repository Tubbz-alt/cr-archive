<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/UnresolvedPermissionCollection.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="UnresolvedPermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cert/CRLException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/UnresolvedPermissionCollection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
120 
121     /**
122      * Returns an enumeration of all the UnresolvedPermission lists in the
123      * container.
124      *
125      * @return an enumeration of all the UnresolvedPermission objects.
126      */
127     @Override
128     public Enumeration&lt;Permission&gt; elements() {
129         List&lt;Permission&gt; results =
130             new ArrayList&lt;&gt;(); // where results are stored
131 
132         // Get iterator of Map values (which are lists of permissions)
133         for (List&lt;UnresolvedPermission&gt; l : perms.values()) {
134             results.addAll(l);
135         }
136 
137         return Collections.enumeration(results);
138     }
139 

140     private static final long serialVersionUID = -7176153071733132400L;
141 
142     // Need to maintain serialization interoperability with earlier releases,
143     // which had the serializable field:
144     // private Hashtable permissions; // keyed on type
145 
146     /**
147      * @serialField permissions java.util.Hashtable
148      *     A table of the UnresolvedPermissions keyed on type, value is Vector
149      *     of permissions
150      */

151     private static final ObjectStreamField[] serialPersistentFields = {
152         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
153     };
154 
155     /**
156      * @serialData Default field.
157      */
158     /*
159      * Writes the contents of the perms field out as a Hashtable
160      * in which the values are Vectors for
161      * serialization compatibility with earlier releases.
162      */

163     private void writeObject(ObjectOutputStream out) throws IOException {
164         // Don&#39;t call out.defaultWriteObject()
165 
166         // Copy perms into a Hashtable
167         Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; permissions =
168             new Hashtable&lt;&gt;(perms.size()*2);
169 
170         // Convert each entry (List) into a Vector
171         Set&lt;Map.Entry&lt;String, List&lt;UnresolvedPermission&gt;&gt;&gt; set = perms.entrySet();
172         for (Map.Entry&lt;String, List&lt;UnresolvedPermission&gt;&gt; e : set) {
173             // Convert list into Vector
174             List&lt;UnresolvedPermission&gt; list = e.getValue();
175             Vector&lt;UnresolvedPermission&gt; vec = new Vector&lt;&gt;(list);
176 
177             // Add to Hashtable being serialized
178             permissions.put(e.getKey(), vec);
179         }
180 
181         // Write out serializable fields
182         ObjectOutputStream.PutField pfields = out.putFields();
183         pfields.put(&quot;permissions&quot;, permissions);
184         out.writeFields();
185     }
186 
187     /*
188      * Reads in a Hashtable in which the values are Vectors of
189      * UnresolvedPermissions and saves them in the perms field.
190      */

191     private void readObject(ObjectInputStream in) throws IOException,
192     ClassNotFoundException {
193         // Don&#39;t call defaultReadObject()
194 
195         // Read in serialized fields
196         ObjectInputStream.GetField gfields = in.readFields();
197 
198         // Get permissions
199         @SuppressWarnings(&quot;unchecked&quot;)
200         // writeObject writes a Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;
201         // for the permissions key, so this cast is safe, unless the data is corrupt.
202         Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; permissions =
203                 (Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;)
204                 gfields.get(&quot;permissions&quot;, null);
205         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
206 
207         // Convert each entry (Vector) into a List
208         Set&lt;Map.Entry&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;&gt; set = permissions.entrySet();
209         for (Map.Entry&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; e : set) {
210             // Convert Vector into ArrayList
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
120 
121     /**
122      * Returns an enumeration of all the UnresolvedPermission lists in the
123      * container.
124      *
125      * @return an enumeration of all the UnresolvedPermission objects.
126      */
127     @Override
128     public Enumeration&lt;Permission&gt; elements() {
129         List&lt;Permission&gt; results =
130             new ArrayList&lt;&gt;(); // where results are stored
131 
132         // Get iterator of Map values (which are lists of permissions)
133         for (List&lt;UnresolvedPermission&gt; l : perms.values()) {
134             results.addAll(l);
135         }
136 
137         return Collections.enumeration(results);
138     }
139 
<span class="line-added">140     @java.io.Serial</span>
141     private static final long serialVersionUID = -7176153071733132400L;
142 
143     // Need to maintain serialization interoperability with earlier releases,
144     // which had the serializable field:
145     // private Hashtable permissions; // keyed on type
146 
147     /**
148      * @serialField permissions java.util.Hashtable
149      *     A table of the UnresolvedPermissions keyed on type, value is Vector
150      *     of permissions
151      */
<span class="line-added">152     @java.io.Serial</span>
153     private static final ObjectStreamField[] serialPersistentFields = {
154         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
155     };
156 
157     /**
158      * @serialData Default field.
159      */
160     /*
161      * Writes the contents of the perms field out as a Hashtable
162      * in which the values are Vectors for
163      * serialization compatibility with earlier releases.
164      */
<span class="line-added">165     @java.io.Serial</span>
166     private void writeObject(ObjectOutputStream out) throws IOException {
167         // Don&#39;t call out.defaultWriteObject()
168 
169         // Copy perms into a Hashtable
170         Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; permissions =
171             new Hashtable&lt;&gt;(perms.size()*2);
172 
173         // Convert each entry (List) into a Vector
174         Set&lt;Map.Entry&lt;String, List&lt;UnresolvedPermission&gt;&gt;&gt; set = perms.entrySet();
175         for (Map.Entry&lt;String, List&lt;UnresolvedPermission&gt;&gt; e : set) {
176             // Convert list into Vector
177             List&lt;UnresolvedPermission&gt; list = e.getValue();
178             Vector&lt;UnresolvedPermission&gt; vec = new Vector&lt;&gt;(list);
179 
180             // Add to Hashtable being serialized
181             permissions.put(e.getKey(), vec);
182         }
183 
184         // Write out serializable fields
185         ObjectOutputStream.PutField pfields = out.putFields();
186         pfields.put(&quot;permissions&quot;, permissions);
187         out.writeFields();
188     }
189 
190     /*
191      * Reads in a Hashtable in which the values are Vectors of
192      * UnresolvedPermissions and saves them in the perms field.
193      */
<span class="line-added">194     @java.io.Serial</span>
195     private void readObject(ObjectInputStream in) throws IOException,
196     ClassNotFoundException {
197         // Don&#39;t call defaultReadObject()
198 
199         // Read in serialized fields
200         ObjectInputStream.GetField gfields = in.readFields();
201 
202         // Get permissions
203         @SuppressWarnings(&quot;unchecked&quot;)
204         // writeObject writes a Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;
205         // for the permissions key, so this cast is safe, unless the data is corrupt.
206         Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; permissions =
207                 (Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;)
208                 gfields.get(&quot;permissions&quot;, null);
209         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
210 
211         // Convert each entry (Vector) into a List
212         Set&lt;Map.Entry&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;&gt; set = permissions.entrySet();
213         for (Map.Entry&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; e : set) {
214             // Convert Vector into ArrayList
</pre>
</td>
</tr>
</table>
<center><a href="UnresolvedPermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cert/CRLException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
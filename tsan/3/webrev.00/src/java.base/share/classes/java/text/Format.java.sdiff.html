<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/Format.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FieldPosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MergeCollation.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/Format.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.Serializable;
 42 
 43 /**
<span class="line-modified"> 44  * &lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive</span>
 45  * information such as dates, messages, and numbers.
 46  *
 47  * &lt;p&gt;
<span class="line-modified"> 48  * &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting</span>
<span class="line-modified"> 49  * locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the</span>
<span class="line-modified"> 50  * &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back</span>
<span class="line-modified"> 51  * into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).</span>
 52  *
 53  * &lt;p&gt;
<span class="line-modified"> 54  * Generally, a format&#39;s &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse</span>
<span class="line-modified"> 55  * any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may</span>
 56  * be exceptional cases where this is not possible. For example, a
<span class="line-modified"> 57  * &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with</span>
<span class="line-modified"> 58  * no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could</span>
 59  * not tell which digits belong to which number.
 60  *
<span class="line-modified"> 61  * &lt;h3&gt;Subclassing&lt;/h3&gt;</span>
 62  *
 63  * &lt;p&gt;
<span class="line-modified"> 64  * The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--</span>
<span class="line-modified"> 65  * &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and</span>
<span class="line-modified"> 66  * &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,</span>
 67  * respectively.
 68  * &lt;p&gt;
 69  * Concrete subclasses must implement three methods:
 70  * &lt;ol&gt;
<span class="line-modified"> 71  * &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;</span>
<span class="line-modified"> 72  * &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;</span>
<span class="line-modified"> 73  * &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;</span>
 74  * &lt;/ol&gt;
 75  * These general methods allow polymorphic parsing and formatting of objects
<span class="line-modified"> 76  * and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.</span>
<span class="line-modified"> 77  * Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for</span>
<span class="line-modified"> 78  * specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific</span>
<span class="line-modified"> 79  * result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a</span>
<span class="line-modified"> 80  * &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;</span>
 81  * when no text in the required format is at the beginning of the input text.
 82  *
 83  * &lt;p&gt;
 84  * Most subclasses will also implement the following factory methods:
 85  * &lt;ol&gt;
 86  * &lt;li&gt;
<span class="line-modified"> 87  * &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate</span>
 88  * for the current locale
 89  * &lt;li&gt;
<span class="line-modified"> 90  * &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format</span>
 91  * object appropriate for the specified locale
 92  * &lt;/ol&gt;
 93  * In addition, some subclasses may also implement other
<span class="line-modified"> 94  * &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For</span>
<span class="line-modified"> 95  * example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides</span>
<span class="line-modified"> 96  * &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;</span>
 97  * methods for getting specialized number formatters.
 98  *
 99  * &lt;p&gt;
<span class="line-modified">100  * Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects</span>
<span class="line-modified">101  * for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)</span>
102  * must also implement the following class method:
103  * &lt;blockquote&gt;
104  * &lt;pre&gt;
105  * public static Locale[] getAvailableLocales()
106  * &lt;/pre&gt;
107  * &lt;/blockquote&gt;
108  *
109  * &lt;p&gt;
110  * And finally subclasses may define a set of constants to identify the various
111  * fields in the formatted output. These constants are used to create a FieldPosition
112  * object which identifies what information is contained in the field and its
113  * position in the formatted result. These constants should be named
114  * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
<span class="line-modified">115  * the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its</span>
116  * friends in {@link DateFormat}.
117  *
<span class="line-modified">118  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
119  *
120  * &lt;p&gt;
121  * Formats are generally not synchronized.
122  * It is recommended to create separate format instances for each thread.
123  * If multiple threads access a format concurrently, it must be synchronized
124  * externally.
125  *
126  * @see          java.text.ParsePosition
127  * @see          java.text.FieldPosition
128  * @see          java.text.NumberFormat
129  * @see          java.text.DateFormat
130  * @see          java.text.MessageFormat
131  * @author       Mark Davis
132  * @since 1.1
133  */
134 public abstract class Format implements Serializable, Cloneable {
135 

136     private static final long serialVersionUID = -299282585814624189L;
137 
138     /**
139      * Sole constructor.  (For invocation by subclass constructors, typically
140      * implicit.)
141      */
142     protected Format() {
143     }
144 
145     /**
146      * Formats an object to produce a string. This is equivalent to
147      * &lt;blockquote&gt;
148      * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
149      *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
150      * &lt;/blockquote&gt;
151      *
152      * @param obj    The object to format
153      * @return       Formatted string.
<span class="line-modified">154      * @exception IllegalArgumentException if the Format cannot format the given</span>
155      *            object
156      */
157     public final String format (Object obj) {
158         return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
159     }
160 
161     /**
162      * Formats an object and appends the resulting text to a given string
163      * buffer.
<span class="line-modified">164      * If the &lt;code&gt;pos&lt;/code&gt; argument identifies a field used by the format,</span>
165      * then its indices are set to the beginning and end of the first such
166      * field encountered.
167      *
168      * @param obj    The object to format
169      * @param toAppendTo    where the text is to be appended
<span class="line-modified">170      * @param pos    A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field</span>
171      *               in the formatted text
<span class="line-modified">172      * @return       the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,</span>
173      *               with formatted text appended
<span class="line-modified">174      * @exception NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified">175      *            &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified">176      * @exception IllegalArgumentException if the Format cannot format the given</span>
177      *            object
178      */
179     public abstract StringBuffer format(Object obj,
180                     StringBuffer toAppendTo,
181                     FieldPosition pos);
182 
183     /**
<span class="line-modified">184      * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">185      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
186      * to build the resulting String, as well as to determine information
187      * about the resulting String.
188      * &lt;p&gt;
189      * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified">190      * &lt;code&gt;Field&lt;/code&gt;. It is up to each &lt;code&gt;Format&lt;/code&gt; implementation</span>
191      * to define what the legal values are for each attribute in the
<span class="line-modified">192      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;, but typically the attribute</span>
193      * key is also used as the attribute value.
194      * &lt;p&gt;The default implementation creates an
<span class="line-modified">195      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses</span>
196      * that support fields should override this and create an
<span class="line-modified">197      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.</span>
198      *
<span class="line-modified">199      * @exception NullPointerException if obj is null.</span>
<span class="line-modified">200      * @exception IllegalArgumentException when the Format cannot format the</span>
201      *            given object.
202      * @param obj The object to format
203      * @return AttributedCharacterIterator describing the formatted value.
204      * @since 1.4
205      */
206     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
207         return createAttributedCharacterIterator(format(obj));
208     }
209 
210     /**
211      * Parses text from a string to produce an object.
212      * &lt;p&gt;
213      * The method attempts to parse text starting at the index given by
<span class="line-modified">214      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">215      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
216      * to the index after the last character used (parsing does not necessarily
217      * use all characters up to the end of the string), and the parsed
<span class="line-modified">218      * object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
219      * indicate the starting point for the next call to this method.
<span class="line-modified">220      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">221      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
222      * the character where the error occurred, and null is returned.
223      *
<span class="line-modified">224      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">225      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
226      *            index information as described above.
<span class="line-modified">227      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of</span>
228      *         error, returns null.
229      * @throws NullPointerException if {@code source} or {@code pos} is null.
230      */
231     public abstract Object parseObject (String source, ParsePosition pos);
232 
233     /**
234      * Parses text from the beginning of the given string to produce an object.
235      * The method may not use the entire text of the given string.
236      *
<span class="line-modified">237      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">238      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string.</span>
<span class="line-modified">239      * @exception ParseException if the beginning of the specified string</span>
240      *            cannot be parsed.
241      * @throws NullPointerException if {@code source} is null.
242      */
243     public Object parseObject(String source) throws ParseException {
244         ParsePosition pos = new ParsePosition(0);
245         Object result = parseObject(source, pos);
246         if (pos.index == 0) {
247             throw new ParseException(&quot;Format.parseObject(String) failed&quot;,
248                 pos.errorIndex);
249         }
250         return result;
251     }
252 
253     /**
254      * Creates and returns a copy of this object.
255      *
256      * @return a clone of this instance.
257      */
258     public Object clone() {
259         try {
260             return super.clone();
261         } catch (CloneNotSupportedException e) {
262             // will never happen
263             throw new InternalError(e);
264         }
265     }
266 
267     //
268     // Convenience methods for creating AttributedCharacterIterators from
269     // different parameters.
270     //
271 
272     /**
<span class="line-modified">273      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String</span>
<span class="line-modified">274      * &lt;code&gt;s&lt;/code&gt;.</span>
275      *
276      * @param s String to create AttributedCharacterIterator from
277      * @return AttributedCharacterIterator wrapping s
278      */
279     AttributedCharacterIterator createAttributedCharacterIterator(String s) {
280         AttributedString as = new AttributedString(s);
281 
282         return as.getIterator();
283     }
284 
285     /**
<span class="line-modified">286      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; containing the</span>
287      * concatenated contents of the passed in
<span class="line-modified">288      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;s.</span>
289      *
290      * @param iterators AttributedCharacterIterators used to create resulting
291      *                  AttributedCharacterIterators
292      * @return AttributedCharacterIterator wrapping passed in
293      *         AttributedCharacterIterators
294      */
295     AttributedCharacterIterator createAttributedCharacterIterator(
296                        AttributedCharacterIterator[] iterators) {
297         AttributedString as = new AttributedString(iterators);
298 
299         return as.getIterator();
300     }
301 
302     /**
303      * Returns an AttributedCharacterIterator with the String
<span class="line-modified">304      * &lt;code&gt;string&lt;/code&gt; and additional key/value pair &lt;code&gt;key&lt;/code&gt;,</span>
<span class="line-modified">305      * &lt;code&gt;value&lt;/code&gt;.</span>
306      *
307      * @param string String to create AttributedCharacterIterator from
308      * @param key Key for AttributedCharacterIterator
309      * @param value Value associated with key in AttributedCharacterIterator
310      * @return AttributedCharacterIterator wrapping args
311      */
312     AttributedCharacterIterator createAttributedCharacterIterator(
313                       String string, AttributedCharacterIterator.Attribute key,
314                       Object value) {
315         AttributedString as = new AttributedString(string);
316 
317         as.addAttribute(key, value);
318         return as.getIterator();
319     }
320 
321     /**
322      * Creates an AttributedCharacterIterator with the contents of
<span class="line-modified">323      * &lt;code&gt;iterator&lt;/code&gt; and the additional attribute &lt;code&gt;key&lt;/code&gt;</span>
<span class="line-modified">324      * &lt;code&gt;value&lt;/code&gt;.</span>
325      *
326      * @param iterator Initial AttributedCharacterIterator to add arg to
327      * @param key Key for AttributedCharacterIterator
328      * @param value Value associated with key in AttributedCharacterIterator
329      * @return AttributedCharacterIterator wrapping args
330      */
331     AttributedCharacterIterator createAttributedCharacterIterator(
332               AttributedCharacterIterator iterator,
333               AttributedCharacterIterator.Attribute key, Object value) {
334         AttributedString as = new AttributedString(iterator);
335 
336         as.addAttribute(key, value);
337         return as.getIterator();
338     }
339 
340 
341     /**
342      * Defines constants that are used as attribute keys in the
<span class="line-modified">343      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">344      * from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">345      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
346      *
347      * @since 1.4
348      */
349     public static class Field extends AttributedCharacterIterator.Attribute {
350 
351         // Proclaim serial compatibility with 1.4 FCS

352         private static final long serialVersionUID = 276966692217360283L;
353 
354         /**
355          * Creates a Field with the specified name.
356          *
357          * @param name Name of the attribute
358          */
359         protected Field(String name) {
360             super(name);
361         }
362     }
363 
364 
365     /**
<span class="line-modified">366      * FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;</span>
367      * implementations as they are formatting the Objects. This allows for
368      * storage of the individual sections of the formatted String for
<span class="line-modified">369      * later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an</span>
<span class="line-modified">370      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
371      * &lt;p&gt;
<span class="line-modified">372      * Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify</span>
373      * the delegate of fields in any particular order.
374      *
375      * @see FieldPosition#getFieldDelegate
376      * @see CharacterIteratorFieldDelegate
377      */
378     interface FieldDelegate {
379         /**
380          * Notified when a particular region of the String is formatted. This
381          * method will be invoked if there is no corresponding integer field id
<span class="line-modified">382          * matching &lt;code&gt;attr&lt;/code&gt;.</span>
383          *
384          * @param attr Identifies the field matched
385          * @param value Value associated with the field
386          * @param start Beginning location of the field, will be &gt;= 0
387          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
388          * @param buffer Contains current formatted value, receiver should
389          *        NOT modify it.
390          */
391         public void formatted(Format.Field attr, Object value, int start,
392                               int end, StringBuffer buffer);
393 
394         /**
395          * Notified when a particular region of the String is formatted.
396          *
397          * @param fieldID Identifies the field by integer
398          * @param attr Identifies the field matched
399          * @param value Value associated with the field
400          * @param start Beginning location of the field, will be &gt;= 0
401          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
402          * @param buffer Contains current formatted value, receiver should
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.Serializable;
 42 
 43 /**
<span class="line-modified"> 44  * {@code Format} is an abstract base class for formatting locale-sensitive</span>
 45  * information such as dates, messages, and numbers.
 46  *
 47  * &lt;p&gt;
<span class="line-modified"> 48  * {@code Format} defines the programming interface for formatting</span>
<span class="line-modified"> 49  * locale-sensitive objects into {@code String}s (the</span>
<span class="line-modified"> 50  * {@code format} method) and for parsing {@code String}s back</span>
<span class="line-modified"> 51  * into objects (the {@code parseObject} method).</span>
 52  *
 53  * &lt;p&gt;
<span class="line-modified"> 54  * Generally, a format&#39;s {@code parseObject} method must be able to parse</span>
<span class="line-modified"> 55  * any string formatted by its {@code format} method. However, there may</span>
 56  * be exceptional cases where this is not possible. For example, a
<span class="line-modified"> 57  * {@code format} method might create two adjacent integer numbers with</span>
<span class="line-modified"> 58  * no separator in between, and in this case the {@code parseObject} could</span>
 59  * not tell which digits belong to which number.
 60  *
<span class="line-modified"> 61  * &lt;h2&gt;Subclassing&lt;/h2&gt;</span>
 62  *
 63  * &lt;p&gt;
<span class="line-modified"> 64  * The Java Platform provides three specialized subclasses of {@code Format}--</span>
<span class="line-modified"> 65  * {@code DateFormat}, {@code MessageFormat}, and</span>
<span class="line-modified"> 66  * {@code NumberFormat}--for formatting dates, messages, and numbers,</span>
 67  * respectively.
 68  * &lt;p&gt;
 69  * Concrete subclasses must implement three methods:
 70  * &lt;ol&gt;
<span class="line-modified"> 71  * &lt;li&gt; {@code format(Object obj, StringBuffer toAppendTo, FieldPosition pos)}</span>
<span class="line-modified"> 72  * &lt;li&gt; {@code formatToCharacterIterator(Object obj)}</span>
<span class="line-modified"> 73  * &lt;li&gt; {@code parseObject(String source, ParsePosition pos)}</span>
 74  * &lt;/ol&gt;
 75  * These general methods allow polymorphic parsing and formatting of objects
<span class="line-modified"> 76  * and are used, for example, by {@code MessageFormat}.</span>
<span class="line-modified"> 77  * Subclasses often also provide additional {@code format} methods for</span>
<span class="line-modified"> 78  * specific input types as well as {@code parse} methods for specific</span>
<span class="line-modified"> 79  * result types. Any {@code parse} method that does not take a</span>
<span class="line-modified"> 80  * {@code ParsePosition} argument should throw {@code ParseException}</span>
 81  * when no text in the required format is at the beginning of the input text.
 82  *
 83  * &lt;p&gt;
 84  * Most subclasses will also implement the following factory methods:
 85  * &lt;ol&gt;
 86  * &lt;li&gt;
<span class="line-modified"> 87  * {@code getInstance} for getting a useful format object appropriate</span>
 88  * for the current locale
 89  * &lt;li&gt;
<span class="line-modified"> 90  * {@code getInstance(Locale)} for getting a useful format</span>
 91  * object appropriate for the specified locale
 92  * &lt;/ol&gt;
 93  * In addition, some subclasses may also implement other
<span class="line-modified"> 94  * {@code getXxxxInstance} methods for more specialized control. For</span>
<span class="line-modified"> 95  * example, the {@code NumberFormat} class provides</span>
<span class="line-modified"> 96  * {@code getPercentInstance} and {@code getCurrencyInstance}</span>
 97  * methods for getting specialized number formatters.
 98  *
 99  * &lt;p&gt;
<span class="line-modified">100  * Subclasses of {@code Format} that allow programmers to create objects</span>
<span class="line-modified">101  * for locales (with {@code getInstance(Locale)} for example)</span>
102  * must also implement the following class method:
103  * &lt;blockquote&gt;
104  * &lt;pre&gt;
105  * public static Locale[] getAvailableLocales()
106  * &lt;/pre&gt;
107  * &lt;/blockquote&gt;
108  *
109  * &lt;p&gt;
110  * And finally subclasses may define a set of constants to identify the various
111  * fields in the formatted output. These constants are used to create a FieldPosition
112  * object which identifies what information is contained in the field and its
113  * position in the formatted result. These constants should be named
114  * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
<span class="line-modified">115  * the field. For examples of these constants, see {@code ERA_FIELD} and its</span>
116  * friends in {@link DateFormat}.
117  *
<span class="line-modified">118  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
119  *
120  * &lt;p&gt;
121  * Formats are generally not synchronized.
122  * It is recommended to create separate format instances for each thread.
123  * If multiple threads access a format concurrently, it must be synchronized
124  * externally.
125  *
126  * @see          java.text.ParsePosition
127  * @see          java.text.FieldPosition
128  * @see          java.text.NumberFormat
129  * @see          java.text.DateFormat
130  * @see          java.text.MessageFormat
131  * @author       Mark Davis
132  * @since 1.1
133  */
134 public abstract class Format implements Serializable, Cloneable {
135 
<span class="line-added">136     @java.io.Serial</span>
137     private static final long serialVersionUID = -299282585814624189L;
138 
139     /**
140      * Sole constructor.  (For invocation by subclass constructors, typically
141      * implicit.)
142      */
143     protected Format() {
144     }
145 
146     /**
147      * Formats an object to produce a string. This is equivalent to
148      * &lt;blockquote&gt;
149      * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
150      *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
151      * &lt;/blockquote&gt;
152      *
153      * @param obj    The object to format
154      * @return       Formatted string.
<span class="line-modified">155      * @throws    IllegalArgumentException if the Format cannot format the given</span>
156      *            object
157      */
158     public final String format (Object obj) {
159         return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
160     }
161 
162     /**
163      * Formats an object and appends the resulting text to a given string
164      * buffer.
<span class="line-modified">165      * If the {@code pos} argument identifies a field used by the format,</span>
166      * then its indices are set to the beginning and end of the first such
167      * field encountered.
168      *
169      * @param obj    The object to format
170      * @param toAppendTo    where the text is to be appended
<span class="line-modified">171      * @param pos    A {@code FieldPosition} identifying a field</span>
172      *               in the formatted text
<span class="line-modified">173      * @return       the string buffer passed in as {@code toAppendTo},</span>
174      *               with formatted text appended
<span class="line-modified">175      * @throws    NullPointerException if {@code toAppendTo} or</span>
<span class="line-modified">176      *            {@code pos} is null</span>
<span class="line-modified">177      * @throws    IllegalArgumentException if the Format cannot format the given</span>
178      *            object
179      */
180     public abstract StringBuffer format(Object obj,
181                     StringBuffer toAppendTo,
182                     FieldPosition pos);
183 
184     /**
<span class="line-modified">185      * Formats an Object producing an {@code AttributedCharacterIterator}.</span>
<span class="line-modified">186      * You can use the returned {@code AttributedCharacterIterator}</span>
187      * to build the resulting String, as well as to determine information
188      * about the resulting String.
189      * &lt;p&gt;
190      * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified">191      * {@code Field}. It is up to each {@code Format} implementation</span>
192      * to define what the legal values are for each attribute in the
<span class="line-modified">193      * {@code AttributedCharacterIterator}, but typically the attribute</span>
194      * key is also used as the attribute value.
195      * &lt;p&gt;The default implementation creates an
<span class="line-modified">196      * {@code AttributedCharacterIterator} with no attributes. Subclasses</span>
197      * that support fields should override this and create an
<span class="line-modified">198      * {@code AttributedCharacterIterator} with meaningful attributes.</span>
199      *
<span class="line-modified">200      * @throws    NullPointerException if obj is null.</span>
<span class="line-modified">201      * @throws    IllegalArgumentException when the Format cannot format the</span>
202      *            given object.
203      * @param obj The object to format
204      * @return AttributedCharacterIterator describing the formatted value.
205      * @since 1.4
206      */
207     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
208         return createAttributedCharacterIterator(format(obj));
209     }
210 
211     /**
212      * Parses text from a string to produce an object.
213      * &lt;p&gt;
214      * The method attempts to parse text starting at the index given by
<span class="line-modified">215      * {@code pos}.</span>
<span class="line-modified">216      * If parsing succeeds, then the index of {@code pos} is updated</span>
217      * to the index after the last character used (parsing does not necessarily
218      * use all characters up to the end of the string), and the parsed
<span class="line-modified">219      * object is returned. The updated {@code pos} can be used to</span>
220      * indicate the starting point for the next call to this method.
<span class="line-modified">221      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">222      * changed, the error index of {@code pos} is set to the index of</span>
223      * the character where the error occurred, and null is returned.
224      *
<span class="line-modified">225      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">226      * @param pos A {@code ParsePosition} object with index and error</span>
227      *            index information as described above.
<span class="line-modified">228      * @return An {@code Object} parsed from the string. In case of</span>
229      *         error, returns null.
230      * @throws NullPointerException if {@code source} or {@code pos} is null.
231      */
232     public abstract Object parseObject (String source, ParsePosition pos);
233 
234     /**
235      * Parses text from the beginning of the given string to produce an object.
236      * The method may not use the entire text of the given string.
237      *
<span class="line-modified">238      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">239      * @return An {@code Object} parsed from the string.</span>
<span class="line-modified">240      * @throws    ParseException if the beginning of the specified string</span>
241      *            cannot be parsed.
242      * @throws NullPointerException if {@code source} is null.
243      */
244     public Object parseObject(String source) throws ParseException {
245         ParsePosition pos = new ParsePosition(0);
246         Object result = parseObject(source, pos);
247         if (pos.index == 0) {
248             throw new ParseException(&quot;Format.parseObject(String) failed&quot;,
249                 pos.errorIndex);
250         }
251         return result;
252     }
253 
254     /**
255      * Creates and returns a copy of this object.
256      *
257      * @return a clone of this instance.
258      */
259     public Object clone() {
260         try {
261             return super.clone();
262         } catch (CloneNotSupportedException e) {
263             // will never happen
264             throw new InternalError(e);
265         }
266     }
267 
268     //
269     // Convenience methods for creating AttributedCharacterIterators from
270     // different parameters.
271     //
272 
273     /**
<span class="line-modified">274      * Creates an {@code AttributedCharacterIterator} for the String</span>
<span class="line-modified">275      * {@code s}.</span>
276      *
277      * @param s String to create AttributedCharacterIterator from
278      * @return AttributedCharacterIterator wrapping s
279      */
280     AttributedCharacterIterator createAttributedCharacterIterator(String s) {
281         AttributedString as = new AttributedString(s);
282 
283         return as.getIterator();
284     }
285 
286     /**
<span class="line-modified">287      * Creates an {@code AttributedCharacterIterator} containing the</span>
288      * concatenated contents of the passed in
<span class="line-modified">289      * {@code AttributedCharacterIterator}s.</span>
290      *
291      * @param iterators AttributedCharacterIterators used to create resulting
292      *                  AttributedCharacterIterators
293      * @return AttributedCharacterIterator wrapping passed in
294      *         AttributedCharacterIterators
295      */
296     AttributedCharacterIterator createAttributedCharacterIterator(
297                        AttributedCharacterIterator[] iterators) {
298         AttributedString as = new AttributedString(iterators);
299 
300         return as.getIterator();
301     }
302 
303     /**
304      * Returns an AttributedCharacterIterator with the String
<span class="line-modified">305      * {@code string} and additional key/value pair {@code key},</span>
<span class="line-modified">306      * {@code value}.</span>
307      *
308      * @param string String to create AttributedCharacterIterator from
309      * @param key Key for AttributedCharacterIterator
310      * @param value Value associated with key in AttributedCharacterIterator
311      * @return AttributedCharacterIterator wrapping args
312      */
313     AttributedCharacterIterator createAttributedCharacterIterator(
314                       String string, AttributedCharacterIterator.Attribute key,
315                       Object value) {
316         AttributedString as = new AttributedString(string);
317 
318         as.addAttribute(key, value);
319         return as.getIterator();
320     }
321 
322     /**
323      * Creates an AttributedCharacterIterator with the contents of
<span class="line-modified">324      * {@code iterator} and the additional attribute {@code key}</span>
<span class="line-modified">325      * {@code value}.</span>
326      *
327      * @param iterator Initial AttributedCharacterIterator to add arg to
328      * @param key Key for AttributedCharacterIterator
329      * @param value Value associated with key in AttributedCharacterIterator
330      * @return AttributedCharacterIterator wrapping args
331      */
332     AttributedCharacterIterator createAttributedCharacterIterator(
333               AttributedCharacterIterator iterator,
334               AttributedCharacterIterator.Attribute key, Object value) {
335         AttributedString as = new AttributedString(iterator);
336 
337         as.addAttribute(key, value);
338         return as.getIterator();
339     }
340 
341 
342     /**
343      * Defines constants that are used as attribute keys in the
<span class="line-modified">344      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">345      * from {@code Format.formatToCharacterIterator} and as</span>
<span class="line-modified">346      * field identifiers in {@code FieldPosition}.</span>
347      *
348      * @since 1.4
349      */
350     public static class Field extends AttributedCharacterIterator.Attribute {
351 
352         // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">353         @java.io.Serial</span>
354         private static final long serialVersionUID = 276966692217360283L;
355 
356         /**
357          * Creates a Field with the specified name.
358          *
359          * @param name Name of the attribute
360          */
361         protected Field(String name) {
362             super(name);
363         }
364     }
365 
366 
367     /**
<span class="line-modified">368      * FieldDelegate is notified by the various {@code Format}</span>
369      * implementations as they are formatting the Objects. This allows for
370      * storage of the individual sections of the formatted String for
<span class="line-modified">371      * later use, such as in a {@code FieldPosition} or for an</span>
<span class="line-modified">372      * {@code AttributedCharacterIterator}.</span>
373      * &lt;p&gt;
<span class="line-modified">374      * Delegates should NOT assume that the {@code Format} will notify</span>
375      * the delegate of fields in any particular order.
376      *
377      * @see FieldPosition#getFieldDelegate
378      * @see CharacterIteratorFieldDelegate
379      */
380     interface FieldDelegate {
381         /**
382          * Notified when a particular region of the String is formatted. This
383          * method will be invoked if there is no corresponding integer field id
<span class="line-modified">384          * matching {@code attr}.</span>
385          *
386          * @param attr Identifies the field matched
387          * @param value Value associated with the field
388          * @param start Beginning location of the field, will be &gt;= 0
389          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
390          * @param buffer Contains current formatted value, receiver should
391          *        NOT modify it.
392          */
393         public void formatted(Format.Field attr, Object value, int start,
394                               int end, StringBuffer buffer);
395 
396         /**
397          * Notified when a particular region of the String is formatted.
398          *
399          * @param fieldID Identifies the field by integer
400          * @param attr Identifies the field matched
401          * @param value Value associated with the field
402          * @param start Beginning location of the field, will be &gt;= 0
403          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
404          * @param buffer Contains current formatted value, receiver should
</pre>
</td>
</tr>
</table>
<center><a href="FieldPosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MergeCollation.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
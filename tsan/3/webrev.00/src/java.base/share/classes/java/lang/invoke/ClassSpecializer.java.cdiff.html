<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallSite.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConstantBootstraps.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   * questions.
   */
  
  package java.lang.invoke;
  
<span class="line-added">+ import jdk.internal.access.SharedSecrets;</span>
  import jdk.internal.loader.BootLoader;
  import jdk.internal.org.objectweb.asm.ClassWriter;
  import jdk.internal.org.objectweb.asm.FieldVisitor;
  import jdk.internal.org.objectweb.asm.MethodVisitor;
  import jdk.internal.vm.annotation.Stable;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  import java.lang.reflect.Constructor;
  import java.lang.reflect.Field;
  import java.lang.reflect.Modifier;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
<span class="line-added">+ import java.security.ProtectionDomain;</span>
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;
  import java.util.Objects;
  import java.util.concurrent.ConcurrentHashMap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,10 ***</span>
<span class="line-new-header">--- 456,15 ---</span>
      /**
       * Code generation support for instances.
       * Subclasses can modify the behavior.
       */
      public class Factory {
<span class="line-added">+         /**</span>
<span class="line-added">+          * Constructs a factory.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         Factory() {}</span>
<span class="line-added">+ </span>
          /**
           * Get a concrete subclass of the top class for a given combination of bound types.
           *
           * @param speciesData the species requiring the class, not yet linked
           * @return a linked version of the same species
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,35 ***</span>
           *
           * For example, a concrete species for two references and one integral bound value
           * has a shape like the following:
           *
           * &lt;pre&gt;
<span class="line-modified">!          * class TopClass { ... private static</span>
<span class="line-modified">!          * final class Species_LLI extends TopClass {</span>
<span class="line-modified">!          *     final Object argL0;</span>
<span class="line-modified">!          *     final Object argL1;</span>
<span class="line-modified">!          *     final int argI2;</span>
<span class="line-modified">!          *     private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified">!          *         super(ctarg, ...);</span>
<span class="line-modified">!          *         this.argL0 = argL0;</span>
<span class="line-modified">!          *         this.argL1 = argL1;</span>
<span class="line-modified">!          *         this.argI2 = argI2;</span>
<span class="line-modified">!          *     }</span>
<span class="line-modified">!          *     final SpeciesData speciesData() { return BMH_SPECIES; }</span>
<span class="line-modified">!          *     &amp;#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards</span>
<span class="line-modified">!          *     static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified">!          *         return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified">!          *     }</span>
<span class="line-modified">!          *     final TopClass copyWith(CT ctarg, ...) {</span>
<span class="line-modified">!          *         return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified">!          *     }</span>
<span class="line-modified">!          *     // two transforms, for the sake of illustration:</span>
<span class="line-modified">!          *     final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {</span>
<span class="line-modified">!          *         return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-modified">!          *     }</span>
<span class="line-modified">!          *     final TopClass copyWithExtendI(CT ctarg, ..., int narg) {</span>
<span class="line-modified">!          *         return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
           *     }
           * }
           * &lt;/pre&gt;
           *
           * @param className of the species
<span class="line-new-header">--- 542,37 ---</span>
           *
           * For example, a concrete species for two references and one integral bound value
           * has a shape like the following:
           *
           * &lt;pre&gt;
<span class="line-modified">!          * class TopClass {</span>
<span class="line-modified">!          *     ...</span>
<span class="line-modified">!          *     private static final class Species_LLI extends TopClass {</span>
<span class="line-modified">!          *         final Object argL0;</span>
<span class="line-modified">!          *         final Object argL1;</span>
<span class="line-modified">!          *         final int argI2;</span>
<span class="line-modified">!          *         private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified">!          *             super(ctarg, ...);</span>
<span class="line-modified">!          *             this.argL0 = argL0;</span>
<span class="line-modified">!          *             this.argL1 = argL1;</span>
<span class="line-modified">!          *             this.argI2 = argI2;</span>
<span class="line-modified">!          *         }</span>
<span class="line-modified">!          *         final SpeciesData speciesData() { return BMH_SPECIES; }</span>
<span class="line-modified">!          *         &amp;#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards</span>
<span class="line-modified">!          *         static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified">!          *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified">!          *         }</span>
<span class="line-modified">!          *         final TopClass copyWith(CT ctarg, ...) {</span>
<span class="line-modified">!          *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified">!          *         }</span>
<span class="line-modified">!          *         // two transforms, for the sake of illustration:</span>
<span class="line-modified">!          *         final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {</span>
<span class="line-modified">!          *             return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-modified">!          *         }</span>
<span class="line-modified">!          *         final TopClass copyWithExtendI(CT ctarg, ..., int narg) {</span>
<span class="line-added">+          *             return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-added">+          *         }</span>
           *     }
           * }
           * &lt;/pre&gt;
           *
           * @param className of the species
</pre>
<hr />
<pre>
<span class="line-old-header">*** 573,23 ***</span>
          Class&lt;? extends T&gt; generateConcreteSpeciesCode(String className, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {
              byte[] classFile = generateConcreteSpeciesCodeFile(className, speciesData);
  
              // load class
              InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);
<span class="line-modified">!             Class&lt;?&gt; speciesCode;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             MethodHandles.Lookup lookup = IMPL_LOOKUP.in(topClass());</span>
<span class="line-modified">!             speciesCode = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 public Class&lt;?&gt; run() {</span>
<span class="line-modified">!                     try {</span>
<span class="line-modified">!                         return lookup.defineClass(classFile);</span>
<span class="line-modified">!                     } catch (Exception ex) {</span>
<span class="line-modified">!                         throw newInternalError(ex);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             });</span>
              return speciesCode.asSubclass(topClass());
          }
  
          // These are named like constants because there is only one per specialization scheme:
          private final String SPECIES_DATA = classBCName(metaType);
<span class="line-new-header">--- 582,23 ---</span>
          Class&lt;? extends T&gt; generateConcreteSpeciesCode(String className, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {
              byte[] classFile = generateConcreteSpeciesCodeFile(className, speciesData);
  
              // load class
              InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);
<span class="line-modified">!             ClassLoader cl = topClass.getClassLoader();</span>
<span class="line-modified">!             ProtectionDomain pd = null;</span>
<span class="line-modified">!             if (cl != null) {</span>
<span class="line-modified">!                 pd = AccessController.doPrivileged(</span>
<span class="line-modified">!                         new PrivilegedAction&lt;&gt;() {</span>
<span class="line-modified">!                             @Override</span>
<span class="line-modified">!                             public ProtectionDomain run() {</span>
<span class="line-modified">!                                 return topClass().getProtectionDomain();</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                         });</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             Class&lt;?&gt; speciesCode = SharedSecrets.getJavaLangAccess()</span>
<span class="line-modified">!                     .defineClass(cl, className, classFile, pd, &quot;_ClassSpecializer_generateConcreteSpeciesCode&quot;);</span>
              return speciesCode.asSubclass(topClass());
          }
  
          // These are named like constants because there is only one per specialization scheme:
          private final String SPECIES_DATA = classBCName(metaType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 615,11 ***</span>
              TRANSFORM_TYPES = List.of(tts.toArray(new MethodType[0]));
              TRANSFORM_MODS = List.of(tms.toArray(new Integer[0]));
          }
          private static final int ACC_PPP = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
  
<span class="line-modified">!         /*non-public*/ byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {</span>
              final String className = classBCName(className0);
              final String superClassName = classBCName(speciesData.deriveSuperClass());
  
              final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
              final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<span class="line-new-header">--- 624,12 ---</span>
              TRANSFORM_TYPES = List.of(tts.toArray(new MethodType[0]));
              TRANSFORM_MODS = List.of(tms.toArray(new Integer[0]));
          }
          private static final int ACC_PPP = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
  
<span class="line-modified">!         /*non-public*/</span>
<span class="line-added">+         byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {</span>
              final String className = classBCName(className0);
              final String superClassName = classBCName(speciesData.deriveSuperClass());
  
              final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
              final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
</pre>
<center><a href="CallSite.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConstantBootstraps.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
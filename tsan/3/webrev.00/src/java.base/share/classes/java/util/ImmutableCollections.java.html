<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/ImmutableCollections.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.IOException;
  29 import java.io.InvalidObjectException;
  30 import java.io.ObjectInputStream;
  31 import java.io.ObjectOutputStream;
  32 import java.io.ObjectStreamException;
  33 import java.io.Serializable;
  34 import java.lang.reflect.Array;
  35 import java.util.function.BiFunction;
  36 import java.util.function.Function;
  37 import java.util.function.Predicate;
  38 import java.util.function.UnaryOperator;
  39 import jdk.internal.access.SharedSecrets;
  40 import jdk.internal.misc.VM;
  41 import jdk.internal.vm.annotation.Stable;
  42 
  43 /**
  44  * Container class for immutable collections. Not part of the public API.
  45  * Mainly for namespace management and shared infrastructure.
  46  *
  47  * Serial warnings are suppressed throughout because all implementation
  48  * classes use a serial proxy and thus have no need to declare serialVersionUID.
  49  */
  50 @SuppressWarnings(&quot;serial&quot;)
  51 class ImmutableCollections {
  52     /**
  53      * A &quot;salt&quot; value used for randomizing iteration order. This is initialized once
  54      * and stays constant for the lifetime of the JVM. It need not be truly random, but
  55      * it needs to vary sufficiently from one run to the next so that iteration order
  56      * will vary between JVM runs.
  57      */
  58     private static final long SALT32L;
  59 
  60     /**
  61      * For set and map iteration, we will iterate in &quot;reverse&quot; stochastically,
  62      * decided at bootstrap time.
  63      */
  64     private static final boolean REVERSE;
  65     static {
  66         // to generate a reasonably random and well-mixed SALT, use an arbitrary
  67         // value (a slice of pi), multiply with the System.nanoTime, then pick
  68         // the mid 32-bits from the product. By picking a SALT value in the
  69         // [0 ... 0xFFFF_FFFFL == 2^32-1] range, we ensure that for any positive
  70         // int N, (SALT32L * N) &gt;&gt; 32 is a number in the [0 ... N-1] range. This
  71         // property will be used to avoid more expensive modulo-based
  72         // calculations.
  73         long color = 0x243F_6A88_85A3_08D3L; // slice of pi
  74         long seed = System.nanoTime();
  75         SALT32L = (int)((color * seed) &gt;&gt; 16) &amp; 0xFFFF_FFFFL;
  76         // use the lowest bit to determine if we should reverse iteration
  77         REVERSE = (SALT32L &amp; 1) == 0;
  78     }
  79 
  80     /**
  81      * Constants following this might be initialized from the CDS archive via
  82      * this array.
  83      */
  84     private static Object[] archivedObjects;
  85 
  86     private static final Object EMPTY;
  87 
  88     static final ListN&lt;?&gt; EMPTY_LIST;
  89 
  90     static final SetN&lt;?&gt; EMPTY_SET;
  91 
  92     static final MapN&lt;?,?&gt; EMPTY_MAP;
  93 
  94     static {
  95         VM.initializeFromArchive(ImmutableCollections.class);
  96         if (archivedObjects == null) {
  97             EMPTY = new Object();
  98             EMPTY_LIST = new ListN&lt;&gt;();
  99             EMPTY_SET = new SetN&lt;&gt;();
 100             EMPTY_MAP = new MapN&lt;&gt;();
 101             archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };
 102         } else {
 103             EMPTY = archivedObjects[0];
 104             EMPTY_LIST = (ListN)archivedObjects[1];
 105             EMPTY_SET = (SetN)archivedObjects[2];
 106             EMPTY_MAP = (MapN)archivedObjects[3];
 107         }
 108     }
 109 
 110     /** No instances. */
 111     private ImmutableCollections() { }
 112 
 113     /**
 114      * The reciprocal of load factor. Given a number of elements
 115      * to store, multiply by this factor to get the table size.
 116      */
 117     static final int EXPAND_FACTOR = 2;
 118 
 119     static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }
 120 
 121     static abstract class AbstractImmutableCollection&lt;E&gt; extends AbstractCollection&lt;E&gt; {
 122         // all mutating methods throw UnsupportedOperationException
 123         @Override public boolean add(E e) { throw uoe(); }
 124         @Override public boolean addAll(Collection&lt;? extends E&gt; c) { throw uoe(); }
 125         @Override public void    clear() { throw uoe(); }
 126         @Override public boolean remove(Object o) { throw uoe(); }
 127         @Override public boolean removeAll(Collection&lt;?&gt; c) { throw uoe(); }
 128         @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) { throw uoe(); }
 129         @Override public boolean retainAll(Collection&lt;?&gt; c) { throw uoe(); }
 130     }
 131 
 132     // ---------- List Implementations ----------
 133 
 134     // make a copy, short-circuiting based on implementation class
 135     @SuppressWarnings(&quot;unchecked&quot;)
 136     static &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) {
 137         if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) {
 138             return (List&lt;E&gt;)coll;
 139         } else {
 140             return (List&lt;E&gt;)List.of(coll.toArray());
 141         }
 142     }
 143 
 144     static abstract class AbstractImmutableList&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;
 145             implements List&lt;E&gt;, RandomAccess {
 146 
 147         // all mutating methods throw UnsupportedOperationException
 148         @Override public void    add(int index, E element) { throw uoe(); }
 149         @Override public boolean addAll(int index, Collection&lt;? extends E&gt; c) { throw uoe(); }
 150         @Override public E       remove(int index) { throw uoe(); }
 151         @Override public void    replaceAll(UnaryOperator&lt;E&gt; operator) { throw uoe(); }
 152         @Override public E       set(int index, E element) { throw uoe(); }
 153         @Override public void    sort(Comparator&lt;? super E&gt; c) { throw uoe(); }
 154 
 155         @Override
 156         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 157             int size = size();
 158             subListRangeCheck(fromIndex, toIndex, size);
 159             return SubList.fromList(this, fromIndex, toIndex);
 160         }
 161 
 162         static void subListRangeCheck(int fromIndex, int toIndex, int size) {
 163             if (fromIndex &lt; 0)
 164                 throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
 165             if (toIndex &gt; size)
 166                 throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
 167             if (fromIndex &gt; toIndex)
 168                 throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
 169                         &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
 170         }
 171 
 172         @Override
 173         public Iterator&lt;E&gt; iterator() {
 174             return new ListItr&lt;E&gt;(this, size());
 175         }
 176 
 177         @Override
 178         public ListIterator&lt;E&gt; listIterator() {
 179             return listIterator(0);
 180         }
 181 
 182         @Override
 183         public ListIterator&lt;E&gt; listIterator(final int index) {
 184             int size = size();
 185             if (index &lt; 0 || index &gt; size) {
 186                 throw outOfBounds(index);
 187             }
 188             return new ListItr&lt;E&gt;(this, size, index);
 189         }
 190 
 191         @Override
 192         public boolean equals(Object o) {
 193             if (o == this) {
 194                 return true;
 195             }
 196 
 197             if (!(o instanceof List)) {
 198                 return false;
 199             }
 200 
 201             Iterator&lt;?&gt; oit = ((List&lt;?&gt;) o).iterator();
 202             for (int i = 0, s = size(); i &lt; s; i++) {
 203                 if (!oit.hasNext() || !get(i).equals(oit.next())) {
 204                     return false;
 205                 }
 206             }
 207             return !oit.hasNext();
 208         }
 209 
 210         @Override
 211         public int indexOf(Object o) {
 212             Objects.requireNonNull(o);
 213             for (int i = 0, s = size(); i &lt; s; i++) {
 214                 if (o.equals(get(i))) {
 215                     return i;
 216                 }
 217             }
 218             return -1;
 219         }
 220 
 221         @Override
 222         public int lastIndexOf(Object o) {
 223             Objects.requireNonNull(o);
 224             for (int i = size() - 1; i &gt;= 0; i--) {
 225                 if (o.equals(get(i))) {
 226                     return i;
 227                 }
 228             }
 229             return -1;
 230         }
 231 
 232         @Override
 233         public int hashCode() {
 234             int hash = 1;
 235             for (int i = 0, s = size(); i &lt; s; i++) {
 236                 hash = 31 * hash + get(i).hashCode();
 237             }
 238             return hash;
 239         }
 240 
 241         @Override
 242         public boolean contains(Object o) {
 243             return indexOf(o) &gt;= 0;
 244         }
 245 
 246         IndexOutOfBoundsException outOfBounds(int index) {
 247             return new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot; Size: &quot; + size());
 248         }
 249     }
 250 
 251     static final class ListItr&lt;E&gt; implements ListIterator&lt;E&gt; {
 252 
 253         @Stable
 254         private final List&lt;E&gt; list;
 255 
 256         @Stable
 257         private final int size;
 258 
 259         @Stable
 260         private final boolean isListIterator;
 261 
 262         private int cursor;
 263 
 264         ListItr(List&lt;E&gt; list, int size) {
 265             this.list = list;
 266             this.size = size;
 267             this.cursor = 0;
 268             isListIterator = false;
 269         }
 270 
 271         ListItr(List&lt;E&gt; list, int size, int index) {
 272             this.list = list;
 273             this.size = size;
 274             this.cursor = index;
 275             isListIterator = true;
 276         }
 277 
 278         public boolean hasNext() {
 279             return cursor != size;
 280         }
 281 
 282         public E next() {
 283             try {
 284                 int i = cursor;
 285                 E next = list.get(i);
 286                 cursor = i + 1;
 287                 return next;
 288             } catch (IndexOutOfBoundsException e) {
 289                 throw new NoSuchElementException();
 290             }
 291         }
 292 
 293         public void remove() {
 294             throw uoe();
 295         }
 296 
 297         public boolean hasPrevious() {
 298             if (!isListIterator) {
 299                 throw uoe();
 300             }
 301             return cursor != 0;
 302         }
 303 
 304         public E previous() {
 305             if (!isListIterator) {
 306                 throw uoe();
 307             }
 308             try {
 309                 int i = cursor - 1;
 310                 E previous = list.get(i);
 311                 cursor = i;
 312                 return previous;
 313             } catch (IndexOutOfBoundsException e) {
 314                 throw new NoSuchElementException();
 315             }
 316         }
 317 
 318         public int nextIndex() {
 319             if (!isListIterator) {
 320                 throw uoe();
 321             }
 322             return cursor;
 323         }
 324 
 325         public int previousIndex() {
 326             if (!isListIterator) {
 327                 throw uoe();
 328             }
 329             return cursor - 1;
 330         }
 331 
 332         public void set(E e) {
 333             throw uoe();
 334         }
 335 
 336         public void add(E e) {
 337             throw uoe();
 338         }
 339     }
 340 
 341     static final class SubList&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 342             implements RandomAccess {
 343 
 344         @Stable
 345         private final List&lt;E&gt; root;
 346 
 347         @Stable
 348         private final int offset;
 349 
 350         @Stable
 351         private final int size;
 352 
 353         private SubList(List&lt;E&gt; root, int offset, int size) {
 354             this.root = root;
 355             this.offset = offset;
 356             this.size = size;
 357         }
 358 
 359         /**
 360          * Constructs a sublist of another SubList.
 361          */
 362         static &lt;E&gt; SubList&lt;E&gt; fromSubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
 363             return new SubList&lt;&gt;(parent.root, parent.offset + fromIndex, toIndex - fromIndex);
 364         }
 365 
 366         /**
 367          * Constructs a sublist of an arbitrary AbstractImmutableList, which is
 368          * not a SubList itself.
 369          */
 370         static &lt;E&gt; SubList&lt;E&gt; fromList(List&lt;E&gt; list, int fromIndex, int toIndex) {
 371             return new SubList&lt;&gt;(list, fromIndex, toIndex - fromIndex);
 372         }
 373 
 374         public E get(int index) {
 375             Objects.checkIndex(index, size);
 376             return root.get(offset + index);
 377         }
 378 
 379         public int size() {
 380             return size;
 381         }
 382 
 383         public Iterator&lt;E&gt; iterator() {
 384             return new ListItr&lt;&gt;(this, size());
 385         }
 386 
 387         public ListIterator&lt;E&gt; listIterator(int index) {
 388             rangeCheck(index);
 389             return new ListItr&lt;&gt;(this, size(), index);
 390         }
 391 
 392         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 393             subListRangeCheck(fromIndex, toIndex, size);
 394             return SubList.fromSubList(this, fromIndex, toIndex);
 395         }
 396 
 397         private void rangeCheck(int index) {
 398             if (index &lt; 0 || index &gt; size) {
 399                 throw outOfBounds(index);
 400             }
 401         }
 402 
 403         @Override
 404         public Object[] toArray() {
 405             Object[] array = new Object[size];
 406             for (int i = 0; i &lt; size; i++) {
 407                 array[i] = get(i);
 408             }
 409             return array;
 410         }
 411 
 412         @Override
 413         @SuppressWarnings(&quot;unchecked&quot;)
 414         public &lt;T&gt; T[] toArray(T[] a) {
 415             T[] array = a.length &gt;= size ? a :
 416                     (T[])java.lang.reflect.Array
 417                             .newInstance(a.getClass().getComponentType(), size);
 418             for (int i = 0; i &lt; size; i++) {
 419                 array[i] = (T)get(i);
 420             }
 421             if (array.length &gt; size) {
 422                 array[size] = null; // null-terminate
 423             }
 424             return array;
 425         }
 426     }
 427 
 428     static final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 429             implements Serializable {
 430 
 431         @Stable
 432         private final E e0;
 433 
 434         @Stable
 435         private final Object e1;
 436 
 437         List12(E e0) {
 438             this.e0 = Objects.requireNonNull(e0);
 439             // Use EMPTY as a sentinel for an unused element: not using null
 440             // enable constant folding optimizations over single-element lists
 441             this.e1 = EMPTY;
 442         }
 443 
 444         List12(E e0, E e1) {
 445             this.e0 = Objects.requireNonNull(e0);
 446             this.e1 = Objects.requireNonNull(e1);
 447         }
 448 
 449         @Override
 450         public int size() {
 451             return e1 != EMPTY ? 2 : 1;
 452         }
 453 
 454         @Override
 455         public boolean isEmpty() {
 456             return false;
 457         }
 458 
 459         @Override
 460         @SuppressWarnings(&quot;unchecked&quot;)
 461         public E get(int index) {
 462             if (index == 0) {
 463                 return e0;
 464             } else if (index == 1 &amp;&amp; e1 != EMPTY) {
 465                 return (E)e1;
 466             }
 467             throw outOfBounds(index);
 468         }
 469 
 470         @java.io.Serial
 471         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 472             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 473         }
 474 
 475         @java.io.Serial
 476         private Object writeReplace() {
 477             if (e1 == EMPTY) {
 478                 return new CollSer(CollSer.IMM_LIST, e0);
 479             } else {
 480                 return new CollSer(CollSer.IMM_LIST, e0, e1);
 481             }
 482         }
 483 
 484         @Override
 485         public Object[] toArray() {
 486             if (e1 == EMPTY) {
 487                 return new Object[] { e0 };
 488             } else {
 489                 return new Object[] { e0, e1 };
 490             }
 491         }
 492 
 493         @Override
 494         @SuppressWarnings(&quot;unchecked&quot;)
 495         public &lt;T&gt; T[] toArray(T[] a) {
 496             int size = size();
 497             T[] array = a.length &gt;= size ? a :
 498                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 499             array[0] = (T)e0;
 500             if (size == 2) {
 501                 array[1] = (T)e1;
 502             }
 503             if (array.length &gt; size) {
 504                 array[size] = null; // null-terminate
 505             }
 506             return array;
 507         }
 508     }
 509 
 510     static final class ListN&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 511             implements Serializable {
 512 
 513         @Stable
 514         private final E[] elements;
 515 
 516         @SafeVarargs
 517         ListN(E... input) {
 518             // copy and check manually to avoid TOCTOU
 519             @SuppressWarnings(&quot;unchecked&quot;)
 520             E[] tmp = (E[])new Object[input.length]; // implicit nullcheck of input
 521             for (int i = 0; i &lt; input.length; i++) {
 522                 tmp[i] = Objects.requireNonNull(input[i]);
 523             }
 524             elements = tmp;
 525         }
 526 
 527         @Override
 528         public boolean isEmpty() {
 529             return elements.length == 0;
 530         }
 531 
 532         @Override
 533         public int size() {
 534             return elements.length;
 535         }
 536 
 537         @Override
 538         public E get(int index) {
 539             return elements[index];
 540         }
 541 
 542         @java.io.Serial
 543         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 544             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 545         }
 546 
 547         @java.io.Serial
 548         private Object writeReplace() {
 549             return new CollSer(CollSer.IMM_LIST, elements);
 550         }
 551 
 552         @Override
 553         public Object[] toArray() {
 554             return Arrays.copyOf(elements, elements.length);
 555         }
 556 
 557         @Override
 558         @SuppressWarnings(&quot;unchecked&quot;)
 559         public &lt;T&gt; T[] toArray(T[] a) {
 560             int size = elements.length;
 561             if (a.length &lt; size) {
 562                 // Make a new array of a&#39;s runtime type, but my contents:
 563                 return (T[]) Arrays.copyOf(elements, size, a.getClass());
 564             }
 565             System.arraycopy(elements, 0, a, 0, size);
 566             if (a.length &gt; size) {
 567                 a[size] = null; // null-terminate
 568             }
 569             return a;
 570         }
 571     }
 572 
 573     // ---------- Set Implementations ----------
 574 
 575     static abstract class AbstractImmutableSet&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;
 576             implements Set&lt;E&gt; {
 577 
 578         @Override
 579         public boolean equals(Object o) {
 580             if (o == this) {
 581                 return true;
 582             } else if (!(o instanceof Set)) {
 583                 return false;
 584             }
 585 
 586             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
 587             if (c.size() != size()) {
 588                 return false;
 589             }
 590             for (Object e : c) {
 591                 if (e == null || !contains(e)) {
 592                     return false;
 593                 }
 594             }
 595             return true;
 596         }
 597 
 598         @Override
 599         public abstract int hashCode();
 600     }
 601 
 602     static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
 603             implements Serializable {
 604 
 605         @Stable
 606         private final E e0;
 607 
 608         @Stable
 609         private final Object e1;
 610 
 611         Set12(E e0) {
 612             this.e0 = Objects.requireNonNull(e0);
 613             // Use EMPTY as a sentinel for an unused element: not using null
 614             // enable constant folding optimizations over single-element sets
 615             this.e1 = EMPTY;
 616         }
 617 
 618         Set12(E e0, E e1) {
 619             if (e0.equals(Objects.requireNonNull(e1))) { // implicit nullcheck of e0
 620                 throw new IllegalArgumentException(&quot;duplicate element: &quot; + e0);
 621             }
 622 
 623             this.e0 = e0;
 624             this.e1 = e1;
 625         }
 626 
 627         @Override
 628         public int size() {
 629             return (e1 == EMPTY) ? 1 : 2;
 630         }
 631 
 632         @Override
 633         public boolean isEmpty() {
 634             return false;
 635         }
 636 
 637         @Override
 638         public boolean contains(Object o) {
 639             return o.equals(e0) || e1.equals(o); // implicit nullcheck of o
 640         }
 641 
 642         @Override
 643         public int hashCode() {
 644             return e0.hashCode() + (e1 == EMPTY ? 0 : e1.hashCode());
 645         }
 646 
 647         @Override
 648         public Iterator&lt;E&gt; iterator() {
 649             return new Iterator&lt;&gt;() {
 650                 private int idx = (e1 == EMPTY) ? 1 : 2;
 651 
 652                 @Override
 653                 public boolean hasNext() {
 654                     return idx &gt; 0;
 655                 }
 656 
 657                 @Override
 658                 @SuppressWarnings(&quot;unchecked&quot;)
 659                 public E next() {
 660                     if (idx == 1) {
 661                         idx = 0;
 662                         return (REVERSE || e1 == EMPTY) ? e0 : (E)e1;
 663                     } else if (idx == 2) {
 664                         idx = 1;
 665                         return REVERSE ? (E)e1 : e0;
 666                     } else {
 667                         throw new NoSuchElementException();
 668                     }
 669                 }
 670             };
 671         }
 672 
 673         @java.io.Serial
 674         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 675             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 676         }
 677 
 678         @java.io.Serial
 679         private Object writeReplace() {
 680             if (e1 == EMPTY) {
 681                 return new CollSer(CollSer.IMM_SET, e0);
 682             } else {
 683                 return new CollSer(CollSer.IMM_SET, e0, e1);
 684             }
 685         }
 686 
 687         @Override
 688         public Object[] toArray() {
 689             if (e1 == EMPTY) {
 690                 return new Object[] { e0 };
 691             } else if (REVERSE) {
 692                 return new Object[] { e1, e0 };
 693             } else {
 694                 return new Object[] { e0, e1 };
 695             }
 696         }
 697 
 698         @Override
 699         @SuppressWarnings(&quot;unchecked&quot;)
 700         public &lt;T&gt; T[] toArray(T[] a) {
 701             int size = size();
 702             T[] array = a.length &gt;= size ? a :
 703                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 704             if (size == 1) {
 705                 array[0] = (T)e0;
 706             } else if (REVERSE) {
 707                 array[0] = (T)e1;
 708                 array[1] = (T)e0;
 709             } else {
 710                 array[0] = (T)e0;
 711                 array[1] = (T)e1;
 712             }
 713             if (array.length &gt; size) {
 714                 array[size] = null; // null-terminate
 715             }
 716             return array;
 717         }
 718     }
 719 
 720 
 721     /**
 722      * An array-based Set implementation. The element array must be strictly
 723      * larger than the size (the number of contained elements) so that at
 724      * least one null is always present.
 725      * @param &lt;E&gt; the element type
 726      */
 727     static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
 728             implements Serializable {
 729 
 730         @Stable
 731         final E[] elements;
 732 
 733         @Stable
 734         final int size;
 735 
 736         @SafeVarargs
 737         @SuppressWarnings(&quot;unchecked&quot;)
 738         SetN(E... input) {
 739             size = input.length; // implicit nullcheck of input
 740 
 741             elements = (E[])new Object[EXPAND_FACTOR * input.length];
 742             for (int i = 0; i &lt; input.length; i++) {
 743                 E e = input[i];
 744                 int idx = probe(e); // implicit nullcheck of e
 745                 if (idx &gt;= 0) {
 746                     throw new IllegalArgumentException(&quot;duplicate element: &quot; + e);
 747                 } else {
 748                     elements[-(idx + 1)] = e;
 749                 }
 750             }
 751         }
 752 
 753         @Override
 754         public int size() {
 755             return size;
 756         }
 757 
 758         @Override
 759         public boolean isEmpty() {
 760             return size == 0;
 761         }
 762 
 763         @Override
 764         public boolean contains(Object o) {
 765             Objects.requireNonNull(o);
 766             return size &gt; 0 &amp;&amp; probe(o) &gt;= 0;
 767         }
 768 
 769         private final class SetNIterator implements Iterator&lt;E&gt; {
 770 
 771             private int remaining;
 772 
 773             private int idx;
 774 
 775             SetNIterator() {
 776                 remaining = size;
 777                 // pick a starting index in the [0 .. element.length-1] range
 778                 // randomly based on SALT32L
 779                 idx = (int) ((SALT32L * elements.length) &gt;&gt;&gt; 32);
 780             }
 781 
 782             @Override
 783             public boolean hasNext() {
 784                 return remaining &gt; 0;
 785             }
 786 
 787             @Override
 788             public E next() {
 789                 if (remaining &gt; 0) {
 790                     E element;
 791                     int idx = this.idx;
 792                     int len = elements.length;
 793                     // step to the next element; skip null elements
 794                     do {
 795                         if (REVERSE) {
 796                             if (++idx &gt;= len) {
 797                                 idx = 0;
 798                             }
 799                         } else {
 800                             if (--idx &lt; 0) {
 801                                 idx = len - 1;
 802                             }
 803                         }
 804                     } while ((element = elements[idx]) == null);
 805                     this.idx = idx;
 806                     remaining--;
 807                     return element;
 808                 } else {
 809                     throw new NoSuchElementException();
 810                 }
 811             }
 812         }
 813 
 814         @Override
 815         public Iterator&lt;E&gt; iterator() {
 816             return new SetNIterator();
 817         }
 818 
 819         @Override
 820         public int hashCode() {
 821             int h = 0;
 822             for (E e : elements) {
 823                 if (e != null) {
 824                     h += e.hashCode();
 825                 }
 826             }
 827             return h;
 828         }
 829 
 830         // returns index at which element is present; or if absent,
 831         // (-i - 1) where i is location where element should be inserted.
 832         // Callers are relying on this method to perform an implicit nullcheck
 833         // of pe
 834         private int probe(Object pe) {
 835             int idx = Math.floorMod(pe.hashCode(), elements.length);
 836             while (true) {
 837                 E ee = elements[idx];
 838                 if (ee == null) {
 839                     return -idx - 1;
 840                 } else if (pe.equals(ee)) {
 841                     return idx;
 842                 } else if (++idx == elements.length) {
 843                     idx = 0;
 844                 }
 845             }
 846         }
 847 
 848         @java.io.Serial
 849         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 850             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 851         }
 852 
 853         @java.io.Serial
 854         private Object writeReplace() {
 855             Object[] array = new Object[size];
 856             int dest = 0;
 857             for (Object o : elements) {
 858                 if (o != null) {
 859                     array[dest++] = o;
 860                 }
 861             }
 862             return new CollSer(CollSer.IMM_SET, array);
 863         }
 864 
 865         @Override
 866         public Object[] toArray() {
 867             Object[] array = new Object[size];
 868             Iterator&lt;E&gt; it = iterator();
 869             for (int i = 0; i &lt; size; i++) {
 870                 array[i] = it.next();
 871             }
 872             return array;
 873         }
 874 
 875         @Override
 876         @SuppressWarnings(&quot;unchecked&quot;)
 877         public &lt;T&gt; T[] toArray(T[] a) {
 878             T[] array = a.length &gt;= size ? a :
 879                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 880             Iterator&lt;E&gt; it = iterator();
 881             for (int i = 0; i &lt; size; i++) {
 882                 array[i] = (T)it.next();
 883             }
 884             if (array.length &gt; size) {
 885                 array[size] = null; // null-terminate
 886             }
 887             return array;
 888         }
 889     }
 890 
 891     // ---------- Map Implementations ----------
 892 
 893     abstract static class AbstractImmutableMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Serializable {
 894         @Override public void clear() { throw uoe(); }
 895         @Override public V compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
 896         @Override public V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mf) { throw uoe(); }
 897         @Override public V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
 898         @Override public V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; rf) { throw uoe(); }
 899         @Override public V put(K key, V value) { throw uoe(); }
 900         @Override public void putAll(Map&lt;? extends K,? extends V&gt; m) { throw uoe(); }
 901         @Override public V putIfAbsent(K key, V value) { throw uoe(); }
 902         @Override public V remove(Object key) { throw uoe(); }
 903         @Override public boolean remove(Object key, Object value) { throw uoe(); }
 904         @Override public V replace(K key, V value) { throw uoe(); }
 905         @Override public boolean replace(K key, V oldValue, V newValue) { throw uoe(); }
 906         @Override public void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; f) { throw uoe(); }
 907 
 908         /**
 909          * @implNote {@code null} values are disallowed in these immutable maps,
 910          * so we can improve upon the default implementation since a
 911          * {@code null} return from {@code get(key)} always means the default
 912          * value should be returned.
 913          */
 914         @Override
 915         public V getOrDefault(Object key, V defaultValue) {
 916             V v;
 917             return ((v = get(key)) != null)
 918                     ? v
 919                     : defaultValue;
 920         }
 921     }
 922 
 923     static final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
 924         @Stable
 925         private final K k0;
 926         @Stable
 927         private final V v0;
 928 
 929         Map1(K k0, V v0) {
 930             this.k0 = Objects.requireNonNull(k0);
 931             this.v0 = Objects.requireNonNull(v0);
 932         }
 933 
 934         @Override
 935         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
 936             return Set.of(new KeyValueHolder&lt;&gt;(k0, v0));
 937         }
 938 
 939         @Override
 940         public V get(Object o) {
 941             return o.equals(k0) ? v0 : null; // implicit nullcheck of o
 942         }
 943 
 944         @Override
 945         public boolean containsKey(Object o) {
 946             return o.equals(k0); // implicit nullcheck of o
 947         }
 948 
 949         @Override
 950         public boolean containsValue(Object o) {
 951             return o.equals(v0); // implicit nullcheck of o
 952         }
 953 
 954         @Override
 955         public int size() {
 956             return 1;
 957         }
 958 
 959         @Override
 960         public boolean isEmpty() {
 961             return false;
 962         }
 963 
 964         @java.io.Serial
 965         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 966             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 967         }
 968 
 969         @java.io.Serial
 970         private Object writeReplace() {
 971             return new CollSer(CollSer.IMM_MAP, k0, v0);
 972         }
 973 
 974         @Override
 975         public int hashCode() {
 976             return k0.hashCode() ^ v0.hashCode();
 977         }
 978     }
 979 
 980     /**
 981      * An array-based Map implementation. There is a single array &quot;table&quot; that
 982      * contains keys and values interleaved: table[0] is kA, table[1] is vA,
 983      * table[2] is kB, table[3] is vB, etc. The table size must be even. It must
 984      * also be strictly larger than the size (the number of key-value pairs contained
 985      * in the map) so that at least one null key is always present.
 986      * @param &lt;K&gt; the key type
 987      * @param &lt;V&gt; the value type
 988      */
 989     static final class MapN&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
 990 
 991         @Stable
 992         final Object[] table; // pairs of key, value
 993 
 994         @Stable
 995         final int size; // number of pairs
 996 
 997         MapN(Object... input) {
 998             if ((input.length &amp; 1) != 0) { // implicit nullcheck of input
 999                 throw new InternalError(&quot;length is odd&quot;);
1000             }
1001             size = input.length &gt;&gt; 1;
1002 
1003             int len = EXPAND_FACTOR * input.length;
1004             len = (len + 1) &amp; ~1; // ensure table is even length
1005             table = new Object[len];
1006 
1007             for (int i = 0; i &lt; input.length; i += 2) {
1008                 @SuppressWarnings(&quot;unchecked&quot;)
1009                     K k = Objects.requireNonNull((K)input[i]);
1010                 @SuppressWarnings(&quot;unchecked&quot;)
1011                     V v = Objects.requireNonNull((V)input[i+1]);
1012                 int idx = probe(k);
1013                 if (idx &gt;= 0) {
1014                     throw new IllegalArgumentException(&quot;duplicate key: &quot; + k);
1015                 } else {
1016                     int dest = -(idx + 1);
1017                     table[dest] = k;
1018                     table[dest+1] = v;
1019                 }
1020             }
1021         }
1022 
1023         @Override
1024         public boolean containsKey(Object o) {
1025             Objects.requireNonNull(o);
1026             return size &gt; 0 &amp;&amp; probe(o) &gt;= 0;
1027         }
1028 
1029         @Override
1030         public boolean containsValue(Object o) {
1031             Objects.requireNonNull(o);
1032             for (int i = 1; i &lt; table.length; i += 2) {
1033                 Object v = table[i];
1034                 if (v != null &amp;&amp; o.equals(v)) {
1035                     return true;
1036                 }
1037             }
1038             return false;
1039         }
1040 
1041         @Override
1042         public int hashCode() {
1043             int hash = 0;
1044             for (int i = 0; i &lt; table.length; i += 2) {
1045                 Object k = table[i];
1046                 if (k != null) {
1047                     hash += k.hashCode() ^ table[i + 1].hashCode();
1048                 }
1049             }
1050             return hash;
1051         }
1052 
1053         @Override
1054         @SuppressWarnings(&quot;unchecked&quot;)
1055         public V get(Object o) {
1056             if (size == 0) {
1057                 Objects.requireNonNull(o);
1058                 return null;
1059             }
1060             int i = probe(o);
1061             if (i &gt;= 0) {
1062                 return (V)table[i+1];
1063             } else {
1064                 return null;
1065             }
1066         }
1067 
1068         @Override
1069         public int size() {
1070             return size;
1071         }
1072 
1073         @Override
1074         public boolean isEmpty() {
1075             return size == 0;
1076         }
1077 
1078         class MapNIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1079 
1080             private int remaining;
1081 
1082             private int idx;
1083 
1084             MapNIterator() {
1085                 remaining = size;
1086                 // pick an even starting index in the [0 .. table.length-1]
1087                 // range randomly based on SALT32L
1088                 idx = (int) ((SALT32L * (table.length &gt;&gt; 1)) &gt;&gt;&gt; 32) &lt;&lt; 1;
1089             }
1090 
1091             @Override
1092             public boolean hasNext() {
1093                 return remaining &gt; 0;
1094             }
1095 
1096             private int nextIndex() {
1097                 int idx = this.idx;
1098                 if (REVERSE) {
1099                     if ((idx += 2) &gt;= table.length) {
1100                         idx = 0;
1101                     }
1102                 } else {
1103                     if ((idx -= 2) &lt; 0) {
1104                         idx = table.length - 2;
1105                     }
1106                 }
1107                 return this.idx = idx;
1108             }
1109 
1110             @Override
1111             public Map.Entry&lt;K,V&gt; next() {
1112                 if (remaining &gt; 0) {
1113                     int idx;
1114                     while (table[idx = nextIndex()] == null) {}
1115                     @SuppressWarnings(&quot;unchecked&quot;)
1116                     Map.Entry&lt;K,V&gt; e =
1117                             new KeyValueHolder&lt;&gt;((K)table[idx], (V)table[idx+1]);
1118                     remaining--;
1119                     return e;
1120                 } else {
1121                     throw new NoSuchElementException();
1122                 }
1123             }
1124         }
1125 
1126         @Override
1127         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1128             return new AbstractSet&lt;&gt;() {
1129                 @Override
1130                 public int size() {
1131                     return MapN.this.size;
1132                 }
1133 
1134                 @Override
1135                 public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
1136                     return new MapNIterator();
1137                 }
1138             };
1139         }
1140 
1141         // returns index at which the probe key is present; or if absent,
1142         // (-i - 1) where i is location where element should be inserted.
1143         // Callers are relying on this method to perform an implicit nullcheck
1144         // of pk.
1145         private int probe(Object pk) {
1146             int idx = Math.floorMod(pk.hashCode(), table.length &gt;&gt; 1) &lt;&lt; 1;
1147             while (true) {
1148                 @SuppressWarnings(&quot;unchecked&quot;)
1149                 K ek = (K)table[idx];
1150                 if (ek == null) {
1151                     return -idx - 1;
1152                 } else if (pk.equals(ek)) {
1153                     return idx;
1154                 } else if ((idx += 2) == table.length) {
1155                     idx = 0;
1156                 }
1157             }
1158         }
1159 
1160         @java.io.Serial
1161         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1162             throw new InvalidObjectException(&quot;not serial proxy&quot;);
1163         }
1164 
1165         @java.io.Serial
1166         private Object writeReplace() {
1167             Object[] array = new Object[2 * size];
1168             int len = table.length;
1169             int dest = 0;
1170             for (int i = 0; i &lt; len; i += 2) {
1171                 if (table[i] != null) {
1172                     array[dest++] = table[i];
1173                     array[dest++] = table[i+1];
1174                 }
1175             }
1176             return new CollSer(CollSer.IMM_MAP, array);
1177         }
1178     }
1179 }
1180 
1181 // ---------- Serialization Proxy ----------
1182 
1183 /**
1184  * A unified serialization proxy class for the immutable collections.
1185  *
1186  * @serial
1187  * @since 9
1188  */
1189 final class CollSer implements Serializable {
1190     @java.io.Serial
1191     private static final long serialVersionUID = 6309168927139932177L;
1192 
1193     static final int IMM_LIST = 1;
1194     static final int IMM_SET = 2;
1195     static final int IMM_MAP = 3;
1196 
1197     /**
1198      * Indicates the type of collection that is serialized.
1199      * The low order 8 bits have the value 1 for an immutable
1200      * {@code List}, 2 for an immutable {@code Set}, and 3 for
1201      * an immutable {@code Map}. Any other value causes an
1202      * {@link InvalidObjectException} to be thrown. The high
1203      * order 24 bits are zero when an instance is serialized,
1204      * and they are ignored when an instance is deserialized.
1205      * They can thus be used by future implementations without
1206      * causing compatibility issues.
1207      *
1208      * &lt;p&gt;The tag value also determines the interpretation of the
1209      * transient {@code Object[] array} field.
1210      * For {@code List} and {@code Set}, the array&#39;s length is the size
1211      * of the collection, and the array contains the elements of the collection.
1212      * Null elements are not allowed. For {@code Set}, duplicate elements
1213      * are not allowed.
1214      *
1215      * &lt;p&gt;For {@code Map}, the array&#39;s length is twice the number of mappings
1216      * present in the map. The array length is necessarily even.
1217      * The array contains a succession of key and value pairs:
1218      * {@code k1, v1, k2, v2, ..., kN, vN.} Nulls are not allowed,
1219      * and duplicate keys are not allowed.
1220      *
1221      * @serial
1222      * @since 9
1223      */
1224     private final int tag;
1225 
1226     /**
1227      * @serial
1228      * @since 9
1229      */
1230     private transient Object[] array;
1231 
1232     CollSer(int t, Object... a) {
1233         tag = t;
1234         array = a;
1235     }
1236 
1237     /**
1238      * Reads objects from the stream and stores them
1239      * in the transient {@code Object[] array} field.
1240      *
1241      * @serialData
1242      * A nonnegative int, indicating the count of objects,
1243      * followed by that many objects.
1244      *
1245      * @param ois the ObjectInputStream from which data is read
1246      * @throws IOException if an I/O error occurs
1247      * @throws ClassNotFoundException if a serialized class cannot be loaded
1248      * @throws InvalidObjectException if the count is negative
1249      * @since 9
1250      */
1251     @java.io.Serial
1252     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
1253         ois.defaultReadObject();
1254         int len = ois.readInt();
1255 
1256         if (len &lt; 0) {
1257             throw new InvalidObjectException(&quot;negative length &quot; + len);
1258         }
1259 
1260         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, len);
1261         Object[] a = new Object[len];
1262         for (int i = 0; i &lt; len; i++) {
1263             a[i] = ois.readObject();
1264         }
1265 
1266         array = a;
1267     }
1268 
1269     /**
1270      * Writes objects to the stream from
1271      * the transient {@code Object[] array} field.
1272      *
1273      * @serialData
1274      * A nonnegative int, indicating the count of objects,
1275      * followed by that many objects.
1276      *
1277      * @param oos the ObjectOutputStream to which data is written
1278      * @throws IOException if an I/O error occurs
1279      * @since 9
1280      */
1281     @java.io.Serial
1282     private void writeObject(ObjectOutputStream oos) throws IOException {
1283         oos.defaultWriteObject();
1284         oos.writeInt(array.length);
1285         for (int i = 0; i &lt; array.length; i++) {
1286             oos.writeObject(array[i]);
1287         }
1288     }
1289 
1290     /**
1291      * Creates and returns an immutable collection from this proxy class.
1292      * The instance returned is created as if by calling one of the
1293      * static factory methods for
1294      * &lt;a href=&quot;List.html#unmodifiable&quot;&gt;List&lt;/a&gt;,
1295      * &lt;a href=&quot;Map.html#unmodifiable&quot;&gt;Map&lt;/a&gt;, or
1296      * &lt;a href=&quot;Set.html#unmodifiable&quot;&gt;Set&lt;/a&gt;.
1297      * This proxy class is the serial form for all immutable collection instances,
1298      * regardless of implementation type. This is necessary to ensure that the
1299      * existence of any particular implementation type is kept out of the
1300      * serialized form.
1301      *
1302      * @return a collection created from this proxy object
1303      * @throws InvalidObjectException if the tag value is illegal or if an exception
1304      *         is thrown during creation of the collection
1305      * @throws ObjectStreamException if another serialization error has occurred
1306      * @since 9
1307      */
1308    @java.io.Serial
1309     private Object readResolve() throws ObjectStreamException {
1310         try {
1311             if (array == null) {
1312                 throw new InvalidObjectException(&quot;null array&quot;);
1313             }
1314 
1315             // use low order 8 bits to indicate &quot;kind&quot;
1316             // ignore high order 24 bits
1317             switch (tag &amp; 0xff) {
1318                 case IMM_LIST:
1319                     return List.of(array);
1320                 case IMM_SET:
1321                     return Set.of(array);
1322                 case IMM_MAP:
1323                     if (array.length == 0) {
1324                         return ImmutableCollections.EMPTY_MAP;
1325                     } else if (array.length == 2) {
1326                         return new ImmutableCollections.Map1&lt;&gt;(array[0], array[1]);
1327                     } else {
1328                         return new ImmutableCollections.MapN&lt;&gt;(array);
1329                     }
1330                 default:
1331                     throw new InvalidObjectException(String.format(&quot;invalid flags 0x%x&quot;, tag));
1332             }
1333         } catch (NullPointerException|IllegalArgumentException ex) {
1334             InvalidObjectException ioe = new InvalidObjectException(&quot;invalid object&quot;);
1335             ioe.initCause(ex);
1336             throw ioe;
1337         }
1338     }
1339 }
    </pre>
  </body>
</html>
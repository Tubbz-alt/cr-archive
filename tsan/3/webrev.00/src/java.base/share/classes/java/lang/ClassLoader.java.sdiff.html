<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/ClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassFormatError.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassNotFoundException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.io.InputStream;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.io.File;
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.InvocationTargetException;
  34 import java.net.URL;
  35 import java.security.AccessController;
  36 import java.security.AccessControlContext;
  37 import java.security.CodeSource;
  38 import java.security.PrivilegedAction;
  39 import java.security.ProtectionDomain;
  40 import java.security.cert.Certificate;
  41 import java.util.ArrayDeque;

  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.HashSet;
<span class="line-removed">  48 import java.util.Hashtable;</span>
  49 import java.util.Map;
  50 import java.util.NoSuchElementException;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.Spliterator;
  54 import java.util.Spliterators;
<span class="line-removed">  55 import java.util.Vector;</span>
  56 import java.util.WeakHashMap;
  57 import java.util.concurrent.ConcurrentHashMap;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Stream;
  60 import java.util.stream.StreamSupport;
  61 
  62 import jdk.internal.loader.BuiltinClassLoader;
  63 import jdk.internal.perf.PerfCounter;
  64 import jdk.internal.loader.BootLoader;
  65 import jdk.internal.loader.ClassLoaders;
  66 import jdk.internal.misc.Unsafe;
  67 import jdk.internal.misc.VM;
  68 import jdk.internal.ref.CleanerFactory;
  69 import jdk.internal.reflect.CallerSensitive;
  70 import jdk.internal.reflect.Reflection;

  71 import sun.reflect.misc.ReflectUtil;
  72 import sun.security.util.SecurityConstants;
  73 
  74 /**
  75  * A class loader is an object that is responsible for loading classes. The
  76  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  77  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  78  * locate or generate data that constitutes a definition for the class.  A
  79  * typical strategy is to transform the name into a file name and then read a
  80  * &quot;class file&quot; of that name from a file system.
  81  *
  82  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  83  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  84  * it.
  85  *
  86  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  87  * loaders, but are created automatically as required by the Java runtime.
  88  * The class loader for an array class, as returned by {@link
  89  * Class#getClassLoader()} is the same as the class loader for its element
  90  * type; if the element type is a primitive type, then the array class has no
</pre>
<hr />
<pre>
 109  * classes and resources.  Each instance of {@code ClassLoader} has an
 110  * associated parent class loader. When requested to find a class or
 111  * resource, a {@code ClassLoader} instance will usually delegate the search
 112  * for the class or resource to its parent class loader before attempting to
 113  * find the class or resource itself.
 114  *
 115  * &lt;p&gt; Class loaders that support concurrent loading of classes are known as
 116  * &lt;em&gt;{@linkplain #isRegisteredAsParallelCapable() parallel capable}&lt;/em&gt; class
 117  * loaders and are required to register themselves at their class initialization
 118  * time by invoking the {@link
 119  * #registerAsParallelCapable ClassLoader.registerAsParallelCapable}
 120  * method. Note that the {@code ClassLoader} class is registered as parallel
 121  * capable by default. However, its subclasses still need to register themselves
 122  * if they are parallel capable.
 123  * In environments in which the delegation model is not strictly
 124  * hierarchical, class loaders need to be parallel capable, otherwise class
 125  * loading can lead to deadlocks because the loader lock is held for the
 126  * duration of the class loading process (see {@link #loadClass
 127  * loadClass} methods).
 128  *
<span class="line-modified"> 129  * &lt;h3&gt; &lt;a id=&quot;builtinLoaders&quot;&gt;Run-time Built-in Class Loaders&lt;/a&gt;&lt;/h3&gt;</span>
 130  *
 131  * The Java run-time has the following built-in class loaders:
 132  *
 133  * &lt;ul&gt;
 134  * &lt;li&gt;&lt;p&gt;Bootstrap class loader.
 135  *     It is the virtual machine&#39;s built-in class loader, typically represented
 136  *     as {@code null}, and does not have a parent.&lt;/li&gt;
 137  * &lt;li&gt;&lt;p&gt;{@linkplain #getPlatformClassLoader() Platform class loader}.
 138  *     All &lt;em&gt;platform classes&lt;/em&gt; are visible to the platform class loader
 139  *     that can be used as the parent of a {@code ClassLoader} instance.
 140  *     Platform classes include Java SE platform APIs, their implementation
 141  *     classes and JDK-specific run-time classes that are defined by the
 142  *     platform class loader or its ancestors.
 143  *     &lt;p&gt; To allow for upgrading/overriding of modules defined to the platform
 144  *     class loader, and where upgraded modules read modules defined to class
 145  *     loaders other than the platform class loader and its ancestors, then
 146  *     the platform class loader may have to delegate to other class loaders,
 147  *     the application class loader for example.
 148  *     In other words, classes in named modules defined to class loaders
 149  *     other than the platform class loader and its ancestors may be visible
</pre>
<hr />
<pre>
 205  *
 206  * &lt;h3&gt; &lt;a id=&quot;binary-name&quot;&gt;Binary names&lt;/a&gt; &lt;/h3&gt;
 207  *
 208  * &lt;p&gt; Any class name provided as a {@code String} parameter to methods in
 209  * {@code ClassLoader} must be a binary name as defined by
 210  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 211  *
 212  * &lt;p&gt; Examples of valid class names include:
 213  * &lt;blockquote&gt;&lt;pre&gt;
 214  *   &quot;java.lang.String&quot;
 215  *   &quot;javax.swing.JSpinner$DefaultEditor&quot;
 216  *   &quot;java.security.KeyStore$Builder$FileBuilder$1&quot;
 217  *   &quot;java.net.URLClassLoader$3$1&quot;
 218  * &lt;/pre&gt;&lt;/blockquote&gt;
 219  *
 220  * &lt;p&gt; Any package name provided as a {@code String} parameter to methods in
 221  * {@code ClassLoader} must be either the empty string (denoting an unnamed package)
 222  * or a fully qualified name as defined by
 223  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 224  *
<span class="line-modified"> 225  * @jls 6.7  Fully Qualified Names</span>
 226  * @jls 13.1 The Form of a Binary
 227  * @see      #resolveClass(Class)
 228  * @since 1.0
 229  * @revised 9
 230  * @spec JPMS
 231  */
 232 public abstract class ClassLoader {
 233 
 234     private static native void registerNatives();
 235     static {
 236         registerNatives();
 237     }
 238 
 239     // The parent class loader for delegation
 240     // Note: VM hardcoded the offset of this field, thus all new fields
 241     // must be added *after* it.
 242     private final ClassLoader parent;
 243 
 244     // class loader name
 245     private final String name;
</pre>
<hr />
<pre>
 285         }
 286 
 287         /**
 288          * Returns {@code true} if the given class loader type is
 289          * registered as parallel capable.
 290          */
 291         static boolean isRegistered(Class&lt;? extends ClassLoader&gt; c) {
 292             synchronized (loaderTypes) {
 293                 return loaderTypes.contains(c);
 294             }
 295         }
 296     }
 297 
 298     // Maps class name to the corresponding lock object when the current
 299     // class loader is parallel capable.
 300     // Note: VM also uses this field to decide if the current class loader
 301     // is parallel capable and the appropriate lock object for class loading.
 302     private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;
 303 
 304     // Maps packages to certs
<span class="line-modified"> 305     private final Map &lt;String, Certificate[]&gt; package2certs;</span>
 306 
 307     // Shared among all packages with unsigned classes
 308     private static final Certificate[] nocerts = new Certificate[0];
 309 
 310     // The classes loaded by this class loader. The only purpose of this table
 311     // is to keep the classes from being GC&#39;ed until the loader is GC&#39;ed.
<span class="line-modified"> 312     private final Vector&lt;Class&lt;?&gt;&gt; classes = new Vector&lt;&gt;();</span>
 313 
 314     // The &quot;default&quot; domain. Set as the default ProtectionDomain on newly
 315     // created classes.
 316     private final ProtectionDomain defaultDomain =
 317         new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
 318                              null, this, null);
 319 
 320     // Invoked by the VM to record every loaded class with this loader.
 321     void addClass(Class&lt;?&gt; c) {
<span class="line-modified"> 322         classes.addElement(c);</span>


 323     }
 324 
 325     // The packages defined in this class loader.  Each package name is
 326     // mapped to its corresponding NamedPackage object.
 327     //
 328     // The value is a Package object if ClassLoader::definePackage,
 329     // Class::getPackage, ClassLoader::getDefinePackage(s) or
 330     // Package::getPackage(s) method is called to define it.
 331     // Otherwise, the value is a NamedPackage object.
 332     private final ConcurrentHashMap&lt;String, NamedPackage&gt; packages
 333             = new ConcurrentHashMap&lt;&gt;();
 334 
 335     /*
 336      * Returns a named package for the given module.
 337      */
 338     private NamedPackage getNamedPackage(String pn, Module m) {
 339         NamedPackage p = packages.get(pn);
 340         if (p == null) {
 341             p = new NamedPackage(pn, m);
 342 
</pre>
<hr />
<pre>
 360     }
 361 
 362     private static Void checkCreateClassLoader(String name) {
 363         if (name != null &amp;&amp; name.isEmpty()) {
 364             throw new IllegalArgumentException(&quot;name must be non-empty or null&quot;);
 365         }
 366 
 367         SecurityManager security = System.getSecurityManager();
 368         if (security != null) {
 369             security.checkCreateClassLoader();
 370         }
 371         return null;
 372     }
 373 
 374     private ClassLoader(Void unused, String name, ClassLoader parent) {
 375         this.name = name;
 376         this.parent = parent;
 377         this.unnamedModule = new Module(this);
 378         if (ParallelLoaders.isRegistered(this.getClass())) {
 379             parallelLockMap = new ConcurrentHashMap&lt;&gt;();
<span class="line-removed"> 380             package2certs = new ConcurrentHashMap&lt;&gt;();</span>
 381             assertionLock = new Object();
 382         } else {
 383             // no finer-grained lock; lock on the classloader instance
 384             parallelLockMap = null;
<span class="line-removed"> 385             package2certs = new Hashtable&lt;&gt;();</span>
 386             assertionLock = this;
 387         }

 388         this.nameAndId = nameAndId(this);
 389     }
 390 
 391     /**
 392      * If the defining loader has a name explicitly set then
 393      *       &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
 394      * If the defining loader has no name then
 395      *       &lt;qualified-class-name&gt; @&lt;id&gt;
 396      * If it&#39;s built-in loader then omit `@&lt;id&gt;` as there is only one instance.
 397      */
 398     private static String nameAndId(ClassLoader ld) {
 399         String nid = ld.getName() != null ? &quot;\&#39;&quot; + ld.getName() + &quot;\&#39;&quot;
 400                                           : ld.getClass().getName();
 401         if (!(ld instanceof BuiltinClassLoader)) {
 402             String id = Integer.toHexString(System.identityHashCode(ld));
 403             nid = nid + &quot; @&quot; + id;
 404         }
 405         return nid;
 406     }
 407 
</pre>
<hr />
<pre>
 428      */
 429     protected ClassLoader(String name, ClassLoader parent) {
 430         this(checkCreateClassLoader(name), name, parent);
 431     }
 432 
 433     /**
 434      * Creates a new class loader using the specified parent class loader for
 435      * delegation.
 436      *
 437      * &lt;p&gt; If there is a security manager, its {@link
 438      * SecurityManager#checkCreateClassLoader() checkCreateClassLoader} method
 439      * is invoked.  This may result in a security exception.  &lt;/p&gt;
 440      *
 441      * @apiNote If the parent is specified as {@code null} (for the
 442      * bootstrap class loader) then there is no guarantee that all platform
 443      * classes are visible.
 444      *
 445      * @param  parent
 446      *         The parent class loader
 447      *
<span class="line-modified"> 448      * @throws  SecurityException</span>
<span class="line-modified"> 449      *          If a security manager exists and its</span>
<span class="line-modified"> 450      *          {@code checkCreateClassLoader} method doesn&#39;t allow creation</span>
<span class="line-modified"> 451      *          of a new class loader.</span>
 452      *
 453      * @since  1.2
 454      */
 455     protected ClassLoader(ClassLoader parent) {
 456         this(checkCreateClassLoader(), null, parent);
 457     }
 458 
 459     /**
 460      * Creates a new class loader using the {@code ClassLoader} returned by
 461      * the method {@link #getSystemClassLoader()
 462      * getSystemClassLoader()} as the parent class loader.
 463      *
 464      * &lt;p&gt; If there is a security manager, its {@link
 465      * SecurityManager#checkCreateClassLoader()
 466      * checkCreateClassLoader} method is invoked.  This may result in
 467      * a security exception.  &lt;/p&gt;
 468      *
 469      * @throws  SecurityException
 470      *          If a security manager exists and its
 471      *          {@code checkCreateClassLoader} method doesn&#39;t allow creation
</pre>
<hr />
<pre>
 492     public String getName() {
 493         return name;
 494     }
 495 
 496     // package-private used by StackTraceElement to avoid
 497     // calling the overrideable getName method
 498     final String name() {
 499         return name;
 500     }
 501 
 502     // -- Class --
 503 
 504     /**
 505      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.
 506      * This method searches for classes in the same manner as the {@link
 507      * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
 508      * machine to resolve class references.  Invoking this method is equivalent
 509      * to invoking {@link #loadClass(String, boolean) loadClass(name,
 510      * false)}.
 511      *
<span class="line-modified"> 512      * @param  name</span>
<span class="line-modified"> 513      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
 514      *
 515      * @return  The resulting {@code Class} object
 516      *
 517      * @throws  ClassNotFoundException
 518      *          If the class was not found
 519      */
 520     public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
 521         return loadClass(name, false);
 522     }
 523 
 524     /**
 525      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The
 526      * default implementation of this method searches for classes in the
 527      * following order:
 528      *
 529      * &lt;ol&gt;
 530      *
 531      *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
 532      *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
 533      *
 534      *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) loadClass} method
 535      *   on the parent class loader.  If the parent is {@code null} the class
 536      *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
 537      *
 538      *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
 539      *   class.  &lt;/p&gt;&lt;/li&gt;
 540      *
 541      * &lt;/ol&gt;
 542      *
 543      * &lt;p&gt; If the class was found using the above steps, and the
 544      * {@code resolve} flag is true, this method will then invoke the {@link
 545      * #resolveClass(Class)} method on the resulting {@code Class} object.
 546      *
 547      * &lt;p&gt; Subclasses of {@code ClassLoader} are encouraged to override {@link
 548      * #findClass(String)}, rather than this method.  &lt;/p&gt;
 549      *
 550      * &lt;p&gt; Unless overridden, this method synchronizes on the result of
 551      * {@link #getClassLoadingLock getClassLoadingLock} method
 552      * during the entire class loading process.
 553      *
<span class="line-modified"> 554      * @param  name</span>
<span class="line-modified"> 555      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
 556      *
<span class="line-modified"> 557      * @param  resolve</span>
<span class="line-modified"> 558      *         If {@code true} then resolve the class</span>
 559      *
 560      * @return  The resulting {@code Class} object
 561      *
 562      * @throws  ClassNotFoundException
 563      *          If the class could not be found
 564      */
 565     protected Class&lt;?&gt; loadClass(String name, boolean resolve)
 566         throws ClassNotFoundException
 567     {
 568         synchronized (getClassLoadingLock(name)) {
 569             // First, check if the class has already been loaded
 570             Class&lt;?&gt; c = findLoadedClass(name);
 571             if (c == null) {
 572                 long t0 = System.nanoTime();
 573                 try {
 574                     if (parent != null) {
 575                         c = parent.loadClass(name, false);
 576                     } else {
 577                         c = findBootstrapClassOrNull(name);
 578                     }
</pre>
<hr />
<pre>
 687             if (!packageName.isEmpty()) {
 688                 AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 689                     public Void run() {
 690                         sm.checkPackageAccess(packageName);
 691                         return null;
 692                     }
 693                 }, new AccessControlContext(new ProtectionDomain[] {pd}));
 694             }
 695         }
 696     }
 697 
 698     /**
 699      * Finds the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.
 700      * This method should be overridden by class loader implementations that
 701      * follow the delegation model for loading classes, and will be invoked by
 702      * the {@link #loadClass loadClass} method after checking the
 703      * parent class loader for the requested class.
 704      *
 705      * @implSpec The default implementation throws {@code ClassNotFoundException}.
 706      *
<span class="line-modified"> 707      * @param  name</span>
<span class="line-modified"> 708      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
 709      *
 710      * @return  The resulting {@code Class} object
 711      *
 712      * @throws  ClassNotFoundException
 713      *          If the class could not be found
 714      *
 715      * @since  1.2
 716      */
 717     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
 718         throw new ClassNotFoundException(name);
 719     }
 720 
 721     /**
 722      * Finds the class with the given &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;
 723      * in a module defined to this class loader.
 724      * Class loader implementations that support loading from modules
 725      * should override this method.
 726      *
 727      * @apiNote This method returns {@code null} rather than throwing
 728      *          {@code ClassNotFoundException} if the class could not be found.
</pre>
<hr />
<pre>
1117                                         int off, int len, ProtectionDomain pd,
1118                                         String source);
1119 
1120     // true if the name is null or has the potential to be a valid binary name
1121     private boolean checkName(String name) {
1122         if ((name == null) || (name.isEmpty()))
1123             return true;
1124         if ((name.indexOf(&#39;/&#39;) != -1) || (name.charAt(0) == &#39;[&#39;))
1125             return false;
1126         return true;
1127     }
1128 
1129     private void checkCerts(String name, CodeSource cs) {
1130         int i = name.lastIndexOf(&#39;.&#39;);
1131         String pname = (i == -1) ? &quot;&quot; : name.substring(0, i);
1132 
1133         Certificate[] certs = null;
1134         if (cs != null) {
1135             certs = cs.getCertificates();
1136         }
<span class="line-modified">1137         Certificate[] pcerts = null;</span>
<span class="line-modified">1138         if (parallelLockMap == null) {</span>
<span class="line-removed">1139             synchronized (this) {</span>
<span class="line-removed">1140                 pcerts = package2certs.get(pname);</span>
<span class="line-removed">1141                 if (pcerts == null) {</span>
<span class="line-removed">1142                     package2certs.put(pname, (certs == null? nocerts:certs));</span>
<span class="line-removed">1143                 }</span>
<span class="line-removed">1144             }</span>
<span class="line-removed">1145         } else {</span>
<span class="line-removed">1146             pcerts = ((ConcurrentHashMap&lt;String, Certificate[]&gt;)package2certs).</span>
<span class="line-removed">1147                 putIfAbsent(pname, (certs == null? nocerts:certs));</span>
<span class="line-removed">1148         }</span>
1149         if (pcerts != null &amp;&amp; !compareCerts(pcerts, certs)) {
1150             throw new SecurityException(&quot;class \&quot;&quot; + name
1151                 + &quot;\&quot;&#39;s signer information does not match signer information&quot;
1152                 + &quot; of other classes in the same package&quot;);
1153         }
1154     }
1155 
1156     /**
1157      * check to make sure the certs for the new class (certs) are the same as
1158      * the certs for the first class inserted in the package (pcerts)
1159      */
<span class="line-modified">1160     private boolean compareCerts(Certificate[] pcerts,</span>
<span class="line-modified">1161                                  Certificate[] certs)</span>
<span class="line-modified">1162     {</span>
<span class="line-removed">1163         // certs can be null, indicating no certs.</span>
<span class="line-removed">1164         if ((certs == null) || (certs.length == 0)) {</span>
1165             return pcerts.length == 0;
<span class="line-removed">1166         }</span>
1167 
1168         // the length must be the same at this point
1169         if (certs.length != pcerts.length)
1170             return false;
1171 
1172         // go through and make sure all the certs in one array
1173         // are in the other and vice-versa.
1174         boolean match;
1175         for (Certificate cert : certs) {
1176             match = false;
1177             for (Certificate pcert : pcerts) {
1178                 if (cert.equals(pcert)) {
1179                     match = true;
1180                     break;
1181                 }
1182             }
1183             if (!match) return false;
1184         }
1185 
1186         // now do the same for pcerts
</pre>
<hr />
<pre>
1876      * should take great care to avoid calling {@code getSystemClassLoader()}.
1877      * If circular initialization of the system class loader is detected then
1878      * an {@code IllegalStateException} is thrown.
1879      *
1880      * @implNote The system property to override the system class loader is not
1881      * examined until the VM is almost fully initialized. Code that executes
1882      * this method during startup should take care not to cache the return
1883      * value until the system is fully initialized.
1884      *
1885      * &lt;p&gt; The name of the built-in system class loader is {@code &quot;app&quot;}.
1886      * The system property &quot;{@code java.class.path}&quot; is read during early
1887      * initialization of the VM to determine the class path.
1888      * An empty value of &quot;{@code java.class.path}&quot; property is interpreted
1889      * differently depending on whether the initial module (the module
1890      * containing the main class) is named or unnamed:
1891      * If named, the built-in system class loader will have no class path and
1892      * will search for classes and resources using the application module path;
1893      * otherwise, if unnamed, it will set the class path to the current
1894      * working directory.
1895      *










1896      * @return  The system {@code ClassLoader}
1897      *
1898      * @throws  SecurityException
1899      *          If a security manager is present, and the caller&#39;s class loader
1900      *          is not {@code null} and is not the same as or an ancestor of the
1901      *          system class loader, and the caller does not have the
1902      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1903      *
1904      * @throws  IllegalStateException
1905      *          If invoked recursively during the construction of the class
1906      *          loader specified by the &quot;{@code java.system.class.loader}&quot;
1907      *          property.
1908      *
1909      * @throws  Error
1910      *          If the system property &quot;{@code java.system.class.loader}&quot;
1911      *          is defined but the named class could not be loaded, the
1912      *          provider class does not define the required constructor, or an
1913      *          exception is thrown by that constructor when it is invoked. The
1914      *          underlying cause of the error can be retrieved via the
1915      *          {@link Throwable#getCause()} method.
</pre>
<hr />
<pre>
2167      *
2168      * @param  sealBase
2169      *         If not {@code null}, then this package is sealed with
2170      *         respect to the given code source {@link java.net.URL URL}
2171      *         object.  Otherwise, the package is not sealed.
2172      *
2173      * @return  The newly defined {@code Package} object
2174      *
2175      * @throws  NullPointerException
2176      *          if {@code name} is {@code null}.
2177      *
2178      * @throws  IllegalArgumentException
2179      *          if a package of the given {@code name} is already
2180      *          defined by this class loader
2181      *
2182      *
2183      * @since  1.2
2184      * @revised 9
2185      * @spec JPMS
2186      *
<span class="line-modified">2187      * @jvms 5.3 Run-time package</span>
2188      * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
2189      *      The JAR File Specification: Package Sealing&lt;/a&gt;
2190      */
2191     protected Package definePackage(String name, String specTitle,
2192                                     String specVersion, String specVendor,
2193                                     String implTitle, String implVersion,
2194                                     String implVendor, URL sealBase)
2195     {
2196         Objects.requireNonNull(name);
2197 
2198         // definePackage is not final and may be overridden by custom class loader
2199         Package p = new Package(name, specTitle, specVersion, specVendor,
2200                                 implTitle, implVersion, implVendor,
2201                                 sealBase, this);
2202 
2203         if (packages.putIfAbsent(name, p) != null)
2204             throw new IllegalArgumentException(name);
2205 
2206         return p;
2207     }
2208 
2209     /**
2210      * Returns a {@code Package} of the given &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; that
2211      * has been defined by this class loader.
2212      *
2213      * @param  name The &lt;a href=&quot;#binary-name&quot;&gt;package name&lt;/a&gt;
2214      *
2215      * @return The {@code Package} of the given name that has been defined
2216      *         by this class loader, or {@code null} if not found
2217      *
2218      * @throws  NullPointerException
2219      *          if {@code name} is {@code null}.
2220      *
<span class="line-modified">2221      * @jvms 5.3 Run-time package</span>
2222      *
2223      * @since  9
2224      * @spec JPMS
2225      */
2226     public final Package getDefinedPackage(String name) {
2227         Objects.requireNonNull(name, &quot;name cannot be null&quot;);
2228 
2229         NamedPackage p = packages.get(name);
2230         if (p == null)
2231             return null;
2232 
2233         return definePackage(name, p.module());
2234     }
2235 
2236     /**
2237      * Returns all of the {@code Package}s that have been defined by
2238      * this class loader.  The returned array has no duplicated {@code Package}s
2239      * of the same name.
2240      *
2241      * @apiNote This method returns an array rather than a {@code Set} or {@code Stream}
2242      *          for consistency with the existing {@link #getPackages} method.
2243      *
2244      * @return The array of {@code Package} objects that have been defined by
2245      *         this class loader; or an zero length array if no package has been
2246      *         defined by this class loader.
2247      *
<span class="line-modified">2248      * @jvms 5.3 Run-time package</span>
2249      *
2250      * @since  9
2251      * @spec JPMS
2252      */
2253     public final Package[] getDefinedPackages() {
2254         return packages().toArray(Package[]::new);
2255     }
2256 
2257     /**
2258      * Finds a package by &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; in this class loader and its ancestors.
2259      * &lt;p&gt;
2260      * If this class loader defines a {@code Package} of the given name,
2261      * the {@code Package} is returned. Otherwise, the ancestors of
2262      * this class loader are searched recursively (parent by parent)
2263      * for a {@code Package} of the given name.
2264      *
2265      * @apiNote The {@link #getPlatformClassLoader() platform class loader}
2266      * may delegate to the application class loader but the application class
2267      * loader is not its ancestor.  When invoked on the platform class loader,
2268      * this method  will not find packages defined to the application
</pre>
<hr />
<pre>
2446                 fromClass == null ? null : fromClass.getClassLoader();
2447 
2448             synchronized (loadedLibraryNames) {
2449                 Map&lt;String, NativeLibrary&gt; libs =
2450                     loader != null ? loader.nativeLibraries() : systemNativeLibraries();
2451                 if (libs.containsKey(name)) {
2452                     return true;
2453                 }
2454 
2455                 if (loadedLibraryNames.contains(name)) {
2456                     throw new UnsatisfiedLinkError(&quot;Native Library &quot; + name +
2457                         &quot; already loaded in another classloader&quot;);
2458                 }
2459 
2460                 /*
2461                  * When a library is being loaded, JNI_OnLoad function can cause
2462                  * another loadLibrary invocation that should succeed.
2463                  *
2464                  * We use a static stack to hold the list of libraries we are
2465                  * loading because this can happen only when called by the
<span class="line-modified">2466                  * same thread because Runtime.load and Runtime.loadLibrary</span>
<span class="line-removed">2467                  * are synchronous.</span>
2468                  *
2469                  * If there is a pending load operation for the library, we
2470                  * immediately return success; otherwise, we raise
2471                  * UnsatisfiedLinkError.
2472                  */
2473                 for (NativeLibrary lib : nativeLibraryContext) {
2474                     if (name.equals(lib.name)) {
2475                         if (loader == lib.fromClass.getClassLoader()) {
2476                             return true;
2477                         } else {
2478                             throw new UnsatisfiedLinkError(&quot;Native Library &quot; +
2479                                 name + &quot; is being loaded in another classloader&quot;);
2480                         }
2481                     }
2482                 }
2483                 NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);
2484                 // load the native library
2485                 nativeLibraryContext.push(lib);
2486                 try {
2487                     if (!lib.load()) return false;
</pre>
<hr />
<pre>
2532             public void run() {
2533                 synchronized (loadedLibraryNames) {
2534                     /* remove the native library name */
2535                     loadedLibraryNames.remove(name);
2536                     nativeLibraryContext.push(UNLOADER);
2537                     try {
2538                         unload(name, isBuiltin, handle);
2539                     } finally {
2540                         nativeLibraryContext.pop();
2541                     }
2542 
2543                 }
2544             }
2545         }
2546 
2547         // JNI FindClass expects the caller class if invoked from JNI_OnLoad
2548         // and JNI_OnUnload is NativeLibrary class
2549         static native void unload(String name, boolean isBuiltin, long handle);
2550     }
2551 
<span class="line-modified">2552     // The paths searched for libraries</span>
<span class="line-modified">2553     private static String usr_paths[];</span>
<span class="line-modified">2554     private static String sys_paths[];</span>
<span class="line-modified">2555 </span>
<span class="line-modified">2556     private static String[] initializePath(String propName) {</span>
<span class="line-modified">2557         String ldPath = System.getProperty(propName, &quot;&quot;);</span>
<span class="line-modified">2558         int ldLen = ldPath.length();</span>
<span class="line-modified">2559         char ps = File.pathSeparatorChar;</span>
<span class="line-modified">2560         int psCount = 0;</span>
<span class="line-modified">2561 </span>
<span class="line-modified">2562         if (ClassLoaderHelper.allowsQuotedPathElements &amp;&amp;</span>
<span class="line-removed">2563             ldPath.indexOf(&#39;\&quot;&#39;) &gt;= 0) {</span>
<span class="line-removed">2564             // First, remove quotes put around quoted parts of paths.</span>
<span class="line-removed">2565             // Second, use a quotation mark as a new path separator.</span>
<span class="line-removed">2566             // This will preserve any quoted old path separators.</span>
<span class="line-removed">2567             char[] buf = new char[ldLen];</span>
<span class="line-removed">2568             int bufLen = 0;</span>
<span class="line-removed">2569             for (int i = 0; i &lt; ldLen; ++i) {</span>
<span class="line-removed">2570                 char ch = ldPath.charAt(i);</span>
<span class="line-removed">2571                 if (ch == &#39;\&quot;&#39;) {</span>
<span class="line-removed">2572                     while (++i &lt; ldLen &amp;&amp;</span>
<span class="line-removed">2573                         (ch = ldPath.charAt(i)) != &#39;\&quot;&#39;) {</span>
<span class="line-removed">2574                         buf[bufLen++] = ch;</span>
<span class="line-removed">2575                     }</span>
<span class="line-removed">2576                 } else {</span>
<span class="line-removed">2577                     if (ch == ps) {</span>
<span class="line-removed">2578                         psCount++;</span>
<span class="line-removed">2579                         ch = &#39;\&quot;&#39;;</span>
<span class="line-removed">2580                     }</span>
<span class="line-removed">2581                     buf[bufLen++] = ch;</span>
<span class="line-removed">2582                 }</span>
<span class="line-removed">2583             }</span>
<span class="line-removed">2584             ldPath = new String(buf, 0, bufLen);</span>
<span class="line-removed">2585             ldLen = bufLen;</span>
<span class="line-removed">2586             ps = &#39;\&quot;&#39;;</span>
<span class="line-removed">2587         } else {</span>
<span class="line-removed">2588             for (int i = ldPath.indexOf(ps); i &gt;= 0;</span>
<span class="line-removed">2589                  i = ldPath.indexOf(ps, i + 1)) {</span>
<span class="line-removed">2590                 psCount++;</span>
<span class="line-removed">2591             }</span>
<span class="line-removed">2592         }</span>
<span class="line-removed">2593 </span>
<span class="line-removed">2594         String[] paths = new String[psCount + 1];</span>
<span class="line-removed">2595         int pathStart = 0;</span>
<span class="line-removed">2596         for (int j = 0; j &lt; psCount; ++j) {</span>
<span class="line-removed">2597             int pathEnd = ldPath.indexOf(ps, pathStart);</span>
<span class="line-removed">2598             paths[j] = (pathStart &lt; pathEnd) ?</span>
<span class="line-removed">2599                 ldPath.substring(pathStart, pathEnd) : &quot;.&quot;;</span>
<span class="line-removed">2600             pathStart = pathEnd + 1;</span>
<span class="line-removed">2601         }</span>
<span class="line-removed">2602         paths[psCount] = (pathStart &lt; ldLen) ?</span>
<span class="line-removed">2603             ldPath.substring(pathStart, ldLen) : &quot;.&quot;;</span>
<span class="line-removed">2604         return paths;</span>
2605     }
2606 
2607     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
2608     static void loadLibrary(Class&lt;?&gt; fromClass, String name,
2609                             boolean isAbsolute) {
2610         ClassLoader loader =
2611             (fromClass == null) ? null : fromClass.getClassLoader();
<span class="line-modified">2612         if (sys_paths == null) {</span>
<span class="line-removed">2613             usr_paths = initializePath(&quot;java.library.path&quot;);</span>
<span class="line-removed">2614             sys_paths = initializePath(&quot;sun.boot.library.path&quot;);</span>
<span class="line-removed">2615         }</span>
2616         if (isAbsolute) {
2617             if (loadLibrary0(fromClass, new File(name))) {
2618                 return;
2619             }
2620             throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);
2621         }
2622         if (loader != null) {
2623             String libfilename = loader.findLibrary(name);
2624             if (libfilename != null) {
2625                 File libfile = new File(libfilename);
2626                 if (!libfile.isAbsolute()) {
2627                     throw new UnsatisfiedLinkError(
2628                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
2629                 }
2630                 if (loadLibrary0(fromClass, libfile)) {
2631                     return;
2632                 }
2633                 throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);
2634             }
2635         }
<span class="line-modified">2636         for (String sys_path : sys_paths) {</span>
<span class="line-modified">2637             File libfile = new File(sys_path, System.mapLibraryName(name));</span>
2638             if (loadLibrary0(fromClass, libfile)) {
2639                 return;
2640             }
2641             libfile = ClassLoaderHelper.mapAlternativeName(libfile);
2642             if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
2643                 return;
2644             }
2645         }
2646         if (loader != null) {
<span class="line-modified">2647             for (String usr_path : usr_paths) {</span>
<span class="line-modified">2648                 File libfile = new File(usr_path, System.mapLibraryName(name));</span>
2649                 if (loadLibrary0(fromClass, libfile)) {
2650                     return;
2651                 }
2652                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);
2653                 if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
2654                     return;
2655                 }
2656             }
2657         }
2658         // Oops, it failed
2659         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">2660             &quot; in java.library.path: &quot; + Arrays.toString(usr_paths));</span>
2661     }
2662 
2663     private static native String findBuiltinLib(String name);
2664 
2665     private static boolean loadLibrary0(Class&lt;?&gt; fromClass, final File file) {
2666         // Check to see if we&#39;re attempting to access a static library
2667         String name = findBuiltinLib(file.getName());
2668         boolean isBuiltin = (name != null);
2669         if (!isBuiltin) {
2670             name = AccessController.doPrivileged(
2671                 new PrivilegedAction&lt;&gt;() {
2672                     public String run() {
2673                         try {
2674                             return file.exists() ? file.getCanonicalPath() : null;
2675                         } catch (IOException e) {
2676                             return null;
2677                         }
2678                     }
2679                 });
2680             if (name == null) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-added">   3  * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.  Oracle designates this
   9  * particular file as subject to the &quot;Classpath&quot; exception as provided
  10  * by Oracle in the LICENSE file that accompanied this code.
  11  *
  12  * This code is distributed in the hope that it will be useful, but WITHOUT
  13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  15  * version 2 for more details (a copy is included in the LICENSE file that
  16  * accompanied this code).
  17  *
  18  * You should have received a copy of the GNU General Public License version
  19  * 2 along with this work; if not, write to the Free Software Foundation,
  20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  21  *
  22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  23  * or visit www.oracle.com if you need additional information or have any
  24  * questions.
  25  */
  26 
  27 package java.lang;
  28 
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.io.File;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.InvocationTargetException;
  35 import java.net.URL;
  36 import java.security.AccessController;
  37 import java.security.AccessControlContext;
  38 import java.security.CodeSource;
  39 import java.security.PrivilegedAction;
  40 import java.security.ProtectionDomain;
  41 import java.security.cert.Certificate;
  42 import java.util.ArrayDeque;
<span class="line-added">  43 import java.util.ArrayList;</span>
  44 import java.util.Arrays;
  45 import java.util.Collections;
  46 import java.util.Deque;
  47 import java.util.Enumeration;
  48 import java.util.HashMap;
  49 import java.util.HashSet;

  50 import java.util.Map;
  51 import java.util.NoSuchElementException;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.Spliterator;
  55 import java.util.Spliterators;

  56 import java.util.WeakHashMap;
  57 import java.util.concurrent.ConcurrentHashMap;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Stream;
  60 import java.util.stream.StreamSupport;
  61 
  62 import jdk.internal.loader.BuiltinClassLoader;
  63 import jdk.internal.perf.PerfCounter;
  64 import jdk.internal.loader.BootLoader;
  65 import jdk.internal.loader.ClassLoaders;
  66 import jdk.internal.misc.Unsafe;
  67 import jdk.internal.misc.VM;
  68 import jdk.internal.ref.CleanerFactory;
  69 import jdk.internal.reflect.CallerSensitive;
  70 import jdk.internal.reflect.Reflection;
<span class="line-added">  71 import jdk.internal.util.StaticProperty;</span>
  72 import sun.reflect.misc.ReflectUtil;
  73 import sun.security.util.SecurityConstants;
  74 
  75 /**
  76  * A class loader is an object that is responsible for loading classes. The
  77  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  78  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  79  * locate or generate data that constitutes a definition for the class.  A
  80  * typical strategy is to transform the name into a file name and then read a
  81  * &quot;class file&quot; of that name from a file system.
  82  *
  83  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  84  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  85  * it.
  86  *
  87  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  88  * loaders, but are created automatically as required by the Java runtime.
  89  * The class loader for an array class, as returned by {@link
  90  * Class#getClassLoader()} is the same as the class loader for its element
  91  * type; if the element type is a primitive type, then the array class has no
</pre>
<hr />
<pre>
 110  * classes and resources.  Each instance of {@code ClassLoader} has an
 111  * associated parent class loader. When requested to find a class or
 112  * resource, a {@code ClassLoader} instance will usually delegate the search
 113  * for the class or resource to its parent class loader before attempting to
 114  * find the class or resource itself.
 115  *
 116  * &lt;p&gt; Class loaders that support concurrent loading of classes are known as
 117  * &lt;em&gt;{@linkplain #isRegisteredAsParallelCapable() parallel capable}&lt;/em&gt; class
 118  * loaders and are required to register themselves at their class initialization
 119  * time by invoking the {@link
 120  * #registerAsParallelCapable ClassLoader.registerAsParallelCapable}
 121  * method. Note that the {@code ClassLoader} class is registered as parallel
 122  * capable by default. However, its subclasses still need to register themselves
 123  * if they are parallel capable.
 124  * In environments in which the delegation model is not strictly
 125  * hierarchical, class loaders need to be parallel capable, otherwise class
 126  * loading can lead to deadlocks because the loader lock is held for the
 127  * duration of the class loading process (see {@link #loadClass
 128  * loadClass} methods).
 129  *
<span class="line-modified"> 130  * &lt;h2&gt; &lt;a id=&quot;builtinLoaders&quot;&gt;Run-time Built-in Class Loaders&lt;/a&gt;&lt;/h2&gt;</span>
 131  *
 132  * The Java run-time has the following built-in class loaders:
 133  *
 134  * &lt;ul&gt;
 135  * &lt;li&gt;&lt;p&gt;Bootstrap class loader.
 136  *     It is the virtual machine&#39;s built-in class loader, typically represented
 137  *     as {@code null}, and does not have a parent.&lt;/li&gt;
 138  * &lt;li&gt;&lt;p&gt;{@linkplain #getPlatformClassLoader() Platform class loader}.
 139  *     All &lt;em&gt;platform classes&lt;/em&gt; are visible to the platform class loader
 140  *     that can be used as the parent of a {@code ClassLoader} instance.
 141  *     Platform classes include Java SE platform APIs, their implementation
 142  *     classes and JDK-specific run-time classes that are defined by the
 143  *     platform class loader or its ancestors.
 144  *     &lt;p&gt; To allow for upgrading/overriding of modules defined to the platform
 145  *     class loader, and where upgraded modules read modules defined to class
 146  *     loaders other than the platform class loader and its ancestors, then
 147  *     the platform class loader may have to delegate to other class loaders,
 148  *     the application class loader for example.
 149  *     In other words, classes in named modules defined to class loaders
 150  *     other than the platform class loader and its ancestors may be visible
</pre>
<hr />
<pre>
 206  *
 207  * &lt;h3&gt; &lt;a id=&quot;binary-name&quot;&gt;Binary names&lt;/a&gt; &lt;/h3&gt;
 208  *
 209  * &lt;p&gt; Any class name provided as a {@code String} parameter to methods in
 210  * {@code ClassLoader} must be a binary name as defined by
 211  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 212  *
 213  * &lt;p&gt; Examples of valid class names include:
 214  * &lt;blockquote&gt;&lt;pre&gt;
 215  *   &quot;java.lang.String&quot;
 216  *   &quot;javax.swing.JSpinner$DefaultEditor&quot;
 217  *   &quot;java.security.KeyStore$Builder$FileBuilder$1&quot;
 218  *   &quot;java.net.URLClassLoader$3$1&quot;
 219  * &lt;/pre&gt;&lt;/blockquote&gt;
 220  *
 221  * &lt;p&gt; Any package name provided as a {@code String} parameter to methods in
 222  * {@code ClassLoader} must be either the empty string (denoting an unnamed package)
 223  * or a fully qualified name as defined by
 224  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 225  *
<span class="line-modified"> 226  * @jls 6.7 Fully Qualified Names</span>
 227  * @jls 13.1 The Form of a Binary
 228  * @see      #resolveClass(Class)
 229  * @since 1.0
 230  * @revised 9
 231  * @spec JPMS
 232  */
 233 public abstract class ClassLoader {
 234 
 235     private static native void registerNatives();
 236     static {
 237         registerNatives();
 238     }
 239 
 240     // The parent class loader for delegation
 241     // Note: VM hardcoded the offset of this field, thus all new fields
 242     // must be added *after* it.
 243     private final ClassLoader parent;
 244 
 245     // class loader name
 246     private final String name;
</pre>
<hr />
<pre>
 286         }
 287 
 288         /**
 289          * Returns {@code true} if the given class loader type is
 290          * registered as parallel capable.
 291          */
 292         static boolean isRegistered(Class&lt;? extends ClassLoader&gt; c) {
 293             synchronized (loaderTypes) {
 294                 return loaderTypes.contains(c);
 295             }
 296         }
 297     }
 298 
 299     // Maps class name to the corresponding lock object when the current
 300     // class loader is parallel capable.
 301     // Note: VM also uses this field to decide if the current class loader
 302     // is parallel capable and the appropriate lock object for class loading.
 303     private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;
 304 
 305     // Maps packages to certs
<span class="line-modified"> 306     private final ConcurrentHashMap&lt;String, Certificate[]&gt; package2certs;</span>
 307 
 308     // Shared among all packages with unsigned classes
 309     private static final Certificate[] nocerts = new Certificate[0];
 310 
 311     // The classes loaded by this class loader. The only purpose of this table
 312     // is to keep the classes from being GC&#39;ed until the loader is GC&#39;ed.
<span class="line-modified"> 313     private final ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();</span>
 314 
 315     // The &quot;default&quot; domain. Set as the default ProtectionDomain on newly
 316     // created classes.
 317     private final ProtectionDomain defaultDomain =
 318         new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
 319                              null, this, null);
 320 
 321     // Invoked by the VM to record every loaded class with this loader.
 322     void addClass(Class&lt;?&gt; c) {
<span class="line-modified"> 323         synchronized (classes) {</span>
<span class="line-added"> 324             classes.add(c);</span>
<span class="line-added"> 325         }</span>
 326     }
 327 
 328     // The packages defined in this class loader.  Each package name is
 329     // mapped to its corresponding NamedPackage object.
 330     //
 331     // The value is a Package object if ClassLoader::definePackage,
 332     // Class::getPackage, ClassLoader::getDefinePackage(s) or
 333     // Package::getPackage(s) method is called to define it.
 334     // Otherwise, the value is a NamedPackage object.
 335     private final ConcurrentHashMap&lt;String, NamedPackage&gt; packages
 336             = new ConcurrentHashMap&lt;&gt;();
 337 
 338     /*
 339      * Returns a named package for the given module.
 340      */
 341     private NamedPackage getNamedPackage(String pn, Module m) {
 342         NamedPackage p = packages.get(pn);
 343         if (p == null) {
 344             p = new NamedPackage(pn, m);
 345 
</pre>
<hr />
<pre>
 363     }
 364 
 365     private static Void checkCreateClassLoader(String name) {
 366         if (name != null &amp;&amp; name.isEmpty()) {
 367             throw new IllegalArgumentException(&quot;name must be non-empty or null&quot;);
 368         }
 369 
 370         SecurityManager security = System.getSecurityManager();
 371         if (security != null) {
 372             security.checkCreateClassLoader();
 373         }
 374         return null;
 375     }
 376 
 377     private ClassLoader(Void unused, String name, ClassLoader parent) {
 378         this.name = name;
 379         this.parent = parent;
 380         this.unnamedModule = new Module(this);
 381         if (ParallelLoaders.isRegistered(this.getClass())) {
 382             parallelLockMap = new ConcurrentHashMap&lt;&gt;();

 383             assertionLock = new Object();
 384         } else {
 385             // no finer-grained lock; lock on the classloader instance
 386             parallelLockMap = null;

 387             assertionLock = this;
 388         }
<span class="line-added"> 389         this.package2certs = new ConcurrentHashMap&lt;&gt;();</span>
 390         this.nameAndId = nameAndId(this);
 391     }
 392 
 393     /**
 394      * If the defining loader has a name explicitly set then
 395      *       &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
 396      * If the defining loader has no name then
 397      *       &lt;qualified-class-name&gt; @&lt;id&gt;
 398      * If it&#39;s built-in loader then omit `@&lt;id&gt;` as there is only one instance.
 399      */
 400     private static String nameAndId(ClassLoader ld) {
 401         String nid = ld.getName() != null ? &quot;\&#39;&quot; + ld.getName() + &quot;\&#39;&quot;
 402                                           : ld.getClass().getName();
 403         if (!(ld instanceof BuiltinClassLoader)) {
 404             String id = Integer.toHexString(System.identityHashCode(ld));
 405             nid = nid + &quot; @&quot; + id;
 406         }
 407         return nid;
 408     }
 409 
</pre>
<hr />
<pre>
 430      */
 431     protected ClassLoader(String name, ClassLoader parent) {
 432         this(checkCreateClassLoader(name), name, parent);
 433     }
 434 
 435     /**
 436      * Creates a new class loader using the specified parent class loader for
 437      * delegation.
 438      *
 439      * &lt;p&gt; If there is a security manager, its {@link
 440      * SecurityManager#checkCreateClassLoader() checkCreateClassLoader} method
 441      * is invoked.  This may result in a security exception.  &lt;/p&gt;
 442      *
 443      * @apiNote If the parent is specified as {@code null} (for the
 444      * bootstrap class loader) then there is no guarantee that all platform
 445      * classes are visible.
 446      *
 447      * @param  parent
 448      *         The parent class loader
 449      *
<span class="line-modified"> 450      * @throws SecurityException</span>
<span class="line-modified"> 451      *         If a security manager exists and its</span>
<span class="line-modified"> 452      *         {@code checkCreateClassLoader} method doesn&#39;t allow creation</span>
<span class="line-modified"> 453      *         of a new class loader.</span>
 454      *
 455      * @since  1.2
 456      */
 457     protected ClassLoader(ClassLoader parent) {
 458         this(checkCreateClassLoader(), null, parent);
 459     }
 460 
 461     /**
 462      * Creates a new class loader using the {@code ClassLoader} returned by
 463      * the method {@link #getSystemClassLoader()
 464      * getSystemClassLoader()} as the parent class loader.
 465      *
 466      * &lt;p&gt; If there is a security manager, its {@link
 467      * SecurityManager#checkCreateClassLoader()
 468      * checkCreateClassLoader} method is invoked.  This may result in
 469      * a security exception.  &lt;/p&gt;
 470      *
 471      * @throws  SecurityException
 472      *          If a security manager exists and its
 473      *          {@code checkCreateClassLoader} method doesn&#39;t allow creation
</pre>
<hr />
<pre>
 494     public String getName() {
 495         return name;
 496     }
 497 
 498     // package-private used by StackTraceElement to avoid
 499     // calling the overrideable getName method
 500     final String name() {
 501         return name;
 502     }
 503 
 504     // -- Class --
 505 
 506     /**
 507      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.
 508      * This method searches for classes in the same manner as the {@link
 509      * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
 510      * machine to resolve class references.  Invoking this method is equivalent
 511      * to invoking {@link #loadClass(String, boolean) loadClass(name,
 512      * false)}.
 513      *
<span class="line-modified"> 514      * @param   name</span>
<span class="line-modified"> 515      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
 516      *
 517      * @return  The resulting {@code Class} object
 518      *
 519      * @throws  ClassNotFoundException
 520      *          If the class was not found
 521      */
 522     public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
 523         return loadClass(name, false);
 524     }
 525 
 526     /**
 527      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The
 528      * default implementation of this method searches for classes in the
 529      * following order:
 530      *
 531      * &lt;ol&gt;
 532      *
 533      *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
 534      *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
 535      *
 536      *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) loadClass} method
 537      *   on the parent class loader.  If the parent is {@code null} the class
 538      *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
 539      *
 540      *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
 541      *   class.  &lt;/p&gt;&lt;/li&gt;
 542      *
 543      * &lt;/ol&gt;
 544      *
 545      * &lt;p&gt; If the class was found using the above steps, and the
 546      * {@code resolve} flag is true, this method will then invoke the {@link
 547      * #resolveClass(Class)} method on the resulting {@code Class} object.
 548      *
 549      * &lt;p&gt; Subclasses of {@code ClassLoader} are encouraged to override {@link
 550      * #findClass(String)}, rather than this method.  &lt;/p&gt;
 551      *
 552      * &lt;p&gt; Unless overridden, this method synchronizes on the result of
 553      * {@link #getClassLoadingLock getClassLoadingLock} method
 554      * during the entire class loading process.
 555      *
<span class="line-modified"> 556      * @param   name</span>
<span class="line-modified"> 557      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
 558      *
<span class="line-modified"> 559      * @param   resolve</span>
<span class="line-modified"> 560      *          If {@code true} then resolve the class</span>
 561      *
 562      * @return  The resulting {@code Class} object
 563      *
 564      * @throws  ClassNotFoundException
 565      *          If the class could not be found
 566      */
 567     protected Class&lt;?&gt; loadClass(String name, boolean resolve)
 568         throws ClassNotFoundException
 569     {
 570         synchronized (getClassLoadingLock(name)) {
 571             // First, check if the class has already been loaded
 572             Class&lt;?&gt; c = findLoadedClass(name);
 573             if (c == null) {
 574                 long t0 = System.nanoTime();
 575                 try {
 576                     if (parent != null) {
 577                         c = parent.loadClass(name, false);
 578                     } else {
 579                         c = findBootstrapClassOrNull(name);
 580                     }
</pre>
<hr />
<pre>
 689             if (!packageName.isEmpty()) {
 690                 AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 691                     public Void run() {
 692                         sm.checkPackageAccess(packageName);
 693                         return null;
 694                     }
 695                 }, new AccessControlContext(new ProtectionDomain[] {pd}));
 696             }
 697         }
 698     }
 699 
 700     /**
 701      * Finds the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.
 702      * This method should be overridden by class loader implementations that
 703      * follow the delegation model for loading classes, and will be invoked by
 704      * the {@link #loadClass loadClass} method after checking the
 705      * parent class loader for the requested class.
 706      *
 707      * @implSpec The default implementation throws {@code ClassNotFoundException}.
 708      *
<span class="line-modified"> 709      * @param   name</span>
<span class="line-modified"> 710      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
 711      *
 712      * @return  The resulting {@code Class} object
 713      *
 714      * @throws  ClassNotFoundException
 715      *          If the class could not be found
 716      *
 717      * @since  1.2
 718      */
 719     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
 720         throw new ClassNotFoundException(name);
 721     }
 722 
 723     /**
 724      * Finds the class with the given &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;
 725      * in a module defined to this class loader.
 726      * Class loader implementations that support loading from modules
 727      * should override this method.
 728      *
 729      * @apiNote This method returns {@code null} rather than throwing
 730      *          {@code ClassNotFoundException} if the class could not be found.
</pre>
<hr />
<pre>
1119                                         int off, int len, ProtectionDomain pd,
1120                                         String source);
1121 
1122     // true if the name is null or has the potential to be a valid binary name
1123     private boolean checkName(String name) {
1124         if ((name == null) || (name.isEmpty()))
1125             return true;
1126         if ((name.indexOf(&#39;/&#39;) != -1) || (name.charAt(0) == &#39;[&#39;))
1127             return false;
1128         return true;
1129     }
1130 
1131     private void checkCerts(String name, CodeSource cs) {
1132         int i = name.lastIndexOf(&#39;.&#39;);
1133         String pname = (i == -1) ? &quot;&quot; : name.substring(0, i);
1134 
1135         Certificate[] certs = null;
1136         if (cs != null) {
1137             certs = cs.getCertificates();
1138         }
<span class="line-modified">1139         certs = certs == null ? nocerts : certs;</span>
<span class="line-modified">1140         Certificate[] pcerts = package2certs.putIfAbsent(pname, certs);</span>










1141         if (pcerts != null &amp;&amp; !compareCerts(pcerts, certs)) {
1142             throw new SecurityException(&quot;class \&quot;&quot; + name
1143                 + &quot;\&quot;&#39;s signer information does not match signer information&quot;
1144                 + &quot; of other classes in the same package&quot;);
1145         }
1146     }
1147 
1148     /**
1149      * check to make sure the certs for the new class (certs) are the same as
1150      * the certs for the first class inserted in the package (pcerts)
1151      */
<span class="line-modified">1152     private boolean compareCerts(Certificate[] pcerts, Certificate[] certs) {</span>
<span class="line-modified">1153         // empty array fast-path</span>
<span class="line-modified">1154         if (certs.length == 0)</span>


1155             return pcerts.length == 0;

1156 
1157         // the length must be the same at this point
1158         if (certs.length != pcerts.length)
1159             return false;
1160 
1161         // go through and make sure all the certs in one array
1162         // are in the other and vice-versa.
1163         boolean match;
1164         for (Certificate cert : certs) {
1165             match = false;
1166             for (Certificate pcert : pcerts) {
1167                 if (cert.equals(pcert)) {
1168                     match = true;
1169                     break;
1170                 }
1171             }
1172             if (!match) return false;
1173         }
1174 
1175         // now do the same for pcerts
</pre>
<hr />
<pre>
1865      * should take great care to avoid calling {@code getSystemClassLoader()}.
1866      * If circular initialization of the system class loader is detected then
1867      * an {@code IllegalStateException} is thrown.
1868      *
1869      * @implNote The system property to override the system class loader is not
1870      * examined until the VM is almost fully initialized. Code that executes
1871      * this method during startup should take care not to cache the return
1872      * value until the system is fully initialized.
1873      *
1874      * &lt;p&gt; The name of the built-in system class loader is {@code &quot;app&quot;}.
1875      * The system property &quot;{@code java.class.path}&quot; is read during early
1876      * initialization of the VM to determine the class path.
1877      * An empty value of &quot;{@code java.class.path}&quot; property is interpreted
1878      * differently depending on whether the initial module (the module
1879      * containing the main class) is named or unnamed:
1880      * If named, the built-in system class loader will have no class path and
1881      * will search for classes and resources using the application module path;
1882      * otherwise, if unnamed, it will set the class path to the current
1883      * working directory.
1884      *
<span class="line-added">1885      * &lt;p&gt; JAR files on the class path may contain a {@code Class-Path} manifest</span>
<span class="line-added">1886      * attribute to specify dependent JAR files to be included in the class path.</span>
<span class="line-added">1887      * {@code Class-Path} entries must meet certain conditions for validity (see</span>
<span class="line-added">1888      * the &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#class-path-attribute&quot;&gt;</span>
<span class="line-added">1889      * JAR File Specification&lt;/a&gt; for details).  Invalid {@code Class-Path}</span>
<span class="line-added">1890      * entries are ignored.  For debugging purposes, ignored entries can be</span>
<span class="line-added">1891      * printed to the console if the</span>
<span class="line-added">1892      * {@systemProperty jdk.net.URLClassPath.showIgnoredClassPathEntries} system</span>
<span class="line-added">1893      * property is set to {@code true}.</span>
<span class="line-added">1894      *</span>
1895      * @return  The system {@code ClassLoader}
1896      *
1897      * @throws  SecurityException
1898      *          If a security manager is present, and the caller&#39;s class loader
1899      *          is not {@code null} and is not the same as or an ancestor of the
1900      *          system class loader, and the caller does not have the
1901      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1902      *
1903      * @throws  IllegalStateException
1904      *          If invoked recursively during the construction of the class
1905      *          loader specified by the &quot;{@code java.system.class.loader}&quot;
1906      *          property.
1907      *
1908      * @throws  Error
1909      *          If the system property &quot;{@code java.system.class.loader}&quot;
1910      *          is defined but the named class could not be loaded, the
1911      *          provider class does not define the required constructor, or an
1912      *          exception is thrown by that constructor when it is invoked. The
1913      *          underlying cause of the error can be retrieved via the
1914      *          {@link Throwable#getCause()} method.
</pre>
<hr />
<pre>
2166      *
2167      * @param  sealBase
2168      *         If not {@code null}, then this package is sealed with
2169      *         respect to the given code source {@link java.net.URL URL}
2170      *         object.  Otherwise, the package is not sealed.
2171      *
2172      * @return  The newly defined {@code Package} object
2173      *
2174      * @throws  NullPointerException
2175      *          if {@code name} is {@code null}.
2176      *
2177      * @throws  IllegalArgumentException
2178      *          if a package of the given {@code name} is already
2179      *          defined by this class loader
2180      *
2181      *
2182      * @since  1.2
2183      * @revised 9
2184      * @spec JPMS
2185      *
<span class="line-modified">2186      * @jvms 5.3 Creation and Loading</span>
2187      * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
2188      *      The JAR File Specification: Package Sealing&lt;/a&gt;
2189      */
2190     protected Package definePackage(String name, String specTitle,
2191                                     String specVersion, String specVendor,
2192                                     String implTitle, String implVersion,
2193                                     String implVendor, URL sealBase)
2194     {
2195         Objects.requireNonNull(name);
2196 
2197         // definePackage is not final and may be overridden by custom class loader
2198         Package p = new Package(name, specTitle, specVersion, specVendor,
2199                                 implTitle, implVersion, implVendor,
2200                                 sealBase, this);
2201 
2202         if (packages.putIfAbsent(name, p) != null)
2203             throw new IllegalArgumentException(name);
2204 
2205         return p;
2206     }
2207 
2208     /**
2209      * Returns a {@code Package} of the given &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; that
2210      * has been defined by this class loader.
2211      *
2212      * @param  name The &lt;a href=&quot;#binary-name&quot;&gt;package name&lt;/a&gt;
2213      *
2214      * @return The {@code Package} of the given name that has been defined
2215      *         by this class loader, or {@code null} if not found
2216      *
2217      * @throws  NullPointerException
2218      *          if {@code name} is {@code null}.
2219      *
<span class="line-modified">2220      * @jvms 5.3 Creation and Loading</span>
2221      *
2222      * @since  9
2223      * @spec JPMS
2224      */
2225     public final Package getDefinedPackage(String name) {
2226         Objects.requireNonNull(name, &quot;name cannot be null&quot;);
2227 
2228         NamedPackage p = packages.get(name);
2229         if (p == null)
2230             return null;
2231 
2232         return definePackage(name, p.module());
2233     }
2234 
2235     /**
2236      * Returns all of the {@code Package}s that have been defined by
2237      * this class loader.  The returned array has no duplicated {@code Package}s
2238      * of the same name.
2239      *
2240      * @apiNote This method returns an array rather than a {@code Set} or {@code Stream}
2241      *          for consistency with the existing {@link #getPackages} method.
2242      *
2243      * @return The array of {@code Package} objects that have been defined by
2244      *         this class loader; or an zero length array if no package has been
2245      *         defined by this class loader.
2246      *
<span class="line-modified">2247      * @jvms 5.3 Creation and Loading</span>
2248      *
2249      * @since  9
2250      * @spec JPMS
2251      */
2252     public final Package[] getDefinedPackages() {
2253         return packages().toArray(Package[]::new);
2254     }
2255 
2256     /**
2257      * Finds a package by &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; in this class loader and its ancestors.
2258      * &lt;p&gt;
2259      * If this class loader defines a {@code Package} of the given name,
2260      * the {@code Package} is returned. Otherwise, the ancestors of
2261      * this class loader are searched recursively (parent by parent)
2262      * for a {@code Package} of the given name.
2263      *
2264      * @apiNote The {@link #getPlatformClassLoader() platform class loader}
2265      * may delegate to the application class loader but the application class
2266      * loader is not its ancestor.  When invoked on the platform class loader,
2267      * this method  will not find packages defined to the application
</pre>
<hr />
<pre>
2445                 fromClass == null ? null : fromClass.getClassLoader();
2446 
2447             synchronized (loadedLibraryNames) {
2448                 Map&lt;String, NativeLibrary&gt; libs =
2449                     loader != null ? loader.nativeLibraries() : systemNativeLibraries();
2450                 if (libs.containsKey(name)) {
2451                     return true;
2452                 }
2453 
2454                 if (loadedLibraryNames.contains(name)) {
2455                     throw new UnsatisfiedLinkError(&quot;Native Library &quot; + name +
2456                         &quot; already loaded in another classloader&quot;);
2457                 }
2458 
2459                 /*
2460                  * When a library is being loaded, JNI_OnLoad function can cause
2461                  * another loadLibrary invocation that should succeed.
2462                  *
2463                  * We use a static stack to hold the list of libraries we are
2464                  * loading because this can happen only when called by the
<span class="line-modified">2465                  * same thread because this block is synchronous.</span>

2466                  *
2467                  * If there is a pending load operation for the library, we
2468                  * immediately return success; otherwise, we raise
2469                  * UnsatisfiedLinkError.
2470                  */
2471                 for (NativeLibrary lib : nativeLibraryContext) {
2472                     if (name.equals(lib.name)) {
2473                         if (loader == lib.fromClass.getClassLoader()) {
2474                             return true;
2475                         } else {
2476                             throw new UnsatisfiedLinkError(&quot;Native Library &quot; +
2477                                 name + &quot; is being loaded in another classloader&quot;);
2478                         }
2479                     }
2480                 }
2481                 NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);
2482                 // load the native library
2483                 nativeLibraryContext.push(lib);
2484                 try {
2485                     if (!lib.load()) return false;
</pre>
<hr />
<pre>
2530             public void run() {
2531                 synchronized (loadedLibraryNames) {
2532                     /* remove the native library name */
2533                     loadedLibraryNames.remove(name);
2534                     nativeLibraryContext.push(UNLOADER);
2535                     try {
2536                         unload(name, isBuiltin, handle);
2537                     } finally {
2538                         nativeLibraryContext.pop();
2539                     }
2540 
2541                 }
2542             }
2543         }
2544 
2545         // JNI FindClass expects the caller class if invoked from JNI_OnLoad
2546         // and JNI_OnUnload is NativeLibrary class
2547         static native void unload(String name, boolean isBuiltin, long handle);
2548     }
2549 
<span class="line-modified">2550     /**</span>
<span class="line-modified">2551      * Holds system and user library paths derived from the</span>
<span class="line-modified">2552      * {@code java.library.path} and {@code sun.boot.library.path} system</span>
<span class="line-modified">2553      * properties. The system properties are eagerly read at bootstrap, then</span>
<span class="line-modified">2554      * lazily parsed on first use to avoid initialization ordering issues.</span>
<span class="line-modified">2555      */</span>
<span class="line-modified">2556     private static class LibraryPaths {</span>
<span class="line-modified">2557         static final String[] USER =</span>
<span class="line-modified">2558                 ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());</span>
<span class="line-modified">2559         static final String[] SYS =</span>
<span class="line-modified">2560                 ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());</span>










































2561     }
2562 
2563     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
2564     static void loadLibrary(Class&lt;?&gt; fromClass, String name,
2565                             boolean isAbsolute) {
2566         ClassLoader loader =
2567             (fromClass == null) ? null : fromClass.getClassLoader();
<span class="line-modified">2568 </span>



2569         if (isAbsolute) {
2570             if (loadLibrary0(fromClass, new File(name))) {
2571                 return;
2572             }
2573             throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);
2574         }
2575         if (loader != null) {
2576             String libfilename = loader.findLibrary(name);
2577             if (libfilename != null) {
2578                 File libfile = new File(libfilename);
2579                 if (!libfile.isAbsolute()) {
2580                     throw new UnsatisfiedLinkError(
2581                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
2582                 }
2583                 if (loadLibrary0(fromClass, libfile)) {
2584                     return;
2585                 }
2586                 throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);
2587             }
2588         }
<span class="line-modified">2589         for (String sysPath : LibraryPaths.SYS) {</span>
<span class="line-modified">2590             File libfile = new File(sysPath, System.mapLibraryName(name));</span>
2591             if (loadLibrary0(fromClass, libfile)) {
2592                 return;
2593             }
2594             libfile = ClassLoaderHelper.mapAlternativeName(libfile);
2595             if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
2596                 return;
2597             }
2598         }
2599         if (loader != null) {
<span class="line-modified">2600             for (String userPath : LibraryPaths.USER) {</span>
<span class="line-modified">2601                 File libfile = new File(userPath, System.mapLibraryName(name));</span>
2602                 if (loadLibrary0(fromClass, libfile)) {
2603                     return;
2604                 }
2605                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);
2606                 if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
2607                     return;
2608                 }
2609             }
2610         }
2611         // Oops, it failed
2612         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">2613             &quot; in java.library.path: &quot; + Arrays.toString(LibraryPaths.USER));</span>
2614     }
2615 
2616     private static native String findBuiltinLib(String name);
2617 
2618     private static boolean loadLibrary0(Class&lt;?&gt; fromClass, final File file) {
2619         // Check to see if we&#39;re attempting to access a static library
2620         String name = findBuiltinLib(file.getName());
2621         boolean isBuiltin = (name != null);
2622         if (!isBuiltin) {
2623             name = AccessController.doPrivileged(
2624                 new PrivilegedAction&lt;&gt;() {
2625                     public String run() {
2626                         try {
2627                             return file.exists() ? file.getCanonicalPath() : null;
2628                         } catch (IOException e) {
2629                             return null;
2630                         }
2631                     }
2632                 });
2633             if (name == null) {
</pre>
</td>
</tr>
</table>
<center><a href="ClassFormatError.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassNotFoundException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
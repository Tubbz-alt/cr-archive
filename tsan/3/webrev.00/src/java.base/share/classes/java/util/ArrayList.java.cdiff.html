<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/ArrayList.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayDeque.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayPrefixHelpers.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ArrayList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  
  import java.util.function.Consumer;
  import java.util.function.Predicate;
  import java.util.function.UnaryOperator;
  import jdk.internal.access.SharedSecrets;
<span class="line-added">+ import jdk.internal.util.ArraysSupport;</span>
  
  /**
   * Resizable-array implementation of the {@code List} interface.  Implements
   * all optional list operations, and permits all elements, including
   * {@code null}.  In addition to implementing the {@code List} interface,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,10 ***</span>
<span class="line-new-header">--- 107,11 ---</span>
   * @since   1.2
   */
  public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
          implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
  {
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 8683452581122892189L;
  
      /**
       * Default initial capacity.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,65 ***</span>
              modCount++;
              grow(minCapacity);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The maximum size of array to allocate (unless necessary).</span>
<span class="line-removed">-      * Some VMs reserve some header words in an array.</span>
<span class="line-removed">-      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed">-      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed">- </span>
      /**
       * Increases the capacity to ensure that it can hold at least the
       * number of elements specified by the minimum capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       * @throws OutOfMemoryError if minCapacity is less than zero
       */
      private Object[] grow(int minCapacity) {
<span class="line-removed">-         return elementData = Arrays.copyOf(elementData,</span>
<span class="line-removed">-                                            newCapacity(minCapacity));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private Object[] grow() {</span>
<span class="line-removed">-         return grow(size + 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Returns a capacity at least as large as the given minimum capacity.</span>
<span class="line-removed">-      * Returns the current capacity increased by 50% if that suffices.</span>
<span class="line-removed">-      * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span>
<span class="line-removed">-      * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param minCapacity the desired minimum capacity</span>
<span class="line-removed">-      * @throws OutOfMemoryError if minCapacity is less than zero</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private int newCapacity(int minCapacity) {</span>
<span class="line-removed">-         // overflow-conscious code</span>
          int oldCapacity = elementData.length;
<span class="line-modified">!         int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span>
<span class="line-modified">!         if (newCapacity - minCapacity &lt;= 0) {</span>
<span class="line-modified">!             if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span>
<span class="line-modified">!                 return Math.max(DEFAULT_CAPACITY, minCapacity);</span>
<span class="line-modified">!             if (minCapacity &lt; 0) // overflow</span>
<span class="line-modified">!                 throw new OutOfMemoryError();</span>
<span class="line-modified">!             return minCapacity;</span>
          }
<span class="line-removed">-         return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)</span>
<span class="line-removed">-             ? newCapacity</span>
<span class="line-removed">-             : hugeCapacity(minCapacity);</span>
      }
  
<span class="line-modified">!     private static int hugeCapacity(int minCapacity) {</span>
<span class="line-modified">!         if (minCapacity &lt; 0) // overflow</span>
<span class="line-removed">-             throw new OutOfMemoryError();</span>
<span class="line-removed">-         return (minCapacity &gt; MAX_ARRAY_SIZE)</span>
<span class="line-removed">-             ? Integer.MAX_VALUE</span>
<span class="line-removed">-             : MAX_ARRAY_SIZE;</span>
      }
  
      /**
       * Returns the number of elements in this list.
       *
<span class="line-new-header">--- 218,31 ---</span>
              modCount++;
              grow(minCapacity);
          }
      }
  
      /**
       * Increases the capacity to ensure that it can hold at least the
       * number of elements specified by the minimum capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       * @throws OutOfMemoryError if minCapacity is less than zero
       */
      private Object[] grow(int minCapacity) {
          int oldCapacity = elementData.length;
<span class="line-modified">!         if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span>
<span class="line-modified">!             int newCapacity = ArraysSupport.newLength(oldCapacity,</span>
<span class="line-modified">!                     minCapacity - oldCapacity, /* minimum growth */</span>
<span class="line-modified">!                     oldCapacity &gt;&gt; 1           /* preferred growth */);</span>
<span class="line-modified">!             return elementData = Arrays.copyOf(elementData, newCapacity);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span>
          }
      }
  
<span class="line-modified">!     private Object[] grow() {</span>
<span class="line-modified">!         return grow(size + 1);</span>
      }
  
      /**
       * Returns the number of elements in this list.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,10 ***</span>
<span class="line-new-header">--- 848,11 ---</span>
       * @throws java.io.IOException if an I/O error occurs
       * @serialData The length of the array backing the {@code ArrayList}
       *             instance is emitted (int), followed by all of its elements
       *             (each an {@code Object}) in the proper order.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(java.io.ObjectOutputStream s)
          throws java.io.IOException {
          // Write out element count, and any hidden stuff
          int expectedModCount = modCount;
          s.defaultWriteObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 907,10 ***</span>
<span class="line-new-header">--- 876,11 ---</span>
       * @param s the stream
       * @throws ClassNotFoundException if the class of a serialized object
       *         could not be found
       * @throws java.io.IOException if an I/O error occurs
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(java.io.ObjectInputStream s)
          throws java.io.IOException, ClassNotFoundException {
  
          // Read in size, and any hidden stuff
          s.defaultReadObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1161,11 ***</span>
          private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
              this.root = parent.root;
              this.parent = parent;
              this.offset = parent.offset + fromIndex;
              this.size = toIndex - fromIndex;
<span class="line-modified">!             this.modCount = root.modCount;</span>
          }
  
          public E set(int index, E element) {
              Objects.checkIndex(index, size);
              checkForComodification();
<span class="line-new-header">--- 1131,11 ---</span>
          private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
              this.root = parent.root;
              this.parent = parent;
              this.offset = parent.offset + fromIndex;
              this.size = toIndex - fromIndex;
<span class="line-modified">!             this.modCount = parent.modCount;</span>
          }
  
          public E set(int index, E element) {
              Objects.checkIndex(index, size);
              checkForComodification();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1314,11 ***</span>
              rangeCheckForAdd(index);
  
              return new ListIterator&lt;E&gt;() {
                  int cursor = index;
                  int lastRet = -1;
<span class="line-modified">!                 int expectedModCount = root.modCount;</span>
  
                  public boolean hasNext() {
                      return cursor != SubList.this.size;
                  }
  
<span class="line-new-header">--- 1284,11 ---</span>
              rangeCheckForAdd(index);
  
              return new ListIterator&lt;E&gt;() {
                  int cursor = index;
                  int lastRet = -1;
<span class="line-modified">!                 int expectedModCount = SubList.this.modCount;</span>
  
                  public boolean hasNext() {
                      return cursor != SubList.this.size;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1358,11 ***</span>
                      int i = cursor;
                      if (i &lt; size) {
                          final Object[] es = root.elementData;
                          if (offset + i &gt;= es.length)
                              throw new ConcurrentModificationException();
<span class="line-modified">!                         for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)</span>
                              action.accept(elementAt(es, offset + i));
                          // update once at end to reduce heap write traffic
                          cursor = i;
                          lastRet = i - 1;
                          checkForComodification();
<span class="line-new-header">--- 1328,11 ---</span>
                      int i = cursor;
                      if (i &lt; size) {
                          final Object[] es = root.elementData;
                          if (offset + i &gt;= es.length)
                              throw new ConcurrentModificationException();
<span class="line-modified">!                         for (; i &lt; size &amp;&amp; root.modCount == expectedModCount; i++)</span>
                              action.accept(elementAt(es, offset + i));
                          // update once at end to reduce heap write traffic
                          cursor = i;
                          lastRet = i - 1;
                          checkForComodification();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1384,11 ***</span>
  
                      try {
                          SubList.this.remove(lastRet);
                          cursor = lastRet;
                          lastRet = -1;
<span class="line-modified">!                         expectedModCount = root.modCount;</span>
                      } catch (IndexOutOfBoundsException ex) {
                          throw new ConcurrentModificationException();
                      }
                  }
  
<span class="line-new-header">--- 1354,11 ---</span>
  
                      try {
                          SubList.this.remove(lastRet);
                          cursor = lastRet;
                          lastRet = -1;
<span class="line-modified">!                         expectedModCount = SubList.this.modCount;</span>
                      } catch (IndexOutOfBoundsException ex) {
                          throw new ConcurrentModificationException();
                      }
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1410,11 ***</span>
                      try {
                          int i = cursor;
                          SubList.this.add(i, e);
                          cursor = i + 1;
                          lastRet = -1;
<span class="line-modified">!                         expectedModCount = root.modCount;</span>
                      } catch (IndexOutOfBoundsException ex) {
                          throw new ConcurrentModificationException();
                      }
                  }
  
<span class="line-new-header">--- 1380,11 ---</span>
                      try {
                          int i = cursor;
                          SubList.this.add(i, e);
                          cursor = i + 1;
                          lastRet = -1;
<span class="line-modified">!                         expectedModCount = SubList.this.modCount;</span>
                      } catch (IndexOutOfBoundsException ex) {
                          throw new ConcurrentModificationException();
                      }
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1727,10 ***</span>
<span class="line-new-header">--- 1697,11 ---</span>
      }
  
      @Override
      public void replaceAll(UnaryOperator&lt;E&gt; operator) {
          replaceAllRange(operator, 0, size);
<span class="line-added">+         // TODO(8203662): remove increment of modCount from ...</span>
          modCount++;
      }
  
      private void replaceAllRange(UnaryOperator&lt;E&gt; operator, int i, int end) {
          Objects.requireNonNull(operator);
</pre>
<center><a href="ArrayDeque.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayPrefixHelpers.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
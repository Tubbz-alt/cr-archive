<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/HashMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="GregorianCalendar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/HashMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 121  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 122  * Java Collections Framework&lt;/a&gt;.
 123  *
 124  * @param &lt;K&gt; the type of keys maintained by this map
 125  * @param &lt;V&gt; the type of mapped values
 126  *
 127  * @author  Doug Lea
 128  * @author  Josh Bloch
 129  * @author  Arthur van Hoff
 130  * @author  Neal Gafter
 131  * @see     Object#hashCode()
 132  * @see     Collection
 133  * @see     Map
 134  * @see     TreeMap
 135  * @see     Hashtable
 136  * @since   1.2
 137  */
 138 public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
 139     implements Map&lt;K,V&gt;, Cloneable, Serializable {
 140 

 141     private static final long serialVersionUID = 362498820763181265L;
 142 
 143     /*
 144      * Implementation notes.
 145      *
 146      * This map usually acts as a binned (bucketed) hash table, but
 147      * when bins get too large, they are transformed into bins of
 148      * TreeNodes, each structured similarly to those in
 149      * java.util.TreeMap. Most methods try to use normal bins, but
 150      * relay to TreeNode methods when applicable (simply by checking
 151      * instanceof a node).  Bins of TreeNodes may be traversed and
 152      * used like any others, but additionally support faster lookup
 153      * when overpopulated. However, since the vast majority of bins in
 154      * normal use are not overpopulated, checking for existence of
 155      * tree bins may be delayed in the course of table methods.
 156      *
 157      * Tree bins (i.e., bins whose elements are all TreeNodes) are
 158      * ordered primarily by hashCode, but in the case of ties, if two
 159      * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,
 160      * type then their compareTo method is used for ordering. (We
</pre>
<hr />
<pre>
 894      * while an iteration over the set is in progress (except through
 895      * the iterator&#39;s own {@code remove} operation), the results of
 896      * the iteration are undefined.  The set supports element removal,
 897      * which removes the corresponding mapping from the map, via the
 898      * {@code Iterator.remove}, {@code Set.remove},
 899      * {@code removeAll}, {@code retainAll}, and {@code clear}
 900      * operations.  It does not support the {@code add} or {@code addAll}
 901      * operations.
 902      *
 903      * @return a set view of the keys contained in this map
 904      */
 905     public Set&lt;K&gt; keySet() {
 906         Set&lt;K&gt; ks = keySet;
 907         if (ks == null) {
 908             ks = new KeySet();
 909             keySet = ks;
 910         }
 911         return ks;
 912     }
 913 




































































 914     final class KeySet extends AbstractSet&lt;K&gt; {
 915         public final int size()                 { return size; }
 916         public final void clear()               { HashMap.this.clear(); }
 917         public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }
 918         public final boolean contains(Object o) { return containsKey(o); }
 919         public final boolean remove(Object key) {
 920             return removeNode(hash(key), key, null, false, true) != null;
 921         }
 922         public final Spliterator&lt;K&gt; spliterator() {
 923             return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
 924         }









 925         public final void forEach(Consumer&lt;? super K&gt; action) {
 926             Node&lt;K,V&gt;[] tab;
 927             if (action == null)
 928                 throw new NullPointerException();
 929             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
 930                 int mc = modCount;
 931                 for (Node&lt;K,V&gt; e : tab) {
 932                     for (; e != null; e = e.next)
 933                         action.accept(e.key);
 934                 }
 935                 if (modCount != mc)
 936                     throw new ConcurrentModificationException();
 937             }
 938         }
 939     }
 940 
 941     /**
 942      * Returns a {@link Collection} view of the values contained in this map.
 943      * The collection is backed by the map, so changes to the map are
 944      * reflected in the collection, and vice-versa.  If the map is
</pre>
<hr />
<pre>
 953      *
 954      * @return a view of the values contained in this map
 955      */
 956     public Collection&lt;V&gt; values() {
 957         Collection&lt;V&gt; vs = values;
 958         if (vs == null) {
 959             vs = new Values();
 960             values = vs;
 961         }
 962         return vs;
 963     }
 964 
 965     final class Values extends AbstractCollection&lt;V&gt; {
 966         public final int size()                 { return size; }
 967         public final void clear()               { HashMap.this.clear(); }
 968         public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }
 969         public final boolean contains(Object o) { return containsValue(o); }
 970         public final Spliterator&lt;V&gt; spliterator() {
 971             return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
 972         }









 973         public final void forEach(Consumer&lt;? super V&gt; action) {
 974             Node&lt;K,V&gt;[] tab;
 975             if (action == null)
 976                 throw new NullPointerException();
 977             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
 978                 int mc = modCount;
 979                 for (Node&lt;K,V&gt; e : tab) {
 980                     for (; e != null; e = e.next)
 981                         action.accept(e.value);
 982                 }
 983                 if (modCount != mc)
 984                     throw new ConcurrentModificationException();
 985             }
 986         }
 987     }
 988 
 989     /**
 990      * Returns a {@link Set} view of the mappings contained in this map.
 991      * The set is backed by the map, so changes to the map are
 992      * reflected in the set, and vice-versa.  If the map is modified
</pre>
<hr />
<pre>
1386     // These methods are also used when serializing HashSets
1387     final float loadFactor() { return loadFactor; }
1388     final int capacity() {
1389         return (table != null) ? table.length :
1390             (threshold &gt; 0) ? threshold :
1391             DEFAULT_INITIAL_CAPACITY;
1392     }
1393 
1394     /**
1395      * Saves this map to a stream (that is, serializes it).
1396      *
1397      * @param s the stream
1398      * @throws IOException if an I/O error occurs
1399      * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
1400      *             bucket array) is emitted (int), followed by the
1401      *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
1402      *             mappings), followed by the key (Object) and value (Object)
1403      *             for each key-value mapping.  The key-value mappings are
1404      *             emitted in no particular order.
1405      */

1406     private void writeObject(java.io.ObjectOutputStream s)
1407         throws IOException {
1408         int buckets = capacity();
1409         // Write out the threshold, loadfactor, and any hidden stuff
1410         s.defaultWriteObject();
1411         s.writeInt(buckets);
1412         s.writeInt(size);
1413         internalWriteEntries(s);
1414     }
1415 
1416     /**
1417      * Reconstitutes this map from a stream (that is, deserializes it).
1418      * @param s the stream
1419      * @throws ClassNotFoundException if the class of a serialized object
1420      *         could not be found
1421      * @throws IOException if an I/O error occurs
1422      */

1423     private void readObject(java.io.ObjectInputStream s)
1424         throws IOException, ClassNotFoundException {
1425         // Read in the threshold (ignored), loadfactor, and any hidden stuff
1426         s.defaultReadObject();
1427         reinitialize();
1428         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
1429             throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
1430                                              loadFactor);
1431         s.readInt();                // Read and ignore number of buckets
1432         int mappings = s.readInt(); // Read number of mappings (size)
1433         if (mappings &lt; 0)
1434             throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
1435                                              mappings);
1436         else if (mappings &gt; 0) { // (if zero, use defaults)
1437             // Size the table using given load factor only if within
1438             // range of 0.25...4.0
1439             float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
1440             float fc = (float)mappings / lf + 1.0f;
1441             int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
1442                        DEFAULT_INITIAL_CAPACITY :
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 121  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 122  * Java Collections Framework&lt;/a&gt;.
 123  *
 124  * @param &lt;K&gt; the type of keys maintained by this map
 125  * @param &lt;V&gt; the type of mapped values
 126  *
 127  * @author  Doug Lea
 128  * @author  Josh Bloch
 129  * @author  Arthur van Hoff
 130  * @author  Neal Gafter
 131  * @see     Object#hashCode()
 132  * @see     Collection
 133  * @see     Map
 134  * @see     TreeMap
 135  * @see     Hashtable
 136  * @since   1.2
 137  */
 138 public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
 139     implements Map&lt;K,V&gt;, Cloneable, Serializable {
 140 
<span class="line-added"> 141     @java.io.Serial</span>
 142     private static final long serialVersionUID = 362498820763181265L;
 143 
 144     /*
 145      * Implementation notes.
 146      *
 147      * This map usually acts as a binned (bucketed) hash table, but
 148      * when bins get too large, they are transformed into bins of
 149      * TreeNodes, each structured similarly to those in
 150      * java.util.TreeMap. Most methods try to use normal bins, but
 151      * relay to TreeNode methods when applicable (simply by checking
 152      * instanceof a node).  Bins of TreeNodes may be traversed and
 153      * used like any others, but additionally support faster lookup
 154      * when overpopulated. However, since the vast majority of bins in
 155      * normal use are not overpopulated, checking for existence of
 156      * tree bins may be delayed in the course of table methods.
 157      *
 158      * Tree bins (i.e., bins whose elements are all TreeNodes) are
 159      * ordered primarily by hashCode, but in the case of ties, if two
 160      * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,
 161      * type then their compareTo method is used for ordering. (We
</pre>
<hr />
<pre>
 895      * while an iteration over the set is in progress (except through
 896      * the iterator&#39;s own {@code remove} operation), the results of
 897      * the iteration are undefined.  The set supports element removal,
 898      * which removes the corresponding mapping from the map, via the
 899      * {@code Iterator.remove}, {@code Set.remove},
 900      * {@code removeAll}, {@code retainAll}, and {@code clear}
 901      * operations.  It does not support the {@code add} or {@code addAll}
 902      * operations.
 903      *
 904      * @return a set view of the keys contained in this map
 905      */
 906     public Set&lt;K&gt; keySet() {
 907         Set&lt;K&gt; ks = keySet;
 908         if (ks == null) {
 909             ks = new KeySet();
 910             keySet = ks;
 911         }
 912         return ks;
 913     }
 914 
<span class="line-added"> 915     /**</span>
<span class="line-added"> 916      * Prepares the array for {@link Collection#toArray(Object[])} implementation.</span>
<span class="line-added"> 917      * If supplied array is smaller than this map size, a new array is allocated.</span>
<span class="line-added"> 918      * If supplied array is bigger than this map size, a null is written at size index.</span>
<span class="line-added"> 919      *</span>
<span class="line-added"> 920      * @param a an original array passed to {@code toArray()} method</span>
<span class="line-added"> 921      * @param &lt;T&gt; type of array elements</span>
<span class="line-added"> 922      * @return an array ready to be filled and returned from {@code toArray()} method.</span>
<span class="line-added"> 923      */</span>
<span class="line-added"> 924     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added"> 925     final &lt;T&gt; T[] prepareArray(T[] a) {</span>
<span class="line-added"> 926         int size = this.size;</span>
<span class="line-added"> 927         if (a.length &lt; size) {</span>
<span class="line-added"> 928             return (T[]) java.lang.reflect.Array</span>
<span class="line-added"> 929                     .newInstance(a.getClass().getComponentType(), size);</span>
<span class="line-added"> 930         }</span>
<span class="line-added"> 931         if (a.length &gt; size) {</span>
<span class="line-added"> 932             a[size] = null;</span>
<span class="line-added"> 933         }</span>
<span class="line-added"> 934         return a;</span>
<span class="line-added"> 935     }</span>
<span class="line-added"> 936 </span>
<span class="line-added"> 937     /**</span>
<span class="line-added"> 938      * Fills an array with this map keys and returns it. This method assumes</span>
<span class="line-added"> 939      * that input array is big enough to fit all the keys. Use</span>
<span class="line-added"> 940      * {@link #prepareArray(Object[])} to ensure this.</span>
<span class="line-added"> 941      *</span>
<span class="line-added"> 942      * @param a an array to fill</span>
<span class="line-added"> 943      * @param &lt;T&gt; type of array elements</span>
<span class="line-added"> 944      * @return supplied array</span>
<span class="line-added"> 945      */</span>
<span class="line-added"> 946     &lt;T&gt; T[] keysToArray(T[] a) {</span>
<span class="line-added"> 947         Object[] r = a;</span>
<span class="line-added"> 948         Node&lt;K,V&gt;[] tab;</span>
<span class="line-added"> 949         int idx = 0;</span>
<span class="line-added"> 950         if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="line-added"> 951             for (Node&lt;K,V&gt; e : tab) {</span>
<span class="line-added"> 952                 for (; e != null; e = e.next) {</span>
<span class="line-added"> 953                     r[idx++] = e.key;</span>
<span class="line-added"> 954                 }</span>
<span class="line-added"> 955             }</span>
<span class="line-added"> 956         }</span>
<span class="line-added"> 957         return a;</span>
<span class="line-added"> 958     }</span>
<span class="line-added"> 959 </span>
<span class="line-added"> 960     /**</span>
<span class="line-added"> 961      * Fills an array with this map values and returns it. This method assumes</span>
<span class="line-added"> 962      * that input array is big enough to fit all the values. Use</span>
<span class="line-added"> 963      * {@link #prepareArray(Object[])} to ensure this.</span>
<span class="line-added"> 964      *</span>
<span class="line-added"> 965      * @param a an array to fill</span>
<span class="line-added"> 966      * @param &lt;T&gt; type of array elements</span>
<span class="line-added"> 967      * @return supplied array</span>
<span class="line-added"> 968      */</span>
<span class="line-added"> 969     &lt;T&gt; T[] valuesToArray(T[] a) {</span>
<span class="line-added"> 970         Object[] r = a;</span>
<span class="line-added"> 971         Node&lt;K,V&gt;[] tab;</span>
<span class="line-added"> 972         int idx = 0;</span>
<span class="line-added"> 973         if (size &gt; 0 &amp;&amp; (tab = table) != null) {</span>
<span class="line-added"> 974             for (Node&lt;K,V&gt; e : tab) {</span>
<span class="line-added"> 975                 for (; e != null; e = e.next) {</span>
<span class="line-added"> 976                     r[idx++] = e.value;</span>
<span class="line-added"> 977                 }</span>
<span class="line-added"> 978             }</span>
<span class="line-added"> 979         }</span>
<span class="line-added"> 980         return a;</span>
<span class="line-added"> 981     }</span>
<span class="line-added"> 982 </span>
 983     final class KeySet extends AbstractSet&lt;K&gt; {
 984         public final int size()                 { return size; }
 985         public final void clear()               { HashMap.this.clear(); }
 986         public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }
 987         public final boolean contains(Object o) { return containsKey(o); }
 988         public final boolean remove(Object key) {
 989             return removeNode(hash(key), key, null, false, true) != null;
 990         }
 991         public final Spliterator&lt;K&gt; spliterator() {
 992             return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
 993         }
<span class="line-added"> 994 </span>
<span class="line-added"> 995         public Object[] toArray() {</span>
<span class="line-added"> 996             return keysToArray(new Object[size]);</span>
<span class="line-added"> 997         }</span>
<span class="line-added"> 998 </span>
<span class="line-added"> 999         public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="line-added">1000             return keysToArray(prepareArray(a));</span>
<span class="line-added">1001         }</span>
<span class="line-added">1002 </span>
1003         public final void forEach(Consumer&lt;? super K&gt; action) {
1004             Node&lt;K,V&gt;[] tab;
1005             if (action == null)
1006                 throw new NullPointerException();
1007             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1008                 int mc = modCount;
1009                 for (Node&lt;K,V&gt; e : tab) {
1010                     for (; e != null; e = e.next)
1011                         action.accept(e.key);
1012                 }
1013                 if (modCount != mc)
1014                     throw new ConcurrentModificationException();
1015             }
1016         }
1017     }
1018 
1019     /**
1020      * Returns a {@link Collection} view of the values contained in this map.
1021      * The collection is backed by the map, so changes to the map are
1022      * reflected in the collection, and vice-versa.  If the map is
</pre>
<hr />
<pre>
1031      *
1032      * @return a view of the values contained in this map
1033      */
1034     public Collection&lt;V&gt; values() {
1035         Collection&lt;V&gt; vs = values;
1036         if (vs == null) {
1037             vs = new Values();
1038             values = vs;
1039         }
1040         return vs;
1041     }
1042 
1043     final class Values extends AbstractCollection&lt;V&gt; {
1044         public final int size()                 { return size; }
1045         public final void clear()               { HashMap.this.clear(); }
1046         public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }
1047         public final boolean contains(Object o) { return containsValue(o); }
1048         public final Spliterator&lt;V&gt; spliterator() {
1049             return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
1050         }
<span class="line-added">1051 </span>
<span class="line-added">1052         public Object[] toArray() {</span>
<span class="line-added">1053             return valuesToArray(new Object[size]);</span>
<span class="line-added">1054         }</span>
<span class="line-added">1055 </span>
<span class="line-added">1056         public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="line-added">1057             return valuesToArray(prepareArray(a));</span>
<span class="line-added">1058         }</span>
<span class="line-added">1059 </span>
1060         public final void forEach(Consumer&lt;? super V&gt; action) {
1061             Node&lt;K,V&gt;[] tab;
1062             if (action == null)
1063                 throw new NullPointerException();
1064             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1065                 int mc = modCount;
1066                 for (Node&lt;K,V&gt; e : tab) {
1067                     for (; e != null; e = e.next)
1068                         action.accept(e.value);
1069                 }
1070                 if (modCount != mc)
1071                     throw new ConcurrentModificationException();
1072             }
1073         }
1074     }
1075 
1076     /**
1077      * Returns a {@link Set} view of the mappings contained in this map.
1078      * The set is backed by the map, so changes to the map are
1079      * reflected in the set, and vice-versa.  If the map is modified
</pre>
<hr />
<pre>
1473     // These methods are also used when serializing HashSets
1474     final float loadFactor() { return loadFactor; }
1475     final int capacity() {
1476         return (table != null) ? table.length :
1477             (threshold &gt; 0) ? threshold :
1478             DEFAULT_INITIAL_CAPACITY;
1479     }
1480 
1481     /**
1482      * Saves this map to a stream (that is, serializes it).
1483      *
1484      * @param s the stream
1485      * @throws IOException if an I/O error occurs
1486      * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
1487      *             bucket array) is emitted (int), followed by the
1488      *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
1489      *             mappings), followed by the key (Object) and value (Object)
1490      *             for each key-value mapping.  The key-value mappings are
1491      *             emitted in no particular order.
1492      */
<span class="line-added">1493     @java.io.Serial</span>
1494     private void writeObject(java.io.ObjectOutputStream s)
1495         throws IOException {
1496         int buckets = capacity();
1497         // Write out the threshold, loadfactor, and any hidden stuff
1498         s.defaultWriteObject();
1499         s.writeInt(buckets);
1500         s.writeInt(size);
1501         internalWriteEntries(s);
1502     }
1503 
1504     /**
1505      * Reconstitutes this map from a stream (that is, deserializes it).
1506      * @param s the stream
1507      * @throws ClassNotFoundException if the class of a serialized object
1508      *         could not be found
1509      * @throws IOException if an I/O error occurs
1510      */
<span class="line-added">1511     @java.io.Serial</span>
1512     private void readObject(java.io.ObjectInputStream s)
1513         throws IOException, ClassNotFoundException {
1514         // Read in the threshold (ignored), loadfactor, and any hidden stuff
1515         s.defaultReadObject();
1516         reinitialize();
1517         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
1518             throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
1519                                              loadFactor);
1520         s.readInt();                // Read and ignore number of buckets
1521         int mappings = s.readInt(); // Read number of mappings (size)
1522         if (mappings &lt; 0)
1523             throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
1524                                              mappings);
1525         else if (mappings &gt; 0) { // (if zero, use defaults)
1526             // Size the table using given load factor only if within
1527             // range of 0.25...4.0
1528             float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
1529             float fc = (float)mappings / lf + 1.0f;
1530             int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
1531                        DEFAULT_INITIAL_CAPACITY :
</pre>
</td>
</tr>
</table>
<center><a href="GregorianCalendar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
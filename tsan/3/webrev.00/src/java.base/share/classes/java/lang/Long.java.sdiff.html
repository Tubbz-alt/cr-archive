<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Long.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="LiveStackFrame.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Math.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Long.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 381      * Format a long (treated as unsigned) into a String.
 382      * @param val the value to format
 383      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
 384      */
 385     static String toUnsignedString0(long val, int shift) {
 386         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
 387         int mag = Long.SIZE - Long.numberOfLeadingZeros(val);
 388         int chars = Math.max(((mag + (shift - 1)) / shift), 1);
 389         if (COMPACT_STRINGS) {
 390             byte[] buf = new byte[chars];
 391             formatUnsignedLong0(val, shift, buf, 0, chars);
 392             return new String(buf, LATIN1);
 393         } else {
 394             byte[] buf = new byte[chars * 2];
 395             formatUnsignedLong0UTF16(val, shift, buf, 0, chars);
 396             return new String(buf, UTF16);
 397         }
 398     }
 399 
 400     /**
<span class="line-modified"> 401      * Format a long (treated as unsigned) into a character buffer. If</span>
 402      * {@code len} exceeds the formatted ASCII representation of {@code val},
 403      * {@code buf} will be padded with leading zeroes.
 404      *
 405      * @param val the unsigned long to format
 406      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified"> 407      * @param buf the character buffer to write to</span>
 408      * @param offset the offset in the destination buffer to start at
 409      * @param len the number of characters to write
 410      */
<span class="line-modified"> 411 </span>
<span class="line-removed"> 412     /** byte[]/LATIN1 version    */</span>
<span class="line-removed"> 413     static void formatUnsignedLong0(long val, int shift, byte[] buf, int offset, int len) {</span>
 414         int charPos = offset + len;
 415         int radix = 1 &lt;&lt; shift;
 416         int mask = radix - 1;
 417         do {
 418             buf[--charPos] = (byte)Integer.digits[((int) val) &amp; mask];
 419             val &gt;&gt;&gt;= shift;
 420         } while (charPos &gt; offset);
 421     }
 422 
<span class="line-modified"> 423     /** byte[]/UTF16 version    */</span>










 424     private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {
 425         int charPos = offset + len;
 426         int radix = 1 &lt;&lt; shift;
 427         int mask = radix - 1;
 428         do {
 429             StringUTF16.putChar(buf, --charPos, Integer.digits[((int) val) &amp; mask]);
 430             val &gt;&gt;&gt;= shift;
 431         } while (charPos &gt; offset);
 432     }
 433 
 434     static String fastUUID(long lsb, long msb) {
 435         if (COMPACT_STRINGS) {
 436             byte[] buf = new byte[36];
 437             formatUnsignedLong0(lsb,        4, buf, 24, 12);
 438             formatUnsignedLong0(lsb &gt;&gt;&gt; 48, 4, buf, 19, 4);
 439             formatUnsignedLong0(msb,        4, buf, 14, 4);
 440             formatUnsignedLong0(msb &gt;&gt;&gt; 16, 4, buf, 9,  4);
 441             formatUnsignedLong0(msb &gt;&gt;&gt; 32, 4, buf, 0,  8);
 442 
 443             buf[23] = &#39;-&#39;;
</pre>
<hr />
<pre>
 722      *                  representation to be parsed
 723      * @param      beginIndex   the beginning index, inclusive.
 724      * @param      endIndex     the ending index, exclusive.
 725      * @param      radix   the radix to be used while parsing {@code s}.
 726      * @return     the signed {@code long} represented by the subsequence in
 727      *             the specified radix.
 728      * @throws     NullPointerException  if {@code s} is null.
 729      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 730      *             negative, or if {@code beginIndex} is greater than
 731      *             {@code endIndex} or if {@code endIndex} is greater than
 732      *             {@code s.length()}.
 733      * @throws     NumberFormatException  if the {@code CharSequence} does not
 734      *             contain a parsable {@code long} in the specified
 735      *             {@code radix}, or if {@code radix} is either smaller than
 736      *             {@link java.lang.Character#MIN_RADIX} or larger than
 737      *             {@link java.lang.Character#MAX_RADIX}.
 738      * @since  9
 739      */
 740     public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix)
 741                 throws NumberFormatException {
<span class="line-modified"> 742         s = Objects.requireNonNull(s);</span>
 743 
 744         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 745             throw new IndexOutOfBoundsException();
 746         }
 747         if (radix &lt; Character.MIN_RADIX) {
 748             throw new NumberFormatException(&quot;radix &quot; + radix +
 749                     &quot; less than Character.MIN_RADIX&quot;);
 750         }
 751         if (radix &gt; Character.MAX_RADIX) {
 752             throw new NumberFormatException(&quot;radix &quot; + radix +
 753                     &quot; greater than Character.MAX_RADIX&quot;);
 754         }
 755 
 756         boolean negative = false;
 757         int i = beginIndex;
 758         long limit = -Long.MAX_VALUE;
 759 
 760         if (i &lt; endIndex) {
 761             char firstChar = s.charAt(i);
 762             if (firstChar &lt; &#39;0&#39;) { // Possible leading &quot;+&quot; or &quot;-&quot;
</pre>
<hr />
<pre>
 968      *                 {@code long} representation to be parsed
 969      * @param      beginIndex   the beginning index, inclusive.
 970      * @param      endIndex     the ending index, exclusive.
 971      * @param      radix   the radix to be used while parsing {@code s}.
 972      * @return     the unsigned {@code long} represented by the subsequence in
 973      *             the specified radix.
 974      * @throws     NullPointerException  if {@code s} is null.
 975      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 976      *             negative, or if {@code beginIndex} is greater than
 977      *             {@code endIndex} or if {@code endIndex} is greater than
 978      *             {@code s.length()}.
 979      * @throws     NumberFormatException  if the {@code CharSequence} does not
 980      *             contain a parsable unsigned {@code long} in the specified
 981      *             {@code radix}, or if {@code radix} is either smaller than
 982      *             {@link java.lang.Character#MIN_RADIX} or larger than
 983      *             {@link java.lang.Character#MAX_RADIX}.
 984      * @since  9
 985      */
 986     public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix)
 987                 throws NumberFormatException {
<span class="line-modified"> 988         s = Objects.requireNonNull(s);</span>
 989 
 990         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 991             throw new IndexOutOfBoundsException();
 992         }
 993         int start = beginIndex, len = endIndex - beginIndex;
 994 
 995         if (len &gt; 0) {
 996             char firstChar = s.charAt(start);
 997             if (firstChar == &#39;-&#39;) {
 998                 throw new NumberFormatException(String.format(&quot;Illegal leading minus sign &quot; +
 999                         &quot;on unsigned string %s.&quot;, s.subSequence(start, start + len)));
1000             } else {
1001                 if (len &lt;= 12 || // Long.MAX_VALUE in Character.MAX_RADIX is 13 digits
1002                     (radix == 10 &amp;&amp; len &lt;= 18) ) { // Long.MAX_VALUE in base 10 is 19 digits
1003                     return parseLong(s, start, start + len, radix);
1004                 }
1005 
1006                 // No need for range checks on end due to testing above.
1007                 long first = parseLong(s, start, start + len - 1, radix);
1008                 int second = Character.digit(s.charAt(start + len - 1), radix);
</pre>
<hr />
<pre>
1322      *
1323      * @param      s   the {@code String} to be converted to a
1324      *             {@code Long}.
1325      * @throws     NumberFormatException  if the {@code String} does not
1326      *             contain a parsable {@code long}.
1327      *
1328      * @deprecated
1329      * It is rarely appropriate to use this constructor.
1330      * Use {@link #parseLong(String)} to convert a string to a
1331      * {@code long} primitive, or use {@link #valueOf(String)}
1332      * to convert a string to a {@code Long} object.
1333      */
1334     @Deprecated(since=&quot;9&quot;)
1335     public Long(String s) throws NumberFormatException {
1336         this.value = parseLong(s, 10);
1337     }
1338 
1339     /**
1340      * Returns the value of this {@code Long} as a {@code byte} after
1341      * a narrowing primitive conversion.
<span class="line-modified">1342      * @jls 5.1.3 Narrowing Primitive Conversions</span>
1343      */
1344     public byte byteValue() {
1345         return (byte)value;
1346     }
1347 
1348     /**
1349      * Returns the value of this {@code Long} as a {@code short} after
1350      * a narrowing primitive conversion.
<span class="line-modified">1351      * @jls 5.1.3 Narrowing Primitive Conversions</span>
1352      */
1353     public short shortValue() {
1354         return (short)value;
1355     }
1356 
1357     /**
1358      * Returns the value of this {@code Long} as an {@code int} after
1359      * a narrowing primitive conversion.
<span class="line-modified">1360      * @jls 5.1.3 Narrowing Primitive Conversions</span>
1361      */
1362     public int intValue() {
1363         return (int)value;
1364     }
1365 
1366     /**
1367      * Returns the value of this {@code Long} as a
1368      * {@code long} value.
1369      */
1370     @HotSpotIntrinsicCandidate
1371     public long longValue() {
1372         return value;
1373     }
1374 
1375     /**
1376      * Returns the value of this {@code Long} as a {@code float} after
1377      * a widening primitive conversion.
<span class="line-modified">1378      * @jls 5.1.2 Widening Primitive Conversions</span>
1379      */
1380     public float floatValue() {
1381         return (float)value;
1382     }
1383 
1384     /**
1385      * Returns the value of this {@code Long} as a {@code double}
1386      * after a widening primitive conversion.
<span class="line-modified">1387      * @jls 5.1.2 Widening Primitive Conversions</span>
1388      */
1389     public double doubleValue() {
1390         return (double)value;
1391     }
1392 
1393     /**
1394      * Returns a {@code String} object representing this
1395      * {@code Long}&#39;s value.  The value is converted to signed
1396      * decimal representation and returned as a string, exactly as if
1397      * the {@code long} value were given as an argument to the
1398      * {@link java.lang.Long#toString(long)} method.
1399      *
1400      * @return  a string representation of the value of this object in
1401      *          base&amp;nbsp;10.
1402      */
1403     public String toString() {
1404         return toString(value);
1405     }
1406 
1407     /**
</pre>
<hr />
<pre>
1975      */
1976     @Override
1977     public Optional&lt;Long&gt; describeConstable() {
1978         return Optional.of(this);
1979     }
1980 
1981     /**
1982      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1983      * the instance itself.
1984      *
1985      * @param lookup ignored
1986      * @return the {@linkplain Long} instance
1987      * @since 12
1988      */
1989     @Override
1990     public Long resolveConstantDesc(MethodHandles.Lookup lookup) {
1991         return this;
1992     }
1993 
1994     /** use serialVersionUID from JDK 1.0.2 for interoperability */

1995     @Native private static final long serialVersionUID = 4290774380558885855L;
1996 }
</pre>
</td>
<td>
<hr />
<pre>
 381      * Format a long (treated as unsigned) into a String.
 382      * @param val the value to format
 383      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
 384      */
 385     static String toUnsignedString0(long val, int shift) {
 386         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
 387         int mag = Long.SIZE - Long.numberOfLeadingZeros(val);
 388         int chars = Math.max(((mag + (shift - 1)) / shift), 1);
 389         if (COMPACT_STRINGS) {
 390             byte[] buf = new byte[chars];
 391             formatUnsignedLong0(val, shift, buf, 0, chars);
 392             return new String(buf, LATIN1);
 393         } else {
 394             byte[] buf = new byte[chars * 2];
 395             formatUnsignedLong0UTF16(val, shift, buf, 0, chars);
 396             return new String(buf, UTF16);
 397         }
 398     }
 399 
 400     /**
<span class="line-modified"> 401      * Format a long (treated as unsigned) into a byte buffer (LATIN1 version). If</span>
 402      * {@code len} exceeds the formatted ASCII representation of {@code val},
 403      * {@code buf} will be padded with leading zeroes.
 404      *
 405      * @param val the unsigned long to format
 406      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified"> 407      * @param buf the byte buffer to write to</span>
 408      * @param offset the offset in the destination buffer to start at
 409      * @param len the number of characters to write
 410      */
<span class="line-modified"> 411     private static void formatUnsignedLong0(long val, int shift, byte[] buf, int offset, int len) {</span>


 412         int charPos = offset + len;
 413         int radix = 1 &lt;&lt; shift;
 414         int mask = radix - 1;
 415         do {
 416             buf[--charPos] = (byte)Integer.digits[((int) val) &amp; mask];
 417             val &gt;&gt;&gt;= shift;
 418         } while (charPos &gt; offset);
 419     }
 420 
<span class="line-modified"> 421     /**</span>
<span class="line-added"> 422      * Format a long (treated as unsigned) into a byte buffer (UTF16 version). If</span>
<span class="line-added"> 423      * {@code len} exceeds the formatted ASCII representation of {@code val},</span>
<span class="line-added"> 424      * {@code buf} will be padded with leading zeroes.</span>
<span class="line-added"> 425      *</span>
<span class="line-added"> 426      * @param val the unsigned long to format</span>
<span class="line-added"> 427      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)</span>
<span class="line-added"> 428      * @param buf the byte buffer to write to</span>
<span class="line-added"> 429      * @param offset the offset in the destination buffer to start at</span>
<span class="line-added"> 430      * @param len the number of characters to write</span>
<span class="line-added"> 431      */</span>
 432     private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {
 433         int charPos = offset + len;
 434         int radix = 1 &lt;&lt; shift;
 435         int mask = radix - 1;
 436         do {
 437             StringUTF16.putChar(buf, --charPos, Integer.digits[((int) val) &amp; mask]);
 438             val &gt;&gt;&gt;= shift;
 439         } while (charPos &gt; offset);
 440     }
 441 
 442     static String fastUUID(long lsb, long msb) {
 443         if (COMPACT_STRINGS) {
 444             byte[] buf = new byte[36];
 445             formatUnsignedLong0(lsb,        4, buf, 24, 12);
 446             formatUnsignedLong0(lsb &gt;&gt;&gt; 48, 4, buf, 19, 4);
 447             formatUnsignedLong0(msb,        4, buf, 14, 4);
 448             formatUnsignedLong0(msb &gt;&gt;&gt; 16, 4, buf, 9,  4);
 449             formatUnsignedLong0(msb &gt;&gt;&gt; 32, 4, buf, 0,  8);
 450 
 451             buf[23] = &#39;-&#39;;
</pre>
<hr />
<pre>
 730      *                  representation to be parsed
 731      * @param      beginIndex   the beginning index, inclusive.
 732      * @param      endIndex     the ending index, exclusive.
 733      * @param      radix   the radix to be used while parsing {@code s}.
 734      * @return     the signed {@code long} represented by the subsequence in
 735      *             the specified radix.
 736      * @throws     NullPointerException  if {@code s} is null.
 737      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 738      *             negative, or if {@code beginIndex} is greater than
 739      *             {@code endIndex} or if {@code endIndex} is greater than
 740      *             {@code s.length()}.
 741      * @throws     NumberFormatException  if the {@code CharSequence} does not
 742      *             contain a parsable {@code long} in the specified
 743      *             {@code radix}, or if {@code radix} is either smaller than
 744      *             {@link java.lang.Character#MIN_RADIX} or larger than
 745      *             {@link java.lang.Character#MAX_RADIX}.
 746      * @since  9
 747      */
 748     public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix)
 749                 throws NumberFormatException {
<span class="line-modified"> 750         Objects.requireNonNull(s);</span>
 751 
 752         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 753             throw new IndexOutOfBoundsException();
 754         }
 755         if (radix &lt; Character.MIN_RADIX) {
 756             throw new NumberFormatException(&quot;radix &quot; + radix +
 757                     &quot; less than Character.MIN_RADIX&quot;);
 758         }
 759         if (radix &gt; Character.MAX_RADIX) {
 760             throw new NumberFormatException(&quot;radix &quot; + radix +
 761                     &quot; greater than Character.MAX_RADIX&quot;);
 762         }
 763 
 764         boolean negative = false;
 765         int i = beginIndex;
 766         long limit = -Long.MAX_VALUE;
 767 
 768         if (i &lt; endIndex) {
 769             char firstChar = s.charAt(i);
 770             if (firstChar &lt; &#39;0&#39;) { // Possible leading &quot;+&quot; or &quot;-&quot;
</pre>
<hr />
<pre>
 976      *                 {@code long} representation to be parsed
 977      * @param      beginIndex   the beginning index, inclusive.
 978      * @param      endIndex     the ending index, exclusive.
 979      * @param      radix   the radix to be used while parsing {@code s}.
 980      * @return     the unsigned {@code long} represented by the subsequence in
 981      *             the specified radix.
 982      * @throws     NullPointerException  if {@code s} is null.
 983      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 984      *             negative, or if {@code beginIndex} is greater than
 985      *             {@code endIndex} or if {@code endIndex} is greater than
 986      *             {@code s.length()}.
 987      * @throws     NumberFormatException  if the {@code CharSequence} does not
 988      *             contain a parsable unsigned {@code long} in the specified
 989      *             {@code radix}, or if {@code radix} is either smaller than
 990      *             {@link java.lang.Character#MIN_RADIX} or larger than
 991      *             {@link java.lang.Character#MAX_RADIX}.
 992      * @since  9
 993      */
 994     public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix)
 995                 throws NumberFormatException {
<span class="line-modified"> 996         Objects.requireNonNull(s);</span>
 997 
 998         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 999             throw new IndexOutOfBoundsException();
1000         }
1001         int start = beginIndex, len = endIndex - beginIndex;
1002 
1003         if (len &gt; 0) {
1004             char firstChar = s.charAt(start);
1005             if (firstChar == &#39;-&#39;) {
1006                 throw new NumberFormatException(String.format(&quot;Illegal leading minus sign &quot; +
1007                         &quot;on unsigned string %s.&quot;, s.subSequence(start, start + len)));
1008             } else {
1009                 if (len &lt;= 12 || // Long.MAX_VALUE in Character.MAX_RADIX is 13 digits
1010                     (radix == 10 &amp;&amp; len &lt;= 18) ) { // Long.MAX_VALUE in base 10 is 19 digits
1011                     return parseLong(s, start, start + len, radix);
1012                 }
1013 
1014                 // No need for range checks on end due to testing above.
1015                 long first = parseLong(s, start, start + len - 1, radix);
1016                 int second = Character.digit(s.charAt(start + len - 1), radix);
</pre>
<hr />
<pre>
1330      *
1331      * @param      s   the {@code String} to be converted to a
1332      *             {@code Long}.
1333      * @throws     NumberFormatException  if the {@code String} does not
1334      *             contain a parsable {@code long}.
1335      *
1336      * @deprecated
1337      * It is rarely appropriate to use this constructor.
1338      * Use {@link #parseLong(String)} to convert a string to a
1339      * {@code long} primitive, or use {@link #valueOf(String)}
1340      * to convert a string to a {@code Long} object.
1341      */
1342     @Deprecated(since=&quot;9&quot;)
1343     public Long(String s) throws NumberFormatException {
1344         this.value = parseLong(s, 10);
1345     }
1346 
1347     /**
1348      * Returns the value of this {@code Long} as a {@code byte} after
1349      * a narrowing primitive conversion.
<span class="line-modified">1350      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1351      */
1352     public byte byteValue() {
1353         return (byte)value;
1354     }
1355 
1356     /**
1357      * Returns the value of this {@code Long} as a {@code short} after
1358      * a narrowing primitive conversion.
<span class="line-modified">1359      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1360      */
1361     public short shortValue() {
1362         return (short)value;
1363     }
1364 
1365     /**
1366      * Returns the value of this {@code Long} as an {@code int} after
1367      * a narrowing primitive conversion.
<span class="line-modified">1368      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1369      */
1370     public int intValue() {
1371         return (int)value;
1372     }
1373 
1374     /**
1375      * Returns the value of this {@code Long} as a
1376      * {@code long} value.
1377      */
1378     @HotSpotIntrinsicCandidate
1379     public long longValue() {
1380         return value;
1381     }
1382 
1383     /**
1384      * Returns the value of this {@code Long} as a {@code float} after
1385      * a widening primitive conversion.
<span class="line-modified">1386      * @jls 5.1.2 Widening Primitive Conversion</span>
1387      */
1388     public float floatValue() {
1389         return (float)value;
1390     }
1391 
1392     /**
1393      * Returns the value of this {@code Long} as a {@code double}
1394      * after a widening primitive conversion.
<span class="line-modified">1395      * @jls 5.1.2 Widening Primitive Conversion</span>
1396      */
1397     public double doubleValue() {
1398         return (double)value;
1399     }
1400 
1401     /**
1402      * Returns a {@code String} object representing this
1403      * {@code Long}&#39;s value.  The value is converted to signed
1404      * decimal representation and returned as a string, exactly as if
1405      * the {@code long} value were given as an argument to the
1406      * {@link java.lang.Long#toString(long)} method.
1407      *
1408      * @return  a string representation of the value of this object in
1409      *          base&amp;nbsp;10.
1410      */
1411     public String toString() {
1412         return toString(value);
1413     }
1414 
1415     /**
</pre>
<hr />
<pre>
1983      */
1984     @Override
1985     public Optional&lt;Long&gt; describeConstable() {
1986         return Optional.of(this);
1987     }
1988 
1989     /**
1990      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1991      * the instance itself.
1992      *
1993      * @param lookup ignored
1994      * @return the {@linkplain Long} instance
1995      * @since 12
1996      */
1997     @Override
1998     public Long resolveConstantDesc(MethodHandles.Lookup lookup) {
1999         return this;
2000     }
2001 
2002     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">2003     @java.io.Serial</span>
2004     @Native private static final long serialVersionUID = 4290774380558885855L;
2005 }
</pre>
</td>
</tr>
</table>
<center><a href="LiveStackFrame.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Math.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
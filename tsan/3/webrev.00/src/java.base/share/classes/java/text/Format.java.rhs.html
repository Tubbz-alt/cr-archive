<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/text/Format.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.Serializable;
 42 
 43 /**
<a name="2" id="anc2"></a><span class="line-modified"> 44  * {@code Format} is an abstract base class for formatting locale-sensitive</span>
 45  * information such as dates, messages, and numbers.
 46  *
 47  * &lt;p&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 48  * {@code Format} defines the programming interface for formatting</span>
<span class="line-modified"> 49  * locale-sensitive objects into {@code String}s (the</span>
<span class="line-modified"> 50  * {@code format} method) and for parsing {@code String}s back</span>
<span class="line-modified"> 51  * into objects (the {@code parseObject} method).</span>
 52  *
 53  * &lt;p&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 54  * Generally, a format&#39;s {@code parseObject} method must be able to parse</span>
<span class="line-modified"> 55  * any string formatted by its {@code format} method. However, there may</span>
 56  * be exceptional cases where this is not possible. For example, a
<a name="5" id="anc5"></a><span class="line-modified"> 57  * {@code format} method might create two adjacent integer numbers with</span>
<span class="line-modified"> 58  * no separator in between, and in this case the {@code parseObject} could</span>
 59  * not tell which digits belong to which number.
 60  *
<a name="6" id="anc6"></a><span class="line-modified"> 61  * &lt;h2&gt;Subclassing&lt;/h2&gt;</span>
 62  *
 63  * &lt;p&gt;
<a name="7" id="anc7"></a><span class="line-modified"> 64  * The Java Platform provides three specialized subclasses of {@code Format}--</span>
<span class="line-modified"> 65  * {@code DateFormat}, {@code MessageFormat}, and</span>
<span class="line-modified"> 66  * {@code NumberFormat}--for formatting dates, messages, and numbers,</span>
 67  * respectively.
 68  * &lt;p&gt;
 69  * Concrete subclasses must implement three methods:
 70  * &lt;ol&gt;
<a name="8" id="anc8"></a><span class="line-modified"> 71  * &lt;li&gt; {@code format(Object obj, StringBuffer toAppendTo, FieldPosition pos)}</span>
<span class="line-modified"> 72  * &lt;li&gt; {@code formatToCharacterIterator(Object obj)}</span>
<span class="line-modified"> 73  * &lt;li&gt; {@code parseObject(String source, ParsePosition pos)}</span>
 74  * &lt;/ol&gt;
 75  * These general methods allow polymorphic parsing and formatting of objects
<a name="9" id="anc9"></a><span class="line-modified"> 76  * and are used, for example, by {@code MessageFormat}.</span>
<span class="line-modified"> 77  * Subclasses often also provide additional {@code format} methods for</span>
<span class="line-modified"> 78  * specific input types as well as {@code parse} methods for specific</span>
<span class="line-modified"> 79  * result types. Any {@code parse} method that does not take a</span>
<span class="line-modified"> 80  * {@code ParsePosition} argument should throw {@code ParseException}</span>
 81  * when no text in the required format is at the beginning of the input text.
 82  *
 83  * &lt;p&gt;
 84  * Most subclasses will also implement the following factory methods:
 85  * &lt;ol&gt;
 86  * &lt;li&gt;
<a name="10" id="anc10"></a><span class="line-modified"> 87  * {@code getInstance} for getting a useful format object appropriate</span>
 88  * for the current locale
 89  * &lt;li&gt;
<a name="11" id="anc11"></a><span class="line-modified"> 90  * {@code getInstance(Locale)} for getting a useful format</span>
 91  * object appropriate for the specified locale
 92  * &lt;/ol&gt;
 93  * In addition, some subclasses may also implement other
<a name="12" id="anc12"></a><span class="line-modified"> 94  * {@code getXxxxInstance} methods for more specialized control. For</span>
<span class="line-modified"> 95  * example, the {@code NumberFormat} class provides</span>
<span class="line-modified"> 96  * {@code getPercentInstance} and {@code getCurrencyInstance}</span>
 97  * methods for getting specialized number formatters.
 98  *
 99  * &lt;p&gt;
<a name="13" id="anc13"></a><span class="line-modified">100  * Subclasses of {@code Format} that allow programmers to create objects</span>
<span class="line-modified">101  * for locales (with {@code getInstance(Locale)} for example)</span>
102  * must also implement the following class method:
103  * &lt;blockquote&gt;
104  * &lt;pre&gt;
105  * public static Locale[] getAvailableLocales()
106  * &lt;/pre&gt;
107  * &lt;/blockquote&gt;
108  *
109  * &lt;p&gt;
110  * And finally subclasses may define a set of constants to identify the various
111  * fields in the formatted output. These constants are used to create a FieldPosition
112  * object which identifies what information is contained in the field and its
113  * position in the formatted result. These constants should be named
114  * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
<a name="14" id="anc14"></a><span class="line-modified">115  * the field. For examples of these constants, see {@code ERA_FIELD} and its</span>
116  * friends in {@link DateFormat}.
117  *
<a name="15" id="anc15"></a><span class="line-modified">118  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
119  *
120  * &lt;p&gt;
121  * Formats are generally not synchronized.
122  * It is recommended to create separate format instances for each thread.
123  * If multiple threads access a format concurrently, it must be synchronized
124  * externally.
125  *
126  * @see          java.text.ParsePosition
127  * @see          java.text.FieldPosition
128  * @see          java.text.NumberFormat
129  * @see          java.text.DateFormat
130  * @see          java.text.MessageFormat
131  * @author       Mark Davis
132  * @since 1.1
133  */
134 public abstract class Format implements Serializable, Cloneable {
135 
<a name="16" id="anc16"></a><span class="line-added">136     @java.io.Serial</span>
137     private static final long serialVersionUID = -299282585814624189L;
138 
139     /**
140      * Sole constructor.  (For invocation by subclass constructors, typically
141      * implicit.)
142      */
143     protected Format() {
144     }
145 
146     /**
147      * Formats an object to produce a string. This is equivalent to
148      * &lt;blockquote&gt;
149      * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
150      *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
151      * &lt;/blockquote&gt;
152      *
153      * @param obj    The object to format
154      * @return       Formatted string.
<a name="17" id="anc17"></a><span class="line-modified">155      * @throws    IllegalArgumentException if the Format cannot format the given</span>
156      *            object
157      */
158     public final String format (Object obj) {
159         return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
160     }
161 
162     /**
163      * Formats an object and appends the resulting text to a given string
164      * buffer.
<a name="18" id="anc18"></a><span class="line-modified">165      * If the {@code pos} argument identifies a field used by the format,</span>
166      * then its indices are set to the beginning and end of the first such
167      * field encountered.
168      *
169      * @param obj    The object to format
170      * @param toAppendTo    where the text is to be appended
<a name="19" id="anc19"></a><span class="line-modified">171      * @param pos    A {@code FieldPosition} identifying a field</span>
172      *               in the formatted text
<a name="20" id="anc20"></a><span class="line-modified">173      * @return       the string buffer passed in as {@code toAppendTo},</span>
174      *               with formatted text appended
<a name="21" id="anc21"></a><span class="line-modified">175      * @throws    NullPointerException if {@code toAppendTo} or</span>
<span class="line-modified">176      *            {@code pos} is null</span>
<span class="line-modified">177      * @throws    IllegalArgumentException if the Format cannot format the given</span>
178      *            object
179      */
180     public abstract StringBuffer format(Object obj,
181                     StringBuffer toAppendTo,
182                     FieldPosition pos);
183 
184     /**
<a name="22" id="anc22"></a><span class="line-modified">185      * Formats an Object producing an {@code AttributedCharacterIterator}.</span>
<span class="line-modified">186      * You can use the returned {@code AttributedCharacterIterator}</span>
187      * to build the resulting String, as well as to determine information
188      * about the resulting String.
189      * &lt;p&gt;
190      * Each attribute key of the AttributedCharacterIterator will be of type
<a name="23" id="anc23"></a><span class="line-modified">191      * {@code Field}. It is up to each {@code Format} implementation</span>
192      * to define what the legal values are for each attribute in the
<a name="24" id="anc24"></a><span class="line-modified">193      * {@code AttributedCharacterIterator}, but typically the attribute</span>
194      * key is also used as the attribute value.
195      * &lt;p&gt;The default implementation creates an
<a name="25" id="anc25"></a><span class="line-modified">196      * {@code AttributedCharacterIterator} with no attributes. Subclasses</span>
197      * that support fields should override this and create an
<a name="26" id="anc26"></a><span class="line-modified">198      * {@code AttributedCharacterIterator} with meaningful attributes.</span>
199      *
<a name="27" id="anc27"></a><span class="line-modified">200      * @throws    NullPointerException if obj is null.</span>
<span class="line-modified">201      * @throws    IllegalArgumentException when the Format cannot format the</span>
202      *            given object.
203      * @param obj The object to format
204      * @return AttributedCharacterIterator describing the formatted value.
205      * @since 1.4
206      */
207     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
208         return createAttributedCharacterIterator(format(obj));
209     }
210 
211     /**
212      * Parses text from a string to produce an object.
213      * &lt;p&gt;
214      * The method attempts to parse text starting at the index given by
<a name="28" id="anc28"></a><span class="line-modified">215      * {@code pos}.</span>
<span class="line-modified">216      * If parsing succeeds, then the index of {@code pos} is updated</span>
217      * to the index after the last character used (parsing does not necessarily
218      * use all characters up to the end of the string), and the parsed
<a name="29" id="anc29"></a><span class="line-modified">219      * object is returned. The updated {@code pos} can be used to</span>
220      * indicate the starting point for the next call to this method.
<a name="30" id="anc30"></a><span class="line-modified">221      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">222      * changed, the error index of {@code pos} is set to the index of</span>
223      * the character where the error occurred, and null is returned.
224      *
<a name="31" id="anc31"></a><span class="line-modified">225      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">226      * @param pos A {@code ParsePosition} object with index and error</span>
227      *            index information as described above.
<a name="32" id="anc32"></a><span class="line-modified">228      * @return An {@code Object} parsed from the string. In case of</span>
229      *         error, returns null.
230      * @throws NullPointerException if {@code source} or {@code pos} is null.
231      */
232     public abstract Object parseObject (String source, ParsePosition pos);
233 
234     /**
235      * Parses text from the beginning of the given string to produce an object.
236      * The method may not use the entire text of the given string.
237      *
<a name="33" id="anc33"></a><span class="line-modified">238      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">239      * @return An {@code Object} parsed from the string.</span>
<span class="line-modified">240      * @throws    ParseException if the beginning of the specified string</span>
241      *            cannot be parsed.
242      * @throws NullPointerException if {@code source} is null.
243      */
244     public Object parseObject(String source) throws ParseException {
245         ParsePosition pos = new ParsePosition(0);
246         Object result = parseObject(source, pos);
247         if (pos.index == 0) {
248             throw new ParseException(&quot;Format.parseObject(String) failed&quot;,
249                 pos.errorIndex);
250         }
251         return result;
252     }
253 
254     /**
255      * Creates and returns a copy of this object.
256      *
257      * @return a clone of this instance.
258      */
259     public Object clone() {
260         try {
261             return super.clone();
262         } catch (CloneNotSupportedException e) {
263             // will never happen
264             throw new InternalError(e);
265         }
266     }
267 
268     //
269     // Convenience methods for creating AttributedCharacterIterators from
270     // different parameters.
271     //
272 
273     /**
<a name="34" id="anc34"></a><span class="line-modified">274      * Creates an {@code AttributedCharacterIterator} for the String</span>
<span class="line-modified">275      * {@code s}.</span>
276      *
277      * @param s String to create AttributedCharacterIterator from
278      * @return AttributedCharacterIterator wrapping s
279      */
280     AttributedCharacterIterator createAttributedCharacterIterator(String s) {
281         AttributedString as = new AttributedString(s);
282 
283         return as.getIterator();
284     }
285 
286     /**
<a name="35" id="anc35"></a><span class="line-modified">287      * Creates an {@code AttributedCharacterIterator} containing the</span>
288      * concatenated contents of the passed in
<a name="36" id="anc36"></a><span class="line-modified">289      * {@code AttributedCharacterIterator}s.</span>
290      *
291      * @param iterators AttributedCharacterIterators used to create resulting
292      *                  AttributedCharacterIterators
293      * @return AttributedCharacterIterator wrapping passed in
294      *         AttributedCharacterIterators
295      */
296     AttributedCharacterIterator createAttributedCharacterIterator(
297                        AttributedCharacterIterator[] iterators) {
298         AttributedString as = new AttributedString(iterators);
299 
300         return as.getIterator();
301     }
302 
303     /**
304      * Returns an AttributedCharacterIterator with the String
<a name="37" id="anc37"></a><span class="line-modified">305      * {@code string} and additional key/value pair {@code key},</span>
<span class="line-modified">306      * {@code value}.</span>
307      *
308      * @param string String to create AttributedCharacterIterator from
309      * @param key Key for AttributedCharacterIterator
310      * @param value Value associated with key in AttributedCharacterIterator
311      * @return AttributedCharacterIterator wrapping args
312      */
313     AttributedCharacterIterator createAttributedCharacterIterator(
314                       String string, AttributedCharacterIterator.Attribute key,
315                       Object value) {
316         AttributedString as = new AttributedString(string);
317 
318         as.addAttribute(key, value);
319         return as.getIterator();
320     }
321 
322     /**
323      * Creates an AttributedCharacterIterator with the contents of
<a name="38" id="anc38"></a><span class="line-modified">324      * {@code iterator} and the additional attribute {@code key}</span>
<span class="line-modified">325      * {@code value}.</span>
326      *
327      * @param iterator Initial AttributedCharacterIterator to add arg to
328      * @param key Key for AttributedCharacterIterator
329      * @param value Value associated with key in AttributedCharacterIterator
330      * @return AttributedCharacterIterator wrapping args
331      */
332     AttributedCharacterIterator createAttributedCharacterIterator(
333               AttributedCharacterIterator iterator,
334               AttributedCharacterIterator.Attribute key, Object value) {
335         AttributedString as = new AttributedString(iterator);
336 
337         as.addAttribute(key, value);
338         return as.getIterator();
339     }
340 
341 
342     /**
343      * Defines constants that are used as attribute keys in the
<a name="39" id="anc39"></a><span class="line-modified">344      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">345      * from {@code Format.formatToCharacterIterator} and as</span>
<span class="line-modified">346      * field identifiers in {@code FieldPosition}.</span>
347      *
348      * @since 1.4
349      */
350     public static class Field extends AttributedCharacterIterator.Attribute {
351 
352         // Proclaim serial compatibility with 1.4 FCS
<a name="40" id="anc40"></a><span class="line-added">353         @java.io.Serial</span>
354         private static final long serialVersionUID = 276966692217360283L;
355 
356         /**
357          * Creates a Field with the specified name.
358          *
359          * @param name Name of the attribute
360          */
361         protected Field(String name) {
362             super(name);
363         }
364     }
365 
366 
367     /**
<a name="41" id="anc41"></a><span class="line-modified">368      * FieldDelegate is notified by the various {@code Format}</span>
369      * implementations as they are formatting the Objects. This allows for
370      * storage of the individual sections of the formatted String for
<a name="42" id="anc42"></a><span class="line-modified">371      * later use, such as in a {@code FieldPosition} or for an</span>
<span class="line-modified">372      * {@code AttributedCharacterIterator}.</span>
373      * &lt;p&gt;
<a name="43" id="anc43"></a><span class="line-modified">374      * Delegates should NOT assume that the {@code Format} will notify</span>
375      * the delegate of fields in any particular order.
376      *
377      * @see FieldPosition#getFieldDelegate
378      * @see CharacterIteratorFieldDelegate
379      */
380     interface FieldDelegate {
381         /**
382          * Notified when a particular region of the String is formatted. This
383          * method will be invoked if there is no corresponding integer field id
<a name="44" id="anc44"></a><span class="line-modified">384          * matching {@code attr}.</span>
385          *
386          * @param attr Identifies the field matched
387          * @param value Value associated with the field
388          * @param start Beginning location of the field, will be &gt;= 0
389          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
390          * @param buffer Contains current formatted value, receiver should
391          *        NOT modify it.
392          */
393         public void formatted(Format.Field attr, Object value, int start,
394                               int end, StringBuffer buffer);
395 
396         /**
397          * Notified when a particular region of the String is formatted.
398          *
399          * @param fieldID Identifies the field by integer
400          * @param attr Identifies the field matched
401          * @param value Value associated with the field
402          * @param start Beginning location of the field, will be &gt;= 0
403          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
404          * @param buffer Contains current formatted value, receiver should
405          *        NOT modify it.
406          */
407         public void formatted(int fieldID, Format.Field attr, Object value,
408                               int start, int end, StringBuffer buffer);
409     }
410 }
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
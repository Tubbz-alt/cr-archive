<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/Inet6AddressImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Inet6Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InetAddress.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/Inet6AddressImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.IOException;


 28 import static java.net.InetAddress.PREFER_IPV6_VALUE;
 29 import static java.net.InetAddress.PREFER_SYSTEM_VALUE;
 30 
 31 /*
 32  * Package private implementation of InetAddressImpl for dual
 33  * IPv4/IPv6 stack.
 34  * &lt;p&gt;
<span class="line-modified"> 35  * If InetAddress.preferIPv6Address is true then anyLocalAddress(),</span>
<span class="line-modified"> 36  * loopbackAddress(), and localHost() will return IPv6 addresses,</span>
<span class="line-modified"> 37  * otherwise IPv4 addresses.</span>




 38  *
 39  * @since 1.4
 40  */
 41 class Inet6AddressImpl implements InetAddressImpl {
 42 
 43     public native String getLocalHostName() throws UnknownHostException;
 44 
 45     public native InetAddress[] lookupAllHostAddr(String hostname)
 46         throws UnknownHostException;
 47 
 48     public native String getHostByAddr(byte[] addr) throws UnknownHostException;
 49 
 50     private native boolean isReachable0(byte[] addr, int scope, int timeout,
 51                                         byte[] inf, int ttl, int if_scope)
 52         throws IOException;
 53 
 54     public boolean isReachable(InetAddress addr, int timeout,
 55                                NetworkInterface netif, int ttl)
 56         throws IOException
 57     {
 58         byte[] ifaddr = null;
 59         int scope = -1;
 60         int netif_scope = -1;
 61         if (netif != null) {
 62             /*
 63              * Let&#39;s make sure we bind to an address of the proper family.
 64              * Which means same family as addr because at this point it could
 65              * be either an IPv6 address or an IPv4 address (case of a dual
 66              * stack system).
 67              */
 68             java.util.Enumeration&lt;InetAddress&gt; it = netif.getInetAddresses();
<span class="line-modified"> 69             InetAddress inetaddr = null;</span>
 70             while (it.hasMoreElements()) {
 71                 inetaddr = it.nextElement();
 72                 if (inetaddr.getClass().isInstance(addr)) {
 73                     ifaddr = inetaddr.getAddress();
 74                     if (inetaddr instanceof Inet6Address) {
 75                         netif_scope = ((Inet6Address) inetaddr).getScopeId();
 76                     }
 77                     break;
 78                 }
 79             }
 80             if (ifaddr == null) {
 81                 // Interface doesn&#39;t support the address family of
 82                 // the destination
 83                 return false;
 84             }
 85         }
 86         if (addr instanceof Inet6Address)
 87             scope = ((Inet6Address) addr).getScopeId();
 88         return isReachable0(addr.getAddress(), scope, timeout, ifaddr, ttl, netif_scope);
 89     }
 90 
 91     public synchronized InetAddress anyLocalAddress() {
 92         if (anyLocalAddress == null) {
 93             if (InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||
 94                 InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE) {
 95                 anyLocalAddress = new Inet6Address();
 96                 anyLocalAddress.holder().hostName = &quot;::&quot;;
 97             } else {
 98                 anyLocalAddress = (new Inet4AddressImpl()).anyLocalAddress();
 99             }
100         }
101         return anyLocalAddress;
102     }
103 
104     public synchronized InetAddress loopbackAddress() {
105         if (loopbackAddress == null) {
<span class="line-modified">106              if (InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||</span>
<span class="line-modified">107                  InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE) {</span>
<span class="line-modified">108                  byte[] loopback =</span>
<span class="line-modified">109                         {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span class="line-modified">110                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};</span>
<span class="line-modified">111                  loopbackAddress = new Inet6Address(&quot;localhost&quot;, loopback);</span>
<span class="line-modified">112              } else {</span>
<span class="line-modified">113                 loopbackAddress = (new Inet4AddressImpl()).loopbackAddress();</span>
<span class="line-modified">114              }</span>



















115         }
116         return loopbackAddress;
117     }
118 
119     private InetAddress anyLocalAddress;
120     private InetAddress loopbackAddress;
121 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.IOException;
<span class="line-added"> 28 </span>
<span class="line-added"> 29 import static java.net.InetAddress.IPv6;</span>
 30 import static java.net.InetAddress.PREFER_IPV6_VALUE;
 31 import static java.net.InetAddress.PREFER_SYSTEM_VALUE;
 32 
 33 /*
 34  * Package private implementation of InetAddressImpl for dual
 35  * IPv4/IPv6 stack.
 36  * &lt;p&gt;
<span class="line-modified"> 37  * If InetAddress.preferIPv6Address is true then anyLocalAddress()</span>
<span class="line-modified"> 38  * and localHost() will return IPv6 addresses, otherwise IPv4 addresses.</span>
<span class="line-modified"> 39  *</span>
<span class="line-added"> 40  * loopbackAddress() will return the first valid loopback address in</span>
<span class="line-added"> 41  * [IPv6 loopback, IPv4 loopback] if InetAddress.preferIPv6Address is true,</span>
<span class="line-added"> 42  * else [IPv4 loopback, IPv6 loopback].</span>
<span class="line-added"> 43  * If neither are valid it will fallback to the first address tried.</span>
 44  *
 45  * @since 1.4
 46  */
 47 class Inet6AddressImpl implements InetAddressImpl {
 48 
 49     public native String getLocalHostName() throws UnknownHostException;
 50 
 51     public native InetAddress[] lookupAllHostAddr(String hostname)
 52         throws UnknownHostException;
 53 
 54     public native String getHostByAddr(byte[] addr) throws UnknownHostException;
 55 
 56     private native boolean isReachable0(byte[] addr, int scope, int timeout,
 57                                         byte[] inf, int ttl, int if_scope)
 58         throws IOException;
 59 
 60     public boolean isReachable(InetAddress addr, int timeout,
 61                                NetworkInterface netif, int ttl)
 62         throws IOException
 63     {
 64         byte[] ifaddr = null;
 65         int scope = -1;
 66         int netif_scope = -1;
 67         if (netif != null) {
 68             /*
 69              * Let&#39;s make sure we bind to an address of the proper family.
 70              * Which means same family as addr because at this point it could
 71              * be either an IPv6 address or an IPv4 address (case of a dual
 72              * stack system).
 73              */
 74             java.util.Enumeration&lt;InetAddress&gt; it = netif.getInetAddresses();
<span class="line-modified"> 75             InetAddress inetaddr;</span>
 76             while (it.hasMoreElements()) {
 77                 inetaddr = it.nextElement();
 78                 if (inetaddr.getClass().isInstance(addr)) {
 79                     ifaddr = inetaddr.getAddress();
 80                     if (inetaddr instanceof Inet6Address) {
 81                         netif_scope = ((Inet6Address) inetaddr).getScopeId();
 82                     }
 83                     break;
 84                 }
 85             }
 86             if (ifaddr == null) {
 87                 // Interface doesn&#39;t support the address family of
 88                 // the destination
 89                 return false;
 90             }
 91         }
 92         if (addr instanceof Inet6Address)
 93             scope = ((Inet6Address) addr).getScopeId();
 94         return isReachable0(addr.getAddress(), scope, timeout, ifaddr, ttl, netif_scope);
 95     }
 96 
 97     public synchronized InetAddress anyLocalAddress() {
 98         if (anyLocalAddress == null) {
 99             if (InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||
100                 InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE) {
101                 anyLocalAddress = new Inet6Address();
102                 anyLocalAddress.holder().hostName = &quot;::&quot;;
103             } else {
104                 anyLocalAddress = (new Inet4AddressImpl()).anyLocalAddress();
105             }
106         }
107         return anyLocalAddress;
108     }
109 
110     public synchronized InetAddress loopbackAddress() {
111         if (loopbackAddress == null) {
<span class="line-modified">112             boolean preferIPv6Address =</span>
<span class="line-modified">113                 InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||</span>
<span class="line-modified">114                 InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE;</span>
<span class="line-modified">115 </span>
<span class="line-modified">116             for (int i = 0; i &lt; 2; i++) {</span>
<span class="line-modified">117                 InetAddress address;</span>
<span class="line-modified">118                 // Order the candidate addresses by preference.</span>
<span class="line-modified">119                 if (i == (preferIPv6Address ? 0 : 1)) {</span>
<span class="line-modified">120                     address = new Inet6Address(&quot;localhost&quot;,</span>
<span class="line-added">121                             new byte[]{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span class="line-added">122                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01});</span>
<span class="line-added">123                 } else {</span>
<span class="line-added">124                     address = new Inet4Address(&quot;localhost&quot;, new byte[]{ 0x7f,0x00,0x00,0x01 });</span>
<span class="line-added">125                 }</span>
<span class="line-added">126                 if (i == 0) {</span>
<span class="line-added">127                     // In case of failure, default to the preferred address.</span>
<span class="line-added">128                     loopbackAddress = address;</span>
<span class="line-added">129                 }</span>
<span class="line-added">130                 try {</span>
<span class="line-added">131                     if (!NetworkInterface.isBoundInetAddress(address)) {</span>
<span class="line-added">132                         continue;</span>
<span class="line-added">133                     }</span>
<span class="line-added">134                 } catch (SocketException e) {</span>
<span class="line-added">135                     continue;</span>
<span class="line-added">136                 }</span>
<span class="line-added">137                 loopbackAddress = address;</span>
<span class="line-added">138                 break;</span>
<span class="line-added">139             }</span>
140         }
141         return loopbackAddress;
142     }
143 
144     private InetAddress anyLocalAddress;
145     private InetAddress loopbackAddress;
146 }
</pre>
</td>
</tr>
</table>
<center><a href="Inet6Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InetAddress.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/Double.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.invoke.MethodHandles;
  29 import java.lang.constant.Constable;
  30 import java.lang.constant.ConstantDesc;
  31 import java.util.Optional;
  32 
  33 import jdk.internal.math.FloatingDecimal;
  34 import jdk.internal.math.DoubleConsts;
  35 import jdk.internal.HotSpotIntrinsicCandidate;
  36 
  37 /**
  38  * The {@code Double} class wraps a value of the primitive type
  39  * {@code double} in an object. An object of type
  40  * {@code Double} contains a single field whose type is
  41  * {@code double}.
  42  *
  43  * &lt;p&gt;In addition, this class provides several methods for converting a
  44  * {@code double} to a {@code String} and a
  45  * {@code String} to a {@code double}, as well as other
  46  * constants and methods useful when dealing with a
  47  * {@code double}.
  48  *
  49  * @author  Lee Boynton
  50  * @author  Arthur van Hoff
  51  * @author  Joseph D. Darcy
  52  * @since 1.0
  53  */
  54 public final class Double extends Number
  55         implements Comparable&lt;Double&gt;, Constable, ConstantDesc {
  56     /**
  57      * A constant holding the positive infinity of type
  58      * {@code double}. It is equal to the value returned by
  59      * {@code Double.longBitsToDouble(0x7ff0000000000000L)}.
  60      */
  61     public static final double POSITIVE_INFINITY = 1.0 / 0.0;
  62 
  63     /**
  64      * A constant holding the negative infinity of type
  65      * {@code double}. It is equal to the value returned by
  66      * {@code Double.longBitsToDouble(0xfff0000000000000L)}.
  67      */
  68     public static final double NEGATIVE_INFINITY = -1.0 / 0.0;
  69 
  70     /**
  71      * A constant holding a Not-a-Number (NaN) value of type
  72      * {@code double}. It is equivalent to the value returned by
  73      * {@code Double.longBitsToDouble(0x7ff8000000000000L)}.
  74      */
  75     public static final double NaN = 0.0d / 0.0;
  76 
  77     /**
  78      * A constant holding the largest positive finite value of type
  79      * {@code double},
  80      * (2-2&lt;sup&gt;-52&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;1023&lt;/sup&gt;.  It is equal to
  81      * the hexadecimal floating-point literal
  82      * {@code 0x1.fffffffffffffP+1023} and also equal to
  83      * {@code Double.longBitsToDouble(0x7fefffffffffffffL)}.
  84      */
  85     public static final double MAX_VALUE = 0x1.fffffffffffffP+1023; // 1.7976931348623157e+308
  86 
  87     /**
  88      * A constant holding the smallest positive normal value of type
  89      * {@code double}, 2&lt;sup&gt;-1022&lt;/sup&gt;.  It is equal to the
  90      * hexadecimal floating-point literal {@code 0x1.0p-1022} and also
  91      * equal to {@code Double.longBitsToDouble(0x0010000000000000L)}.
  92      *
  93      * @since 1.6
  94      */
  95     public static final double MIN_NORMAL = 0x1.0p-1022; // 2.2250738585072014E-308
  96 
  97     /**
  98      * A constant holding the smallest positive nonzero value of type
  99      * {@code double}, 2&lt;sup&gt;-1074&lt;/sup&gt;. It is equal to the
 100      * hexadecimal floating-point literal
 101      * {@code 0x0.0000000000001P-1022} and also equal to
 102      * {@code Double.longBitsToDouble(0x1L)}.
 103      */
 104     public static final double MIN_VALUE = 0x0.0000000000001P-1022; // 4.9e-324
 105 
 106     /**
 107      * Maximum exponent a finite {@code double} variable may have.
 108      * It is equal to the value returned by
 109      * {@code Math.getExponent(Double.MAX_VALUE)}.
 110      *
 111      * @since 1.6
 112      */
 113     public static final int MAX_EXPONENT = 1023;
 114 
 115     /**
 116      * Minimum exponent a normalized {@code double} variable may
 117      * have.  It is equal to the value returned by
 118      * {@code Math.getExponent(Double.MIN_NORMAL)}.
 119      *
 120      * @since 1.6
 121      */
 122     public static final int MIN_EXPONENT = -1022;
 123 
 124     /**
 125      * The number of bits used to represent a {@code double} value.
 126      *
 127      * @since 1.5
 128      */
 129     public static final int SIZE = 64;
 130 
 131     /**
 132      * The number of bytes used to represent a {@code double} value.
 133      *
 134      * @since 1.8
 135      */
 136     public static final int BYTES = SIZE / Byte.SIZE;
 137 
 138     /**
 139      * The {@code Class} instance representing the primitive type
 140      * {@code double}.
 141      *
 142      * @since 1.1
 143      */
 144     @SuppressWarnings(&quot;unchecked&quot;)
 145     public static final Class&lt;Double&gt;   TYPE = (Class&lt;Double&gt;) Class.getPrimitiveClass(&quot;double&quot;);
 146 
 147     /**
 148      * Returns a string representation of the {@code double}
 149      * argument. All characters mentioned below are ASCII characters.
 150      * &lt;ul&gt;
 151      * &lt;li&gt;If the argument is NaN, the result is the string
 152      *     &quot;{@code NaN}&quot;.
 153      * &lt;li&gt;Otherwise, the result is a string that represents the sign and
 154      * magnitude (absolute value) of the argument. If the sign is negative,
 155      * the first character of the result is &#39;{@code -}&#39;
 156      * ({@code &#39;\u005Cu002D&#39;}); if the sign is positive, no sign character
 157      * appears in the result. As for the magnitude &lt;i&gt;m&lt;/i&gt;:
 158      * &lt;ul&gt;
 159      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the characters
 160      * {@code &quot;Infinity&quot;}; thus, positive infinity produces the result
 161      * {@code &quot;Infinity&quot;} and negative infinity produces the result
 162      * {@code &quot;-Infinity&quot;}.
 163      *
 164      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the characters
 165      * {@code &quot;0.0&quot;}; thus, negative zero produces the result
 166      * {@code &quot;-0.0&quot;} and positive zero produces the result
 167      * {@code &quot;0.0&quot;}.
 168      *
 169      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-3&lt;/sup&gt; but less
 170      * than 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented as the integer part of
 171      * &lt;i&gt;m&lt;/i&gt;, in decimal form with no leading zeroes, followed by
 172      * &#39;{@code .}&#39; ({@code &#39;\u005Cu002E&#39;}), followed by one or
 173      * more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
 174      *
 175      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-3&lt;/sup&gt; or greater than or
 176      * equal to 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented in so-called
 177      * &quot;computerized scientific notation.&quot; Let &lt;i&gt;n&lt;/i&gt; be the unique
 178      * integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; &amp;le; &lt;i&gt;m&lt;/i&gt; {@literal &lt;}
 179      * 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
 180      * mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and
 181      * 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so that 1 &amp;le; &lt;i&gt;a&lt;/i&gt; {@literal &lt;} 10. The
 182      * magnitude is then represented as the integer part of &lt;i&gt;a&lt;/i&gt;,
 183      * as a single decimal digit, followed by &#39;{@code .}&#39;
 184      * ({@code &#39;\u005Cu002E&#39;}), followed by decimal digits
 185      * representing the fractional part of &lt;i&gt;a&lt;/i&gt;, followed by the
 186      * letter &#39;{@code E}&#39; ({@code &#39;\u005Cu0045&#39;}), followed
 187      * by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as
 188      * produced by the method {@link Integer#toString(int)}.
 189      * &lt;/ul&gt;
 190      * &lt;/ul&gt;
 191      * How many digits must be printed for the fractional part of
 192      * &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt;? There must be at least one digit to represent
 193      * the fractional part, and beyond that as many, but only as many, more
 194      * digits as are needed to uniquely distinguish the argument value from
 195      * adjacent values of type {@code double}. That is, suppose that
 196      * &lt;i&gt;x&lt;/i&gt; is the exact mathematical value represented by the decimal
 197      * representation produced by this method for a finite nonzero argument
 198      * &lt;i&gt;d&lt;/i&gt;. Then &lt;i&gt;d&lt;/i&gt; must be the {@code double} value nearest
 199      * to &lt;i&gt;x&lt;/i&gt;; or if two {@code double} values are equally close
 200      * to &lt;i&gt;x&lt;/i&gt;, then &lt;i&gt;d&lt;/i&gt; must be one of them and the least
 201      * significant bit of the significand of &lt;i&gt;d&lt;/i&gt; must be {@code 0}.
 202      *
 203      * &lt;p&gt;To create localized string representations of a floating-point
 204      * value, use subclasses of {@link java.text.NumberFormat}.
 205      *
 206      * @param   d   the {@code double} to be converted.
 207      * @return a string representation of the argument.
 208      */
 209     public static String toString(double d) {
 210         return FloatingDecimal.toJavaFormatString(d);
 211     }
 212 
 213     /**
 214      * Returns a hexadecimal string representation of the
 215      * {@code double} argument. All characters mentioned below
 216      * are ASCII characters.
 217      *
 218      * &lt;ul&gt;
 219      * &lt;li&gt;If the argument is NaN, the result is the string
 220      *     &quot;{@code NaN}&quot;.
 221      * &lt;li&gt;Otherwise, the result is a string that represents the sign
 222      * and magnitude of the argument. If the sign is negative, the
 223      * first character of the result is &#39;{@code -}&#39;
 224      * ({@code &#39;\u005Cu002D&#39;}); if the sign is positive, no sign
 225      * character appears in the result. As for the magnitude &lt;i&gt;m&lt;/i&gt;:
 226      *
 227      * &lt;ul&gt;
 228      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the string
 229      * {@code &quot;Infinity&quot;}; thus, positive infinity produces the
 230      * result {@code &quot;Infinity&quot;} and negative infinity produces
 231      * the result {@code &quot;-Infinity&quot;}.
 232      *
 233      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the string
 234      * {@code &quot;0x0.0p0&quot;}; thus, negative zero produces the result
 235      * {@code &quot;-0x0.0p0&quot;} and positive zero produces the result
 236      * {@code &quot;0x0.0p0&quot;}.
 237      *
 238      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a
 239      * normalized representation, substrings are used to represent the
 240      * significand and exponent fields.  The significand is
 241      * represented by the characters {@code &quot;0x1.&quot;}
 242      * followed by a lowercase hexadecimal representation of the rest
 243      * of the significand as a fraction.  Trailing zeros in the
 244      * hexadecimal representation are removed unless all the digits
 245      * are zero, in which case a single zero is used. Next, the
 246      * exponent is represented by {@code &quot;p&quot;} followed
 247      * by a decimal string of the unbiased exponent as if produced by
 248      * a call to {@link Integer#toString(int) Integer.toString} on the
 249      * exponent value.
 250      *
 251      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a subnormal
 252      * representation, the significand is represented by the
 253      * characters {@code &quot;0x0.&quot;} followed by a
 254      * hexadecimal representation of the rest of the significand as a
 255      * fraction.  Trailing zeros in the hexadecimal representation are
 256      * removed. Next, the exponent is represented by
 257      * {@code &quot;p-1022&quot;}.  Note that there must be at
 258      * least one nonzero digit in a subnormal significand.
 259      *
 260      * &lt;/ul&gt;
 261      *
 262      * &lt;/ul&gt;
 263      *
 264      * &lt;table class=&quot;striped&quot;&gt;
 265      * &lt;caption&gt;Examples&lt;/caption&gt;
 266      * &lt;thead&gt;
 267      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Floating-point Value&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Hexadecimal String&lt;/th&gt;
 268      * &lt;/thead&gt;
 269      * &lt;tbody style=&quot;text-align:right&quot;&gt;
 270      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 1.0}&lt;/th&gt; &lt;td&gt;{@code 0x1.0p0}&lt;/td&gt;
 271      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code -1.0}&lt;/th&gt;        &lt;td&gt;{@code -0x1.0p0}&lt;/td&gt;
 272      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 2.0}&lt;/th&gt; &lt;td&gt;{@code 0x1.0p1}&lt;/td&gt;
 273      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 3.0}&lt;/th&gt; &lt;td&gt;{@code 0x1.8p1}&lt;/td&gt;
 274      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 0.5}&lt;/th&gt; &lt;td&gt;{@code 0x1.0p-1}&lt;/td&gt;
 275      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 0.25}&lt;/th&gt;        &lt;td&gt;{@code 0x1.0p-2}&lt;/td&gt;
 276      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Double.MAX_VALUE}&lt;/th&gt;
 277      *     &lt;td&gt;{@code 0x1.fffffffffffffp1023}&lt;/td&gt;
 278      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Minimum Normal Value}&lt;/th&gt;
 279      *     &lt;td&gt;{@code 0x1.0p-1022}&lt;/td&gt;
 280      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Maximum Subnormal Value}&lt;/th&gt;
 281      *     &lt;td&gt;{@code 0x0.fffffffffffffp-1022}&lt;/td&gt;
 282      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Double.MIN_VALUE}&lt;/th&gt;
 283      *     &lt;td&gt;{@code 0x0.0000000000001p-1022}&lt;/td&gt;
 284      * &lt;/tbody&gt;
 285      * &lt;/table&gt;
 286      * @param   d   the {@code double} to be converted.
 287      * @return a hex string representation of the argument.
 288      * @since 1.5
 289      * @author Joseph D. Darcy
 290      */
 291     public static String toHexString(double d) {
 292         /*
 293          * Modeled after the &quot;a&quot; conversion specifier in C99, section
 294          * 7.19.6.1; however, the output of this method is more
 295          * tightly specified.
 296          */
 297         if (!isFinite(d) )
 298             // For infinity and NaN, use the decimal output.
 299             return Double.toString(d);
 300         else {
 301             // Initialized to maximum size of output.
 302             StringBuilder answer = new StringBuilder(24);
 303 
 304             if (Math.copySign(1.0, d) == -1.0)    // value is negative,
 305                 answer.append(&quot;-&quot;);                  // so append sign info
 306 
 307             answer.append(&quot;0x&quot;);
 308 
 309             d = Math.abs(d);
 310 
 311             if(d == 0.0) {
 312                 answer.append(&quot;0.0p0&quot;);
 313             } else {
 314                 boolean subnormal = (d &lt; Double.MIN_NORMAL);
 315 
 316                 // Isolate significand bits and OR in a high-order bit
 317                 // so that the string representation has a known
 318                 // length.
 319                 long signifBits = (Double.doubleToLongBits(d)
 320                                    &amp; DoubleConsts.SIGNIF_BIT_MASK) |
 321                     0x1000000000000000L;
 322 
 323                 // Subnormal values have a 0 implicit bit; normal
 324                 // values have a 1 implicit bit.
 325                 answer.append(subnormal ? &quot;0.&quot; : &quot;1.&quot;);
 326 
 327                 // Isolate the low-order 13 digits of the hex
 328                 // representation.  If all the digits are zero,
 329                 // replace with a single 0; otherwise, remove all
 330                 // trailing zeros.
 331                 String signif = Long.toHexString(signifBits).substring(3,16);
 332                 answer.append(signif.equals(&quot;0000000000000&quot;) ? // 13 zeros
 333                               &quot;0&quot;:
 334                               signif.replaceFirst(&quot;0{1,12}$&quot;, &quot;&quot;));
 335 
 336                 answer.append(&#39;p&#39;);
 337                 // If the value is subnormal, use the E_min exponent
 338                 // value for double; otherwise, extract and report d&#39;s
 339                 // exponent (the representation of a subnormal uses
 340                 // E_min -1).
 341                 answer.append(subnormal ?
 342                               Double.MIN_EXPONENT:
 343                               Math.getExponent(d));
 344             }
 345             return answer.toString();
 346         }
 347     }
 348 
 349     /**
 350      * Returns a {@code Double} object holding the
 351      * {@code double} value represented by the argument string
 352      * {@code s}.
 353      *
 354      * &lt;p&gt;If {@code s} is {@code null}, then a
 355      * {@code NullPointerException} is thrown.
 356      *
 357      * &lt;p&gt;Leading and trailing whitespace characters in {@code s}
 358      * are ignored.  Whitespace is removed as if by the {@link
 359      * String#trim} method; that is, both ASCII space and control
 360      * characters are removed. The rest of {@code s} should
 361      * constitute a &lt;i&gt;FloatValue&lt;/i&gt; as described by the lexical
 362      * syntax rules:
 363      *
 364      * &lt;blockquote&gt;
 365      * &lt;dl&gt;
 366      * &lt;dt&gt;&lt;i&gt;FloatValue:&lt;/i&gt;
 367      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code NaN}
 368      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code Infinity}
 369      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; FloatingPointLiteral&lt;/i&gt;
 370      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; HexFloatingPointLiteral&lt;/i&gt;
 371      * &lt;dd&gt;&lt;i&gt;SignedInteger&lt;/i&gt;
 372      * &lt;/dl&gt;
 373      *
 374      * &lt;dl&gt;
 375      * &lt;dt&gt;&lt;i&gt;HexFloatingPointLiteral&lt;/i&gt;:
 376      * &lt;dd&gt; &lt;i&gt;HexSignificand BinaryExponent FloatTypeSuffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 377      * &lt;/dl&gt;
 378      *
 379      * &lt;dl&gt;
 380      * &lt;dt&gt;&lt;i&gt;HexSignificand:&lt;/i&gt;
 381      * &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt;
 382      * &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt; {@code .}
 383      * &lt;dd&gt;{@code 0x} &lt;i&gt;HexDigits&lt;sub&gt;opt&lt;/sub&gt;
 384      *     &lt;/i&gt;{@code .}&lt;i&gt; HexDigits&lt;/i&gt;
 385      * &lt;dd&gt;{@code 0X}&lt;i&gt; HexDigits&lt;sub&gt;opt&lt;/sub&gt;
 386      *     &lt;/i&gt;{@code .} &lt;i&gt;HexDigits&lt;/i&gt;
 387      * &lt;/dl&gt;
 388      *
 389      * &lt;dl&gt;
 390      * &lt;dt&gt;&lt;i&gt;BinaryExponent:&lt;/i&gt;
 391      * &lt;dd&gt;&lt;i&gt;BinaryExponentIndicator SignedInteger&lt;/i&gt;
 392      * &lt;/dl&gt;
 393      *
 394      * &lt;dl&gt;
 395      * &lt;dt&gt;&lt;i&gt;BinaryExponentIndicator:&lt;/i&gt;
 396      * &lt;dd&gt;{@code p}
 397      * &lt;dd&gt;{@code P}
 398      * &lt;/dl&gt;
 399      *
 400      * &lt;/blockquote&gt;
 401      *
 402      * where &lt;i&gt;Sign&lt;/i&gt;, &lt;i&gt;FloatingPointLiteral&lt;/i&gt;,
 403      * &lt;i&gt;HexNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, &lt;i&gt;SignedInteger&lt;/i&gt; and
 404      * &lt;i&gt;FloatTypeSuffix&lt;/i&gt; are as defined in the lexical structure
 405      * sections of
 406      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 407      * except that underscores are not accepted between digits.
 408      * If {@code s} does not have the form of
 409      * a &lt;i&gt;FloatValue&lt;/i&gt;, then a {@code NumberFormatException}
 410      * is thrown. Otherwise, {@code s} is regarded as
 411      * representing an exact decimal value in the usual
 412      * &quot;computerized scientific notation&quot; or as an exact
 413      * hexadecimal value; this exact numerical value is then
 414      * conceptually converted to an &quot;infinitely precise&quot;
 415      * binary value that is then rounded to type {@code double}
 416      * by the usual round-to-nearest rule of IEEE 754 floating-point
 417      * arithmetic, which includes preserving the sign of a zero
 418      * value.
 419      *
 420      * Note that the round-to-nearest rule also implies overflow and
 421      * underflow behaviour; if the exact value of {@code s} is large
 422      * enough in magnitude (greater than or equal to ({@link
 423      * #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),
 424      * rounding to {@code double} will result in an infinity and if the
 425      * exact value of {@code s} is small enough in magnitude (less
 426      * than or equal to {@link #MIN_VALUE}/2), rounding to float will
 427      * result in a zero.
 428      *
 429      * Finally, after rounding a {@code Double} object representing
 430      * this {@code double} value is returned.
 431      *
 432      * &lt;p&gt; To interpret localized string representations of a
 433      * floating-point value, use subclasses of {@link
 434      * java.text.NumberFormat}.
 435      *
 436      * &lt;p&gt;Note that trailing format specifiers, specifiers that
 437      * determine the type of a floating-point literal
 438      * ({@code 1.0f} is a {@code float} value;
 439      * {@code 1.0d} is a {@code double} value), do
 440      * &lt;em&gt;not&lt;/em&gt; influence the results of this method.  In other
 441      * words, the numerical value of the input string is converted
 442      * directly to the target floating-point type.  The two-step
 443      * sequence of conversions, string to {@code float} followed
 444      * by {@code float} to {@code double}, is &lt;em&gt;not&lt;/em&gt;
 445      * equivalent to converting a string directly to
 446      * {@code double}. For example, the {@code float}
 447      * literal {@code 0.1f} is equal to the {@code double}
 448      * value {@code 0.10000000149011612}; the {@code float}
 449      * literal {@code 0.1f} represents a different numerical
 450      * value than the {@code double} literal
 451      * {@code 0.1}. (The numerical value 0.1 cannot be exactly
 452      * represented in a binary floating-point number.)
 453      *
 454      * &lt;p&gt;To avoid calling this method on an invalid string and having
 455      * a {@code NumberFormatException} be thrown, the regular
 456      * expression below can be used to screen the input string:
 457      *
 458      * &lt;pre&gt;{@code
 459      *  final String Digits     = &quot;(\\p{Digit}+)&quot;;
 460      *  final String HexDigits  = &quot;(\\p{XDigit}+)&quot;;
 461      *  // an exponent is &#39;e&#39; or &#39;E&#39; followed by an optionally
 462      *  // signed decimal integer.
 463      *  final String Exp        = &quot;[eE][+-]?&quot;+Digits;
 464      *  final String fpRegex    =
 465      *      (&quot;[\\x00-\\x20]*&quot;+  // Optional leading &quot;whitespace&quot;
 466      *       &quot;[+-]?(&quot; + // Optional sign character
 467      *       &quot;NaN|&quot; +           // &quot;NaN&quot; string
 468      *       &quot;Infinity|&quot; +      // &quot;Infinity&quot; string
 469      *
 470      *       // A decimal floating-point string representing a finite positive
 471      *       // number without a leading sign has at most five basic pieces:
 472      *       // Digits . Digits ExponentPart FloatTypeSuffix
 473      *       //
 474      *       // Since this method allows integer-only strings as input
 475      *       // in addition to strings of floating-point literals, the
 476      *       // two sub-patterns below are simplifications of the grammar
 477      *       // productions from section 3.10.2 of
 478      *       // The Java Language Specification.
 479      *
 480      *       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt
 481      *       &quot;(((&quot;+Digits+&quot;(\\.)?(&quot;+Digits+&quot;?)(&quot;+Exp+&quot;)?)|&quot;+
 482      *
 483      *       // . Digits ExponentPart_opt FloatTypeSuffix_opt
 484      *       &quot;(\\.(&quot;+Digits+&quot;)(&quot;+Exp+&quot;)?)|&quot;+
 485      *
 486      *       // Hexadecimal strings
 487      *       &quot;((&quot; +
 488      *        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt
 489      *        &quot;(0[xX]&quot; + HexDigits + &quot;(\\.)?)|&quot; +
 490      *
 491      *        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt
 492      *        &quot;(0[xX]&quot; + HexDigits + &quot;?(\\.)&quot; + HexDigits + &quot;)&quot; +
 493      *
 494      *        &quot;)[pP][+-]?&quot; + Digits + &quot;))&quot; +
 495      *       &quot;[fFdD]?))&quot; +
 496      *       &quot;[\\x00-\\x20]*&quot;);// Optional trailing &quot;whitespace&quot;
 497      *
 498      *  if (Pattern.matches(fpRegex, myString))
 499      *      Double.valueOf(myString); // Will not throw NumberFormatException
 500      *  else {
 501      *      // Perform suitable alternative action
 502      *  }
 503      * }&lt;/pre&gt;
 504      *
 505      * @param      s   the string to be parsed.
 506      * @return     a {@code Double} object holding the value
 507      *             represented by the {@code String} argument.
 508      * @throws     NumberFormatException  if the string does not contain a
 509      *             parsable number.
 510      */
 511     public static Double valueOf(String s) throws NumberFormatException {
 512         return new Double(parseDouble(s));
 513     }
 514 
 515     /**
 516      * Returns a {@code Double} instance representing the specified
 517      * {@code double} value.
 518      * If a new {@code Double} instance is not required, this method
 519      * should generally be used in preference to the constructor
 520      * {@link #Double(double)}, as this method is likely to yield
 521      * significantly better space and time performance by caching
 522      * frequently requested values.
 523      *
 524      * @param  d a double value.
 525      * @return a {@code Double} instance representing {@code d}.
 526      * @since  1.5
 527      */
 528     @HotSpotIntrinsicCandidate
 529     public static Double valueOf(double d) {
 530         return new Double(d);
 531     }
 532 
 533     /**
 534      * Returns a new {@code double} initialized to the value
 535      * represented by the specified {@code String}, as performed
 536      * by the {@code valueOf} method of class
 537      * {@code Double}.
 538      *
 539      * @param  s   the string to be parsed.
 540      * @return the {@code double} value represented by the string
 541      *         argument.
 542      * @throws NullPointerException  if the string is null
 543      * @throws NumberFormatException if the string does not contain
 544      *         a parsable {@code double}.
 545      * @see    java.lang.Double#valueOf(String)
 546      * @since 1.2
 547      */
 548     public static double parseDouble(String s) throws NumberFormatException {
 549         return FloatingDecimal.parseDouble(s);
 550     }
 551 
 552     /**
 553      * Returns {@code true} if the specified number is a
 554      * Not-a-Number (NaN) value, {@code false} otherwise.
 555      *
 556      * @param   v   the value to be tested.
 557      * @return  {@code true} if the value of the argument is NaN;
 558      *          {@code false} otherwise.
 559      */
 560     public static boolean isNaN(double v) {
 561         return (v != v);
 562     }
 563 
 564     /**
 565      * Returns {@code true} if the specified number is infinitely
 566      * large in magnitude, {@code false} otherwise.
 567      *
 568      * @param   v   the value to be tested.
 569      * @return  {@code true} if the value of the argument is positive
 570      *          infinity or negative infinity; {@code false} otherwise.
 571      */
 572     public static boolean isInfinite(double v) {
 573         return (v == POSITIVE_INFINITY) || (v == NEGATIVE_INFINITY);
 574     }
 575 
 576     /**
 577      * Returns {@code true} if the argument is a finite floating-point
 578      * value; returns {@code false} otherwise (for NaN and infinity
 579      * arguments).
 580      *
 581      * @param d the {@code double} value to be tested
 582      * @return {@code true} if the argument is a finite
 583      * floating-point value, {@code false} otherwise.
 584      * @since 1.8
 585      */
 586     public static boolean isFinite(double d) {
 587         return Math.abs(d) &lt;= Double.MAX_VALUE;
 588     }
 589 
 590     /**
 591      * The value of the Double.
 592      *
 593      * @serial
 594      */
 595     private final double value;
 596 
 597     /**
 598      * Constructs a newly allocated {@code Double} object that
 599      * represents the primitive {@code double} argument.
 600      *
 601      * @param   value   the value to be represented by the {@code Double}.
 602      *
 603      * @deprecated
 604      * It is rarely appropriate to use this constructor. The static factory
 605      * {@link #valueOf(double)} is generally a better choice, as it is
 606      * likely to yield significantly better space and time performance.
 607      */
 608     @Deprecated(since=&quot;9&quot;)
 609     public Double(double value) {
 610         this.value = value;
 611     }
 612 
 613     /**
 614      * Constructs a newly allocated {@code Double} object that
 615      * represents the floating-point value of type {@code double}
 616      * represented by the string. The string is converted to a
 617      * {@code double} value as if by the {@code valueOf} method.
 618      *
 619      * @param  s  a string to be converted to a {@code Double}.
 620      * @throws    NumberFormatException if the string does not contain a
 621      *            parsable number.
 622      *
 623      * @deprecated
 624      * It is rarely appropriate to use this constructor.
 625      * Use {@link #parseDouble(String)} to convert a string to a
 626      * {@code double} primitive, or use {@link #valueOf(String)}
 627      * to convert a string to a {@code Double} object.
 628      */
 629     @Deprecated(since=&quot;9&quot;)
 630     public Double(String s) throws NumberFormatException {
 631         value = parseDouble(s);
 632     }
 633 
 634     /**
 635      * Returns {@code true} if this {@code Double} value is
 636      * a Not-a-Number (NaN), {@code false} otherwise.
 637      *
 638      * @return  {@code true} if the value represented by this object is
 639      *          NaN; {@code false} otherwise.
 640      */
 641     public boolean isNaN() {
 642         return isNaN(value);
 643     }
 644 
 645     /**
 646      * Returns {@code true} if this {@code Double} value is
 647      * infinitely large in magnitude, {@code false} otherwise.
 648      *
 649      * @return  {@code true} if the value represented by this object is
 650      *          positive infinity or negative infinity;
 651      *          {@code false} otherwise.
 652      */
 653     public boolean isInfinite() {
 654         return isInfinite(value);
 655     }
 656 
 657     /**
 658      * Returns a string representation of this {@code Double} object.
 659      * The primitive {@code double} value represented by this
 660      * object is converted to a string exactly as if by the method
 661      * {@code toString} of one argument.
 662      *
 663      * @return  a {@code String} representation of this object.
 664      * @see java.lang.Double#toString(double)
 665      */
 666     public String toString() {
 667         return toString(value);
 668     }
 669 
 670     /**
 671      * Returns the value of this {@code Double} as a {@code byte}
 672      * after a narrowing primitive conversion.
 673      *
 674      * @return  the {@code double} value represented by this object
 675      *          converted to type {@code byte}
 676      * @jls 5.1.3 Narrowing Primitive Conversions
 677      * @since 1.1
 678      */
 679     public byte byteValue() {
 680         return (byte)value;
 681     }
 682 
 683     /**
 684      * Returns the value of this {@code Double} as a {@code short}
 685      * after a narrowing primitive conversion.
 686      *
 687      * @return  the {@code double} value represented by this object
 688      *          converted to type {@code short}
 689      * @jls 5.1.3 Narrowing Primitive Conversions
 690      * @since 1.1
 691      */
 692     public short shortValue() {
 693         return (short)value;
 694     }
 695 
 696     /**
 697      * Returns the value of this {@code Double} as an {@code int}
 698      * after a narrowing primitive conversion.
 699      * @jls 5.1.3 Narrowing Primitive Conversions
 700      *
 701      * @return  the {@code double} value represented by this object
 702      *          converted to type {@code int}
 703      */
 704     public int intValue() {
 705         return (int)value;
 706     }
 707 
 708     /**
 709      * Returns the value of this {@code Double} as a {@code long}
 710      * after a narrowing primitive conversion.
 711      *
 712      * @return  the {@code double} value represented by this object
 713      *          converted to type {@code long}
 714      * @jls 5.1.3 Narrowing Primitive Conversions
 715      */
 716     public long longValue() {
 717         return (long)value;
 718     }
 719 
 720     /**
 721      * Returns the value of this {@code Double} as a {@code float}
 722      * after a narrowing primitive conversion.
 723      *
 724      * @return  the {@code double} value represented by this object
 725      *          converted to type {@code float}
 726      * @jls 5.1.3 Narrowing Primitive Conversions
 727      * @since 1.0
 728      */
 729     public float floatValue() {
 730         return (float)value;
 731     }
 732 
 733     /**
 734      * Returns the {@code double} value of this {@code Double} object.
 735      *
 736      * @return the {@code double} value represented by this object
 737      */
 738     @HotSpotIntrinsicCandidate
 739     public double doubleValue() {
 740         return value;
 741     }
 742 
 743     /**
 744      * Returns a hash code for this {@code Double} object. The
 745      * result is the exclusive OR of the two halves of the
 746      * {@code long} integer bit representation, exactly as
 747      * produced by the method {@link #doubleToLongBits(double)}, of
 748      * the primitive {@code double} value represented by this
 749      * {@code Double} object. That is, the hash code is the value
 750      * of the expression:
 751      *
 752      * &lt;blockquote&gt;
 753      *  {@code (int)(v^(v&gt;&gt;&gt;32))}
 754      * &lt;/blockquote&gt;
 755      *
 756      * where {@code v} is defined by:
 757      *
 758      * &lt;blockquote&gt;
 759      *  {@code long v = Double.doubleToLongBits(this.doubleValue());}
 760      * &lt;/blockquote&gt;
 761      *
 762      * @return  a {@code hash code} value for this object.
 763      */
 764     @Override
 765     public int hashCode() {
 766         return Double.hashCode(value);
 767     }
 768 
 769     /**
 770      * Returns a hash code for a {@code double} value; compatible with
 771      * {@code Double.hashCode()}.
 772      *
 773      * @param value the value to hash
 774      * @return a hash code value for a {@code double} value.
 775      * @since 1.8
 776      */
 777     public static int hashCode(double value) {
 778         long bits = doubleToLongBits(value);
 779         return (int)(bits ^ (bits &gt;&gt;&gt; 32));
 780     }
 781 
 782     /**
 783      * Compares this object against the specified object.  The result
 784      * is {@code true} if and only if the argument is not
 785      * {@code null} and is a {@code Double} object that
 786      * represents a {@code double} that has the same value as the
 787      * {@code double} represented by this object. For this
 788      * purpose, two {@code double} values are considered to be
 789      * the same if and only if the method {@link
 790      * #doubleToLongBits(double)} returns the identical
 791      * {@code long} value when applied to each.
 792      *
 793      * &lt;p&gt;Note that in most cases, for two instances of class
 794      * {@code Double}, {@code d1} and {@code d2}, the
 795      * value of {@code d1.equals(d2)} is {@code true} if and
 796      * only if
 797      *
 798      * &lt;blockquote&gt;
 799      *  {@code d1.doubleValue() == d2.doubleValue()}
 800      * &lt;/blockquote&gt;
 801      *
 802      * &lt;p&gt;also has the value {@code true}. However, there are two
 803      * exceptions:
 804      * &lt;ul&gt;
 805      * &lt;li&gt;If {@code d1} and {@code d2} both represent
 806      *     {@code Double.NaN}, then the {@code equals} method
 807      *     returns {@code true}, even though
 808      *     {@code Double.NaN==Double.NaN} has the value
 809      *     {@code false}.
 810      * &lt;li&gt;If {@code d1} represents {@code +0.0} while
 811      *     {@code d2} represents {@code -0.0}, or vice versa,
 812      *     the {@code equal} test has the value {@code false},
 813      *     even though {@code +0.0==-0.0} has the value {@code true}.
 814      * &lt;/ul&gt;
 815      * This definition allows hash tables to operate properly.
 816      * @param   obj   the object to compare with.
 817      * @return  {@code true} if the objects are the same;
 818      *          {@code false} otherwise.
 819      * @see java.lang.Double#doubleToLongBits(double)
 820      */
 821     public boolean equals(Object obj) {
 822         return (obj instanceof Double)
 823                &amp;&amp; (doubleToLongBits(((Double)obj).value) ==
 824                       doubleToLongBits(value));
 825     }
 826 
 827     /**
 828      * Returns a representation of the specified floating-point value
 829      * according to the IEEE 754 floating-point &quot;double
 830      * format&quot; bit layout.
 831      *
 832      * &lt;p&gt;Bit 63 (the bit that is selected by the mask
 833      * {@code 0x8000000000000000L}) represents the sign of the
 834      * floating-point number. Bits
 835      * 62-52 (the bits that are selected by the mask
 836      * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0
 837      * (the bits that are selected by the mask
 838      * {@code 0x000fffffffffffffL}) represent the significand
 839      * (sometimes called the mantissa) of the floating-point number.
 840      *
 841      * &lt;p&gt;If the argument is positive infinity, the result is
 842      * {@code 0x7ff0000000000000L}.
 843      *
 844      * &lt;p&gt;If the argument is negative infinity, the result is
 845      * {@code 0xfff0000000000000L}.
 846      *
 847      * &lt;p&gt;If the argument is NaN, the result is
 848      * {@code 0x7ff8000000000000L}.
 849      *
 850      * &lt;p&gt;In all cases, the result is a {@code long} integer that, when
 851      * given to the {@link #longBitsToDouble(long)} method, will produce a
 852      * floating-point value the same as the argument to
 853      * {@code doubleToLongBits} (except all NaN values are
 854      * collapsed to a single &quot;canonical&quot; NaN value).
 855      *
 856      * @param   value   a {@code double} precision floating-point number.
 857      * @return the bits that represent the floating-point number.
 858      */
 859     @HotSpotIntrinsicCandidate
 860     public static long doubleToLongBits(double value) {
 861         if (!isNaN(value)) {
 862             return doubleToRawLongBits(value);
 863         }
 864         return 0x7ff8000000000000L;
 865     }
 866 
 867     /**
 868      * Returns a representation of the specified floating-point value
 869      * according to the IEEE 754 floating-point &quot;double
 870      * format&quot; bit layout, preserving Not-a-Number (NaN) values.
 871      *
 872      * &lt;p&gt;Bit 63 (the bit that is selected by the mask
 873      * {@code 0x8000000000000000L}) represents the sign of the
 874      * floating-point number. Bits
 875      * 62-52 (the bits that are selected by the mask
 876      * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0
 877      * (the bits that are selected by the mask
 878      * {@code 0x000fffffffffffffL}) represent the significand
 879      * (sometimes called the mantissa) of the floating-point number.
 880      *
 881      * &lt;p&gt;If the argument is positive infinity, the result is
 882      * {@code 0x7ff0000000000000L}.
 883      *
 884      * &lt;p&gt;If the argument is negative infinity, the result is
 885      * {@code 0xfff0000000000000L}.
 886      *
 887      * &lt;p&gt;If the argument is NaN, the result is the {@code long}
 888      * integer representing the actual NaN value.  Unlike the
 889      * {@code doubleToLongBits} method,
 890      * {@code doubleToRawLongBits} does not collapse all the bit
 891      * patterns encoding a NaN to a single &quot;canonical&quot; NaN
 892      * value.
 893      *
 894      * &lt;p&gt;In all cases, the result is a {@code long} integer that,
 895      * when given to the {@link #longBitsToDouble(long)} method, will
 896      * produce a floating-point value the same as the argument to
 897      * {@code doubleToRawLongBits}.
 898      *
 899      * @param   value   a {@code double} precision floating-point number.
 900      * @return the bits that represent the floating-point number.
 901      * @since 1.3
 902      */
 903     @HotSpotIntrinsicCandidate
 904     public static native long doubleToRawLongBits(double value);
 905 
 906     /**
 907      * Returns the {@code double} value corresponding to a given
 908      * bit representation.
 909      * The argument is considered to be a representation of a
 910      * floating-point value according to the IEEE 754 floating-point
 911      * &quot;double format&quot; bit layout.
 912      *
 913      * &lt;p&gt;If the argument is {@code 0x7ff0000000000000L}, the result
 914      * is positive infinity.
 915      *
 916      * &lt;p&gt;If the argument is {@code 0xfff0000000000000L}, the result
 917      * is negative infinity.
 918      *
 919      * &lt;p&gt;If the argument is any value in the range
 920      * {@code 0x7ff0000000000001L} through
 921      * {@code 0x7fffffffffffffffL} or in the range
 922      * {@code 0xfff0000000000001L} through
 923      * {@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE
 924      * 754 floating-point operation provided by Java can distinguish
 925      * between two NaN values of the same type with different bit
 926      * patterns.  Distinct values of NaN are only distinguishable by
 927      * use of the {@code Double.doubleToRawLongBits} method.
 928      *
 929      * &lt;p&gt;In all other cases, let &lt;i&gt;s&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt;, and &lt;i&gt;m&lt;/i&gt; be three
 930      * values that can be computed from the argument:
 931      *
 932      * &lt;blockquote&gt;&lt;pre&gt;{@code
 933      * int s = ((bits &gt;&gt; 63) == 0) ? 1 : -1;
 934      * int e = (int)((bits &gt;&gt; 52) &amp; 0x7ffL);
 935      * long m = (e == 0) ?
 936      *                 (bits &amp; 0xfffffffffffffL) &lt;&lt; 1 :
 937      *                 (bits &amp; 0xfffffffffffffL) | 0x10000000000000L;
 938      * }&lt;/pre&gt;&lt;/blockquote&gt;
 939      *
 940      * Then the floating-point result equals the value of the mathematical
 941      * expression &lt;i&gt;s&lt;/i&gt;&amp;middot;&lt;i&gt;m&lt;/i&gt;&amp;middot;2&lt;sup&gt;&lt;i&gt;e&lt;/i&gt;-1075&lt;/sup&gt;.
 942      *
 943      * &lt;p&gt;Note that this method may not be able to return a
 944      * {@code double} NaN with exactly same bit pattern as the
 945      * {@code long} argument.  IEEE 754 distinguishes between two
 946      * kinds of NaNs, quiet NaNs and &lt;i&gt;signaling NaNs&lt;/i&gt;.  The
 947      * differences between the two kinds of NaN are generally not
 948      * visible in Java.  Arithmetic operations on signaling NaNs turn
 949      * them into quiet NaNs with a different, but often similar, bit
 950      * pattern.  However, on some processors merely copying a
 951      * signaling NaN also performs that conversion.  In particular,
 952      * copying a signaling NaN to return it to the calling method
 953      * may perform this conversion.  So {@code longBitsToDouble}
 954      * may not be able to return a {@code double} with a
 955      * signaling NaN bit pattern.  Consequently, for some
 956      * {@code long} values,
 957      * {@code doubleToRawLongBits(longBitsToDouble(start))} may
 958      * &lt;i&gt;not&lt;/i&gt; equal {@code start}.  Moreover, which
 959      * particular bit patterns represent signaling NaNs is platform
 960      * dependent; although all NaN bit patterns, quiet or signaling,
 961      * must be in the NaN range identified above.
 962      *
 963      * @param   bits   any {@code long} integer.
 964      * @return  the {@code double} floating-point value with the same
 965      *          bit pattern.
 966      */
 967     @HotSpotIntrinsicCandidate
 968     public static native double longBitsToDouble(long bits);
 969 
 970     /**
 971      * Compares two {@code Double} objects numerically.  There
 972      * are two ways in which comparisons performed by this method
 973      * differ from those performed by the Java language numerical
 974      * comparison operators ({@code &lt;, &lt;=, ==, &gt;=, &gt;})
 975      * when applied to primitive {@code double} values:
 976      * &lt;ul&gt;&lt;li&gt;
 977      *          {@code Double.NaN} is considered by this method
 978      *          to be equal to itself and greater than all other
 979      *          {@code double} values (including
 980      *          {@code Double.POSITIVE_INFINITY}).
 981      * &lt;li&gt;
 982      *          {@code 0.0d} is considered by this method to be greater
 983      *          than {@code -0.0d}.
 984      * &lt;/ul&gt;
 985      * This ensures that the &lt;i&gt;natural ordering&lt;/i&gt; of
 986      * {@code Double} objects imposed by this method is &lt;i&gt;consistent
 987      * with equals&lt;/i&gt;.
 988      *
 989      * @param   anotherDouble   the {@code Double} to be compared.
 990      * @return  the value {@code 0} if {@code anotherDouble} is
 991      *          numerically equal to this {@code Double}; a value
 992      *          less than {@code 0} if this {@code Double}
 993      *          is numerically less than {@code anotherDouble};
 994      *          and a value greater than {@code 0} if this
 995      *          {@code Double} is numerically greater than
 996      *          {@code anotherDouble}.
 997      *
 998      * @since   1.2
 999      */
1000     public int compareTo(Double anotherDouble) {
1001         return Double.compare(value, anotherDouble.value);
1002     }
1003 
1004     /**
1005      * Compares the two specified {@code double} values. The sign
1006      * of the integer value returned is the same as that of the
1007      * integer that would be returned by the call:
1008      * &lt;pre&gt;
1009      *    new Double(d1).compareTo(new Double(d2))
1010      * &lt;/pre&gt;
1011      *
1012      * @param   d1        the first {@code double} to compare
1013      * @param   d2        the second {@code double} to compare
1014      * @return  the value {@code 0} if {@code d1} is
1015      *          numerically equal to {@code d2}; a value less than
1016      *          {@code 0} if {@code d1} is numerically less than
1017      *          {@code d2}; and a value greater than {@code 0}
1018      *          if {@code d1} is numerically greater than
1019      *          {@code d2}.
1020      * @since 1.4
1021      */
1022     public static int compare(double d1, double d2) {
1023         if (d1 &lt; d2)
1024             return -1;           // Neither val is NaN, thisVal is smaller
1025         if (d1 &gt; d2)
1026             return 1;            // Neither val is NaN, thisVal is larger
1027 
1028         // Cannot use doubleToRawLongBits because of possibility of NaNs.
1029         long thisBits    = Double.doubleToLongBits(d1);
1030         long anotherBits = Double.doubleToLongBits(d2);
1031 
1032         return (thisBits == anotherBits ?  0 : // Values are equal
1033                 (thisBits &lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN)
1034                  1));                          // (0.0, -0.0) or (NaN, !NaN)
1035     }
1036 
1037     /**
1038      * Adds two {@code double} values together as per the + operator.
1039      *
1040      * @param a the first operand
1041      * @param b the second operand
1042      * @return the sum of {@code a} and {@code b}
1043      * @jls 4.2.4 Floating-Point Operations
1044      * @see java.util.function.BinaryOperator
1045      * @since 1.8
1046      */
1047     public static double sum(double a, double b) {
1048         return a + b;
1049     }
1050 
1051     /**
1052      * Returns the greater of two {@code double} values
1053      * as if by calling {@link Math#max(double, double) Math.max}.
1054      *
1055      * @param a the first operand
1056      * @param b the second operand
1057      * @return the greater of {@code a} and {@code b}
1058      * @see java.util.function.BinaryOperator
1059      * @since 1.8
1060      */
1061     public static double max(double a, double b) {
1062         return Math.max(a, b);
1063     }
1064 
1065     /**
1066      * Returns the smaller of two {@code double} values
1067      * as if by calling {@link Math#min(double, double) Math.min}.
1068      *
1069      * @param a the first operand
1070      * @param b the second operand
1071      * @return the smaller of {@code a} and {@code b}.
1072      * @see java.util.function.BinaryOperator
1073      * @since 1.8
1074      */
1075     public static double min(double a, double b) {
1076         return Math.min(a, b);
1077     }
1078 
1079     /**
1080      * Returns an {@link Optional} containing the nominal descriptor for this
1081      * instance, which is the instance itself.
1082      *
1083      * @return an {@link Optional} describing the {@linkplain Double} instance
1084      * @since 12
1085      */
1086     @Override
1087     public Optional&lt;Double&gt; describeConstable() {
1088         return Optional.of(this);
1089     }
1090 
1091     /**
1092      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1093      * the instance itself.
1094      *
1095      * @param lookup ignored
1096      * @return the {@linkplain Double} instance
1097      * @since 12
1098      */
1099     @Override
1100     public Double resolveConstantDesc(MethodHandles.Lookup lookup) {
1101         return this;
1102     }
1103 
1104     /** use serialVersionUID from JDK 1.0.2 for interoperability */
1105     private static final long serialVersionUID = -9172774392245257468L;
1106 }
    </pre>
  </body>
</html>
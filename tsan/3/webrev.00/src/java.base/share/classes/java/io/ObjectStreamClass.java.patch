diff a/src/java.base/share/classes/java/io/ObjectStreamClass.java b/src/java.base/share/classes/java/io/ObjectStreamClass.java
--- a/src/java.base/share/classes/java/io/ObjectStreamClass.java
+++ b/src/java.base/share/classes/java/io/ObjectStreamClass.java
@@ -23,17 +23,20 @@
  * questions.
  */
 
 package java.io;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.RecordComponent;
 import java.lang.reflect.UndeclaredThrowableException;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
@@ -42,10 +45,12 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.PermissionCollection;
 import java.security.Permissions;
 import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
@@ -82,11 +87,13 @@
 
     /** serialPersistentFields value indicating no serializable fields */
     public static final ObjectStreamField[] NO_FIELDS =
         new ObjectStreamField[0];
 
+    @java.io.Serial
     private static final long serialVersionUID = -6120832682080437368L;
+    @java.io.Serial
     private static final ObjectStreamField[] serialPersistentFields =
         NO_FIELDS;
 
     /** reflection factory for obtaining serialization constructors */
     private static final ReflectionFactory reflFactory =
@@ -119,10 +126,12 @@
 
     /** true if represents dynamic proxy class */
     private boolean isProxy;
     /** true if represents enum type */
     private boolean isEnum;
+    /** true if represents record type */
+    private boolean isRecord;
     /** true if represented class implements Serializable */
     private boolean serializable;
     /** true if represented class implements Externalizable */
     private boolean externalizable;
     /** true if desc has data written by class-defined writeObject method */
@@ -180,10 +189,12 @@
     /** data layout of serialized objects described by this class desc */
     private volatile ClassDataSlot[] dataLayout;
 
     /** serialization-appropriate constructor, or null if none */
     private Constructor<?> cons;
+    /** record canonical constructor, or null */
+    private MethodHandle canonicalCtr;
     /** protection domains that need to be checked when calling the constructor */
     private ProtectionDomain[] domains;
 
     /** class-defined writeObject method, or null if none */
     private Method writeObjectMethod;
@@ -257,10 +268,13 @@
      * @return  the SUID of the class described by this descriptor
      */
     public long getSerialVersionUID() {
         // REMIND: synchronize instead of relying on volatile?
         if (suid == null) {
+            if (isRecord)
+                return 0L;
+
             suid = AccessController.doPrivileged(
                 new PrivilegedAction<Long>() {
                     public Long run() {
                         return computeDefaultSUID(cl);
                     }
@@ -272,11 +286,11 @@
 
     /**
      * Return the class in the local VM that this version is mapped to.  Null
      * is returned if there is no corresponding local class.
      *
-     * @return  the <code>Class</code> instance that this descriptor represents
+     * @return  the {@code Class} instance that this descriptor represents
      */
     @CallerSensitive
     public Class<?> forClass() {
         if (cl == null) {
             return null;
@@ -463,18 +477,24 @@
         Thread getOwner() {
             return owner;
         }
     }
 
+    @SuppressWarnings("preview")
+    private static boolean isRecord(Class<?> cls) {
+        return cls.isRecord();
+    }
+
     /**
      * Creates local class descriptor representing given class.
      */
     private ObjectStreamClass(final Class<?> cl) {
         this.cl = cl;
         name = cl.getName();
         isProxy = Proxy.isProxyClass(cl);
         isEnum = Enum.class.isAssignableFrom(cl);
+        isRecord = isRecord(cl);
         serializable = Serializable.class.isAssignableFrom(cl);
         externalizable = Externalizable.class.isAssignableFrom(cl);
 
         Class<?> superCl = cl.getSuperclass();
         superDesc = (superCl != null) ? lookup(superCl, false) : null;
@@ -501,11 +521,13 @@
                         serializeEx = deserializeEx =
                             new ExceptionInfo(e.classname, e.getMessage());
                         fields = NO_FIELDS;
                     }
 
-                    if (externalizable) {
+                    if (isRecord) {
+                        canonicalCtr = canonicalRecordCtr(cl);
+                    } else if (externalizable) {
                         cons = getExternalizableConstructor(cl);
                     } else {
                         cons = getSerializableConstructor(cl);
                         writeObjectMethod = getPrivateMethod(cl, "writeObject",
                             new Class<?>[] { ObjectOutputStream.class },
@@ -538,18 +560,22 @@
         }
 
         if (deserializeEx == null) {
             if (isEnum) {
                 deserializeEx = new ExceptionInfo(name, "enum type");
-            } else if (cons == null) {
+            } else if (cons == null && !isRecord) {
                 deserializeEx = new ExceptionInfo(name, "no valid constructor");
             }
         }
-        for (int i = 0; i < fields.length; i++) {
-            if (fields[i].getField() == null) {
-                defaultSerializeEx = new ExceptionInfo(
-                    name, "unmatched serializable field(s) declared");
+        if (isRecord && canonicalCtr == null) {
+            deserializeEx = new ExceptionInfo(name, "record canonical constructor not found");
+        } else {
+            for (int i = 0; i < fields.length; i++) {
+                if (fields[i].getField() == null) {
+                    defaultSerializeEx = new ExceptionInfo(
+                        name, "unmatched serializable field(s) declared");
+                }
             }
         }
         initialized = true;
     }
 
@@ -678,11 +704,11 @@
                         "cannot bind enum descriptor to a non-enum class" :
                         "cannot bind non-enum descriptor to an enum class");
             }
 
             if (model.serializable == osc.serializable &&
-                    !cl.isArray() &&
+                    !cl.isArray() && !isRecord(cl) &&
                     suid != osc.getSerialVersionUID()) {
                 throw new InvalidClassException(osc.name,
                         "local class incompatible: " +
                                 "stream classdesc serialVersionUID = " + suid +
                                 ", local class serialVersionUID = " +
@@ -710,10 +736,14 @@
                 }
             }
         }
 
         this.cl = cl;
+        if (cl != null) {
+            this.isRecord = isRecord(cl);
+            this.canonicalCtr = osc.canonicalCtr;
+        }
         this.resolveEx = resolveEx;
         this.superDesc = superDesc;
         name = model.name;
         this.suid = suid;
         isProxy = false;
@@ -735,16 +765,18 @@
             readResolveMethod = localDesc.readResolveMethod;
             if (deserializeEx == null) {
                 deserializeEx = localDesc.deserializeEx;
             }
             domains = localDesc.domains;
+            assert isRecord(cl) ? localDesc.cons == null : true;
             cons = localDesc.cons;
         }
 
         fieldRefl = getReflector(fields, localDesc);
         // reassign to matched fields so as to reflect local unshared settings
         fields = fieldRefl.getFields();
+
         initialized = true;
     }
 
     /**
      * Reads non-proxy class descriptor information from given input stream.
@@ -962,10 +994,19 @@
     boolean isEnum() {
         requireInitialized();
         return isEnum;
     }
 
+    /**
+     * Returns true if class descriptor represents a record type, false
+     * otherwise.
+     */
+    boolean isRecord() {
+        requireInitialized();
+        return isRecord;
+    }
+
     /**
      * Returns true if represented class implements Externalizable, false
      * otherwise.
      */
     boolean isExternalizable() {
@@ -1514,10 +1555,41 @@
      */
     private static Constructor<?> getSerializableConstructor(Class<?> cl) {
         return reflFactory.newConstructorForSerialization(cl);
     }
 
+    /**
+     * Returns the canonical constructor for the given record class, or null if
+     * the not found ( which should never happen for correctly generated record
+     * classes ).
+     */
+    @SuppressWarnings("preview")
+    private static MethodHandle canonicalRecordCtr(Class<?> cls) {
+        assert isRecord(cls) : "Expected record, got: " + cls;
+        PrivilegedAction<MethodHandle> pa = () -> {
+            Class<?>[] paramTypes = Arrays.stream(cls.getRecordComponents())
+                                          .map(RecordComponent::getType)
+                                          .toArray(Class<?>[]::new);
+            try {
+                Constructor<?> ctr = cls.getConstructor(paramTypes);
+                ctr.setAccessible(true);
+                return MethodHandles.lookup().unreflectConstructor(ctr);
+            } catch (IllegalAccessException | NoSuchMethodException e) {
+                return null;
+            }
+        };
+        return AccessController.doPrivileged(pa);
+    }
+
+    /**
+     * Returns the canonical constructor, if the local class equivalent of this
+     * stream class descriptor is a record class, otherwise null.
+     */
+    MethodHandle getRecordConstructor() {
+        return canonicalCtr;
+    }
+
     /**
      * Returns non-static, non-abstract method with given signature provided it
      * is defined by or accessible (via inheritance) by the given class, or
      * null if no match found.  Access checks are disabled on the returned
      * method (if any).
@@ -1637,16 +1709,20 @@
      * declared) serializable fields are invalid.
      */
     private static ObjectStreamField[] getSerialFields(Class<?> cl)
         throws InvalidClassException
     {
+        if (!Serializable.class.isAssignableFrom(cl))
+            return NO_FIELDS;
+
         ObjectStreamField[] fields;
-        if (Serializable.class.isAssignableFrom(cl) &&
-            !Externalizable.class.isAssignableFrom(cl) &&
+        if (isRecord(cl)) {
+            fields = getDefaultSerialFields(cl);
+            Arrays.sort(fields);
+        } else if (!Externalizable.class.isAssignableFrom(cl) &&
             !Proxy.isProxyClass(cl) &&
-            !cl.isInterface())
-        {
+                   !cl.isInterface()) {
             if ((fields = getDeclaredSerialFields(cl)) == null) {
                 fields = getDefaultSerialFields(cl);
             }
             Arrays.sort(fields);
         } else {
@@ -2434,6 +2510,117 @@
             } else {
                 return false;
             }
         }
     }
+
+    /** Record specific support for retrieving and binding stream field values. */
+    static final class RecordSupport {
+
+        /** Binds the given stream field values to the given method handle. */
+        @SuppressWarnings("preview")
+        static MethodHandle bindCtrValues(MethodHandle ctrMH,
+                                          ObjectStreamClass desc,
+                                          ObjectInputStream.FieldValues fieldValues) {
+            RecordComponent[] recordComponents;
+            try {
+                Class<?> cls = desc.forClass();
+                PrivilegedExceptionAction<RecordComponent[]> pa = cls::getRecordComponents;
+                recordComponents = AccessController.doPrivileged(pa);
+            } catch (PrivilegedActionException e) {
+                throw new InternalError(e.getCause());
+            }
+
+            Object[] args = new Object[recordComponents.length];
+            for (int i = 0; i < recordComponents.length; i++) {
+                String name = recordComponents[i].getName();
+                Class<?> type= recordComponents[i].getType();
+                Object o = streamFieldValue(name, type, desc, fieldValues);
+                args[i] = o;
+            }
+
+            return MethodHandles.insertArguments(ctrMH, 0, args);
+        }
+
+        /** Returns the number of primitive fields for the given descriptor. */
+        private static int numberPrimValues(ObjectStreamClass desc) {
+            ObjectStreamField[] fields = desc.getFields();
+            int primValueCount = 0;
+            for (int i = 0; i < fields.length; i++) {
+                if (fields[i].isPrimitive())
+                    primValueCount++;
+                else
+                    break;  // can be no more
+            }
+            return primValueCount;
+        }
+
+        /** Returns the default value for the given type. */
+        private static Object defaultValueFor(Class<?> pType) {
+            if (pType == Integer.TYPE)
+                return 0;
+            else if (pType == Byte.TYPE)
+                return (byte)0;
+            else if (pType == Long.TYPE)
+                return 0L;
+            else if (pType == Float.TYPE)
+                return 0.0f;
+            else if (pType == Double.TYPE)
+                return 0.0d;
+            else if (pType == Short.TYPE)
+                return (short)0;
+            else if (pType == Character.TYPE)
+                return '\u0000';
+            else if (pType == Boolean.TYPE)
+                return false;
+            else
+                return null;
+        }
+
+        /**
+         * Returns the stream field value for the given name. The default value
+         * for the given type is returned if the field value is absent.
+         */
+        private static Object streamFieldValue(String pName,
+                                               Class<?> pType,
+                                               ObjectStreamClass desc,
+                                               ObjectInputStream.FieldValues fieldValues) {
+            ObjectStreamField[] fields = desc.getFields();
+
+            for (int i = 0; i < fields.length; i++) {
+                ObjectStreamField f = fields[i];
+                String fName = f.getName();
+                if (!fName.equals(pName))
+                    continue;
+
+                Class<?> fType = f.getField().getType();
+                if (!pType.isAssignableFrom(fType))
+                    throw new InternalError(fName + " unassignable, pType:" + pType + ", fType:" + fType);
+
+                if (f.isPrimitive()) {
+                    if (pType == Integer.TYPE)
+                        return Bits.getInt(fieldValues.primValues, f.getOffset());
+                    else if (fType == Byte.TYPE)
+                        return fieldValues.primValues[f.getOffset()];
+                    else if (fType == Long.TYPE)
+                        return Bits.getLong(fieldValues.primValues, f.getOffset());
+                    else if (fType == Float.TYPE)
+                        return Bits.getFloat(fieldValues.primValues, f.getOffset());
+                    else if (fType == Double.TYPE)
+                        return Bits.getDouble(fieldValues.primValues, f.getOffset());
+                    else if (fType == Short.TYPE)
+                        return Bits.getShort(fieldValues.primValues, f.getOffset());
+                    else if (fType == Character.TYPE)
+                        return Bits.getChar(fieldValues.primValues, f.getOffset());
+                    else if (fType == Boolean.TYPE)
+                        return Bits.getBoolean(fieldValues.primValues, f.getOffset());
+                    else
+                        throw new InternalError("Unexpected type: " + fType);
+                } else { // reference
+                    return fieldValues.objValues[i - numberPrimValues(desc)];
+                }
+            }
+
+            return defaultValueFor(pType);
+        }
+    }
 }

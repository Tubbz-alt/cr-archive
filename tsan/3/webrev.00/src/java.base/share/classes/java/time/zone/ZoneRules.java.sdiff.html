<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/time/zone/ZoneRules.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZoneOffsetTransitionRule.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/AbstractCollection.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/time/zone/ZoneRules.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time.zone;
  63 
  64 import java.io.DataInput;
  65 import java.io.DataOutput;
  66 import java.io.IOException;
  67 import java.io.InvalidObjectException;
  68 import java.io.ObjectInputStream;
  69 import java.io.Serializable;
  70 import java.time.Duration;
  71 import java.time.Instant;
<span class="line-removed">  72 import java.time.LocalDate;</span>
  73 import java.time.LocalDateTime;
  74 import java.time.ZoneId;
  75 import java.time.ZoneOffset;
  76 import java.time.Year;
  77 import java.util.ArrayList;
  78 import java.util.Arrays;
  79 import java.util.Collections;
  80 import java.util.List;
  81 import java.util.Objects;
  82 import java.util.concurrent.ConcurrentHashMap;
  83 import java.util.concurrent.ConcurrentMap;
  84 
  85 /**
  86  * The rules defining how the zone offset varies for a single time-zone.
  87  * &lt;p&gt;
  88  * The rules model all the historic and future transitions for a time-zone.
  89  * {@link ZoneOffsetTransition} is used for known transitions, typically historic.
  90  * {@link ZoneOffsetTransitionRule} is used for future transitions that are based
  91  * on the result of an algorithm.
  92  * &lt;p&gt;
</pre>
<hr />
<pre>
 145      */
 146     private final ZoneOffsetTransitionRule[] lastRules;
 147     /**
 148      * The map of recent transitions.
 149      */
 150     private final transient ConcurrentMap&lt;Integer, ZoneOffsetTransition[]&gt; lastRulesCache =
 151                 new ConcurrentHashMap&lt;Integer, ZoneOffsetTransition[]&gt;();
 152     /**
 153      * The zero-length long array.
 154      */
 155     private static final long[] EMPTY_LONG_ARRAY = new long[0];
 156     /**
 157      * The zero-length lastrules array.
 158      */
 159     private static final ZoneOffsetTransitionRule[] EMPTY_LASTRULES =
 160         new ZoneOffsetTransitionRule[0];
 161     /**
 162      * The zero-length ldt array.
 163      */
 164     private static final LocalDateTime[] EMPTY_LDT_ARRAY = new LocalDateTime[0];










 165 
 166     /**
 167      * Obtains an instance of a ZoneRules.
 168      *
 169      * @param baseStandardOffset  the standard offset to use before legal rules were set, not null
 170      * @param baseWallOffset  the wall offset to use before legal rules were set, not null
 171      * @param standardOffsetTransitionList  the list of changes to the standard offset, not null
 172      * @param transitionList  the list of transitions, not null
 173      * @param lastRules  the recurring last rules, size 16 or less, not null
 174      * @return the zone rules, not null
 175      */
 176     public static ZoneRules of(ZoneOffset baseStandardOffset,
 177                                ZoneOffset baseWallOffset,
 178                                List&lt;ZoneOffsetTransition&gt; standardOffsetTransitionList,
 179                                List&lt;ZoneOffsetTransition&gt; transitionList,
 180                                List&lt;ZoneOffsetTransitionRule&gt; lastRules) {
 181         Objects.requireNonNull(baseStandardOffset, &quot;baseStandardOffset&quot;);
 182         Objects.requireNonNull(baseWallOffset, &quot;baseWallOffset&quot;);
 183         Objects.requireNonNull(standardOffsetTransitionList, &quot;standardOffsetTransitionList&quot;);
 184         Objects.requireNonNull(transitionList, &quot;transitionList&quot;);
</pre>
<hr />
<pre>
 904             int lastHistoricYear = findYear(lastHistoric, lastHistoricOffset);
 905             if (--year &gt; lastHistoricYear) {
 906                 transArray = findTransitionArray(year);
 907                 return transArray[transArray.length - 1];
 908             }
 909             // drop through
 910         }
 911 
 912         // using historic rules
 913         int index  = Arrays.binarySearch(savingsInstantTransitions, epochSec);
 914         if (index &lt; 0) {
 915             index = -index - 1;
 916         }
 917         if (index &lt;= 0) {
 918             return null;
 919         }
 920         return new ZoneOffsetTransition(savingsInstantTransitions[index - 1], wallOffsets[index - 1], wallOffsets[index]);
 921     }
 922 
 923     private int findYear(long epochSecond, ZoneOffset offset) {
<span class="line-removed"> 924         // inline for performance</span>
 925         long localSecond = epochSecond + offset.getTotalSeconds();
<span class="line-modified"> 926         long localEpochDay = Math.floorDiv(localSecond, 86400);</span>
<span class="line-modified"> 927         return LocalDate.ofEpochDay(localEpochDay).getYear();</span>

























 928     }
 929 
 930     /**
 931      * Gets the complete list of fully defined transitions.
 932      * &lt;p&gt;
 933      * The complete set of transitions for this rules instance is defined by this method
 934      * and {@link #getTransitionRules()}. This method returns those transitions that have
 935      * been fully defined. These are typically historical, but may be in the future.
 936      * &lt;p&gt;
 937      * The list will be empty for fixed offset rules and for any time-zone where there has
 938      * only ever been a single offset. The list will also be empty if the transition rules are unknown.
 939      *
 940      * @return an immutable list of fully defined transitions, not null
 941      */
 942     public List&lt;ZoneOffsetTransition&gt; getTransitions() {
 943         List&lt;ZoneOffsetTransition&gt; list = new ArrayList&lt;&gt;();
 944         for (int i = 0; i &lt; savingsInstantTransitions.length; i++) {
 945             list.add(new ZoneOffsetTransition(savingsInstantTransitions[i], wallOffsets[i], wallOffsets[i + 1]));
 946         }
 947         return Collections.unmodifiableList(list);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time.zone;
  63 
  64 import java.io.DataInput;
  65 import java.io.DataOutput;
  66 import java.io.IOException;
  67 import java.io.InvalidObjectException;
  68 import java.io.ObjectInputStream;
  69 import java.io.Serializable;
  70 import java.time.Duration;
  71 import java.time.Instant;

  72 import java.time.LocalDateTime;
  73 import java.time.ZoneId;
  74 import java.time.ZoneOffset;
  75 import java.time.Year;
  76 import java.util.ArrayList;
  77 import java.util.Arrays;
  78 import java.util.Collections;
  79 import java.util.List;
  80 import java.util.Objects;
  81 import java.util.concurrent.ConcurrentHashMap;
  82 import java.util.concurrent.ConcurrentMap;
  83 
  84 /**
  85  * The rules defining how the zone offset varies for a single time-zone.
  86  * &lt;p&gt;
  87  * The rules model all the historic and future transitions for a time-zone.
  88  * {@link ZoneOffsetTransition} is used for known transitions, typically historic.
  89  * {@link ZoneOffsetTransitionRule} is used for future transitions that are based
  90  * on the result of an algorithm.
  91  * &lt;p&gt;
</pre>
<hr />
<pre>
 144      */
 145     private final ZoneOffsetTransitionRule[] lastRules;
 146     /**
 147      * The map of recent transitions.
 148      */
 149     private final transient ConcurrentMap&lt;Integer, ZoneOffsetTransition[]&gt; lastRulesCache =
 150                 new ConcurrentHashMap&lt;Integer, ZoneOffsetTransition[]&gt;();
 151     /**
 152      * The zero-length long array.
 153      */
 154     private static final long[] EMPTY_LONG_ARRAY = new long[0];
 155     /**
 156      * The zero-length lastrules array.
 157      */
 158     private static final ZoneOffsetTransitionRule[] EMPTY_LASTRULES =
 159         new ZoneOffsetTransitionRule[0];
 160     /**
 161      * The zero-length ldt array.
 162      */
 163     private static final LocalDateTime[] EMPTY_LDT_ARRAY = new LocalDateTime[0];
<span class="line-added"> 164     /**</span>
<span class="line-added"> 165      * The number of days in a 400 year cycle.</span>
<span class="line-added"> 166      */</span>
<span class="line-added"> 167     private static final int DAYS_PER_CYCLE = 146097;</span>
<span class="line-added"> 168     /**</span>
<span class="line-added"> 169      * The number of days from year zero to year 1970.</span>
<span class="line-added"> 170      * There are five 400 year cycles from year zero to 2000.</span>
<span class="line-added"> 171      * There are 7 leap years from 1970 to 2000.</span>
<span class="line-added"> 172      */</span>
<span class="line-added"> 173     private static final long DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);</span>
 174 
 175     /**
 176      * Obtains an instance of a ZoneRules.
 177      *
 178      * @param baseStandardOffset  the standard offset to use before legal rules were set, not null
 179      * @param baseWallOffset  the wall offset to use before legal rules were set, not null
 180      * @param standardOffsetTransitionList  the list of changes to the standard offset, not null
 181      * @param transitionList  the list of transitions, not null
 182      * @param lastRules  the recurring last rules, size 16 or less, not null
 183      * @return the zone rules, not null
 184      */
 185     public static ZoneRules of(ZoneOffset baseStandardOffset,
 186                                ZoneOffset baseWallOffset,
 187                                List&lt;ZoneOffsetTransition&gt; standardOffsetTransitionList,
 188                                List&lt;ZoneOffsetTransition&gt; transitionList,
 189                                List&lt;ZoneOffsetTransitionRule&gt; lastRules) {
 190         Objects.requireNonNull(baseStandardOffset, &quot;baseStandardOffset&quot;);
 191         Objects.requireNonNull(baseWallOffset, &quot;baseWallOffset&quot;);
 192         Objects.requireNonNull(standardOffsetTransitionList, &quot;standardOffsetTransitionList&quot;);
 193         Objects.requireNonNull(transitionList, &quot;transitionList&quot;);
</pre>
<hr />
<pre>
 913             int lastHistoricYear = findYear(lastHistoric, lastHistoricOffset);
 914             if (--year &gt; lastHistoricYear) {
 915                 transArray = findTransitionArray(year);
 916                 return transArray[transArray.length - 1];
 917             }
 918             // drop through
 919         }
 920 
 921         // using historic rules
 922         int index  = Arrays.binarySearch(savingsInstantTransitions, epochSec);
 923         if (index &lt; 0) {
 924             index = -index - 1;
 925         }
 926         if (index &lt;= 0) {
 927             return null;
 928         }
 929         return new ZoneOffsetTransition(savingsInstantTransitions[index - 1], wallOffsets[index - 1], wallOffsets[index]);
 930     }
 931 
 932     private int findYear(long epochSecond, ZoneOffset offset) {

 933         long localSecond = epochSecond + offset.getTotalSeconds();
<span class="line-modified"> 934         long zeroDay = Math.floorDiv(localSecond, 86400) + DAYS_0000_TO_1970;</span>
<span class="line-modified"> 935 </span>
<span class="line-added"> 936         // find the march-based year</span>
<span class="line-added"> 937         zeroDay -= 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle</span>
<span class="line-added"> 938         long adjust = 0;</span>
<span class="line-added"> 939         if (zeroDay &lt; 0) {</span>
<span class="line-added"> 940             // adjust negative years to positive for calculation</span>
<span class="line-added"> 941             long adjustCycles = (zeroDay + 1) / DAYS_PER_CYCLE - 1;</span>
<span class="line-added"> 942             adjust = adjustCycles * 400;</span>
<span class="line-added"> 943             zeroDay += -adjustCycles * DAYS_PER_CYCLE;</span>
<span class="line-added"> 944         }</span>
<span class="line-added"> 945         long yearEst = (400 * zeroDay + 591) / DAYS_PER_CYCLE;</span>
<span class="line-added"> 946         long doyEst = zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);</span>
<span class="line-added"> 947         if (doyEst &lt; 0) {</span>
<span class="line-added"> 948             // fix estimate</span>
<span class="line-added"> 949             yearEst--;</span>
<span class="line-added"> 950             doyEst = zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);</span>
<span class="line-added"> 951         }</span>
<span class="line-added"> 952         yearEst += adjust;  // reset any negative year</span>
<span class="line-added"> 953         int marchDoy0 = (int) doyEst;</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955         // convert march-based values back to january-based</span>
<span class="line-added"> 956         int marchMonth0 = (marchDoy0 * 5 + 2) / 153;</span>
<span class="line-added"> 957         yearEst += marchMonth0 / 10;</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959         // Cap to the max value</span>
<span class="line-added"> 960         return (int)Math.min(yearEst, Year.MAX_VALUE);</span>
 961     }
 962 
 963     /**
 964      * Gets the complete list of fully defined transitions.
 965      * &lt;p&gt;
 966      * The complete set of transitions for this rules instance is defined by this method
 967      * and {@link #getTransitionRules()}. This method returns those transitions that have
 968      * been fully defined. These are typically historical, but may be in the future.
 969      * &lt;p&gt;
 970      * The list will be empty for fixed offset rules and for any time-zone where there has
 971      * only ever been a single offset. The list will also be empty if the transition rules are unknown.
 972      *
 973      * @return an immutable list of fully defined transitions, not null
 974      */
 975     public List&lt;ZoneOffsetTransition&gt; getTransitions() {
 976         List&lt;ZoneOffsetTransition&gt; list = new ArrayList&lt;&gt;();
 977         for (int i = 0; i &lt; savingsInstantTransitions.length; i++) {
 978             list.add(new ZoneOffsetTransition(savingsInstantTransitions[i], wallOffsets[i], wallOffsets[i + 1]));
 979         }
 980         return Collections.unmodifiableList(list);
</pre>
</td>
</tr>
</table>
<center><a href="ZoneOffsetTransitionRule.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/AbstractCollection.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/Invokers.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LambdaConversionException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/Invokers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 /**
 42  * Construction and caching of often-used invokers.
 43  * @author jrose
 44  */
 45 class Invokers {
 46     // exact type (sans leading target MH) for the outgoing call
 47     private final MethodType targetType;
 48 
 49     // Cached adapter information:
 50     private final @Stable MethodHandle[] invokers = new MethodHandle[INV_LIMIT];
 51     // Indexes into invokers:
 52     static final int
 53             INV_EXACT          =  0,  // MethodHandles.exactInvoker
 54             INV_GENERIC        =  1,  // MethodHandles.invoker (generic invocation)
 55             INV_BASIC          =  2,  // MethodHandles.basicInvoker
 56             INV_LIMIT          =  3;
 57 
 58     /** Compute and cache information common to all collecting adapters
 59      *  that implement members of the erasure-family of the given erased type.
 60      */
<span class="line-modified"> 61     /*non-public*/ Invokers(MethodType targetType) {</span>

 62         this.targetType = targetType;
 63     }
 64 
<span class="line-modified"> 65     /*non-public*/ MethodHandle exactInvoker() {</span>

 66         MethodHandle invoker = cachedInvoker(INV_EXACT);
 67         if (invoker != null)  return invoker;
 68         invoker = makeExactOrGeneralInvoker(true);
 69         return setCachedInvoker(INV_EXACT, invoker);
 70     }
 71 
<span class="line-modified"> 72     /*non-public*/ MethodHandle genericInvoker() {</span>

 73         MethodHandle invoker = cachedInvoker(INV_GENERIC);
 74         if (invoker != null)  return invoker;
 75         invoker = makeExactOrGeneralInvoker(false);
 76         return setCachedInvoker(INV_GENERIC, invoker);
 77     }
 78 
<span class="line-modified"> 79     /*non-public*/ MethodHandle basicInvoker() {</span>

 80         MethodHandle invoker = cachedInvoker(INV_BASIC);
 81         if (invoker != null)  return invoker;
 82         MethodType basicType = targetType.basicType();
 83         if (basicType != targetType) {
 84             // double cache; not used significantly
 85             return setCachedInvoker(INV_BASIC, basicType.invokers().basicInvoker());
 86         }
 87         invoker = basicType.form().cachedMethodHandle(MethodTypeForm.MH_BASIC_INV);
 88         if (invoker == null) {
 89             MemberName method = invokeBasicMethod(basicType);
 90             invoker = DirectMethodHandle.make(method);
 91             assert(checkInvoker(invoker));
 92             invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_BASIC_INV, invoker);
 93         }
 94         return setCachedInvoker(INV_BASIC, invoker);
 95     }
 96 
<span class="line-modified"> 97     /*non-public*/ MethodHandle varHandleMethodInvoker(VarHandle.AccessMode ak) {</span>

 98         // TODO cache invoker
 99         return makeVarHandleMethodInvoker(ak, false);
100     }
101 
<span class="line-modified">102     /*non-public*/ MethodHandle varHandleMethodExactInvoker(VarHandle.AccessMode ak) {</span>

103         // TODO cache invoker
104         return makeVarHandleMethodInvoker(ak, true);
105     }
106 
107     private MethodHandle cachedInvoker(int idx) {
108         return invokers[idx];
109     }
110 
111     private synchronized MethodHandle setCachedInvoker(int idx, final MethodHandle invoker) {
112         // Simulate a CAS, to avoid racy duplication of results.
113         MethodHandle prev = invokers[idx];
114         if (prev != null)  return prev;
115         return invokers[idx] = invoker;
116     }
117 
118     private MethodHandle makeExactOrGeneralInvoker(boolean isExact) {
119         MethodType mtype = targetType;
120         MethodType invokerType = mtype.invokerType();
121         int which = (isExact ? MethodTypeForm.LF_EX_INVOKER : MethodTypeForm.LF_GEN_INVOKER);
122         LambdaForm lform = invokeHandleForm(mtype, false, which);
</pre>
<hr />
<pre>
136         VarHandle.AccessDescriptor ad = new VarHandle.AccessDescriptor(mtype, ak.at.ordinal(), ak.ordinal());
137         MethodHandle invoker = BoundMethodHandle.bindSingle(invokerType, lform, ad);
138 
139         invoker = invoker.withInternalMemberName(MemberName.makeVarHandleMethodInvoke(ak.methodName(), mtype), false);
140         assert(checkVarHandleInvoker(invoker));
141 
142         maybeCompileToBytecode(invoker);
143         return invoker;
144     }
145 
146     /** If the target type seems to be common enough, eagerly compile the invoker to bytecodes. */
147     private void maybeCompileToBytecode(MethodHandle invoker) {
148         final int EAGER_COMPILE_ARITY_LIMIT = 10;
149         if (targetType == targetType.erase() &amp;&amp;
150             targetType.parameterCount() &lt; EAGER_COMPILE_ARITY_LIMIT) {
151             invoker.form.compileToBytecode();
152         }
153     }
154 
155     // This next one is called from LambdaForm.NamedFunction.&lt;init&gt;.
<span class="line-modified">156     /*non-public*/ static MemberName invokeBasicMethod(MethodType basicType) {</span>

157         assert(basicType == basicType.basicType());
158         try {
159             //Lookup.findVirtual(MethodHandle.class, name, type);
160             return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, &quot;invokeBasic&quot;, basicType);
161         } catch (ReflectiveOperationException ex) {
162             throw newInternalError(&quot;JVM cannot find invoker for &quot;+basicType, ex);
163         }
164     }
165 
166     private boolean checkInvoker(MethodHandle invoker) {
167         assert(targetType.invokerType().equals(invoker.type()))
168                 : java.util.Arrays.asList(targetType, targetType.invokerType(), invoker);
169         assert(invoker.internalMemberName() == null ||
170                invoker.internalMemberName().getMethodType().equals(targetType));
171         assert(!invoker.isVarargsCollector());
172         return true;
173     }
174 
175     private boolean checkVarHandleInvoker(MethodHandle invoker) {
176         MethodType invokerType = targetType.insertParameterTypes(0, VarHandle.class);
177         assert(invokerType.equals(invoker.type()))
178                 : java.util.Arrays.asList(targetType, invokerType, invoker);
179         assert(invoker.internalMemberName() == null ||
180                invoker.internalMemberName().getMethodType().equals(targetType));
181         assert(!invoker.isVarargsCollector());
182         return true;
183     }
184 
185     /**
186      * Find or create an invoker which passes unchanged a given number of arguments
187      * and spreads the rest from a trailing array argument.
188      * The invoker target type is the post-spread type {@code (TYPEOF(uarg*), TYPEOF(sarg*))=&gt;RT}.
189      * All the {@code sarg}s must have a common type {@code C}.  (If there are none, {@code Object} is assumed.}
190      * @param leadingArgCount the number of unchanged (non-spread) arguments
191      * @return {@code invoker.invokeExact(mh, uarg*, C[]{sarg*}) := (RT)mh.invoke(uarg*, sarg*)}
192      */
<span class="line-modified">193     /*non-public*/ MethodHandle spreadInvoker(int leadingArgCount) {</span>

194         int spreadArgCount = targetType.parameterCount() - leadingArgCount;
195         MethodType postSpreadType = targetType;
196         Class&lt;?&gt; argArrayType = impliedRestargType(postSpreadType, leadingArgCount);
197         if (postSpreadType.parameterSlotCount() &lt;= MethodType.MAX_MH_INVOKER_ARITY) {
198             return genericInvoker().asSpreader(argArrayType, spreadArgCount);
199         }
200         // Cannot build a generic invoker here of type ginvoker.invoke(mh, a*[254]).
201         // Instead, factor sinvoker.invoke(mh, a) into ainvoker.invoke(filter(mh), a)
202         // where filter(mh) == mh.asSpreader(Object[], spreadArgCount)
203         MethodType preSpreadType = postSpreadType
204             .replaceParameterTypes(leadingArgCount, postSpreadType.parameterCount(), argArrayType);
205         MethodHandle arrayInvoker = MethodHandles.invoker(preSpreadType);
206         MethodHandle makeSpreader = MethodHandles.insertArguments(Lazy.MH_asSpreader, 1, argArrayType, spreadArgCount);
207         return MethodHandles.filterArgument(arrayInvoker, 0, makeSpreader);
208     }
209 
210     private static Class&lt;?&gt; impliedRestargType(MethodType restargType, int fromPos) {
211         if (restargType.isGeneric())  return Object[].class;  // can be nothing else
212         int maxPos = restargType.parameterCount();
213         if (fromPos &gt;= maxPos)  return Object[].class;  // reasonable default
</pre>
<hr />
<pre>
428         outArgs[0] = names[CHECK_TYPE];
429         for (int i = 1; i &lt; ARG_LIMIT; i++) {
430             outArgs[i] = names[i];
431         }
432 
433         MethodType outCallType = mtype.insertParameterTypes(0, VarHandle.class)
434                 .basicType();
435         names[LINKER_CALL] = new Name(outCallType, outArgs);
436         Kind kind = isExact ? VARHANDLE_EXACT_INVOKER : VARHANDLE_INVOKER;
437         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, kind);
438         if (LambdaForm.debugNames()) {
439             String name = ak.methodName() +
440                     (isExact ? &quot;:VarHandle_exactInvoker_&quot; : &quot;:VarHandle_invoker_&quot;) +
441                     shortenSignature(basicTypeSignature(mtype));
442             LambdaForm.associateWithDebugName(lform, name);
443         }
444         lform.prepare();
445         return lform;
446     }
447 
<span class="line-removed">448     /*non-public*/ static</span>
449     @ForceInline
<span class="line-modified">450     MethodHandle checkVarHandleGenericType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>

451         // Test for exact match on invoker types
452         // TODO match with erased types and add cast of return value to lambda form
453         MethodHandle mh = handle.getMethodHandle(ad.mode);
454         if (mh.type() == ad.symbolicMethodTypeInvoker) {
455             return mh;
456         }
457         else {
458             return mh.asType(ad.symbolicMethodTypeInvoker);
459         }
460     }
461 
<span class="line-removed">462     /*non-public*/ static</span>
463     @ForceInline
<span class="line-modified">464     MethodHandle checkVarHandleExactType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>

465         MethodHandle mh = handle.getMethodHandle(ad.mode);
466         MethodType mt = mh.type();
467         if (mt != ad.symbolicMethodTypeInvoker) {
468             throw newWrongMethodTypeException(mt, ad.symbolicMethodTypeInvoker);
469         }
470         return mh;
471     }
472 
<span class="line-modified">473     /*non-public*/ static</span>
<span class="line-modified">474     WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {</span>
475         // FIXME: merge with JVM logic for throwing WMTE
476         return new WrongMethodTypeException(&quot;expected &quot;+expected+&quot; but found &quot;+actual);
477     }
478 
479     /** Static definition of MethodHandle.invokeExact checking code. */
<span class="line-removed">480     /*non-public*/ static</span>
481     @ForceInline
<span class="line-modified">482     void checkExactType(MethodHandle mh, MethodType expected) {</span>

483         MethodType actual = mh.type();
484         if (actual != expected)
485             throw newWrongMethodTypeException(expected, actual);
486     }
487 
488     /** Static definition of MethodHandle.invokeGeneric checking code.
489      * Directly returns the type-adjusted MH to invoke, as follows:
490      * {@code (R)MH.invoke(a*) =&gt; MH.asType(TYPEOF(a*:R)).invokeBasic(a*)}
491      */
<span class="line-removed">492     /*non-public*/ static</span>
493     @ForceInline
<span class="line-modified">494     MethodHandle checkGenericType(MethodHandle mh,  MethodType expected) {</span>

495         return mh.asType(expected);
496         /* Maybe add more paths here.  Possible optimizations:
497          * for (R)MH.invoke(a*),
498          * let MT0 = TYPEOF(a*:R), MT1 = MH.type
499          *
500          * if MT0==MT1 or MT1 can be safely called by MT0
501          *  =&gt; MH.invokeBasic(a*)
502          * if MT1 can be safely called by MT0[R := Object]
503          *  =&gt; MH.invokeBasic(a*) &amp; checkcast(R)
504          * if MT1 can be safely called by MT0[* := Object]
505          *  =&gt; checkcast(A)* &amp; MH.invokeBasic(a*) &amp; checkcast(R)
506          * if a big adapter BA can be pulled out of (MT0,MT1)
507          *  =&gt; BA.invokeBasic(MT0,MH,a*)
508          * if a local adapter LA can be cached on static CS0 = new GICS(MT0)
509          *  =&gt; CS0.LA.invokeBasic(MH,a*)
510          * else
511          *  =&gt; MH.asType(MT0).invokeBasic(A*)
512          */
513     }
514 
</pre>
<hr />
<pre>
542         Name[] names = arguments(nameCursor - INARG_LIMIT, invokerFormType);
543         assert(names.length == nameCursor);
544         assert(names[APPENDIX_ARG] != null);
545         if (!skipCallSite)
546             names[CALL_MH] = new Name(getFunction(NF_getCallSiteTarget), names[CSITE_ARG]);
547         // (site.)invokedynamic(a*):R =&gt; mh = site.getTarget(); mh.invokeBasic(a*)
548         final int PREPEND_MH = 0, PREPEND_COUNT = 1;
549         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, OUTARG_LIMIT + PREPEND_COUNT, Object[].class);
550         // prepend MH argument:
551         System.arraycopy(outArgs, 0, outArgs, PREPEND_COUNT, outArgs.length - PREPEND_COUNT);
552         outArgs[PREPEND_MH] = names[CALL_MH];
553         names[LINKER_CALL] = new Name(mtype, outArgs);
554         lform = new LambdaForm(INARG_LIMIT, names,
555                 (skipCallSite ? LINK_TO_TARGET_METHOD : LINK_TO_CALL_SITE));
556         lform.compileToBytecode();  // JVM needs a real methodOop
557         lform = mtype.form().setCachedLambdaForm(which, lform);
558         return lform;
559     }
560 
561     /** Static definition of MethodHandle.invokeGeneric checking code. */
<span class="line-removed">562     /*non-public*/ static</span>
563     @ForceInline
<span class="line-modified">564     MethodHandle getCallSiteTarget(CallSite site) {</span>

565         return site.getTarget();
566     }
567 
<span class="line-removed">568     /*non-public*/ static</span>
569     @ForceInline
<span class="line-modified">570     void checkCustomized(MethodHandle mh) {</span>

571         if (MethodHandleImpl.isCompileConstant(mh)) return;
572         if (mh.form.customized == null) {
573             maybeCustomize(mh);
574         }
575     }
576 
<span class="line-removed">577     /*non-public*/ static</span>
578     @DontInline
<span class="line-modified">579     void maybeCustomize(MethodHandle mh) {</span>

580         byte count = mh.customizationCount;
581         if (count &gt;= CUSTOMIZE_THRESHOLD) {
582             mh.customize();
583         } else {
584             mh.customizationCount = (byte)(count+1);
585         }
586     }
587 
588     // Local constant functions:
589     private static final byte NF_checkExactType = 0,
590         NF_checkGenericType = 1,
591         NF_getCallSiteTarget = 2,
592         NF_checkCustomized = 3,
593         NF_checkVarHandleGenericType = 4,
594         NF_checkVarHandleExactType = 5,
595         NF_LIMIT = 6;
596 
597     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
598 
599     private static NamedFunction getFunction(byte func) {
</pre>
</td>
<td>
<hr />
<pre>
 41 /**
 42  * Construction and caching of often-used invokers.
 43  * @author jrose
 44  */
 45 class Invokers {
 46     // exact type (sans leading target MH) for the outgoing call
 47     private final MethodType targetType;
 48 
 49     // Cached adapter information:
 50     private final @Stable MethodHandle[] invokers = new MethodHandle[INV_LIMIT];
 51     // Indexes into invokers:
 52     static final int
 53             INV_EXACT          =  0,  // MethodHandles.exactInvoker
 54             INV_GENERIC        =  1,  // MethodHandles.invoker (generic invocation)
 55             INV_BASIC          =  2,  // MethodHandles.basicInvoker
 56             INV_LIMIT          =  3;
 57 
 58     /** Compute and cache information common to all collecting adapters
 59      *  that implement members of the erasure-family of the given erased type.
 60      */
<span class="line-modified"> 61     /*non-public*/</span>
<span class="line-added"> 62     Invokers(MethodType targetType) {</span>
 63         this.targetType = targetType;
 64     }
 65 
<span class="line-modified"> 66     /*non-public*/</span>
<span class="line-added"> 67     MethodHandle exactInvoker() {</span>
 68         MethodHandle invoker = cachedInvoker(INV_EXACT);
 69         if (invoker != null)  return invoker;
 70         invoker = makeExactOrGeneralInvoker(true);
 71         return setCachedInvoker(INV_EXACT, invoker);
 72     }
 73 
<span class="line-modified"> 74     /*non-public*/</span>
<span class="line-added"> 75     MethodHandle genericInvoker() {</span>
 76         MethodHandle invoker = cachedInvoker(INV_GENERIC);
 77         if (invoker != null)  return invoker;
 78         invoker = makeExactOrGeneralInvoker(false);
 79         return setCachedInvoker(INV_GENERIC, invoker);
 80     }
 81 
<span class="line-modified"> 82     /*non-public*/</span>
<span class="line-added"> 83     MethodHandle basicInvoker() {</span>
 84         MethodHandle invoker = cachedInvoker(INV_BASIC);
 85         if (invoker != null)  return invoker;
 86         MethodType basicType = targetType.basicType();
 87         if (basicType != targetType) {
 88             // double cache; not used significantly
 89             return setCachedInvoker(INV_BASIC, basicType.invokers().basicInvoker());
 90         }
 91         invoker = basicType.form().cachedMethodHandle(MethodTypeForm.MH_BASIC_INV);
 92         if (invoker == null) {
 93             MemberName method = invokeBasicMethod(basicType);
 94             invoker = DirectMethodHandle.make(method);
 95             assert(checkInvoker(invoker));
 96             invoker = basicType.form().setCachedMethodHandle(MethodTypeForm.MH_BASIC_INV, invoker);
 97         }
 98         return setCachedInvoker(INV_BASIC, invoker);
 99     }
100 
<span class="line-modified">101     /*non-public*/</span>
<span class="line-added">102     MethodHandle varHandleMethodInvoker(VarHandle.AccessMode ak) {</span>
103         // TODO cache invoker
104         return makeVarHandleMethodInvoker(ak, false);
105     }
106 
<span class="line-modified">107     /*non-public*/</span>
<span class="line-added">108     MethodHandle varHandleMethodExactInvoker(VarHandle.AccessMode ak) {</span>
109         // TODO cache invoker
110         return makeVarHandleMethodInvoker(ak, true);
111     }
112 
113     private MethodHandle cachedInvoker(int idx) {
114         return invokers[idx];
115     }
116 
117     private synchronized MethodHandle setCachedInvoker(int idx, final MethodHandle invoker) {
118         // Simulate a CAS, to avoid racy duplication of results.
119         MethodHandle prev = invokers[idx];
120         if (prev != null)  return prev;
121         return invokers[idx] = invoker;
122     }
123 
124     private MethodHandle makeExactOrGeneralInvoker(boolean isExact) {
125         MethodType mtype = targetType;
126         MethodType invokerType = mtype.invokerType();
127         int which = (isExact ? MethodTypeForm.LF_EX_INVOKER : MethodTypeForm.LF_GEN_INVOKER);
128         LambdaForm lform = invokeHandleForm(mtype, false, which);
</pre>
<hr />
<pre>
142         VarHandle.AccessDescriptor ad = new VarHandle.AccessDescriptor(mtype, ak.at.ordinal(), ak.ordinal());
143         MethodHandle invoker = BoundMethodHandle.bindSingle(invokerType, lform, ad);
144 
145         invoker = invoker.withInternalMemberName(MemberName.makeVarHandleMethodInvoke(ak.methodName(), mtype), false);
146         assert(checkVarHandleInvoker(invoker));
147 
148         maybeCompileToBytecode(invoker);
149         return invoker;
150     }
151 
152     /** If the target type seems to be common enough, eagerly compile the invoker to bytecodes. */
153     private void maybeCompileToBytecode(MethodHandle invoker) {
154         final int EAGER_COMPILE_ARITY_LIMIT = 10;
155         if (targetType == targetType.erase() &amp;&amp;
156             targetType.parameterCount() &lt; EAGER_COMPILE_ARITY_LIMIT) {
157             invoker.form.compileToBytecode();
158         }
159     }
160 
161     // This next one is called from LambdaForm.NamedFunction.&lt;init&gt;.
<span class="line-modified">162     /*non-public*/</span>
<span class="line-added">163     static MemberName invokeBasicMethod(MethodType basicType) {</span>
164         assert(basicType == basicType.basicType());
165         try {
166             //Lookup.findVirtual(MethodHandle.class, name, type);
167             return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, &quot;invokeBasic&quot;, basicType);
168         } catch (ReflectiveOperationException ex) {
169             throw newInternalError(&quot;JVM cannot find invoker for &quot;+basicType, ex);
170         }
171     }
172 
173     private boolean checkInvoker(MethodHandle invoker) {
174         assert(targetType.invokerType().equals(invoker.type()))
175                 : java.util.Arrays.asList(targetType, targetType.invokerType(), invoker);
176         assert(invoker.internalMemberName() == null ||
177                invoker.internalMemberName().getMethodType().equals(targetType));
178         assert(!invoker.isVarargsCollector());
179         return true;
180     }
181 
182     private boolean checkVarHandleInvoker(MethodHandle invoker) {
183         MethodType invokerType = targetType.insertParameterTypes(0, VarHandle.class);
184         assert(invokerType.equals(invoker.type()))
185                 : java.util.Arrays.asList(targetType, invokerType, invoker);
186         assert(invoker.internalMemberName() == null ||
187                invoker.internalMemberName().getMethodType().equals(targetType));
188         assert(!invoker.isVarargsCollector());
189         return true;
190     }
191 
192     /**
193      * Find or create an invoker which passes unchanged a given number of arguments
194      * and spreads the rest from a trailing array argument.
195      * The invoker target type is the post-spread type {@code (TYPEOF(uarg*), TYPEOF(sarg*))=&gt;RT}.
196      * All the {@code sarg}s must have a common type {@code C}.  (If there are none, {@code Object} is assumed.}
197      * @param leadingArgCount the number of unchanged (non-spread) arguments
198      * @return {@code invoker.invokeExact(mh, uarg*, C[]{sarg*}) := (RT)mh.invoke(uarg*, sarg*)}
199      */
<span class="line-modified">200     /*non-public*/</span>
<span class="line-added">201     MethodHandle spreadInvoker(int leadingArgCount) {</span>
202         int spreadArgCount = targetType.parameterCount() - leadingArgCount;
203         MethodType postSpreadType = targetType;
204         Class&lt;?&gt; argArrayType = impliedRestargType(postSpreadType, leadingArgCount);
205         if (postSpreadType.parameterSlotCount() &lt;= MethodType.MAX_MH_INVOKER_ARITY) {
206             return genericInvoker().asSpreader(argArrayType, spreadArgCount);
207         }
208         // Cannot build a generic invoker here of type ginvoker.invoke(mh, a*[254]).
209         // Instead, factor sinvoker.invoke(mh, a) into ainvoker.invoke(filter(mh), a)
210         // where filter(mh) == mh.asSpreader(Object[], spreadArgCount)
211         MethodType preSpreadType = postSpreadType
212             .replaceParameterTypes(leadingArgCount, postSpreadType.parameterCount(), argArrayType);
213         MethodHandle arrayInvoker = MethodHandles.invoker(preSpreadType);
214         MethodHandle makeSpreader = MethodHandles.insertArguments(Lazy.MH_asSpreader, 1, argArrayType, spreadArgCount);
215         return MethodHandles.filterArgument(arrayInvoker, 0, makeSpreader);
216     }
217 
218     private static Class&lt;?&gt; impliedRestargType(MethodType restargType, int fromPos) {
219         if (restargType.isGeneric())  return Object[].class;  // can be nothing else
220         int maxPos = restargType.parameterCount();
221         if (fromPos &gt;= maxPos)  return Object[].class;  // reasonable default
</pre>
<hr />
<pre>
436         outArgs[0] = names[CHECK_TYPE];
437         for (int i = 1; i &lt; ARG_LIMIT; i++) {
438             outArgs[i] = names[i];
439         }
440 
441         MethodType outCallType = mtype.insertParameterTypes(0, VarHandle.class)
442                 .basicType();
443         names[LINKER_CALL] = new Name(outCallType, outArgs);
444         Kind kind = isExact ? VARHANDLE_EXACT_INVOKER : VARHANDLE_INVOKER;
445         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, kind);
446         if (LambdaForm.debugNames()) {
447             String name = ak.methodName() +
448                     (isExact ? &quot;:VarHandle_exactInvoker_&quot; : &quot;:VarHandle_invoker_&quot;) +
449                     shortenSignature(basicTypeSignature(mtype));
450             LambdaForm.associateWithDebugName(lform, name);
451         }
452         lform.prepare();
453         return lform;
454     }
455 

456     @ForceInline
<span class="line-modified">457     /*non-public*/</span>
<span class="line-added">458     static MethodHandle checkVarHandleGenericType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>
459         // Test for exact match on invoker types
460         // TODO match with erased types and add cast of return value to lambda form
461         MethodHandle mh = handle.getMethodHandle(ad.mode);
462         if (mh.type() == ad.symbolicMethodTypeInvoker) {
463             return mh;
464         }
465         else {
466             return mh.asType(ad.symbolicMethodTypeInvoker);
467         }
468     }
469 

470     @ForceInline
<span class="line-modified">471     /*non-public*/</span>
<span class="line-added">472     static MethodHandle checkVarHandleExactType(VarHandle handle, VarHandle.AccessDescriptor ad) {</span>
473         MethodHandle mh = handle.getMethodHandle(ad.mode);
474         MethodType mt = mh.type();
475         if (mt != ad.symbolicMethodTypeInvoker) {
476             throw newWrongMethodTypeException(mt, ad.symbolicMethodTypeInvoker);
477         }
478         return mh;
479     }
480 
<span class="line-modified">481     /*non-public*/</span>
<span class="line-modified">482     static WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {</span>
483         // FIXME: merge with JVM logic for throwing WMTE
484         return new WrongMethodTypeException(&quot;expected &quot;+expected+&quot; but found &quot;+actual);
485     }
486 
487     /** Static definition of MethodHandle.invokeExact checking code. */

488     @ForceInline
<span class="line-modified">489     /*non-public*/</span>
<span class="line-added">490     static void checkExactType(MethodHandle mh, MethodType expected) {</span>
491         MethodType actual = mh.type();
492         if (actual != expected)
493             throw newWrongMethodTypeException(expected, actual);
494     }
495 
496     /** Static definition of MethodHandle.invokeGeneric checking code.
497      * Directly returns the type-adjusted MH to invoke, as follows:
498      * {@code (R)MH.invoke(a*) =&gt; MH.asType(TYPEOF(a*:R)).invokeBasic(a*)}
499      */

500     @ForceInline
<span class="line-modified">501     /*non-public*/</span>
<span class="line-added">502     static MethodHandle checkGenericType(MethodHandle mh,  MethodType expected) {</span>
503         return mh.asType(expected);
504         /* Maybe add more paths here.  Possible optimizations:
505          * for (R)MH.invoke(a*),
506          * let MT0 = TYPEOF(a*:R), MT1 = MH.type
507          *
508          * if MT0==MT1 or MT1 can be safely called by MT0
509          *  =&gt; MH.invokeBasic(a*)
510          * if MT1 can be safely called by MT0[R := Object]
511          *  =&gt; MH.invokeBasic(a*) &amp; checkcast(R)
512          * if MT1 can be safely called by MT0[* := Object]
513          *  =&gt; checkcast(A)* &amp; MH.invokeBasic(a*) &amp; checkcast(R)
514          * if a big adapter BA can be pulled out of (MT0,MT1)
515          *  =&gt; BA.invokeBasic(MT0,MH,a*)
516          * if a local adapter LA can be cached on static CS0 = new GICS(MT0)
517          *  =&gt; CS0.LA.invokeBasic(MH,a*)
518          * else
519          *  =&gt; MH.asType(MT0).invokeBasic(A*)
520          */
521     }
522 
</pre>
<hr />
<pre>
550         Name[] names = arguments(nameCursor - INARG_LIMIT, invokerFormType);
551         assert(names.length == nameCursor);
552         assert(names[APPENDIX_ARG] != null);
553         if (!skipCallSite)
554             names[CALL_MH] = new Name(getFunction(NF_getCallSiteTarget), names[CSITE_ARG]);
555         // (site.)invokedynamic(a*):R =&gt; mh = site.getTarget(); mh.invokeBasic(a*)
556         final int PREPEND_MH = 0, PREPEND_COUNT = 1;
557         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, OUTARG_LIMIT + PREPEND_COUNT, Object[].class);
558         // prepend MH argument:
559         System.arraycopy(outArgs, 0, outArgs, PREPEND_COUNT, outArgs.length - PREPEND_COUNT);
560         outArgs[PREPEND_MH] = names[CALL_MH];
561         names[LINKER_CALL] = new Name(mtype, outArgs);
562         lform = new LambdaForm(INARG_LIMIT, names,
563                 (skipCallSite ? LINK_TO_TARGET_METHOD : LINK_TO_CALL_SITE));
564         lform.compileToBytecode();  // JVM needs a real methodOop
565         lform = mtype.form().setCachedLambdaForm(which, lform);
566         return lform;
567     }
568 
569     /** Static definition of MethodHandle.invokeGeneric checking code. */

570     @ForceInline
<span class="line-modified">571     /*non-public*/</span>
<span class="line-added">572     static MethodHandle getCallSiteTarget(CallSite site) {</span>
573         return site.getTarget();
574     }
575 

576     @ForceInline
<span class="line-modified">577     /*non-public*/</span>
<span class="line-added">578     static void checkCustomized(MethodHandle mh) {</span>
579         if (MethodHandleImpl.isCompileConstant(mh)) return;
580         if (mh.form.customized == null) {
581             maybeCustomize(mh);
582         }
583     }
584 

585     @DontInline
<span class="line-modified">586     /*non-public*/</span>
<span class="line-added">587     static void maybeCustomize(MethodHandle mh) {</span>
588         byte count = mh.customizationCount;
589         if (count &gt;= CUSTOMIZE_THRESHOLD) {
590             mh.customize();
591         } else {
592             mh.customizationCount = (byte)(count+1);
593         }
594     }
595 
596     // Local constant functions:
597     private static final byte NF_checkExactType = 0,
598         NF_checkGenericType = 1,
599         NF_getCallSiteTarget = 2,
600         NF_checkCustomized = 3,
601         NF_checkVarHandleGenericType = 4,
602         NF_checkVarHandleExactType = 5,
603         NF_LIMIT = 6;
604 
605     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
606 
607     private static NamedFunction getFunction(byte func) {
</pre>
</td>
</tr>
</table>
<center><a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LambdaConversionException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
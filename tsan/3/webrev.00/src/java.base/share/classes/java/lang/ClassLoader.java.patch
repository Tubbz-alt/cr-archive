diff a/src/java.base/share/classes/java/lang/ClassLoader.java b/src/java.base/share/classes/java/lang/ClassLoader.java
--- a/src/java.base/share/classes/java/lang/ClassLoader.java
+++ b/src/java.base/share/classes/java/lang/ClassLoader.java
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -37,24 +38,23 @@
 import java.security.CodeSource;
 import java.security.PrivilegedAction;
 import java.security.ProtectionDomain;
 import java.security.cert.Certificate;
 import java.util.ArrayDeque;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Hashtable;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import java.util.Vector;
 import java.util.WeakHashMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
@@ -66,10 +66,11 @@
 import jdk.internal.misc.Unsafe;
 import jdk.internal.misc.VM;
 import jdk.internal.ref.CleanerFactory;
 import jdk.internal.reflect.CallerSensitive;
 import jdk.internal.reflect.Reflection;
+import jdk.internal.util.StaticProperty;
 import sun.reflect.misc.ReflectUtil;
 import sun.security.util.SecurityConstants;
 
 /**
  * A class loader is an object that is responsible for loading classes. The
@@ -124,11 +125,11 @@
  * hierarchical, class loaders need to be parallel capable, otherwise class
  * loading can lead to deadlocks because the loader lock is held for the
  * duration of the class loading process (see {@link #loadClass
  * loadClass} methods).
  *
- * <h3> <a id="builtinLoaders">Run-time Built-in Class Loaders</a></h3>
+ * <h2> <a id="builtinLoaders">Run-time Built-in Class Loaders</a></h2>
  *
  * The Java run-time has the following built-in class loaders:
  *
  * <ul>
  * <li><p>Bootstrap class loader.
@@ -220,11 +221,11 @@
  * <p> Any package name provided as a {@code String} parameter to methods in
  * {@code ClassLoader} must be either the empty string (denoting an unnamed package)
  * or a fully qualified name as defined by
  * <cite>The Java&trade; Language Specification</cite>.
  *
- * @jls 6.7  Fully Qualified Names
+ * @jls 6.7 Fully Qualified Names
  * @jls 13.1 The Form of a Binary
  * @see      #resolveClass(Class)
  * @since 1.0
  * @revised 9
  * @spec JPMS
@@ -300,28 +301,30 @@
     // Note: VM also uses this field to decide if the current class loader
     // is parallel capable and the appropriate lock object for class loading.
     private final ConcurrentHashMap<String, Object> parallelLockMap;
 
     // Maps packages to certs
-    private final Map <String, Certificate[]> package2certs;
+    private final ConcurrentHashMap<String, Certificate[]> package2certs;
 
     // Shared among all packages with unsigned classes
     private static final Certificate[] nocerts = new Certificate[0];
 
     // The classes loaded by this class loader. The only purpose of this table
     // is to keep the classes from being GC'ed until the loader is GC'ed.
-    private final Vector<Class<?>> classes = new Vector<>();
+    private final ArrayList<Class<?>> classes = new ArrayList<>();
 
     // The "default" domain. Set as the default ProtectionDomain on newly
     // created classes.
     private final ProtectionDomain defaultDomain =
         new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
                              null, this, null);
 
     // Invoked by the VM to record every loaded class with this loader.
     void addClass(Class<?> c) {
-        classes.addElement(c);
+        synchronized (classes) {
+            classes.add(c);
+        }
     }
 
     // The packages defined in this class loader.  Each package name is
     // mapped to its corresponding NamedPackage object.
     //
@@ -375,18 +378,17 @@
         this.name = name;
         this.parent = parent;
         this.unnamedModule = new Module(this);
         if (ParallelLoaders.isRegistered(this.getClass())) {
             parallelLockMap = new ConcurrentHashMap<>();
-            package2certs = new ConcurrentHashMap<>();
             assertionLock = new Object();
         } else {
             // no finer-grained lock; lock on the classloader instance
             parallelLockMap = null;
-            package2certs = new Hashtable<>();
             assertionLock = this;
         }
+        this.package2certs = new ConcurrentHashMap<>();
         this.nameAndId = nameAndId(this);
     }
 
     /**
      * If the defining loader has a name explicitly set then
@@ -443,14 +445,14 @@
      * classes are visible.
      *
      * @param  parent
      *         The parent class loader
      *
-     * @throws  SecurityException
-     *          If a security manager exists and its
-     *          {@code checkCreateClassLoader} method doesn't allow creation
-     *          of a new class loader.
+     * @throws SecurityException
+     *         If a security manager exists and its
+     *         {@code checkCreateClassLoader} method doesn't allow creation
+     *         of a new class loader.
      *
      * @since  1.2
      */
     protected ClassLoader(ClassLoader parent) {
         this(checkCreateClassLoader(), null, parent);
@@ -507,12 +509,12 @@
      * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
      * machine to resolve class references.  Invoking this method is equivalent
      * to invoking {@link #loadClass(String, boolean) loadClass(name,
      * false)}.
      *
-     * @param  name
-     *         The <a href="#binary-name">binary name</a> of the class
+     * @param   name
+     *          The <a href="#binary-name">binary name</a> of the class
      *
      * @return  The resulting {@code Class} object
      *
      * @throws  ClassNotFoundException
      *          If the class was not found
@@ -549,15 +551,15 @@
      *
      * <p> Unless overridden, this method synchronizes on the result of
      * {@link #getClassLoadingLock getClassLoadingLock} method
      * during the entire class loading process.
      *
-     * @param  name
-     *         The <a href="#binary-name">binary name</a> of the class
+     * @param   name
+     *          The <a href="#binary-name">binary name</a> of the class
      *
-     * @param  resolve
-     *         If {@code true} then resolve the class
+     * @param   resolve
+     *          If {@code true} then resolve the class
      *
      * @return  The resulting {@code Class} object
      *
      * @throws  ClassNotFoundException
      *          If the class could not be found
@@ -702,12 +704,12 @@
      * the {@link #loadClass loadClass} method after checking the
      * parent class loader for the requested class.
      *
      * @implSpec The default implementation throws {@code ClassNotFoundException}.
      *
-     * @param  name
-     *         The <a href="#binary-name">binary name</a> of the class
+     * @param   name
+     *          The <a href="#binary-name">binary name</a> of the class
      *
      * @return  The resulting {@code Class} object
      *
      * @throws  ClassNotFoundException
      *          If the class could not be found
@@ -1132,22 +1134,12 @@
 
         Certificate[] certs = null;
         if (cs != null) {
             certs = cs.getCertificates();
         }
-        Certificate[] pcerts = null;
-        if (parallelLockMap == null) {
-            synchronized (this) {
-                pcerts = package2certs.get(pname);
-                if (pcerts == null) {
-                    package2certs.put(pname, (certs == null? nocerts:certs));
-                }
-            }
-        } else {
-            pcerts = ((ConcurrentHashMap<String, Certificate[]>)package2certs).
-                putIfAbsent(pname, (certs == null? nocerts:certs));
-        }
+        certs = certs == null ? nocerts : certs;
+        Certificate[] pcerts = package2certs.putIfAbsent(pname, certs);
         if (pcerts != null && !compareCerts(pcerts, certs)) {
             throw new SecurityException("class \"" + name
                 + "\"'s signer information does not match signer information"
                 + " of other classes in the same package");
         }
@@ -1155,17 +1147,14 @@
 
     /**
      * check to make sure the certs for the new class (certs) are the same as
      * the certs for the first class inserted in the package (pcerts)
      */
-    private boolean compareCerts(Certificate[] pcerts,
-                                 Certificate[] certs)
-    {
-        // certs can be null, indicating no certs.
-        if ((certs == null) || (certs.length == 0)) {
+    private boolean compareCerts(Certificate[] pcerts, Certificate[] certs) {
+        // empty array fast-path
+        if (certs.length == 0)
             return pcerts.length == 0;
-        }
 
         // the length must be the same at this point
         if (certs.length != pcerts.length)
             return false;
 
@@ -1891,10 +1880,20 @@
      * If named, the built-in system class loader will have no class path and
      * will search for classes and resources using the application module path;
      * otherwise, if unnamed, it will set the class path to the current
      * working directory.
      *
+     * <p> JAR files on the class path may contain a {@code Class-Path} manifest
+     * attribute to specify dependent JAR files to be included in the class path.
+     * {@code Class-Path} entries must meet certain conditions for validity (see
+     * the <a href="{@docRoot}/../specs/jar/jar.html#class-path-attribute">
+     * JAR File Specification</a> for details).  Invalid {@code Class-Path}
+     * entries are ignored.  For debugging purposes, ignored entries can be
+     * printed to the console if the
+     * {@systemProperty jdk.net.URLClassPath.showIgnoredClassPathEntries} system
+     * property is set to {@code true}.
+     *
      * @return  The system {@code ClassLoader}
      *
      * @throws  SecurityException
      *          If a security manager is present, and the caller's class loader
      *          is not {@code null} and is not the same as or an ancestor of the
@@ -2182,11 +2181,11 @@
      *
      * @since  1.2
      * @revised 9
      * @spec JPMS
      *
-     * @jvms 5.3 Run-time package
+     * @jvms 5.3 Creation and Loading
      * @see <a href="{@docRoot}/../specs/jar/jar.html#package-sealing">
      *      The JAR File Specification: Package Sealing</a>
      */
     protected Package definePackage(String name, String specTitle,
                                     String specVersion, String specVendor,
@@ -2216,11 +2215,11 @@
      *         by this class loader, or {@code null} if not found
      *
      * @throws  NullPointerException
      *          if {@code name} is {@code null}.
      *
-     * @jvms 5.3 Run-time package
+     * @jvms 5.3 Creation and Loading
      *
      * @since  9
      * @spec JPMS
      */
     public final Package getDefinedPackage(String name) {
@@ -2243,11 +2242,11 @@
      *
      * @return The array of {@code Package} objects that have been defined by
      *         this class loader; or an zero length array if no package has been
      *         defined by this class loader.
      *
-     * @jvms 5.3 Run-time package
+     * @jvms 5.3 Creation and Loading
      *
      * @since  9
      * @spec JPMS
      */
     public final Package[] getDefinedPackages() {
@@ -2461,12 +2460,11 @@
                  * When a library is being loaded, JNI_OnLoad function can cause
                  * another loadLibrary invocation that should succeed.
                  *
                  * We use a static stack to hold the list of libraries we are
                  * loading because this can happen only when called by the
-                 * same thread because Runtime.load and Runtime.loadLibrary
-                 * are synchronous.
+                 * same thread because this block is synchronous.
                  *
                  * If there is a pending load operation for the library, we
                  * immediately return success; otherwise, we raise
                  * UnsatisfiedLinkError.
                  */
@@ -2547,74 +2545,29 @@
         // JNI FindClass expects the caller class if invoked from JNI_OnLoad
         // and JNI_OnUnload is NativeLibrary class
         static native void unload(String name, boolean isBuiltin, long handle);
     }
 
-    // The paths searched for libraries
-    private static String usr_paths[];
-    private static String sys_paths[];
-
-    private static String[] initializePath(String propName) {
-        String ldPath = System.getProperty(propName, "");
-        int ldLen = ldPath.length();
-        char ps = File.pathSeparatorChar;
-        int psCount = 0;
-
-        if (ClassLoaderHelper.allowsQuotedPathElements &&
-            ldPath.indexOf('\"') >= 0) {
-            // First, remove quotes put around quoted parts of paths.
-            // Second, use a quotation mark as a new path separator.
-            // This will preserve any quoted old path separators.
-            char[] buf = new char[ldLen];
-            int bufLen = 0;
-            for (int i = 0; i < ldLen; ++i) {
-                char ch = ldPath.charAt(i);
-                if (ch == '\"') {
-                    while (++i < ldLen &&
-                        (ch = ldPath.charAt(i)) != '\"') {
-                        buf[bufLen++] = ch;
-                    }
-                } else {
-                    if (ch == ps) {
-                        psCount++;
-                        ch = '\"';
-                    }
-                    buf[bufLen++] = ch;
-                }
-            }
-            ldPath = new String(buf, 0, bufLen);
-            ldLen = bufLen;
-            ps = '\"';
-        } else {
-            for (int i = ldPath.indexOf(ps); i >= 0;
-                 i = ldPath.indexOf(ps, i + 1)) {
-                psCount++;
-            }
-        }
-
-        String[] paths = new String[psCount + 1];
-        int pathStart = 0;
-        for (int j = 0; j < psCount; ++j) {
-            int pathEnd = ldPath.indexOf(ps, pathStart);
-            paths[j] = (pathStart < pathEnd) ?
-                ldPath.substring(pathStart, pathEnd) : ".";
-            pathStart = pathEnd + 1;
-        }
-        paths[psCount] = (pathStart < ldLen) ?
-            ldPath.substring(pathStart, ldLen) : ".";
-        return paths;
+    /**
+     * Holds system and user library paths derived from the
+     * {@code java.library.path} and {@code sun.boot.library.path} system
+     * properties. The system properties are eagerly read at bootstrap, then
+     * lazily parsed on first use to avoid initialization ordering issues.
+     */
+    private static class LibraryPaths {
+        static final String[] USER =
+                ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());
+        static final String[] SYS =
+                ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());
     }
 
     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
     static void loadLibrary(Class<?> fromClass, String name,
                             boolean isAbsolute) {
         ClassLoader loader =
             (fromClass == null) ? null : fromClass.getClassLoader();
-        if (sys_paths == null) {
-            usr_paths = initializePath("java.library.path");
-            sys_paths = initializePath("sun.boot.library.path");
-        }
+
         if (isAbsolute) {
             if (loadLibrary0(fromClass, new File(name))) {
                 return;
             }
             throw new UnsatisfiedLinkError("Can't load library: " + name);
@@ -2631,23 +2584,23 @@
                     return;
                 }
                 throw new UnsatisfiedLinkError("Can't load " + libfilename);
             }
         }
-        for (String sys_path : sys_paths) {
-            File libfile = new File(sys_path, System.mapLibraryName(name));
+        for (String sysPath : LibraryPaths.SYS) {
+            File libfile = new File(sysPath, System.mapLibraryName(name));
             if (loadLibrary0(fromClass, libfile)) {
                 return;
             }
             libfile = ClassLoaderHelper.mapAlternativeName(libfile);
             if (libfile != null && loadLibrary0(fromClass, libfile)) {
                 return;
             }
         }
         if (loader != null) {
-            for (String usr_path : usr_paths) {
-                File libfile = new File(usr_path, System.mapLibraryName(name));
+            for (String userPath : LibraryPaths.USER) {
+                File libfile = new File(userPath, System.mapLibraryName(name));
                 if (loadLibrary0(fromClass, libfile)) {
                     return;
                 }
                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);
                 if (libfile != null && loadLibrary0(fromClass, libfile)) {
@@ -2655,11 +2608,11 @@
                 }
             }
         }
         // Oops, it failed
         throw new UnsatisfiedLinkError("no " + name +
-            " in java.library.path: " + Arrays.toString(usr_paths));
+            " in java.library.path: " + Arrays.toString(LibraryPaths.USER));
     }
 
     private static native String findBuiltinLib(String name);
 
     private static boolean loadLibrary0(Class<?> fromClass, final File file) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Method.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Member.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Modifier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Method.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 96 
 97     // Accessor for factory
 98     private GenericsFactory getFactory() {
 99         // create scope and factory
100         return CoreReflectionFactory.make(this, MethodScope.make(this));
101     }
102 
103     // Accessor for generic info repository
104     @Override
105     MethodRepository getGenericInfo() {
106         // lazily initialize repository if necessary
107         if (genericInfo == null) {
108             // create and cache generic info repository
109             genericInfo = MethodRepository.make(getGenericSignature(),
110                                                 getFactory());
111         }
112         return genericInfo; //return cached repository
113     }
114 
115     /**
<span class="line-modified">116      * Package-private constructor used by ReflectAccess to enable</span>
<span class="line-removed">117      * instantiation of these objects in Java code from the java.lang</span>
<span class="line-removed">118      * package via sun.reflect.LangReflectAccess.</span>
119      */
120     Method(Class&lt;?&gt; declaringClass,
121            String name,
122            Class&lt;?&gt;[] parameterTypes,
123            Class&lt;?&gt; returnType,
124            Class&lt;?&gt;[] checkedExceptions,
125            int modifiers,
126            int slot,
127            String signature,
128            byte[] annotations,
129            byte[] parameterAnnotations,
130            byte[] annotationDefault) {
131         this.clazz = declaringClass;
132         this.name = name;
133         this.parameterTypes = parameterTypes;
134         this.returnType = returnType;
135         this.exceptionTypes = checkedExceptions;
136         this.modifiers = modifiers;
137         this.slot = slot;
138         this.signature = signature;
</pre>
<hr />
<pre>
252         else
253             return (TypeVariable&lt;Method&gt;[])new TypeVariable[0];
254     }
255 
256     /**
257      * Returns a {@code Class} object that represents the formal return type
258      * of the method represented by this {@code Method} object.
259      *
260      * @return the return type for the method this object represents
261      */
262     public Class&lt;?&gt; getReturnType() {
263         return returnType;
264     }
265 
266     /**
267      * Returns a {@code Type} object that represents the formal return
268      * type of the method represented by this {@code Method} object.
269      *
270      * &lt;p&gt;If the return type is a parameterized type,
271      * the {@code Type} object returned must accurately reflect
<span class="line-modified">272      * the actual type parameters used in the source code.</span>
273      *
274      * &lt;p&gt;If the return type is a type variable or a parameterized type, it
275      * is created. Otherwise, it is resolved.
276      *
277      * @return  a {@code Type} object that represents the formal return
278      *     type of the underlying  method
279      * @throws GenericSignatureFormatError
280      *     if the generic method signature does not conform to the format
281      *     specified in
282      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
283      * @throws TypeNotPresentException if the underlying method&#39;s
284      *     return type refers to a non-existent type declaration
285      * @throws MalformedParameterizedTypeException if the
286      *     underlying method&#39;s return typed refers to a parameterized
287      *     type that cannot be instantiated for any reason
288      * @since 1.5
289      */
290     public Type getGenericReturnType() {
291       if (getGenericSignature() != null) {
292         return getGenericInfo().getReturnType();
</pre>
<hr />
<pre>
386      * the method name, followed by a parenthesized, comma-separated
387      * list of the method&#39;s formal parameter types. If the method
388      * throws checked exceptions, the parameter list is followed by a
389      * space, followed by the word &quot;{@code throws}&quot; followed by a
390      * comma-separated list of the thrown exception types.
391      * For example:
392      * &lt;pre&gt;
393      *    public boolean java.lang.Object.equals(java.lang.Object)
394      * &lt;/pre&gt;
395      *
396      * &lt;p&gt;The access modifiers are placed in canonical order as
397      * specified by &quot;The Java Language Specification&quot;.  This is
398      * {@code public}, {@code protected} or {@code private} first,
399      * and then other modifiers in the following order:
400      * {@code abstract}, {@code default}, {@code static}, {@code final},
401      * {@code synchronized}, {@code native}, {@code strictfp}.
402      *
403      * @return a string describing this {@code Method}
404      *
405      * @jls 8.4.3 Method Modifiers
<span class="line-modified">406      * @jls 9.4   Method Declarations</span>
407      * @jls 9.6.1 Annotation Type Elements
408      */
409     public String toString() {
410         return sharedToString(Modifier.methodModifiers(),
411                               isDefault(),
412                               parameterTypes,
413                               exceptionTypes);
414     }
415 
416     @Override
417     void specificToStringHeader(StringBuilder sb) {
418         sb.append(getReturnType().getTypeName()).append(&#39; &#39;);
419         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
420         sb.append(getName());
421     }
422 
423     @Override
424     String toShortString() {
<span class="line-modified">425         StringBuilder sb = new StringBuilder(&quot;method &quot;);</span>
<span class="line-modified">426         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);</span>
<span class="line-modified">427         sb.append(getName());</span>
<span class="line-modified">428         sb.append(&#39;(&#39;);</span>
<span class="line-modified">429         StringJoiner sj = new StringJoiner(&quot;,&quot;);</span>

430         for (Class&lt;?&gt; parameterType : getParameterTypes()) {
431             sj.add(parameterType.getTypeName());
432         }
<span class="line-modified">433         sb.append(sj);</span>
<span class="line-removed">434         sb.append(&#39;)&#39;);</span>
<span class="line-removed">435         return sb.toString();</span>
436     }
437 
438     /**
439      * Returns a string describing this {@code Method}, including type
440      * parameters.  The string is formatted as the method access
441      * modifiers, if any, followed by an angle-bracketed
442      * comma-separated list of the method&#39;s type parameters, if any,
443      * including informative bounds of the type parameters, if any,
444      * followed by the method&#39;s generic return type, followed by a
445      * space, followed by the class declaring the method, followed by
446      * a period, followed by the method name, followed by a
447      * parenthesized, comma-separated list of the method&#39;s generic
448      * formal parameter types.
449      *
450      * If this method was declared to take a variable number of
451      * arguments, instead of denoting the last parameter as
452      * &quot;&lt;code&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/code&gt;&quot;, it is denoted as
453      * &quot;&lt;code&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/code&gt;&quot;.
454      *
455      * A space is used to separate access modifiers from one another
</pre>
<hr />
<pre>
457      * type parameters, the type parameter list is elided; if the type
458      * parameter list is present, a space separates the list from the
459      * class name.  If the method is declared to throw exceptions, the
460      * parameter list is followed by a space, followed by the word
461      * &quot;{@code throws}&quot; followed by a comma-separated list of the generic
462      * thrown exception types.
463      *
464      * &lt;p&gt;The access modifiers are placed in canonical order as
465      * specified by &quot;The Java Language Specification&quot;.  This is
466      * {@code public}, {@code protected} or {@code private} first,
467      * and then other modifiers in the following order:
468      * {@code abstract}, {@code default}, {@code static}, {@code final},
469      * {@code synchronized}, {@code native}, {@code strictfp}.
470      *
471      * @return a string describing this {@code Method},
472      * include type parameters
473      *
474      * @since 1.5
475      *
476      * @jls 8.4.3 Method Modifiers
<span class="line-modified">477      * @jls 9.4   Method Declarations</span>
478      * @jls 9.6.1 Annotation Type Elements
479      */
480     @Override
481     public String toGenericString() {
482         return sharedToGenericString(Modifier.methodModifiers(), isDefault());
483     }
484 
485     @Override
486     void specificToGenericStringHeader(StringBuilder sb) {
487         Type genRetType = getGenericReturnType();
488         sb.append(genRetType.getTypeName()).append(&#39; &#39;);
489         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
490         sb.append(getName());
491     }
492 
493     /**
494      * Invokes the underlying method represented by this {@code Method}
495      * object, on the specified object with the specified parameters.
496      * Individual parameters are automatically unwrapped to match
497      * primitive formal parameters, and both primitive and reference
498      * parameters are subject to method invocation conversions as
499      * necessary.
500      *
501      * &lt;p&gt;If the underlying method is static, then the specified {@code obj}
502      * argument is ignored. It may be null.
503      *
504      * &lt;p&gt;If the number of formal parameters required by the underlying method is
505      * 0, the supplied {@code args} array may be of length 0 or null.
506      *
507      * &lt;p&gt;If the underlying method is an instance method, it is invoked
508      * using dynamic method lookup as documented in The Java Language
<span class="line-modified">509      * Specification, section 15.12.4.4; in particular,</span>
510      * overriding based on the runtime type of the target object may occur.
511      *
512      * &lt;p&gt;If the underlying method is static, the class that declared
513      * the method is initialized if it has not already been initialized.
514      *
515      * &lt;p&gt;If the method completes normally, the value it returns is
516      * returned to the caller of invoke; if the value has a primitive
517      * type, it is first appropriately wrapped in an object. However,
518      * if the value has the type of an array of a primitive type, the
519      * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in
520      * other words, an array of primitive type is returned.  If the
521      * underlying method return type is void, the invocation returns
522      * null.
523      *
524      * @param obj  the object the underlying method is invoked from
525      * @param args the arguments used for the method call
526      * @return the result of dispatching the method represented by
527      * this object on {@code obj} with parameters
528      * {@code args}
529      *
<span class="line-modified">530      * @exception IllegalAccessException    if this {@code Method} object</span>
531      *              is enforcing Java language access control and the underlying
532      *              method is inaccessible.
<span class="line-modified">533      * @exception IllegalArgumentException  if the method is an</span>
534      *              instance method and the specified object argument
535      *              is not an instance of the class or interface
536      *              declaring the underlying method (or of a subclass
537      *              or implementor thereof); if the number of actual
538      *              and formal parameters differ; if an unwrapping
539      *              conversion for primitive arguments fails; or if,
540      *              after possible unwrapping, a parameter value
541      *              cannot be converted to the corresponding formal
542      *              parameter type by a method invocation conversion.
<span class="line-modified">543      * @exception InvocationTargetException if the underlying method</span>
544      *              throws an exception.
<span class="line-modified">545      * @exception NullPointerException      if the specified object is null</span>
546      *              and the method is an instance method.
<span class="line-modified">547      * @exception ExceptionInInitializerError if the initialization</span>
548      * provoked by this method fails.
549      */
550     @CallerSensitive
551     @ForceInline // to ensure Reflection.getCallerClass optimization
552     @HotSpotIntrinsicCandidate
553     public Object invoke(Object obj, Object... args)
554         throws IllegalAccessException, IllegalArgumentException,
555            InvocationTargetException
556     {
557         if (!override) {
558             Class&lt;?&gt; caller = Reflection.getCallerClass();
559             checkAccess(caller, clazz,
560                         Modifier.isStatic(modifiers) ? null : obj.getClass(),
561                         modifiers);
562         }
563         MethodAccessor ma = methodAccessor;             // read volatile
564         if (ma == null) {
565             ma = acquireMethodAccessor();
566         }
567         return ma.invoke(obj, args);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 96 
 97     // Accessor for factory
 98     private GenericsFactory getFactory() {
 99         // create scope and factory
100         return CoreReflectionFactory.make(this, MethodScope.make(this));
101     }
102 
103     // Accessor for generic info repository
104     @Override
105     MethodRepository getGenericInfo() {
106         // lazily initialize repository if necessary
107         if (genericInfo == null) {
108             // create and cache generic info repository
109             genericInfo = MethodRepository.make(getGenericSignature(),
110                                                 getFactory());
111         }
112         return genericInfo; //return cached repository
113     }
114 
115     /**
<span class="line-modified">116      * Package-private constructor</span>


117      */
118     Method(Class&lt;?&gt; declaringClass,
119            String name,
120            Class&lt;?&gt;[] parameterTypes,
121            Class&lt;?&gt; returnType,
122            Class&lt;?&gt;[] checkedExceptions,
123            int modifiers,
124            int slot,
125            String signature,
126            byte[] annotations,
127            byte[] parameterAnnotations,
128            byte[] annotationDefault) {
129         this.clazz = declaringClass;
130         this.name = name;
131         this.parameterTypes = parameterTypes;
132         this.returnType = returnType;
133         this.exceptionTypes = checkedExceptions;
134         this.modifiers = modifiers;
135         this.slot = slot;
136         this.signature = signature;
</pre>
<hr />
<pre>
250         else
251             return (TypeVariable&lt;Method&gt;[])new TypeVariable[0];
252     }
253 
254     /**
255      * Returns a {@code Class} object that represents the formal return type
256      * of the method represented by this {@code Method} object.
257      *
258      * @return the return type for the method this object represents
259      */
260     public Class&lt;?&gt; getReturnType() {
261         return returnType;
262     }
263 
264     /**
265      * Returns a {@code Type} object that represents the formal return
266      * type of the method represented by this {@code Method} object.
267      *
268      * &lt;p&gt;If the return type is a parameterized type,
269      * the {@code Type} object returned must accurately reflect
<span class="line-modified">270      * the actual type arguments used in the source code.</span>
271      *
272      * &lt;p&gt;If the return type is a type variable or a parameterized type, it
273      * is created. Otherwise, it is resolved.
274      *
275      * @return  a {@code Type} object that represents the formal return
276      *     type of the underlying  method
277      * @throws GenericSignatureFormatError
278      *     if the generic method signature does not conform to the format
279      *     specified in
280      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
281      * @throws TypeNotPresentException if the underlying method&#39;s
282      *     return type refers to a non-existent type declaration
283      * @throws MalformedParameterizedTypeException if the
284      *     underlying method&#39;s return typed refers to a parameterized
285      *     type that cannot be instantiated for any reason
286      * @since 1.5
287      */
288     public Type getGenericReturnType() {
289       if (getGenericSignature() != null) {
290         return getGenericInfo().getReturnType();
</pre>
<hr />
<pre>
384      * the method name, followed by a parenthesized, comma-separated
385      * list of the method&#39;s formal parameter types. If the method
386      * throws checked exceptions, the parameter list is followed by a
387      * space, followed by the word &quot;{@code throws}&quot; followed by a
388      * comma-separated list of the thrown exception types.
389      * For example:
390      * &lt;pre&gt;
391      *    public boolean java.lang.Object.equals(java.lang.Object)
392      * &lt;/pre&gt;
393      *
394      * &lt;p&gt;The access modifiers are placed in canonical order as
395      * specified by &quot;The Java Language Specification&quot;.  This is
396      * {@code public}, {@code protected} or {@code private} first,
397      * and then other modifiers in the following order:
398      * {@code abstract}, {@code default}, {@code static}, {@code final},
399      * {@code synchronized}, {@code native}, {@code strictfp}.
400      *
401      * @return a string describing this {@code Method}
402      *
403      * @jls 8.4.3 Method Modifiers
<span class="line-modified">404      * @jls 9.4 Method Declarations</span>
405      * @jls 9.6.1 Annotation Type Elements
406      */
407     public String toString() {
408         return sharedToString(Modifier.methodModifiers(),
409                               isDefault(),
410                               parameterTypes,
411                               exceptionTypes);
412     }
413 
414     @Override
415     void specificToStringHeader(StringBuilder sb) {
416         sb.append(getReturnType().getTypeName()).append(&#39; &#39;);
417         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
418         sb.append(getName());
419     }
420 
421     @Override
422     String toShortString() {
<span class="line-modified">423         return &quot;method &quot; + getDeclaringClass().getTypeName() +</span>
<span class="line-modified">424                 &#39;.&#39; + toShortSignature();</span>
<span class="line-modified">425     }</span>
<span class="line-modified">426 </span>
<span class="line-modified">427     String toShortSignature() {</span>
<span class="line-added">428         StringJoiner sj = new StringJoiner(&quot;,&quot;, getName() + &quot;(&quot;, &quot;)&quot;);</span>
429         for (Class&lt;?&gt; parameterType : getParameterTypes()) {
430             sj.add(parameterType.getTypeName());
431         }
<span class="line-modified">432         return sj.toString();</span>


433     }
434 
435     /**
436      * Returns a string describing this {@code Method}, including type
437      * parameters.  The string is formatted as the method access
438      * modifiers, if any, followed by an angle-bracketed
439      * comma-separated list of the method&#39;s type parameters, if any,
440      * including informative bounds of the type parameters, if any,
441      * followed by the method&#39;s generic return type, followed by a
442      * space, followed by the class declaring the method, followed by
443      * a period, followed by the method name, followed by a
444      * parenthesized, comma-separated list of the method&#39;s generic
445      * formal parameter types.
446      *
447      * If this method was declared to take a variable number of
448      * arguments, instead of denoting the last parameter as
449      * &quot;&lt;code&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/code&gt;&quot;, it is denoted as
450      * &quot;&lt;code&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/code&gt;&quot;.
451      *
452      * A space is used to separate access modifiers from one another
</pre>
<hr />
<pre>
454      * type parameters, the type parameter list is elided; if the type
455      * parameter list is present, a space separates the list from the
456      * class name.  If the method is declared to throw exceptions, the
457      * parameter list is followed by a space, followed by the word
458      * &quot;{@code throws}&quot; followed by a comma-separated list of the generic
459      * thrown exception types.
460      *
461      * &lt;p&gt;The access modifiers are placed in canonical order as
462      * specified by &quot;The Java Language Specification&quot;.  This is
463      * {@code public}, {@code protected} or {@code private} first,
464      * and then other modifiers in the following order:
465      * {@code abstract}, {@code default}, {@code static}, {@code final},
466      * {@code synchronized}, {@code native}, {@code strictfp}.
467      *
468      * @return a string describing this {@code Method},
469      * include type parameters
470      *
471      * @since 1.5
472      *
473      * @jls 8.4.3 Method Modifiers
<span class="line-modified">474      * @jls 9.4 Method Declarations</span>
475      * @jls 9.6.1 Annotation Type Elements
476      */
477     @Override
478     public String toGenericString() {
479         return sharedToGenericString(Modifier.methodModifiers(), isDefault());
480     }
481 
482     @Override
483     void specificToGenericStringHeader(StringBuilder sb) {
484         Type genRetType = getGenericReturnType();
485         sb.append(genRetType.getTypeName()).append(&#39; &#39;);
486         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
487         sb.append(getName());
488     }
489 
490     /**
491      * Invokes the underlying method represented by this {@code Method}
492      * object, on the specified object with the specified parameters.
493      * Individual parameters are automatically unwrapped to match
494      * primitive formal parameters, and both primitive and reference
495      * parameters are subject to method invocation conversions as
496      * necessary.
497      *
498      * &lt;p&gt;If the underlying method is static, then the specified {@code obj}
499      * argument is ignored. It may be null.
500      *
501      * &lt;p&gt;If the number of formal parameters required by the underlying method is
502      * 0, the supplied {@code args} array may be of length 0 or null.
503      *
504      * &lt;p&gt;If the underlying method is an instance method, it is invoked
505      * using dynamic method lookup as documented in The Java Language
<span class="line-modified">506      * Specification, section {@jls 15.12.4.4}; in particular,</span>
507      * overriding based on the runtime type of the target object may occur.
508      *
509      * &lt;p&gt;If the underlying method is static, the class that declared
510      * the method is initialized if it has not already been initialized.
511      *
512      * &lt;p&gt;If the method completes normally, the value it returns is
513      * returned to the caller of invoke; if the value has a primitive
514      * type, it is first appropriately wrapped in an object. However,
515      * if the value has the type of an array of a primitive type, the
516      * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in
517      * other words, an array of primitive type is returned.  If the
518      * underlying method return type is void, the invocation returns
519      * null.
520      *
521      * @param obj  the object the underlying method is invoked from
522      * @param args the arguments used for the method call
523      * @return the result of dispatching the method represented by
524      * this object on {@code obj} with parameters
525      * {@code args}
526      *
<span class="line-modified">527      * @throws    IllegalAccessException    if this {@code Method} object</span>
528      *              is enforcing Java language access control and the underlying
529      *              method is inaccessible.
<span class="line-modified">530      * @throws    IllegalArgumentException  if the method is an</span>
531      *              instance method and the specified object argument
532      *              is not an instance of the class or interface
533      *              declaring the underlying method (or of a subclass
534      *              or implementor thereof); if the number of actual
535      *              and formal parameters differ; if an unwrapping
536      *              conversion for primitive arguments fails; or if,
537      *              after possible unwrapping, a parameter value
538      *              cannot be converted to the corresponding formal
539      *              parameter type by a method invocation conversion.
<span class="line-modified">540      * @throws    InvocationTargetException if the underlying method</span>
541      *              throws an exception.
<span class="line-modified">542      * @throws    NullPointerException      if the specified object is null</span>
543      *              and the method is an instance method.
<span class="line-modified">544      * @throws    ExceptionInInitializerError if the initialization</span>
545      * provoked by this method fails.
546      */
547     @CallerSensitive
548     @ForceInline // to ensure Reflection.getCallerClass optimization
549     @HotSpotIntrinsicCandidate
550     public Object invoke(Object obj, Object... args)
551         throws IllegalAccessException, IllegalArgumentException,
552            InvocationTargetException
553     {
554         if (!override) {
555             Class&lt;?&gt; caller = Reflection.getCallerClass();
556             checkAccess(caller, clazz,
557                         Modifier.isStatic(modifiers) ? null : obj.getClass(),
558                         modifiers);
559         }
560         MethodAccessor ma = methodAccessor;             // read volatile
561         if (ma == null) {
562             ma = acquireMethodAccessor();
563         }
564         return ma.invoke(obj, args);
</pre>
</td>
</tr>
</table>
<center><a href="Member.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Modifier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
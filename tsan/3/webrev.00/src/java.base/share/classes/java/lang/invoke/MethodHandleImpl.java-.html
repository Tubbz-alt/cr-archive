<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangInvokeAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.reflect.CallerSensitive;
  34 import jdk.internal.reflect.Reflection;
  35 import jdk.internal.vm.annotation.ForceInline;
  36 import jdk.internal.vm.annotation.Hidden;
  37 import jdk.internal.vm.annotation.Stable;
  38 import sun.invoke.empty.Empty;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyType;
  41 import sun.invoke.util.Wrapper;
  42 
  43 import java.lang.reflect.Array;
  44 import java.util.Arrays;
  45 import java.util.Collections;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.function.Function;
  51 import java.util.stream.Stream;
  52 
  53 import static java.lang.invoke.LambdaForm.*;
  54 import static java.lang.invoke.MethodHandleStatics.*;
  55 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  56 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  57 
  58 /**
  59  * Trusted implementation code for MethodHandle.
  60  * @author jrose
  61  */
  62 /*non-public*/ abstract class MethodHandleImpl {
  63 
  64     /// Factory methods to create method handles:
  65 
  66     static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
  67         if (arrayClass == Object[].class) {
  68             return ArrayAccess.objectAccessor(access);
  69         }
  70         if (!arrayClass.isArray())
  71             throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
  72         MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
  73         int cacheIndex = ArrayAccess.cacheIndex(access);
  74         MethodHandle mh = cache[cacheIndex];
  75         if (mh != null)  return mh;
  76         mh = ArrayAccessor.getAccessor(arrayClass, access);
  77         MethodType correctType = ArrayAccessor.correctType(arrayClass, access);
  78         if (mh.type() != correctType) {
  79             assert(mh.type().parameterType(0) == Object[].class);
  80             /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);
  81             /* if access == GET */ assert(access != ArrayAccess.GET ||
  82                     (mh.type().returnType() == Object.class &amp;&amp;
  83                      correctType.parameterType(0).getComponentType() == correctType.returnType()));
  84             // safe to view non-strictly, because element type follows from array type
  85             mh = mh.viewAsType(correctType, false);
  86         }
  87         mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));
  88         // Atomically update accessor cache.
  89         synchronized(cache) {
  90             if (cache[cacheIndex] == null) {
  91                 cache[cacheIndex] = mh;
  92             } else {
  93                 // Throw away newly constructed accessor and use cached version.
  94                 mh = cache[cacheIndex];
  95             }
  96         }
  97         return mh;
  98     }
  99 
 100     enum ArrayAccess {
 101         GET, SET, LENGTH;
 102 
 103         // As ArrayAccess and ArrayAccessor have a circular dependency, the ArrayAccess properties cannot be stored in
 104         // final fields.
 105 
 106         static String opName(ArrayAccess a) {
 107             switch (a) {
 108                 case GET: return &quot;getElement&quot;;
 109                 case SET: return &quot;setElement&quot;;
 110                 case LENGTH: return &quot;length&quot;;
 111             }
 112             throw unmatchedArrayAccess(a);
 113         }
 114 
 115         static MethodHandle objectAccessor(ArrayAccess a) {
 116             switch (a) {
 117                 case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;
 118                 case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;
 119                 case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;
 120             }
 121             throw unmatchedArrayAccess(a);
 122         }
 123 
 124         static int cacheIndex(ArrayAccess a) {
 125             switch (a) {
 126                 case GET: return ArrayAccessor.GETTER_INDEX;
 127                 case SET: return ArrayAccessor.SETTER_INDEX;
 128                 case LENGTH: return ArrayAccessor.LENGTH_INDEX;
 129             }
 130             throw unmatchedArrayAccess(a);
 131         }
 132 
 133         static Intrinsic intrinsic(ArrayAccess a) {
 134             switch (a) {
 135                 case GET: return Intrinsic.ARRAY_LOAD;
 136                 case SET: return Intrinsic.ARRAY_STORE;
 137                 case LENGTH: return Intrinsic.ARRAY_LENGTH;
 138             }
 139             throw unmatchedArrayAccess(a);
 140         }
 141     }
 142 
 143     static InternalError unmatchedArrayAccess(ArrayAccess a) {
 144         return newInternalError(&quot;should not reach here (unmatched ArrayAccess: &quot; + a + &quot;)&quot;);
 145     }
 146 
 147     static final class ArrayAccessor {
 148         /// Support for array element and length access
 149         static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;
 150         static final ClassValue&lt;MethodHandle[]&gt; TYPED_ACCESSORS
 151                 = new ClassValue&lt;MethodHandle[]&gt;() {
 152                     @Override
 153                     protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 154                         return new MethodHandle[INDEX_LIMIT];
 155                     }
 156                 };
 157         static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;
 158         static {
 159             MethodHandle[] cache = TYPED_ACCESSORS.get(Object[].class);
 160             cache[GETTER_INDEX] = OBJECT_ARRAY_GETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.GET),    Intrinsic.ARRAY_LOAD);
 161             cache[SETTER_INDEX] = OBJECT_ARRAY_SETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.SET),    Intrinsic.ARRAY_STORE);
 162             cache[LENGTH_INDEX] = OBJECT_ARRAY_LENGTH = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.LENGTH), Intrinsic.ARRAY_LENGTH);
 163 
 164             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_GETTER.internalMemberName()));
 165             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_SETTER.internalMemberName()));
 166             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_LENGTH.internalMemberName()));
 167         }
 168 
 169         static int     getElementI(int[]     a, int i)            { return              a[i]; }
 170         static long    getElementJ(long[]    a, int i)            { return              a[i]; }
 171         static float   getElementF(float[]   a, int i)            { return              a[i]; }
 172         static double  getElementD(double[]  a, int i)            { return              a[i]; }
 173         static boolean getElementZ(boolean[] a, int i)            { return              a[i]; }
 174         static byte    getElementB(byte[]    a, int i)            { return              a[i]; }
 175         static short   getElementS(short[]   a, int i)            { return              a[i]; }
 176         static char    getElementC(char[]    a, int i)            { return              a[i]; }
 177         static Object  getElementL(Object[]  a, int i)            { return              a[i]; }
 178 
 179         static void    setElementI(int[]     a, int i, int     x) {              a[i] = x; }
 180         static void    setElementJ(long[]    a, int i, long    x) {              a[i] = x; }
 181         static void    setElementF(float[]   a, int i, float   x) {              a[i] = x; }
 182         static void    setElementD(double[]  a, int i, double  x) {              a[i] = x; }
 183         static void    setElementZ(boolean[] a, int i, boolean x) {              a[i] = x; }
 184         static void    setElementB(byte[]    a, int i, byte    x) {              a[i] = x; }
 185         static void    setElementS(short[]   a, int i, short   x) {              a[i] = x; }
 186         static void    setElementC(char[]    a, int i, char    x) {              a[i] = x; }
 187         static void    setElementL(Object[]  a, int i, Object  x) {              a[i] = x; }
 188 
 189         static int     lengthI(int[]     a)                       { return a.length; }
 190         static int     lengthJ(long[]    a)                       { return a.length; }
 191         static int     lengthF(float[]   a)                       { return a.length; }
 192         static int     lengthD(double[]  a)                       { return a.length; }
 193         static int     lengthZ(boolean[] a)                       { return a.length; }
 194         static int     lengthB(byte[]    a)                       { return a.length; }
 195         static int     lengthS(short[]   a)                       { return a.length; }
 196         static int     lengthC(char[]    a)                       { return a.length; }
 197         static int     lengthL(Object[]  a)                       { return a.length; }
 198 
 199         static String name(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 200             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 201             if (elemClass == null)  throw newIllegalArgumentException(&quot;not an array&quot;, arrayClass);
 202             return ArrayAccess.opName(access) + Wrapper.basicTypeChar(elemClass);
 203         }
 204         static MethodType type(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 205             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 206             Class&lt;?&gt; arrayArgClass = arrayClass;
 207             if (!elemClass.isPrimitive()) {
 208                 arrayArgClass = Object[].class;
 209                 elemClass = Object.class;
 210             }
 211             switch (access) {
 212                 case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);
 213                 case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);
 214                 case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);
 215             }
 216             throw unmatchedArrayAccess(access);
 217         }
 218         static MethodType correctType(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 219             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 220             switch (access) {
 221                 case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);
 222                 case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);
 223                 case LENGTH: return MethodType.methodType(int.class,  arrayClass);
 224             }
 225             throw unmatchedArrayAccess(access);
 226         }
 227         static MethodHandle getAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 228             String     name = name(arrayClass, access);
 229             MethodType type = type(arrayClass, access);
 230             try {
 231                 return IMPL_LOOKUP.findStatic(ArrayAccessor.class, name, type);
 232             } catch (ReflectiveOperationException ex) {
 233                 throw uncaughtException(ex);
 234             }
 235         }
 236     }
 237 
 238     /**
 239      * Create a JVM-level adapter method handle to conform the given method
 240      * handle to the similar newType, using only pairwise argument conversions.
 241      * For each argument, convert incoming argument to the exact type needed.
 242      * The argument conversions allowed are casting, boxing and unboxing,
 243      * integral widening or narrowing, and floating point widening or narrowing.
 244      * @param srcType required call type
 245      * @param target original method handle
 246      * @param strict if true, only asType conversions are allowed; if false, explicitCastArguments conversions allowed
 247      * @param monobox if true, unboxing conversions are assumed to be exactly typed (Integer to int only, not long or double)
 248      * @return an adapter to the original handle with the desired new type,
 249      *          or the original target if the types are already identical
 250      *          or null if the adaptation cannot be made
 251      */
 252     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 253                                             boolean strict, boolean monobox) {
 254         MethodType dstType = target.type();
 255         if (srcType == dstType)
 256             return target;
 257         return makePairwiseConvertByEditor(target, srcType, strict, monobox);
 258     }
 259 
 260     private static int countNonNull(Object[] array) {
 261         int count = 0;
 262         if (array != null) {
 263             for (Object x : array) {
 264                 if (x != null) ++count;
 265             }
 266         }
 267         return count;
 268     }
 269 
 270     static MethodHandle makePairwiseConvertByEditor(MethodHandle target, MethodType srcType,
 271                                                     boolean strict, boolean monobox) {
 272         // In method types arguments start at index 0, while the LF
 273         // editor have the MH receiver at position 0 - adjust appropriately.
 274         final int MH_RECEIVER_OFFSET = 1;
 275         Object[] convSpecs = computeValueConversions(srcType, target.type(), strict, monobox);
 276         int convCount = countNonNull(convSpecs);
 277         if (convCount == 0)
 278             return target.viewAsType(srcType, strict);
 279         MethodType basicSrcType = srcType.basicType();
 280         MethodType midType = target.type().basicType();
 281         BoundMethodHandle mh = target.rebind();
 282 
 283         // Match each unique conversion to the positions at which it is to be applied
 284         var convSpecMap = new HashMap&lt;Object, int[]&gt;(((4 * convCount) / 3) + 1);
 285         for (int i = 0; i &lt; convSpecs.length - MH_RECEIVER_OFFSET; i++) {
 286             Object convSpec = convSpecs[i];
 287             if (convSpec == null) continue;
 288             int[] positions = convSpecMap.get(convSpec);
 289             if (positions == null) {
 290                 positions = new int[] { i + MH_RECEIVER_OFFSET };
 291             } else {
 292                 positions = Arrays.copyOf(positions, positions.length + 1);
 293                 positions[positions.length - 1] = i + MH_RECEIVER_OFFSET;
 294             }
 295             convSpecMap.put(convSpec, positions);
 296         }
 297         for (var entry : convSpecMap.entrySet()) {
 298             Object convSpec = entry.getKey();
 299 
 300             MethodHandle fn;
 301             if (convSpec instanceof Class) {
 302                 fn = getConstantHandle(MH_cast).bindTo(convSpec);
 303             } else {
 304                 fn = (MethodHandle) convSpec;
 305             }
 306             int[] positions = entry.getValue();
 307             Class&lt;?&gt; newType = basicSrcType.parameterType(positions[0] - MH_RECEIVER_OFFSET);
 308             BasicType newBasicType = BasicType.basicType(newType);
 309             convCount -= positions.length;
 310             if (convCount == 0) {
 311                 midType = srcType;
 312             } else {
 313                 Class&lt;?&gt;[] ptypes = midType.ptypes().clone();
 314                 for (int pos : positions) {
 315                     ptypes[pos - 1] = newType;
 316                 }
 317                 midType = MethodType.makeImpl(midType.rtype(), ptypes, true);
 318             }
 319             LambdaForm form2;
 320             if (positions.length &gt; 1) {
 321                 form2 = mh.editor().filterRepeatedArgumentForm(newBasicType, positions);
 322             } else {
 323                 form2 = mh.editor().filterArgumentForm(positions[0], newBasicType);
 324             }
 325             mh = mh.copyWithExtendL(midType, form2, fn);
 326         }
 327         Object convSpec = convSpecs[convSpecs.length - 1];
 328         if (convSpec != null) {
 329             MethodHandle fn;
 330             if (convSpec instanceof Class) {
 331                 if (convSpec == void.class)
 332                     fn = null;
 333                 else
 334                     fn = getConstantHandle(MH_cast).bindTo(convSpec);
 335             } else {
 336                 fn = (MethodHandle) convSpec;
 337             }
 338             Class&lt;?&gt; newType = basicSrcType.returnType();
 339             assert(--convCount == 0);
 340             midType = srcType;
 341             if (fn != null) {
 342                 mh = mh.rebind();  // rebind if too complex
 343                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), false);
 344                 mh = mh.copyWithExtendL(midType, form2, fn);
 345             } else {
 346                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), true);
 347                 mh = mh.copyWith(midType, form2);
 348             }
 349         }
 350         assert(convCount == 0);
 351         assert(mh.type().equals(srcType));
 352         return mh;
 353     }
 354 
 355     static Object[] computeValueConversions(MethodType srcType, MethodType dstType,
 356                                             boolean strict, boolean monobox) {
 357         final int INARG_COUNT = srcType.parameterCount();
 358         Object[] convSpecs = null;
 359         for (int i = 0; i &lt;= INARG_COUNT; i++) {
 360             boolean isRet = (i == INARG_COUNT);
 361             Class&lt;?&gt; src = isRet ? dstType.returnType() : srcType.parameterType(i);
 362             Class&lt;?&gt; dst = isRet ? srcType.returnType() : dstType.parameterType(i);
 363             if (!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict)) {
 364                 if (convSpecs == null) {
 365                     convSpecs = new Object[INARG_COUNT + 1];
 366                 }
 367                 convSpecs[i] = valueConversion(src, dst, strict, monobox);
 368             }
 369         }
 370         return convSpecs;
 371     }
 372     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 373                                             boolean strict) {
 374         return makePairwiseConvert(target, srcType, strict, /*monobox=*/ false);
 375     }
 376 
 377     /**
 378      * Find a conversion function from the given source to the given destination.
 379      * This conversion function will be used as a LF NamedFunction.
 380      * Return a Class object if a simple cast is needed.
 381      * Return void.class if void is involved.
 382      */
 383     static Object valueConversion(Class&lt;?&gt; src, Class&lt;?&gt; dst, boolean strict, boolean monobox) {
 384         assert(!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict));  // caller responsibility
 385         if (dst == void.class)
 386             return dst;
 387         MethodHandle fn;
 388         if (src.isPrimitive()) {
 389             if (src == void.class) {
 390                 return void.class;  // caller must recognize this specially
 391             } else if (dst.isPrimitive()) {
 392                 // Examples: int-&gt;byte, byte-&gt;int, boolean-&gt;int (!strict)
 393                 fn = ValueConversions.convertPrimitive(src, dst);
 394             } else {
 395                 // Examples: int-&gt;Integer, boolean-&gt;Object, float-&gt;Number
 396                 Wrapper wsrc = Wrapper.forPrimitiveType(src);
 397                 fn = ValueConversions.boxExact(wsrc);
 398                 assert(fn.type().parameterType(0) == wsrc.primitiveType());
 399                 assert(fn.type().returnType() == wsrc.wrapperType());
 400                 if (!VerifyType.isNullConversion(wsrc.wrapperType(), dst, strict)) {
 401                     // Corner case, such as int-&gt;Long, which will probably fail.
 402                     MethodType mt = MethodType.methodType(dst, src);
 403                     if (strict)
 404                         fn = fn.asType(mt);
 405                     else
 406                         fn = MethodHandleImpl.makePairwiseConvert(fn, mt, /*strict=*/ false);
 407                 }
 408             }
 409         } else if (dst.isPrimitive()) {
 410             Wrapper wdst = Wrapper.forPrimitiveType(dst);
 411             if (monobox || src == wdst.wrapperType()) {
 412                 // Use a strongly-typed unboxer, if possible.
 413                 fn = ValueConversions.unboxExact(wdst, strict);
 414             } else {
 415                 // Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int, Byte-&gt;int
 416                 // must include additional conversions
 417                 // src must be examined at runtime, to detect Byte, Character, etc.
 418                 fn = (strict
 419                         ? ValueConversions.unboxWiden(wdst)
 420                         : ValueConversions.unboxCast(wdst));
 421             }
 422         } else {
 423             // Simple reference conversion.
 424             // Note:  Do not check for a class hierarchy relation
 425             // between src and dst.  In all cases a &#39;null&#39; argument
 426             // will pass the cast conversion.
 427             return dst;
 428         }
 429         assert(fn.type().parameterCount() &lt;= 1) : &quot;pc&quot;+Arrays.asList(src.getSimpleName(), dst.getSimpleName(), fn);
 430         return fn;
 431     }
 432 
 433     static MethodHandle makeVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 434         MethodType type = target.type();
 435         int last = type.parameterCount() - 1;
 436         if (type.parameterType(last) != arrayType)
 437             target = target.asType(type.changeParameterType(last, arrayType));
 438         target = target.asFixedArity();  // make sure this attribute is turned off
 439         return new AsVarargsCollector(target, arrayType);
 440     }
 441 
 442     private static final class AsVarargsCollector extends DelegatingMethodHandle {
 443         private final MethodHandle target;
 444         private final Class&lt;?&gt; arrayType;
 445         private @Stable MethodHandle asCollectorCache;
 446 
 447         AsVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 448             this(target.type(), target, arrayType);
 449         }
 450         AsVarargsCollector(MethodType type, MethodHandle target, Class&lt;?&gt; arrayType) {
 451             super(type, target);
 452             this.target = target;
 453             this.arrayType = arrayType;
 454         }
 455 
 456         @Override
 457         public boolean isVarargsCollector() {
 458             return true;
 459         }
 460 
 461         @Override
 462         protected MethodHandle getTarget() {
 463             return target;
 464         }
 465 
 466         @Override
 467         public MethodHandle asFixedArity() {
 468             return target;
 469         }
 470 
 471         @Override
 472         MethodHandle setVarargs(MemberName member) {
 473             if (member.isVarargs())  return this;
 474             return asFixedArity();
 475         }
 476 
 477         @Override
 478         public MethodHandle withVarargs(boolean makeVarargs) {
 479             if (makeVarargs)  return this;
 480             return asFixedArity();
 481         }
 482 
 483         @Override
 484         public MethodHandle asTypeUncached(MethodType newType) {
 485             MethodType type = this.type();
 486             int collectArg = type.parameterCount() - 1;
 487             int newArity = newType.parameterCount();
 488             if (newArity == collectArg+1 &amp;&amp;
 489                 type.parameterType(collectArg).isAssignableFrom(newType.parameterType(collectArg))) {
 490                 // if arity and trailing parameter are compatible, do normal thing
 491                 return asTypeCache = asFixedArity().asType(newType);
 492             }
 493             // check cache
 494             MethodHandle acc = asCollectorCache;
 495             if (acc != null &amp;&amp; acc.type().parameterCount() == newArity)
 496                 return asTypeCache = acc.asType(newType);
 497             // build and cache a collector
 498             int arrayLength = newArity - collectArg;
 499             MethodHandle collector;
 500             try {
 501                 collector = asFixedArity().asCollector(arrayType, arrayLength);
 502                 assert(collector.type().parameterCount() == newArity) : &quot;newArity=&quot;+newArity+&quot; but collector=&quot;+collector;
 503             } catch (IllegalArgumentException ex) {
 504                 throw new WrongMethodTypeException(&quot;cannot build collector&quot;, ex);
 505             }
 506             asCollectorCache = collector;
 507             return asTypeCache = collector.asType(newType);
 508         }
 509 
 510         @Override
 511         boolean viewAsTypeChecks(MethodType newType, boolean strict) {
 512             super.viewAsTypeChecks(newType, true);
 513             if (strict) return true;
 514             // extra assertion for non-strict checks:
 515             assert (type().lastParameterType().getComponentType()
 516                     .isAssignableFrom(
 517                             newType.lastParameterType().getComponentType()))
 518                     : Arrays.asList(this, newType);
 519             return true;
 520         }
 521 
 522         @Override
 523         public Object invokeWithArguments(Object... arguments) throws Throwable {
 524             MethodType type = this.type();
 525             int argc;
 526             final int MAX_SAFE = 127;  // 127 longs require 254 slots, which is safe to spread
 527             if (arguments == null
 528                     || (argc = arguments.length) &lt;= MAX_SAFE
 529                     || argc &lt; type.parameterCount()) {
 530                 return super.invokeWithArguments(arguments);
 531             }
 532 
 533             // a jumbo invocation requires more explicit reboxing of the trailing arguments
 534             int uncollected = type.parameterCount() - 1;
 535             Class&lt;?&gt; elemType = arrayType.getComponentType();
 536             int collected = argc - uncollected;
 537             Object collArgs = (elemType == Object.class)
 538                 ? new Object[collected] : Array.newInstance(elemType, collected);
 539             if (!elemType.isPrimitive()) {
 540                 // simple cast:  just do some casting
 541                 try {
 542                     System.arraycopy(arguments, uncollected, collArgs, 0, collected);
 543                 } catch (ArrayStoreException ex) {
 544                     return super.invokeWithArguments(arguments);
 545                 }
 546             } else {
 547                 // corner case of flat array requires reflection (or specialized copy loop)
 548                 MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
 549                 try {
 550                     for (int i = 0; i &lt; collected; i++) {
 551                         arraySetter.invoke(collArgs, i, arguments[uncollected + i]);
 552                     }
 553                 } catch (WrongMethodTypeException|ClassCastException ex) {
 554                     return super.invokeWithArguments(arguments);
 555                 }
 556             }
 557 
 558             // chop the jumbo list down to size and call in non-varargs mode
 559             Object[] newArgs = new Object[uncollected + 1];
 560             System.arraycopy(arguments, 0, newArgs, 0, uncollected);
 561             newArgs[uncollected] = collArgs;
 562             return asFixedArity().invokeWithArguments(newArgs);
 563         }
 564     }
 565 
 566     /** Factory method:  Spread selected argument. */
 567     static MethodHandle makeSpreadArguments(MethodHandle target,
 568                                             Class&lt;?&gt; spreadArgType, int spreadArgPos, int spreadArgCount) {
 569         MethodType targetType = target.type();
 570 
 571         for (int i = 0; i &lt; spreadArgCount; i++) {
 572             Class&lt;?&gt; arg = VerifyType.spreadArgElementType(spreadArgType, i);
 573             if (arg == null)  arg = Object.class;
 574             targetType = targetType.changeParameterType(spreadArgPos + i, arg);
 575         }
 576         target = target.asType(targetType);
 577 
 578         MethodType srcType = targetType
 579                 .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);
 580         // Now build a LambdaForm.
 581         MethodType lambdaType = srcType.invokerType();
 582         Name[] names = arguments(spreadArgCount + 2, lambdaType);
 583         int nameCursor = lambdaType.parameterCount();
 584         int[] indexes = new int[targetType.parameterCount()];
 585 
 586         for (int i = 0, argIndex = 1; i &lt; targetType.parameterCount() + 1; i++, argIndex++) {
 587             Class&lt;?&gt; src = lambdaType.parameterType(i);
 588             if (i == spreadArgPos) {
 589                 // Spread the array.
 590                 MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);
 591                 Name array = names[argIndex];
 592                 names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);
 593                 for (int j = 0; j &lt; spreadArgCount; i++, j++) {
 594                     indexes[i] = nameCursor;
 595                     names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);
 596                 }
 597             } else if (i &lt; indexes.length) {
 598                 indexes[i] = argIndex;
 599             }
 600         }
 601         assert(nameCursor == names.length-1);  // leave room for the final call
 602 
 603         // Build argument array for the call.
 604         Name[] targetArgs = new Name[targetType.parameterCount()];
 605         for (int i = 0; i &lt; targetType.parameterCount(); i++) {
 606             int idx = indexes[i];
 607             targetArgs[i] = names[idx];
 608         }
 609         names[names.length - 1] = new Name(target, (Object[]) targetArgs);
 610 
 611         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);
 612         return SimpleMethodHandle.make(srcType, form);
 613     }
 614 
 615     static void checkSpreadArgument(Object av, int n) {
 616         if (av == null &amp;&amp; n == 0) {
 617             return;
 618         } else if (av == null) {
 619             throw new NullPointerException(&quot;null array reference&quot;);
 620         } else if (av instanceof Object[]) {
 621             int len = ((Object[])av).length;
 622             if (len == n)  return;
 623         } else {
 624             int len = java.lang.reflect.Array.getLength(av);
 625             if (len == n)  return;
 626         }
 627         // fall through to error:
 628         throw newIllegalArgumentException(&quot;array is not of length &quot;+n);
 629     }
 630 
 631     /** Factory method:  Collect or filter selected argument(s). */
 632     static MethodHandle makeCollectArguments(MethodHandle target,
 633                 MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {
 634         MethodType targetType = target.type();          // (a..., c, [b...])=&gt;r
 635         MethodType collectorType = collector.type();    // (b...)=&gt;c
 636         int collectArgCount = collectorType.parameterCount();
 637         Class&lt;?&gt; collectValType = collectorType.returnType();
 638         int collectValCount = (collectValType == void.class ? 0 : 1);
 639         MethodType srcType = targetType                 // (a..., [b...])=&gt;r
 640                 .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);
 641         if (!retainOriginalArgs) {                      // (a..., b...)=&gt;r
 642             srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());
 643         }
 644         // in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]
 645         // out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]
 646         // out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]
 647 
 648         // Now build a LambdaForm.
 649         MethodType lambdaType = srcType.invokerType();
 650         Name[] names = arguments(2, lambdaType);
 651         final int collectNamePos = names.length - 2;
 652         final int targetNamePos  = names.length - 1;
 653 
 654         Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);
 655         names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);
 656 
 657         // Build argument array for the target.
 658         // Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].
 659         // Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
 660         Name[] targetArgs = new Name[targetType.parameterCount()];
 661         int inputArgPos  = 1;  // incoming LF args to copy to target
 662         int targetArgPos = 0;  // fill pointer for targetArgs
 663         int chunk = collectArgPos;  // |headArgs|
 664         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 665         inputArgPos  += chunk;
 666         targetArgPos += chunk;
 667         if (collectValType != void.class) {
 668             targetArgs[targetArgPos++] = names[collectNamePos];
 669         }
 670         chunk = collectArgCount;
 671         if (retainOriginalArgs) {
 672             System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 673             targetArgPos += chunk;   // optionally pass on the collected chunk
 674         }
 675         inputArgPos += chunk;
 676         chunk = targetArgs.length - targetArgPos;  // all the rest
 677         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 678         assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
 679         names[targetNamePos] = new Name(target, (Object[]) targetArgs);
 680 
 681         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
 682         return SimpleMethodHandle.make(srcType, form);
 683     }
 684 
 685     @Hidden
 686     static
 687     MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
 688         if (testResult) {
 689             return target;
 690         } else {
 691             return fallback;
 692         }
 693     }
 694 
 695     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
 696     @Hidden
 697     @jdk.internal.HotSpotIntrinsicCandidate
 698     static
 699     boolean profileBoolean(boolean result, int[] counters) {
 700         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
 701         int idx = result ? 1 : 0;
 702         try {
 703             counters[idx] = Math.addExact(counters[idx], 1);
 704         } catch (ArithmeticException e) {
 705             // Avoid continuous overflow by halving the problematic count.
 706             counters[idx] = counters[idx] / 2;
 707         }
 708         return result;
 709     }
 710 
 711     // Intrinsified by C2. Returns true if obj is a compile-time constant.
 712     @Hidden
 713     @jdk.internal.HotSpotIntrinsicCandidate
 714     static
 715     boolean isCompileConstant(Object obj) {
 716         return false;
 717     }
 718 
 719     static
 720     MethodHandle makeGuardWithTest(MethodHandle test,
 721                                    MethodHandle target,
 722                                    MethodHandle fallback) {
 723         MethodType type = target.type();
 724         assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
 725         MethodType basicType = type.basicType();
 726         LambdaForm form = makeGuardWithTestForm(basicType);
 727         BoundMethodHandle mh;
 728         try {
 729             if (PROFILE_GWT) {
 730                 int[] counts = new int[2];
 731                 mh = (BoundMethodHandle)
 732                         BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
 733                                 (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
 734             } else {
 735                 mh = (BoundMethodHandle)
 736                         BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
 737                                 (Object) test, (Object) profile(target), (Object) profile(fallback));
 738             }
 739         } catch (Throwable ex) {
 740             throw uncaughtException(ex);
 741         }
 742         assert(mh.type() == type);
 743         return mh;
 744     }
 745 
 746 
 747     static
 748     MethodHandle profile(MethodHandle target) {
 749         if (DONT_INLINE_THRESHOLD &gt;= 0) {
 750             return makeBlockInliningWrapper(target);
 751         } else {
 752             return target;
 753         }
 754     }
 755 
 756     /**
 757      * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
 758      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
 759      */
 760     static
 761     MethodHandle makeBlockInliningWrapper(MethodHandle target) {
 762         LambdaForm lform;
 763         if (DONT_INLINE_THRESHOLD &gt; 0) {
 764             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
 765         } else {
 766             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
 767         }
 768         return new CountingWrapper(target, lform,
 769                 Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
 770                                    DONT_INLINE_THRESHOLD);
 771     }
 772 
 773     private final static class Makers {
 774         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
 775         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 776             @Override
 777             public LambdaForm apply(MethodHandle target) {
 778                 return DelegatingMethodHandle.makeReinvokerForm(target,
 779                                    MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
 780                                    DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);
 781             }
 782         };
 783 
 784         /** Constructs simple reinvoker lambda form for a particular method handle */
 785         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_REINVOKER_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 786             @Override
 787             public LambdaForm apply(MethodHandle target) {
 788                 return DelegatingMethodHandle.makeReinvokerForm(target,
 789                         MethodTypeForm.LF_DELEGATE, DelegatingMethodHandle.class, DelegatingMethodHandle.NF_getTarget);
 790             }
 791         };
 792 
 793         /** Maker of type-polymorphic varargs */
 794         static final ClassValue&lt;MethodHandle[]&gt; TYPED_COLLECTORS = new ClassValue&lt;MethodHandle[]&gt;() {
 795             @Override
 796             protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 797                 return new MethodHandle[MAX_JVM_ARITY + 1];
 798             }
 799         };
 800     }
 801 
 802     /**
 803      * Counting method handle. It has 2 states: counting and non-counting.
 804      * It is in counting state for the first n invocations and then transitions to non-counting state.
 805      * Behavior in counting and non-counting states is determined by lambda forms produced by
 806      * countingFormProducer &amp; nonCountingFormProducer respectively.
 807      */
 808     static class CountingWrapper extends DelegatingMethodHandle {
 809         private final MethodHandle target;
 810         private int count;
 811         private Function&lt;MethodHandle, LambdaForm&gt; countingFormProducer;
 812         private Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer;
 813         private volatile boolean isCounting;
 814 
 815         private CountingWrapper(MethodHandle target, LambdaForm lform,
 816                                 Function&lt;MethodHandle, LambdaForm&gt; countingFromProducer,
 817                                 Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer,
 818                                 int count) {
 819             super(target.type(), lform);
 820             this.target = target;
 821             this.count = count;
 822             this.countingFormProducer = countingFromProducer;
 823             this.nonCountingFormProducer = nonCountingFormProducer;
 824             this.isCounting = (count &gt; 0);
 825         }
 826 
 827         @Hidden
 828         @Override
 829         protected MethodHandle getTarget() {
 830             return target;
 831         }
 832 
 833         @Override
 834         public MethodHandle asTypeUncached(MethodType newType) {
 835             MethodHandle newTarget = target.asType(newType);
 836             MethodHandle wrapper;
 837             if (isCounting) {
 838                 LambdaForm lform;
 839                 lform = countingFormProducer.apply(newTarget);
 840                 wrapper = new CountingWrapper(newTarget, lform, countingFormProducer, nonCountingFormProducer, DONT_INLINE_THRESHOLD);
 841             } else {
 842                 wrapper = newTarget; // no need for a counting wrapper anymore
 843             }
 844             return (asTypeCache = wrapper);
 845         }
 846 
 847         // Customize target if counting happens for too long.
 848         private int invocations = CUSTOMIZE_THRESHOLD;
 849         private void maybeCustomizeTarget() {
 850             int c = invocations;
 851             if (c &gt;= 0) {
 852                 if (c == 1) {
 853                     target.customize();
 854                 }
 855                 invocations = c - 1;
 856             }
 857         }
 858 
 859         boolean countDown() {
 860             int c = count;
 861             maybeCustomizeTarget();
 862             if (c &lt;= 1) {
 863                 // Try to limit number of updates. MethodHandle.updateForm() doesn&#39;t guarantee LF update visibility.
 864                 if (isCounting) {
 865                     isCounting = false;
 866                     return true;
 867                 } else {
 868                     return false;
 869                 }
 870             } else {
 871                 count = c - 1;
 872                 return false;
 873             }
 874         }
 875 
 876         @Hidden
 877         static void maybeStopCounting(Object o1) {
 878              CountingWrapper wrapper = (CountingWrapper) o1;
 879              if (wrapper.countDown()) {
 880                  // Reached invocation threshold. Replace counting behavior with a non-counting one.
 881                  LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
 882                  lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
 883                  wrapper.updateForm(lform);
 884              }
 885         }
 886 
 887         static final NamedFunction NF_maybeStopCounting;
 888         static {
 889             Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
 890             try {
 891                 NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
 892             } catch (ReflectiveOperationException ex) {
 893                 throw newInternalError(ex);
 894             }
 895         }
 896     }
 897 
 898     static
 899     LambdaForm makeGuardWithTestForm(MethodType basicType) {
 900         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
 901         if (lform != null)  return lform;
 902         final int THIS_MH      = 0;  // the BMH_LLL
 903         final int ARG_BASE     = 1;  // start of incoming arguments
 904         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 905         int nameCursor = ARG_LIMIT;
 906         final int GET_TEST     = nameCursor++;
 907         final int GET_TARGET   = nameCursor++;
 908         final int GET_FALLBACK = nameCursor++;
 909         final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
 910         final int CALL_TEST    = nameCursor++;
 911         final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
 912         final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST
 913         final int SELECT_ALT   = nameCursor++;
 914         final int CALL_TARGET  = nameCursor++;
 915         assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative
 916 
 917         MethodType lambdaType = basicType.invokerType();
 918         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 919 
 920         BoundMethodHandle.SpeciesData data =
 921                 (GET_COUNTERS != -1) ? BoundMethodHandle.speciesData_LLLL()
 922                                      : BoundMethodHandle.speciesData_LLL();
 923         names[THIS_MH] = names[THIS_MH].withConstraint(data);
 924         names[GET_TEST]     = new Name(data.getterFunction(0), names[THIS_MH]);
 925         names[GET_TARGET]   = new Name(data.getterFunction(1), names[THIS_MH]);
 926         names[GET_FALLBACK] = new Name(data.getterFunction(2), names[THIS_MH]);
 927         if (GET_COUNTERS != -1) {
 928             names[GET_COUNTERS] = new Name(data.getterFunction(3), names[THIS_MH]);
 929         }
 930         Object[] invokeArgs = Arrays.copyOfRange(names, 0, ARG_LIMIT, Object[].class);
 931 
 932         // call test
 933         MethodType testType = basicType.changeReturnType(boolean.class).basicType();
 934         invokeArgs[0] = names[GET_TEST];
 935         names[CALL_TEST] = new Name(testType, invokeArgs);
 936 
 937         // profile branch
 938         if (PROFILE != -1) {
 939             names[PROFILE] = new Name(getFunction(NF_profileBoolean), names[CALL_TEST], names[GET_COUNTERS]);
 940         }
 941         // call selectAlternative
 942         names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);
 943 
 944         // call target or fallback
 945         invokeArgs[0] = names[SELECT_ALT];
 946         names[CALL_TARGET] = new Name(basicType, invokeArgs);
 947 
 948         lform = new LambdaForm(lambdaType.parameterCount(), names, /*forceInline=*/true, Kind.GUARD);
 949 
 950         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWT, lform);
 951     }
 952 
 953     /**
 954      * The LambdaForm shape for catchException combinator is the following:
 955      * &lt;blockquote&gt;&lt;pre&gt;{@code
 956      *  guardWithCatch=Lambda(a0:L,a1:L,a2:L)=&gt;{
 957      *    t3:L=BoundMethodHandle$Species_LLLLL.argL0(a0:L);
 958      *    t4:L=BoundMethodHandle$Species_LLLLL.argL1(a0:L);
 959      *    t5:L=BoundMethodHandle$Species_LLLLL.argL2(a0:L);
 960      *    t6:L=BoundMethodHandle$Species_LLLLL.argL3(a0:L);
 961      *    t7:L=BoundMethodHandle$Species_LLLLL.argL4(a0:L);
 962      *    t8:L=MethodHandle.invokeBasic(t6:L,a1:L,a2:L);
 963      *    t9:L=MethodHandleImpl.guardWithCatch(t3:L,t4:L,t5:L,t8:L);
 964      *   t10:I=MethodHandle.invokeBasic(t7:L,t9:L);t10:I}
 965      * }&lt;/pre&gt;&lt;/blockquote&gt;
 966      *
 967      * argL0 and argL2 are target and catcher method handles. argL1 is exception class.
 968      * argL3 and argL4 are auxiliary method handles: argL3 boxes arguments and wraps them into Object[]
 969      * (ValueConversions.array()) and argL4 unboxes result if necessary (ValueConversions.unbox()).
 970      *
 971      * Having t8 and t10 passed outside and not hardcoded into a lambda form allows to share lambda forms
 972      * among catchException combinators with the same basic type.
 973      */
 974     private static LambdaForm makeGuardWithCatchForm(MethodType basicType) {
 975         MethodType lambdaType = basicType.invokerType();
 976 
 977         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWC);
 978         if (lform != null) {
 979             return lform;
 980         }
 981         final int THIS_MH      = 0;  // the BMH_LLLLL
 982         final int ARG_BASE     = 1;  // start of incoming arguments
 983         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 984 
 985         int nameCursor = ARG_LIMIT;
 986         final int GET_TARGET       = nameCursor++;
 987         final int GET_CLASS        = nameCursor++;
 988         final int GET_CATCHER      = nameCursor++;
 989         final int GET_COLLECT_ARGS = nameCursor++;
 990         final int GET_UNBOX_RESULT = nameCursor++;
 991         final int BOXED_ARGS       = nameCursor++;
 992         final int TRY_CATCH        = nameCursor++;
 993         final int UNBOX_RESULT     = nameCursor++;
 994 
 995         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 996 
 997         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
 998         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
 999         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
1000         names[GET_CLASS]        = new Name(data.getterFunction(1), names[THIS_MH]);
1001         names[GET_CATCHER]      = new Name(data.getterFunction(2), names[THIS_MH]);
1002         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(3), names[THIS_MH]);
1003         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(4), names[THIS_MH]);
1004 
1005         // FIXME: rework argument boxing/result unboxing logic for LF interpretation
1006 
1007         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
1008         MethodType collectArgsType = basicType.changeReturnType(Object.class);
1009         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1010         Object[] args = new Object[invokeBasic.type().parameterCount()];
1011         args[0] = names[GET_COLLECT_ARGS];
1012         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
1013         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
1014 
1015         // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);
1016         Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};
1017         names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);
1018 
1019         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1020         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1021         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
1022         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1023 
1024         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
1025 
1026         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
1027     }
1028 
1029     static
1030     MethodHandle makeGuardWithCatch(MethodHandle target,
1031                                     Class&lt;? extends Throwable&gt; exType,
1032                                     MethodHandle catcher) {
1033         MethodType type = target.type();
1034         LambdaForm form = makeGuardWithCatchForm(type.basicType());
1035 
1036         // Prepare auxiliary method handles used during LambdaForm interpretation.
1037         // Box arguments and wrap them into Object[]: ValueConversions.array().
1038         MethodType varargsType = type.changeReturnType(Object[].class);
1039         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1040         MethodHandle unboxResult = unboxResultHandle(type.returnType());
1041 
1042         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
1043         BoundMethodHandle mh;
1044         try {
1045             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,
1046                     (Object) catcher, (Object) collectArgs, (Object) unboxResult);
1047         } catch (Throwable ex) {
1048             throw uncaughtException(ex);
1049         }
1050         assert(mh.type() == type);
1051         return mh;
1052     }
1053 
1054     /**
1055      * Intrinsified during LambdaForm compilation
1056      * (see {@link InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch}).
1057      */
1058     @Hidden
1059     static Object guardWithCatch(MethodHandle target, Class&lt;? extends Throwable&gt; exType, MethodHandle catcher,
1060                                  Object... av) throws Throwable {
1061         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
1062         try {
1063             return target.asFixedArity().invokeWithArguments(av);
1064         } catch (Throwable t) {
1065             if (!exType.isInstance(t)) throw t;
1066             return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
1067         }
1068     }
1069 
1070     /** Prepend elements to an array. */
1071     @Hidden
1072     private static Object[] prepend(Object[] array, Object... elems) {
1073         int nArray = array.length;
1074         int nElems = elems.length;
1075         Object[] newArray = new Object[nArray + nElems];
1076         System.arraycopy(elems, 0, newArray, 0, nElems);
1077         System.arraycopy(array, 0, newArray, nElems, nArray);
1078         return newArray;
1079     }
1080 
1081     static
1082     MethodHandle throwException(MethodType type) {
1083         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
1084         int arity = type.parameterCount();
1085         if (arity &gt; 1) {
1086             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
1087             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
1088             return mh;
1089         }
1090         return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
1091     }
1092 
1093     static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }
1094 
1095     static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];
1096     static MethodHandle fakeMethodHandleInvoke(MemberName method) {
1097         int idx;
1098         assert(method.isMethodHandleInvoke());
1099         switch (method.getName()) {
1100         case &quot;invoke&quot;:       idx = 0; break;
1101         case &quot;invokeExact&quot;:  idx = 1; break;
1102         default:             throw new InternalError(method.getName());
1103         }
1104         MethodHandle mh = FAKE_METHOD_HANDLE_INVOKE[idx];
1105         if (mh != null)  return mh;
1106         MethodType type = MethodType.methodType(Object.class, UnsupportedOperationException.class,
1107                                                 MethodHandle.class, Object[].class);
1108         mh = throwException(type);
1109         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke MethodHandle&quot;));
1110         if (!method.getInvocationType().equals(mh.type()))
1111             throw new InternalError(method.toString());
1112         mh = mh.withInternalMemberName(method, false);
1113         mh = mh.withVarargs(true);
1114         assert(method.isVarargs());
1115         FAKE_METHOD_HANDLE_INVOKE[idx] = mh;
1116         return mh;
1117     }
1118     static MethodHandle fakeVarHandleInvoke(MemberName method) {
1119         // TODO caching, is it necessary?
1120         MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,
1121                                                 VarHandle.class, Object[].class);
1122         MethodHandle mh = throwException(type);
1123         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));
1124         if (!method.getInvocationType().equals(mh.type()))
1125             throw new InternalError(method.toString());
1126         mh = mh.withInternalMemberName(method, false);
1127         mh = mh.asVarargsCollector(Object[].class);
1128         assert(method.isVarargs());
1129         return mh;
1130     }
1131 
1132     /**
1133      * Create an alias for the method handle which, when called,
1134      * appears to be called from the same class loader and protection domain
1135      * as hostClass.
1136      * This is an expensive no-op unless the method which is called
1137      * is sensitive to its caller.  A small number of system methods
1138      * are in this category, including Class.forName and Method.invoke.
1139      */
1140     static
1141     MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1142         return BindCaller.bindCaller(mh, hostClass);
1143     }
1144 
1145     // Put the whole mess into its own nested class.
1146     // That way we can lazily load the code and set up the constants.
1147     private static class BindCaller {
1148         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1149 
1150         static
1151         MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1152             // Code in the boot layer should now be careful while creating method handles or
1153             // functional interface instances created from method references to @CallerSensitive  methods,
1154             // it needs to be ensured the handles or interface instances are kept safe and are not passed
1155             // from the boot layer to untrusted code.
1156             if (hostClass == null
1157                 ||    (hostClass.isArray() ||
1158                        hostClass.isPrimitive() ||
1159                        hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
1160                 throw new InternalError();  // does not happen, and should not anyway
1161             }
1162             // For simplicity, convert mh to a varargs-like method.
1163             MethodHandle vamh = prepareForInvoker(mh);
1164             // Cache the result of makeInjectedInvoker once per argument class.
1165             MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
1166             return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);
1167         }
1168 
1169         private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; hostClass) {
1170             try {
1171                 Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(hostClass, INJECTED_INVOKER_TEMPLATE, null);
1172                 assert checkInjectedInvoker(hostClass, invokerClass);
1173                 return IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1174             } catch (ReflectiveOperationException ex) {
1175                 throw uncaughtException(ex);
1176             }
1177         }
1178 
1179         private static ClassValue&lt;MethodHandle&gt; CV_makeInjectedInvoker = new ClassValue&lt;MethodHandle&gt;() {
1180             @Override protected MethodHandle computeValue(Class&lt;?&gt; hostClass) {
1181                 return makeInjectedInvoker(hostClass);
1182             }
1183         };
1184 
1185         // Adapt mh so that it can be called directly from an injected invoker:
1186         private static MethodHandle prepareForInvoker(MethodHandle mh) {
1187             mh = mh.asFixedArity();
1188             MethodType mt = mh.type();
1189             int arity = mt.parameterCount();
1190             MethodHandle vamh = mh.asType(mt.generic());
1191             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1192             vamh = vamh.asSpreader(Object[].class, arity);
1193             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1194             return vamh;
1195         }
1196 
1197         // Undo the adapter effect of prepareForInvoker:
1198         private static MethodHandle restoreToType(MethodHandle vamh,
1199                                                   MethodHandle original,
1200                                                   Class&lt;?&gt; hostClass) {
1201             MethodType type = original.type();
1202             MethodHandle mh = vamh.asCollector(Object[].class, type.parameterCount());
1203             MemberName member = original.internalMemberName();
1204             mh = mh.asType(type);
1205             mh = new WrappedMember(mh, type, member, original.isInvokeSpecial(), hostClass);
1206             return mh;
1207         }
1208 
1209         private static boolean checkInjectedInvoker(Class&lt;?&gt; hostClass, Class&lt;?&gt; invokerClass) {
1210             assert (hostClass.getClassLoader() == invokerClass.getClassLoader()) : hostClass.getName()+&quot; (CL)&quot;;
1211             try {
1212                 assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+&quot; (PD)&quot;;
1213             } catch (SecurityException ex) {
1214                 // Self-check was blocked by security manager. This is OK.
1215             }
1216             try {
1217                 // Test the invoker to ensure that it really injects into the right place.
1218                 MethodHandle invoker = IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1219                 MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
1220                 return (boolean)invoker.invoke(vamh, new Object[]{ invokerClass });
1221             } catch (Throwable ex) {
1222                 throw new InternalError(ex);
1223             }
1224         }
1225 
1226         private static final MethodHandle MH_checkCallerClass;
1227         static {
1228             final Class&lt;?&gt; THIS_CLASS = BindCaller.class;
1229             assert(checkCallerClass(THIS_CLASS));
1230             try {
1231                 MH_checkCallerClass = IMPL_LOOKUP
1232                     .findStatic(THIS_CLASS, &quot;checkCallerClass&quot;,
1233                                 MethodType.methodType(boolean.class, Class.class));
1234                 assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS));
1235             } catch (Throwable ex) {
1236                 throw new InternalError(ex);
1237             }
1238         }
1239 
1240         @CallerSensitive
1241         @ForceInline // to ensure Reflection.getCallerClass optimization
1242         private static boolean checkCallerClass(Class&lt;?&gt; expected) {
1243             // This method is called via MH_checkCallerClass and so it&#39;s correct to ask for the immediate caller here.
1244             Class&lt;?&gt; actual = Reflection.getCallerClass();
1245             if (actual != expected)
1246                 throw new InternalError(&quot;found &quot; + actual.getName() + &quot;, expected &quot; + expected.getName());
1247             return true;
1248         }
1249 
1250         private static final byte[] INJECTED_INVOKER_TEMPLATE = generateInvokerTemplate();
1251 
1252         /** Produces byte code for a class that is used as an injected invoker. */
1253         private static byte[] generateInvokerTemplate() {
1254             ClassWriter cw = new ClassWriter(0);
1255 
1256             // private static class InjectedInvoker {
1257             //     @Hidden
1258             //     static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
1259             //        return vamh.invokeExact(args);
1260             //     }
1261             // }
1262             cw.visit(52, ACC_PRIVATE | ACC_SUPER, &quot;InjectedInvoker&quot;, null, &quot;java/lang/Object&quot;, null);
1263 
1264             MethodVisitor mv = cw.visitMethod(ACC_STATIC, &quot;invoke_V&quot;,
1265                           &quot;(Ljava/lang/invoke/MethodHandle;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,
1266                           null, null);
1267 
1268             // Suppress invoker method in stack traces.
1269             AnnotationVisitor av0 = mv.visitAnnotation(InvokerBytecodeGenerator.HIDDEN_SIG, true);
1270             av0.visitEnd();
1271 
1272             mv.visitCode();
1273             mv.visitVarInsn(ALOAD, 0);
1274             mv.visitVarInsn(ALOAD, 1);
1275             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;, &quot;invokeExact&quot;,
1276                                &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1277             mv.visitInsn(ARETURN);
1278             mv.visitMaxs(2, 2);
1279             mv.visitEnd();
1280 
1281             cw.visitEnd();
1282             return cw.toByteArray();
1283         }
1284     }
1285 
1286     /** This subclass allows a wrapped method handle to be re-associated with an arbitrary member name. */
1287     private static final class WrappedMember extends DelegatingMethodHandle {
1288         private final MethodHandle target;
1289         private final MemberName member;
1290         private final Class&lt;?&gt; callerClass;
1291         private final boolean isInvokeSpecial;
1292 
1293         private WrappedMember(MethodHandle target, MethodType type,
1294                               MemberName member, boolean isInvokeSpecial,
1295                               Class&lt;?&gt; callerClass) {
1296             super(type, target);
1297             this.target = target;
1298             this.member = member;
1299             this.callerClass = callerClass;
1300             this.isInvokeSpecial = isInvokeSpecial;
1301         }
1302 
1303         @Override
1304         MemberName internalMemberName() {
1305             return member;
1306         }
1307         @Override
1308         Class&lt;?&gt; internalCallerClass() {
1309             return callerClass;
1310         }
1311         @Override
1312         boolean isInvokeSpecial() {
1313             return isInvokeSpecial;
1314         }
1315         @Override
1316         protected MethodHandle getTarget() {
1317             return target;
1318         }
1319         @Override
1320         public MethodHandle asTypeUncached(MethodType newType) {
1321             // This MH is an alias for target, except for the MemberName
1322             // Drop the MemberName if there is any conversion.
1323             return asTypeCache = target.asType(newType);
1324         }
1325     }
1326 
1327     static MethodHandle makeWrappedMember(MethodHandle target, MemberName member, boolean isInvokeSpecial) {
1328         if (member.equals(target.internalMemberName()) &amp;&amp; isInvokeSpecial == target.isInvokeSpecial())
1329             return target;
1330         return new WrappedMember(target, target.type(), member, isInvokeSpecial, null);
1331     }
1332 
1333     /** Intrinsic IDs */
1334     /*non-public*/
1335     enum Intrinsic {
1336         SELECT_ALTERNATIVE,
1337         GUARD_WITH_CATCH,
1338         TRY_FINALLY,
1339         LOOP,
1340         NEW_ARRAY,
1341         ARRAY_LOAD,
1342         ARRAY_STORE,
1343         ARRAY_LENGTH,
1344         IDENTITY,
1345         ZERO,
1346         NONE // no intrinsic associated
1347     }
1348 
1349     /** Mark arbitrary method handle as intrinsic.
1350      * InvokerBytecodeGenerator uses this info to produce more efficient bytecode shape. */
1351     static final class IntrinsicMethodHandle extends DelegatingMethodHandle {
1352         private final MethodHandle target;
1353         private final Intrinsic intrinsicName;
1354 
1355         IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName) {
1356             super(target.type(), target);
1357             this.target = target;
1358             this.intrinsicName = intrinsicName;
1359         }
1360 
1361         @Override
1362         protected MethodHandle getTarget() {
1363             return target;
1364         }
1365 
1366         @Override
1367         Intrinsic intrinsicName() {
1368             return intrinsicName;
1369         }
1370 
1371         @Override
1372         public MethodHandle asTypeUncached(MethodType newType) {
1373             // This MH is an alias for target, except for the intrinsic name
1374             // Drop the name if there is any conversion.
1375             return asTypeCache = target.asType(newType);
1376         }
1377 
1378         @Override
1379         String internalProperties() {
1380             return super.internalProperties() +
1381                     &quot;\n&amp; Intrinsic=&quot;+intrinsicName;
1382         }
1383 
1384         @Override
1385         public MethodHandle asCollector(Class&lt;?&gt; arrayType, int arrayLength) {
1386             if (intrinsicName == Intrinsic.IDENTITY) {
1387                 MethodType resultType = type().asCollectorType(arrayType, type().parameterCount() - 1, arrayLength);
1388                 MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
1389                 return newArray.asType(resultType);
1390             }
1391             return super.asCollector(arrayType, arrayLength);
1392         }
1393     }
1394 
1395     static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName) {
1396         if (intrinsicName == target.intrinsicName())
1397             return target;
1398         return new IntrinsicMethodHandle(target, intrinsicName);
1399     }
1400 
1401     static MethodHandle makeIntrinsic(MethodType type, LambdaForm form, Intrinsic intrinsicName) {
1402         return new IntrinsicMethodHandle(SimpleMethodHandle.make(type, form), intrinsicName);
1403     }
1404 
1405     /// Collection of multiple arguments.
1406 
1407     private static MethodHandle findCollector(String name, int nargs, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1408         MethodType type = MethodType.genericMethodType(nargs)
1409                 .changeReturnType(rtype)
1410                 .insertParameterTypes(0, ptypes);
1411         try {
1412             return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);
1413         } catch (ReflectiveOperationException ex) {
1414             return null;
1415         }
1416     }
1417 
1418     private static final Object[] NO_ARGS_ARRAY = {};
1419     private static Object[] makeArray(Object... args) { return args; }
1420     private static Object[] array() { return NO_ARGS_ARRAY; }
1421     private static Object[] array(Object a0)
1422                 { return makeArray(a0); }
1423     private static Object[] array(Object a0, Object a1)
1424                 { return makeArray(a0, a1); }
1425     private static Object[] array(Object a0, Object a1, Object a2)
1426                 { return makeArray(a0, a1, a2); }
1427     private static Object[] array(Object a0, Object a1, Object a2, Object a3)
1428                 { return makeArray(a0, a1, a2, a3); }
1429     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1430                                   Object a4)
1431                 { return makeArray(a0, a1, a2, a3, a4); }
1432     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1433                                   Object a4, Object a5)
1434                 { return makeArray(a0, a1, a2, a3, a4, a5); }
1435     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1436                                   Object a4, Object a5, Object a6)
1437                 { return makeArray(a0, a1, a2, a3, a4, a5, a6); }
1438     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1439                                   Object a4, Object a5, Object a6, Object a7)
1440                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }
1441     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1442                                   Object a4, Object a5, Object a6, Object a7,
1443                                   Object a8)
1444                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }
1445     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1446                                   Object a4, Object a5, Object a6, Object a7,
1447                                   Object a8, Object a9)
1448                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
1449 
1450     private static final int ARRAYS_COUNT = 11;
1451     private static final @Stable MethodHandle[] ARRAYS = new MethodHandle[MAX_ARITY + 1];
1452 
1453     // filling versions of the above:
1454     // using Integer len instead of int len and no varargs to avoid bootstrapping problems
1455     private static Object[] fillNewArray(Integer len, Object[] /*not ...*/ args) {
1456         Object[] a = new Object[len];
1457         fillWithArguments(a, 0, args);
1458         return a;
1459     }
1460     private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] /*not ...*/ args) {
1461         Object[] a = Arrays.copyOf(example, len);
1462         assert(a.getClass() != Object[].class);
1463         fillWithArguments(a, 0, args);
1464         return a;
1465     }
1466     private static void fillWithArguments(Object[] a, int pos, Object... args) {
1467         System.arraycopy(args, 0, a, pos, args.length);
1468     }
1469     // using Integer pos instead of int pos to avoid bootstrapping problems
1470     private static Object[] fillArray(Integer pos, Object[] a, Object a0)
1471                 { fillWithArguments(a, pos, a0); return a; }
1472     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)
1473                 { fillWithArguments(a, pos, a0, a1); return a; }
1474     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)
1475                 { fillWithArguments(a, pos, a0, a1, a2); return a; }
1476     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)
1477                 { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }
1478     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1479                                   Object a4)
1480                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }
1481     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1482                                   Object a4, Object a5)
1483                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }
1484     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1485                                   Object a4, Object a5, Object a6)
1486                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }
1487     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1488                                   Object a4, Object a5, Object a6, Object a7)
1489                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }
1490     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1491                                   Object a4, Object a5, Object a6, Object a7,
1492                                   Object a8)
1493                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }
1494     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1495                                   Object a4, Object a5, Object a6, Object a7,
1496                                   Object a8, Object a9)
1497                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
1498 
1499     private static final int FILL_ARRAYS_COUNT = 11; // current number of fillArray methods
1500     private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];
1501 
1502     private static MethodHandle getFillArray(int count) {
1503         assert (count &gt; 0 &amp;&amp; count &lt; FILL_ARRAYS_COUNT);
1504         MethodHandle mh = FILL_ARRAYS[count];
1505         if (mh != null) {
1506             return mh;
1507         }
1508         mh = findCollector(&quot;fillArray&quot;, count, Object[].class, Integer.class, Object[].class);
1509         FILL_ARRAYS[count] = mh;
1510         return mh;
1511     }
1512 
1513     private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {
1514         Object a = w.makeArray(boxes.length);
1515         w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);
1516         return a;
1517     }
1518 
1519     /** Return a method handle that takes the indicated number of Object
1520      *  arguments and returns an Object array of them, as if for varargs.
1521      */
1522     static MethodHandle varargsArray(int nargs) {
1523         MethodHandle mh = ARRAYS[nargs];
1524         if (mh != null) {
1525             return mh;
1526         }
1527         if (nargs &lt; ARRAYS_COUNT) {
1528             mh = findCollector(&quot;array&quot;, nargs, Object[].class);
1529         } else {
1530             mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),
1531                     getConstantHandle(MH_arrayIdentity), nargs);
1532         }
1533         assert(assertCorrectArity(mh, nargs));
1534         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1535         return ARRAYS[nargs] = mh;
1536     }
1537 
1538     private static boolean assertCorrectArity(MethodHandle mh, int arity) {
1539         assert(mh.type().parameterCount() == arity) : &quot;arity != &quot;+arity+&quot;: &quot;+mh;
1540         return true;
1541     }
1542 
1543     // Array identity function (used as getConstantHandle(MH_arrayIdentity)).
1544     static &lt;T&gt; T[] identity(T[] x) {
1545         return x;
1546     }
1547 
1548     private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {
1549         // Build up the result mh as a sequence of fills like this:
1550         //   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))
1551         // The various fill(_,10*I,___*[J]) are reusable.
1552         int leftLen = Math.min(nargs, LEFT_ARGS);  // absorb some arguments immediately
1553         int rightLen = nargs - leftLen;
1554         MethodHandle leftCollector = newArray.bindTo(nargs);
1555         leftCollector = leftCollector.asCollector(Object[].class, leftLen);
1556         MethodHandle mh = finisher;
1557         if (rightLen &gt; 0) {
1558             MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);
1559             if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1560                 mh = rightFiller;
1561             else
1562                 mh = MethodHandles.collectArguments(mh, 0, rightFiller);
1563         }
1564         if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1565             mh = leftCollector;
1566         else
1567             mh = MethodHandles.collectArguments(mh, 0, leftCollector);
1568         return mh;
1569     }
1570 
1571     private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;
1572     private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];
1573     /** fill_array_to_right(N).invoke(a, argL..arg[N-1])
1574      *  fills a[L]..a[N-1] with corresponding arguments,
1575      *  and then returns a.  The value L is a global constant (LEFT_ARGS).
1576      */
1577     private static MethodHandle fillToRight(int nargs) {
1578         MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];
1579         if (filler != null)  return filler;
1580         filler = buildFiller(nargs);
1581         assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));
1582         return FILL_ARRAY_TO_RIGHT[nargs] = filler;
1583     }
1584     private static MethodHandle buildFiller(int nargs) {
1585         if (nargs &lt;= LEFT_ARGS)
1586             return getConstantHandle(MH_arrayIdentity);  // no args to fill; return the array unchanged
1587         // we need room for both mh and a in mh.invoke(a, arg*[nargs])
1588         final int CHUNK = LEFT_ARGS;
1589         int rightLen = nargs % CHUNK;
1590         int midLen = nargs - rightLen;
1591         if (rightLen == 0) {
1592             midLen = nargs - (rightLen = CHUNK);
1593             if (FILL_ARRAY_TO_RIGHT[midLen] == null) {
1594                 // build some precursors from left to right
1595                 for (int j = LEFT_ARGS % CHUNK; j &lt; midLen; j += CHUNK)
1596                     if (j &gt; LEFT_ARGS)  fillToRight(j);
1597             }
1598         }
1599         if (midLen &lt; LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);
1600         assert(rightLen &gt; 0);
1601         MethodHandle midFill = fillToRight(midLen);  // recursive fill
1602         MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  // [midLen..nargs-1]
1603         assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);
1604         assert(rightFill.type().parameterCount() == 1 + rightLen);
1605 
1606         // Combine the two fills:
1607         //   right(mid(a, x10..x19), x20..x23)
1608         // The final product will look like this:
1609         //   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)
1610         if (midLen == LEFT_ARGS)
1611             return rightFill;
1612         else
1613             return MethodHandles.collectArguments(rightFill, 0, midFill);
1614     }
1615 
1616     static final int MAX_JVM_ARITY = 255;  // limit imposed by the JVM
1617 
1618     /** Return a method handle that takes the indicated number of
1619      *  typed arguments and returns an array of them.
1620      *  The type argument is the array type.
1621      */
1622     static MethodHandle varargsArray(Class&lt;?&gt; arrayType, int nargs) {
1623         Class&lt;?&gt; elemType = arrayType.getComponentType();
1624         if (elemType == null)  throw new IllegalArgumentException(&quot;not an array: &quot;+arrayType);
1625         // FIXME: Need more special casing and caching here.
1626         if (nargs &gt;= MAX_JVM_ARITY/2 - 1) {
1627             int slots = nargs;
1628             final int MAX_ARRAY_SLOTS = MAX_JVM_ARITY - 1;  // 1 for receiver MH
1629             if (slots &lt;= MAX_ARRAY_SLOTS &amp;&amp; elemType.isPrimitive())
1630                 slots *= Wrapper.forPrimitiveType(elemType).stackSlots();
1631             if (slots &gt; MAX_ARRAY_SLOTS)
1632                 throw new IllegalArgumentException(&quot;too many arguments: &quot;+arrayType.getSimpleName()+&quot;, length &quot;+nargs);
1633         }
1634         if (elemType == Object.class)
1635             return varargsArray(nargs);
1636         // other cases:  primitive arrays, subtypes of Object[]
1637         MethodHandle cache[] = Makers.TYPED_COLLECTORS.get(elemType);
1638         MethodHandle mh = nargs &lt; cache.length ? cache[nargs] : null;
1639         if (mh != null)  return mh;
1640         if (nargs == 0) {
1641             Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);
1642             mh = MethodHandles.constant(arrayType, example);
1643         } else if (elemType.isPrimitive()) {
1644             MethodHandle builder = getConstantHandle(MH_fillNewArray);
1645             MethodHandle producer = buildArrayProducer(arrayType);
1646             mh = buildVarargsArray(builder, producer, nargs);
1647         } else {
1648             Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
1649             Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
1650             MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
1651             MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
1652             mh = buildVarargsArray(builder, producer, nargs);
1653         }
1654         mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
1655         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1656         assert(assertCorrectArity(mh, nargs));
1657         if (nargs &lt; cache.length)
1658             cache[nargs] = mh;
1659         return mh;
1660     }
1661 
1662     private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
1663         Class&lt;?&gt; elemType = arrayType.getComponentType();
1664         assert(elemType.isPrimitive());
1665         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
1666     }
1667 
1668     /*non-public*/ static void assertSame(Object mh1, Object mh2) {
1669         if (mh1 != mh2) {
1670             String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
1671                     mh1, ((MethodHandle)mh1).form,
1672                     mh2, ((MethodHandle)mh2).form);
1673             throw newInternalError(msg);
1674         }
1675     }
1676 
1677     // Local constant functions:
1678 
1679     /* non-public */
1680     static final byte NF_checkSpreadArgument = 0,
1681             NF_guardWithCatch = 1,
1682             NF_throwException = 2,
1683             NF_tryFinally = 3,
1684             NF_loop = 4,
1685             NF_profileBoolean = 5,
1686             NF_LIMIT = 6;
1687 
1688     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
1689 
1690     static NamedFunction getFunction(byte func) {
1691         NamedFunction nf = NFS[func];
1692         if (nf != null) {
1693             return nf;
1694         }
1695         return NFS[func] = createFunction(func);
1696     }
1697 
1698     private static NamedFunction createFunction(byte func) {
1699         try {
1700             switch (func) {
1701                 case NF_checkSpreadArgument:
1702                     return new NamedFunction(MethodHandleImpl.class
1703                             .getDeclaredMethod(&quot;checkSpreadArgument&quot;, Object.class, int.class));
1704                 case NF_guardWithCatch:
1705                     return new NamedFunction(MethodHandleImpl.class
1706                             .getDeclaredMethod(&quot;guardWithCatch&quot;, MethodHandle.class, Class.class,
1707                                     MethodHandle.class, Object[].class));
1708                 case NF_tryFinally:
1709                     return new NamedFunction(MethodHandleImpl.class
1710                             .getDeclaredMethod(&quot;tryFinally&quot;, MethodHandle.class, MethodHandle.class, Object[].class));
1711                 case NF_loop:
1712                     return new NamedFunction(MethodHandleImpl.class
1713                             .getDeclaredMethod(&quot;loop&quot;, BasicType[].class, LoopClauses.class, Object[].class));
1714                 case NF_throwException:
1715                     return new NamedFunction(MethodHandleImpl.class
1716                             .getDeclaredMethod(&quot;throwException&quot;, Throwable.class));
1717                 case NF_profileBoolean:
1718                     return new NamedFunction(MethodHandleImpl.class
1719                             .getDeclaredMethod(&quot;profileBoolean&quot;, boolean.class, int[].class));
1720                 default:
1721                     throw new InternalError(&quot;Undefined function: &quot; + func);
1722             }
1723         } catch (ReflectiveOperationException ex) {
1724             throw newInternalError(ex);
1725         }
1726     }
1727 
1728     static {
1729         SharedSecrets.setJavaLangInvokeAccess(new JavaLangInvokeAccess() {
1730             @Override
1731             public Object newMemberName() {
1732                 return new MemberName();
1733             }
1734 
1735             @Override
1736             public String getName(Object mname) {
1737                 MemberName memberName = (MemberName)mname;
1738                 return memberName.getName();
1739             }
1740             @Override
1741             public Class&lt;?&gt; getDeclaringClass(Object mname) {
1742                 MemberName memberName = (MemberName)mname;
1743                 return memberName.getDeclaringClass();
1744             }
1745 
1746             @Override
1747             public MethodType getMethodType(Object mname) {
1748                 MemberName memberName = (MemberName)mname;
1749                 return memberName.getMethodType();
1750             }
1751 
1752             @Override
1753             public String getMethodDescriptor(Object mname) {
1754                 MemberName memberName = (MemberName)mname;
1755                 return memberName.getMethodDescriptor();
1756             }
1757 
1758             @Override
1759             public boolean isNative(Object mname) {
1760                 MemberName memberName = (MemberName)mname;
1761                 return memberName.isNative();
1762             }
1763 
1764             @Override
1765             public byte[] generateDirectMethodHandleHolderClassBytes(
1766                     String className, MethodType[] methodTypes, int[] types) {
1767                 return GenerateJLIClassesHelper
1768                         .generateDirectMethodHandleHolderClassBytes(
1769                                 className, methodTypes, types);
1770             }
1771 
1772             @Override
1773             public byte[] generateDelegatingMethodHandleHolderClassBytes(
1774                     String className, MethodType[] methodTypes) {
1775                 return GenerateJLIClassesHelper
1776                         .generateDelegatingMethodHandleHolderClassBytes(
1777                                 className, methodTypes);
1778             }
1779 
1780             @Override
1781             public Map.Entry&lt;String, byte[]&gt; generateConcreteBMHClassBytes(
1782                     final String types) {
1783                 return GenerateJLIClassesHelper
1784                         .generateConcreteBMHClassBytes(types);
1785             }
1786 
1787             @Override
1788             public byte[] generateBasicFormsClassBytes(final String className) {
1789                 return GenerateJLIClassesHelper
1790                         .generateBasicFormsClassBytes(className);
1791             }
1792 
1793             @Override
1794             public byte[] generateInvokersHolderClassBytes(final String className,
1795                     MethodType[] invokerMethodTypes,
1796                     MethodType[] callSiteMethodTypes) {
1797                 return GenerateJLIClassesHelper
1798                         .generateInvokersHolderClassBytes(className,
1799                                 invokerMethodTypes, callSiteMethodTypes);
1800             }
1801 
1802         });
1803     }
1804 
1805     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
1806     private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
1807         if (returnType.isPrimitive()) {
1808             if (returnType == void.class) {
1809                 return ValueConversions.ignore();
1810             } else {
1811                 Wrapper w = Wrapper.forPrimitiveType(returnType);
1812                 return ValueConversions.unboxExact(w);
1813             }
1814         } else {
1815             return MethodHandles.identity(Object.class);
1816         }
1817     }
1818 
1819     /**
1820      * Assembles a loop method handle from the given handles and type information.
1821      *
1822      * @param tloop the return type of the loop.
1823      * @param targs types of the arguments to be passed to the loop.
1824      * @param init sanitized array of initializers for loop-local variables.
1825      * @param step sanitited array of loop bodies.
1826      * @param pred sanitized array of predicates.
1827      * @param fini sanitized array of loop finalizers.
1828      *
1829      * @return a handle that, when invoked, will execute the loop.
1830      */
1831     static MethodHandle makeLoop(Class&lt;?&gt; tloop, List&lt;Class&lt;?&gt;&gt; targs, List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step,
1832                                  List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini) {
1833         MethodType type = MethodType.methodType(tloop, targs);
1834         BasicType[] initClauseTypes =
1835                 init.stream().map(h -&gt; h.type().returnType()).map(BasicType::basicType).toArray(BasicType[]::new);
1836         LambdaForm form = makeLoopForm(type.basicType(), initClauseTypes);
1837 
1838         // Prepare auxiliary method handles used during LambdaForm interpretation.
1839         // Box arguments and wrap them into Object[]: ValueConversions.array().
1840         MethodType varargsType = type.changeReturnType(Object[].class);
1841         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1842         MethodHandle unboxResult = unboxResultHandle(tloop);
1843 
1844         LoopClauses clauseData =
1845                 new LoopClauses(new MethodHandle[][]{toArray(init), toArray(step), toArray(pred), toArray(fini)});
1846         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1847         BoundMethodHandle mh;
1848         try {
1849             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) clauseData,
1850                     (Object) collectArgs, (Object) unboxResult);
1851         } catch (Throwable ex) {
1852             throw uncaughtException(ex);
1853         }
1854         assert(mh.type() == type);
1855         return mh;
1856     }
1857 
1858     private static MethodHandle[] toArray(List&lt;MethodHandle&gt; l) {
1859         return l.toArray(new MethodHandle[0]);
1860     }
1861 
1862     /**
1863      * Loops introduce some complexity as they can have additional local state. Hence, LambdaForms for loops are
1864      * generated from a template. The LambdaForm template shape for the loop combinator is as follows (assuming one
1865      * reference parameter passed in {@code a1}, and a reference return type, with the return value represented by
1866      * {@code t12}):
1867      * &lt;blockquote&gt;&lt;pre&gt;{@code
1868      *  loop=Lambda(a0:L,a1:L)=&gt;{
1869      *    t2:L=BoundMethodHandle$Species_L3.argL0(a0:L);    // LoopClauses holding init, step, pred, fini handles
1870      *    t3:L=BoundMethodHandle$Species_L3.argL1(a0:L);    // helper handle to box the arguments into an Object[]
1871      *    t4:L=BoundMethodHandle$Species_L3.argL2(a0:L);    // helper handle to unbox the result
1872      *    t5:L=MethodHandle.invokeBasic(t3:L,a1:L);         // box the arguments into an Object[]
1873      *    t6:L=MethodHandleImpl.loop(null,t2:L,t3:L);       // call the loop executor
1874      *    t7:L=MethodHandle.invokeBasic(t4:L,t6:L);t7:L}    // unbox the result; return the result
1875      * }&lt;/pre&gt;&lt;/blockquote&gt;
1876      * &lt;p&gt;
1877      * {@code argL0} is a LoopClauses instance holding, in a 2-dimensional array, the init, step, pred, and fini method
1878      * handles. {@code argL1} and {@code argL2} are auxiliary method handles: {@code argL1} boxes arguments and wraps
1879      * them into {@code Object[]} ({@code ValueConversions.array()}), and {@code argL2} unboxes the result if necessary
1880      * ({@code ValueConversions.unbox()}).
1881      * &lt;p&gt;
1882      * Having {@code t3} and {@code t4} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
1883      * forms among loop combinators with the same basic type.
1884      * &lt;p&gt;
1885      * The above template is instantiated by using the {@link LambdaFormEditor} to replace the {@code null} argument to
1886      * the {@code loop} invocation with the {@code BasicType} array describing the loop clause types. This argument is
1887      * ignored in the loop invoker, but will be extracted and used in {@linkplain InvokerBytecodeGenerator#emitLoop(int)
1888      * bytecode generation}.
1889      */
1890     private static LambdaForm makeLoopForm(MethodType basicType, BasicType[] localVarTypes) {
1891         MethodType lambdaType = basicType.invokerType();
1892 
1893         final int THIS_MH = 0;  // the BMH_LLL
1894         final int ARG_BASE = 1; // start of incoming arguments
1895         final int ARG_LIMIT = ARG_BASE + basicType.parameterCount();
1896 
1897         int nameCursor = ARG_LIMIT;
1898         final int GET_CLAUSE_DATA = nameCursor++;
1899         final int GET_COLLECT_ARGS = nameCursor++;
1900         final int GET_UNBOX_RESULT = nameCursor++;
1901         final int BOXED_ARGS = nameCursor++;
1902         final int LOOP = nameCursor++;
1903         final int UNBOX_RESULT = nameCursor++;
1904 
1905         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_LOOP);
1906         if (lform == null) {
1907             Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
1908 
1909             BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1910             names[THIS_MH] = names[THIS_MH].withConstraint(data);
1911             names[GET_CLAUSE_DATA] = new Name(data.getterFunction(0), names[THIS_MH]);
1912             names[GET_COLLECT_ARGS] = new Name(data.getterFunction(1), names[THIS_MH]);
1913             names[GET_UNBOX_RESULT] = new Name(data.getterFunction(2), names[THIS_MH]);
1914 
1915             // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
1916             MethodType collectArgsType = basicType.changeReturnType(Object.class);
1917             MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1918             Object[] args = new Object[invokeBasic.type().parameterCount()];
1919             args[0] = names[GET_COLLECT_ARGS];
1920             System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);
1921             names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);
1922 
1923             // t_{i+1}:L=MethodHandleImpl.loop(localTypes:L,clauses:L,t_{i}:L);
1924             Object[] lArgs =
1925                     new Object[]{null, // placeholder for BasicType[] localTypes - will be added by LambdaFormEditor
1926                             names[GET_CLAUSE_DATA], names[BOXED_ARGS]};
1927             names[LOOP] = new Name(getFunction(NF_loop), lArgs);
1928 
1929             // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1930             MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1931             Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[LOOP]};
1932             names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1933 
1934             lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_LOOP,
1935                     new LambdaForm(lambdaType.parameterCount(), names, Kind.LOOP));
1936         }
1937 
1938         // BOXED_ARGS is the index into the names array where the loop idiom starts
1939         return lform.editor().noteLoopLocalTypesForm(BOXED_ARGS, localVarTypes);
1940     }
1941 
1942     static class LoopClauses {
1943         @Stable final MethodHandle[][] clauses;
1944         LoopClauses(MethodHandle[][] clauses) {
1945             assert clauses.length == 4;
1946             this.clauses = clauses;
1947         }
1948         @Override
1949         public String toString() {
1950             StringBuffer sb = new StringBuffer(&quot;LoopClauses -- &quot;);
1951             for (int i = 0; i &lt; 4; ++i) {
1952                 if (i &gt; 0) {
1953                     sb.append(&quot;       &quot;);
1954                 }
1955                 sb.append(&#39;&lt;&#39;).append(i).append(&quot;&gt;: &quot;);
1956                 MethodHandle[] hs = clauses[i];
1957                 for (int j = 0; j &lt; hs.length; ++j) {
1958                     if (j &gt; 0) {
1959                         sb.append(&quot;          &quot;);
1960                     }
1961                     sb.append(&#39;*&#39;).append(j).append(&quot;: &quot;).append(hs[j]).append(&#39;\n&#39;);
1962                 }
1963             }
1964             sb.append(&quot; --\n&quot;);
1965             return sb.toString();
1966         }
1967     }
1968 
1969     /**
1970      * Intrinsified during LambdaForm compilation
1971      * (see {@link InvokerBytecodeGenerator#emitLoop(int)}).
1972      */
1973     @Hidden
1974     static Object loop(BasicType[] localTypes, LoopClauses clauseData, Object... av) throws Throwable {
1975         final MethodHandle[] init = clauseData.clauses[0];
1976         final MethodHandle[] step = clauseData.clauses[1];
1977         final MethodHandle[] pred = clauseData.clauses[2];
1978         final MethodHandle[] fini = clauseData.clauses[3];
1979         int varSize = (int) Stream.of(init).filter(h -&gt; h.type().returnType() != void.class).count();
1980         int nArgs = init[0].type().parameterCount();
1981         Object[] varsAndArgs = new Object[varSize + nArgs];
1982         for (int i = 0, v = 0; i &lt; init.length; ++i) {
1983             MethodHandle ih = init[i];
1984             if (ih.type().returnType() == void.class) {
1985                 ih.invokeWithArguments(av);
1986             } else {
1987                 varsAndArgs[v++] = ih.invokeWithArguments(av);
1988             }
1989         }
1990         System.arraycopy(av, 0, varsAndArgs, varSize, nArgs);
1991         final int nSteps = step.length;
1992         for (; ; ) {
1993             for (int i = 0, v = 0; i &lt; nSteps; ++i) {
1994                 MethodHandle p = pred[i];
1995                 MethodHandle s = step[i];
1996                 MethodHandle f = fini[i];
1997                 if (s.type().returnType() == void.class) {
1998                     s.invokeWithArguments(varsAndArgs);
1999                 } else {
2000                     varsAndArgs[v++] = s.invokeWithArguments(varsAndArgs);
2001                 }
2002                 if (!(boolean) p.invokeWithArguments(varsAndArgs)) {
2003                     return f.invokeWithArguments(varsAndArgs);
2004                 }
2005             }
2006         }
2007     }
2008 
2009     /**
2010      * This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2011      * MethodHandle) counting loops}.
2012      *
2013      * @param limit the upper bound of the parameter, statically bound at loop creation time.
2014      * @param counter the counter parameter, passed in during loop execution.
2015      *
2016      * @return whether the counter has reached the limit.
2017      */
2018     static boolean countedLoopPredicate(int limit, int counter) {
2019         return counter &lt; limit;
2020     }
2021 
2022     /**
2023      * This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2024      * MethodHandle) counting loops} to increment the counter.
2025      *
2026      * @param limit the upper bound of the loop counter (ignored).
2027      * @param counter the loop counter.
2028      *
2029      * @return the loop counter incremented by 1.
2030      */
2031     static int countedLoopStep(int limit, int counter) {
2032         return counter + 1;
2033     }
2034 
2035     /**
2036      * This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2037      *
2038      * @param it the {@link Iterable} over which the loop iterates.
2039      *
2040      * @return an {@link Iterator} over the argument&#39;s elements.
2041      */
2042     static Iterator&lt;?&gt; initIterator(Iterable&lt;?&gt; it) {
2043         return it.iterator();
2044     }
2045 
2046     /**
2047      * This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2048      *
2049      * @param it the iterator to be checked.
2050      *
2051      * @return {@code true} iff there are more elements to iterate over.
2052      */
2053     static boolean iteratePredicate(Iterator&lt;?&gt; it) {
2054         return it.hasNext();
2055     }
2056 
2057     /**
2058      * This method is bound as the step for retrieving the current value from the iterator in {@linkplain
2059      * MethodHandles#iteratedLoop iterating loops}.
2060      *
2061      * @param it the iterator.
2062      *
2063      * @return the next element from the iterator.
2064      */
2065     static Object iterateNext(Iterator&lt;?&gt; it) {
2066         return it.next();
2067     }
2068 
2069     /**
2070      * Makes a {@code try-finally} handle that conforms to the type constraints.
2071      *
2072      * @param target the target to execute in a {@code try-finally} block.
2073      * @param cleanup the cleanup to execute in the {@code finally} block.
2074      * @param rtype the result type of the entire construct.
2075      * @param argTypes the types of the arguments.
2076      *
2077      * @return a handle on the constructed {@code try-finally} block.
2078      */
2079     static MethodHandle makeTryFinally(MethodHandle target, MethodHandle cleanup, Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; argTypes) {
2080         MethodType type = MethodType.methodType(rtype, argTypes);
2081         LambdaForm form = makeTryFinallyForm(type.basicType());
2082 
2083         // Prepare auxiliary method handles used during LambdaForm interpretation.
2084         // Box arguments and wrap them into Object[]: ValueConversions.array().
2085         MethodType varargsType = type.changeReturnType(Object[].class);
2086         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
2087         MethodHandle unboxResult = unboxResultHandle(rtype);
2088 
2089         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2090         BoundMethodHandle mh;
2091         try {
2092             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) cleanup,
2093                     (Object) collectArgs, (Object) unboxResult);
2094         } catch (Throwable ex) {
2095             throw uncaughtException(ex);
2096         }
2097         assert(mh.type() == type);
2098         return mh;
2099     }
2100 
2101     /**
2102      * The LambdaForm shape for the tryFinally combinator is as follows (assuming one reference parameter passed in
2103      * {@code a1}, and a reference return type, with the return value represented by {@code t8}):
2104      * &lt;blockquote&gt;&lt;pre&gt;{@code
2105      *  tryFinally=Lambda(a0:L,a1:L)=&gt;{
2106      *    t2:L=BoundMethodHandle$Species_LLLL.argL0(a0:L);  // target method handle
2107      *    t3:L=BoundMethodHandle$Species_LLLL.argL1(a0:L);  // cleanup method handle
2108      *    t4:L=BoundMethodHandle$Species_LLLL.argL2(a0:L);  // helper handle to box the arguments into an Object[]
2109      *    t5:L=BoundMethodHandle$Species_LLLL.argL3(a0:L);  // helper handle to unbox the result
2110      *    t6:L=MethodHandle.invokeBasic(t4:L,a1:L);         // box the arguments into an Object[]
2111      *    t7:L=MethodHandleImpl.tryFinally(t2:L,t3:L,t6:L); // call the tryFinally executor
2112      *    t8:L=MethodHandle.invokeBasic(t5:L,t7:L);t8:L}    // unbox the result; return the result
2113      * }&lt;/pre&gt;&lt;/blockquote&gt;
2114      * &lt;p&gt;
2115      * {@code argL0} and {@code argL1} are the target and cleanup method handles.
2116      * {@code argL2} and {@code argL3} are auxiliary method handles: {@code argL2} boxes arguments and wraps them into
2117      * {@code Object[]} ({@code ValueConversions.array()}), and {@code argL3} unboxes the result if necessary
2118      * ({@code ValueConversions.unbox()}).
2119      * &lt;p&gt;
2120      * Having {@code t4} and {@code t5} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
2121      * forms among tryFinally combinators with the same basic type.
2122      */
2123     private static LambdaForm makeTryFinallyForm(MethodType basicType) {
2124         MethodType lambdaType = basicType.invokerType();
2125 
2126         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_TF);
2127         if (lform != null) {
2128             return lform;
2129         }
2130         final int THIS_MH      = 0;  // the BMH_LLLL
2131         final int ARG_BASE     = 1;  // start of incoming arguments
2132         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
2133 
2134         int nameCursor = ARG_LIMIT;
2135         final int GET_TARGET       = nameCursor++;
2136         final int GET_CLEANUP      = nameCursor++;
2137         final int GET_COLLECT_ARGS = nameCursor++;
2138         final int GET_UNBOX_RESULT = nameCursor++;
2139         final int BOXED_ARGS       = nameCursor++;
2140         final int TRY_FINALLY      = nameCursor++;
2141         final int UNBOX_RESULT     = nameCursor++;
2142 
2143         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
2144 
2145         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2146         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
2147         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
2148         names[GET_CLEANUP]      = new Name(data.getterFunction(1), names[THIS_MH]);
2149         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(2), names[THIS_MH]);
2150         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(3), names[THIS_MH]);
2151 
2152         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
2153         MethodType collectArgsType = basicType.changeReturnType(Object.class);
2154         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
2155         Object[] args = new Object[invokeBasic.type().parameterCount()];
2156         args[0] = names[GET_COLLECT_ARGS];
2157         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
2158         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);
2159 
2160         // t_{i+1}:L=MethodHandleImpl.tryFinally(target:L,exType:L,catcher:L,t_{i}:L);
2161         Object[] tfArgs = new Object[] {names[GET_TARGET], names[GET_CLEANUP], names[BOXED_ARGS]};
2162         names[TRY_FINALLY] = new Name(getFunction(NF_tryFinally), tfArgs);
2163 
2164         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
2165         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
2166         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_FINALLY]};
2167         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
2168 
2169         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TRY_FINALLY);
2170 
2171         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_TF, lform);
2172     }
2173 
2174     /**
2175      * Intrinsified during LambdaForm compilation
2176      * (see {@link InvokerBytecodeGenerator#emitTryFinally emitTryFinally}).
2177      */
2178     @Hidden
2179     static Object tryFinally(MethodHandle target, MethodHandle cleanup, Object... av) throws Throwable {
2180         Throwable t = null;
2181         Object r = null;
2182         try {
2183             r = target.invokeWithArguments(av);
2184         } catch (Throwable thrown) {
2185             t = thrown;
2186             throw t;
2187         } finally {
2188             Object[] args = target.type().returnType() == void.class ? prepend(av, t) : prepend(av, t, r);
2189             r = cleanup.invokeWithArguments(args);
2190         }
2191         return r;
2192     }
2193 
2194     // Indexes into constant method handles:
2195     static final int
2196             MH_cast                  =  0,
2197             MH_selectAlternative     =  1,
2198             MH_copyAsPrimitiveArray  =  2,
2199             MH_fillNewTypedArray     =  3,
2200             MH_fillNewArray          =  4,
2201             MH_arrayIdentity         =  5,
2202             MH_countedLoopPred       =  6,
2203             MH_countedLoopStep       =  7,
2204             MH_initIterator          =  8,
2205             MH_iteratePred           =  9,
2206             MH_iterateNext           = 10,
2207             MH_Array_newInstance     = 11,
2208             MH_LIMIT                 = 12;
2209 
2210     static MethodHandle getConstantHandle(int idx) {
2211         MethodHandle handle = HANDLES[idx];
2212         if (handle != null) {
2213             return handle;
2214         }
2215         return setCachedHandle(idx, makeConstantHandle(idx));
2216     }
2217 
2218     private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method) {
2219         // Simulate a CAS, to avoid racy duplication of results.
2220         MethodHandle prev = HANDLES[idx];
2221         if (prev != null) {
2222             return prev;
2223         }
2224         HANDLES[idx] = method;
2225         return method;
2226     }
2227 
2228     // Local constant method handles:
2229     private static final @Stable MethodHandle[] HANDLES = new MethodHandle[MH_LIMIT];
2230 
2231     private static MethodHandle makeConstantHandle(int idx) {
2232         try {
2233             switch (idx) {
2234                 case MH_cast:
2235                     return IMPL_LOOKUP.findVirtual(Class.class, &quot;cast&quot;,
2236                             MethodType.methodType(Object.class, Object.class));
2237                 case MH_copyAsPrimitiveArray:
2238                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;copyAsPrimitiveArray&quot;,
2239                             MethodType.methodType(Object.class, Wrapper.class, Object[].class));
2240                 case MH_arrayIdentity:
2241                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;identity&quot;,
2242                             MethodType.methodType(Object[].class, Object[].class));
2243                 case MH_fillNewArray:
2244                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewArray&quot;,
2245                             MethodType.methodType(Object[].class, Integer.class, Object[].class));
2246                 case MH_fillNewTypedArray:
2247                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewTypedArray&quot;,
2248                             MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));
2249                 case MH_selectAlternative:
2250                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;selectAlternative&quot;,
2251                             MethodType.methodType(MethodHandle.class, boolean.class, MethodHandle.class, MethodHandle.class));
2252                 case MH_countedLoopPred:
2253                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopPredicate&quot;,
2254                             MethodType.methodType(boolean.class, int.class, int.class));
2255                 case MH_countedLoopStep:
2256                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopStep&quot;,
2257                             MethodType.methodType(int.class, int.class, int.class));
2258                 case MH_initIterator:
2259                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;initIterator&quot;,
2260                             MethodType.methodType(Iterator.class, Iterable.class));
2261                 case MH_iteratePred:
2262                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iteratePredicate&quot;,
2263                             MethodType.methodType(boolean.class, Iterator.class));
2264                 case MH_iterateNext:
2265                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iterateNext&quot;,
2266                             MethodType.methodType(Object.class, Iterator.class));
2267                 case MH_Array_newInstance:
2268                     return IMPL_LOOKUP.findStatic(Array.class, &quot;newInstance&quot;,
2269                             MethodType.methodType(Object.class, Class.class, int.class));
2270             }
2271         } catch (ReflectiveOperationException ex) {
2272             throw newInternalError(ex);
2273         }
2274         throw newInternalError(&quot;Unknown function index: &quot; + idx);
2275     }
2276 }
    </pre>
  </body>
</html>
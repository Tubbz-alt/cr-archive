<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/ServiceLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceConfigurationError.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Set.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ServiceLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  28 import java.io.BufferedReader;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InputStreamReader;
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.InvocationTargetException;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.net.URL;
  37 import java.net.URLConnection;
  38 import java.security.AccessControlContext;
  39 import java.security.AccessController;
  40 import java.security.PrivilegedAction;
  41 import java.security.PrivilegedActionException;
  42 import java.security.PrivilegedExceptionAction;
  43 import java.util.function.Consumer;
  44 import java.util.function.Supplier;
  45 import java.util.stream.Stream;
  46 import java.util.stream.StreamSupport;
  47 


  48 import jdk.internal.loader.BootLoader;
  49 import jdk.internal.loader.ClassLoaders;
  50 import jdk.internal.access.JavaLangAccess;
  51 import jdk.internal.access.SharedSecrets;
  52 import jdk.internal.misc.VM;
  53 import jdk.internal.module.ServicesCatalog;
  54 import jdk.internal.module.ServicesCatalog.ServiceProvider;
  55 import jdk.internal.reflect.CallerSensitive;
  56 import jdk.internal.reflect.Reflection;
  57 
<span class="line-removed">  58 </span>
  59 /**
  60  * A facility to load implementations of a service.
  61  *
  62  * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known interface or class for which zero, one,
  63  * or many service providers exist. A &lt;i&gt;service provider&lt;/i&gt; (or just
  64  * &lt;i&gt;provider&lt;/i&gt;) is a class that implements or subclasses the well-known
  65  * interface or class. A {@code ServiceLoader} is an object that locates and
  66  * loads service providers deployed in the run time environment at a time of an
  67  * application&#39;s choosing. Application code refers only to the service, not to
  68  * service providers, and is assumed to be capable of choosing between multiple
  69  * service providers (based on the functionality they expose through the service),
  70  * and handling the possibility that no service providers are located.
  71  *
<span class="line-modified">  72  * &lt;h3&gt; Obtaining a service loader &lt;/h3&gt;</span>
  73  *
  74  * &lt;p&gt; An application obtains a service loader for a given service by invoking
  75  * one of the static {@code load} methods of {@code ServiceLoader}. If the
  76  * application is a module, then its module declaration must have a &lt;i&gt;uses&lt;/i&gt;
  77  * directive that specifies the service; this helps to locate providers and ensure
  78  * they will execute reliably. In addition, if the application module does not
  79  * contain the service, then its module declaration must have a &lt;i&gt;requires&lt;/i&gt;
  80  * directive that specifies the module which exports the service. It is strongly
  81  * recommended that the application module does &lt;b&gt;not&lt;/b&gt; require modules which
  82  * contain providers of the service.
  83  *
  84  * &lt;p&gt; A service loader can be used to locate and instantiate providers of the
  85  * service by means of the {@link #iterator() iterator} method. {@code ServiceLoader}
  86  * also defines the {@link #stream() stream} method to obtain a stream of providers
  87  * that can be inspected and filtered without instantiating them.
  88  *
  89  * &lt;p&gt; As an example, suppose the service is {@code com.example.CodecFactory}, an
  90  * interface that defines methods for producing encoders and decoders:
  91  *
  92  * &lt;pre&gt;{@code
</pre>
<hr />
<pre>
 124  * instantiating it, in order to determine if an instance of that service
 125  * provider would be useful. For example, a service provider for {@code
 126  * CodecFactory} that is capable of producing a &quot;PNG&quot; encoder may be annotated
 127  * with {@code @PNG}. The following code uses service loader&#39;s {@code stream}
 128  * method to yield instances of {@code Provider&lt;CodecFactory&gt;} in contrast to
 129  * how the iterator yields instances of {@code CodecFactory}:
 130  * &lt;pre&gt;{@code
 131  *     ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
 132  *     Set&lt;CodecFactory&gt; pngFactories = loader
 133  *            .stream()                                              // Note a below
 134  *            .filter(p -&gt; p.type().isAnnotationPresent(PNG.class))  // Note b
 135  *            .map(Provider::get)                                    // Note c
 136  *            .collect(Collectors.toSet());
 137  * }&lt;/pre&gt;
 138  * &lt;ol type=&quot;a&quot;&gt;
 139  *   &lt;li&gt; A stream of {@code Provider&lt;CodecFactory&gt;} objects &lt;/li&gt;
 140  *   &lt;li&gt; {@code p.type()} yields a {@code Class&lt;CodecFactory&gt;} &lt;/li&gt;
 141  *   &lt;li&gt; {@code get()} yields an instance of {@code CodecFactory} &lt;/li&gt;
 142  * &lt;/ol&gt;
 143  *
<span class="line-modified"> 144  * &lt;h3&gt; Designing services &lt;/h3&gt;</span>
 145  *
 146  * &lt;p&gt; A service is a single type, usually an interface or abstract class. A
 147  * concrete class can be used, but this is not recommended. The type may have
 148  * any accessibility. The methods of a service are highly domain-specific, so
 149  * this API specification cannot give concrete advice about their form or
 150  * function. However, there are two general guidelines:
 151  * &lt;ol&gt;
 152  *   &lt;li&gt;&lt;p&gt; A service should declare as many methods as needed to allow service
 153  *   providers to communicate their domain-specific properties and other
 154  *   quality-of-implementation factors. An application which obtains a service
 155  *   loader for the service may then invoke these methods on each instance of
 156  *   a service provider, in order to choose the best provider for the
 157  *   application. &lt;/p&gt;&lt;/li&gt;
 158  *   &lt;li&gt;&lt;p&gt; A service should express whether its service providers are intended
 159  *   to be direct implementations of the service or to be an indirection
 160  *   mechanism such as a &quot;proxy&quot; or a &quot;factory&quot;. Service providers tend to be
 161  *   indirection mechanisms when domain-specific objects are relatively
 162  *   expensive to instantiate; in this case, the service should be designed
 163  *   so that service providers are abstractions which create the &quot;real&quot;
 164  *   implementation on demand. For example, the {@code CodecFactory} service
 165  *   expresses through its name that its service providers are factories
 166  *   for codecs, rather than codecs themselves, because it may be expensive
 167  *   or complicated to produce certain codecs. &lt;/p&gt;&lt;/li&gt;
 168  * &lt;/ol&gt;
 169  *
<span class="line-modified"> 170  * &lt;h3&gt; &lt;a id=&quot;developing-service-providers&quot;&gt;Developing service providers&lt;/a&gt; &lt;/h3&gt;</span>
 171  *
 172  * &lt;p&gt; A service provider is a single type, usually a concrete class. An
 173  * interface or abstract class is permitted because it may declare a static
 174  * provider method, discussed later. The type must be public and must not be
 175  * an inner class.
 176  *
 177  * &lt;p&gt; A service provider and its supporting code may be developed in a module,
 178  * which is then deployed on the application module path or in a modular
 179  * image. Alternatively, a service provider and its supporting code may be
 180  * packaged as a JAR file and deployed on the application class path. The
 181  * advantage of developing a service provider in a module is that the provider
 182  * can be fully encapsulated to hide all details of its implementation.
 183  *
 184  * &lt;p&gt; An application that obtains a service loader for a given service is
 185  * indifferent to whether providers of the service are deployed in modules or
 186  * packaged as JAR files. The application instantiates service providers via
 187  * the service loader&#39;s iterator, or via {@link Provider Provider} objects in
 188  * the service loader&#39;s stream, without knowledge of the service providers&#39;
 189  * locations.
 190  *
<span class="line-modified"> 191  * &lt;h3&gt; Deploying service providers as modules &lt;/h3&gt;</span>
 192  *
 193  * &lt;p&gt; A service provider that is developed in a module must be specified in a
 194  * &lt;i&gt;provides&lt;/i&gt; directive in the module declaration. The provides directive
 195  * specifies both the service and the service provider; this helps to locate the
 196  * provider when another module, with a &lt;i&gt;uses&lt;/i&gt; directive for the service,
 197  * obtains a service loader for the service. It is strongly recommended that the
 198  * module does not export the package containing the service provider. There is
 199  * no support for a module specifying, in a &lt;i&gt;provides&lt;/i&gt; directive, a service
 200  * provider in another module.
 201 
 202  * &lt;p&gt; A service provider that is developed in a module has no control over when
 203  * it is instantiated, since that occurs at the behest of the application, but it
 204  * does have control over how it is instantiated:
 205  *
 206  * &lt;ul&gt;
 207  *
 208  *   &lt;li&gt; If the service provider declares a provider method, then the service
 209  *   loader invokes that method to obtain an instance of the service provider. A
 210  *   provider method is a public static method named &quot;provider&quot; with no formal
 211  *   parameters and a return type that is assignable to the service&#39;s interface
</pre>
<hr />
<pre>
 236  *
 237  * &lt;ul&gt;
 238  *   &lt;li&gt; {@code com.example.CodecFactory} is the two-method service from
 239  *   earlier. &lt;/li&gt;
 240  *
 241  *   &lt;li&gt; {@code com.example.impl.StandardCodecs} is a public class that implements
 242  *   {@code CodecFactory} and has a public no-args constructor. &lt;/li&gt;
 243  *
 244  *   &lt;li&gt; {@code com.example.impl.ExtendedCodecsFactory} is a public class that
 245  *   does not implement CodecFactory, but it declares a public static no-args
 246  *   method named &quot;provider&quot; with a return type of {@code CodecFactory}. &lt;/li&gt;
 247  * &lt;/ul&gt;
 248  *
 249  * &lt;p&gt; A service loader will instantiate {@code StandardCodecs} via its
 250  * constructor, and will instantiate {@code ExtendedCodecsFactory} by invoking
 251  * its {@code provider} method. The requirement that the provider constructor or
 252  * provider method is public helps to document the intent that the class (that is,
 253  * the service provider) will be instantiated by an entity (that is, a service
 254  * loader) which is outside the class&#39;s package.
 255  *
<span class="line-modified"> 256  * &lt;h3&gt; Deploying service providers on the class path &lt;/h3&gt;</span>
 257  *
 258  * A service provider that is packaged as a JAR file for the class path is
 259  * identified by placing a &lt;i&gt;provider-configuration file&lt;/i&gt; in the resource
 260  * directory {@code META-INF/services}. The name of the provider-configuration
 261  * file is the fully qualified binary name of the service. The provider-configuration
 262  * file contains a list of fully qualified binary names of service providers, one
 263  * per line.
 264  *
 265  * &lt;p&gt; For example, suppose the service provider
 266  * {@code com.example.impl.StandardCodecs} is packaged in a JAR file for the
 267  * class path. The JAR file will contain a provider-configuration file named:
 268  *
 269  * &lt;blockquote&gt;{@code
 270  *     META-INF/services/com.example.CodecFactory
 271  * }&lt;/blockquote&gt;
 272  *
 273  * that contains the line:
 274  *
 275  * &lt;blockquote&gt;{@code
 276  *     com.example.impl.StandardCodecs # Standard codecs
 277  * }&lt;/blockquote&gt;
 278  *
 279  * &lt;p&gt;&lt;a id=&quot;format&quot;&gt;The provider-configuration file must be encoded in UTF-8. &lt;/a&gt;
 280  * Space and tab characters surrounding each service provider&#39;s name, as well as
 281  * blank lines, are ignored. The comment character is {@code &#39;#&#39;}
 282  * ({@code &#39;&amp;#92;u0023&#39;} &lt;span style=&quot;font-size:smaller;&quot;&gt;NUMBER SIGN&lt;/span&gt;);
 283  * on each line all characters following the first comment character are ignored.
 284  * If a service provider class name is listed more than once in a
 285  * provider-configuration file then the duplicate is ignored. If a service
 286  * provider class is named in more than one configuration file then the duplicate
 287  * is ignored.
 288  *
 289  * &lt;p&gt; A service provider that is mentioned in a provider-configuration file may
 290  * be located in the same JAR file as the provider-configuration file or in a
 291  * different JAR file. The service provider must be visible from the class loader
 292  * that is initially queried to locate the provider-configuration file; this is
 293  * not necessarily the class loader which ultimately locates the
 294  * provider-configuration file.
 295  *
<span class="line-modified"> 296  * &lt;h3&gt; Timing of provider discovery &lt;/h3&gt;</span>
 297  *
 298  * &lt;p&gt; Service providers are loaded and instantiated lazily, that is, on demand.
 299  * A service loader maintains a cache of the providers that have been loaded so
 300  * far. Each invocation of the {@code iterator} method returns an {@code Iterator}
 301  * that first yields all of the elements cached from previous iteration, in
 302  * instantiation order, and then lazily locates and instantiates any remaining
 303  * providers, adding each one to the cache in turn. Similarly, each invocation
 304  * of the stream method returns a {@code Stream} that first processes all
 305  * providers loaded by previous stream operations, in load order, and then lazily
 306  * locates any remaining providers. Caches are cleared via the {@link #reload
 307  * reload} method.
 308  *
<span class="line-modified"> 309  * &lt;h3&gt; &lt;a id=&quot;errors&quot;&gt;Errors&lt;/a&gt; &lt;/h3&gt;</span>
 310  *
 311  * &lt;p&gt; When using the service loader&#39;s {@code iterator}, the {@link
 312  * Iterator#hasNext() hasNext} and {@link Iterator#next() next} methods will
 313  * fail with {@link ServiceConfigurationError} if an error occurs locating,
 314  * loading or instantiating a service provider. When processing the service
 315  * loader&#39;s stream then {@code ServiceConfigurationError} may be thrown by any
 316  * method that causes a service provider to be located or loaded.
 317  *
 318  * &lt;p&gt; When loading or instantiating a service provider in a module, {@code
 319  * ServiceConfigurationError} can be thrown for the following reasons:
 320  *
 321  * &lt;ul&gt;
 322  *
 323  *   &lt;li&gt; The service provider cannot be loaded. &lt;/li&gt;
 324  *
 325  *   &lt;li&gt; The service provider does not declare a provider method, and either
 326  *   it is not assignable to the service&#39;s interface/class or does not have a
 327  *   provider constructor. &lt;/li&gt;
 328  *
 329  *   &lt;li&gt; The service provider declares a public static no-args method named
</pre>
<hr />
<pre>
 344  * &lt;p&gt; When reading a provider-configuration file, or loading or instantiating
 345  * a provider class named in a provider-configuration file, then {@code
 346  * ServiceConfigurationError} can be thrown for the following reasons:
 347  *
 348  * &lt;ul&gt;
 349  *
 350  *   &lt;li&gt; The format of the provider-configuration file violates the &lt;a
 351  *   href=&quot;ServiceLoader.html#format&quot;&gt;format&lt;/a&gt; specified above; &lt;/li&gt;
 352  *
 353  *   &lt;li&gt; An {@link IOException IOException} occurs while reading the
 354  *   provider-configuration file; &lt;/li&gt;
 355  *
 356  *   &lt;li&gt; A service provider cannot be loaded; &lt;/li&gt;
 357  *
 358  *   &lt;li&gt; A service provider is not assignable to the service&#39;s interface or
 359  *   class, or does not define a provider constructor, or cannot be
 360  *   instantiated. &lt;/li&gt;
 361  *
 362  * &lt;/ul&gt;
 363  *
<span class="line-modified"> 364  * &lt;h3&gt; Security &lt;/h3&gt;</span>
 365  *
 366  * &lt;p&gt; Service loaders always execute in the security context of the caller
 367  * of the iterator or stream methods and may also be restricted by the security
 368  * context of the caller that created the service loader.
 369  * Trusted system code should typically invoke the methods in this class, and
 370  * the methods of the iterators which they return, from within a privileged
 371  * security context.
 372  *
<span class="line-modified"> 373  * &lt;h3&gt; Concurrency &lt;/h3&gt;</span>
 374  *
 375  * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
 376  * threads.
 377  *
 378  * &lt;h3&gt; Null handling &lt;/h3&gt;
 379  *
 380  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
 381  * method in this class will cause a {@link NullPointerException} to be thrown.
 382  *
 383  * @param  &lt;S&gt;
 384  *         The type of the service to be loaded by this loader
 385  *
 386  * @author Mark Reinhold
 387  * @since 1.6
 388  * @revised 9
 389  * @spec JPMS
 390  */
 391 
 392 public final class ServiceLoader&lt;S&gt;
 393     implements Iterable&lt;S&gt;
</pre>
<hr />
<pre>
1147                     if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != &#39;.&#39;))
1148                         fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);
1149                 }
1150                 if (providerNames.add(ln)) {
1151                     names.add(ln);
1152                 }
1153             }
1154             return lc + 1;
1155         }
1156 
1157         /**
1158          * Parse the content of the given URL as a provider-configuration file.
1159          */
1160         private Iterator&lt;String&gt; parse(URL u) {
1161             Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(); // preserve insertion order
1162             try {
1163                 URLConnection uc = u.openConnection();
1164                 uc.setUseCaches(false);
1165                 try (InputStream in = uc.getInputStream();
1166                      BufferedReader r
<span class="line-modified">1167                          = new BufferedReader(new InputStreamReader(in, &quot;utf-8&quot;)))</span>
1168                 {
1169                     int lc = 1;
1170                     while ((lc = parseLine(u, r, lc, names)) &gt;= 0);
1171                 }
1172             } catch (IOException x) {
1173                 fail(service, &quot;Error accessing configuration file&quot;, x);
1174             }
1175             return names.iterator();
1176         }
1177 
1178         /**
1179          * Loads and returns the next provider class.
1180          */
1181         private Class&lt;?&gt; nextProviderClass() {
1182             if (configs == null) {
1183                 try {
1184                     String fullName = PREFIX + service.getName();
1185                     if (loader == null) {
1186                         configs = ClassLoader.getSystemResources(fullName);
1187                     } else if (loader == ClassLoaders.platformClassLoader()) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  28 import java.io.BufferedReader;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InputStreamReader;
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.InvocationTargetException;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.net.URL;
  37 import java.net.URLConnection;
  38 import java.security.AccessControlContext;
  39 import java.security.AccessController;
  40 import java.security.PrivilegedAction;
  41 import java.security.PrivilegedActionException;
  42 import java.security.PrivilegedExceptionAction;
  43 import java.util.function.Consumer;
  44 import java.util.function.Supplier;
  45 import java.util.stream.Stream;
  46 import java.util.stream.StreamSupport;
  47 
<span class="line-added">  48 import sun.nio.cs.UTF_8;</span>
<span class="line-added">  49 </span>
  50 import jdk.internal.loader.BootLoader;
  51 import jdk.internal.loader.ClassLoaders;
  52 import jdk.internal.access.JavaLangAccess;
  53 import jdk.internal.access.SharedSecrets;
  54 import jdk.internal.misc.VM;
  55 import jdk.internal.module.ServicesCatalog;
  56 import jdk.internal.module.ServicesCatalog.ServiceProvider;
  57 import jdk.internal.reflect.CallerSensitive;
  58 import jdk.internal.reflect.Reflection;
  59 

  60 /**
  61  * A facility to load implementations of a service.
  62  *
  63  * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known interface or class for which zero, one,
  64  * or many service providers exist. A &lt;i&gt;service provider&lt;/i&gt; (or just
  65  * &lt;i&gt;provider&lt;/i&gt;) is a class that implements or subclasses the well-known
  66  * interface or class. A {@code ServiceLoader} is an object that locates and
  67  * loads service providers deployed in the run time environment at a time of an
  68  * application&#39;s choosing. Application code refers only to the service, not to
  69  * service providers, and is assumed to be capable of choosing between multiple
  70  * service providers (based on the functionality they expose through the service),
  71  * and handling the possibility that no service providers are located.
  72  *
<span class="line-modified">  73  * &lt;h2&gt; Obtaining a service loader &lt;/h2&gt;</span>
  74  *
  75  * &lt;p&gt; An application obtains a service loader for a given service by invoking
  76  * one of the static {@code load} methods of {@code ServiceLoader}. If the
  77  * application is a module, then its module declaration must have a &lt;i&gt;uses&lt;/i&gt;
  78  * directive that specifies the service; this helps to locate providers and ensure
  79  * they will execute reliably. In addition, if the application module does not
  80  * contain the service, then its module declaration must have a &lt;i&gt;requires&lt;/i&gt;
  81  * directive that specifies the module which exports the service. It is strongly
  82  * recommended that the application module does &lt;b&gt;not&lt;/b&gt; require modules which
  83  * contain providers of the service.
  84  *
  85  * &lt;p&gt; A service loader can be used to locate and instantiate providers of the
  86  * service by means of the {@link #iterator() iterator} method. {@code ServiceLoader}
  87  * also defines the {@link #stream() stream} method to obtain a stream of providers
  88  * that can be inspected and filtered without instantiating them.
  89  *
  90  * &lt;p&gt; As an example, suppose the service is {@code com.example.CodecFactory}, an
  91  * interface that defines methods for producing encoders and decoders:
  92  *
  93  * &lt;pre&gt;{@code
</pre>
<hr />
<pre>
 125  * instantiating it, in order to determine if an instance of that service
 126  * provider would be useful. For example, a service provider for {@code
 127  * CodecFactory} that is capable of producing a &quot;PNG&quot; encoder may be annotated
 128  * with {@code @PNG}. The following code uses service loader&#39;s {@code stream}
 129  * method to yield instances of {@code Provider&lt;CodecFactory&gt;} in contrast to
 130  * how the iterator yields instances of {@code CodecFactory}:
 131  * &lt;pre&gt;{@code
 132  *     ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
 133  *     Set&lt;CodecFactory&gt; pngFactories = loader
 134  *            .stream()                                              // Note a below
 135  *            .filter(p -&gt; p.type().isAnnotationPresent(PNG.class))  // Note b
 136  *            .map(Provider::get)                                    // Note c
 137  *            .collect(Collectors.toSet());
 138  * }&lt;/pre&gt;
 139  * &lt;ol type=&quot;a&quot;&gt;
 140  *   &lt;li&gt; A stream of {@code Provider&lt;CodecFactory&gt;} objects &lt;/li&gt;
 141  *   &lt;li&gt; {@code p.type()} yields a {@code Class&lt;CodecFactory&gt;} &lt;/li&gt;
 142  *   &lt;li&gt; {@code get()} yields an instance of {@code CodecFactory} &lt;/li&gt;
 143  * &lt;/ol&gt;
 144  *
<span class="line-modified"> 145  * &lt;h2&gt; Designing services &lt;/h2&gt;</span>
 146  *
 147  * &lt;p&gt; A service is a single type, usually an interface or abstract class. A
 148  * concrete class can be used, but this is not recommended. The type may have
 149  * any accessibility. The methods of a service are highly domain-specific, so
 150  * this API specification cannot give concrete advice about their form or
 151  * function. However, there are two general guidelines:
 152  * &lt;ol&gt;
 153  *   &lt;li&gt;&lt;p&gt; A service should declare as many methods as needed to allow service
 154  *   providers to communicate their domain-specific properties and other
 155  *   quality-of-implementation factors. An application which obtains a service
 156  *   loader for the service may then invoke these methods on each instance of
 157  *   a service provider, in order to choose the best provider for the
 158  *   application. &lt;/p&gt;&lt;/li&gt;
 159  *   &lt;li&gt;&lt;p&gt; A service should express whether its service providers are intended
 160  *   to be direct implementations of the service or to be an indirection
 161  *   mechanism such as a &quot;proxy&quot; or a &quot;factory&quot;. Service providers tend to be
 162  *   indirection mechanisms when domain-specific objects are relatively
 163  *   expensive to instantiate; in this case, the service should be designed
 164  *   so that service providers are abstractions which create the &quot;real&quot;
 165  *   implementation on demand. For example, the {@code CodecFactory} service
 166  *   expresses through its name that its service providers are factories
 167  *   for codecs, rather than codecs themselves, because it may be expensive
 168  *   or complicated to produce certain codecs. &lt;/p&gt;&lt;/li&gt;
 169  * &lt;/ol&gt;
 170  *
<span class="line-modified"> 171  * &lt;h2&gt; &lt;a id=&quot;developing-service-providers&quot;&gt;Developing service providers&lt;/a&gt; &lt;/h2&gt;</span>
 172  *
 173  * &lt;p&gt; A service provider is a single type, usually a concrete class. An
 174  * interface or abstract class is permitted because it may declare a static
 175  * provider method, discussed later. The type must be public and must not be
 176  * an inner class.
 177  *
 178  * &lt;p&gt; A service provider and its supporting code may be developed in a module,
 179  * which is then deployed on the application module path or in a modular
 180  * image. Alternatively, a service provider and its supporting code may be
 181  * packaged as a JAR file and deployed on the application class path. The
 182  * advantage of developing a service provider in a module is that the provider
 183  * can be fully encapsulated to hide all details of its implementation.
 184  *
 185  * &lt;p&gt; An application that obtains a service loader for a given service is
 186  * indifferent to whether providers of the service are deployed in modules or
 187  * packaged as JAR files. The application instantiates service providers via
 188  * the service loader&#39;s iterator, or via {@link Provider Provider} objects in
 189  * the service loader&#39;s stream, without knowledge of the service providers&#39;
 190  * locations.
 191  *
<span class="line-modified"> 192  * &lt;h2&gt; Deploying service providers as modules &lt;/h2&gt;</span>
 193  *
 194  * &lt;p&gt; A service provider that is developed in a module must be specified in a
 195  * &lt;i&gt;provides&lt;/i&gt; directive in the module declaration. The provides directive
 196  * specifies both the service and the service provider; this helps to locate the
 197  * provider when another module, with a &lt;i&gt;uses&lt;/i&gt; directive for the service,
 198  * obtains a service loader for the service. It is strongly recommended that the
 199  * module does not export the package containing the service provider. There is
 200  * no support for a module specifying, in a &lt;i&gt;provides&lt;/i&gt; directive, a service
 201  * provider in another module.
 202 
 203  * &lt;p&gt; A service provider that is developed in a module has no control over when
 204  * it is instantiated, since that occurs at the behest of the application, but it
 205  * does have control over how it is instantiated:
 206  *
 207  * &lt;ul&gt;
 208  *
 209  *   &lt;li&gt; If the service provider declares a provider method, then the service
 210  *   loader invokes that method to obtain an instance of the service provider. A
 211  *   provider method is a public static method named &quot;provider&quot; with no formal
 212  *   parameters and a return type that is assignable to the service&#39;s interface
</pre>
<hr />
<pre>
 237  *
 238  * &lt;ul&gt;
 239  *   &lt;li&gt; {@code com.example.CodecFactory} is the two-method service from
 240  *   earlier. &lt;/li&gt;
 241  *
 242  *   &lt;li&gt; {@code com.example.impl.StandardCodecs} is a public class that implements
 243  *   {@code CodecFactory} and has a public no-args constructor. &lt;/li&gt;
 244  *
 245  *   &lt;li&gt; {@code com.example.impl.ExtendedCodecsFactory} is a public class that
 246  *   does not implement CodecFactory, but it declares a public static no-args
 247  *   method named &quot;provider&quot; with a return type of {@code CodecFactory}. &lt;/li&gt;
 248  * &lt;/ul&gt;
 249  *
 250  * &lt;p&gt; A service loader will instantiate {@code StandardCodecs} via its
 251  * constructor, and will instantiate {@code ExtendedCodecsFactory} by invoking
 252  * its {@code provider} method. The requirement that the provider constructor or
 253  * provider method is public helps to document the intent that the class (that is,
 254  * the service provider) will be instantiated by an entity (that is, a service
 255  * loader) which is outside the class&#39;s package.
 256  *
<span class="line-modified"> 257  * &lt;h2&gt; Deploying service providers on the class path &lt;/h2&gt;</span>
 258  *
 259  * A service provider that is packaged as a JAR file for the class path is
 260  * identified by placing a &lt;i&gt;provider-configuration file&lt;/i&gt; in the resource
 261  * directory {@code META-INF/services}. The name of the provider-configuration
 262  * file is the fully qualified binary name of the service. The provider-configuration
 263  * file contains a list of fully qualified binary names of service providers, one
 264  * per line.
 265  *
 266  * &lt;p&gt; For example, suppose the service provider
 267  * {@code com.example.impl.StandardCodecs} is packaged in a JAR file for the
 268  * class path. The JAR file will contain a provider-configuration file named:
 269  *
 270  * &lt;blockquote&gt;{@code
 271  *     META-INF/services/com.example.CodecFactory
 272  * }&lt;/blockquote&gt;
 273  *
 274  * that contains the line:
 275  *
 276  * &lt;blockquote&gt;{@code
 277  *     com.example.impl.StandardCodecs # Standard codecs
 278  * }&lt;/blockquote&gt;
 279  *
 280  * &lt;p&gt;&lt;a id=&quot;format&quot;&gt;The provider-configuration file must be encoded in UTF-8. &lt;/a&gt;
 281  * Space and tab characters surrounding each service provider&#39;s name, as well as
 282  * blank lines, are ignored. The comment character is {@code &#39;#&#39;}
 283  * ({@code &#39;&amp;#92;u0023&#39;} &lt;span style=&quot;font-size:smaller;&quot;&gt;NUMBER SIGN&lt;/span&gt;);
 284  * on each line all characters following the first comment character are ignored.
 285  * If a service provider class name is listed more than once in a
 286  * provider-configuration file then the duplicate is ignored. If a service
 287  * provider class is named in more than one configuration file then the duplicate
 288  * is ignored.
 289  *
 290  * &lt;p&gt; A service provider that is mentioned in a provider-configuration file may
 291  * be located in the same JAR file as the provider-configuration file or in a
 292  * different JAR file. The service provider must be visible from the class loader
 293  * that is initially queried to locate the provider-configuration file; this is
 294  * not necessarily the class loader which ultimately locates the
 295  * provider-configuration file.
 296  *
<span class="line-modified"> 297  * &lt;h2&gt; Timing of provider discovery &lt;/h2&gt;</span>
 298  *
 299  * &lt;p&gt; Service providers are loaded and instantiated lazily, that is, on demand.
 300  * A service loader maintains a cache of the providers that have been loaded so
 301  * far. Each invocation of the {@code iterator} method returns an {@code Iterator}
 302  * that first yields all of the elements cached from previous iteration, in
 303  * instantiation order, and then lazily locates and instantiates any remaining
 304  * providers, adding each one to the cache in turn. Similarly, each invocation
 305  * of the stream method returns a {@code Stream} that first processes all
 306  * providers loaded by previous stream operations, in load order, and then lazily
 307  * locates any remaining providers. Caches are cleared via the {@link #reload
 308  * reload} method.
 309  *
<span class="line-modified"> 310  * &lt;h2&gt; &lt;a id=&quot;errors&quot;&gt;Errors&lt;/a&gt; &lt;/h2&gt;</span>
 311  *
 312  * &lt;p&gt; When using the service loader&#39;s {@code iterator}, the {@link
 313  * Iterator#hasNext() hasNext} and {@link Iterator#next() next} methods will
 314  * fail with {@link ServiceConfigurationError} if an error occurs locating,
 315  * loading or instantiating a service provider. When processing the service
 316  * loader&#39;s stream then {@code ServiceConfigurationError} may be thrown by any
 317  * method that causes a service provider to be located or loaded.
 318  *
 319  * &lt;p&gt; When loading or instantiating a service provider in a module, {@code
 320  * ServiceConfigurationError} can be thrown for the following reasons:
 321  *
 322  * &lt;ul&gt;
 323  *
 324  *   &lt;li&gt; The service provider cannot be loaded. &lt;/li&gt;
 325  *
 326  *   &lt;li&gt; The service provider does not declare a provider method, and either
 327  *   it is not assignable to the service&#39;s interface/class or does not have a
 328  *   provider constructor. &lt;/li&gt;
 329  *
 330  *   &lt;li&gt; The service provider declares a public static no-args method named
</pre>
<hr />
<pre>
 345  * &lt;p&gt; When reading a provider-configuration file, or loading or instantiating
 346  * a provider class named in a provider-configuration file, then {@code
 347  * ServiceConfigurationError} can be thrown for the following reasons:
 348  *
 349  * &lt;ul&gt;
 350  *
 351  *   &lt;li&gt; The format of the provider-configuration file violates the &lt;a
 352  *   href=&quot;ServiceLoader.html#format&quot;&gt;format&lt;/a&gt; specified above; &lt;/li&gt;
 353  *
 354  *   &lt;li&gt; An {@link IOException IOException} occurs while reading the
 355  *   provider-configuration file; &lt;/li&gt;
 356  *
 357  *   &lt;li&gt; A service provider cannot be loaded; &lt;/li&gt;
 358  *
 359  *   &lt;li&gt; A service provider is not assignable to the service&#39;s interface or
 360  *   class, or does not define a provider constructor, or cannot be
 361  *   instantiated. &lt;/li&gt;
 362  *
 363  * &lt;/ul&gt;
 364  *
<span class="line-modified"> 365  * &lt;h2&gt; Security &lt;/h2&gt;</span>
 366  *
 367  * &lt;p&gt; Service loaders always execute in the security context of the caller
 368  * of the iterator or stream methods and may also be restricted by the security
 369  * context of the caller that created the service loader.
 370  * Trusted system code should typically invoke the methods in this class, and
 371  * the methods of the iterators which they return, from within a privileged
 372  * security context.
 373  *
<span class="line-modified"> 374  * &lt;h2&gt; Concurrency &lt;/h2&gt;</span>
 375  *
 376  * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
 377  * threads.
 378  *
 379  * &lt;h3&gt; Null handling &lt;/h3&gt;
 380  *
 381  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
 382  * method in this class will cause a {@link NullPointerException} to be thrown.
 383  *
 384  * @param  &lt;S&gt;
 385  *         The type of the service to be loaded by this loader
 386  *
 387  * @author Mark Reinhold
 388  * @since 1.6
 389  * @revised 9
 390  * @spec JPMS
 391  */
 392 
 393 public final class ServiceLoader&lt;S&gt;
 394     implements Iterable&lt;S&gt;
</pre>
<hr />
<pre>
1148                     if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != &#39;.&#39;))
1149                         fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);
1150                 }
1151                 if (providerNames.add(ln)) {
1152                     names.add(ln);
1153                 }
1154             }
1155             return lc + 1;
1156         }
1157 
1158         /**
1159          * Parse the content of the given URL as a provider-configuration file.
1160          */
1161         private Iterator&lt;String&gt; parse(URL u) {
1162             Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(); // preserve insertion order
1163             try {
1164                 URLConnection uc = u.openConnection();
1165                 uc.setUseCaches(false);
1166                 try (InputStream in = uc.getInputStream();
1167                      BufferedReader r
<span class="line-modified">1168                          = new BufferedReader(new InputStreamReader(in, UTF_8.INSTANCE)))</span>
1169                 {
1170                     int lc = 1;
1171                     while ((lc = parseLine(u, r, lc, names)) &gt;= 0);
1172                 }
1173             } catch (IOException x) {
1174                 fail(service, &quot;Error accessing configuration file&quot;, x);
1175             }
1176             return names.iterator();
1177         }
1178 
1179         /**
1180          * Loads and returns the next provider class.
1181          */
1182         private Class&lt;?&gt; nextProviderClass() {
1183             if (configs == null) {
1184                 try {
1185                     String fullName = PREFIX + service.getName();
1186                     if (loader == null) {
1187                         configs = ClassLoader.getSystemResources(fullName);
1188                     } else if (loader == ClassLoaders.platformClassLoader()) {
</pre>
</td>
</tr>
</table>
<center><a href="ServiceConfigurationError.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Set.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
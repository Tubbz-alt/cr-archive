<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/SerializedLambda.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MutableCallSite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SimpleMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/SerializedLambda.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 48  * serialization to proceed.
 49  *
 50  * &lt;p&gt;{@code SerializedLambda} has a {@code readResolve} method that looks for
 51  * a (possibly private) static method called
 52  * {@code $deserializeLambda$(SerializedLambda)} in the capturing class, invokes
 53  * that with itself as the first argument, and returns the result.  Lambda classes
 54  * implementing {@code $deserializeLambda$} are responsible for validating
 55  * that the properties of the {@code SerializedLambda} are consistent with a
 56  * lambda actually captured by that class.
 57  *
 58  * &lt;p&gt;The identity of a function object produced by deserializing the serialized
 59  * form is unpredictable, and therefore identity-sensitive operations (such as
 60  * reference equality, object locking, and {@code System.identityHashCode()} may
 61  * produce different results in different implementations, or even upon
 62  * different deserializations in the same implementation.
 63  *
 64  * @see LambdaMetafactory
 65  * @since 1.8
 66  */
 67 public final class SerializedLambda implements Serializable {

 68     private static final long serialVersionUID = 8025925345765570181L;
 69     private final Class&lt;?&gt; capturingClass;
 70     private final String functionalInterfaceClass;
 71     private final String functionalInterfaceMethodName;
 72     private final String functionalInterfaceMethodSignature;
 73     private final String implClass;
 74     private final String implMethodName;
 75     private final String implMethodSignature;
 76     private final int implMethodKind;
 77     private final String instantiatedMethodType;

 78     private final Object[] capturedArgs;
 79 
 80     /**
 81      * Create a {@code SerializedLambda} from the low-level information present
 82      * at the lambda factory site.
 83      *
 84      * @param capturingClass The class in which the lambda expression appears
 85      * @param functionalInterfaceClass Name, in slash-delimited form, of static
 86      *                                 type of the returned lambda object
 87      * @param functionalInterfaceMethodName Name of the functional interface
 88      *                                      method for the present at the
 89      *                                      lambda factory site
 90      * @param functionalInterfaceMethodSignature Signature of the functional
 91      *                                           interface method present at
 92      *                                           the lambda factory site
 93      * @param implMethodKind Method handle kind for the implementation method
 94      * @param implClass Name, in slash-delimited form, for the class holding
 95      *                  the implementation method
 96      * @param implMethodName Name of the implementation method
 97      * @param implMethodSignature Signature of the implementation method
</pre>
<hr />
<pre>
208         return instantiatedMethodType;
209     }
210 
211     /**
212      * Get the count of dynamic arguments to the lambda capture site.
213      * @return the count of dynamic arguments to the lambda capture site
214      */
215     public int getCapturedArgCount() {
216         return capturedArgs.length;
217     }
218 
219     /**
220      * Get a dynamic argument to the lambda capture site.
221      * @param i the argument to capture
222      * @return a dynamic argument to the lambda capture site
223      */
224     public Object getCapturedArg(int i) {
225         return capturedArgs[i];
226     }
227 

228     private Object readResolve() throws ObjectStreamException {
229         try {
230             Method deserialize = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
231                 @Override
232                 public Method run() throws Exception {
233                     Method m = capturingClass.getDeclaredMethod(&quot;$deserializeLambda$&quot;, SerializedLambda.class);
234                     m.setAccessible(true);
235                     return m;
236                 }
237             });
238 
239             return deserialize.invoke(null, this);
240         } catch (ReflectiveOperationException roe) {
241             ObjectStreamException ose = new InvalidObjectException(&quot;ReflectiveOperationException during deserialization&quot;);
242             ose.initCause(roe);
243             throw ose;
244         } catch (PrivilegedActionException e) {
245             Exception cause = e.getException();
246             if (cause instanceof RuntimeException)
247                 throw (RuntimeException) cause;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 48  * serialization to proceed.
 49  *
 50  * &lt;p&gt;{@code SerializedLambda} has a {@code readResolve} method that looks for
 51  * a (possibly private) static method called
 52  * {@code $deserializeLambda$(SerializedLambda)} in the capturing class, invokes
 53  * that with itself as the first argument, and returns the result.  Lambda classes
 54  * implementing {@code $deserializeLambda$} are responsible for validating
 55  * that the properties of the {@code SerializedLambda} are consistent with a
 56  * lambda actually captured by that class.
 57  *
 58  * &lt;p&gt;The identity of a function object produced by deserializing the serialized
 59  * form is unpredictable, and therefore identity-sensitive operations (such as
 60  * reference equality, object locking, and {@code System.identityHashCode()} may
 61  * produce different results in different implementations, or even upon
 62  * different deserializations in the same implementation.
 63  *
 64  * @see LambdaMetafactory
 65  * @since 1.8
 66  */
 67 public final class SerializedLambda implements Serializable {
<span class="line-added"> 68     @java.io.Serial</span>
 69     private static final long serialVersionUID = 8025925345765570181L;
 70     private final Class&lt;?&gt; capturingClass;
 71     private final String functionalInterfaceClass;
 72     private final String functionalInterfaceMethodName;
 73     private final String functionalInterfaceMethodSignature;
 74     private final String implClass;
 75     private final String implMethodName;
 76     private final String implMethodSignature;
 77     private final int implMethodKind;
 78     private final String instantiatedMethodType;
<span class="line-added"> 79     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 80     private final Object[] capturedArgs;
 81 
 82     /**
 83      * Create a {@code SerializedLambda} from the low-level information present
 84      * at the lambda factory site.
 85      *
 86      * @param capturingClass The class in which the lambda expression appears
 87      * @param functionalInterfaceClass Name, in slash-delimited form, of static
 88      *                                 type of the returned lambda object
 89      * @param functionalInterfaceMethodName Name of the functional interface
 90      *                                      method for the present at the
 91      *                                      lambda factory site
 92      * @param functionalInterfaceMethodSignature Signature of the functional
 93      *                                           interface method present at
 94      *                                           the lambda factory site
 95      * @param implMethodKind Method handle kind for the implementation method
 96      * @param implClass Name, in slash-delimited form, for the class holding
 97      *                  the implementation method
 98      * @param implMethodName Name of the implementation method
 99      * @param implMethodSignature Signature of the implementation method
</pre>
<hr />
<pre>
210         return instantiatedMethodType;
211     }
212 
213     /**
214      * Get the count of dynamic arguments to the lambda capture site.
215      * @return the count of dynamic arguments to the lambda capture site
216      */
217     public int getCapturedArgCount() {
218         return capturedArgs.length;
219     }
220 
221     /**
222      * Get a dynamic argument to the lambda capture site.
223      * @param i the argument to capture
224      * @return a dynamic argument to the lambda capture site
225      */
226     public Object getCapturedArg(int i) {
227         return capturedArgs[i];
228     }
229 
<span class="line-added">230     @java.io.Serial</span>
231     private Object readResolve() throws ObjectStreamException {
232         try {
233             Method deserialize = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
234                 @Override
235                 public Method run() throws Exception {
236                     Method m = capturingClass.getDeclaredMethod(&quot;$deserializeLambda$&quot;, SerializedLambda.class);
237                     m.setAccessible(true);
238                     return m;
239                 }
240             });
241 
242             return deserialize.invoke(null, this);
243         } catch (ReflectiveOperationException roe) {
244             ObjectStreamException ose = new InvalidObjectException(&quot;ReflectiveOperationException during deserialization&quot;);
245             ose.initCause(roe);
246             throw ose;
247         } catch (PrivilegedActionException e) {
248             Exception cause = e.getException();
249             if (cause instanceof RuntimeException)
250                 throw (RuntimeException) cause;
</pre>
</td>
</tr>
</table>
<center><a href="MutableCallSite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SimpleMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
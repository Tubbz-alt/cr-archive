<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/Signature.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SecurityPermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SignatureException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/Signature.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.security.spec.AlgorithmParameterSpec;
  29 import java.util.*;
  30 import java.util.concurrent.ConcurrentHashMap;
  31 import java.io.*;
  32 import java.security.cert.Certificate;
  33 import java.security.cert.X509Certificate;
  34 
  35 import java.nio.ByteBuffer;
  36 
  37 import java.security.Provider.Service;
  38 
  39 import javax.crypto.Cipher;
  40 import javax.crypto.IllegalBlockSizeException;
  41 import javax.crypto.BadPaddingException;
  42 import javax.crypto.NoSuchPaddingException;


  43 
  44 import sun.security.util.Debug;
  45 import sun.security.jca.*;
  46 import sun.security.jca.GetInstance.Instance;
  47 
  48 /**
  49  * The Signature class is used to provide applications the functionality
  50  * of a digital signature algorithm. Digital signatures are used for
  51  * authentication and integrity assurance of digital data.
  52  *
  53  * &lt;p&gt; The signature algorithm can be, among others, the NIST standard
  54  * DSA, using DSA and SHA-256. The DSA algorithm using the
  55  * SHA-256 message digest algorithm can be specified as {@code SHA256withDSA}.
  56  * In the case of RSA the signing algorithm could be specified as, for example,
  57  * {@code SHA256withRSA}.
  58  * The algorithm name must be specified, as there is no default.
  59  *
  60  * &lt;p&gt; A Signature object can be used to generate and verify digital
  61  * signatures.
  62  *
</pre>
<hr />
<pre>
 101  * &lt;ul&gt;
 102  * &lt;li&gt;{@code SHA1withDSA}&lt;/li&gt;
 103  * &lt;li&gt;{@code SHA256withDSA}&lt;/li&gt;
 104  * &lt;li&gt;{@code SHA1withRSA}&lt;/li&gt;
 105  * &lt;li&gt;{@code SHA256withRSA}&lt;/li&gt;
 106  * &lt;/ul&gt;
 107  * These algorithms are described in the &lt;a href=
 108  * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 109  * Signature section&lt;/a&gt; of the
 110  * Java Security Standard Algorithm Names Specification.
 111  * Consult the release documentation for your implementation to see if any
 112  * other algorithms are supported.
 113  *
 114  * @author Benjamin Renaud
 115  * @since 1.1
 116  *
 117  */
 118 
 119 public abstract class Signature extends SignatureSpi {
 120 




























 121     private static final Debug debug =
 122                         Debug.getInstance(&quot;jca&quot;, &quot;Signature&quot;);
 123 
 124     private static final Debug pdebug =
 125                         Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 126     private static final boolean skipDebug =
 127         Debug.isOn(&quot;engine=&quot;) &amp;&amp; !Debug.isOn(&quot;signature&quot;);
 128 
 129     /*
 130      * The algorithm for this signature object.
 131      * This value is used to map an OID to the particular algorithm.
 132      * The mapping is done in AlgorithmObject.algOID(String algorithm)
 133      */
 134     private String algorithm;
 135 
 136     // The provider
 137     Provider provider;
 138 
 139     /**
 140      * Possible {@link #state} value, signifying that
</pre>
<hr />
<pre>
 451         chooseFirstProvider();
 452         return this.provider;
 453     }
 454 
 455     private String getProviderName() {
 456         return (provider == null)  ? &quot;(no provider)&quot; : provider.getName();
 457     }
 458 
 459     void chooseFirstProvider() {
 460         // empty, overridden in Delegate
 461     }
 462 
 463     /**
 464      * Initializes this object for verification. If this method is called
 465      * again with a different argument, it negates the effect
 466      * of this call.
 467      *
 468      * @param publicKey the public key of the identity whose signature is
 469      * going to be verified.
 470      *
<span class="line-modified"> 471      * @exception InvalidKeyException if the key is invalid.</span>
 472      */
 473     public final void initVerify(PublicKey publicKey)
 474             throws InvalidKeyException {
 475         engineInitVerify(publicKey);
 476         state = VERIFY;
 477 
 478         if (!skipDebug &amp;&amp; pdebug != null) {
 479             pdebug.println(&quot;Signature.&quot; + algorithm +
 480                 &quot; verification algorithm from: &quot; + getProviderName());
 481         }
 482     }
 483 















































 484     /**
 485      * Initializes this object for verification, using the public key from
 486      * the given certificate.
 487      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
 488      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
 489      * extension field implies that the public key in
 490      * the certificate and its corresponding private key are not
 491      * supposed to be used for digital signatures, an
 492      * {@code InvalidKeyException} is thrown.
 493      *
 494      * @param certificate the certificate of the identity whose signature is
 495      * going to be verified.
 496      *
<span class="line-modified"> 497      * @exception InvalidKeyException  if the public key in the certificate</span>
 498      * is not encoded properly or does not include required  parameter
 499      * information or cannot be used for digital signature purposes.
 500      * @since 1.3
 501      */
 502     public final void initVerify(Certificate certificate)
 503             throws InvalidKeyException {
<span class="line-modified"> 504         // If the certificate is of type X509Certificate,</span>
<span class="line-modified"> 505         // we should check whether it has a Key Usage</span>
<span class="line-removed"> 506         // extension marked as critical.</span>
<span class="line-removed"> 507         if (certificate instanceof java.security.cert.X509Certificate) {</span>
<span class="line-removed"> 508             // Check whether the cert has a key usage extension</span>
<span class="line-removed"> 509             // marked as a critical extension.</span>
<span class="line-removed"> 510             // The OID for KeyUsage extension is 2.5.29.15.</span>
<span class="line-removed"> 511             X509Certificate cert = (X509Certificate)certificate;</span>
<span class="line-removed"> 512             Set&lt;String&gt; critSet = cert.getCriticalExtensionOIDs();</span>
 513 
<span class="line-modified"> 514             if (critSet != null &amp;&amp; !critSet.isEmpty()</span>
<span class="line-modified"> 515                 &amp;&amp; critSet.contains(&quot;2.5.29.15&quot;)) {</span>
<span class="line-modified"> 516                 boolean[] keyUsageInfo = cert.getKeyUsage();</span>
<span class="line-removed"> 517                 // keyUsageInfo[0] is for digitalSignature.</span>
<span class="line-removed"> 518                 if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))</span>
<span class="line-removed"> 519                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);</span>
<span class="line-removed"> 520             }</span>
 521         }

 522 
<span class="line-modified"> 523         PublicKey publicKey = certificate.getPublicKey();</span>
<span class="line-modified"> 524         engineInitVerify(publicKey);</span>























 525         state = VERIFY;
 526 
 527         if (!skipDebug &amp;&amp; pdebug != null) {
 528             pdebug.println(&quot;Signature.&quot; + algorithm +
 529                 &quot; verification algorithm from: &quot; + getProviderName());
 530         }
 531     }
 532 
 533     /**
 534      * Initialize this object for signing. If this method is called
 535      * again with a different argument, it negates the effect
 536      * of this call.
 537      *
 538      * @param privateKey the private key of the identity whose signature
 539      * is going to be generated.
 540      *
<span class="line-modified"> 541      * @exception InvalidKeyException if the key is invalid.</span>
 542      */
 543     public final void initSign(PrivateKey privateKey)
 544             throws InvalidKeyException {
 545         engineInitSign(privateKey);
 546         state = SIGN;
 547 
 548         if (!skipDebug &amp;&amp; pdebug != null) {
 549             pdebug.println(&quot;Signature.&quot; + algorithm +
 550                 &quot; signing algorithm from: &quot; + getProviderName());
 551         }
 552     }
 553 
 554     /**
 555      * Initialize this object for signing. If this method is called
 556      * again with a different argument, it negates the effect
 557      * of this call.
 558      *
 559      * @param privateKey the private key of the identity whose signature
 560      * is going to be generated.
 561      *
 562      * @param random the source of randomness for this signature.
 563      *
<span class="line-modified"> 564      * @exception InvalidKeyException if the key is invalid.</span>
 565      */
 566     public final void initSign(PrivateKey privateKey, SecureRandom random)
 567             throws InvalidKeyException {
 568         engineInitSign(privateKey, random);
 569         state = SIGN;
 570 
 571         if (!skipDebug &amp;&amp; pdebug != null) {
 572             pdebug.println(&quot;Signature.&quot; + algorithm +
 573                 &quot; signing algorithm from: &quot; + getProviderName());
 574         }
 575     }
 576 

























 577     /**
 578      * Returns the signature bytes of all the data updated.
 579      * The format of the signature depends on the underlying
 580      * signature scheme.
 581      *
 582      * &lt;p&gt;A call to this method resets this signature object to the state
 583      * it was in when previously initialized for signing via a
 584      * call to {@code initSign(PrivateKey)}. That is, the object is
 585      * reset and available to generate another signature from the same
 586      * signer, if desired, via new calls to {@code update} and
 587      * {@code sign}.
 588      *
 589      * @return the signature bytes of the signing operation&#39;s result.
 590      *
<span class="line-modified"> 591      * @exception SignatureException if this signature object is not</span>
 592      * initialized properly or if this signature algorithm is unable to
 593      * process the input data provided.
 594      */
 595     public final byte[] sign() throws SignatureException {
 596         if (state == SIGN) {
 597             return engineSign();
 598         }
 599         throw new SignatureException(&quot;object not initialized for &quot; +
 600                                      &quot;signing&quot;);
 601     }
 602 
 603     /**
 604      * Finishes the signature operation and stores the resulting signature
 605      * bytes in the provided buffer {@code outbuf}, starting at
 606      * {@code offset}.
 607      * The format of the signature depends on the underlying
 608      * signature scheme.
 609      *
 610      * &lt;p&gt;This signature object is reset to its initial state (the state it
 611      * was in after a call to one of the {@code initSign} methods) and
 612      * can be reused to generate further signatures with the same private key.
 613      *
 614      * @param outbuf buffer for the signature result.
 615      *
 616      * @param offset offset into {@code outbuf} where the signature is
 617      * stored.
 618      *
 619      * @param len number of bytes within {@code outbuf} allotted for the
 620      * signature.
 621      *
 622      * @return the number of bytes placed into {@code outbuf}.
 623      *
<span class="line-modified"> 624      * @exception SignatureException if this signature object is not</span>
 625      *     initialized properly, if this signature algorithm is unable to
 626      *     process the input data provided, or if {@code len} is less
 627      *     than the actual signature length.
<span class="line-modified"> 628      * @exception IllegalArgumentException if {@code outbuf} is {@code null},</span>
 629      *     or {@code offset} or {@code len} is less than 0, or the sum of
 630      *     {@code offset} and {@code len} is greater than the length of
 631      *     {@code outbuf}.
 632      *
 633      * @since 1.2
 634      */
 635     public final int sign(byte[] outbuf, int offset, int len)
 636         throws SignatureException {
 637         if (outbuf == null) {
 638             throw new IllegalArgumentException(&quot;No output buffer given&quot;);
 639         }
 640         if (offset &lt; 0 || len &lt; 0) {
 641             throw new IllegalArgumentException(&quot;offset or len is less than 0&quot;);
 642         }
 643         if (outbuf.length - offset &lt; len) {
 644             throw new IllegalArgumentException
 645                 (&quot;Output buffer too small for specified offset and length&quot;);
 646         }
 647         if (state != SIGN) {
 648             throw new SignatureException(&quot;object not initialized for &quot; +
 649                                          &quot;signing&quot;);
 650         }
 651         return engineSign(outbuf, offset, len);
 652     }
 653 
 654     /**
 655      * Verifies the passed-in signature.
 656      *
 657      * &lt;p&gt;A call to this method resets this signature object to the state
 658      * it was in when previously initialized for verification via a
 659      * call to {@code initVerify(PublicKey)}. That is, the object is
 660      * reset and available to verify another signature from the identity
 661      * whose public key was specified in the call to {@code initVerify}.
 662      *
 663      * @param signature the signature bytes to be verified.
 664      *
 665      * @return true if the signature was verified, false if not.
 666      *
<span class="line-modified"> 667      * @exception SignatureException if this signature object is not</span>
 668      * initialized properly, the passed-in signature is improperly
 669      * encoded or of the wrong type, if this signature algorithm is unable to
 670      * process the input data provided, etc.
 671      */
 672     public final boolean verify(byte[] signature) throws SignatureException {
 673         if (state == VERIFY) {
 674             return engineVerify(signature);
 675         }
 676         throw new SignatureException(&quot;object not initialized for &quot; +
 677                                      &quot;verification&quot;);
 678     }
 679 
 680     /**
 681      * Verifies the passed-in signature in the specified array
 682      * of bytes, starting at the specified offset.
 683      *
 684      * &lt;p&gt;A call to this method resets this signature object to the state
 685      * it was in when previously initialized for verification via a
 686      * call to {@code initVerify(PublicKey)}. That is, the object is
 687      * reset and available to verify another signature from the identity
 688      * whose public key was specified in the call to {@code initVerify}.
 689      *
 690      *
 691      * @param signature the signature bytes to be verified.
 692      * @param offset the offset to start from in the array of bytes.
 693      * @param length the number of bytes to use, starting at offset.
 694      *
 695      * @return true if the signature was verified, false if not.
 696      *
<span class="line-modified"> 697      * @exception SignatureException if this signature object is not</span>
 698      * initialized properly, the passed-in signature is improperly
 699      * encoded or of the wrong type, if this signature algorithm is unable to
 700      * process the input data provided, etc.
<span class="line-modified"> 701      * @exception IllegalArgumentException if the {@code signature}</span>
 702      * byte array is {@code null}, or the {@code offset} or {@code length}
 703      * is less than 0, or the sum of the {@code offset} and
 704      * {@code length} is greater than the length of the
 705      * {@code signature} byte array.
 706      * @since 1.4
 707      */
 708     public final boolean verify(byte[] signature, int offset, int length)
 709         throws SignatureException {
 710         if (state == VERIFY) {
 711             if (signature == null) {
 712                 throw new IllegalArgumentException(&quot;signature is null&quot;);
 713             }
 714             if (offset &lt; 0 || length &lt; 0) {
 715                 throw new IllegalArgumentException
 716                     (&quot;offset or length is less than 0&quot;);
 717             }
 718             if (signature.length - offset &lt; length) {
 719                 throw new IllegalArgumentException
 720                     (&quot;signature too small for specified offset and length&quot;);
 721             }
 722 
 723             return engineVerify(signature, offset, length);
 724         }
 725         throw new SignatureException(&quot;object not initialized for &quot; +
 726                                      &quot;verification&quot;);
 727     }
 728 
 729     /**
 730      * Updates the data to be signed or verified by a byte.
 731      *
 732      * @param b the byte to use for the update.
 733      *
<span class="line-modified"> 734      * @exception SignatureException if this signature object is not</span>
 735      * initialized properly.
 736      */
 737     public final void update(byte b) throws SignatureException {
 738         if (state == VERIFY || state == SIGN) {
 739             engineUpdate(b);
 740         } else {
 741             throw new SignatureException(&quot;object not initialized for &quot;
 742                                          + &quot;signature or verification&quot;);
 743         }
 744     }
 745 
 746     /**
 747      * Updates the data to be signed or verified, using the specified
 748      * array of bytes.
 749      *
 750      * @param data the byte array to use for the update.
 751      *
<span class="line-modified"> 752      * @exception SignatureException if this signature object is not</span>
 753      * initialized properly.
 754      */
 755     public final void update(byte[] data) throws SignatureException {
 756         update(data, 0, data.length);
 757     }
 758 
 759     /**
 760      * Updates the data to be signed or verified, using the specified
 761      * array of bytes, starting at the specified offset.
 762      *
 763      * @param data the array of bytes.
 764      * @param off the offset to start from in the array of bytes.
 765      * @param len the number of bytes to use, starting at offset.
 766      *
<span class="line-modified"> 767      * @exception SignatureException if this signature object is not</span>
 768      *     initialized properly.
<span class="line-modified"> 769      * @exception IllegalArgumentException if {@code data} is {@code null},</span>
 770      *     or {@code off} or {@code len} is less than 0, or the sum of
 771      *     {@code off} and {@code len} is greater than the length of
 772      *     {@code data}.
 773      */
 774     public final void update(byte[] data, int off, int len)
 775             throws SignatureException {
 776         if (state == SIGN || state == VERIFY) {
 777             if (data == null) {
 778                 throw new IllegalArgumentException(&quot;data is null&quot;);
 779             }
 780             if (off &lt; 0 || len &lt; 0) {
 781                 throw new IllegalArgumentException(&quot;off or len is less than 0&quot;);
 782             }
 783             if (data.length - off &lt; len) {
 784                 throw new IllegalArgumentException
 785                     (&quot;data too small for specified offset and length&quot;);
 786             }
 787             engineUpdate(data, off, len);
 788         } else {
 789             throw new SignatureException(&quot;object not initialized for &quot;
 790                                          + &quot;signature or verification&quot;);
 791         }
 792     }
 793 
 794     /**
 795      * Updates the data to be signed or verified using the specified
 796      * ByteBuffer. Processes the {@code data.remaining()} bytes
 797      * starting at {@code data.position()}.
 798      * Upon return, the buffer&#39;s position will be equal to its limit;
 799      * its limit will not have changed.
 800      *
 801      * @param data the ByteBuffer
 802      *
<span class="line-modified"> 803      * @exception SignatureException if this signature object is not</span>
 804      * initialized properly.
 805      * @since 1.5
 806      */
 807     public final void update(ByteBuffer data) throws SignatureException {
 808         if ((state != SIGN) &amp;&amp; (state != VERIFY)) {
 809             throw new SignatureException(&quot;object not initialized for &quot;
 810                                          + &quot;signature or verification&quot;);
 811         }
 812         if (data == null) {
 813             throw new NullPointerException();
 814         }
 815         engineUpdate(data);
 816     }
 817 
 818     /**
 819      * Returns the name of the algorithm for this signature object.
 820      *
 821      * @return the name of the algorithm for this signature object.
 822      */
 823     public final String getAlgorithm() {
</pre>
<hr />
<pre>
 844             initState = &quot;&lt;initialized for signing&gt;&quot;;
 845             break;
 846         }
 847         return &quot;Signature object: &quot; + getAlgorithm() + initState;
 848     }
 849 
 850     /**
 851      * Sets the specified algorithm parameter to the specified value.
 852      * This method supplies a general-purpose mechanism through
 853      * which it is possible to set the various parameters of this object.
 854      * A parameter may be any settable parameter for the algorithm, such as
 855      * a parameter size, or a source of random bits for signature generation
 856      * (if appropriate), or an indication of whether or not to perform
 857      * a specific but optional computation. A uniform algorithm-specific
 858      * naming scheme for each parameter is desirable but left unspecified
 859      * at this time.
 860      *
 861      * @param param the string identifier of the parameter.
 862      * @param value the parameter value.
 863      *
<span class="line-modified"> 864      * @exception InvalidParameterException if {@code param} is an</span>
 865      * invalid parameter for this signature algorithm engine,
 866      * the parameter is already set
 867      * and cannot be set again, a security exception occurs, and so on.
 868      *
 869      * @see #getParameter
 870      *
 871      * @deprecated Use
 872      * {@link #setParameter(java.security.spec.AlgorithmParameterSpec)
 873      * setParameter}.
 874      */
 875     @Deprecated
 876     public final void setParameter(String param, Object value)
 877             throws InvalidParameterException {
 878         engineSetParameter(param, value);
 879     }
 880 
 881     /**
 882      * Initializes this signature engine with the specified parameter set.
 883      *
 884      * @param params the parameters
 885      *
<span class="line-modified"> 886      * @exception InvalidAlgorithmParameterException if the given parameters</span>
 887      * are inappropriate for this signature engine
 888      *
 889      * @see #getParameters
 890      */
 891     public final void setParameter(AlgorithmParameterSpec params)
 892             throws InvalidAlgorithmParameterException {
 893         engineSetParameter(params);
 894     }
 895 
 896     /**
 897      * Returns the parameters used with this signature object.
 898      *
 899      * &lt;p&gt; If this signature has been previously initialized with parameters
 900      * (by calling the {@code setParameter} method), this method returns
 901      * the same parameters. If this signature has not been initialized with
 902      * parameters, this method may return a combination of default and
 903      * randomly generated parameter values if the underlying
 904      * signature implementation supports it and can successfully generate
 905      * them. Otherwise, {@code null} is returned.
 906      *
</pre>
<hr />
<pre>
 911      */
 912     public final AlgorithmParameters getParameters() {
 913         return engineGetParameters();
 914     }
 915 
 916     /**
 917      * Gets the value of the specified algorithm parameter. This method
 918      * supplies a general-purpose mechanism through which it is possible to
 919      * get the various parameters of this object. A parameter may be any
 920      * settable parameter for the algorithm, such as a parameter size, or
 921      * a source of random bits for signature generation (if appropriate),
 922      * or an indication of whether or not to perform a specific but optional
 923      * computation. A uniform algorithm-specific naming scheme for each
 924      * parameter is desirable but left unspecified at this time.
 925      *
 926      * @param param the string name of the parameter.
 927      *
 928      * @return the object that represents the parameter value, or {@code null} if
 929      * there is none.
 930      *
<span class="line-modified"> 931      * @exception InvalidParameterException if {@code param} is an invalid</span>
 932      * parameter for this engine, or another exception occurs while
 933      * trying to get this parameter.
 934      *
 935      * @see #setParameter(String, Object)
 936      *
 937      * @deprecated
 938      */
 939     @Deprecated
 940     public final Object getParameter(String param)
 941             throws InvalidParameterException {
 942         return engineGetParameter(param);
 943     }
 944 
 945     /**
 946      * Returns a clone if the implementation is cloneable.
 947      *
 948      * @return a clone if the implementation is cloneable.
 949      *
<span class="line-modified"> 950      * @exception CloneNotSupportedException if this is called</span>
 951      * on an implementation that does not support {@code Cloneable}.
 952      */
 953     public Object clone() throws CloneNotSupportedException {
 954         if (this instanceof Cloneable) {
 955             return super.clone();
 956         } else {
 957             throw new CloneNotSupportedException();
 958         }
 959     }
 960 
 961     /*
 962      * The following class allows providers to extend from SignatureSpi
 963      * rather than from Signature. It represents a Signature with an
 964      * encapsulated, provider-supplied SPI object (of type SignatureSpi).
 965      * If the provider implementation is an instance of SignatureSpi, the
 966      * getInstance() methods above return an instance of this class, with
 967      * the SPI object encapsulated.
 968      *
 969      * Note: All SPI methods from the original Signature class have been
 970      * moved up the hierarchy into a new class (SignatureSpi), which has
</pre>
<hr />
<pre>
 994         Delegate(SignatureSpi sigSpi, String algorithm) {
 995             super(algorithm);
 996             this.sigSpi = sigSpi;
 997             this.lock = null; // no lock needed
 998         }
 999 
1000         // used with delayed provider selection
1001         Delegate(Service service,
1002                         Iterator&lt;Service&gt; iterator, String algorithm) {
1003             super(algorithm);
1004             this.firstService = service;
1005             this.serviceIterator = iterator;
1006             this.lock = new Object();
1007         }
1008 
1009         /**
1010          * Returns a clone if the delegate is cloneable.
1011          *
1012          * @return a clone if the delegate is cloneable.
1013          *
<span class="line-modified">1014          * @exception CloneNotSupportedException if this is called on a</span>
1015          * delegate that does not support {@code Cloneable}.
1016          */
1017         public Object clone() throws CloneNotSupportedException {
1018             chooseFirstProvider();
1019             if (sigSpi instanceof Cloneable) {
1020                 SignatureSpi sigSpiClone = (SignatureSpi)sigSpi.clone();
1021                 // Because &#39;algorithm&#39; and &#39;provider&#39; are private
1022                 // members of our supertype, we must perform a cast to
1023                 // access them.
1024                 Signature that =
1025                     new Delegate(sigSpiClone, ((Signature)this).algorithm);
1026                 that.provider = ((Signature)this).provider;
1027                 return that;
1028             } else {
1029                 throw new CloneNotSupportedException();
1030             }
1031         }
1032 
1033         private static SignatureSpi newInstance(Service s)
1034                 throws NoSuchAlgorithmException {
</pre>
<hr />
<pre>
1093                     try {
1094                         sigSpi = newInstance(s);
1095                         provider = s.getProvider();
1096                         // not needed any more
1097                         firstService = null;
1098                         serviceIterator = null;
1099                         return;
1100                     } catch (NoSuchAlgorithmException e) {
1101                         lastException = e;
1102                     }
1103                 }
1104                 ProviderException e = new ProviderException
1105                         (&quot;Could not construct SignatureSpi instance&quot;);
1106                 if (lastException != null) {
1107                     e.initCause(lastException);
1108                 }
1109                 throw e;
1110             }
1111         }
1112 
<span class="line-modified">1113         private void chooseProvider(int type, Key key, SecureRandom random)</span>
<span class="line-modified">1114                 throws InvalidKeyException {</span>



1115             synchronized (lock) {
1116                 if (sigSpi != null) {
<span class="line-removed">1117                     init(sigSpi, type, key, random);</span>
1118                     return;
1119                 }
1120                 Exception lastException = null;
1121                 while ((firstService != null) || serviceIterator.hasNext()) {
1122                     Service s;
1123                     if (firstService != null) {
1124                         s = firstService;
1125                         firstService = null;
1126                     } else {
1127                         s = serviceIterator.next();
1128                     }
1129                     // if provider says it does not support this key, ignore it
<span class="line-modified">1130                     if (s.supportsParameter(key) == false) {</span>
1131                         continue;
1132                     }
1133                     // if instance is not a SignatureSpi, ignore it
1134                     if (isSpi(s) == false) {
1135                         continue;
1136                     }
1137                     try {
1138                         SignatureSpi spi = newInstance(s);
<span class="line-modified">1139                         init(spi, type, key, random);</span>
1140                         provider = s.getProvider();
1141                         sigSpi = spi;
1142                         firstService = null;
1143                         serviceIterator = null;
1144                         return;
1145                     } catch (Exception e) {
1146                         // NoSuchAlgorithmException from newInstance()
1147                         // InvalidKeyException from init()
1148                         // RuntimeException (ProviderException) from init()
1149                         if (lastException == null) {
1150                             lastException = e;
1151                         }
1152                     }
1153                 }
1154                 // no working provider found, fail
1155                 if (lastException instanceof InvalidKeyException) {
1156                     throw (InvalidKeyException)lastException;
1157                 }
1158                 if (lastException instanceof RuntimeException) {
1159                     throw (RuntimeException)lastException;
1160                 }




1161                 String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
1162                 throw new InvalidKeyException
1163                     (&quot;No installed provider supports this key: &quot;
1164                     + k, lastException);
1165             }
1166         }
1167 
<span class="line-modified">1168         private static final int I_PUB     = 1;</span>
<span class="line-modified">1169         private static final int I_PRIV    = 2;</span>
<span class="line-modified">1170         private static final int I_PRIV_SR = 3;</span>



1171 
<span class="line-modified">1172         private void init(SignatureSpi spi, int type, Key  key,</span>
<span class="line-modified">1173                 SecureRandom random) throws InvalidKeyException {</span>

1174             switch (type) {
1175             case I_PUB:
1176                 spi.engineInitVerify((PublicKey)key);
1177                 break;



1178             case I_PRIV:
1179                 spi.engineInitSign((PrivateKey)key);
1180                 break;
1181             case I_PRIV_SR:
1182                 spi.engineInitSign((PrivateKey)key, random);
1183                 break;






1184             default:
1185                 throw new AssertionError(&quot;Internal error: &quot; + type);
1186             }
1187         }
1188 
1189         protected void engineInitVerify(PublicKey publicKey)
1190                 throws InvalidKeyException {
1191             if (sigSpi != null) {
1192                 sigSpi.engineInitVerify(publicKey);
1193             } else {
<span class="line-modified">1194                 chooseProvider(I_PUB, publicKey, null);</span>















1195             }
1196         }
1197 
1198         protected void engineInitSign(PrivateKey privateKey)
1199                 throws InvalidKeyException {
1200             if (sigSpi != null) {
1201                 sigSpi.engineInitSign(privateKey);
1202             } else {
<span class="line-modified">1203                 chooseProvider(I_PRIV, privateKey, null);</span>





1204             }
1205         }
1206 
1207         protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
1208                 throws InvalidKeyException {
1209             if (sigSpi != null) {
1210                 sigSpi.engineInitSign(privateKey, sr);
1211             } else {
<span class="line-modified">1212                 chooseProvider(I_PRIV_SR, privateKey, sr);</span>















1213             }
1214         }
1215 
1216         protected void engineUpdate(byte b) throws SignatureException {
1217             chooseFirstProvider();
1218             sigSpi.engineUpdate(b);
1219         }
1220 
1221         protected void engineUpdate(byte[] b, int off, int len)
1222                 throws SignatureException {
1223             chooseFirstProvider();
1224             sigSpi.engineUpdate(b, off, len);
1225         }
1226 
1227         protected void engineUpdate(ByteBuffer data) {
1228             chooseFirstProvider();
1229             sigSpi.engineUpdate(data);
1230         }
1231 
1232         protected byte[] engineSign() throws SignatureException {
</pre>
<hr />
<pre>
1243         protected boolean engineVerify(byte[] sigBytes)
1244                 throws SignatureException {
1245             chooseFirstProvider();
1246             return sigSpi.engineVerify(sigBytes);
1247         }
1248 
1249         protected boolean engineVerify(byte[] sigBytes, int offset, int length)
1250                 throws SignatureException {
1251             chooseFirstProvider();
1252             return sigSpi.engineVerify(sigBytes, offset, length);
1253         }
1254 
1255         protected void engineSetParameter(String param, Object value)
1256                 throws InvalidParameterException {
1257             chooseFirstProvider();
1258             sigSpi.engineSetParameter(param, value);
1259         }
1260 
1261         protected void engineSetParameter(AlgorithmParameterSpec params)
1262                 throws InvalidAlgorithmParameterException {
<span class="line-modified">1263             chooseFirstProvider();</span>
<span class="line-modified">1264             sigSpi.engineSetParameter(params);</span>








1265         }
1266 
1267         protected Object engineGetParameter(String param)
1268                 throws InvalidParameterException {
1269             chooseFirstProvider();
1270             return sigSpi.engineGetParameter(param);
1271         }
1272 
1273         protected AlgorithmParameters engineGetParameters() {
1274             chooseFirstProvider();
1275             return sigSpi.engineGetParameters();
1276         }
1277     }
1278 
1279     // adapter for RSA/ECB/PKCS1Padding ciphers
1280     @SuppressWarnings(&quot;deprecation&quot;)
1281     private static class CipherAdapter extends SignatureSpi {
1282 
1283         private final Cipher cipher;
1284 
</pre>
</td>
<td>
<hr />
<pre>
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.security.spec.AlgorithmParameterSpec;
  29 import java.util.*;
  30 import java.util.concurrent.ConcurrentHashMap;
  31 import java.io.*;
  32 import java.security.cert.Certificate;
  33 import java.security.cert.X509Certificate;
  34 
  35 import java.nio.ByteBuffer;
  36 
  37 import java.security.Provider.Service;
  38 
  39 import javax.crypto.Cipher;
  40 import javax.crypto.IllegalBlockSizeException;
  41 import javax.crypto.BadPaddingException;
  42 import javax.crypto.NoSuchPaddingException;
<span class="line-added">  43 import jdk.internal.access.JavaSecuritySignatureAccess;</span>
<span class="line-added">  44 import jdk.internal.access.SharedSecrets;</span>
  45 
  46 import sun.security.util.Debug;
  47 import sun.security.jca.*;
  48 import sun.security.jca.GetInstance.Instance;
  49 
  50 /**
  51  * The Signature class is used to provide applications the functionality
  52  * of a digital signature algorithm. Digital signatures are used for
  53  * authentication and integrity assurance of digital data.
  54  *
  55  * &lt;p&gt; The signature algorithm can be, among others, the NIST standard
  56  * DSA, using DSA and SHA-256. The DSA algorithm using the
  57  * SHA-256 message digest algorithm can be specified as {@code SHA256withDSA}.
  58  * In the case of RSA the signing algorithm could be specified as, for example,
  59  * {@code SHA256withRSA}.
  60  * The algorithm name must be specified, as there is no default.
  61  *
  62  * &lt;p&gt; A Signature object can be used to generate and verify digital
  63  * signatures.
  64  *
</pre>
<hr />
<pre>
 103  * &lt;ul&gt;
 104  * &lt;li&gt;{@code SHA1withDSA}&lt;/li&gt;
 105  * &lt;li&gt;{@code SHA256withDSA}&lt;/li&gt;
 106  * &lt;li&gt;{@code SHA1withRSA}&lt;/li&gt;
 107  * &lt;li&gt;{@code SHA256withRSA}&lt;/li&gt;
 108  * &lt;/ul&gt;
 109  * These algorithms are described in the &lt;a href=
 110  * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 111  * Signature section&lt;/a&gt; of the
 112  * Java Security Standard Algorithm Names Specification.
 113  * Consult the release documentation for your implementation to see if any
 114  * other algorithms are supported.
 115  *
 116  * @author Benjamin Renaud
 117  * @since 1.1
 118  *
 119  */
 120 
 121 public abstract class Signature extends SignatureSpi {
 122 
<span class="line-added"> 123     static {</span>
<span class="line-added"> 124         SharedSecrets.setJavaSecuritySignatureAccess(</span>
<span class="line-added"> 125             new JavaSecuritySignatureAccess() {</span>
<span class="line-added"> 126                 @Override</span>
<span class="line-added"> 127                 public void initVerify(Signature s, PublicKey publicKey,</span>
<span class="line-added"> 128                         AlgorithmParameterSpec params)</span>
<span class="line-added"> 129                         throws InvalidKeyException,</span>
<span class="line-added"> 130                         InvalidAlgorithmParameterException {</span>
<span class="line-added"> 131                     s.initVerify(publicKey, params);</span>
<span class="line-added"> 132                 }</span>
<span class="line-added"> 133                 @Override</span>
<span class="line-added"> 134                 public void initVerify(Signature s,</span>
<span class="line-added"> 135                         java.security.cert.Certificate certificate,</span>
<span class="line-added"> 136                         AlgorithmParameterSpec params)</span>
<span class="line-added"> 137                         throws InvalidKeyException,</span>
<span class="line-added"> 138                         InvalidAlgorithmParameterException {</span>
<span class="line-added"> 139                     s.initVerify(certificate, params);</span>
<span class="line-added"> 140                 }</span>
<span class="line-added"> 141                 @Override</span>
<span class="line-added"> 142                 public void initSign(Signature s, PrivateKey privateKey,</span>
<span class="line-added"> 143                         AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added"> 144                         throws InvalidKeyException,</span>
<span class="line-added"> 145                         InvalidAlgorithmParameterException {</span>
<span class="line-added"> 146                     s.initSign(privateKey, params, random);</span>
<span class="line-added"> 147                 }</span>
<span class="line-added"> 148         });</span>
<span class="line-added"> 149     }</span>
<span class="line-added"> 150 </span>
 151     private static final Debug debug =
 152                         Debug.getInstance(&quot;jca&quot;, &quot;Signature&quot;);
 153 
 154     private static final Debug pdebug =
 155                         Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 156     private static final boolean skipDebug =
 157         Debug.isOn(&quot;engine=&quot;) &amp;&amp; !Debug.isOn(&quot;signature&quot;);
 158 
 159     /*
 160      * The algorithm for this signature object.
 161      * This value is used to map an OID to the particular algorithm.
 162      * The mapping is done in AlgorithmObject.algOID(String algorithm)
 163      */
 164     private String algorithm;
 165 
 166     // The provider
 167     Provider provider;
 168 
 169     /**
 170      * Possible {@link #state} value, signifying that
</pre>
<hr />
<pre>
 481         chooseFirstProvider();
 482         return this.provider;
 483     }
 484 
 485     private String getProviderName() {
 486         return (provider == null)  ? &quot;(no provider)&quot; : provider.getName();
 487     }
 488 
 489     void chooseFirstProvider() {
 490         // empty, overridden in Delegate
 491     }
 492 
 493     /**
 494      * Initializes this object for verification. If this method is called
 495      * again with a different argument, it negates the effect
 496      * of this call.
 497      *
 498      * @param publicKey the public key of the identity whose signature is
 499      * going to be verified.
 500      *
<span class="line-modified"> 501      * @throws    InvalidKeyException if the key is invalid.</span>
 502      */
 503     public final void initVerify(PublicKey publicKey)
 504             throws InvalidKeyException {
 505         engineInitVerify(publicKey);
 506         state = VERIFY;
 507 
 508         if (!skipDebug &amp;&amp; pdebug != null) {
 509             pdebug.println(&quot;Signature.&quot; + algorithm +
 510                 &quot; verification algorithm from: &quot; + getProviderName());
 511         }
 512     }
 513 
<span class="line-added"> 514     /**</span>
<span class="line-added"> 515      * Initialize this object for verification. If this method is called</span>
<span class="line-added"> 516      * again with different arguments, it negates the effect</span>
<span class="line-added"> 517      * of this call.</span>
<span class="line-added"> 518      *</span>
<span class="line-added"> 519      * @param publicKey the public key of the identity whose signature is</span>
<span class="line-added"> 520      * going to be verified.</span>
<span class="line-added"> 521      * @param params the parameters used for verifying this signature.</span>
<span class="line-added"> 522      *</span>
<span class="line-added"> 523      * @throws    InvalidKeyException if the key is invalid.</span>
<span class="line-added"> 524      * @throws    InvalidAlgorithmParameterException if the params is invalid.</span>
<span class="line-added"> 525      */</span>
<span class="line-added"> 526     final void initVerify(PublicKey publicKey, AlgorithmParameterSpec params)</span>
<span class="line-added"> 527             throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added"> 528         engineInitVerify(publicKey, params);</span>
<span class="line-added"> 529         state = VERIFY;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531         if (!skipDebug &amp;&amp; pdebug != null) {</span>
<span class="line-added"> 532             pdebug.println(&quot;Signature.&quot; + algorithm +</span>
<span class="line-added"> 533                 &quot; verification algorithm from: &quot; + getProviderName());</span>
<span class="line-added"> 534         }</span>
<span class="line-added"> 535     }</span>
<span class="line-added"> 536 </span>
<span class="line-added"> 537     private static PublicKey getPublicKeyFromCert(Certificate cert)</span>
<span class="line-added"> 538             throws InvalidKeyException {</span>
<span class="line-added"> 539         // If the certificate is of type X509Certificate,</span>
<span class="line-added"> 540         // we should check whether it has a Key Usage</span>
<span class="line-added"> 541         // extension marked as critical.</span>
<span class="line-added"> 542         //if (cert instanceof java.security.cert.X509Certificate) {</span>
<span class="line-added"> 543         if (cert instanceof X509Certificate) {</span>
<span class="line-added"> 544             // Check whether the cert has a key usage extension</span>
<span class="line-added"> 545             // marked as a critical extension.</span>
<span class="line-added"> 546             // The OID for KeyUsage extension is 2.5.29.15.</span>
<span class="line-added"> 547             X509Certificate c = (X509Certificate)cert;</span>
<span class="line-added"> 548             Set&lt;String&gt; critSet = c.getCriticalExtensionOIDs();</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550             if (critSet != null &amp;&amp; !critSet.isEmpty()</span>
<span class="line-added"> 551                 &amp;&amp; critSet.contains(&quot;2.5.29.15&quot;)) {</span>
<span class="line-added"> 552                 boolean[] keyUsageInfo = c.getKeyUsage();</span>
<span class="line-added"> 553                 // keyUsageInfo[0] is for digitalSignature.</span>
<span class="line-added"> 554                 if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))</span>
<span class="line-added"> 555                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);</span>
<span class="line-added"> 556             }</span>
<span class="line-added"> 557         }</span>
<span class="line-added"> 558         return cert.getPublicKey();</span>
<span class="line-added"> 559     }</span>
<span class="line-added"> 560 </span>
 561     /**
 562      * Initializes this object for verification, using the public key from
 563      * the given certificate.
 564      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
 565      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
 566      * extension field implies that the public key in
 567      * the certificate and its corresponding private key are not
 568      * supposed to be used for digital signatures, an
 569      * {@code InvalidKeyException} is thrown.
 570      *
 571      * @param certificate the certificate of the identity whose signature is
 572      * going to be verified.
 573      *
<span class="line-modified"> 574      * @throws    InvalidKeyException  if the public key in the certificate</span>
 575      * is not encoded properly or does not include required  parameter
 576      * information or cannot be used for digital signature purposes.
 577      * @since 1.3
 578      */
 579     public final void initVerify(Certificate certificate)
 580             throws InvalidKeyException {
<span class="line-modified"> 581         engineInitVerify(getPublicKeyFromCert(certificate));</span>
<span class="line-modified"> 582         state = VERIFY;</span>







 583 
<span class="line-modified"> 584         if (!skipDebug &amp;&amp; pdebug != null) {</span>
<span class="line-modified"> 585             pdebug.println(&quot;Signature.&quot; + algorithm +</span>
<span class="line-modified"> 586                 &quot; verification algorithm from: &quot; + getProviderName());</span>




 587         }
<span class="line-added"> 588     }</span>
 589 
<span class="line-modified"> 590     /**</span>
<span class="line-modified"> 591      * Initializes this object for verification, using the public key from</span>
<span class="line-added"> 592      * the given certificate.</span>
<span class="line-added"> 593      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;</span>
<span class="line-added"> 594      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;</span>
<span class="line-added"> 595      * extension field implies that the public key in</span>
<span class="line-added"> 596      * the certificate and its corresponding private key are not</span>
<span class="line-added"> 597      * supposed to be used for digital signatures, an</span>
<span class="line-added"> 598      * {@code InvalidKeyException} is thrown.</span>
<span class="line-added"> 599      *</span>
<span class="line-added"> 600      * @param certificate the certificate of the identity whose signature is</span>
<span class="line-added"> 601      * going to be verified.</span>
<span class="line-added"> 602      * @param params the parameters used for verifying this signature.</span>
<span class="line-added"> 603      *</span>
<span class="line-added"> 604      * @throws    InvalidKeyException  if the public key in the certificate</span>
<span class="line-added"> 605      * is not encoded properly or does not include required  parameter</span>
<span class="line-added"> 606      * information or cannot be used for digital signature purposes.</span>
<span class="line-added"> 607      * @throws    InvalidAlgorithmParameterException if the params is invalid.</span>
<span class="line-added"> 608      *</span>
<span class="line-added"> 609      * @since 13</span>
<span class="line-added"> 610      */</span>
<span class="line-added"> 611     final void initVerify(Certificate certificate,</span>
<span class="line-added"> 612             AlgorithmParameterSpec params)</span>
<span class="line-added"> 613             throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added"> 614         engineInitVerify(getPublicKeyFromCert(certificate), params);</span>
 615         state = VERIFY;
 616 
 617         if (!skipDebug &amp;&amp; pdebug != null) {
 618             pdebug.println(&quot;Signature.&quot; + algorithm +
 619                 &quot; verification algorithm from: &quot; + getProviderName());
 620         }
 621     }
 622 
 623     /**
 624      * Initialize this object for signing. If this method is called
 625      * again with a different argument, it negates the effect
 626      * of this call.
 627      *
 628      * @param privateKey the private key of the identity whose signature
 629      * is going to be generated.
 630      *
<span class="line-modified"> 631      * @throws    InvalidKeyException if the key is invalid.</span>
 632      */
 633     public final void initSign(PrivateKey privateKey)
 634             throws InvalidKeyException {
 635         engineInitSign(privateKey);
 636         state = SIGN;
 637 
 638         if (!skipDebug &amp;&amp; pdebug != null) {
 639             pdebug.println(&quot;Signature.&quot; + algorithm +
 640                 &quot; signing algorithm from: &quot; + getProviderName());
 641         }
 642     }
 643 
 644     /**
 645      * Initialize this object for signing. If this method is called
 646      * again with a different argument, it negates the effect
 647      * of this call.
 648      *
 649      * @param privateKey the private key of the identity whose signature
 650      * is going to be generated.
 651      *
 652      * @param random the source of randomness for this signature.
 653      *
<span class="line-modified"> 654      * @throws    InvalidKeyException if the key is invalid.</span>
 655      */
 656     public final void initSign(PrivateKey privateKey, SecureRandom random)
 657             throws InvalidKeyException {
 658         engineInitSign(privateKey, random);
 659         state = SIGN;
 660 
 661         if (!skipDebug &amp;&amp; pdebug != null) {
 662             pdebug.println(&quot;Signature.&quot; + algorithm +
 663                 &quot; signing algorithm from: &quot; + getProviderName());
 664         }
 665     }
 666 
<span class="line-added"> 667     /**</span>
<span class="line-added"> 668      * Initialize this object for signing. If this method is called</span>
<span class="line-added"> 669      * again with different arguments, it negates the effect</span>
<span class="line-added"> 670      * of this call.</span>
<span class="line-added"> 671      *</span>
<span class="line-added"> 672      * @param privateKey the private key of the identity whose signature</span>
<span class="line-added"> 673      * is going to be generated.</span>
<span class="line-added"> 674      * @param params the parameters used for generating signature.</span>
<span class="line-added"> 675      * @param random the source of randomness for this signature.</span>
<span class="line-added"> 676      *</span>
<span class="line-added"> 677      * @throws    InvalidKeyException if the key is invalid.</span>
<span class="line-added"> 678      * @throws    InvalidAlgorithmParameterException if the params is invalid</span>
<span class="line-added"> 679      */</span>
<span class="line-added"> 680     final void initSign(PrivateKey privateKey,</span>
<span class="line-added"> 681             AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added"> 682             throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added"> 683         engineInitSign(privateKey, params, random);</span>
<span class="line-added"> 684         state = SIGN;</span>
<span class="line-added"> 685 </span>
<span class="line-added"> 686         if (!skipDebug &amp;&amp; pdebug != null) {</span>
<span class="line-added"> 687             pdebug.println(&quot;Signature.&quot; + algorithm +</span>
<span class="line-added"> 688                 &quot; signing algorithm from: &quot; + getProviderName());</span>
<span class="line-added"> 689         }</span>
<span class="line-added"> 690     }</span>
<span class="line-added"> 691 </span>
 692     /**
 693      * Returns the signature bytes of all the data updated.
 694      * The format of the signature depends on the underlying
 695      * signature scheme.
 696      *
 697      * &lt;p&gt;A call to this method resets this signature object to the state
 698      * it was in when previously initialized for signing via a
 699      * call to {@code initSign(PrivateKey)}. That is, the object is
 700      * reset and available to generate another signature from the same
 701      * signer, if desired, via new calls to {@code update} and
 702      * {@code sign}.
 703      *
 704      * @return the signature bytes of the signing operation&#39;s result.
 705      *
<span class="line-modified"> 706      * @throws    SignatureException if this signature object is not</span>
 707      * initialized properly or if this signature algorithm is unable to
 708      * process the input data provided.
 709      */
 710     public final byte[] sign() throws SignatureException {
 711         if (state == SIGN) {
 712             return engineSign();
 713         }
 714         throw new SignatureException(&quot;object not initialized for &quot; +
 715                                      &quot;signing&quot;);
 716     }
 717 
 718     /**
 719      * Finishes the signature operation and stores the resulting signature
 720      * bytes in the provided buffer {@code outbuf}, starting at
 721      * {@code offset}.
 722      * The format of the signature depends on the underlying
 723      * signature scheme.
 724      *
 725      * &lt;p&gt;This signature object is reset to its initial state (the state it
 726      * was in after a call to one of the {@code initSign} methods) and
 727      * can be reused to generate further signatures with the same private key.
 728      *
 729      * @param outbuf buffer for the signature result.
 730      *
 731      * @param offset offset into {@code outbuf} where the signature is
 732      * stored.
 733      *
 734      * @param len number of bytes within {@code outbuf} allotted for the
 735      * signature.
 736      *
 737      * @return the number of bytes placed into {@code outbuf}.
 738      *
<span class="line-modified"> 739      * @throws    SignatureException if this signature object is not</span>
 740      *     initialized properly, if this signature algorithm is unable to
 741      *     process the input data provided, or if {@code len} is less
 742      *     than the actual signature length.
<span class="line-modified"> 743      * @throws    IllegalArgumentException if {@code outbuf} is {@code null},</span>
 744      *     or {@code offset} or {@code len} is less than 0, or the sum of
 745      *     {@code offset} and {@code len} is greater than the length of
 746      *     {@code outbuf}.
 747      *
 748      * @since 1.2
 749      */
 750     public final int sign(byte[] outbuf, int offset, int len)
 751         throws SignatureException {
 752         if (outbuf == null) {
 753             throw new IllegalArgumentException(&quot;No output buffer given&quot;);
 754         }
 755         if (offset &lt; 0 || len &lt; 0) {
 756             throw new IllegalArgumentException(&quot;offset or len is less than 0&quot;);
 757         }
 758         if (outbuf.length - offset &lt; len) {
 759             throw new IllegalArgumentException
 760                 (&quot;Output buffer too small for specified offset and length&quot;);
 761         }
 762         if (state != SIGN) {
 763             throw new SignatureException(&quot;object not initialized for &quot; +
 764                                          &quot;signing&quot;);
 765         }
 766         return engineSign(outbuf, offset, len);
 767     }
 768 
 769     /**
 770      * Verifies the passed-in signature.
 771      *
 772      * &lt;p&gt;A call to this method resets this signature object to the state
 773      * it was in when previously initialized for verification via a
 774      * call to {@code initVerify(PublicKey)}. That is, the object is
 775      * reset and available to verify another signature from the identity
 776      * whose public key was specified in the call to {@code initVerify}.
 777      *
 778      * @param signature the signature bytes to be verified.
 779      *
 780      * @return true if the signature was verified, false if not.
 781      *
<span class="line-modified"> 782      * @throws    SignatureException if this signature object is not</span>
 783      * initialized properly, the passed-in signature is improperly
 784      * encoded or of the wrong type, if this signature algorithm is unable to
 785      * process the input data provided, etc.
 786      */
 787     public final boolean verify(byte[] signature) throws SignatureException {
 788         if (state == VERIFY) {
 789             return engineVerify(signature);
 790         }
 791         throw new SignatureException(&quot;object not initialized for &quot; +
 792                                      &quot;verification&quot;);
 793     }
 794 
 795     /**
 796      * Verifies the passed-in signature in the specified array
 797      * of bytes, starting at the specified offset.
 798      *
 799      * &lt;p&gt;A call to this method resets this signature object to the state
 800      * it was in when previously initialized for verification via a
 801      * call to {@code initVerify(PublicKey)}. That is, the object is
 802      * reset and available to verify another signature from the identity
 803      * whose public key was specified in the call to {@code initVerify}.
 804      *
 805      *
 806      * @param signature the signature bytes to be verified.
 807      * @param offset the offset to start from in the array of bytes.
 808      * @param length the number of bytes to use, starting at offset.
 809      *
 810      * @return true if the signature was verified, false if not.
 811      *
<span class="line-modified"> 812      * @throws    SignatureException if this signature object is not</span>
 813      * initialized properly, the passed-in signature is improperly
 814      * encoded or of the wrong type, if this signature algorithm is unable to
 815      * process the input data provided, etc.
<span class="line-modified"> 816      * @throws    IllegalArgumentException if the {@code signature}</span>
 817      * byte array is {@code null}, or the {@code offset} or {@code length}
 818      * is less than 0, or the sum of the {@code offset} and
 819      * {@code length} is greater than the length of the
 820      * {@code signature} byte array.
 821      * @since 1.4
 822      */
 823     public final boolean verify(byte[] signature, int offset, int length)
 824         throws SignatureException {
 825         if (state == VERIFY) {
 826             if (signature == null) {
 827                 throw new IllegalArgumentException(&quot;signature is null&quot;);
 828             }
 829             if (offset &lt; 0 || length &lt; 0) {
 830                 throw new IllegalArgumentException
 831                     (&quot;offset or length is less than 0&quot;);
 832             }
 833             if (signature.length - offset &lt; length) {
 834                 throw new IllegalArgumentException
 835                     (&quot;signature too small for specified offset and length&quot;);
 836             }
 837 
 838             return engineVerify(signature, offset, length);
 839         }
 840         throw new SignatureException(&quot;object not initialized for &quot; +
 841                                      &quot;verification&quot;);
 842     }
 843 
 844     /**
 845      * Updates the data to be signed or verified by a byte.
 846      *
 847      * @param b the byte to use for the update.
 848      *
<span class="line-modified"> 849      * @throws    SignatureException if this signature object is not</span>
 850      * initialized properly.
 851      */
 852     public final void update(byte b) throws SignatureException {
 853         if (state == VERIFY || state == SIGN) {
 854             engineUpdate(b);
 855         } else {
 856             throw new SignatureException(&quot;object not initialized for &quot;
 857                                          + &quot;signature or verification&quot;);
 858         }
 859     }
 860 
 861     /**
 862      * Updates the data to be signed or verified, using the specified
 863      * array of bytes.
 864      *
 865      * @param data the byte array to use for the update.
 866      *
<span class="line-modified"> 867      * @throws    SignatureException if this signature object is not</span>
 868      * initialized properly.
 869      */
 870     public final void update(byte[] data) throws SignatureException {
 871         update(data, 0, data.length);
 872     }
 873 
 874     /**
 875      * Updates the data to be signed or verified, using the specified
 876      * array of bytes, starting at the specified offset.
 877      *
 878      * @param data the array of bytes.
 879      * @param off the offset to start from in the array of bytes.
 880      * @param len the number of bytes to use, starting at offset.
 881      *
<span class="line-modified"> 882      * @throws    SignatureException if this signature object is not</span>
 883      *     initialized properly.
<span class="line-modified"> 884      * @throws    IllegalArgumentException if {@code data} is {@code null},</span>
 885      *     or {@code off} or {@code len} is less than 0, or the sum of
 886      *     {@code off} and {@code len} is greater than the length of
 887      *     {@code data}.
 888      */
 889     public final void update(byte[] data, int off, int len)
 890             throws SignatureException {
 891         if (state == SIGN || state == VERIFY) {
 892             if (data == null) {
 893                 throw new IllegalArgumentException(&quot;data is null&quot;);
 894             }
 895             if (off &lt; 0 || len &lt; 0) {
 896                 throw new IllegalArgumentException(&quot;off or len is less than 0&quot;);
 897             }
 898             if (data.length - off &lt; len) {
 899                 throw new IllegalArgumentException
 900                     (&quot;data too small for specified offset and length&quot;);
 901             }
 902             engineUpdate(data, off, len);
 903         } else {
 904             throw new SignatureException(&quot;object not initialized for &quot;
 905                                          + &quot;signature or verification&quot;);
 906         }
 907     }
 908 
 909     /**
 910      * Updates the data to be signed or verified using the specified
 911      * ByteBuffer. Processes the {@code data.remaining()} bytes
 912      * starting at {@code data.position()}.
 913      * Upon return, the buffer&#39;s position will be equal to its limit;
 914      * its limit will not have changed.
 915      *
 916      * @param data the ByteBuffer
 917      *
<span class="line-modified"> 918      * @throws    SignatureException if this signature object is not</span>
 919      * initialized properly.
 920      * @since 1.5
 921      */
 922     public final void update(ByteBuffer data) throws SignatureException {
 923         if ((state != SIGN) &amp;&amp; (state != VERIFY)) {
 924             throw new SignatureException(&quot;object not initialized for &quot;
 925                                          + &quot;signature or verification&quot;);
 926         }
 927         if (data == null) {
 928             throw new NullPointerException();
 929         }
 930         engineUpdate(data);
 931     }
 932 
 933     /**
 934      * Returns the name of the algorithm for this signature object.
 935      *
 936      * @return the name of the algorithm for this signature object.
 937      */
 938     public final String getAlgorithm() {
</pre>
<hr />
<pre>
 959             initState = &quot;&lt;initialized for signing&gt;&quot;;
 960             break;
 961         }
 962         return &quot;Signature object: &quot; + getAlgorithm() + initState;
 963     }
 964 
 965     /**
 966      * Sets the specified algorithm parameter to the specified value.
 967      * This method supplies a general-purpose mechanism through
 968      * which it is possible to set the various parameters of this object.
 969      * A parameter may be any settable parameter for the algorithm, such as
 970      * a parameter size, or a source of random bits for signature generation
 971      * (if appropriate), or an indication of whether or not to perform
 972      * a specific but optional computation. A uniform algorithm-specific
 973      * naming scheme for each parameter is desirable but left unspecified
 974      * at this time.
 975      *
 976      * @param param the string identifier of the parameter.
 977      * @param value the parameter value.
 978      *
<span class="line-modified"> 979      * @throws    InvalidParameterException if {@code param} is an</span>
 980      * invalid parameter for this signature algorithm engine,
 981      * the parameter is already set
 982      * and cannot be set again, a security exception occurs, and so on.
 983      *
 984      * @see #getParameter
 985      *
 986      * @deprecated Use
 987      * {@link #setParameter(java.security.spec.AlgorithmParameterSpec)
 988      * setParameter}.
 989      */
 990     @Deprecated
 991     public final void setParameter(String param, Object value)
 992             throws InvalidParameterException {
 993         engineSetParameter(param, value);
 994     }
 995 
 996     /**
 997      * Initializes this signature engine with the specified parameter set.
 998      *
 999      * @param params the parameters
1000      *
<span class="line-modified">1001      * @throws    InvalidAlgorithmParameterException if the given parameters</span>
1002      * are inappropriate for this signature engine
1003      *
1004      * @see #getParameters
1005      */
1006     public final void setParameter(AlgorithmParameterSpec params)
1007             throws InvalidAlgorithmParameterException {
1008         engineSetParameter(params);
1009     }
1010 
1011     /**
1012      * Returns the parameters used with this signature object.
1013      *
1014      * &lt;p&gt; If this signature has been previously initialized with parameters
1015      * (by calling the {@code setParameter} method), this method returns
1016      * the same parameters. If this signature has not been initialized with
1017      * parameters, this method may return a combination of default and
1018      * randomly generated parameter values if the underlying
1019      * signature implementation supports it and can successfully generate
1020      * them. Otherwise, {@code null} is returned.
1021      *
</pre>
<hr />
<pre>
1026      */
1027     public final AlgorithmParameters getParameters() {
1028         return engineGetParameters();
1029     }
1030 
1031     /**
1032      * Gets the value of the specified algorithm parameter. This method
1033      * supplies a general-purpose mechanism through which it is possible to
1034      * get the various parameters of this object. A parameter may be any
1035      * settable parameter for the algorithm, such as a parameter size, or
1036      * a source of random bits for signature generation (if appropriate),
1037      * or an indication of whether or not to perform a specific but optional
1038      * computation. A uniform algorithm-specific naming scheme for each
1039      * parameter is desirable but left unspecified at this time.
1040      *
1041      * @param param the string name of the parameter.
1042      *
1043      * @return the object that represents the parameter value, or {@code null} if
1044      * there is none.
1045      *
<span class="line-modified">1046      * @throws    InvalidParameterException if {@code param} is an invalid</span>
1047      * parameter for this engine, or another exception occurs while
1048      * trying to get this parameter.
1049      *
1050      * @see #setParameter(String, Object)
1051      *
1052      * @deprecated
1053      */
1054     @Deprecated
1055     public final Object getParameter(String param)
1056             throws InvalidParameterException {
1057         return engineGetParameter(param);
1058     }
1059 
1060     /**
1061      * Returns a clone if the implementation is cloneable.
1062      *
1063      * @return a clone if the implementation is cloneable.
1064      *
<span class="line-modified">1065      * @throws    CloneNotSupportedException if this is called</span>
1066      * on an implementation that does not support {@code Cloneable}.
1067      */
1068     public Object clone() throws CloneNotSupportedException {
1069         if (this instanceof Cloneable) {
1070             return super.clone();
1071         } else {
1072             throw new CloneNotSupportedException();
1073         }
1074     }
1075 
1076     /*
1077      * The following class allows providers to extend from SignatureSpi
1078      * rather than from Signature. It represents a Signature with an
1079      * encapsulated, provider-supplied SPI object (of type SignatureSpi).
1080      * If the provider implementation is an instance of SignatureSpi, the
1081      * getInstance() methods above return an instance of this class, with
1082      * the SPI object encapsulated.
1083      *
1084      * Note: All SPI methods from the original Signature class have been
1085      * moved up the hierarchy into a new class (SignatureSpi), which has
</pre>
<hr />
<pre>
1109         Delegate(SignatureSpi sigSpi, String algorithm) {
1110             super(algorithm);
1111             this.sigSpi = sigSpi;
1112             this.lock = null; // no lock needed
1113         }
1114 
1115         // used with delayed provider selection
1116         Delegate(Service service,
1117                         Iterator&lt;Service&gt; iterator, String algorithm) {
1118             super(algorithm);
1119             this.firstService = service;
1120             this.serviceIterator = iterator;
1121             this.lock = new Object();
1122         }
1123 
1124         /**
1125          * Returns a clone if the delegate is cloneable.
1126          *
1127          * @return a clone if the delegate is cloneable.
1128          *
<span class="line-modified">1129          * @throws    CloneNotSupportedException if this is called on a</span>
1130          * delegate that does not support {@code Cloneable}.
1131          */
1132         public Object clone() throws CloneNotSupportedException {
1133             chooseFirstProvider();
1134             if (sigSpi instanceof Cloneable) {
1135                 SignatureSpi sigSpiClone = (SignatureSpi)sigSpi.clone();
1136                 // Because &#39;algorithm&#39; and &#39;provider&#39; are private
1137                 // members of our supertype, we must perform a cast to
1138                 // access them.
1139                 Signature that =
1140                     new Delegate(sigSpiClone, ((Signature)this).algorithm);
1141                 that.provider = ((Signature)this).provider;
1142                 return that;
1143             } else {
1144                 throw new CloneNotSupportedException();
1145             }
1146         }
1147 
1148         private static SignatureSpi newInstance(Service s)
1149                 throws NoSuchAlgorithmException {
</pre>
<hr />
<pre>
1208                     try {
1209                         sigSpi = newInstance(s);
1210                         provider = s.getProvider();
1211                         // not needed any more
1212                         firstService = null;
1213                         serviceIterator = null;
1214                         return;
1215                     } catch (NoSuchAlgorithmException e) {
1216                         lastException = e;
1217                     }
1218                 }
1219                 ProviderException e = new ProviderException
1220                         (&quot;Could not construct SignatureSpi instance&quot;);
1221                 if (lastException != null) {
1222                     e.initCause(lastException);
1223                 }
1224                 throw e;
1225             }
1226         }
1227 
<span class="line-modified">1228         // Used by engineSetParameter/engineInitSign/engineInitVerify() to</span>
<span class="line-modified">1229         // find the right provider with the supplied key, parameters, random source</span>
<span class="line-added">1230         private void chooseProvider(int type, Key key,</span>
<span class="line-added">1231                 AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added">1232                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
1233             synchronized (lock) {
1234                 if (sigSpi != null) {

1235                     return;
1236                 }
1237                 Exception lastException = null;
1238                 while ((firstService != null) || serviceIterator.hasNext()) {
1239                     Service s;
1240                     if (firstService != null) {
1241                         s = firstService;
1242                         firstService = null;
1243                     } else {
1244                         s = serviceIterator.next();
1245                     }
1246                     // if provider says it does not support this key, ignore it
<span class="line-modified">1247                     if (key != null &amp;&amp; s.supportsParameter(key) == false) {</span>
1248                         continue;
1249                     }
1250                     // if instance is not a SignatureSpi, ignore it
1251                     if (isSpi(s) == false) {
1252                         continue;
1253                     }
1254                     try {
1255                         SignatureSpi spi = newInstance(s);
<span class="line-modified">1256                         tryOperation(spi, type, key, params, random);</span>
1257                         provider = s.getProvider();
1258                         sigSpi = spi;
1259                         firstService = null;
1260                         serviceIterator = null;
1261                         return;
1262                     } catch (Exception e) {
1263                         // NoSuchAlgorithmException from newInstance()
1264                         // InvalidKeyException from init()
1265                         // RuntimeException (ProviderException) from init()
1266                         if (lastException == null) {
1267                             lastException = e;
1268                         }
1269                     }
1270                 }
1271                 // no working provider found, fail
1272                 if (lastException instanceof InvalidKeyException) {
1273                     throw (InvalidKeyException)lastException;
1274                 }
1275                 if (lastException instanceof RuntimeException) {
1276                     throw (RuntimeException)lastException;
1277                 }
<span class="line-added">1278                 if (lastException instanceof InvalidAlgorithmParameterException) {</span>
<span class="line-added">1279                     throw (InvalidAlgorithmParameterException)lastException;</span>
<span class="line-added">1280                 }</span>
<span class="line-added">1281 </span>
1282                 String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
1283                 throw new InvalidKeyException
1284                     (&quot;No installed provider supports this key: &quot;
1285                     + k, lastException);
1286             }
1287         }
1288 
<span class="line-modified">1289         private static final int I_PUB           = 1;</span>
<span class="line-modified">1290         private static final int I_PRIV          = 2;</span>
<span class="line-modified">1291         private static final int I_PRIV_SR       = 3;</span>
<span class="line-added">1292         private static final int I_PUB_PARAM     = 4;</span>
<span class="line-added">1293         private static final int I_PRIV_PARAM_SR = 5;</span>
<span class="line-added">1294         private static final int S_PARAM         = 6;</span>
1295 
<span class="line-modified">1296         private void tryOperation(SignatureSpi spi, int type, Key  key,</span>
<span class="line-modified">1297                 AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added">1298                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
1299             switch (type) {
1300             case I_PUB:
1301                 spi.engineInitVerify((PublicKey)key);
1302                 break;
<span class="line-added">1303             case I_PUB_PARAM:</span>
<span class="line-added">1304                 spi.engineInitVerify((PublicKey)key, params);</span>
<span class="line-added">1305                 break;</span>
1306             case I_PRIV:
1307                 spi.engineInitSign((PrivateKey)key);
1308                 break;
1309             case I_PRIV_SR:
1310                 spi.engineInitSign((PrivateKey)key, random);
1311                 break;
<span class="line-added">1312             case I_PRIV_PARAM_SR:</span>
<span class="line-added">1313                 spi.engineInitSign((PrivateKey)key, params, random);</span>
<span class="line-added">1314                 break;</span>
<span class="line-added">1315             case S_PARAM:</span>
<span class="line-added">1316                 spi.engineSetParameter(params);</span>
<span class="line-added">1317                 break;</span>
1318             default:
1319                 throw new AssertionError(&quot;Internal error: &quot; + type);
1320             }
1321         }
1322 
1323         protected void engineInitVerify(PublicKey publicKey)
1324                 throws InvalidKeyException {
1325             if (sigSpi != null) {
1326                 sigSpi.engineInitVerify(publicKey);
1327             } else {
<span class="line-modified">1328                 try {</span>
<span class="line-added">1329                     chooseProvider(I_PUB, publicKey, null, null);</span>
<span class="line-added">1330                 } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="line-added">1331                     // should not happen, re-throw as IKE just in case</span>
<span class="line-added">1332                     throw new InvalidKeyException(iape);</span>
<span class="line-added">1333                 }</span>
<span class="line-added">1334             }</span>
<span class="line-added">1335         }</span>
<span class="line-added">1336 </span>
<span class="line-added">1337         void engineInitVerify(PublicKey publicKey,</span>
<span class="line-added">1338                 AlgorithmParameterSpec params)</span>
<span class="line-added">1339                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">1340             if (sigSpi != null) {</span>
<span class="line-added">1341                 sigSpi.engineInitVerify(publicKey, params);</span>
<span class="line-added">1342             } else {</span>
<span class="line-added">1343                 chooseProvider(I_PUB_PARAM, publicKey, params, null);</span>
1344             }
1345         }
1346 
1347         protected void engineInitSign(PrivateKey privateKey)
1348                 throws InvalidKeyException {
1349             if (sigSpi != null) {
1350                 sigSpi.engineInitSign(privateKey);
1351             } else {
<span class="line-modified">1352                 try {</span>
<span class="line-added">1353                     chooseProvider(I_PRIV, privateKey, null, null);</span>
<span class="line-added">1354                 } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="line-added">1355                     // should not happen, re-throw as IKE just in case</span>
<span class="line-added">1356                     throw new InvalidKeyException(iape);</span>
<span class="line-added">1357                 }</span>
1358             }
1359         }
1360 
1361         protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
1362                 throws InvalidKeyException {
1363             if (sigSpi != null) {
1364                 sigSpi.engineInitSign(privateKey, sr);
1365             } else {
<span class="line-modified">1366                 try {</span>
<span class="line-added">1367                     chooseProvider(I_PRIV_SR, privateKey, null, sr);</span>
<span class="line-added">1368                 } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="line-added">1369                     // should not happen, re-throw as IKE just in case</span>
<span class="line-added">1370                     throw new InvalidKeyException(iape);</span>
<span class="line-added">1371                 }</span>
<span class="line-added">1372             }</span>
<span class="line-added">1373         }</span>
<span class="line-added">1374 </span>
<span class="line-added">1375         void engineInitSign(PrivateKey privateKey,</span>
<span class="line-added">1376                 AlgorithmParameterSpec params, SecureRandom sr)</span>
<span class="line-added">1377                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">1378             if (sigSpi != null) {</span>
<span class="line-added">1379                 sigSpi.engineInitSign(privateKey, params, sr);</span>
<span class="line-added">1380             } else {</span>
<span class="line-added">1381                 chooseProvider(I_PRIV_PARAM_SR, privateKey, params, sr);</span>
1382             }
1383         }
1384 
1385         protected void engineUpdate(byte b) throws SignatureException {
1386             chooseFirstProvider();
1387             sigSpi.engineUpdate(b);
1388         }
1389 
1390         protected void engineUpdate(byte[] b, int off, int len)
1391                 throws SignatureException {
1392             chooseFirstProvider();
1393             sigSpi.engineUpdate(b, off, len);
1394         }
1395 
1396         protected void engineUpdate(ByteBuffer data) {
1397             chooseFirstProvider();
1398             sigSpi.engineUpdate(data);
1399         }
1400 
1401         protected byte[] engineSign() throws SignatureException {
</pre>
<hr />
<pre>
1412         protected boolean engineVerify(byte[] sigBytes)
1413                 throws SignatureException {
1414             chooseFirstProvider();
1415             return sigSpi.engineVerify(sigBytes);
1416         }
1417 
1418         protected boolean engineVerify(byte[] sigBytes, int offset, int length)
1419                 throws SignatureException {
1420             chooseFirstProvider();
1421             return sigSpi.engineVerify(sigBytes, offset, length);
1422         }
1423 
1424         protected void engineSetParameter(String param, Object value)
1425                 throws InvalidParameterException {
1426             chooseFirstProvider();
1427             sigSpi.engineSetParameter(param, value);
1428         }
1429 
1430         protected void engineSetParameter(AlgorithmParameterSpec params)
1431                 throws InvalidAlgorithmParameterException {
<span class="line-modified">1432             if (sigSpi != null) {</span>
<span class="line-modified">1433                 sigSpi.engineSetParameter(params);</span>
<span class="line-added">1434             } else {</span>
<span class="line-added">1435                 try {</span>
<span class="line-added">1436                     chooseProvider(S_PARAM, null, params, null);</span>
<span class="line-added">1437                 } catch (InvalidKeyException ike) {</span>
<span class="line-added">1438                     // should never happen, rethrow just in case</span>
<span class="line-added">1439                     throw new InvalidAlgorithmParameterException(ike);</span>
<span class="line-added">1440                 }</span>
<span class="line-added">1441             }</span>
1442         }
1443 
1444         protected Object engineGetParameter(String param)
1445                 throws InvalidParameterException {
1446             chooseFirstProvider();
1447             return sigSpi.engineGetParameter(param);
1448         }
1449 
1450         protected AlgorithmParameters engineGetParameters() {
1451             chooseFirstProvider();
1452             return sigSpi.engineGetParameters();
1453         }
1454     }
1455 
1456     // adapter for RSA/ECB/PKCS1Padding ciphers
1457     @SuppressWarnings(&quot;deprecation&quot;)
1458     private static class CipherAdapter extends SignatureSpi {
1459 
1460         private final Cipher cipher;
1461 
</pre>
</td>
</tr>
</table>
<center><a href="SecurityPermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SignatureException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
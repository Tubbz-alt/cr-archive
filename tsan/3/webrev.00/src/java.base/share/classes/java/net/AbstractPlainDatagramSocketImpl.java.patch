diff a/src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java b/src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java
--- a/src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java
+++ b/src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,13 +26,16 @@
 
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Objects;
 import java.util.Set;
 
 import sun.net.ResourceManager;
+import sun.net.ext.ExtendedSocketOptions;
+import sun.net.util.IPAddressUtil;
 import sun.security.action.GetPropertyAction;
 
 /**
  * Abstract datagram and multicast socket implementation base class.
  * Note: This is not a public class, so that applets cannot call
@@ -49,10 +52,11 @@
     int timeout = 0;
     boolean connected = false;
     private int trafficClass = 0;
     protected InetAddress connectedAddress = null;
     private int connectedPort = -1;
+    private final boolean isMulticast;
 
     private static final String os =
             GetPropertyAction.privilegedGetProperty("os.name");
 
     /**
@@ -62,17 +66,11 @@
 
     /**
      * Load net library into runtime.
      */
     static {
-        java.security.AccessController.doPrivileged(
-            new java.security.PrivilegedAction<>() {
-                public Void run() {
-                    System.loadLibrary("net");
-                    return null;
-                }
-            });
+        jdk.internal.loader.BootLoader.loadLibrary("net");
     }
 
     private static volatile boolean checkedReusePort;
     private static volatile boolean isReusePortAvailable;
 
@@ -85,39 +83,23 @@
             checkedReusePort = true;
         }
         return isReusePortAvailable;
     }
 
-    /**
-     * Returns a set of SocketOptions supported by this impl and by this impl's
-     * socket (Socket or ServerSocket)
-     *
-     * @return a Set of SocketOptions
-     */
-    @Override
-    protected Set<SocketOption<?>> supportedOptions() {
-        Set<SocketOption<?>> options;
-        if (isReusePortAvailable()) {
-            options = new HashSet<>();
-            options.addAll(super.supportedOptions());
-            options.add(StandardSocketOptions.SO_REUSEPORT);
-            options = Collections.unmodifiableSet(options);
-        } else {
-            options = super.supportedOptions();
-        }
-        return options;
+    AbstractPlainDatagramSocketImpl(boolean isMulticast) {
+        this.isMulticast = isMulticast;
     }
 
     /**
      * Creates a datagram socket
      */
     protected synchronized void create() throws SocketException {
         ResourceManager.beforeUdpCreate();
         fd = new FileDescriptor();
         try {
             datagramSocketCreate();
-            SocketCleanable.register(fd);
+            SocketCleanable.register(fd, false);
         } catch (SocketException ioe) {
             ResourceManager.afterUdpClose();
             fd = null;
             throw ioe;
         }
@@ -126,10 +108,13 @@
     /**
      * Binds a datagram socket to a local port.
      */
     protected synchronized void bind(int lport, InetAddress laddr)
         throws SocketException {
+        if (laddr.isLinkLocalAddress()) {
+            laddr = IPAddressUtil.toScopedAddress(laddr);
+        }
         bind0(lport, laddr);
     }
 
     protected abstract void bind0(int lport, InetAddress laddr)
         throws SocketException;
@@ -137,20 +122,35 @@
     /**
      * Sends a datagram packet. The packet contains the data and the
      * destination address to send the packet to.
      * @param p the packet to be sent.
      */
-    protected abstract void send(DatagramPacket p) throws IOException;
+    protected void send(DatagramPacket p) throws IOException {
+        InetAddress orig = p.getAddress();
+        if (orig.isLinkLocalAddress()) {
+            InetAddress scoped = IPAddressUtil.toScopedAddress(orig);
+            if (orig != scoped) {
+                p = new DatagramPacket(p.getData(), p.getOffset(),
+                                       p.getLength(), scoped, p.getPort());
+            }
+        }
+        send0(p);
+    }
+
+    protected abstract void send0(DatagramPacket p) throws IOException;
 
     /**
      * Connects a datagram socket to a remote destination. This associates the remote
      * address with the local socket so that datagrams may only be sent to this destination
      * and received from this destination.
      * @param address the remote InetAddress to connect to
      * @param port the remote port number
      */
     protected void connect(InetAddress address, int port) throws SocketException {
+        if (address.isLinkLocalAddress()) {
+            address = IPAddressUtil.toScopedAddress(address);
+        }
         connect0(address, port);
         connectedAddress = address;
         connectedPort = port;
         connected = true;
     }
@@ -398,10 +398,122 @@
         }
 
         return result;
     }
 
+    static final ExtendedSocketOptions extendedOptions =
+            ExtendedSocketOptions.getInstance();
+
+    private static final Set<SocketOption<?>> datagramSocketOptions = datagramSocketOptions();
+
+    private static Set<SocketOption<?>> datagramSocketOptions() {
+        HashSet<SocketOption<?>> options = new HashSet<>();
+        options.add(StandardSocketOptions.SO_SNDBUF);
+        options.add(StandardSocketOptions.SO_RCVBUF);
+        options.add(StandardSocketOptions.SO_REUSEADDR);
+        options.add(StandardSocketOptions.SO_BROADCAST);
+        options.add(StandardSocketOptions.IP_TOS);
+        options.add(StandardSocketOptions.IP_MULTICAST_IF);
+        options.add(StandardSocketOptions.IP_MULTICAST_TTL);
+        options.add(StandardSocketOptions.IP_MULTICAST_LOOP);
+        if (isReusePortAvailable())
+            options.add(StandardSocketOptions.SO_REUSEPORT);
+        options.addAll(ExtendedSocketOptions.datagramSocketOptions());
+        return Collections.unmodifiableSet(options);
+    }
+
+    @Override
+    protected Set<SocketOption<?>> supportedOptions() {
+            return datagramSocketOptions;
+    }
+
+    @Override
+    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {
+        Objects.requireNonNull(name);
+        if (!supportedOptions().contains(name))
+            throw new UnsupportedOperationException("'" + name + "' not supported");
+
+        if (!name.type().isInstance(value))
+            throw new IllegalArgumentException("Invalid value '" + value + "'");
+
+        if (isClosed())
+            throw new SocketException("Socket closed");
+
+        if (name == StandardSocketOptions.SO_SNDBUF) {
+            if (((Integer)value).intValue() < 0)
+                throw new IllegalArgumentException("Invalid send buffer size:" + value);
+            setOption(SocketOptions.SO_SNDBUF, value);
+        } else if (name == StandardSocketOptions.SO_RCVBUF) {
+            if (((Integer)value).intValue() < 0)
+                throw new IllegalArgumentException("Invalid recv buffer size:" + value);
+            setOption(SocketOptions.SO_RCVBUF, value);
+        } else if (name == StandardSocketOptions.SO_REUSEADDR) {
+            setOption(SocketOptions.SO_REUSEADDR, value);
+        } else if (name == StandardSocketOptions.SO_REUSEPORT) {
+            setOption(SocketOptions.SO_REUSEPORT, value);
+        } else if (name == StandardSocketOptions.SO_BROADCAST) {
+            setOption(SocketOptions.SO_BROADCAST, value);
+        } else if (name == StandardSocketOptions.IP_TOS) {
+            int i = ((Integer)value).intValue();
+            if (i < 0 || i > 255)
+                throw new IllegalArgumentException("Invalid IP_TOS value: " + value);
+            setOption(SocketOptions.IP_TOS, value);
+        } else if (name == StandardSocketOptions.IP_MULTICAST_IF ) {
+            setOption(SocketOptions.IP_MULTICAST_IF2, value);
+        } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {
+            int i = ((Integer)value).intValue();
+            if (i < 0 || i > 255)
+                throw new IllegalArgumentException("Invalid TTL/hop value: " + value);
+            setTimeToLive((Integer)value);
+        } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {
+            boolean enable = (boolean) value;
+            // Legacy setOption expects true to mean 'disabled'
+            setOption(SocketOptions.IP_MULTICAST_LOOP, !enable);
+        } else if (extendedOptions.isOptionSupported(name)) {
+            extendedOptions.setOption(fd, name, value);
+        } else {
+            throw new AssertionError("unknown option :" + name);
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    protected <T> T getOption(SocketOption<T> name) throws IOException {
+        Objects.requireNonNull(name);
+        if (!supportedOptions().contains(name))
+            throw new UnsupportedOperationException("'" + name + "' not supported");
+
+        if (isClosed())
+            throw new SocketException("Socket closed");
+
+        if (name == StandardSocketOptions.SO_SNDBUF) {
+            return (T) getOption(SocketOptions.SO_SNDBUF);
+        } else if (name == StandardSocketOptions.SO_RCVBUF) {
+            return (T) getOption(SocketOptions.SO_RCVBUF);
+        } else if (name == StandardSocketOptions.SO_REUSEADDR) {
+            return (T) getOption(SocketOptions.SO_REUSEADDR);
+        } else if (name == StandardSocketOptions.SO_REUSEPORT) {
+            return (T) getOption(SocketOptions.SO_REUSEPORT);
+        } else if (name == StandardSocketOptions.SO_BROADCAST) {
+            return (T) getOption(SocketOptions.SO_BROADCAST);
+        } else if (name == StandardSocketOptions.IP_TOS) {
+            return (T) getOption(SocketOptions.IP_TOS);
+        } else if (name == StandardSocketOptions.IP_MULTICAST_IF) {
+            return (T) getOption(SocketOptions.IP_MULTICAST_IF2);
+        } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {
+            return (T) ((Integer) getTimeToLive());
+        } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {
+            boolean disabled = (boolean) getOption(SocketOptions.IP_MULTICAST_LOOP);
+            // Legacy getOption returns true when disabled
+            return (T) Boolean.valueOf(!disabled);
+        } else if (extendedOptions.isOptionSupported(name)) {
+            return (T) extendedOptions.getOption(fd, name);
+        } else {
+            throw new AssertionError("unknown option: " + name);
+        }
+    }
+
     protected abstract void datagramSocketCreate() throws SocketException;
     protected abstract void datagramSocketClose();
     protected abstract void socketSetOption(int opt, Object val)
         throws SocketException;
     protected abstract Object socketGetOption(int opt) throws SocketException;

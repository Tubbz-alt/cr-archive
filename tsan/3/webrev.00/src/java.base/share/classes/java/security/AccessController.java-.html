<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/security/AccessController.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.lang.annotation.ElementType;
  29 import java.lang.annotation.Retention;
  30 import java.lang.annotation.RetentionPolicy;
  31 import java.lang.annotation.Target;
  32 import java.lang.ref.Reference;
  33 
  34 import jdk.internal.vm.annotation.Hidden;
  35 import sun.security.util.Debug;
  36 import sun.security.util.SecurityConstants;
  37 import jdk.internal.reflect.CallerSensitive;
  38 import jdk.internal.reflect.Reflection;
  39 import jdk.internal.vm.annotation.DontInline;
  40 import jdk.internal.vm.annotation.ForceInline;
  41 import jdk.internal.vm.annotation.ReservedStackAccess;
  42 
  43 /**
  44  * &lt;p&gt; The AccessController class is used for access control operations
  45  * and decisions.
  46  *
  47  * &lt;p&gt; More specifically, the AccessController class is used for
  48  * three purposes:
  49  *
  50  * &lt;ul&gt;
  51  * &lt;li&gt; to decide whether an access to a critical system
  52  * resource is to be allowed or denied, based on the security policy
  53  * currently in effect,
  54  * &lt;li&gt;to mark code as being &quot;privileged&quot;, thus affecting subsequent
  55  * access determinations, and
  56  * &lt;li&gt;to obtain a &quot;snapshot&quot; of the current calling context so
  57  * access-control decisions from a different context can be made with
  58  * respect to the saved context. &lt;/ul&gt;
  59  *
  60  * &lt;p&gt; The {@link #checkPermission(Permission) checkPermission} method
  61  * determines whether the access request indicated by a specified
  62  * permission should be granted or denied. A sample call appears
  63  * below. In this example, {@code checkPermission} will determine
  64  * whether or not to grant &quot;read&quot; access to the file named &quot;testFile&quot; in
  65  * the &quot;/temp&quot; directory.
  66  *
  67  * &lt;pre&gt;
  68  *
  69  * FilePermission perm = new FilePermission(&quot;/temp/testFile&quot;, &quot;read&quot;);
  70  * AccessController.checkPermission(perm);
  71  *
  72  * &lt;/pre&gt;
  73  *
  74  * &lt;p&gt; If a requested access is allowed,
  75  * {@code checkPermission} returns quietly. If denied, an
  76  * AccessControlException is
  77  * thrown. AccessControlException can also be thrown if the requested
  78  * permission is of an incorrect type or contains an invalid value.
  79  * Such information is given whenever possible.
  80  *
  81  * Suppose the current thread traversed m callers, in the order of caller 1
  82  * to caller 2 to caller m. Then caller m invoked the
  83  * {@code checkPermission} method.
  84  * The {@code checkPermission} method determines whether access
  85  * is granted or denied based on the following algorithm:
  86  *
  87  *  &lt;pre&gt; {@code
  88  * for (int i = m; i &gt; 0; i--) {
  89  *
  90  *     if (caller i&#39;s domain does not have the permission)
  91  *         throw AccessControlException
  92  *
  93  *     else if (caller i is marked as privileged) {
  94  *         if (a context was specified in the call to doPrivileged)
  95  *             context.checkPermission(permission)
  96  *         if (limited permissions were specified in the call to doPrivileged) {
  97  *             for (each limited permission) {
  98  *                 if (the limited permission implies the requested permission)
  99  *                     return;
 100  *             }
 101  *         } else
 102  *             return;
 103  *     }
 104  * }
 105  *
 106  * // Next, check the context inherited when the thread was created.
 107  * // Whenever a new thread is created, the AccessControlContext at
 108  * // that time is stored and associated with the new thread, as the
 109  * // &quot;inherited&quot; context.
 110  *
 111  * inheritedContext.checkPermission(permission);
 112  * }&lt;/pre&gt;
 113  *
 114  * &lt;p&gt; A caller can be marked as being &quot;privileged&quot;
 115  * (see {@link #doPrivileged(PrivilegedAction) doPrivileged} and below).
 116  * When making access control decisions, the {@code checkPermission}
 117  * method stops checking if it reaches a caller that
 118  * was marked as &quot;privileged&quot; via a {@code doPrivileged}
 119  * call without a context argument (see below for information about a
 120  * context argument). If that caller&#39;s domain has the
 121  * specified permission and at least one limiting permission argument (if any)
 122  * implies the requested permission, no further checking is done and
 123  * {@code checkPermission}
 124  * returns quietly, indicating that the requested access is allowed.
 125  * If that domain does not have the specified permission, an exception
 126  * is thrown, as usual. If the caller&#39;s domain had the specified permission
 127  * but it was not implied by any limiting permission arguments given in the call
 128  * to {@code doPrivileged} then the permission checking continues
 129  * until there are no more callers or another {@code doPrivileged}
 130  * call matches the requested permission and returns normally.
 131  *
 132  * &lt;p&gt; The normal use of the &quot;privileged&quot; feature is as follows. If you
 133  * don&#39;t need to return a value from within the &quot;privileged&quot; block, do
 134  * the following:
 135  *
 136  *  &lt;pre&gt; {@code
 137  * somemethod() {
 138  *     ...normal code here...
 139  *     AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 140  *         public Void run() {
 141  *             // privileged code goes here, for example:
 142  *             System.loadLibrary(&quot;awt&quot;);
 143  *             return null; // nothing to return
 144  *         }
 145  *     });
 146  *     ...normal code here...
 147  * }}&lt;/pre&gt;
 148  *
 149  * &lt;p&gt;
 150  * PrivilegedAction is an interface with a single method, named
 151  * {@code run}.
 152  * The above example shows creation of an implementation
 153  * of that interface; a concrete implementation of the
 154  * {@code run} method is supplied.
 155  * When the call to {@code doPrivileged} is made, an
 156  * instance of the PrivilegedAction implementation is passed
 157  * to it. The {@code doPrivileged} method calls the
 158  * {@code run} method from the PrivilegedAction
 159  * implementation after enabling privileges, and returns the
 160  * {@code run} method&#39;s return value as the
 161  * {@code doPrivileged} return value (which is
 162  * ignored in this example).
 163  *
 164  * &lt;p&gt; If you need to return a value, you can do something like the following:
 165  *
 166  *  &lt;pre&gt; {@code
 167  * somemethod() {
 168  *     ...normal code here...
 169  *     String user = AccessController.doPrivileged(
 170  *         new PrivilegedAction&lt;String&gt;() {
 171  *         public String run() {
 172  *             return System.getProperty(&quot;user.name&quot;);
 173  *             }
 174  *         });
 175  *     ...normal code here...
 176  * }}&lt;/pre&gt;
 177  *
 178  * &lt;p&gt;If the action performed in your {@code run} method could
 179  * throw a &quot;checked&quot; exception (those listed in the {@code throws} clause
 180  * of a method), then you need to use the
 181  * {@code PrivilegedExceptionAction} interface instead of the
 182  * {@code PrivilegedAction} interface:
 183  *
 184  *  &lt;pre&gt; {@code
 185  * somemethod() throws FileNotFoundException {
 186  *     ...normal code here...
 187  *     try {
 188  *         FileInputStream fis = AccessController.doPrivileged(
 189  *         new PrivilegedExceptionAction&lt;FileInputStream&gt;() {
 190  *             public FileInputStream run() throws FileNotFoundException {
 191  *                 return new FileInputStream(&quot;someFile&quot;);
 192  *             }
 193  *         });
 194  *     } catch (PrivilegedActionException e) {
 195  *         // e.getException() should be an instance of FileNotFoundException,
 196  *         // as only &quot;checked&quot; exceptions will be &quot;wrapped&quot; in a
 197  *         // PrivilegedActionException.
 198  *         throw (FileNotFoundException) e.getException();
 199  *     }
 200  *     ...normal code here...
 201  *  }}&lt;/pre&gt;
 202  *
 203  * &lt;p&gt; Be *very* careful in your use of the &quot;privileged&quot; construct, and
 204  * always remember to make the privileged code section as small as possible.
 205  * You can pass {@code Permission} arguments to further limit the
 206  * scope of the &quot;privilege&quot; (see below).
 207  *
 208  *
 209  * &lt;p&gt; Note that {@code checkPermission} always performs security checks
 210  * within the context of the currently executing thread.
 211  * Sometimes a security check that should be made within a given context
 212  * will actually need to be done from within a
 213  * &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
 214  * The {@link #getContext() getContext} method and
 215  * AccessControlContext class are provided
 216  * for this situation. The {@code getContext} method takes a &quot;snapshot&quot;
 217  * of the current calling context, and places
 218  * it in an AccessControlContext object, which it returns. A sample call is
 219  * the following:
 220  *
 221  * &lt;pre&gt;
 222  *
 223  * AccessControlContext acc = AccessController.getContext()
 224  *
 225  * &lt;/pre&gt;
 226  *
 227  * &lt;p&gt;
 228  * AccessControlContext itself has a {@code checkPermission} method
 229  * that makes access decisions based on the context &lt;i&gt;it&lt;/i&gt; encapsulates,
 230  * rather than that of the current execution thread.
 231  * Code within a different context can thus call that method on the
 232  * previously-saved AccessControlContext object. A sample call is the
 233  * following:
 234  *
 235  * &lt;pre&gt;
 236  *
 237  * acc.checkPermission(permission)
 238  *
 239  * &lt;/pre&gt;
 240  *
 241  * &lt;p&gt; There are also times where you don&#39;t know a priori which permissions
 242  * to check the context against. In these cases you can use the
 243  * doPrivileged method that takes a context. You can also limit the scope
 244  * of the privileged code by passing additional {@code Permission}
 245  * parameters.
 246  *
 247  *  &lt;pre&gt; {@code
 248  * somemethod() {
 249  *     AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 250  *         public Object run() {
 251  *             // Code goes here. Any permission checks within this
 252  *             // run method will require that the intersection of the
 253  *             // caller&#39;s protection domain and the snapshot&#39;s
 254  *             // context have the desired permission. If a requested
 255  *             // permission is not implied by the limiting FilePermission
 256  *             // argument then checking of the thread continues beyond the
 257  *             // caller of doPrivileged.
 258  *         }
 259  *     }, acc, new FilePermission(&quot;/temp/*&quot;, read));
 260  *     ...normal code here...
 261  * }}&lt;/pre&gt;
 262  * &lt;p&gt; Passing a limiting {@code Permission} argument of an instance of
 263  * {@code AllPermission} is equivalent to calling the equivalent
 264  * {@code doPrivileged} method without limiting {@code Permission}
 265  * arguments. Passing a zero length array of {@code Permission} disables
 266  * the code privileges so that checking always continues beyond the caller of
 267  * that {@code doPrivileged} method.
 268  *
 269  * @see AccessControlContext
 270  *
 271  * @author Li Gong
 272  * @author Roland Schemers
 273  * @since 1.2
 274  */
 275 
 276 public final class AccessController {
 277 
 278     /**
 279      * Don&#39;t allow anyone to instantiate an AccessController
 280      */
 281     private AccessController() { }
 282 
 283     /**
 284      * Performs the specified {@code PrivilegedAction} with privileges
 285      * enabled. The action is performed with &lt;i&gt;all&lt;/i&gt; of the permissions
 286      * possessed by the caller&#39;s protection domain.
 287      *
 288      * &lt;p&gt; If the action&#39;s {@code run} method throws an (unchecked)
 289      * exception, it will propagate through this method.
 290      *
 291      * &lt;p&gt; Note that any DomainCombiner associated with the current
 292      * AccessControlContext will be ignored while the action is performed.
 293      *
 294      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 295      *                  {@code run} method.
 296      *
 297      * @param action the action to be performed.
 298      *
 299      * @return the value returned by the action&#39;s {@code run} method.
 300      *
 301      * @exception NullPointerException if the action is {@code null}
 302      *
 303      * @see #doPrivileged(PrivilegedAction,AccessControlContext)
 304      * @see #doPrivileged(PrivilegedExceptionAction)
 305      * @see #doPrivilegedWithCombiner(PrivilegedAction)
 306      * @see java.security.DomainCombiner
 307      */
 308 
 309     @CallerSensitive
 310     public static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action)
 311     {
 312         return executePrivileged(action, null, Reflection.getCallerClass());
 313     }
 314 
 315     /**
 316      * Performs the specified {@code PrivilegedAction} with privileges
 317      * enabled. The action is performed with &lt;i&gt;all&lt;/i&gt; of the permissions
 318      * possessed by the caller&#39;s protection domain.
 319      *
 320      * &lt;p&gt; If the action&#39;s {@code run} method throws an (unchecked)
 321      * exception, it will propagate through this method.
 322      *
 323      * &lt;p&gt; This method preserves the current AccessControlContext&#39;s
 324      * DomainCombiner (which may be null) while the action is performed.
 325      *
 326      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 327      *                  {@code run} method.
 328      *
 329      * @param action the action to be performed.
 330      *
 331      * @return the value returned by the action&#39;s {@code run} method.
 332      *
 333      * @exception NullPointerException if the action is {@code null}
 334      *
 335      * @see #doPrivileged(PrivilegedAction)
 336      * @see java.security.DomainCombiner
 337      *
 338      * @since 1.6
 339      */
 340     @CallerSensitive
 341     public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedAction&lt;T&gt; action) {
 342         AccessControlContext acc = getStackAccessControlContext();
 343         if (acc == null) {
 344             return AccessController.doPrivileged(action);
 345         }
 346         DomainCombiner dc = acc.getAssignedCombiner();
 347         return AccessController.doPrivileged(action,
 348                                              preserveCombiner(dc, Reflection.getCallerClass()));
 349     }
 350 
 351 
 352     /**
 353      * Performs the specified {@code PrivilegedAction} with privileges
 354      * enabled and restricted by the specified {@code AccessControlContext}.
 355      * The action is performed with the intersection of the permissions
 356      * possessed by the caller&#39;s protection domain, and those possessed
 357      * by the domains represented by the specified {@code AccessControlContext}.
 358      * &lt;p&gt;
 359      * If the action&#39;s {@code run} method throws an (unchecked) exception,
 360      * it will propagate through this method.
 361      * &lt;p&gt;
 362      * If a security manager is installed and the specified
 363      * {@code AccessControlContext} was not created by system code and the
 364      * caller&#39;s {@code ProtectionDomain} has not been granted the
 365      * {@literal &quot;createAccessControlContext&quot;}
 366      * {@link java.security.SecurityPermission}, then the action is performed
 367      * with no permissions.
 368      *
 369      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 370      *                  {@code run} method.
 371      * @param action the action to be performed.
 372      * @param context an &lt;i&gt;access control context&lt;/i&gt;
 373      *                representing the restriction to be applied to the
 374      *                caller&#39;s domain&#39;s privileges before performing
 375      *                the specified action.  If the context is
 376      *                {@code null}, then no additional restriction is applied.
 377      *
 378      * @return the value returned by the action&#39;s {@code run} method.
 379      *
 380      * @exception NullPointerException if the action is {@code null}
 381      *
 382      * @see #doPrivileged(PrivilegedAction)
 383      * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 384      */
 385     @CallerSensitive
 386     public static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action,
 387                                      AccessControlContext context)
 388     {
 389         Class&lt;?&gt; caller = Reflection.getCallerClass();
 390         context = checkContext(context, caller);
 391         return executePrivileged(action, context, caller);
 392     }
 393 
 394 
 395     /**
 396      * Performs the specified {@code PrivilegedAction} with privileges
 397      * enabled and restricted by the specified
 398      * {@code AccessControlContext} and with a privilege scope limited
 399      * by specified {@code Permission} arguments.
 400      *
 401      * The action is performed with the intersection of the permissions
 402      * possessed by the caller&#39;s protection domain, and those possessed
 403      * by the domains represented by the specified
 404      * {@code AccessControlContext}.
 405      * &lt;p&gt;
 406      * If the action&#39;s {@code run} method throws an (unchecked) exception,
 407      * it will propagate through this method.
 408      * &lt;p&gt;
 409      * If a security manager is installed and the specified
 410      * {@code AccessControlContext} was not created by system code and the
 411      * caller&#39;s {@code ProtectionDomain} has not been granted the
 412      * {@literal &quot;createAccessControlContext&quot;}
 413      * {@link java.security.SecurityPermission}, then the action is performed
 414      * with no permissions.
 415      *
 416      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 417      *                  {@code run} method.
 418      * @param action the action to be performed.
 419      * @param context an &lt;i&gt;access control context&lt;/i&gt;
 420      *                representing the restriction to be applied to the
 421      *                caller&#39;s domain&#39;s privileges before performing
 422      *                the specified action.  If the context is
 423      *                {@code null},
 424      *                then no additional restriction is applied.
 425      * @param perms the {@code Permission} arguments which limit the
 426      *              scope of the caller&#39;s privileges. The number of arguments
 427      *              is variable.
 428      *
 429      * @return the value returned by the action&#39;s {@code run} method.
 430      *
 431      * @throws NullPointerException if action or perms or any element of
 432      *         perms is {@code null}
 433      *
 434      * @see #doPrivileged(PrivilegedAction)
 435      * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 436      *
 437      * @since 1.8
 438      */
 439     @CallerSensitive
 440     public static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action,
 441         AccessControlContext context, Permission... perms) {
 442 
 443         AccessControlContext parent = getContext();
 444         if (perms == null) {
 445             throw new NullPointerException(&quot;null permissions parameter&quot;);
 446         }
 447         Class&lt;?&gt; caller = Reflection.getCallerClass();
 448         return AccessController.doPrivileged(action, createWrapper(null,
 449             caller, parent, context, perms));
 450     }
 451 
 452 
 453     /**
 454      * Performs the specified {@code PrivilegedAction} with privileges
 455      * enabled and restricted by the specified
 456      * {@code AccessControlContext} and with a privilege scope limited
 457      * by specified {@code Permission} arguments.
 458      *
 459      * The action is performed with the intersection of the permissions
 460      * possessed by the caller&#39;s protection domain, and those possessed
 461      * by the domains represented by the specified
 462      * {@code AccessControlContext}.
 463      * &lt;p&gt;
 464      * If the action&#39;s {@code run} method throws an (unchecked) exception,
 465      * it will propagate through this method.
 466      *
 467      * &lt;p&gt; This method preserves the current AccessControlContext&#39;s
 468      * DomainCombiner (which may be null) while the action is performed.
 469      * &lt;p&gt;
 470      * If a security manager is installed and the specified
 471      * {@code AccessControlContext} was not created by system code and the
 472      * caller&#39;s {@code ProtectionDomain} has not been granted the
 473      * {@literal &quot;createAccessControlContext&quot;}
 474      * {@link java.security.SecurityPermission}, then the action is performed
 475      * with no permissions.
 476      *
 477      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 478      *                  {@code run} method.
 479      * @param action the action to be performed.
 480      * @param context an &lt;i&gt;access control context&lt;/i&gt;
 481      *                representing the restriction to be applied to the
 482      *                caller&#39;s domain&#39;s privileges before performing
 483      *                the specified action.  If the context is
 484      *                {@code null},
 485      *                then no additional restriction is applied.
 486      * @param perms the {@code Permission} arguments which limit the
 487      *              scope of the caller&#39;s privileges. The number of arguments
 488      *              is variable.
 489      *
 490      * @return the value returned by the action&#39;s {@code run} method.
 491      *
 492      * @throws NullPointerException if action or perms or any element of
 493      *         perms is {@code null}
 494      *
 495      * @see #doPrivileged(PrivilegedAction)
 496      * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 497      * @see java.security.DomainCombiner
 498      *
 499      * @since 1.8
 500      */
 501     @CallerSensitive
 502     public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedAction&lt;T&gt; action,
 503         AccessControlContext context, Permission... perms) {
 504 
 505         AccessControlContext parent = getContext();
 506         DomainCombiner dc = parent.getCombiner();
 507         if (dc == null &amp;&amp; context != null) {
 508             dc = context.getCombiner();
 509         }
 510         if (perms == null) {
 511             throw new NullPointerException(&quot;null permissions parameter&quot;);
 512         }
 513         Class&lt;?&gt; caller = Reflection.getCallerClass();
 514         return AccessController.doPrivileged(action, createWrapper(dc, caller,
 515             parent, context, perms));
 516     }
 517 
 518     /**
 519      * Performs the specified {@code PrivilegedExceptionAction} with
 520      * privileges enabled.  The action is performed with &lt;i&gt;all&lt;/i&gt; of the
 521      * permissions possessed by the caller&#39;s protection domain.
 522      *
 523      * &lt;p&gt; If the action&#39;s {@code run} method throws an &lt;i&gt;unchecked&lt;/i&gt;
 524      * exception, it will propagate through this method.
 525      *
 526      * &lt;p&gt; Note that any DomainCombiner associated with the current
 527      * AccessControlContext will be ignored while the action is performed.
 528      *
 529      * @param &lt;T&gt; the type of the value returned by the
 530      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 531      *
 532      * @param action the action to be performed
 533      *
 534      * @return the value returned by the action&#39;s {@code run} method
 535      *
 536      * @exception PrivilegedActionException if the specified action&#39;s
 537      *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
 538      * @exception NullPointerException if the action is {@code null}
 539      *
 540      * @see #doPrivileged(PrivilegedAction)
 541      * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 542      * @see #doPrivilegedWithCombiner(PrivilegedExceptionAction)
 543      * @see java.security.DomainCombiner
 544      */
 545     @CallerSensitive
 546     public static &lt;T&gt; T
 547         doPrivileged(PrivilegedExceptionAction&lt;T&gt; action)
 548         throws PrivilegedActionException
 549     {
 550         AccessControlContext context = null;
 551         Class&lt;?&gt; caller = Reflection.getCallerClass();
 552         try {
 553             return executePrivileged(action, context, caller);
 554         } catch (RuntimeException e) {
 555             throw e;
 556         } catch (Exception e) {
 557             throw wrapException(e);
 558         }
 559     }
 560 
 561     /**
 562      * Performs the specified {@code PrivilegedExceptionAction} with
 563      * privileges enabled.  The action is performed with &lt;i&gt;all&lt;/i&gt; of the
 564      * permissions possessed by the caller&#39;s protection domain.
 565      *
 566      * &lt;p&gt; If the action&#39;s {@code run} method throws an &lt;i&gt;unchecked&lt;/i&gt;
 567      * exception, it will propagate through this method.
 568      *
 569      * &lt;p&gt; This method preserves the current AccessControlContext&#39;s
 570      * DomainCombiner (which may be null) while the action is performed.
 571      *
 572      * @param &lt;T&gt; the type of the value returned by the
 573      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 574      *
 575      * @param action the action to be performed.
 576      *
 577      * @return the value returned by the action&#39;s {@code run} method
 578      *
 579      * @exception PrivilegedActionException if the specified action&#39;s
 580      *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
 581      * @exception NullPointerException if the action is {@code null}
 582      *
 583      * @see #doPrivileged(PrivilegedAction)
 584      * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 585      * @see java.security.DomainCombiner
 586      *
 587      * @since 1.6
 588      */
 589     @CallerSensitive
 590     public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedExceptionAction&lt;T&gt; action)
 591         throws PrivilegedActionException
 592     {
 593         AccessControlContext acc = getStackAccessControlContext();
 594         if (acc == null) {
 595             return AccessController.doPrivileged(action);
 596         }
 597         DomainCombiner dc = acc.getAssignedCombiner();
 598         return AccessController.doPrivileged(action,
 599                                              preserveCombiner(dc, Reflection.getCallerClass()));
 600     }
 601 
 602     /**
 603      * preserve the combiner across the doPrivileged call
 604      */
 605     private static AccessControlContext preserveCombiner(DomainCombiner combiner,
 606                                                          Class&lt;?&gt; caller)
 607     {
 608         return createWrapper(combiner, caller, null, null, null);
 609     }
 610 
 611     /**
 612      * Create a wrapper to contain the limited privilege scope data.
 613      */
 614     private static AccessControlContext
 615         createWrapper(DomainCombiner combiner, Class&lt;?&gt; caller,
 616                       AccessControlContext parent, AccessControlContext context,
 617                       Permission[] perms)
 618     {
 619         ProtectionDomain callerPD = getProtectionDomain(caller);
 620         // check if caller is authorized to create context
 621         if (System.getSecurityManager() != null &amp;&amp;
 622             context != null &amp;&amp; !context.isAuthorized() &amp;&amp;
 623             !callerPD.implies(SecurityConstants.CREATE_ACC_PERMISSION))
 624         {
 625             return getInnocuousAcc();
 626         } else {
 627             return new AccessControlContext(callerPD, combiner, parent,
 628                                             context, perms);
 629         }
 630     }
 631 
 632     private static class AccHolder {
 633         // An AccessControlContext with no granted permissions.
 634         // Only initialized on demand when getInnocuousAcc() is called.
 635         static final AccessControlContext innocuousAcc =
 636             new AccessControlContext(new ProtectionDomain[] {
 637                                      new ProtectionDomain(null, null) });
 638     }
 639     private static AccessControlContext getInnocuousAcc() {
 640         return AccHolder.innocuousAcc;
 641     }
 642 
 643     private static native ProtectionDomain getProtectionDomain(final Class&lt;?&gt; caller);
 644 
 645     /**
 646      * Performs the specified {@code PrivilegedExceptionAction} with
 647      * privileges enabled and restricted by the specified
 648      * {@code AccessControlContext}.  The action is performed with the
 649      * intersection of the permissions possessed by the caller&#39;s
 650      * protection domain, and those possessed by the domains represented by the
 651      * specified {@code AccessControlContext}.
 652      * &lt;p&gt;
 653      * If the action&#39;s {@code run} method throws an &lt;i&gt;unchecked&lt;/i&gt;
 654      * exception, it will propagate through this method.
 655      * &lt;p&gt;
 656      * If a security manager is installed and the specified
 657      * {@code AccessControlContext} was not created by system code and the
 658      * caller&#39;s {@code ProtectionDomain} has not been granted the
 659      * {@literal &quot;createAccessControlContext&quot;}
 660      * {@link java.security.SecurityPermission}, then the action is performed
 661      * with no permissions.
 662      *
 663      * @param &lt;T&gt; the type of the value returned by the
 664      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 665      * @param action the action to be performed
 666      * @param context an &lt;i&gt;access control context&lt;/i&gt;
 667      *                representing the restriction to be applied to the
 668      *                caller&#39;s domain&#39;s privileges before performing
 669      *                the specified action.  If the context is
 670      *                {@code null}, then no additional restriction is applied.
 671      *
 672      * @return the value returned by the action&#39;s {@code run} method
 673      *
 674      * @exception PrivilegedActionException if the specified action&#39;s
 675      *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
 676      * @exception NullPointerException if the action is {@code null}
 677      *
 678      * @see #doPrivileged(PrivilegedAction)
 679      * @see #doPrivileged(PrivilegedAction,AccessControlContext)
 680      */
 681     @CallerSensitive
 682     public static &lt;T&gt; T
 683         doPrivileged(PrivilegedExceptionAction&lt;T&gt; action,
 684                      AccessControlContext context)
 685         throws PrivilegedActionException
 686     {
 687         Class&lt;?&gt; caller = Reflection.getCallerClass();
 688         context = checkContext(context, caller);
 689         try {
 690             return executePrivileged(action, context, caller);
 691         } catch (RuntimeException e) {
 692             throw e;
 693         } catch (Exception e) {
 694             throw wrapException(e);
 695         }
 696     }
 697 
 698     private static AccessControlContext checkContext(AccessControlContext context,
 699         Class&lt;?&gt; caller)
 700     {
 701         // check if caller is authorized to create context
 702         if (System.getSecurityManager() != null &amp;&amp;
 703             context != null &amp;&amp; !context.isAuthorized() &amp;&amp;
 704             context != getInnocuousAcc())
 705         {
 706             ProtectionDomain callerPD = getProtectionDomain(caller);
 707             if (callerPD != null &amp;&amp; !callerPD.implies(SecurityConstants.CREATE_ACC_PERMISSION)) {
 708                 return getInnocuousAcc();
 709             }
 710         }
 711         return context;
 712     }
 713 
 714     /**
 715      * The value needs to be physically located in the frame, so that it
 716      * can be found by a stack walk.
 717      */
 718     @Hidden
 719     private static native void ensureMaterializedForStackWalk(Object o);
 720 
 721     /**
 722      * Sanity check that the caller context is indeed privileged.
 723      *
 724      * Used by executePrivileged to make sure the frame is properly
 725      * recognized by the VM.
 726      */
 727     private static boolean isPrivileged() {
 728         AccessControlContext ctx = getStackAccessControlContext();
 729         return ctx == null || ctx.isPrivileged();
 730     }
 731 
 732     /**
 733      * Execute the action as privileged.
 734      *
 735      * The VM recognizes this method as special, so any changes to the
 736      * name or signature require corresponding changes in
 737      * getStackAccessControlContext().
 738      */
 739     @Hidden
 740     @ForceInline
 741     private static &lt;T&gt; T
 742         executePrivileged(PrivilegedAction&lt;T&gt; action,
 743                           AccessControlContext context,
 744                           Class&lt;?&gt; caller)
 745     {
 746         // Ensure context has a physical value in the frame
 747         if (context != null) {
 748             ensureMaterializedForStackWalk(context);
 749         }
 750 
 751         assert isPrivileged(); // sanity check invariant
 752         T result = action.run();
 753         assert isPrivileged(); // sanity check invariant
 754 
 755         // Keep these alive across the run() call so they can be
 756         // retrieved by getStackAccessControlContext().
 757         Reference.reachabilityFence(context);
 758         Reference.reachabilityFence(caller);
 759         return result;
 760     }
 761 
 762     /**
 763      * Execute the action as privileged.
 764      *
 765      * The VM recognizes this method as special, so any changes to the
 766      * name or signature require corresponding changes in
 767      * getStackAccessControlContext().
 768      */
 769     @Hidden
 770     @ForceInline
 771     private static &lt;T&gt; T
 772         executePrivileged(PrivilegedExceptionAction&lt;T&gt; action,
 773                           AccessControlContext context,
 774                           Class&lt;?&gt; caller)
 775         throws Exception
 776     {
 777         // Ensure context has a physical value in the frame
 778         if (context != null) {
 779             ensureMaterializedForStackWalk(context);
 780         }
 781 
 782         assert isPrivileged(); // sanity check invariant
 783         T result = action.run();
 784         assert isPrivileged(); // sanity check invariant
 785 
 786         // Keep these alive across the run() call so they can be
 787         // retrieved by getStackAccessControlContext().
 788         Reference.reachabilityFence(context);
 789         Reference.reachabilityFence(caller);
 790         return result;
 791     }
 792 
 793 
 794     /**
 795      * Wrap an exception.  The annotations are used in a best effort to
 796      * avoid StackOverflowError in the caller.  Inlining the callees as
 797      * well and tail-call elimination could also help here, but are not
 798      * needed for correctness, only quality of implementation.
 799      */
 800     @Hidden
 801     @ForceInline
 802     @ReservedStackAccess
 803     private static PrivilegedActionException wrapException(Exception e) {
 804         return new PrivilegedActionException(e);
 805     }
 806 
 807     /**
 808      * Performs the specified {@code PrivilegedExceptionAction} with
 809      * privileges enabled and restricted by the specified
 810      * {@code AccessControlContext} and with a privilege scope limited by
 811      * specified {@code Permission} arguments.
 812      *
 813      * The action is performed with the intersection of the permissions
 814      * possessed by the caller&#39;s protection domain, and those possessed
 815      * by the domains represented by the specified
 816      * {@code AccessControlContext}.
 817      * &lt;p&gt;
 818      * If the action&#39;s {@code run} method throws an (unchecked) exception,
 819      * it will propagate through this method.
 820      * &lt;p&gt;
 821      * If a security manager is installed and the specified
 822      * {@code AccessControlContext} was not created by system code and the
 823      * caller&#39;s {@code ProtectionDomain} has not been granted the
 824      * {@literal &quot;createAccessControlContext&quot;}
 825      * {@link java.security.SecurityPermission}, then the action is performed
 826      * with no permissions.
 827      *
 828      * @param &lt;T&gt; the type of the value returned by the
 829      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 830      * @param action the action to be performed.
 831      * @param context an &lt;i&gt;access control context&lt;/i&gt;
 832      *                representing the restriction to be applied to the
 833      *                caller&#39;s domain&#39;s privileges before performing
 834      *                the specified action.  If the context is
 835      *                {@code null},
 836      *                then no additional restriction is applied.
 837      * @param perms the {@code Permission} arguments which limit the
 838      *              scope of the caller&#39;s privileges. The number of arguments
 839      *              is variable.
 840      *
 841      * @return the value returned by the action&#39;s {@code run} method.
 842      *
 843      * @throws PrivilegedActionException if the specified action&#39;s
 844      *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
 845      * @throws NullPointerException if action or perms or any element of
 846      *         perms is {@code null}
 847      *
 848      * @see #doPrivileged(PrivilegedAction)
 849      * @see #doPrivileged(PrivilegedAction,AccessControlContext)
 850      *
 851      * @since 1.8
 852      */
 853     @CallerSensitive
 854     public static &lt;T&gt; T doPrivileged(PrivilegedExceptionAction&lt;T&gt; action,
 855                                      AccessControlContext context, Permission... perms)
 856         throws PrivilegedActionException
 857     {
 858         AccessControlContext parent = getContext();
 859         if (perms == null) {
 860             throw new NullPointerException(&quot;null permissions parameter&quot;);
 861         }
 862         Class&lt;?&gt; caller = Reflection.getCallerClass();
 863         return AccessController.doPrivileged(action, createWrapper(null, caller, parent, context, perms));
 864     }
 865 
 866 
 867     /**
 868      * Performs the specified {@code PrivilegedExceptionAction} with
 869      * privileges enabled and restricted by the specified
 870      * {@code AccessControlContext} and with a privilege scope limited by
 871      * specified {@code Permission} arguments.
 872      *
 873      * The action is performed with the intersection of the permissions
 874      * possessed by the caller&#39;s protection domain, and those possessed
 875      * by the domains represented by the specified
 876      * {@code AccessControlContext}.
 877      * &lt;p&gt;
 878      * If the action&#39;s {@code run} method throws an (unchecked) exception,
 879      * it will propagate through this method.
 880      *
 881      * &lt;p&gt; This method preserves the current AccessControlContext&#39;s
 882      * DomainCombiner (which may be null) while the action is performed.
 883      * &lt;p&gt;
 884      * If a security manager is installed and the specified
 885      * {@code AccessControlContext} was not created by system code and the
 886      * caller&#39;s {@code ProtectionDomain} has not been granted the
 887      * {@literal &quot;createAccessControlContext&quot;}
 888      * {@link java.security.SecurityPermission}, then the action is performed
 889      * with no permissions.
 890      *
 891      * @param &lt;T&gt; the type of the value returned by the
 892      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 893      * @param action the action to be performed.
 894      * @param context an &lt;i&gt;access control context&lt;/i&gt;
 895      *                representing the restriction to be applied to the
 896      *                caller&#39;s domain&#39;s privileges before performing
 897      *                the specified action.  If the context is
 898      *                {@code null},
 899      *                then no additional restriction is applied.
 900      * @param perms the {@code Permission} arguments which limit the
 901      *              scope of the caller&#39;s privileges. The number of arguments
 902      *              is variable.
 903      *
 904      * @return the value returned by the action&#39;s {@code run} method.
 905      *
 906      * @throws PrivilegedActionException if the specified action&#39;s
 907      *         {@code run} method threw a &lt;i&gt;checked&lt;/i&gt; exception
 908      * @throws NullPointerException if action or perms or any element of
 909      *         perms is {@code null}
 910      *
 911      * @see #doPrivileged(PrivilegedAction)
 912      * @see #doPrivileged(PrivilegedAction,AccessControlContext)
 913      * @see java.security.DomainCombiner
 914      *
 915      * @since 1.8
 916      */
 917     @CallerSensitive
 918     public static &lt;T&gt; T doPrivilegedWithCombiner(PrivilegedExceptionAction&lt;T&gt; action,
 919                                                  AccessControlContext context,
 920                                                  Permission... perms)
 921         throws PrivilegedActionException
 922     {
 923         AccessControlContext parent = getContext();
 924         DomainCombiner dc = parent.getCombiner();
 925         if (dc == null &amp;&amp; context != null) {
 926             dc = context.getCombiner();
 927         }
 928         if (perms == null) {
 929             throw new NullPointerException(&quot;null permissions parameter&quot;);
 930         }
 931         Class&lt;?&gt; caller = Reflection.getCallerClass();
 932         return AccessController.doPrivileged(action, createWrapper(dc, caller,
 933             parent, context, perms));
 934     }
 935 
 936     /**
 937      * Returns the AccessControl context. i.e., it gets
 938      * the protection domains of all the callers on the stack,
 939      * starting at the first class with a non-null
 940      * ProtectionDomain.
 941      *
 942      * @return the access control context based on the current stack or
 943      *         null if there was only privileged system code.
 944      */
 945 
 946     private static native AccessControlContext getStackAccessControlContext();
 947 
 948 
 949     /**
 950      * Returns the &quot;inherited&quot; AccessControl context. This is the context
 951      * that existed when the thread was created. Package private so
 952      * AccessControlContext can use it.
 953      */
 954 
 955     static native AccessControlContext getInheritedAccessControlContext();
 956 
 957     /**
 958      * This method takes a &quot;snapshot&quot; of the current calling context, which
 959      * includes the current Thread&#39;s inherited AccessControlContext and any
 960      * limited privilege scope, and places it in an AccessControlContext object.
 961      * This context may then be checked at a later point, possibly in another thread.
 962      *
 963      * @see AccessControlContext
 964      *
 965      * @return the AccessControlContext based on the current context.
 966      */
 967 
 968     public static AccessControlContext getContext()
 969     {
 970         AccessControlContext acc = getStackAccessControlContext();
 971         if (acc == null) {
 972             // all we had was privileged system code. We don&#39;t want
 973             // to return null though, so we construct a real ACC.
 974             return new AccessControlContext(null, true);
 975         } else {
 976             return acc.optimize();
 977         }
 978     }
 979 
 980     /**
 981      * Determines whether the access request indicated by the
 982      * specified permission should be allowed or denied, based on
 983      * the current AccessControlContext and security policy.
 984      * This method quietly returns if the access request
 985      * is permitted, or throws an AccessControlException otherwise. The
 986      * getPermission method of the AccessControlException returns the
 987      * {@code perm} Permission object instance.
 988      *
 989      * @param perm the requested permission.
 990      *
 991      * @exception AccessControlException if the specified permission
 992      *            is not permitted, based on the current security policy.
 993      * @exception NullPointerException if the specified permission
 994      *            is {@code null} and is checked based on the
 995      *            security policy currently in effect.
 996      */
 997 
 998     public static void checkPermission(Permission perm)
 999         throws AccessControlException
1000     {
1001         //System.err.println(&quot;checkPermission &quot;+perm);
1002         //Thread.currentThread().dumpStack();
1003 
1004         if (perm == null) {
1005             throw new NullPointerException(&quot;permission can&#39;t be null&quot;);
1006         }
1007 
1008         AccessControlContext stack = getStackAccessControlContext();
1009         // if context is null, we had privileged system code on the stack.
1010         if (stack == null) {
1011             Debug debug = AccessControlContext.getDebug();
1012             boolean dumpDebug = false;
1013             if (debug != null) {
1014                 dumpDebug = !Debug.isOn(&quot;codebase=&quot;);
1015                 dumpDebug &amp;= !Debug.isOn(&quot;permission=&quot;) ||
1016                     Debug.isOn(&quot;permission=&quot; + perm.getClass().getCanonicalName());
1017             }
1018 
1019             if (dumpDebug &amp;&amp; Debug.isOn(&quot;stack&quot;)) {
1020                 Thread.dumpStack();
1021             }
1022 
1023             if (dumpDebug &amp;&amp; Debug.isOn(&quot;domain&quot;)) {
1024                 debug.println(&quot;domain (context is null)&quot;);
1025             }
1026 
1027             if (dumpDebug) {
1028                 debug.println(&quot;access allowed &quot;+perm);
1029             }
1030             return;
1031         }
1032 
1033         AccessControlContext acc = stack.optimize();
1034         acc.checkPermission(perm);
1035     }
1036 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Integer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InstantiationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InternalError.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Integer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 330      * @param   i   an integer to be converted to a string.
 331      * @return  the string representation of the unsigned integer value
 332      *          represented by the argument in binary (base&amp;nbsp;2).
 333      * @see #parseUnsignedInt(String, int)
 334      * @see #toUnsignedString(int, int)
 335      * @since   1.0.2
 336      */
 337     public static String toBinaryString(int i) {
 338         return toUnsignedString0(i, 1);
 339     }
 340 
 341     /**
 342      * Convert the integer to an unsigned number.
 343      */
 344     private static String toUnsignedString0(int val, int shift) {
 345         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
 346         int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
 347         int chars = Math.max(((mag + (shift - 1)) / shift), 1);
 348         if (COMPACT_STRINGS) {
 349             byte[] buf = new byte[chars];
<span class="line-modified"> 350             formatUnsignedInt(val, shift, buf, 0, chars);</span>
 351             return new String(buf, LATIN1);
 352         } else {
 353             byte[] buf = new byte[chars * 2];
<span class="line-modified"> 354             formatUnsignedIntUTF16(val, shift, buf, 0, chars);</span>
 355             return new String(buf, UTF16);
 356         }
 357     }
 358 
 359     /**
<span class="line-modified"> 360      * Format an {@code int} (treated as unsigned) into a character buffer. If</span>
 361      * {@code len} exceeds the formatted ASCII representation of {@code val},
 362      * {@code buf} will be padded with leading zeroes.
 363      *
 364      * @param val the unsigned int to format
 365      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified"> 366      * @param buf the character buffer to write to</span>
<span class="line-removed"> 367      * @param offset the offset in the destination buffer to start at</span>
 368      * @param len the number of characters to write
 369      */
<span class="line-modified"> 370     static void formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) {</span>
<span class="line-modified"> 371         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;</span>
<span class="line-removed"> 372         // assert offset &gt;= 0 &amp;&amp; offset &lt; buf.length : &quot;illegal offset&quot;;</span>
<span class="line-removed"> 373         // assert len &gt; 0 &amp;&amp; (offset + len) &lt;= buf.length : &quot;illegal length&quot;;</span>
<span class="line-removed"> 374         int charPos = offset + len;</span>
<span class="line-removed"> 375         int radix = 1 &lt;&lt; shift;</span>
<span class="line-removed"> 376         int mask = radix - 1;</span>
<span class="line-removed"> 377         do {</span>
<span class="line-removed"> 378             buf[--charPos] = Integer.digits[val &amp; mask];</span>
<span class="line-removed"> 379             val &gt;&gt;&gt;= shift;</span>
<span class="line-removed"> 380         } while (charPos &gt; offset);</span>
<span class="line-removed"> 381     }</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383     /** byte[]/LATIN1 version    */</span>
<span class="line-removed"> 384     static void formatUnsignedInt(int val, int shift, byte[] buf, int offset, int len) {</span>
<span class="line-removed"> 385         int charPos = offset + len;</span>
 386         int radix = 1 &lt;&lt; shift;
 387         int mask = radix - 1;
 388         do {
 389             buf[--charPos] = (byte)Integer.digits[val &amp; mask];
 390             val &gt;&gt;&gt;= shift;
<span class="line-modified"> 391         } while (charPos &gt; offset);</span>
 392     }
 393 
<span class="line-modified"> 394     /** byte[]/UTF16 version    */</span>
<span class="line-modified"> 395     private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int offset, int len) {</span>
<span class="line-modified"> 396         int charPos = offset + len;</span>









 397         int radix = 1 &lt;&lt; shift;
 398         int mask = radix - 1;
 399         do {
 400             StringUTF16.putChar(buf, --charPos, Integer.digits[val &amp; mask]);
 401             val &gt;&gt;&gt;= shift;
<span class="line-modified"> 402         } while (charPos &gt; offset);</span>
 403     }
 404 
 405     static final byte[] DigitTens = {
 406         &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;,
 407         &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;,
 408         &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;,
 409         &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;,
 410         &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;,
 411         &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;,
 412         &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;,
 413         &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;,
 414         &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;,
 415         &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;,
 416         } ;
 417 
 418     static final byte[] DigitOnes = {
 419         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 420         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 421         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 422         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
</pre>
<hr />
<pre>
 587      * &lt;blockquote&gt;&lt;pre&gt;
 588      * parseInt(&quot;0&quot;, 10) returns 0
 589      * parseInt(&quot;473&quot;, 10) returns 473
 590      * parseInt(&quot;+42&quot;, 10) returns 42
 591      * parseInt(&quot;-0&quot;, 10) returns 0
 592      * parseInt(&quot;-FF&quot;, 16) returns -255
 593      * parseInt(&quot;1100110&quot;, 2) returns 102
 594      * parseInt(&quot;2147483647&quot;, 10) returns 2147483647
 595      * parseInt(&quot;-2147483648&quot;, 10) returns -2147483648
 596      * parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException
 597      * parseInt(&quot;99&quot;, 8) throws a NumberFormatException
 598      * parseInt(&quot;Kona&quot;, 10) throws a NumberFormatException
 599      * parseInt(&quot;Kona&quot;, 27) returns 411787
 600      * &lt;/pre&gt;&lt;/blockquote&gt;
 601      *
 602      * @param      s   the {@code String} containing the integer
 603      *                  representation to be parsed
 604      * @param      radix   the radix to be used while parsing {@code s}.
 605      * @return     the integer represented by the string argument in the
 606      *             specified radix.
<span class="line-modified"> 607      * @exception  NumberFormatException if the {@code String}</span>
 608      *             does not contain a parsable {@code int}.
 609      */
 610     public static int parseInt(String s, int radix)
 611                 throws NumberFormatException
 612     {
 613         /*
 614          * WARNING: This method may be invoked early during VM initialization
 615          * before IntegerCache is initialized. Care must be taken to not use
 616          * the valueOf method.
 617          */
 618 
 619         if (s == null) {
 620             throw new NumberFormatException(&quot;null&quot;);
 621         }
 622 
 623         if (radix &lt; Character.MIN_RADIX) {
 624             throw new NumberFormatException(&quot;radix &quot; + radix +
 625                                             &quot; less than Character.MIN_RADIX&quot;);
 626         }
 627 
</pre>
<hr />
<pre>
 681      *                  representation to be parsed
 682      * @param      beginIndex   the beginning index, inclusive.
 683      * @param      endIndex     the ending index, exclusive.
 684      * @param      radix   the radix to be used while parsing {@code s}.
 685      * @return     the signed {@code int} represented by the subsequence in
 686      *             the specified radix.
 687      * @throws     NullPointerException  if {@code s} is null.
 688      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 689      *             negative, or if {@code beginIndex} is greater than
 690      *             {@code endIndex} or if {@code endIndex} is greater than
 691      *             {@code s.length()}.
 692      * @throws     NumberFormatException  if the {@code CharSequence} does not
 693      *             contain a parsable {@code int} in the specified
 694      *             {@code radix}, or if {@code radix} is either smaller than
 695      *             {@link java.lang.Character#MIN_RADIX} or larger than
 696      *             {@link java.lang.Character#MAX_RADIX}.
 697      * @since  9
 698      */
 699     public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
 700                 throws NumberFormatException {
<span class="line-modified"> 701         s = Objects.requireNonNull(s);</span>
 702 
 703         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 704             throw new IndexOutOfBoundsException();
 705         }
 706         if (radix &lt; Character.MIN_RADIX) {
 707             throw new NumberFormatException(&quot;radix &quot; + radix +
 708                                             &quot; less than Character.MIN_RADIX&quot;);
 709         }
 710         if (radix &gt; Character.MAX_RADIX) {
 711             throw new NumberFormatException(&quot;radix &quot; + radix +
 712                                             &quot; greater than Character.MAX_RADIX&quot;);
 713         }
 714 
 715         boolean negative = false;
 716         int i = beginIndex;
 717         int limit = -Integer.MAX_VALUE;
 718 
 719         if (i &lt; endIndex) {
 720             char firstChar = s.charAt(i);
 721             if (firstChar &lt; &#39;0&#39;) { // Possible leading &quot;+&quot; or &quot;-&quot;
</pre>
<hr />
<pre>
 752             return negative ? result : -result;
 753         } else {
 754             throw NumberFormatException.forInputString(&quot;&quot;, radix);
 755         }
 756     }
 757 
 758     /**
 759      * Parses the string argument as a signed decimal integer. The
 760      * characters in the string must all be decimal digits, except
 761      * that the first character may be an ASCII minus sign {@code &#39;-&#39;}
 762      * ({@code &#39;\u005Cu002D&#39;}) to indicate a negative value or an
 763      * ASCII plus sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) to
 764      * indicate a positive value. The resulting integer value is
 765      * returned, exactly as if the argument and the radix 10 were
 766      * given as arguments to the {@link #parseInt(java.lang.String,
 767      * int)} method.
 768      *
 769      * @param s    a {@code String} containing the {@code int}
 770      *             representation to be parsed
 771      * @return     the integer value represented by the argument in decimal.
<span class="line-modified"> 772      * @exception  NumberFormatException  if the string does not contain a</span>
 773      *               parsable integer.
 774      */
 775     public static int parseInt(String s) throws NumberFormatException {
 776         return parseInt(s,10);
 777     }
 778 
 779     /**
 780      * Parses the string argument as an unsigned integer in the radix
 781      * specified by the second argument.  An unsigned integer maps the
 782      * values usually associated with negative numbers to positive
 783      * numbers larger than {@code MAX_VALUE}.
 784      *
 785      * The characters in the string must all be digits of the
 786      * specified radix (as determined by whether {@link
 787      * java.lang.Character#digit(char, int)} returns a nonnegative
 788      * value), except that the first character may be an ASCII plus
 789      * sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}). The resulting
 790      * integer value is returned.
 791      *
 792      * &lt;p&gt;An exception of type {@code NumberFormatException} is
</pre>
<hr />
<pre>
 864      *                 {@code int} representation to be parsed
 865      * @param      beginIndex   the beginning index, inclusive.
 866      * @param      endIndex     the ending index, exclusive.
 867      * @param      radix   the radix to be used while parsing {@code s}.
 868      * @return     the unsigned {@code int} represented by the subsequence in
 869      *             the specified radix.
 870      * @throws     NullPointerException  if {@code s} is null.
 871      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 872      *             negative, or if {@code beginIndex} is greater than
 873      *             {@code endIndex} or if {@code endIndex} is greater than
 874      *             {@code s.length()}.
 875      * @throws     NumberFormatException  if the {@code CharSequence} does not
 876      *             contain a parsable unsigned {@code int} in the specified
 877      *             {@code radix}, or if {@code radix} is either smaller than
 878      *             {@link java.lang.Character#MIN_RADIX} or larger than
 879      *             {@link java.lang.Character#MAX_RADIX}.
 880      * @since  9
 881      */
 882     public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)
 883                 throws NumberFormatException {
<span class="line-modified"> 884         s = Objects.requireNonNull(s);</span>
 885 
 886         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 887             throw new IndexOutOfBoundsException();
 888         }
 889         int start = beginIndex, len = endIndex - beginIndex;
 890 
 891         if (len &gt; 0) {
 892             char firstChar = s.charAt(start);
 893             if (firstChar == &#39;-&#39;) {
 894                 throw new
 895                     NumberFormatException(String.format(&quot;Illegal leading minus sign &quot; +
 896                                                        &quot;on unsigned string %s.&quot;, s));
 897             } else {
 898                 if (len &lt;= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits
 899                         (radix == 10 &amp;&amp; len &lt;= 9)) { // Integer.MAX_VALUE in base 10 is 10 digits
 900                     return parseInt(s, start, start + len, radix);
 901                 } else {
 902                     long ell = Long.parseLong(s, start, start + len, radix);
 903                     if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) {
 904                         return (int) ell;
</pre>
<hr />
<pre>
 939      * extracted from the specified {@code String} when parsed
 940      * with the radix given by the second argument. The first argument
 941      * is interpreted as representing a signed integer in the radix
 942      * specified by the second argument, exactly as if the arguments
 943      * were given to the {@link #parseInt(java.lang.String, int)}
 944      * method. The result is an {@code Integer} object that
 945      * represents the integer value specified by the string.
 946      *
 947      * &lt;p&gt;In other words, this method returns an {@code Integer}
 948      * object equal to the value of:
 949      *
 950      * &lt;blockquote&gt;
 951      *  {@code new Integer(Integer.parseInt(s, radix))}
 952      * &lt;/blockquote&gt;
 953      *
 954      * @param      s   the string to be parsed.
 955      * @param      radix the radix to be used in interpreting {@code s}
 956      * @return     an {@code Integer} object holding the value
 957      *             represented by the string argument in the specified
 958      *             radix.
<span class="line-modified"> 959      * @exception NumberFormatException if the {@code String}</span>
 960      *            does not contain a parsable {@code int}.
 961      */
 962     public static Integer valueOf(String s, int radix) throws NumberFormatException {
 963         return Integer.valueOf(parseInt(s,radix));
 964     }
 965 
 966     /**
 967      * Returns an {@code Integer} object holding the
 968      * value of the specified {@code String}. The argument is
 969      * interpreted as representing a signed decimal integer, exactly
 970      * as if the argument were given to the {@link
 971      * #parseInt(java.lang.String)} method. The result is an
 972      * {@code Integer} object that represents the integer value
 973      * specified by the string.
 974      *
 975      * &lt;p&gt;In other words, this method returns an {@code Integer}
 976      * object equal to the value of:
 977      *
 978      * &lt;blockquote&gt;
 979      *  {@code new Integer(Integer.parseInt(s))}
 980      * &lt;/blockquote&gt;
 981      *
 982      * @param      s   the string to be parsed.
 983      * @return     an {@code Integer} object holding the value
 984      *             represented by the string argument.
<span class="line-modified"> 985      * @exception  NumberFormatException  if the string cannot be parsed</span>
 986      *             as an integer.
 987      */
 988     public static Integer valueOf(String s) throws NumberFormatException {
 989         return Integer.valueOf(parseInt(s, 10));
 990     }
 991 
 992     /**
 993      * Cache to support the object identity semantics of autoboxing for values between
 994      * -128 and 127 (inclusive) as required by JLS.
 995      *
 996      * The cache is initialized on first usage.  The size of the cache
 997      * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.
 998      * During VM initialization, java.lang.Integer.IntegerCache.high property
 999      * may be set and saved in the private system properties in the
1000      * jdk.internal.misc.VM class.
1001      *
1002      * WARNING: The cache is archived with CDS and reloaded from the shared
1003      * archive at runtime. The archived cache (Integer[]) and Integer objects
1004      * reside in the closed archive heap regions. Care should be taken when
1005      * changing the implementation and the cache array should not be assigned
</pre>
<hr />
<pre>
1103      * {@code parseInt} method for radix 10.
1104      *
1105      * @param   s   the {@code String} to be converted to an {@code Integer}.
1106      * @throws      NumberFormatException if the {@code String} does not
1107      *              contain a parsable integer.
1108      *
1109      * @deprecated
1110      * It is rarely appropriate to use this constructor.
1111      * Use {@link #parseInt(String)} to convert a string to a
1112      * {@code int} primitive, or use {@link #valueOf(String)}
1113      * to convert a string to an {@code Integer} object.
1114      */
1115     @Deprecated(since=&quot;9&quot;)
1116     public Integer(String s) throws NumberFormatException {
1117         this.value = parseInt(s, 10);
1118     }
1119 
1120     /**
1121      * Returns the value of this {@code Integer} as a {@code byte}
1122      * after a narrowing primitive conversion.
<span class="line-modified">1123      * @jls 5.1.3 Narrowing Primitive Conversions</span>
1124      */
1125     public byte byteValue() {
1126         return (byte)value;
1127     }
1128 
1129     /**
1130      * Returns the value of this {@code Integer} as a {@code short}
1131      * after a narrowing primitive conversion.
<span class="line-modified">1132      * @jls 5.1.3 Narrowing Primitive Conversions</span>
1133      */
1134     public short shortValue() {
1135         return (short)value;
1136     }
1137 
1138     /**
1139      * Returns the value of this {@code Integer} as an
1140      * {@code int}.
1141      */
1142     @HotSpotIntrinsicCandidate
1143     public int intValue() {
1144         return value;
1145     }
1146 
1147     /**
1148      * Returns the value of this {@code Integer} as a {@code long}
1149      * after a widening primitive conversion.
<span class="line-modified">1150      * @jls 5.1.2 Widening Primitive Conversions</span>
1151      * @see Integer#toUnsignedLong(int)
1152      */
1153     public long longValue() {
1154         return (long)value;
1155     }
1156 
1157     /**
1158      * Returns the value of this {@code Integer} as a {@code float}
1159      * after a widening primitive conversion.
<span class="line-modified">1160      * @jls 5.1.2 Widening Primitive Conversions</span>
1161      */
1162     public float floatValue() {
1163         return (float)value;
1164     }
1165 
1166     /**
1167      * Returns the value of this {@code Integer} as a {@code double}
1168      * after a widening primitive conversion.
<span class="line-modified">1169      * @jls 5.1.2 Widening Primitive Conversions</span>
1170      */
1171     public double doubleValue() {
1172         return (double)value;
1173     }
1174 
1175     /**
1176      * Returns a {@code String} object representing this
1177      * {@code Integer}&#39;s value. The value is converted to signed
1178      * decimal representation and returned as a string, exactly as if
1179      * the integer value were given as an argument to the {@link
1180      * java.lang.Integer#toString(int)} method.
1181      *
1182      * @return  a string representation of the value of this object in
1183      *          base&amp;nbsp;10.
1184      */
1185     public String toString() {
1186         return toString(value);
1187     }
1188 
1189     /**
</pre>
<hr />
<pre>
1382      * &lt;/blockquote&gt;
1383      *
1384      * &lt;i&gt;DecimalNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, and &lt;i&gt;OctalDigits&lt;/i&gt;
1385      * are as defined in section 3.10.1 of
1386      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1387      * except that underscores are not accepted between digits.
1388      *
1389      * &lt;p&gt;The sequence of characters following an optional
1390      * sign and/or radix specifier (&quot;{@code 0x}&quot;, &quot;{@code 0X}&quot;,
1391      * &quot;{@code #}&quot;, or leading zero) is parsed as by the {@code
1392      * Integer.parseInt} method with the indicated radix (10, 16, or
1393      * 8).  This sequence of characters must represent a positive
1394      * value or a {@link NumberFormatException} will be thrown.  The
1395      * result is negated if first character of the specified {@code
1396      * String} is the minus sign.  No whitespace characters are
1397      * permitted in the {@code String}.
1398      *
1399      * @param     nm the {@code String} to decode.
1400      * @return    an {@code Integer} object holding the {@code int}
1401      *             value represented by {@code nm}
<span class="line-modified">1402      * @exception NumberFormatException  if the {@code String} does not</span>
1403      *            contain a parsable integer.
1404      * @see java.lang.Integer#parseInt(java.lang.String, int)
1405      */
1406     public static Integer decode(String nm) throws NumberFormatException {
1407         int radix = 10;
1408         int index = 0;
1409         boolean negative = false;
1410         Integer result;
1411 
1412         if (nm.isEmpty())
1413             throw new NumberFormatException(&quot;Zero length string&quot;);
1414         char firstChar = nm.charAt(0);
1415         // Handle sign, if present
1416         if (firstChar == &#39;-&#39;) {
1417             negative = true;
1418             index++;
1419         } else if (firstChar == &#39;+&#39;)
1420             index++;
1421 
1422         // Handle radix specifier, if present
</pre>
<hr />
<pre>
1846      */
1847     @Override
1848     public Optional&lt;Integer&gt; describeConstable() {
1849         return Optional.of(this);
1850     }
1851 
1852     /**
1853      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1854      * the instance itself.
1855      *
1856      * @param lookup ignored
1857      * @return the {@linkplain Integer} instance
1858      * @since 12
1859      */
1860     @Override
1861     public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {
1862         return this;
1863     }
1864 
1865     /** use serialVersionUID from JDK 1.0.2 for interoperability */

1866     @Native private static final long serialVersionUID = 1360826667806852920L;
1867 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 330      * @param   i   an integer to be converted to a string.
 331      * @return  the string representation of the unsigned integer value
 332      *          represented by the argument in binary (base&amp;nbsp;2).
 333      * @see #parseUnsignedInt(String, int)
 334      * @see #toUnsignedString(int, int)
 335      * @since   1.0.2
 336      */
 337     public static String toBinaryString(int i) {
 338         return toUnsignedString0(i, 1);
 339     }
 340 
 341     /**
 342      * Convert the integer to an unsigned number.
 343      */
 344     private static String toUnsignedString0(int val, int shift) {
 345         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
 346         int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
 347         int chars = Math.max(((mag + (shift - 1)) / shift), 1);
 348         if (COMPACT_STRINGS) {
 349             byte[] buf = new byte[chars];
<span class="line-modified"> 350             formatUnsignedInt(val, shift, buf, chars);</span>
 351             return new String(buf, LATIN1);
 352         } else {
 353             byte[] buf = new byte[chars * 2];
<span class="line-modified"> 354             formatUnsignedIntUTF16(val, shift, buf, chars);</span>
 355             return new String(buf, UTF16);
 356         }
 357     }
 358 
 359     /**
<span class="line-modified"> 360      * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If</span>
 361      * {@code len} exceeds the formatted ASCII representation of {@code val},
 362      * {@code buf} will be padded with leading zeroes.
 363      *
 364      * @param val the unsigned int to format
 365      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified"> 366      * @param buf the byte buffer to write to</span>

 367      * @param len the number of characters to write
 368      */
<span class="line-modified"> 369     private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {</span>
<span class="line-modified"> 370         int charPos = len;</span>














 371         int radix = 1 &lt;&lt; shift;
 372         int mask = radix - 1;
 373         do {
 374             buf[--charPos] = (byte)Integer.digits[val &amp; mask];
 375             val &gt;&gt;&gt;= shift;
<span class="line-modified"> 376         } while (charPos &gt; 0);</span>
 377     }
 378 
<span class="line-modified"> 379     /**</span>
<span class="line-modified"> 380      * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If</span>
<span class="line-modified"> 381      * {@code len} exceeds the formatted ASCII representation of {@code val},</span>
<span class="line-added"> 382      * {@code buf} will be padded with leading zeroes.</span>
<span class="line-added"> 383      *</span>
<span class="line-added"> 384      * @param val the unsigned int to format</span>
<span class="line-added"> 385      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)</span>
<span class="line-added"> 386      * @param buf the byte buffer to write to</span>
<span class="line-added"> 387      * @param len the number of characters to write</span>
<span class="line-added"> 388      */</span>
<span class="line-added"> 389     private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {</span>
<span class="line-added"> 390         int charPos = len;</span>
 391         int radix = 1 &lt;&lt; shift;
 392         int mask = radix - 1;
 393         do {
 394             StringUTF16.putChar(buf, --charPos, Integer.digits[val &amp; mask]);
 395             val &gt;&gt;&gt;= shift;
<span class="line-modified"> 396         } while (charPos &gt; 0);</span>
 397     }
 398 
 399     static final byte[] DigitTens = {
 400         &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;,
 401         &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;,
 402         &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;,
 403         &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;,
 404         &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;,
 405         &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;,
 406         &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;,
 407         &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;,
 408         &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;,
 409         &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;,
 410         } ;
 411 
 412     static final byte[] DigitOnes = {
 413         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 414         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 415         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 416         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
</pre>
<hr />
<pre>
 581      * &lt;blockquote&gt;&lt;pre&gt;
 582      * parseInt(&quot;0&quot;, 10) returns 0
 583      * parseInt(&quot;473&quot;, 10) returns 473
 584      * parseInt(&quot;+42&quot;, 10) returns 42
 585      * parseInt(&quot;-0&quot;, 10) returns 0
 586      * parseInt(&quot;-FF&quot;, 16) returns -255
 587      * parseInt(&quot;1100110&quot;, 2) returns 102
 588      * parseInt(&quot;2147483647&quot;, 10) returns 2147483647
 589      * parseInt(&quot;-2147483648&quot;, 10) returns -2147483648
 590      * parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException
 591      * parseInt(&quot;99&quot;, 8) throws a NumberFormatException
 592      * parseInt(&quot;Kona&quot;, 10) throws a NumberFormatException
 593      * parseInt(&quot;Kona&quot;, 27) returns 411787
 594      * &lt;/pre&gt;&lt;/blockquote&gt;
 595      *
 596      * @param      s   the {@code String} containing the integer
 597      *                  representation to be parsed
 598      * @param      radix   the radix to be used while parsing {@code s}.
 599      * @return     the integer represented by the string argument in the
 600      *             specified radix.
<span class="line-modified"> 601      * @throws     NumberFormatException if the {@code String}</span>
 602      *             does not contain a parsable {@code int}.
 603      */
 604     public static int parseInt(String s, int radix)
 605                 throws NumberFormatException
 606     {
 607         /*
 608          * WARNING: This method may be invoked early during VM initialization
 609          * before IntegerCache is initialized. Care must be taken to not use
 610          * the valueOf method.
 611          */
 612 
 613         if (s == null) {
 614             throw new NumberFormatException(&quot;null&quot;);
 615         }
 616 
 617         if (radix &lt; Character.MIN_RADIX) {
 618             throw new NumberFormatException(&quot;radix &quot; + radix +
 619                                             &quot; less than Character.MIN_RADIX&quot;);
 620         }
 621 
</pre>
<hr />
<pre>
 675      *                  representation to be parsed
 676      * @param      beginIndex   the beginning index, inclusive.
 677      * @param      endIndex     the ending index, exclusive.
 678      * @param      radix   the radix to be used while parsing {@code s}.
 679      * @return     the signed {@code int} represented by the subsequence in
 680      *             the specified radix.
 681      * @throws     NullPointerException  if {@code s} is null.
 682      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 683      *             negative, or if {@code beginIndex} is greater than
 684      *             {@code endIndex} or if {@code endIndex} is greater than
 685      *             {@code s.length()}.
 686      * @throws     NumberFormatException  if the {@code CharSequence} does not
 687      *             contain a parsable {@code int} in the specified
 688      *             {@code radix}, or if {@code radix} is either smaller than
 689      *             {@link java.lang.Character#MIN_RADIX} or larger than
 690      *             {@link java.lang.Character#MAX_RADIX}.
 691      * @since  9
 692      */
 693     public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
 694                 throws NumberFormatException {
<span class="line-modified"> 695         Objects.requireNonNull(s);</span>
 696 
 697         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 698             throw new IndexOutOfBoundsException();
 699         }
 700         if (radix &lt; Character.MIN_RADIX) {
 701             throw new NumberFormatException(&quot;radix &quot; + radix +
 702                                             &quot; less than Character.MIN_RADIX&quot;);
 703         }
 704         if (radix &gt; Character.MAX_RADIX) {
 705             throw new NumberFormatException(&quot;radix &quot; + radix +
 706                                             &quot; greater than Character.MAX_RADIX&quot;);
 707         }
 708 
 709         boolean negative = false;
 710         int i = beginIndex;
 711         int limit = -Integer.MAX_VALUE;
 712 
 713         if (i &lt; endIndex) {
 714             char firstChar = s.charAt(i);
 715             if (firstChar &lt; &#39;0&#39;) { // Possible leading &quot;+&quot; or &quot;-&quot;
</pre>
<hr />
<pre>
 746             return negative ? result : -result;
 747         } else {
 748             throw NumberFormatException.forInputString(&quot;&quot;, radix);
 749         }
 750     }
 751 
 752     /**
 753      * Parses the string argument as a signed decimal integer. The
 754      * characters in the string must all be decimal digits, except
 755      * that the first character may be an ASCII minus sign {@code &#39;-&#39;}
 756      * ({@code &#39;\u005Cu002D&#39;}) to indicate a negative value or an
 757      * ASCII plus sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) to
 758      * indicate a positive value. The resulting integer value is
 759      * returned, exactly as if the argument and the radix 10 were
 760      * given as arguments to the {@link #parseInt(java.lang.String,
 761      * int)} method.
 762      *
 763      * @param s    a {@code String} containing the {@code int}
 764      *             representation to be parsed
 765      * @return     the integer value represented by the argument in decimal.
<span class="line-modified"> 766      * @throws     NumberFormatException  if the string does not contain a</span>
 767      *               parsable integer.
 768      */
 769     public static int parseInt(String s) throws NumberFormatException {
 770         return parseInt(s,10);
 771     }
 772 
 773     /**
 774      * Parses the string argument as an unsigned integer in the radix
 775      * specified by the second argument.  An unsigned integer maps the
 776      * values usually associated with negative numbers to positive
 777      * numbers larger than {@code MAX_VALUE}.
 778      *
 779      * The characters in the string must all be digits of the
 780      * specified radix (as determined by whether {@link
 781      * java.lang.Character#digit(char, int)} returns a nonnegative
 782      * value), except that the first character may be an ASCII plus
 783      * sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}). The resulting
 784      * integer value is returned.
 785      *
 786      * &lt;p&gt;An exception of type {@code NumberFormatException} is
</pre>
<hr />
<pre>
 858      *                 {@code int} representation to be parsed
 859      * @param      beginIndex   the beginning index, inclusive.
 860      * @param      endIndex     the ending index, exclusive.
 861      * @param      radix   the radix to be used while parsing {@code s}.
 862      * @return     the unsigned {@code int} represented by the subsequence in
 863      *             the specified radix.
 864      * @throws     NullPointerException  if {@code s} is null.
 865      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 866      *             negative, or if {@code beginIndex} is greater than
 867      *             {@code endIndex} or if {@code endIndex} is greater than
 868      *             {@code s.length()}.
 869      * @throws     NumberFormatException  if the {@code CharSequence} does not
 870      *             contain a parsable unsigned {@code int} in the specified
 871      *             {@code radix}, or if {@code radix} is either smaller than
 872      *             {@link java.lang.Character#MIN_RADIX} or larger than
 873      *             {@link java.lang.Character#MAX_RADIX}.
 874      * @since  9
 875      */
 876     public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)
 877                 throws NumberFormatException {
<span class="line-modified"> 878         Objects.requireNonNull(s);</span>
 879 
 880         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 881             throw new IndexOutOfBoundsException();
 882         }
 883         int start = beginIndex, len = endIndex - beginIndex;
 884 
 885         if (len &gt; 0) {
 886             char firstChar = s.charAt(start);
 887             if (firstChar == &#39;-&#39;) {
 888                 throw new
 889                     NumberFormatException(String.format(&quot;Illegal leading minus sign &quot; +
 890                                                        &quot;on unsigned string %s.&quot;, s));
 891             } else {
 892                 if (len &lt;= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits
 893                         (radix == 10 &amp;&amp; len &lt;= 9)) { // Integer.MAX_VALUE in base 10 is 10 digits
 894                     return parseInt(s, start, start + len, radix);
 895                 } else {
 896                     long ell = Long.parseLong(s, start, start + len, radix);
 897                     if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) {
 898                         return (int) ell;
</pre>
<hr />
<pre>
 933      * extracted from the specified {@code String} when parsed
 934      * with the radix given by the second argument. The first argument
 935      * is interpreted as representing a signed integer in the radix
 936      * specified by the second argument, exactly as if the arguments
 937      * were given to the {@link #parseInt(java.lang.String, int)}
 938      * method. The result is an {@code Integer} object that
 939      * represents the integer value specified by the string.
 940      *
 941      * &lt;p&gt;In other words, this method returns an {@code Integer}
 942      * object equal to the value of:
 943      *
 944      * &lt;blockquote&gt;
 945      *  {@code new Integer(Integer.parseInt(s, radix))}
 946      * &lt;/blockquote&gt;
 947      *
 948      * @param      s   the string to be parsed.
 949      * @param      radix the radix to be used in interpreting {@code s}
 950      * @return     an {@code Integer} object holding the value
 951      *             represented by the string argument in the specified
 952      *             radix.
<span class="line-modified"> 953      * @throws    NumberFormatException if the {@code String}</span>
 954      *            does not contain a parsable {@code int}.
 955      */
 956     public static Integer valueOf(String s, int radix) throws NumberFormatException {
 957         return Integer.valueOf(parseInt(s,radix));
 958     }
 959 
 960     /**
 961      * Returns an {@code Integer} object holding the
 962      * value of the specified {@code String}. The argument is
 963      * interpreted as representing a signed decimal integer, exactly
 964      * as if the argument were given to the {@link
 965      * #parseInt(java.lang.String)} method. The result is an
 966      * {@code Integer} object that represents the integer value
 967      * specified by the string.
 968      *
 969      * &lt;p&gt;In other words, this method returns an {@code Integer}
 970      * object equal to the value of:
 971      *
 972      * &lt;blockquote&gt;
 973      *  {@code new Integer(Integer.parseInt(s))}
 974      * &lt;/blockquote&gt;
 975      *
 976      * @param      s   the string to be parsed.
 977      * @return     an {@code Integer} object holding the value
 978      *             represented by the string argument.
<span class="line-modified"> 979      * @throws     NumberFormatException  if the string cannot be parsed</span>
 980      *             as an integer.
 981      */
 982     public static Integer valueOf(String s) throws NumberFormatException {
 983         return Integer.valueOf(parseInt(s, 10));
 984     }
 985 
 986     /**
 987      * Cache to support the object identity semantics of autoboxing for values between
 988      * -128 and 127 (inclusive) as required by JLS.
 989      *
 990      * The cache is initialized on first usage.  The size of the cache
 991      * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.
 992      * During VM initialization, java.lang.Integer.IntegerCache.high property
 993      * may be set and saved in the private system properties in the
 994      * jdk.internal.misc.VM class.
 995      *
 996      * WARNING: The cache is archived with CDS and reloaded from the shared
 997      * archive at runtime. The archived cache (Integer[]) and Integer objects
 998      * reside in the closed archive heap regions. Care should be taken when
 999      * changing the implementation and the cache array should not be assigned
</pre>
<hr />
<pre>
1097      * {@code parseInt} method for radix 10.
1098      *
1099      * @param   s   the {@code String} to be converted to an {@code Integer}.
1100      * @throws      NumberFormatException if the {@code String} does not
1101      *              contain a parsable integer.
1102      *
1103      * @deprecated
1104      * It is rarely appropriate to use this constructor.
1105      * Use {@link #parseInt(String)} to convert a string to a
1106      * {@code int} primitive, or use {@link #valueOf(String)}
1107      * to convert a string to an {@code Integer} object.
1108      */
1109     @Deprecated(since=&quot;9&quot;)
1110     public Integer(String s) throws NumberFormatException {
1111         this.value = parseInt(s, 10);
1112     }
1113 
1114     /**
1115      * Returns the value of this {@code Integer} as a {@code byte}
1116      * after a narrowing primitive conversion.
<span class="line-modified">1117      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1118      */
1119     public byte byteValue() {
1120         return (byte)value;
1121     }
1122 
1123     /**
1124      * Returns the value of this {@code Integer} as a {@code short}
1125      * after a narrowing primitive conversion.
<span class="line-modified">1126      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1127      */
1128     public short shortValue() {
1129         return (short)value;
1130     }
1131 
1132     /**
1133      * Returns the value of this {@code Integer} as an
1134      * {@code int}.
1135      */
1136     @HotSpotIntrinsicCandidate
1137     public int intValue() {
1138         return value;
1139     }
1140 
1141     /**
1142      * Returns the value of this {@code Integer} as a {@code long}
1143      * after a widening primitive conversion.
<span class="line-modified">1144      * @jls 5.1.2 Widening Primitive Conversion</span>
1145      * @see Integer#toUnsignedLong(int)
1146      */
1147     public long longValue() {
1148         return (long)value;
1149     }
1150 
1151     /**
1152      * Returns the value of this {@code Integer} as a {@code float}
1153      * after a widening primitive conversion.
<span class="line-modified">1154      * @jls 5.1.2 Widening Primitive Conversion</span>
1155      */
1156     public float floatValue() {
1157         return (float)value;
1158     }
1159 
1160     /**
1161      * Returns the value of this {@code Integer} as a {@code double}
1162      * after a widening primitive conversion.
<span class="line-modified">1163      * @jls 5.1.2 Widening Primitive Conversion</span>
1164      */
1165     public double doubleValue() {
1166         return (double)value;
1167     }
1168 
1169     /**
1170      * Returns a {@code String} object representing this
1171      * {@code Integer}&#39;s value. The value is converted to signed
1172      * decimal representation and returned as a string, exactly as if
1173      * the integer value were given as an argument to the {@link
1174      * java.lang.Integer#toString(int)} method.
1175      *
1176      * @return  a string representation of the value of this object in
1177      *          base&amp;nbsp;10.
1178      */
1179     public String toString() {
1180         return toString(value);
1181     }
1182 
1183     /**
</pre>
<hr />
<pre>
1376      * &lt;/blockquote&gt;
1377      *
1378      * &lt;i&gt;DecimalNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, and &lt;i&gt;OctalDigits&lt;/i&gt;
1379      * are as defined in section 3.10.1 of
1380      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1381      * except that underscores are not accepted between digits.
1382      *
1383      * &lt;p&gt;The sequence of characters following an optional
1384      * sign and/or radix specifier (&quot;{@code 0x}&quot;, &quot;{@code 0X}&quot;,
1385      * &quot;{@code #}&quot;, or leading zero) is parsed as by the {@code
1386      * Integer.parseInt} method with the indicated radix (10, 16, or
1387      * 8).  This sequence of characters must represent a positive
1388      * value or a {@link NumberFormatException} will be thrown.  The
1389      * result is negated if first character of the specified {@code
1390      * String} is the minus sign.  No whitespace characters are
1391      * permitted in the {@code String}.
1392      *
1393      * @param     nm the {@code String} to decode.
1394      * @return    an {@code Integer} object holding the {@code int}
1395      *             value represented by {@code nm}
<span class="line-modified">1396      * @throws    NumberFormatException  if the {@code String} does not</span>
1397      *            contain a parsable integer.
1398      * @see java.lang.Integer#parseInt(java.lang.String, int)
1399      */
1400     public static Integer decode(String nm) throws NumberFormatException {
1401         int radix = 10;
1402         int index = 0;
1403         boolean negative = false;
1404         Integer result;
1405 
1406         if (nm.isEmpty())
1407             throw new NumberFormatException(&quot;Zero length string&quot;);
1408         char firstChar = nm.charAt(0);
1409         // Handle sign, if present
1410         if (firstChar == &#39;-&#39;) {
1411             negative = true;
1412             index++;
1413         } else if (firstChar == &#39;+&#39;)
1414             index++;
1415 
1416         // Handle radix specifier, if present
</pre>
<hr />
<pre>
1840      */
1841     @Override
1842     public Optional&lt;Integer&gt; describeConstable() {
1843         return Optional.of(this);
1844     }
1845 
1846     /**
1847      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1848      * the instance itself.
1849      *
1850      * @param lookup ignored
1851      * @return the {@linkplain Integer} instance
1852      * @since 12
1853      */
1854     @Override
1855     public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {
1856         return this;
1857     }
1858 
1859     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">1860     @java.io.Serial</span>
1861     @Native private static final long serialVersionUID = 1360826667806852920L;
1862 }
</pre>
</td>
</tr>
</table>
<center><a href="InstantiationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InternalError.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
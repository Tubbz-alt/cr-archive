<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/Permissions.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PermissionCollection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Policy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/Permissions.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 






 28 import java.util.Enumeration;
<span class="line-removed"> 29 import java.util.Hashtable;</span>
<span class="line-removed"> 30 import java.util.NoSuchElementException;</span>
<span class="line-removed"> 31 import java.util.Map;</span>
 32 import java.util.HashMap;
<span class="line-modified"> 33 import java.util.List;</span>
 34 import java.util.Iterator;
<span class="line-modified"> 35 import java.util.Collections;</span>


 36 import java.util.concurrent.ConcurrentHashMap;
<span class="line-removed"> 37 import java.io.Serializable;</span>
<span class="line-removed"> 38 import java.io.ObjectStreamField;</span>
<span class="line-removed"> 39 import java.io.ObjectOutputStream;</span>
<span class="line-removed"> 40 import java.io.ObjectInputStream;</span>
<span class="line-removed"> 41 import java.io.IOException;</span>
<span class="line-removed"> 42 </span>
 43 
 44 /**
 45  * This class represents a heterogeneous collection of Permissions. That is,
 46  * it contains different types of Permission objects, organized into
 47  * PermissionCollections. For example, if any
 48  * {@code java.io.FilePermission} objects are added to an instance of
 49  * this class, they are all stored in a single
 50  * PermissionCollection. It is the PermissionCollection returned by a call to
 51  * the {@code newPermissionCollection} method in the FilePermission class.
 52  * Similarly, any {@code java.lang.RuntimePermission} objects are
 53  * stored in the PermissionCollection returned by a call to the
 54  * {@code newPermissionCollection} method in the
 55  * RuntimePermission class. Thus, this class represents a collection of
 56  * PermissionCollections.
 57  *
 58  * &lt;p&gt;When the {@code add} method is called to add a Permission, the
 59  * Permission is stored in the appropriate PermissionCollection. If no such
 60  * collection exists yet, the Permission object&#39;s class is determined and the
 61  * {@code newPermissionCollection} method is called on that class to create
 62  * the PermissionCollection and add it to the Permissions object. If
</pre>
<hr />
<pre>
100     /**
101      * Creates a new Permissions object containing no PermissionCollections.
102      */
103     public Permissions() {
104         permsMap = new ConcurrentHashMap&lt;&gt;(11);
105         allPermission = null;
106     }
107 
108     /**
109      * Adds a permission object to the PermissionCollection for the class the
110      * permission belongs to. For example, if &lt;i&gt;permission&lt;/i&gt; is a
111      * FilePermission, it is added to the FilePermissionCollection stored
112      * in this Permissions object.
113      *
114      * This method creates
115      * a new PermissionCollection object (and adds the permission to it)
116      * if an appropriate collection does not yet exist.
117      *
118      * @param permission the Permission object to add.
119      *
<span class="line-modified">120      * @exception SecurityException if this Permissions object is</span>
121      * marked as readonly.
122      *
123      * @see PermissionCollection#isReadOnly()
124      */
125     @Override
126     public void add(Permission permission) {
127         if (isReadOnly())
128             throw new SecurityException(
129               &quot;attempt to add a Permission to a readonly Permissions object&quot;);
130 
131         PermissionCollection pc = getPermissionCollection(permission, true);
132         pc.add(permission);
133 
134         // No sync; staleness -&gt; optimizations delayed, which is OK
135         if (permission instanceof AllPermission) {
136             allPermission = pc;
137         }
138         if (permission instanceof UnresolvedPermission) {
139             hasUnresolved = true;
140         }
</pre>
<hr />
<pre>
312 
313         PermissionCollection pc = null;
314         synchronized (unresolvedPerms) {
315             int len = unresolvedPerms.size();
316             for (int i = 0; i &lt; len; i++) {
317                 UnresolvedPermission up = unresolvedPerms.get(i);
318                 Permission perm = up.resolve(p, certs);
319                 if (perm != null) {
320                     if (pc == null) {
321                         pc = p.newPermissionCollection();
322                         if (pc == null)
323                             pc = new PermissionsHash();
324                     }
325                     pc.add(perm);
326                 }
327             }
328         }
329         return pc;
330     }
331 

332     private static final long serialVersionUID = 4858622370623524688L;
333 
334     // Need to maintain serialization interoperability with earlier releases,
335     // which had the serializable field:
336     // private Hashtable perms;
337 
338     /**
339      * @serialField perms java.util.Hashtable
340      *     A table of the Permission classes and PermissionCollections.
341      * @serialField allPermission java.security.PermissionCollection
342      */

343     private static final ObjectStreamField[] serialPersistentFields = {
344         new ObjectStreamField(&quot;perms&quot;, Hashtable.class),
345         new ObjectStreamField(&quot;allPermission&quot;, PermissionCollection.class),
346     };
347 
348     /**
349      * @serialData Default fields.
350      */
351     /*
352      * Writes the contents of the permsMap field out as a Hashtable for
353      * serialization compatibility with earlier releases. allPermission
354      * unchanged.
355      */

356     private void writeObject(ObjectOutputStream out) throws IOException {
357         // Don&#39;t call out.defaultWriteObject()
358 
359         // Copy perms into a Hashtable
360         Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; perms =
361             new Hashtable&lt;&gt;(permsMap.size()*2); // no sync; estimate
362         perms.putAll(permsMap);
363 
364         // Write out serializable fields
365         ObjectOutputStream.PutField pfields = out.putFields();
366 
367         pfields.put(&quot;allPermission&quot;, allPermission); // no sync; staleness OK
368         pfields.put(&quot;perms&quot;, perms);
369         out.writeFields();
370     }
371 
372     /*
373      * Reads in a Hashtable of Class/PermissionCollections and saves them in the
374      * permsMap field. Reads in allPermission.
375      */

376     private void readObject(ObjectInputStream in) throws IOException,
377     ClassNotFoundException {
378         // Don&#39;t call defaultReadObject()
379 
380         // Read in serialized fields
381         ObjectInputStream.GetField gfields = in.readFields();
382 
383         // Get allPermission
384         allPermission = (PermissionCollection) gfields.get(&quot;allPermission&quot;, null);
385 
386         // Get permissions
387         // writeObject writes a Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; for
388         // the perms key, so this cast is safe, unless the data is corrupt.
389         @SuppressWarnings(&quot;unchecked&quot;)
390         Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; perms =
391             (Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt;)gfields.get(&quot;perms&quot;, null);
392         permsMap = new ConcurrentHashMap&lt;&gt;(perms.size()*2);
393         permsMap.putAll(perms);
394 
















395         // Set hasUnresolved
396         UnresolvedPermissionCollection uc =
397         (UnresolvedPermissionCollection) permsMap.get(UnresolvedPermission.class);
398         hasUnresolved = (uc != null &amp;&amp; uc.elements().hasMoreElements());
399     }
400 }
401 
402 final class PermissionsEnumerator implements Enumeration&lt;Permission&gt; {
403 
404     // all the perms
405     private Iterator&lt;PermissionCollection&gt; perms;
406     // the current set
407     private Enumeration&lt;Permission&gt; permset;
408 
409     PermissionsEnumerator(Iterator&lt;PermissionCollection&gt; e) {
410         perms = e;
411         permset = getNextEnumWithMore();
412     }
413 
414     // No need to synchronize; caller should sync on object as required
</pre>
<hr />
<pre>
515             for (Permission p_ : permsMap.values()) {
516                 if (p_.implies(permission))
517                     return true;
518             }
519             return false;
520         } else {
521             return true;
522         }
523     }
524 
525     /**
526      * Returns an enumeration of all the Permission objects in the container.
527      *
528      * @return an enumeration of all the Permissions.
529      */
530     @Override
531     public Enumeration&lt;Permission&gt; elements() {
532         return permsMap.elements();
533     }
534 

535     private static final long serialVersionUID = -8491988220802933440L;
536     // Need to maintain serialization interoperability with earlier releases,
537     // which had the serializable field:
538     // private Hashtable perms;
539     /**
540      * @serialField perms java.util.Hashtable
541      *     A table of the Permissions (both key and value are same).
542      */

543     private static final ObjectStreamField[] serialPersistentFields = {
544         new ObjectStreamField(&quot;perms&quot;, Hashtable.class),
545     };
546 
547     /**
548      * @serialData Default fields.
549      */
550     /*
551      * Writes the contents of the permsMap field out as a Hashtable for
552      * serialization compatibility with earlier releases.
553      */

554     private void writeObject(ObjectOutputStream out) throws IOException {
555         // Don&#39;t call out.defaultWriteObject()
556 
557         // Copy perms into a Hashtable
558         Hashtable&lt;Permission, Permission&gt; perms =
559                 new Hashtable&lt;&gt;(permsMap.size()*2);
560         perms.putAll(permsMap);
561 
562         // Write out serializable fields
563         ObjectOutputStream.PutField pfields = out.putFields();
564         pfields.put(&quot;perms&quot;, perms);
565         out.writeFields();
566     }
567 
568     /*
569      * Reads in a Hashtable of Permission/Permission and saves them in the
570      * permsMap field.
571      */

572     private void readObject(ObjectInputStream in) throws IOException,
573     ClassNotFoundException {
574         // Don&#39;t call defaultReadObject()
575 
576         // Read in serialized fields
577         ObjectInputStream.GetField gfields = in.readFields();
578 
579         // Get permissions
580         // writeObject writes a Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; for
581         // the perms key, so this cast is safe, unless the data is corrupt.
582         @SuppressWarnings(&quot;unchecked&quot;)
583         Hashtable&lt;Permission, Permission&gt; perms =
584                 (Hashtable&lt;Permission, Permission&gt;)gfields.get(&quot;perms&quot;, null);
585         permsMap = new ConcurrentHashMap&lt;&gt;(perms.size()*2);
586         permsMap.putAll(perms);










587     }
588 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 
<span class="line-added"> 28 import java.io.InvalidObjectException;</span>
<span class="line-added"> 29 import java.io.IOException;</span>
<span class="line-added"> 30 import java.io.ObjectInputStream;</span>
<span class="line-added"> 31 import java.io.ObjectOutputStream;</span>
<span class="line-added"> 32 import java.io.ObjectStreamField;</span>
<span class="line-added"> 33 import java.io.Serializable;</span>
 34 import java.util.Enumeration;



 35 import java.util.HashMap;
<span class="line-modified"> 36 import java.util.Hashtable;</span>
 37 import java.util.Iterator;
<span class="line-modified"> 38 import java.util.List;</span>
<span class="line-added"> 39 import java.util.Map;</span>
<span class="line-added"> 40 import java.util.NoSuchElementException;</span>
 41 import java.util.concurrent.ConcurrentHashMap;






 42 
 43 /**
 44  * This class represents a heterogeneous collection of Permissions. That is,
 45  * it contains different types of Permission objects, organized into
 46  * PermissionCollections. For example, if any
 47  * {@code java.io.FilePermission} objects are added to an instance of
 48  * this class, they are all stored in a single
 49  * PermissionCollection. It is the PermissionCollection returned by a call to
 50  * the {@code newPermissionCollection} method in the FilePermission class.
 51  * Similarly, any {@code java.lang.RuntimePermission} objects are
 52  * stored in the PermissionCollection returned by a call to the
 53  * {@code newPermissionCollection} method in the
 54  * RuntimePermission class. Thus, this class represents a collection of
 55  * PermissionCollections.
 56  *
 57  * &lt;p&gt;When the {@code add} method is called to add a Permission, the
 58  * Permission is stored in the appropriate PermissionCollection. If no such
 59  * collection exists yet, the Permission object&#39;s class is determined and the
 60  * {@code newPermissionCollection} method is called on that class to create
 61  * the PermissionCollection and add it to the Permissions object. If
</pre>
<hr />
<pre>
 99     /**
100      * Creates a new Permissions object containing no PermissionCollections.
101      */
102     public Permissions() {
103         permsMap = new ConcurrentHashMap&lt;&gt;(11);
104         allPermission = null;
105     }
106 
107     /**
108      * Adds a permission object to the PermissionCollection for the class the
109      * permission belongs to. For example, if &lt;i&gt;permission&lt;/i&gt; is a
110      * FilePermission, it is added to the FilePermissionCollection stored
111      * in this Permissions object.
112      *
113      * This method creates
114      * a new PermissionCollection object (and adds the permission to it)
115      * if an appropriate collection does not yet exist.
116      *
117      * @param permission the Permission object to add.
118      *
<span class="line-modified">119      * @throws    SecurityException if this Permissions object is</span>
120      * marked as readonly.
121      *
122      * @see PermissionCollection#isReadOnly()
123      */
124     @Override
125     public void add(Permission permission) {
126         if (isReadOnly())
127             throw new SecurityException(
128               &quot;attempt to add a Permission to a readonly Permissions object&quot;);
129 
130         PermissionCollection pc = getPermissionCollection(permission, true);
131         pc.add(permission);
132 
133         // No sync; staleness -&gt; optimizations delayed, which is OK
134         if (permission instanceof AllPermission) {
135             allPermission = pc;
136         }
137         if (permission instanceof UnresolvedPermission) {
138             hasUnresolved = true;
139         }
</pre>
<hr />
<pre>
311 
312         PermissionCollection pc = null;
313         synchronized (unresolvedPerms) {
314             int len = unresolvedPerms.size();
315             for (int i = 0; i &lt; len; i++) {
316                 UnresolvedPermission up = unresolvedPerms.get(i);
317                 Permission perm = up.resolve(p, certs);
318                 if (perm != null) {
319                     if (pc == null) {
320                         pc = p.newPermissionCollection();
321                         if (pc == null)
322                             pc = new PermissionsHash();
323                     }
324                     pc.add(perm);
325                 }
326             }
327         }
328         return pc;
329     }
330 
<span class="line-added">331     @java.io.Serial</span>
332     private static final long serialVersionUID = 4858622370623524688L;
333 
334     // Need to maintain serialization interoperability with earlier releases,
335     // which had the serializable field:
336     // private Hashtable perms;
337 
338     /**
339      * @serialField perms java.util.Hashtable
340      *     A table of the Permission classes and PermissionCollections.
341      * @serialField allPermission java.security.PermissionCollection
342      */
<span class="line-added">343     @java.io.Serial</span>
344     private static final ObjectStreamField[] serialPersistentFields = {
345         new ObjectStreamField(&quot;perms&quot;, Hashtable.class),
346         new ObjectStreamField(&quot;allPermission&quot;, PermissionCollection.class),
347     };
348 
349     /**
350      * @serialData Default fields.
351      */
352     /*
353      * Writes the contents of the permsMap field out as a Hashtable for
354      * serialization compatibility with earlier releases. allPermission
355      * unchanged.
356      */
<span class="line-added">357     @java.io.Serial</span>
358     private void writeObject(ObjectOutputStream out) throws IOException {
359         // Don&#39;t call out.defaultWriteObject()
360 
361         // Copy perms into a Hashtable
362         Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; perms =
363             new Hashtable&lt;&gt;(permsMap.size()*2); // no sync; estimate
364         perms.putAll(permsMap);
365 
366         // Write out serializable fields
367         ObjectOutputStream.PutField pfields = out.putFields();
368 
369         pfields.put(&quot;allPermission&quot;, allPermission); // no sync; staleness OK
370         pfields.put(&quot;perms&quot;, perms);
371         out.writeFields();
372     }
373 
374     /*
375      * Reads in a Hashtable of Class/PermissionCollections and saves them in the
376      * permsMap field. Reads in allPermission.
377      */
<span class="line-added">378     @java.io.Serial</span>
379     private void readObject(ObjectInputStream in) throws IOException,
380     ClassNotFoundException {
381         // Don&#39;t call defaultReadObject()
382 
383         // Read in serialized fields
384         ObjectInputStream.GetField gfields = in.readFields();
385 
386         // Get allPermission
387         allPermission = (PermissionCollection) gfields.get(&quot;allPermission&quot;, null);
388 
389         // Get permissions
390         // writeObject writes a Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; for
391         // the perms key, so this cast is safe, unless the data is corrupt.
392         @SuppressWarnings(&quot;unchecked&quot;)
393         Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; perms =
394             (Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt;)gfields.get(&quot;perms&quot;, null);
395         permsMap = new ConcurrentHashMap&lt;&gt;(perms.size()*2);
396         permsMap.putAll(perms);
397 
<span class="line-added">398         // Check that Class is mapped to PermissionCollection containing</span>
<span class="line-added">399         // Permissions of the same class</span>
<span class="line-added">400         for (Map.Entry&lt;Class&lt;?&gt;, PermissionCollection&gt; e : perms.entrySet()) {</span>
<span class="line-added">401             Class&lt;?&gt; k = e.getKey();</span>
<span class="line-added">402             PermissionCollection v = e.getValue();</span>
<span class="line-added">403             Enumeration&lt;Permission&gt; en = v.elements();</span>
<span class="line-added">404             while (en.hasMoreElements()) {</span>
<span class="line-added">405                 Permission p = en.nextElement();</span>
<span class="line-added">406                 if (!k.equals(p.getClass())) {</span>
<span class="line-added">407                     throw new InvalidObjectException(&quot;Permission with class &quot; +</span>
<span class="line-added">408                         k + &quot; incorrectly mapped to PermissionCollection &quot; +</span>
<span class="line-added">409                         &quot;containing Permission with &quot; + p.getClass());</span>
<span class="line-added">410                 }</span>
<span class="line-added">411             }</span>
<span class="line-added">412         }</span>
<span class="line-added">413 </span>
414         // Set hasUnresolved
415         UnresolvedPermissionCollection uc =
416         (UnresolvedPermissionCollection) permsMap.get(UnresolvedPermission.class);
417         hasUnresolved = (uc != null &amp;&amp; uc.elements().hasMoreElements());
418     }
419 }
420 
421 final class PermissionsEnumerator implements Enumeration&lt;Permission&gt; {
422 
423     // all the perms
424     private Iterator&lt;PermissionCollection&gt; perms;
425     // the current set
426     private Enumeration&lt;Permission&gt; permset;
427 
428     PermissionsEnumerator(Iterator&lt;PermissionCollection&gt; e) {
429         perms = e;
430         permset = getNextEnumWithMore();
431     }
432 
433     // No need to synchronize; caller should sync on object as required
</pre>
<hr />
<pre>
534             for (Permission p_ : permsMap.values()) {
535                 if (p_.implies(permission))
536                     return true;
537             }
538             return false;
539         } else {
540             return true;
541         }
542     }
543 
544     /**
545      * Returns an enumeration of all the Permission objects in the container.
546      *
547      * @return an enumeration of all the Permissions.
548      */
549     @Override
550     public Enumeration&lt;Permission&gt; elements() {
551         return permsMap.elements();
552     }
553 
<span class="line-added">554     @java.io.Serial</span>
555     private static final long serialVersionUID = -8491988220802933440L;
556     // Need to maintain serialization interoperability with earlier releases,
557     // which had the serializable field:
558     // private Hashtable perms;
559     /**
560      * @serialField perms java.util.Hashtable
561      *     A table of the Permissions (both key and value are same).
562      */
<span class="line-added">563     @java.io.Serial</span>
564     private static final ObjectStreamField[] serialPersistentFields = {
565         new ObjectStreamField(&quot;perms&quot;, Hashtable.class),
566     };
567 
568     /**
569      * @serialData Default fields.
570      */
571     /*
572      * Writes the contents of the permsMap field out as a Hashtable for
573      * serialization compatibility with earlier releases.
574      */
<span class="line-added">575     @java.io.Serial</span>
576     private void writeObject(ObjectOutputStream out) throws IOException {
577         // Don&#39;t call out.defaultWriteObject()
578 
579         // Copy perms into a Hashtable
580         Hashtable&lt;Permission, Permission&gt; perms =
581                 new Hashtable&lt;&gt;(permsMap.size()*2);
582         perms.putAll(permsMap);
583 
584         // Write out serializable fields
585         ObjectOutputStream.PutField pfields = out.putFields();
586         pfields.put(&quot;perms&quot;, perms);
587         out.writeFields();
588     }
589 
590     /*
591      * Reads in a Hashtable of Permission/Permission and saves them in the
592      * permsMap field.
593      */
<span class="line-added">594     @java.io.Serial</span>
595     private void readObject(ObjectInputStream in) throws IOException,
596     ClassNotFoundException {
597         // Don&#39;t call defaultReadObject()
598 
599         // Read in serialized fields
600         ObjectInputStream.GetField gfields = in.readFields();
601 
602         // Get permissions
603         // writeObject writes a Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; for
604         // the perms key, so this cast is safe, unless the data is corrupt.
605         @SuppressWarnings(&quot;unchecked&quot;)
606         Hashtable&lt;Permission, Permission&gt; perms =
607                 (Hashtable&lt;Permission, Permission&gt;)gfields.get(&quot;perms&quot;, null);
608         permsMap = new ConcurrentHashMap&lt;&gt;(perms.size()*2);
609         permsMap.putAll(perms);
<span class="line-added">610 </span>
<span class="line-added">611         // check that the Permission key and value are the same object</span>
<span class="line-added">612         for (Map.Entry&lt;Permission, Permission&gt; e : perms.entrySet()) {</span>
<span class="line-added">613             Permission k = e.getKey();</span>
<span class="line-added">614             Permission v = e.getValue();</span>
<span class="line-added">615             if (k != v) {</span>
<span class="line-added">616                 throw new InvalidObjectException(&quot;Permission (&quot; + k +</span>
<span class="line-added">617                     &quot;) incorrectly mapped to Permission (&quot; + v + &quot;)&quot;);</span>
<span class="line-added">618             }</span>
<span class="line-added">619         }</span>
620     }
621 }
</pre>
</td>
</tr>
</table>
<center><a href="PermissionCollection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Policy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
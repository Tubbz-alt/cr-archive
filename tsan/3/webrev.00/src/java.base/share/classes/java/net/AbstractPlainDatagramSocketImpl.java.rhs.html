<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.FileDescriptor;
 28 import java.io.IOException;
 29 import java.util.Collections;
 30 import java.util.HashSet;
<a name="2" id="anc2"></a><span class="line-added"> 31 import java.util.Objects;</span>
 32 import java.util.Set;
 33 
 34 import sun.net.ResourceManager;
<a name="3" id="anc3"></a><span class="line-added"> 35 import sun.net.ext.ExtendedSocketOptions;</span>
<span class="line-added"> 36 import sun.net.util.IPAddressUtil;</span>
 37 import sun.security.action.GetPropertyAction;
 38 
 39 /**
 40  * Abstract datagram and multicast socket implementation base class.
 41  * Note: This is not a public class, so that applets cannot call
 42  * into the implementation directly and hence cannot bypass the
 43  * security checks present in the DatagramSocket and MulticastSocket
 44  * classes.
 45  *
 46  * @author Pavani Diwanji
 47  */
 48 
 49 abstract class AbstractPlainDatagramSocketImpl extends DatagramSocketImpl
 50 {
 51     /* timeout value for receive() */
 52     int timeout = 0;
 53     boolean connected = false;
 54     private int trafficClass = 0;
 55     protected InetAddress connectedAddress = null;
 56     private int connectedPort = -1;
<a name="4" id="anc4"></a><span class="line-added"> 57     private final boolean isMulticast;</span>
 58 
 59     private static final String os =
 60             GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
 61 
 62     /**
 63      * flag set if the native connect() call not to be used
 64      */
 65     private static final boolean connectDisabled = os.contains(&quot;OS X&quot;);
 66 
 67     /**
 68      * Load net library into runtime.
 69      */
 70     static {
<a name="5" id="anc5"></a><span class="line-modified"> 71         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 72     }
 73 
 74     private static volatile boolean checkedReusePort;
 75     private static volatile boolean isReusePortAvailable;
 76 
 77     /**
 78      * Tells whether SO_REUSEPORT is supported.
 79      */
 80     static boolean isReusePortAvailable() {
 81         if (!checkedReusePort) {
 82             isReusePortAvailable = isReusePortAvailable0();
 83             checkedReusePort = true;
 84         }
 85         return isReusePortAvailable;
 86     }
 87 
<a name="6" id="anc6"></a><span class="line-modified"> 88     AbstractPlainDatagramSocketImpl(boolean isMulticast) {</span>
<span class="line-modified"> 89         this.isMulticast = isMulticast;</span>
















 90     }
 91 
 92     /**
 93      * Creates a datagram socket
 94      */
 95     protected synchronized void create() throws SocketException {
 96         ResourceManager.beforeUdpCreate();
 97         fd = new FileDescriptor();
 98         try {
 99             datagramSocketCreate();
<a name="7" id="anc7"></a><span class="line-modified">100             SocketCleanable.register(fd, false);</span>
101         } catch (SocketException ioe) {
102             ResourceManager.afterUdpClose();
103             fd = null;
104             throw ioe;
105         }
106     }
107 
108     /**
109      * Binds a datagram socket to a local port.
110      */
111     protected synchronized void bind(int lport, InetAddress laddr)
112         throws SocketException {
<a name="8" id="anc8"></a><span class="line-added">113         if (laddr.isLinkLocalAddress()) {</span>
<span class="line-added">114             laddr = IPAddressUtil.toScopedAddress(laddr);</span>
<span class="line-added">115         }</span>
116         bind0(lport, laddr);
117     }
118 
119     protected abstract void bind0(int lport, InetAddress laddr)
120         throws SocketException;
121 
122     /**
123      * Sends a datagram packet. The packet contains the data and the
124      * destination address to send the packet to.
125      * @param p the packet to be sent.
126      */
<a name="9" id="anc9"></a><span class="line-modified">127     protected void send(DatagramPacket p) throws IOException {</span>
<span class="line-added">128         InetAddress orig = p.getAddress();</span>
<span class="line-added">129         if (orig.isLinkLocalAddress()) {</span>
<span class="line-added">130             InetAddress scoped = IPAddressUtil.toScopedAddress(orig);</span>
<span class="line-added">131             if (orig != scoped) {</span>
<span class="line-added">132                 p = new DatagramPacket(p.getData(), p.getOffset(),</span>
<span class="line-added">133                                        p.getLength(), scoped, p.getPort());</span>
<span class="line-added">134             }</span>
<span class="line-added">135         }</span>
<span class="line-added">136         send0(p);</span>
<span class="line-added">137     }</span>
<span class="line-added">138 </span>
<span class="line-added">139     protected abstract void send0(DatagramPacket p) throws IOException;</span>
140 
141     /**
142      * Connects a datagram socket to a remote destination. This associates the remote
143      * address with the local socket so that datagrams may only be sent to this destination
144      * and received from this destination.
145      * @param address the remote InetAddress to connect to
146      * @param port the remote port number
147      */
148     protected void connect(InetAddress address, int port) throws SocketException {
<a name="10" id="anc10"></a><span class="line-added">149         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">150             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">151         }</span>
152         connect0(address, port);
153         connectedAddress = address;
154         connectedPort = port;
155         connected = true;
156     }
157 
158     /**
159      * Disconnects a previously connected socket. Does nothing if the socket was
160      * not connected already.
161      */
162     protected void disconnect() {
163         disconnect0(connectedAddress.holder().getFamily());
164         connected = false;
165         connectedAddress = null;
166         connectedPort = -1;
167     }
168 
169     /**
170      * Peek at the packet to see who it is from.
171      * @param i the address to populate with the sender address
172      */
173     protected abstract int peek(InetAddress i) throws IOException;
174     protected abstract int peekData(DatagramPacket p) throws IOException;
175     /**
176      * Receive the datagram packet.
177      * @param p the packet to receive into
178      */
179     protected synchronized void receive(DatagramPacket p)
180         throws IOException {
181         receive0(p);
182     }
183 
184     protected abstract void receive0(DatagramPacket p)
185         throws IOException;
186 
187     /**
188      * Set the TTL (time-to-live) option.
189      * @param ttl TTL to be set.
190      */
191     protected abstract void setTimeToLive(int ttl) throws IOException;
192 
193     /**
194      * Get the TTL (time-to-live) option.
195      */
196     protected abstract int getTimeToLive() throws IOException;
197 
198     /**
199      * Set the TTL (time-to-live) option.
200      * @param ttl TTL to be set.
201      */
202     @Deprecated
203     protected abstract void setTTL(byte ttl) throws IOException;
204 
205     /**
206      * Get the TTL (time-to-live) option.
207      */
208     @Deprecated
209     protected abstract byte getTTL() throws IOException;
210 
211     /**
212      * Join the multicast group.
213      * @param inetaddr multicast address to join.
214      */
215     protected void join(InetAddress inetaddr) throws IOException {
216         join(inetaddr, null);
217     }
218 
219     /**
220      * Leave the multicast group.
221      * @param inetaddr multicast address to leave.
222      */
223     protected void leave(InetAddress inetaddr) throws IOException {
224         leave(inetaddr, null);
225     }
226     /**
227      * Join the multicast group.
228      * @param mcastaddr multicast address to join.
229      * @param netIf specifies the local interface to receive multicast
230      *        datagram packets
231      * @throws  IllegalArgumentException if mcastaddr is null or is a
232      *          SocketAddress subclass not supported by this socket
233      * @since 1.4
234      */
235 
236     protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
237         throws IOException {
238         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
239             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
240         join(((InetSocketAddress)mcastaddr).getAddress(), netIf);
241     }
242 
243     protected abstract void join(InetAddress inetaddr, NetworkInterface netIf)
244         throws IOException;
245 
246     /**
247      * Leave the multicast group.
248      * @param mcastaddr  multicast address to leave.
249      * @param netIf specified the local interface to leave the group at
250      * @throws  IllegalArgumentException if mcastaddr is null or is a
251      *          SocketAddress subclass not supported by this socket
252      * @since 1.4
253      */
254     protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
255         throws IOException {
256         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
257             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
258         leave(((InetSocketAddress)mcastaddr).getAddress(), netIf);
259     }
260 
261     protected abstract void leave(InetAddress inetaddr, NetworkInterface netIf)
262         throws IOException;
263 
264     /**
265      * Close the socket.
266      */
267     protected void close() {
268         if (fd != null) {
269             SocketCleanable.unregister(fd);
270             datagramSocketClose();
271             ResourceManager.afterUdpClose();
272             fd = null;
273         }
274     }
275 
276     protected boolean isClosed() {
277         return (fd == null) ? true : false;
278     }
279 
280     /**
281      * set a value - since we only support (setting) binary options
282      * here, o must be a Boolean
283      */
284 
285      public void setOption(int optID, Object o) throws SocketException {
286          if (isClosed()) {
287              throw new SocketException(&quot;Socket Closed&quot;);
288          }
289          switch (optID) {
290             /* check type safety b4 going native.  These should never
291              * fail, since only java.Socket* has access to
292              * PlainSocketImpl.setOption().
293              */
294          case SO_TIMEOUT:
295              if (o == null || !(o instanceof Integer)) {
296                  throw new SocketException(&quot;bad argument for SO_TIMEOUT&quot;);
297              }
298              int tmp = ((Integer) o).intValue();
299              if (tmp &lt; 0)
300                  throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
301              timeout = tmp;
302              return;
303          case IP_TOS:
304              if (o == null || !(o instanceof Integer)) {
305                  throw new SocketException(&quot;bad argument for IP_TOS&quot;);
306              }
307              trafficClass = ((Integer)o).intValue();
308              break;
309          case SO_REUSEADDR:
310              if (o == null || !(o instanceof Boolean)) {
311                  throw new SocketException(&quot;bad argument for SO_REUSEADDR&quot;);
312              }
313              break;
314          case SO_BROADCAST:
315              if (o == null || !(o instanceof Boolean)) {
316                  throw new SocketException(&quot;bad argument for SO_BROADCAST&quot;);
317              }
318              break;
319          case SO_BINDADDR:
320              throw new SocketException(&quot;Cannot re-bind Socket&quot;);
321          case SO_RCVBUF:
322          case SO_SNDBUF:
323              if (o == null || !(o instanceof Integer) ||
324                  ((Integer)o).intValue() &lt; 0) {
325                  throw new SocketException(&quot;bad argument for SO_SNDBUF or &quot; +
326                                            &quot;SO_RCVBUF&quot;);
327              }
328              break;
329          case IP_MULTICAST_IF:
330              if (o == null || !(o instanceof InetAddress))
331                  throw new SocketException(&quot;bad argument for IP_MULTICAST_IF&quot;);
332              break;
333          case IP_MULTICAST_IF2:
334              if (o == null || !(o instanceof NetworkInterface))
335                  throw new SocketException(&quot;bad argument for IP_MULTICAST_IF2&quot;);
336              break;
337          case IP_MULTICAST_LOOP:
338              if (o == null || !(o instanceof Boolean))
339                  throw new SocketException(&quot;bad argument for IP_MULTICAST_LOOP&quot;);
340              break;
341          case SO_REUSEPORT:
342              if (o == null || !(o instanceof Boolean)) {
343                  throw new SocketException(&quot;bad argument for SO_REUSEPORT&quot;);
344              }
345              if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
346                  throw new UnsupportedOperationException(&quot;unsupported option&quot;);
347              }
348              break;
349          default:
350              throw new SocketException(&quot;invalid option: &quot; + optID);
351          }
352          socketSetOption(optID, o);
353      }
354 
355     /*
356      * get option&#39;s state - set or not
357      */
358 
359     public Object getOption(int optID) throws SocketException {
360         if (isClosed()) {
361             throw new SocketException(&quot;Socket Closed&quot;);
362         }
363 
364         Object result;
365 
366         switch (optID) {
367             case SO_TIMEOUT:
368                 result = timeout;
369                 break;
370 
371             case IP_TOS:
372                 result = socketGetOption(optID);
373                 if ( ((Integer)result).intValue() == -1) {
374                     result = trafficClass;
375                 }
376                 break;
377 
378             case SO_BINDADDR:
379             case IP_MULTICAST_IF:
380             case IP_MULTICAST_IF2:
381             case SO_RCVBUF:
382             case SO_SNDBUF:
383             case IP_MULTICAST_LOOP:
384             case SO_REUSEADDR:
385             case SO_BROADCAST:
386                 result = socketGetOption(optID);
387                 break;
388 
389             case SO_REUSEPORT:
390                 if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
391                     throw new UnsupportedOperationException(&quot;unsupported option&quot;);
392                 }
393                 result = socketGetOption(optID);
394                 break;
395 
396             default:
397                 throw new SocketException(&quot;invalid option: &quot; + optID);
398         }
399 
400         return result;
401     }
402 
<a name="11" id="anc11"></a><span class="line-added">403     static final ExtendedSocketOptions extendedOptions =</span>
<span class="line-added">404             ExtendedSocketOptions.getInstance();</span>
<span class="line-added">405 </span>
<span class="line-added">406     private static final Set&lt;SocketOption&lt;?&gt;&gt; datagramSocketOptions = datagramSocketOptions();</span>
<span class="line-added">407 </span>
<span class="line-added">408     private static Set&lt;SocketOption&lt;?&gt;&gt; datagramSocketOptions() {</span>
<span class="line-added">409         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">410         options.add(StandardSocketOptions.SO_SNDBUF);</span>
<span class="line-added">411         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">412         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">413         options.add(StandardSocketOptions.SO_BROADCAST);</span>
<span class="line-added">414         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">415         options.add(StandardSocketOptions.IP_MULTICAST_IF);</span>
<span class="line-added">416         options.add(StandardSocketOptions.IP_MULTICAST_TTL);</span>
<span class="line-added">417         options.add(StandardSocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">418         if (isReusePortAvailable())</span>
<span class="line-added">419             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">420         options.addAll(ExtendedSocketOptions.datagramSocketOptions());</span>
<span class="line-added">421         return Collections.unmodifiableSet(options);</span>
<span class="line-added">422     }</span>
<span class="line-added">423 </span>
<span class="line-added">424     @Override</span>
<span class="line-added">425     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">426             return datagramSocketOptions;</span>
<span class="line-added">427     }</span>
<span class="line-added">428 </span>
<span class="line-added">429     @Override</span>
<span class="line-added">430     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">431         Objects.requireNonNull(name);</span>
<span class="line-added">432         if (!supportedOptions().contains(name))</span>
<span class="line-added">433             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">434 </span>
<span class="line-added">435         if (!name.type().isInstance(value))</span>
<span class="line-added">436             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">437 </span>
<span class="line-added">438         if (isClosed())</span>
<span class="line-added">439             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">440 </span>
<span class="line-added">441         if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">442             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">443                 throw new IllegalArgumentException(&quot;Invalid send buffer size:&quot; + value);</span>
<span class="line-added">444             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-added">445         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">446             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">447                 throw new IllegalArgumentException(&quot;Invalid recv buffer size:&quot; + value);</span>
<span class="line-added">448             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-added">449         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">450             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-added">451         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">452             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-added">453         } else if (name == StandardSocketOptions.SO_BROADCAST) {</span>
<span class="line-added">454             setOption(SocketOptions.SO_BROADCAST, value);</span>
<span class="line-added">455         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">456             int i = ((Integer)value).intValue();</span>
<span class="line-added">457             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">458                 throw new IllegalArgumentException(&quot;Invalid IP_TOS value: &quot; + value);</span>
<span class="line-added">459             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-added">460         } else if (name == StandardSocketOptions.IP_MULTICAST_IF ) {</span>
<span class="line-added">461             setOption(SocketOptions.IP_MULTICAST_IF2, value);</span>
<span class="line-added">462         } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {</span>
<span class="line-added">463             int i = ((Integer)value).intValue();</span>
<span class="line-added">464             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">465                 throw new IllegalArgumentException(&quot;Invalid TTL/hop value: &quot; + value);</span>
<span class="line-added">466             setTimeToLive((Integer)value);</span>
<span class="line-added">467         } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {</span>
<span class="line-added">468             boolean enable = (boolean) value;</span>
<span class="line-added">469             // Legacy setOption expects true to mean &#39;disabled&#39;</span>
<span class="line-added">470             setOption(SocketOptions.IP_MULTICAST_LOOP, !enable);</span>
<span class="line-added">471         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">472             extendedOptions.setOption(fd, name, value);</span>
<span class="line-added">473         } else {</span>
<span class="line-added">474             throw new AssertionError(&quot;unknown option :&quot; + name);</span>
<span class="line-added">475         }</span>
<span class="line-added">476     }</span>
<span class="line-added">477 </span>
<span class="line-added">478     @Override</span>
<span class="line-added">479     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">480     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">481         Objects.requireNonNull(name);</span>
<span class="line-added">482         if (!supportedOptions().contains(name))</span>
<span class="line-added">483             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">484 </span>
<span class="line-added">485         if (isClosed())</span>
<span class="line-added">486             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">487 </span>
<span class="line-added">488         if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">489             return (T) getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-added">490         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">491             return (T) getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-added">492         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">493             return (T) getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-added">494         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">495             return (T) getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-added">496         } else if (name == StandardSocketOptions.SO_BROADCAST) {</span>
<span class="line-added">497             return (T) getOption(SocketOptions.SO_BROADCAST);</span>
<span class="line-added">498         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">499             return (T) getOption(SocketOptions.IP_TOS);</span>
<span class="line-added">500         } else if (name == StandardSocketOptions.IP_MULTICAST_IF) {</span>
<span class="line-added">501             return (T) getOption(SocketOptions.IP_MULTICAST_IF2);</span>
<span class="line-added">502         } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {</span>
<span class="line-added">503             return (T) ((Integer) getTimeToLive());</span>
<span class="line-added">504         } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {</span>
<span class="line-added">505             boolean disabled = (boolean) getOption(SocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">506             // Legacy getOption returns true when disabled</span>
<span class="line-added">507             return (T) Boolean.valueOf(!disabled);</span>
<span class="line-added">508         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">509             return (T) extendedOptions.getOption(fd, name);</span>
<span class="line-added">510         } else {</span>
<span class="line-added">511             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">512         }</span>
<span class="line-added">513     }</span>
<span class="line-added">514 </span>
515     protected abstract void datagramSocketCreate() throws SocketException;
516     protected abstract void datagramSocketClose();
517     protected abstract void socketSetOption(int opt, Object val)
518         throws SocketException;
519     protected abstract Object socketGetOption(int opt) throws SocketException;
520 
521     protected abstract void connect0(InetAddress address, int port) throws SocketException;
522     protected abstract void disconnect0(int family);
523 
524     protected boolean nativeConnectDisabled() {
525         return connectDisabled;
526     }
527 
528     abstract int dataAvailable();
529     private static native boolean isReusePortAvailable0();
530 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
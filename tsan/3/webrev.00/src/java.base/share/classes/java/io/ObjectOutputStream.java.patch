diff a/src/java.base/share/classes/java/io/ObjectOutputStream.java b/src/java.base/share/classes/java/io/ObjectOutputStream.java
--- a/src/java.base/share/classes/java/io/ObjectOutputStream.java
+++ b/src/java.base/share/classes/java/io/ObjectOutputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -148,10 +148,14 @@
  * filled up to 1024 bytes, or be written whenever there is a termination of
  * block-data mode.  Calls to the ObjectOutputStream methods writeObject,
  * defaultWriteObject and writeFields initially terminate any existing
  * block-data record.
  *
+ * @implSpec
+ * Records are serialized differently than ordinary serializable or externalizable
+ * objects, see <a href="ObjectInputStream.html#record-serialization">record serialization</a>.
+ *
  * @author      Mike Warres
  * @author      Roger Riggs
  * @see java.io.DataOutput
  * @see java.io.ObjectInputStream
  * @see java.io.Serializable
@@ -230,11 +234,11 @@
      *
      * @param   out output stream to write to
      * @throws  IOException if an I/O error occurs while writing stream header
      * @throws  SecurityException if untrusted subclass illegally overrides
      *          security-sensitive methods
-     * @throws  NullPointerException if <code>out</code> is <code>null</code>
+     * @throws  NullPointerException if {@code out} is {@code null}
      * @since   1.4
      * @see     ObjectOutputStream#ObjectOutputStream()
      * @see     ObjectOutputStream#putFields()
      * @see     ObjectInputStream#ObjectInputStream(InputStream)
      */
@@ -257,16 +261,16 @@
      * Provide a way for subclasses that are completely reimplementing
      * ObjectOutputStream to not have to allocate private data just used by
      * this implementation of ObjectOutputStream.
      *
      * <p>If there is a security manager installed, this method first calls the
-     * security manager's <code>checkPermission</code> method with a
-     * <code>SerializablePermission("enableSubclassImplementation")</code>
+     * security manager's {@code checkPermission} method with a
+     * {@code SerializablePermission("enableSubclassImplementation")}
      * permission to ensure it's ok to enable subclassing.
      *
      * @throws  SecurityException if a security manager exists and its
-     *          <code>checkPermission</code> method denies enabling
+     *          {@code checkPermission} method denies enabling
      *          subclassing.
      * @throws  IOException if an I/O error occurs while creating this stream
      * @see SecurityManager#checkPermission
      * @see java.io.SerializablePermission
      */
@@ -355,12 +359,12 @@
         }
     }
 
     /**
      * Method used by subclasses to override the default writeObject method.
-     * This method is called by trusted subclasses of ObjectInputStream that
-     * constructed ObjectInputStream using the protected no-arg constructor.
+     * This method is called by trusted subclasses of ObjectOutputStream that
+     * constructed ObjectOutputStream using the protected no-arg constructor.
      * The subclass is expected to provide an override method with the modifier
      * "final".
      *
      * @param   obj object to be written to the underlying stream
      * @throws  IOException if there are I/O errors while writing to the
@@ -427,11 +431,11 @@
      * this stream.  This may only be called from the writeObject method of the
      * class being serialized. It will throw the NotActiveException if it is
      * called otherwise.
      *
      * @throws  IOException if I/O errors occur while writing to the underlying
-     *          <code>OutputStream</code>
+     *          {@code OutputStream}
      */
     public void defaultWriteObject() throws IOException {
         SerialCallbackContext ctx = curContext;
         if (ctx == null) {
             throw new NotActiveException("not in call to writeObject");
@@ -527,22 +531,22 @@
      * Subclasses may implement this method to store custom data in the stream
      * along with descriptors for dynamic proxy classes.
      *
      * <p>This method is called exactly once for each unique proxy class
      * descriptor in the stream.  The default implementation of this method in
-     * <code>ObjectOutputStream</code> does nothing.
+     * {@code ObjectOutputStream} does nothing.
      *
-     * <p>The corresponding method in <code>ObjectInputStream</code> is
-     * <code>resolveProxyClass</code>.  For a given subclass of
-     * <code>ObjectOutputStream</code> that overrides this method, the
-     * <code>resolveProxyClass</code> method in the corresponding subclass of
-     * <code>ObjectInputStream</code> must read any data or objects written by
-     * <code>annotateProxyClass</code>.
+     * <p>The corresponding method in {@code ObjectInputStream} is
+     * {@code resolveProxyClass}.  For a given subclass of
+     * {@code ObjectOutputStream} that overrides this method, the
+     * {@code resolveProxyClass} method in the corresponding subclass of
+     * {@code ObjectInputStream} must read any data or objects written by
+     * {@code annotateProxyClass}.
      *
      * @param   cl the proxy class to annotate custom data for
      * @throws  IOException any exception thrown by the underlying
-     *          <code>OutputStream</code>
+     *          {@code OutputStream}
      * @see ObjectInputStream#resolveProxyClass(String[])
      * @since   1.3
      */
     protected void annotateProxyClass(Class<?> cl) throws IOException {
     }
@@ -644,20 +648,20 @@
      * Write the specified class descriptor to the ObjectOutputStream.  Class
      * descriptors are used to identify the classes of objects written to the
      * stream.  Subclasses of ObjectOutputStream may override this method to
      * customize the way in which class descriptors are written to the
      * serialization stream.  The corresponding method in ObjectInputStream,
-     * <code>readClassDescriptor</code>, should then be overridden to
+     * {@code readClassDescriptor}, should then be overridden to
      * reconstitute the class descriptor from its custom stream representation.
      * By default, this method writes class descriptors according to the format
      * defined in the Object Serialization specification.
      *
      * <p>Note that this method will only be called if the ObjectOutputStream
      * is not using the old serialization stream format (set by calling
-     * ObjectOutputStream's <code>useProtocolVersion</code> method).  If this
+     * ObjectOutputStream's {@code useProtocolVersion} method).  If this
      * serialization stream is using the old format
-     * (<code>PROTOCOL_VERSION_1</code>), the class descriptor will be written
+     * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written
      * internally in a manner that cannot be overridden or customized.
      *
      * @param   desc class descriptor to write to the stream
      * @throws  IOException If an I/O error has occurred.
      * @see java.io.ObjectInputStream#readClassDescriptor()
@@ -877,135 +881,139 @@
      * to ObjectOutput.
      *
      * @since 1.2
      */
     public abstract static class PutField {
+        /**
+         * Constructor for subclasses to call.
+         */
+        public PutField() {}
 
         /**
          * Put the value of the named boolean field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>boolean</code>
+         * {@code boolean}
          */
         public abstract void put(String name, boolean val);
 
         /**
          * Put the value of the named byte field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>byte</code>
+         * {@code byte}
          */
         public abstract void put(String name, byte val);
 
         /**
          * Put the value of the named char field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>char</code>
+         * {@code char}
          */
         public abstract void put(String name, char val);
 
         /**
          * Put the value of the named short field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>short</code>
+         * {@code short}
          */
         public abstract void put(String name, short val);
 
         /**
          * Put the value of the named int field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>int</code>
+         * {@code int}
          */
         public abstract void put(String name, int val);
 
         /**
          * Put the value of the named long field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>long</code>
+         * {@code long}
          */
         public abstract void put(String name, long val);
 
         /**
          * Put the value of the named float field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>float</code>
+         * {@code float}
          */
         public abstract void put(String name, float val);
 
         /**
          * Put the value of the named double field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         * @throws IllegalArgumentException if <code>name</code> does not
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not
-         * <code>double</code>
+         * {@code double}
          */
         public abstract void put(String name, double val);
 
         /**
          * Put the value of the named Object field into the persistent field.
          *
          * @param  name the name of the serializable field
          * @param  val the value to assign to the field
-         *         (which may be <code>null</code>)
-         * @throws IllegalArgumentException if <code>name</code> does not
+         *         (which may be {@code null})
+         * @throws IllegalArgumentException if {@code name} does not
          * match the name of a serializable field for the class whose fields
          * are being written, or if the type of the named field is not a
          * reference type
          */
         public abstract void put(String name, Object val);
 
         /**
          * Write the data and fields to the specified ObjectOutput stream,
          * which must be the same stream that produced this
-         * <code>PutField</code> object.
+         * {@code PutField} object.
          *
          * @param  out the stream to write the data and fields to
          * @throws IOException if I/O errors occur while writing to the
          *         underlying stream
          * @throws IllegalArgumentException if the specified stream is not
-         *         the same stream that produced this <code>PutField</code>
+         *         the same stream that produced this {@code PutField}
          *         object
          * @deprecated This method does not write the values contained by this
-         *         <code>PutField</code> object in a proper format, and may
+         *         {@code PutField} object in a proper format, and may
          *         result in corruption of the serialization stream.  The
-         *         correct way to write <code>PutField</code> data is by
+         *         correct way to write {@code PutField} data is by
          *         calling the {@link java.io.ObjectOutputStream#writeFields()}
          *         method.
          */
         @Deprecated
         public abstract void write(ObjectOutput out) throws IOException;
@@ -1425,11 +1433,14 @@
             desc.checkSerialize();
 
             bout.writeByte(TC_OBJECT);
             writeClassDesc(desc, false);
             handles.assign(unshared ? null : obj);
-            if (desc.isExternalizable() && !desc.isProxy()) {
+
+            if (desc.isRecord()) {
+                writeRecordData(obj, desc);
+            } else if (desc.isExternalizable() && !desc.isProxy()) {
                 writeExternalData((Externalizable) obj);
             } else {
                 writeSerialData(obj, desc);
             }
         } finally {
@@ -1469,10 +1480,25 @@
         }
 
         curPut = oldPut;
     }
 
+    /** Writes the record component values for the given record object. */
+    @SuppressWarnings("preview")
+    private void writeRecordData(Object obj, ObjectStreamClass desc)
+        throws IOException
+    {
+        assert obj.getClass().isRecord();
+        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
+        if (slots.length != 1) {
+            throw new InvalidClassException(
+                    "expected a single record slot length, but found: " + slots.length);
+        }
+
+        defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors
+    }
+
     /**
      * Writes instance data for each serializable class of given object, from
      * superclass to subclass.
      */
     private void writeSerialData(Object obj, ObjectStreamClass desc)
@@ -1585,26 +1611,10 @@
         } finally {
             bout.setBlockDataMode(oldMode);
         }
     }
 
-    /**
-     * Converts specified span of float values into byte values.
-     */
-    // REMIND: remove once hotspot inlines Float.floatToIntBits
-    private static native void floatsToBytes(float[] src, int srcpos,
-                                             byte[] dst, int dstpos,
-                                             int nfloats);
-
-    /**
-     * Converts specified span of double values into byte values.
-     */
-    // REMIND: remove once hotspot inlines Double.doubleToLongBits
-    private static native void doublesToBytes(double[] src, int srcpos,
-                                              byte[] dst, int dstpos,
-                                              int ndoubles);
-
     /**
      * Default PutField implementation.
      */
     private class PutFieldImpl extends PutField {
 
@@ -2090,14 +2100,15 @@
             int limit = MAX_BLOCK_SIZE - 4;
             int endoff = off + len;
             while (off < endoff) {
                 if (pos <= limit) {
                     int avail = (MAX_BLOCK_SIZE - pos) >> 2;
-                    int chunklen = Math.min(endoff - off, avail);
-                    floatsToBytes(v, off, buf, pos, chunklen);
-                    off += chunklen;
-                    pos += chunklen << 2;
+                    int stop = Math.min(endoff, off + avail);
+                    while (off < stop) {
+                        Bits.putFloat(buf, pos, v[off++]);
+                        pos += 4;
+                    }
                 } else {
                     dout.writeFloat(v[off++]);
                 }
             }
         }
@@ -2123,14 +2134,15 @@
             int limit = MAX_BLOCK_SIZE - 8;
             int endoff = off + len;
             while (off < endoff) {
                 if (pos <= limit) {
                     int avail = (MAX_BLOCK_SIZE - pos) >> 3;
-                    int chunklen = Math.min(endoff - off, avail);
-                    doublesToBytes(v, off, buf, pos, chunklen);
-                    off += chunklen;
-                    pos += chunklen << 3;
+                    int stop = Math.min(endoff, off + avail);
+                    while (off < stop) {
+                        Bits.putDouble(buf, pos, v[off++]);
+                        pos += 8;
+                    }
                 } else {
                     dout.writeDouble(v[off++]);
                 }
             }
         }

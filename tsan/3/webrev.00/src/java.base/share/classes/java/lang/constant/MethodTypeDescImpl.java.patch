diff a/src/java.base/share/classes/java/lang/constant/MethodTypeDescImpl.java b/src/java.base/share/classes/java/lang/constant/MethodTypeDescImpl.java
--- a/src/java.base/share/classes/java/lang/constant/MethodTypeDescImpl.java
+++ b/src/java.base/share/classes/java/lang/constant/MethodTypeDescImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,10 +24,12 @@
  */
 package java.lang.constant;
 
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
 
@@ -109,14 +111,12 @@
         return MethodTypeDesc.of(returnType, newArgs);
     }
 
     @Override
     public MethodTypeDesc dropParameterTypes(int start, int end) {
-        if (start < 0 || start >= argTypes.length || end < 0 || end > argTypes.length)
+        if (start < 0 || start >= argTypes.length || end < 0 || end > argTypes.length || start > end)
             throw new IndexOutOfBoundsException();
-        else if (start > end)
-            throw new IllegalArgumentException(String.format("Range (%d, %d) not valid for size %d", start, end, argTypes.length));
         ClassDesc[] newArgs = new ClassDesc[argTypes.length - (end - start)];
         System.arraycopy(argTypes, 0, newArgs, 0, start);
         System.arraycopy(argTypes, end, newArgs, start, argTypes.length - end);
         return MethodTypeDesc.of(returnType, newArgs);
     }
@@ -131,12 +131,25 @@
         System.arraycopy(argTypes, pos, newArgs, pos+paramTypes.length, argTypes.length - pos);
         return MethodTypeDesc.of(returnType, newArgs);
     }
 
     @Override
-    public MethodType resolveConstantDesc(MethodHandles.Lookup lookup) {
-        return MethodType.fromMethodDescriptorString(descriptorString(), lookup.lookupClass().getClassLoader());
+    public MethodType resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException {
+        MethodType mtype = AccessController.doPrivileged(new PrivilegedAction<>() {
+            @Override
+            public MethodType run() {
+                return MethodType.fromMethodDescriptorString(descriptorString(),
+                                                             lookup.lookupClass().getClassLoader());
+            }
+        });
+
+        // let's check that the lookup has access to all the types in the method type
+        lookup.accessClass(mtype.returnType());
+        for (Class<?> paramType: mtype.parameterArray()) {
+            lookup.accessClass(paramType);
+        }
+        return mtype;
     }
 
     /**
      * Returns {@code true} if this {@linkplain MethodTypeDescImpl} is
      * equal to another {@linkplain MethodTypeDescImpl}.  Equality is

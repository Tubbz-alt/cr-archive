<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReentrantReadWriteLock.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../package-info.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -33,13 +33,12 @@</span>
   * http://creativecommons.org/publicdomain/zero/1.0/
   */
  
  package java.util.concurrent.locks;
  
<span class="udiff-line-removed">- import java.lang.invoke.MethodHandles;</span>
<span class="udiff-line-removed">- import java.lang.invoke.VarHandle;</span>
  import java.util.concurrent.TimeUnit;
<span class="udiff-line-added">+ import jdk.internal.misc.Unsafe;</span>
  import jdk.internal.vm.annotation.ReservedStackAccess;
  
  /**
   * A capability-based lock with three modes for controlling read/write
   * access.  The state of a StampedLock consists of a version and mode.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -130,13 +129,12 @@</span>
   * #asReadWriteLock()} in applications requiring only the associated
   * set of functionality.
   *
   * &lt;p&gt;&lt;b&gt;Memory Synchronization.&lt;/b&gt; Methods with the effect of
   * successfully locking in any mode have the same memory
<span class="udiff-line-modified-removed">-  * synchronization effects as a &lt;em&gt;Lock&lt;/em&gt; action described in</span>
<span class="udiff-line-modified-removed">-  * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4&quot;&gt;</span>
<span class="udiff-line-removed">-  * Chapter 17 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;&lt;/a&gt;.</span>
<span class="udiff-line-modified-added">+  * synchronization effects as a &lt;em&gt;Lock&lt;/em&gt; action, as described in</span>
<span class="udiff-line-modified-added">+  * Chapter 17 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
   * Methods successfully unlocking in write mode have the same memory
   * synchronization effects as an &lt;em&gt;Unlock&lt;/em&gt; action.  In optimistic
   * read usages, actions prior to the most recent write mode unlock action
   * are guaranteed to happen-before those following a tryOptimisticRead
   * only if a later validate returns true; otherwise there is no guarantee
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -235,10 +233,11 @@</span>
   *       sl.unlock(stamp);
   *     }
   *   }
   * }}&lt;/pre&gt;
   *
<span class="udiff-line-added">+  * @jls 17.4 Memory Model</span>
   * @since 1.8
   * @author Doug Lea
   */
  public class StampedLock implements java.io.Serializable {
      /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,134 +261,68 @@</span>
       * readers exceeds the count field. We do this by treating the max
       * reader count value (RBITS) as a spinlock protecting overflow
       * updates.
       *
       * Waiters use a modified form of CLH lock used in
<span class="udiff-line-modified-removed">-      * AbstractQueuedSynchronizer (see its internal documentation for</span>
<span class="udiff-line-modified-removed">-      * a fuller account), where each node is tagged (field mode) as</span>
<span class="udiff-line-modified-removed">-      * either a reader or writer. Sets of waiting readers are grouped</span>
<span class="udiff-line-modified-removed">-      * (linked) under a common node (field cowait) so act as a single</span>
<span class="udiff-line-modified-removed">-      * node with respect to most CLH mechanics.  By virtue of the</span>
<span class="udiff-line-modified-removed">-      * queue structure, wait nodes need not actually carry sequence</span>
<span class="udiff-line-modified-removed">-      * numbers; we know each is greater than its predecessor.  This</span>
<span class="udiff-line-modified-removed">-      * simplifies the scheduling policy to a mainly-FIFO scheme that</span>
<span class="udiff-line-modified-removed">-      * incorporates elements of Phase-Fair locks (see Brandenburg &amp;</span>
<span class="udiff-line-modified-removed">-      * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  In</span>
<span class="udiff-line-modified-removed">-      * particular, we use the phase-fair anti-barging rule: If an</span>
<span class="udiff-line-modified-removed">-      * incoming reader arrives while read lock is held but there is a</span>
<span class="udiff-line-removed">-      * queued writer, this incoming reader is queued.  (This rule is</span>
<span class="udiff-line-removed">-      * responsible for some of the complexity of method acquireRead,</span>
<span class="udiff-line-removed">-      * but without it, the lock becomes highly unfair.) Method release</span>
<span class="udiff-line-removed">-      * does not (and sometimes cannot) itself wake up cowaiters. This</span>
<span class="udiff-line-removed">-      * is done by the primary thread, but helped by any other threads</span>
<span class="udiff-line-removed">-      * with nothing better to do in methods acquireRead and</span>
<span class="udiff-line-removed">-      * acquireWrite.</span>
<span class="udiff-line-modified-added">+      * AbstractQueuedSynchronizer (AQS; see its internal documentation</span>
<span class="udiff-line-modified-added">+      * for a fuller account), where each node is either a ReaderNode</span>
<span class="udiff-line-modified-added">+      * or WriterNode. Implementation of queued Writer mode is</span>
<span class="udiff-line-modified-added">+      * identical to AQS except for lock-state operations.  Sets of</span>
<span class="udiff-line-modified-added">+      * waiting readers are grouped (linked) under a common node (field</span>
<span class="udiff-line-modified-added">+      * cowaiters) so act as a single node with respect to most CLH</span>
<span class="udiff-line-modified-added">+      * mechanics.  This simplifies the scheduling policy to a</span>
<span class="udiff-line-modified-added">+      * mainly-FIFO scheme that incorporates elements of Phase-Fair</span>
<span class="udiff-line-modified-added">+      * locks (see Brandenburg &amp; Anderson, especially</span>
<span class="udiff-line-modified-added">+      * http://www.cs.unc.edu/~bbb/diss/).  Method release does not</span>
<span class="udiff-line-modified-added">+      * itself wake up cowaiters. This is done by the primary thread,</span>
<span class="udiff-line-modified-added">+      * but helped by other cowaiters as they awaken.</span>
       *
<span class="udiff-line-modified-removed">-      * These rules apply to threads actually queued. All tryLock forms</span>
<span class="udiff-line-modified-removed">-      * opportunistically try to acquire locks regardless of preference</span>
<span class="udiff-line-modified-removed">-      * rules, and so may &quot;barge&quot; their way in.  Randomized spinning is</span>
<span class="udiff-line-modified-removed">-      * used in the acquire methods to reduce (increasingly expensive)</span>
<span class="udiff-line-modified-removed">-      * context switching while also avoiding sustained memory</span>
<span class="udiff-line-modified-removed">-      * thrashing among many threads.  We limit spins to the head of</span>
<span class="udiff-line-modified-removed">-      * queue. If, upon wakening, a thread fails to obtain lock, and is</span>
<span class="udiff-line-modified-removed">-      * still (or becomes) the first waiting thread (which indicates</span>
<span class="udiff-line-modified-removed">-      * that some other thread barged and obtained lock), it escalates</span>
<span class="udiff-line-removed">-      * spins (up to MAX_HEAD_SPINS) to reduce the likelihood of</span>
<span class="udiff-line-removed">-      * continually losing to barging threads.</span>
<span class="udiff-line-modified-added">+      * These rules apply to threads actually queued. Threads may also</span>
<span class="udiff-line-modified-added">+      * try to acquire locks before or in the process of enqueueing</span>
<span class="udiff-line-modified-added">+      * regardless of preference rules, and so may &quot;barge&quot; their way</span>
<span class="udiff-line-modified-added">+      * in.  Methods writeLock and readLock (but not the other variants</span>
<span class="udiff-line-modified-added">+      * of each) first unconditionally try to CAS state, falling back</span>
<span class="udiff-line-modified-added">+      * to test-and-test-and-set retries on failure, slightly shrinking</span>
<span class="udiff-line-modified-added">+      * race windows on initial attempts, thus making success more</span>
<span class="udiff-line-modified-added">+      * likely. Also, when some threads cancel (via interrupt or</span>
<span class="udiff-line-modified-added">+      * timeout), phase-fairness is at best roughly approximated.</span>
       *
       * Nearly all of these mechanics are carried out in methods
       * acquireWrite and acquireRead, that, as typical of such code,
       * sprawl out because actions and retries rely on consistent sets
       * of locally cached reads.
       *
<span class="udiff-line-modified-removed">-      * As noted in Boehm&#39;s paper (above), sequence validation (mainly</span>
<span class="udiff-line-modified-removed">-      * method validate()) requires stricter ordering rules than apply</span>
<span class="udiff-line-modified-removed">-      * to normal volatile reads (of &quot;state&quot;).  To force orderings of</span>
<span class="udiff-line-modified-removed">-      * reads before a validation and the validation itself in those</span>
<span class="udiff-line-modified-removed">-      * cases where this is not already forced, we use acquireFence.</span>
<span class="udiff-line-modified-removed">-      * Unlike in that paper, we allow writers to use plain writes.</span>
<span class="udiff-line-modified-removed">-      * One would not expect reorderings of such writes with the lock</span>
<span class="udiff-line-removed">-      * acquisition CAS because there is a &quot;control dependency&quot;, but it</span>
<span class="udiff-line-removed">-      * is theoretically possible, so we additionally add a</span>
<span class="udiff-line-removed">-      * storeStoreFence after lock acquisition CAS.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * ----------------------------------------------------------------</span>
<span class="udiff-line-removed">-      * Here&#39;s an informal proof that plain reads by _successful_</span>
<span class="udiff-line-removed">-      * readers see plain writes from preceding but not following</span>
<span class="udiff-line-removed">-      * writers (following Boehm and the C++ standard [atomics.fences]):</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Because of the total synchronization order of accesses to</span>
<span class="udiff-line-removed">-      * volatile long state containing the sequence number, writers and</span>
<span class="udiff-line-removed">-      * _successful_ readers can be globally sequenced.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * int x, y;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Writer 1:</span>
<span class="udiff-line-removed">-      * inc sequence (odd - &quot;locked&quot;)</span>
<span class="udiff-line-removed">-      * storeStoreFence();</span>
<span class="udiff-line-removed">-      * x = 1; y = 2;</span>
<span class="udiff-line-removed">-      * inc sequence (even - &quot;unlocked&quot;)</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Successful Reader:</span>
<span class="udiff-line-removed">-      * read sequence (even)</span>
<span class="udiff-line-removed">-      * // must see writes from Writer 1 but not Writer 2</span>
<span class="udiff-line-removed">-      * r1 = x; r2 = y;</span>
<span class="udiff-line-removed">-      * acquireFence();</span>
<span class="udiff-line-removed">-      * read sequence (even - validated unchanged)</span>
<span class="udiff-line-removed">-      * // use r1 and r2</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Writer 2:</span>
<span class="udiff-line-removed">-      * inc sequence (odd - &quot;locked&quot;)</span>
<span class="udiff-line-removed">-      * storeStoreFence();</span>
<span class="udiff-line-removed">-      * x = 3; y = 4;</span>
<span class="udiff-line-removed">-      * inc sequence (even - &quot;unlocked&quot;)</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Visibility of writer 1&#39;s stores is normal - reader&#39;s initial</span>
<span class="udiff-line-removed">-      * read of state synchronizes with writer 1&#39;s final write to state.</span>
<span class="udiff-line-removed">-      * Lack of visibility of writer 2&#39;s plain writes is less obvious.</span>
<span class="udiff-line-removed">-      * If reader&#39;s read of x or y saw writer 2&#39;s write, then (assuming</span>
<span class="udiff-line-removed">-      * semantics of C++ fences) the storeStoreFence would &quot;synchronize&quot;</span>
<span class="udiff-line-removed">-      * with reader&#39;s acquireFence and reader&#39;s validation read must see</span>
<span class="udiff-line-removed">-      * writer 2&#39;s initial write to state and so validation must fail.</span>
<span class="udiff-line-removed">-      * But making this &quot;proof&quot; formal and rigorous is an open problem!</span>
<span class="udiff-line-removed">-      * ----------------------------------------------------------------</span>
<span class="udiff-line-modified-added">+      * For an explanation of the use of acquireFence, see</span>
<span class="udiff-line-modified-added">+      * http://gee.cs.oswego.edu/dl/html/j9mm.html as well as Boehm&#39;s</span>
<span class="udiff-line-modified-added">+      * paper (above). Note that sequence validation (mainly method</span>
<span class="udiff-line-modified-added">+      * validate()) requires stricter ordering rules than apply to</span>
<span class="udiff-line-modified-added">+      * normal volatile reads (of &quot;state&quot;).  To ensure that writeLock</span>
<span class="udiff-line-modified-added">+      * acquisitions strictly precede subsequent writes in cases where</span>
<span class="udiff-line-modified-added">+      * this is not already forced, we use a storeStoreFence.</span>
       *
       * The memory layout keeps lock state and queue pointers together
       * (normally on the same cache line). This usually works well for
       * read-mostly loads. In most other cases, the natural tendency of
<span class="udiff-line-modified-removed">-      * adaptive-spin CLH locks to reduce memory contention lessens</span>
<span class="udiff-line-modified-removed">-      * motivation to further spread out contended locations, but might</span>
<span class="udiff-line-modified-removed">-      * be subject to future improvements.</span>
<span class="udiff-line-modified-added">+      * CLH locks to reduce memory contention lessens motivation to</span>
<span class="udiff-line-modified-added">+      * further spread out contended locations, but might be subject to</span>
<span class="udiff-line-modified-added">+      * future improvements.</span>
       */
  
      private static final long serialVersionUID = -6001602636862214147L;
  
<span class="udiff-line-removed">-     /** Number of processors, for spin control */</span>
<span class="udiff-line-removed">-     private static final int NCPU = Runtime.getRuntime().availableProcessors();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /** Maximum number of retries before enqueuing on acquisition; at least 1 */</span>
<span class="udiff-line-removed">-     private static final int SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 6 : 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /** Maximum number of tries before blocking at head on acquisition */</span>
<span class="udiff-line-removed">-     private static final int HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 10 : 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /** Maximum number of retries before re-blocking */</span>
<span class="udiff-line-removed">-     private static final int MAX_HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 16 : 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /** The period for yielding when waiting for overflow spinlock */</span>
<span class="udiff-line-removed">-     private static final int OVERFLOW_YIELD_RATE = 7; // must be power 2 - 1</span>
<span class="udiff-line-removed">- </span>
      /** The number of bits to use for reader count before overflowing */
<span class="udiff-line-modified-removed">-     private static final int LG_READERS = 7;</span>
<span class="udiff-line-modified-added">+     private static final int LG_READERS = 7; // 127 readers</span>
  
      // Values for lock state and stamp operations
      private static final long RUNIT = 1L;
      private static final long WBIT  = 1L &lt;&lt; LG_READERS;
      private static final long RBITS = WBIT - 1L;
      private static final long RFULL = RBITS - 1L;
      private static final long ABITS = RBITS | WBIT;
      private static final long SBITS = ~RBITS; // note overlap with ABITS
<span class="udiff-line-added">+     // not writing and conservatively non-overflowing</span>
<span class="udiff-line-added">+     private static final long RSAFE = ~(3L &lt;&lt; (LG_READERS - 1));</span>
  
      /*
       * 3 stamp modes can be distinguished by examining (m = stamp &amp; ABITS):
       * write mode: m == WBIT
       * optimistic read mode: m == 0L (even when read lock is held)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -406,33 +339,68 @@</span>
      private static final long ORIGIN = WBIT &lt;&lt; 1;
  
      // Special value from cancelled acquire methods so caller can throw IE
      private static final long INTERRUPTED = 1L;
  
<span class="udiff-line-modified-removed">-     // Values for node status; order matters</span>
<span class="udiff-line-modified-removed">-     private static final int WAITING   = -1;</span>
<span class="udiff-line-modified-removed">-     private static final int CANCELLED =  1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Modes for nodes (int not boolean to allow arithmetic)</span>
<span class="udiff-line-modified-removed">-     private static final int RMODE = 0;</span>
<span class="udiff-line-modified-removed">-     private static final int WMODE = 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     /** Wait nodes */</span>
<span class="udiff-line-modified-removed">-     static final class WNode {</span>
<span class="udiff-line-modified-removed">-         volatile WNode prev;</span>
<span class="udiff-line-modified-removed">-         volatile WNode next;</span>
<span class="udiff-line-modified-removed">-         volatile WNode cowait;    // list of linked readers</span>
<span class="udiff-line-modified-removed">-         volatile Thread thread;   // non-null while possibly parked</span>
<span class="udiff-line-modified-removed">-         volatile int status;      // 0, WAITING, or CANCELLED</span>
<span class="udiff-line-modified-removed">-         final int mode;           // RMODE or WMODE</span>
<span class="udiff-line-modified-removed">-         WNode(int m, WNode p) { mode = m; prev = p; }</span>
<span class="udiff-line-modified-added">+     // Bits for Node.status</span>
<span class="udiff-line-modified-added">+     static final int WAITING   = 1;</span>
<span class="udiff-line-modified-added">+     static final int CANCELLED = 0x80000000; // must be negative</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /** CLH nodes */</span>
<span class="udiff-line-modified-added">+     abstract static class Node {</span>
<span class="udiff-line-modified-added">+         volatile Node prev;       // initially attached via casTail</span>
<span class="udiff-line-modified-added">+         volatile Node next;       // visibly nonnull when signallable</span>
<span class="udiff-line-modified-added">+         Thread waiter;            // visibly nonnull when enqueued</span>
<span class="udiff-line-modified-added">+         volatile int status;      // written by owner, atomic bit ops by others</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // methods for atomic operations</span>
<span class="udiff-line-modified-added">+         final boolean casPrev(Node c, Node v) {  // for cleanQueue</span>
<span class="udiff-line-modified-added">+             return U.weakCompareAndSetReference(this, PREV, c, v);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         final boolean casNext(Node c, Node v) {  // for cleanQueue</span>
<span class="udiff-line-modified-added">+             return U.weakCompareAndSetReference(this, NEXT, c, v);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         final int getAndUnsetStatus(int v) {     // for signalling</span>
<span class="udiff-line-added">+             return U.getAndBitwiseAndInt(this, STATUS, ~v);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         final void setPrevRelaxed(Node p) {      // for off-queue assignment</span>
<span class="udiff-line-added">+             U.putReference(this, PREV, p);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         final void setStatusRelaxed(int s) {     // for off-queue assignment</span>
<span class="udiff-line-added">+             U.putInt(this, STATUS, s);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         final void clearStatus() {               // for reducing unneeded signals</span>
<span class="udiff-line-added">+             U.putIntOpaque(this, STATUS, 0);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private static final long STATUS</span>
<span class="udiff-line-added">+             = U.objectFieldOffset(Node.class, &quot;status&quot;);</span>
<span class="udiff-line-added">+         private static final long NEXT</span>
<span class="udiff-line-added">+             = U.objectFieldOffset(Node.class, &quot;next&quot;);</span>
<span class="udiff-line-added">+         private static final long PREV</span>
<span class="udiff-line-added">+             = U.objectFieldOffset(Node.class, &quot;prev&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static final class WriterNode extends Node { // node for writers</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static final class ReaderNode extends Node { // node for readers</span>
<span class="udiff-line-added">+         volatile ReaderNode cowaiters;           // list of linked readers</span>
<span class="udiff-line-added">+         final boolean casCowaiters(ReaderNode c, ReaderNode v) {</span>
<span class="udiff-line-added">+             return U.weakCompareAndSetReference(this, COWAITERS, c, v);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         final void setCowaitersRelaxed(ReaderNode p) {</span>
<span class="udiff-line-added">+             U.putReference(this, COWAITERS, p);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         private static final long COWAITERS</span>
<span class="udiff-line-added">+             = U.objectFieldOffset(ReaderNode.class, &quot;cowaiters&quot;);</span>
      }
  
      /** Head of CLH queue */
<span class="udiff-line-modified-removed">-     private transient volatile WNode whead;</span>
<span class="udiff-line-modified-added">+     private transient volatile Node head;</span>
      /** Tail (last) of CLH queue */
<span class="udiff-line-modified-removed">-     private transient volatile WNode wtail;</span>
<span class="udiff-line-modified-added">+     private transient volatile Node tail;</span>
  
      // views
      transient ReadLockView readLockView;
      transient WriteLockView writeLockView;
      transient ReadWriteLockView readWriteLockView;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,46 +415,81 @@</span>
       */
      public StampedLock() {
          state = ORIGIN;
      }
  
<span class="udiff-line-modified-removed">-     private boolean casState(long expectedValue, long newValue) {</span>
<span class="udiff-line-modified-removed">-         return STATE.compareAndSet(this, expectedValue, newValue);</span>
<span class="udiff-line-modified-added">+     // internal lock methods</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     private boolean casState(long expect, long update) {</span>
<span class="udiff-line-added">+         return U.compareAndSetLong(this, STATE, expect, update);</span>
      }
  
<span class="udiff-line-modified-removed">-     private long tryWriteLock(long s) {</span>
<span class="udiff-line-modified-removed">-         // assert (s &amp; ABITS) == 0L;</span>
<span class="udiff-line-modified-removed">-         long next;</span>
<span class="udiff-line-modified-removed">-         if (casState(s, next = s | WBIT)) {</span>
<span class="udiff-line-modified-removed">-             VarHandle.storeStoreFence();</span>
<span class="udiff-line-modified-removed">-             return next;</span>
<span class="udiff-line-modified-added">+     @ReservedStackAccess</span>
<span class="udiff-line-modified-added">+     private long tryAcquireWrite() {</span>
<span class="udiff-line-modified-added">+         long s, nextState;</span>
<span class="udiff-line-modified-added">+         if (((s = state) &amp; ABITS) == 0L &amp;&amp; casState(s, nextState = s | WBIT)) {</span>
<span class="udiff-line-modified-added">+             U.storeStoreFence();</span>
<span class="udiff-line-modified-added">+             return nextState;</span>
          }
          return 0L;
      }
  
<span class="udiff-line-added">+     @ReservedStackAccess</span>
<span class="udiff-line-added">+     private long tryAcquireRead() {</span>
<span class="udiff-line-added">+         for (long s, m, nextState;;) {</span>
<span class="udiff-line-added">+             if ((m = (s = state) &amp; ABITS) &lt; RFULL) {</span>
<span class="udiff-line-added">+                 if (casState(s, nextState = s + RUNIT))</span>
<span class="udiff-line-added">+                     return nextState;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             else if (m == WBIT)</span>
<span class="udiff-line-added">+                 return 0L;</span>
<span class="udiff-line-added">+             else if ((nextState = tryIncReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-added">+                 return nextState;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns an unlocked state, incrementing the version and</span>
<span class="udiff-line-added">+      * avoiding special failure value 0L.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param s a write-locked state (or stamp)</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static long unlockWriteState(long s) {</span>
<span class="udiff-line-added">+         return ((s += WBIT) == 0L) ? ORIGIN : s;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private long releaseWrite(long s) {</span>
<span class="udiff-line-added">+         long nextState = state = unlockWriteState(s);</span>
<span class="udiff-line-added">+         signalNext(head);</span>
<span class="udiff-line-added">+         return nextState;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Exclusively acquires the lock, blocking if necessary
       * until available.
       *
       * @return a write stamp that can be used to unlock or convert mode
       */
      @ReservedStackAccess
      public long writeLock() {
<span class="udiff-line-modified-removed">-         long next;</span>
<span class="udiff-line-modified-removed">-         return ((next = tryWriteLock()) != 0L) ? next : acquireWrite(false, 0L);</span>
<span class="udiff-line-modified-added">+         // try unconditional CAS confirming weak read</span>
<span class="udiff-line-modified-added">+         long s = U.getLongOpaque(this, STATE) &amp; ~ABITS, nextState;</span>
<span class="udiff-line-added">+         if (casState(s, nextState = s | WBIT)) {</span>
<span class="udiff-line-added">+             U.storeStoreFence();</span>
<span class="udiff-line-added">+             return nextState;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return acquireWrite(false, false, 0L);</span>
      }
  
      /**
       * Exclusively acquires the lock if it is immediately available.
       *
       * @return a write stamp that can be used to unlock or convert mode,
       * or zero if the lock is not available
       */
<span class="udiff-line-removed">-     @ReservedStackAccess</span>
      public long tryWriteLock() {
<span class="udiff-line-modified-removed">-         long s;</span>
<span class="udiff-line-removed">-         return (((s = state) &amp; ABITS) == 0L) ? tryWriteLock(s) : 0L;</span>
<span class="udiff-line-modified-added">+         return tryAcquireWrite();</span>
      }
  
      /**
       * Exclusively acquires the lock if it is available within the
       * given time and the current thread has not been interrupted.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -502,19 +505,18 @@</span>
       */
      public long tryWriteLock(long time, TimeUnit unit)
          throws InterruptedException {
          long nanos = unit.toNanos(time);
          if (!Thread.interrupted()) {
<span class="udiff-line-modified-removed">-             long next, deadline;</span>
<span class="udiff-line-modified-removed">-             if ((next = tryWriteLock()) != 0L)</span>
<span class="udiff-line-modified-removed">-                 return next;</span>
<span class="udiff-line-modified-added">+             long nextState;</span>
<span class="udiff-line-modified-added">+             if ((nextState = tryAcquireWrite()) != 0L)</span>
<span class="udiff-line-modified-added">+                 return nextState;</span>
              if (nanos &lt;= 0L)
                  return 0L;
<span class="udiff-line-modified-removed">-             if ((deadline = System.nanoTime() + nanos) == 0L)</span>
<span class="udiff-line-modified-removed">-                 deadline = 1L;</span>
<span class="udiff-line-modified-removed">-             if ((next = acquireWrite(true, deadline)) != INTERRUPTED)</span>
<span class="udiff-line-removed">-                 return next;</span>
<span class="udiff-line-modified-added">+             nextState = acquireWrite(true, true, System.nanoTime() + nanos);</span>
<span class="udiff-line-modified-added">+             if (nextState != INTERRUPTED)</span>
<span class="udiff-line-modified-added">+                 return nextState;</span>
          }
          throw new InterruptedException();
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -525,16 +527,16 @@</span>
       *
       * @return a write stamp that can be used to unlock or convert mode
       * @throws InterruptedException if the current thread is interrupted
       * before acquiring the lock
       */
<span class="udiff-line-removed">-     @ReservedStackAccess</span>
      public long writeLockInterruptibly() throws InterruptedException {
<span class="udiff-line-modified-removed">-         long next;</span>
<span class="udiff-line-modified-added">+         long nextState;</span>
          if (!Thread.interrupted() &amp;&amp;
<span class="udiff-line-modified-removed">-             (next = acquireWrite(true, 0L)) != INTERRUPTED)</span>
<span class="udiff-line-modified-removed">-             return next;</span>
<span class="udiff-line-modified-added">+             ((nextState = tryAcquireWrite()) != 0L ||</span>
<span class="udiff-line-modified-added">+              (nextState = acquireWrite(true, false, 0L)) != INTERRUPTED))</span>
<span class="udiff-line-added">+             return nextState;</span>
          throw new InterruptedException();
      }
  
      /**
       * Non-exclusively acquires the lock, blocking if necessary
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -542,37 +544,26 @@</span>
       *
       * @return a read stamp that can be used to unlock or convert mode
       */
      @ReservedStackAccess
      public long readLock() {
<span class="udiff-line-modified-removed">-         long s, next;</span>
<span class="udiff-line-modified-removed">-         // bypass acquireRead on common uncontended case</span>
<span class="udiff-line-modified-removed">-         return (whead == wtail</span>
<span class="udiff-line-modified-removed">-                 &amp;&amp; ((s = state) &amp; ABITS) &lt; RFULL</span>
<span class="udiff-line-modified-removed">-                 &amp;&amp; casState(s, next = s + RUNIT))</span>
<span class="udiff-line-modified-removed">-             ? next</span>
<span class="udiff-line-removed">-             : acquireRead(false, 0L);</span>
<span class="udiff-line-modified-added">+         // unconditionally optimistically try non-overflow case once</span>
<span class="udiff-line-modified-added">+         long s = U.getLongOpaque(this, STATE) &amp; RSAFE, nextState;</span>
<span class="udiff-line-modified-added">+         if (casState(s, nextState = s + RUNIT))</span>
<span class="udiff-line-modified-added">+             return nextState;</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+             return acquireRead(false, false, 0L);</span>
      }
  
      /**
       * Non-exclusively acquires the lock if it is immediately available.
       *
       * @return a read stamp that can be used to unlock or convert mode,
       * or zero if the lock is not available
       */
<span class="udiff-line-removed">-     @ReservedStackAccess</span>
      public long tryReadLock() {
<span class="udiff-line-modified-removed">-         long s, m, next;</span>
<span class="udiff-line-removed">-         while ((m = (s = state) &amp; ABITS) != WBIT) {</span>
<span class="udiff-line-removed">-             if (m &lt; RFULL) {</span>
<span class="udiff-line-removed">-                 if (casState(s, next = s + RUNIT))</span>
<span class="udiff-line-removed">-                     return next;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-removed">-                 return next;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return 0L;</span>
<span class="udiff-line-modified-added">+         return tryAcquireRead();</span>
      }
  
      /**
       * Non-exclusively acquires the lock if it is available within the
       * given time and the current thread has not been interrupted.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -584,30 +575,22 @@</span>
       * @return a read stamp that can be used to unlock or convert mode,
       * or zero if the lock is not available
       * @throws InterruptedException if the current thread is interrupted
       * before acquiring the lock
       */
<span class="udiff-line-removed">-     @ReservedStackAccess</span>
      public long tryReadLock(long time, TimeUnit unit)
          throws InterruptedException {
<span class="udiff-line-removed">-         long s, m, next, deadline;</span>
          long nanos = unit.toNanos(time);
          if (!Thread.interrupted()) {
<span class="udiff-line-modified-removed">-             if ((m = (s = state) &amp; ABITS) != WBIT) {</span>
<span class="udiff-line-modified-removed">-                 if (m &lt; RFULL) {</span>
<span class="udiff-line-modified-removed">-                     if (casState(s, next = s + RUNIT))</span>
<span class="udiff-line-removed">-                         return next;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-removed">-                     return next;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             long nextState;</span>
<span class="udiff-line-modified-added">+             if (tail == head &amp;&amp; (nextState = tryAcquireRead()) != 0L)</span>
<span class="udiff-line-modified-added">+                 return nextState;</span>
              if (nanos &lt;= 0L)
                  return 0L;
<span class="udiff-line-modified-removed">-             if ((deadline = System.nanoTime() + nanos) == 0L)</span>
<span class="udiff-line-modified-removed">-                 deadline = 1L;</span>
<span class="udiff-line-modified-removed">-             if ((next = acquireRead(true, deadline)) != INTERRUPTED)</span>
<span class="udiff-line-removed">-                 return next;</span>
<span class="udiff-line-modified-added">+             nextState = acquireRead(true, true, System.nanoTime() + nanos);</span>
<span class="udiff-line-modified-added">+             if (nextState != INTERRUPTED)</span>
<span class="udiff-line-modified-added">+                 return nextState;</span>
          }
          throw new InterruptedException();
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -618,21 +601,16 @@</span>
       *
       * @return a read stamp that can be used to unlock or convert mode
       * @throws InterruptedException if the current thread is interrupted
       * before acquiring the lock
       */
<span class="udiff-line-removed">-     @ReservedStackAccess</span>
      public long readLockInterruptibly() throws InterruptedException {
<span class="udiff-line-modified-removed">-         long s, next;</span>
<span class="udiff-line-modified-removed">-         if (!Thread.interrupted()</span>
<span class="udiff-line-modified-removed">-             // bypass acquireRead on common uncontended case</span>
<span class="udiff-line-modified-removed">-             &amp;&amp; ((whead == wtail</span>
<span class="udiff-line-modified-removed">-                  &amp;&amp; ((s = state) &amp; ABITS) &lt; RFULL</span>
<span class="udiff-line-removed">-                  &amp;&amp; casState(s, next = s + RUNIT))</span>
<span class="udiff-line-removed">-                 ||</span>
<span class="udiff-line-removed">-                 (next = acquireRead(true, 0L)) != INTERRUPTED))</span>
<span class="udiff-line-removed">-             return next;</span>
<span class="udiff-line-modified-added">+         long nextState;</span>
<span class="udiff-line-modified-added">+         if (!Thread.interrupted() &amp;&amp;</span>
<span class="udiff-line-modified-added">+             ((nextState = tryAcquireRead()) != 0L ||</span>
<span class="udiff-line-modified-added">+              (nextState = acquireRead(true, false, 0L)) != INTERRUPTED))</span>
<span class="udiff-line-modified-added">+             return nextState;</span>
          throw new InterruptedException();
      }
  
      /**
       * Returns a stamp that can later be validated, or zero
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -656,32 +634,14 @@</span>
       * @param stamp a stamp
       * @return {@code true} if the lock has not been exclusively acquired
       * since issuance of the given stamp; else false
       */
      public boolean validate(long stamp) {
<span class="udiff-line-modified-removed">-         VarHandle.acquireFence();</span>
<span class="udiff-line-modified-added">+         U.loadFence();</span>
          return (stamp &amp; SBITS) == (state &amp; SBITS);
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Returns an unlocked state, incrementing the version and</span>
<span class="udiff-line-removed">-      * avoiding special failure value 0L.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param s a write-locked state (or stamp)</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static long unlockWriteState(long s) {</span>
<span class="udiff-line-removed">-         return ((s += WBIT) == 0L) ? ORIGIN : s;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private long unlockWriteInternal(long s) {</span>
<span class="udiff-line-removed">-         long next; WNode h;</span>
<span class="udiff-line-removed">-         STATE.setVolatile(this, next = unlockWriteState(s));</span>
<span class="udiff-line-removed">-         if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="udiff-line-removed">-             release(h);</span>
<span class="udiff-line-removed">-         return next;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * If the lock state matches the given stamp, releases the
       * exclusive lock.
       *
       * @param stamp a stamp returned by a write-lock operation
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -690,11 +650,11 @@</span>
       */
      @ReservedStackAccess
      public void unlockWrite(long stamp) {
          if (state != stamp || (stamp &amp; WBIT) == 0L)
              throw new IllegalMonitorStateException();
<span class="udiff-line-modified-removed">-         unlockWriteInternal(stamp);</span>
<span class="udiff-line-modified-added">+         releaseWrite(stamp);</span>
      }
  
      /**
       * If the lock state matches the given stamp, releases the
       * non-exclusive lock.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -703,23 +663,24 @@</span>
       * @throws IllegalMonitorStateException if the stamp does
       * not match the current state of this lock
       */
      @ReservedStackAccess
      public void unlockRead(long stamp) {
<span class="udiff-line-modified-removed">-         long s, m; WNode h;</span>
<span class="udiff-line-modified-removed">-         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)</span>
<span class="udiff-line-modified-removed">-                &amp;&amp; (stamp &amp; RBITS) &gt; 0L</span>
<span class="udiff-line-modified-removed">-                &amp;&amp; ((m = s &amp; RBITS) &gt; 0L)) {</span>
<span class="udiff-line-modified-removed">-             if (m &lt; RFULL) {</span>
<span class="udiff-line-modified-removed">-                 if (casState(s, s - RUNIT)) {</span>
<span class="udiff-line-modified-removed">-                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="udiff-line-modified-removed">-                         release(h);</span>
<span class="udiff-line-modified-removed">-                     return;</span>
<span class="udiff-line-modified-added">+         long s, m;</span>
<span class="udiff-line-modified-added">+         if ((stamp &amp; RBITS) != 0L) {</span>
<span class="udiff-line-modified-added">+             while (((s = state) &amp; SBITS) == (stamp &amp; SBITS) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                    ((m = s &amp; RBITS) != 0L)) {</span>
<span class="udiff-line-modified-added">+                 if (m &lt; RFULL) {</span>
<span class="udiff-line-modified-added">+                     if (casState(s, s - RUNIT)) {</span>
<span class="udiff-line-modified-added">+                         if (m == RUNIT)</span>
<span class="udiff-line-modified-added">+                             signalNext(head);</span>
<span class="udiff-line-modified-added">+                         return;</span>
<span class="udiff-line-added">+                     }</span>
                  }
<span class="udiff-line-added">+                 else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="udiff-line-added">+                     return;</span>
              }
<span class="udiff-line-removed">-             else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="udiff-line-removed">-                 return;</span>
          }
          throw new IllegalMonitorStateException();
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -728,11 +689,10 @@</span>
       *
       * @param stamp a stamp returned by a lock operation
       * @throws IllegalMonitorStateException if the stamp does
       * not match the current state of this lock
       */
<span class="udiff-line-removed">-     @ReservedStackAccess</span>
      public void unlock(long stamp) {
          if ((stamp &amp; WBIT) != 0L)
              unlockWrite(stamp);
          else
              unlockRead(stamp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -749,30 +709,27 @@</span>
       *
       * @param stamp a stamp
       * @return a valid write stamp, or zero on failure
       */
      public long tryConvertToWriteLock(long stamp) {
<span class="udiff-line-modified-removed">-         long a = stamp &amp; ABITS, m, s, next;</span>
<span class="udiff-line-modified-added">+         long a = stamp &amp; ABITS, m, s, nextState;</span>
          while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
              if ((m = s &amp; ABITS) == 0L) {
                  if (a != 0L)
                      break;
<span class="udiff-line-modified-removed">-                 if ((next = tryWriteLock(s)) != 0L)</span>
<span class="udiff-line-modified-removed">-                     return next;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (m == WBIT) {</span>
<span class="udiff-line-modified-added">+                 if (casState(s, nextState = s | WBIT)) {</span>
<span class="udiff-line-modified-added">+                     U.storeStoreFence();</span>
<span class="udiff-line-modified-added">+                     return nextState;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-added">+             } else if (m == WBIT) {</span>
                  if (a != m)
                      break;
                  return stamp;
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (m == RUNIT &amp;&amp; a != 0L) {</span>
<span class="udiff-line-modified-removed">-                 if (casState(s, next = s - RUNIT + WBIT)) {</span>
<span class="udiff-line-modified-removed">-                     VarHandle.storeStoreFence();</span>
<span class="udiff-line-removed">-                     return next;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-modified-added">+             } else if (m == RUNIT &amp;&amp; a != 0L) {</span>
<span class="udiff-line-modified-added">+                 if (casState(s, nextState = s - RUNIT + WBIT))</span>
<span class="udiff-line-modified-added">+                     return nextState;</span>
<span class="udiff-line-modified-added">+             } else</span>
                  break;
          }
          return 0L;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -786,32 +743,25 @@</span>
       *
       * @param stamp a stamp
       * @return a valid read stamp, or zero on failure
       */
      public long tryConvertToReadLock(long stamp) {
<span class="udiff-line-modified-removed">-         long a, s, next; WNode h;</span>
<span class="udiff-line-modified-added">+         long a, s, nextState;</span>
          while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
              if ((a = stamp &amp; ABITS) &gt;= WBIT) {
<span class="udiff-line-modified-removed">-                 // write stamp</span>
<span class="udiff-line-removed">-                 if (s != stamp)</span>
<span class="udiff-line-modified-added">+                 if (s != stamp) // write stamp</span>
                      break;
<span class="udiff-line-modified-removed">-                 STATE.setVolatile(this, next = unlockWriteState(s) + RUNIT);</span>
<span class="udiff-line-modified-removed">-                 if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="udiff-line-modified-removed">-                     release(h);</span>
<span class="udiff-line-modified-removed">-                 return next;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             else if (a == 0L) {</span>
<span class="udiff-line-removed">-                 // optimistic read stamp</span>
<span class="udiff-line-modified-added">+                 nextState = state = unlockWriteState(s) + RUNIT;</span>
<span class="udiff-line-modified-added">+                 signalNext(head);</span>
<span class="udiff-line-modified-added">+                 return nextState;</span>
<span class="udiff-line-modified-added">+             } else if (a == 0L) { // optimistic read stamp</span>
                  if ((s &amp; ABITS) &lt; RFULL) {
<span class="udiff-line-modified-removed">-                     if (casState(s, next = s + RUNIT))</span>
<span class="udiff-line-modified-removed">-                         return next;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-modified-removed">-                     return next;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             else {</span>
<span class="udiff-line-removed">-                 // already a read stamp</span>
<span class="udiff-line-modified-added">+                     if (casState(s, nextState = s + RUNIT))</span>
<span class="udiff-line-modified-added">+                         return nextState;</span>
<span class="udiff-line-modified-added">+                 } else if ((nextState = tryIncReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-modified-added">+                     return nextState;</span>
<span class="udiff-line-modified-added">+             } else { // already a read stamp</span>
                  if ((s &amp; ABITS) == 0L)
                      break;
                  return stamp;
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -827,33 +777,29 @@</span>
       *
       * @param stamp a stamp
       * @return a valid optimistic read stamp, or zero on failure
       */
      public long tryConvertToOptimisticRead(long stamp) {
<span class="udiff-line-modified-removed">-         long a, m, s, next; WNode h;</span>
<span class="udiff-line-modified-removed">-         VarHandle.acquireFence();</span>
<span class="udiff-line-modified-added">+         long a, m, s, nextState;</span>
<span class="udiff-line-modified-added">+         U.loadFence();</span>
          while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
              if ((a = stamp &amp; ABITS) &gt;= WBIT) {
<span class="udiff-line-modified-removed">-                 // write stamp</span>
<span class="udiff-line-removed">-                 if (s != stamp)</span>
<span class="udiff-line-modified-added">+                 if (s != stamp)   // write stamp</span>
                      break;
<span class="udiff-line-modified-removed">-                 return unlockWriteInternal(s);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-removed">-             else if (a == 0L)</span>
<span class="udiff-line-removed">-                 // already an optimistic read stamp</span>
<span class="udiff-line-modified-added">+                 return releaseWrite(s);</span>
<span class="udiff-line-modified-added">+             } else if (a == 0L) { // already an optimistic read stamp</span>
                  return stamp;
<span class="udiff-line-modified-removed">-             else if ((m = s &amp; ABITS) == 0L) // invalid read stamp</span>
<span class="udiff-line-modified-added">+             } else if ((m = s &amp; ABITS) == 0L) { // invalid read stamp</span>
                  break;
<span class="udiff-line-modified-removed">-             else if (m &lt; RFULL) {</span>
<span class="udiff-line-modified-removed">-                 if (casState(s, next = s - RUNIT)) {</span>
<span class="udiff-line-modified-removed">-                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="udiff-line-modified-removed">-                         release(h);</span>
<span class="udiff-line-modified-removed">-                     return next &amp; SBITS;</span>
<span class="udiff-line-modified-added">+             } else if (m &lt; RFULL) {</span>
<span class="udiff-line-modified-added">+                 if (casState(s, nextState = s - RUNIT)) {</span>
<span class="udiff-line-modified-added">+                     if (m == RUNIT)</span>
<span class="udiff-line-modified-added">+                         signalNext(head);</span>
<span class="udiff-line-modified-added">+                     return nextState &amp; SBITS;</span>
                  }
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if ((next = tryDecReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-removed">-                 return next &amp; SBITS;</span>
<span class="udiff-line-modified-added">+             } else if ((nextState = tryDecReaderOverflow(s)) != 0L)</span>
<span class="udiff-line-modified-added">+                 return nextState &amp; SBITS;</span>
          }
          return 0L;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -865,11 +811,11 @@</span>
       */
      @ReservedStackAccess
      public boolean tryUnlockWrite() {
          long s;
          if (((s = state) &amp; WBIT) != 0L) {
<span class="udiff-line-modified-removed">-             unlockWriteInternal(s);</span>
<span class="udiff-line-modified-added">+             releaseWrite(s);</span>
              return true;
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -880,16 +826,16 @@</span>
       *
       * @return {@code true} if the read lock was held, else false
       */
      @ReservedStackAccess
      public boolean tryUnlockRead() {
<span class="udiff-line-modified-removed">-         long s, m; WNode h;</span>
<span class="udiff-line-modified-added">+         long s, m;</span>
          while ((m = (s = state) &amp; ABITS) != 0L &amp;&amp; m &lt; WBIT) {
              if (m &lt; RFULL) {
                  if (casState(s, s - RUNIT)) {
<span class="udiff-line-modified-removed">-                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="udiff-line-modified-removed">-                         release(h);</span>
<span class="udiff-line-modified-added">+                     if (m == RUNIT)</span>
<span class="udiff-line-modified-added">+                         signalNext(head);</span>
                      return true;
                  }
              }
              else if (tryDecReaderOverflow(s) != 0L)
                  return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1131,20 +1077,20 @@</span>
  
      final void unstampedUnlockWrite() {
          long s;
          if (((s = state) &amp; WBIT) == 0L)
              throw new IllegalMonitorStateException();
<span class="udiff-line-modified-removed">-         unlockWriteInternal(s);</span>
<span class="udiff-line-modified-added">+         releaseWrite(s);</span>
      }
  
      final void unstampedUnlockRead() {
<span class="udiff-line-modified-removed">-         long s, m; WNode h;</span>
<span class="udiff-line-modified-added">+         long s, m;</span>
          while ((m = (s = state) &amp; RBITS) &gt; 0L) {
              if (m &lt; RFULL) {
                  if (casState(s, s - RUNIT)) {
<span class="udiff-line-modified-removed">-                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="udiff-line-modified-removed">-                         release(h);</span>
<span class="udiff-line-modified-added">+                     if (m == RUNIT)</span>
<span class="udiff-line-modified-added">+                         signalNext(head);</span>
                      return;
                  }
              }
              else if (tryDecReaderOverflow(s) != 0L)
                  return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1153,14 +1099,14 @@</span>
      }
  
      private void readObject(java.io.ObjectInputStream s)
          throws java.io.IOException, ClassNotFoundException {
          s.defaultReadObject();
<span class="udiff-line-modified-removed">-         STATE.setVolatile(this, ORIGIN); // reset to unlocked state</span>
<span class="udiff-line-modified-added">+         state = ORIGIN; // reset to unlocked state</span>
      }
  
<span class="udiff-line-modified-removed">-     // internals</span>
<span class="udiff-line-modified-added">+     // overflow handling methods</span>
  
      /**
       * Tries to increment readerOverflow by first setting state
       * access bits value to RBITS, indicating hold of spinlock,
       * then updating, then releasing.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1168,21 +1114,16 @@</span>
       * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
       * @return new stamp on success, else zero
       */
      private long tryIncReaderOverflow(long s) {
          // assert (s &amp; ABITS) &gt;= RFULL;
<span class="udiff-line-modified-removed">-         if ((s &amp; ABITS) == RFULL) {</span>
<span class="udiff-line-removed">-             if (casState(s, s | RBITS)) {</span>
<span class="udiff-line-removed">-                 ++readerOverflow;</span>
<span class="udiff-line-removed">-                 STATE.setVolatile(this, s);</span>
<span class="udiff-line-removed">-                 return s;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         else if ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == 0)</span>
<span class="udiff-line-removed">-             Thread.yield();</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-modified-added">+         if ((s &amp; ABITS) != RFULL)</span>
              Thread.onSpinWait();
<span class="udiff-line-added">+         else if (casState(s, s | RBITS)) {</span>
<span class="udiff-line-added">+             ++readerOverflow;</span>
<span class="udiff-line-added">+             return state = s;</span>
<span class="udiff-line-added">+         }</span>
          return 0L;
      }
  
      /**
       * Tries to decrement readerOverflow.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1190,445 +1131,368 @@</span>
       * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
       * @return new stamp on success, else zero
       */
      private long tryDecReaderOverflow(long s) {
          // assert (s &amp; ABITS) &gt;= RFULL;
<span class="udiff-line-modified-removed">-         if ((s &amp; ABITS) == RFULL) {</span>
<span class="udiff-line-modified-removed">-             if (casState(s, s | RBITS)) {</span>
<span class="udiff-line-modified-removed">-                 int r; long next;</span>
<span class="udiff-line-modified-removed">-                 if ((r = readerOverflow) &gt; 0) {</span>
<span class="udiff-line-modified-removed">-                     readerOverflow = r - 1;</span>
<span class="udiff-line-modified-removed">-                     next = s;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-removed">-                 else</span>
<span class="udiff-line-removed">-                     next = s - RUNIT;</span>
<span class="udiff-line-removed">-                 STATE.setVolatile(this, next);</span>
<span class="udiff-line-removed">-                 return next;</span>
<span class="udiff-line-modified-added">+         if ((s &amp; ABITS) != RFULL)</span>
<span class="udiff-line-modified-added">+             Thread.onSpinWait();</span>
<span class="udiff-line-modified-added">+         else if (casState(s, s | RBITS)) {</span>
<span class="udiff-line-modified-added">+             int r; long nextState;</span>
<span class="udiff-line-modified-added">+             if ((r = readerOverflow) &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 readerOverflow = r - 1;</span>
<span class="udiff-line-modified-added">+                 nextState = s;</span>
              }
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 nextState = s - RUNIT;</span>
<span class="udiff-line-added">+             return state = nextState;</span>
          }
<span class="udiff-line-removed">-         else if ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == 0)</span>
<span class="udiff-line-removed">-             Thread.yield();</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             Thread.onSpinWait();</span>
          return 0L;
      }
  
<span class="udiff-line-added">+     // release methods</span>
<span class="udiff-line-added">+ </span>
      /**
<span class="udiff-line-modified-removed">-      * Wakes up the successor of h (normally whead). This is normally</span>
<span class="udiff-line-modified-removed">-      * just h.next, but may require traversal from wtail if next</span>
<span class="udiff-line-modified-removed">-      * pointers are lagging. This may fail to wake up an acquiring</span>
<span class="udiff-line-modified-removed">-      * thread when one or more have been cancelled, but the cancel</span>
<span class="udiff-line-removed">-      * methods themselves provide extra safeguards to ensure liveness.</span>
<span class="udiff-line-modified-added">+      * Wakes up the successor of given node, if one exists, and unsets its</span>
<span class="udiff-line-modified-added">+      * WAITING status to avoid park race. This may fail to wake up an</span>
<span class="udiff-line-modified-added">+      * eligible thread when one or more have been cancelled, but</span>
<span class="udiff-line-modified-added">+      * cancelAcquire ensures liveness.</span>
       */
<span class="udiff-line-modified-removed">-     private void release(WNode h) {</span>
<span class="udiff-line-modified-removed">-         if (h != null) {</span>
<span class="udiff-line-modified-removed">-             WNode q; Thread w;</span>
<span class="udiff-line-modified-removed">-             WSTATUS.compareAndSet(h, WAITING, 0);</span>
<span class="udiff-line-modified-removed">-             if ((q = h.next) == null || q.status == CANCELLED) {</span>
<span class="udiff-line-modified-removed">-                 for (WNode t = wtail; t != null &amp;&amp; t != h; t = t.prev)</span>
<span class="udiff-line-modified-removed">-                     if (t.status &lt;= 0)</span>
<span class="udiff-line-modified-removed">-                         q = t;</span>
<span class="udiff-line-modified-added">+     static final void signalNext(Node h) {</span>
<span class="udiff-line-modified-added">+         Node s;</span>
<span class="udiff-line-modified-added">+         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp; s.status &gt; 0) {</span>
<span class="udiff-line-modified-added">+             s.getAndUnsetStatus(WAITING);</span>
<span class="udiff-line-modified-added">+             LockSupport.unpark(s.waiter);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Removes and unparks all cowaiters of node, if it exists.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static void signalCowaiters(ReaderNode node) {</span>
<span class="udiff-line-added">+         if (node != null) {</span>
<span class="udiff-line-added">+             for (ReaderNode c; (c = node.cowaiters) != null; ) {</span>
<span class="udiff-line-added">+                 if (node.casCowaiters(c, c.cowaiters))</span>
<span class="udiff-line-added">+                     LockSupport.unpark(c.waiter);</span>
              }
<span class="udiff-line-removed">-             if (q != null &amp;&amp; (w = q.thread) != null)</span>
<span class="udiff-line-removed">-                 LockSupport.unpark(w);</span>
          }
      }
  
<span class="udiff-line-added">+     // queue link methods</span>
<span class="udiff-line-added">+     private boolean casTail(Node c, Node v) {</span>
<span class="udiff-line-added">+         return U.compareAndSetReference(this, TAIL, c, v);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** tries once to CAS a new dummy node for head */</span>
<span class="udiff-line-added">+     private void tryInitializeHead() {</span>
<span class="udiff-line-added">+         Node h = new WriterNode();</span>
<span class="udiff-line-added">+         if (U.compareAndSetReference(this, HEAD, null, h))</span>
<span class="udiff-line-added">+             tail = h;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
<span class="udiff-line-modified-removed">-      * See above for explanation.</span>
<span class="udiff-line-modified-added">+      * For explanation, see above and AbstractQueuedSynchronizer</span>
<span class="udiff-line-added">+      * internal documentation.</span>
       *
       * @param interruptible true if should check interrupts and if so
       * return INTERRUPTED
<span class="udiff-line-modified-removed">-      * @param deadline if nonzero, the System.nanoTime value to timeout</span>
<span class="udiff-line-modified-removed">-      * at (and return zero)</span>
<span class="udiff-line-modified-added">+      * @param timed if true use timed waits</span>
<span class="udiff-line-modified-added">+      * @param time the System.nanoTime value to timeout at (and return zero)</span>
       * @return next state, or INTERRUPTED
       */
<span class="udiff-line-modified-removed">-     private long acquireWrite(boolean interruptible, long deadline) {</span>
<span class="udiff-line-modified-removed">-         WNode node = null, p;</span>
<span class="udiff-line-modified-removed">-         for (int spins = -1;;) { // spin while enqueuing</span>
<span class="udiff-line-modified-removed">-             long m, s, ns;</span>
<span class="udiff-line-modified-removed">-             if ((m = (s = state) &amp; ABITS) == 0L) {</span>
<span class="udiff-line-modified-removed">-                 if ((ns = tryWriteLock(s)) != 0L)</span>
<span class="udiff-line-modified-removed">-                     return ns;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (spins &lt; 0)</span>
<span class="udiff-line-modified-removed">-                 spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : 0;</span>
<span class="udiff-line-modified-removed">-             else if (spins &gt; 0) {</span>
<span class="udiff-line-modified-removed">-                 --spins;</span>
<span class="udiff-line-modified-removed">-                 Thread.onSpinWait();</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-removed">-             else if ((p = wtail) == null) { // initialize queue</span>
<span class="udiff-line-removed">-                 WNode hd = new WNode(WMODE, null);</span>
<span class="udiff-line-removed">-                 if (WHEAD.weakCompareAndSet(this, null, hd))</span>
<span class="udiff-line-removed">-                     wtail = hd;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             else if (node == null)</span>
<span class="udiff-line-removed">-                 node = new WNode(WMODE, p);</span>
<span class="udiff-line-removed">-             else if (node.prev != p)</span>
<span class="udiff-line-removed">-                 node.prev = p;</span>
<span class="udiff-line-removed">-             else if (WTAIL.weakCompareAndSet(this, p, node)) {</span>
<span class="udiff-line-removed">-                 p.next = node;</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         boolean wasInterrupted = false;</span>
<span class="udiff-line-removed">-         for (int spins = -1;;) {</span>
<span class="udiff-line-removed">-             WNode h, np, pp; int ps;</span>
<span class="udiff-line-removed">-             if ((h = whead) == p) {</span>
<span class="udiff-line-removed">-                 if (spins &lt; 0)</span>
<span class="udiff-line-removed">-                     spins = HEAD_SPINS;</span>
<span class="udiff-line-removed">-                 else if (spins &lt; MAX_HEAD_SPINS)</span>
<span class="udiff-line-removed">-                     spins &lt;&lt;= 1;</span>
<span class="udiff-line-removed">-                 for (int k = spins; k &gt; 0; --k) { // spin at head</span>
<span class="udiff-line-removed">-                     long s, ns;</span>
<span class="udiff-line-removed">-                     if (((s = state) &amp; ABITS) == 0L) {</span>
<span class="udiff-line-removed">-                         if ((ns = tryWriteLock(s)) != 0L) {</span>
<span class="udiff-line-removed">-                             whead = node;</span>
<span class="udiff-line-removed">-                             node.prev = null;</span>
<span class="udiff-line-removed">-                             if (wasInterrupted)</span>
<span class="udiff-line-removed">-                                 Thread.currentThread().interrupt();</span>
<span class="udiff-line-removed">-                             return ns;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     else</span>
<span class="udiff-line-removed">-                         Thread.onSpinWait();</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             else if (h != null) { // help release stale waiters</span>
<span class="udiff-line-removed">-                 WNode c; Thread w;</span>
<span class="udiff-line-removed">-                 while ((c = h.cowait) != null) {</span>
<span class="udiff-line-removed">-                     if (WCOWAIT.weakCompareAndSet(h, c, c.cowait) &amp;&amp;</span>
<span class="udiff-line-removed">-                         (w = c.thread) != null)</span>
<span class="udiff-line-removed">-                         LockSupport.unpark(w);</span>
<span class="udiff-line-modified-added">+     private long acquireWrite(boolean interruptible, boolean timed, long time) {</span>
<span class="udiff-line-modified-added">+         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="udiff-line-modified-added">+         boolean interrupted = false, first = false;</span>
<span class="udiff-line-modified-added">+         WriterNode node = null;</span>
<span class="udiff-line-modified-added">+         Node pred = null;</span>
<span class="udiff-line-modified-added">+         for (long s, nextState;;) {</span>
<span class="udiff-line-modified-added">+             if (!first &amp;&amp; (pred = (node == null) ? null : node.prev) != null &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 !(first = (head == pred))) {</span>
<span class="udiff-line-modified-added">+                 if (pred.status &lt; 0) {</span>
<span class="udiff-line-modified-added">+                     cleanQueue();           // predecessor cancelled</span>
<span class="udiff-line-modified-added">+                     continue;</span>
<span class="udiff-line-modified-added">+                 } else if (pred.prev == null) {</span>
<span class="udiff-line-modified-added">+                     Thread.onSpinWait();    // ensure serialization</span>
<span class="udiff-line-modified-added">+                     continue;</span>
                  }
              }
<span class="udiff-line-modified-removed">-             if (whead == h) {</span>
<span class="udiff-line-modified-removed">-                 if ((np = node.prev) != p) {</span>
<span class="udiff-line-modified-removed">-                     if (np != null)</span>
<span class="udiff-line-modified-removed">-                         (p = np).next = node;   // stale</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 else if ((ps = p.status) == 0)</span>
<span class="udiff-line-modified-removed">-                     WSTATUS.compareAndSet(p, 0, WAITING);</span>
<span class="udiff-line-modified-removed">-                 else if (ps == CANCELLED) {</span>
<span class="udiff-line-modified-removed">-                     if ((pp = p.prev) != null) {</span>
<span class="udiff-line-modified-removed">-                         node.prev = pp;</span>
<span class="udiff-line-removed">-                         pp.next = node;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 else {</span>
<span class="udiff-line-removed">-                     long time; // 0 argument to park means no timeout</span>
<span class="udiff-line-removed">-                     if (deadline == 0L)</span>
<span class="udiff-line-removed">-                         time = 0L;</span>
<span class="udiff-line-removed">-                     else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="udiff-line-removed">-                         return cancelWaiter(node, node, false);</span>
<span class="udiff-line-removed">-                     Thread wt = Thread.currentThread();</span>
<span class="udiff-line-removed">-                     node.thread = wt;</span>
<span class="udiff-line-removed">-                     if (p.status &lt; 0 &amp;&amp; (p != h || (state &amp; ABITS) != 0L) &amp;&amp;</span>
<span class="udiff-line-removed">-                         whead == h &amp;&amp; node.prev == p) {</span>
<span class="udiff-line-removed">-                         if (time == 0L)</span>
<span class="udiff-line-removed">-                             LockSupport.park(this);</span>
<span class="udiff-line-removed">-                         else</span>
<span class="udiff-line-removed">-                             LockSupport.parkNanos(this, time);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     node.thread = null;</span>
<span class="udiff-line-removed">-                     if (Thread.interrupted()) {</span>
<span class="udiff-line-removed">-                         if (interruptible)</span>
<span class="udiff-line-removed">-                             return cancelWaiter(node, node, true);</span>
<span class="udiff-line-removed">-                         wasInterrupted = true;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-modified-added">+             if ((first || pred == null) &amp;&amp; ((s = state) &amp; ABITS) == 0L &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 casState(s, nextState = s | WBIT)) {</span>
<span class="udiff-line-modified-added">+                 U.storeStoreFence();</span>
<span class="udiff-line-modified-added">+                 if (first) {</span>
<span class="udiff-line-modified-added">+                     node.prev = null;</span>
<span class="udiff-line-modified-added">+                     head = node;</span>
<span class="udiff-line-modified-added">+                     pred.next = null;</span>
<span class="udiff-line-modified-added">+                     node.waiter = null;</span>
<span class="udiff-line-modified-added">+                     if (interrupted)</span>
<span class="udiff-line-modified-added">+                         Thread.currentThread().interrupt();</span>
                  }
<span class="udiff-line-added">+                 return nextState;</span>
<span class="udiff-line-added">+             } else if (node == null) {          // retry before enqueuing</span>
<span class="udiff-line-added">+                 node = new WriterNode();</span>
<span class="udiff-line-added">+             } else if (pred == null) {          // try to enqueue</span>
<span class="udiff-line-added">+                 Node t = tail;</span>
<span class="udiff-line-added">+                 node.setPrevRelaxed(t);</span>
<span class="udiff-line-added">+                 if (t == null)</span>
<span class="udiff-line-added">+                     tryInitializeHead();</span>
<span class="udiff-line-added">+                 else if (!casTail(t, node))</span>
<span class="udiff-line-added">+                     node.setPrevRelaxed(null);  // back out</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     t.next = node;</span>
<span class="udiff-line-added">+             } else if (first &amp;&amp; spins != 0) {   // reduce unfairness</span>
<span class="udiff-line-added">+                 --spins;</span>
<span class="udiff-line-added">+                 Thread.onSpinWait();</span>
<span class="udiff-line-added">+             } else if (node.status == 0) {      // enable signal</span>
<span class="udiff-line-added">+                 if (node.waiter == null)</span>
<span class="udiff-line-added">+                     node.waiter = Thread.currentThread();</span>
<span class="udiff-line-added">+                 node.status = WAITING;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 long nanos;</span>
<span class="udiff-line-added">+                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="udiff-line-added">+                 if (!timed)</span>
<span class="udiff-line-added">+                     LockSupport.park(this);</span>
<span class="udiff-line-added">+                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="udiff-line-added">+                     LockSupport.parkNanos(this, nanos);</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 node.clearStatus();</span>
<span class="udiff-line-added">+                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="udiff-line-added">+                     break;</span>
              }
          }
<span class="udiff-line-added">+         return cancelAcquire(node, interrupted);</span>
      }
  
      /**
       * See above for explanation.
       *
       * @param interruptible true if should check interrupts and if so
       * return INTERRUPTED
<span class="udiff-line-modified-removed">-      * @param deadline if nonzero, the System.nanoTime value to timeout</span>
<span class="udiff-line-modified-removed">-      * at (and return zero)</span>
<span class="udiff-line-modified-added">+      * @param timed if true use timed waits</span>
<span class="udiff-line-modified-added">+      * @param time the System.nanoTime value to timeout at (and return zero)</span>
       * @return next state, or INTERRUPTED
       */
<span class="udiff-line-modified-removed">-     private long acquireRead(boolean interruptible, long deadline) {</span>
<span class="udiff-line-modified-removed">-         boolean wasInterrupted = false;</span>
<span class="udiff-line-modified-removed">-         WNode node = null, p;</span>
<span class="udiff-line-modified-removed">-         for (int spins = -1;;) {</span>
<span class="udiff-line-modified-removed">-             WNode h;</span>
<span class="udiff-line-modified-removed">-             if ((h = whead) == (p = wtail)) {</span>
<span class="udiff-line-modified-removed">-                 for (long m, s, ns;;) {</span>
<span class="udiff-line-modified-removed">-                     if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="udiff-line-modified-removed">-                         casState(s, ns = s + RUNIT) :</span>
<span class="udiff-line-modified-removed">-                         (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
<span class="udiff-line-modified-removed">-                         if (wasInterrupted)</span>
<span class="udiff-line-modified-removed">-                             Thread.currentThread().interrupt();</span>
<span class="udiff-line-modified-removed">-                         return ns;</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     else if (m &gt;= WBIT) {</span>
<span class="udiff-line-modified-removed">-                         if (spins &gt; 0) {</span>
<span class="udiff-line-modified-removed">-                             --spins;</span>
<span class="udiff-line-modified-removed">-                             Thread.onSpinWait();</span>
<span class="udiff-line-modified-removed">-                         }</span>
<span class="udiff-line-modified-removed">-                         else {</span>
<span class="udiff-line-modified-removed">-                             if (spins == 0) {</span>
<span class="udiff-line-modified-removed">-                                 WNode nh = whead, np = wtail;</span>
<span class="udiff-line-modified-removed">-                                 if ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))</span>
<span class="udiff-line-modified-removed">-                                     break;</span>
<span class="udiff-line-modified-removed">-                             }</span>
<span class="udiff-line-removed">-                             spins = SPINS;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-modified-added">+     private long acquireRead(boolean interruptible, boolean timed, long time) {</span>
<span class="udiff-line-modified-added">+         boolean interrupted = false;</span>
<span class="udiff-line-modified-added">+         ReaderNode node = null;</span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Loop:</span>
<span class="udiff-line-modified-added">+          *   if empty, try to acquire</span>
<span class="udiff-line-modified-added">+          *   if tail is Reader, try to cowait; restart if leader stale or cancels</span>
<span class="udiff-line-modified-added">+          *   else try to create and enqueue node, and wait in 2nd loop below</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         for (;;) {</span>
<span class="udiff-line-modified-added">+             ReaderNode leader; long nextState;</span>
<span class="udiff-line-modified-added">+             Node tailPred = null, t = tail;</span>
<span class="udiff-line-modified-added">+             if ((t == null || (tailPred = t.prev) == null) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 (nextState = tryAcquireRead()) != 0L) // try now if empty</span>
<span class="udiff-line-modified-added">+                 return nextState;</span>
<span class="udiff-line-modified-added">+             else if (t == null)</span>
<span class="udiff-line-modified-added">+                 tryInitializeHead();</span>
<span class="udiff-line-modified-added">+             else if (tailPred == null || !(t instanceof ReaderNode)) {</span>
<span class="udiff-line-modified-added">+                 if (node == null)</span>
<span class="udiff-line-modified-added">+                     node = new ReaderNode();</span>
<span class="udiff-line-modified-added">+                 if (tail == t) {</span>
<span class="udiff-line-modified-added">+                     node.setPrevRelaxed(t);</span>
<span class="udiff-line-modified-added">+                     if (casTail(t, node)) {</span>
<span class="udiff-line-modified-added">+                         t.next = node;</span>
<span class="udiff-line-modified-added">+                         break; // node is leader; wait in loop below</span>
                      }
<span class="udiff-line-added">+                     node.setPrevRelaxed(null);</span>
                  }
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (p == null) { // initialize queue</span>
<span class="udiff-line-modified-removed">-                 WNode hd = new WNode(WMODE, null);</span>
<span class="udiff-line-modified-removed">-                 if (WHEAD.weakCompareAndSet(this, null, hd))</span>
<span class="udiff-line-modified-removed">-                     wtail = hd;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (node == null)</span>
<span class="udiff-line-modified-removed">-                 node = new WNode(RMODE, p);</span>
<span class="udiff-line-modified-removed">-             else if (h == p || p.mode != RMODE) {</span>
<span class="udiff-line-modified-removed">-                 if (node.prev != p)</span>
<span class="udiff-line-modified-removed">-                     node.prev = p;</span>
<span class="udiff-line-modified-removed">-                 else if (WTAIL.weakCompareAndSet(this, p, node)) {</span>
<span class="udiff-line-modified-removed">-                     p.next = node;</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (!WCOWAIT.compareAndSet(p, node.cowait = p.cowait, node))</span>
<span class="udiff-line-modified-removed">-                 node.cowait = null;</span>
<span class="udiff-line-modified-removed">-             else {</span>
<span class="udiff-line-modified-removed">-                 for (;;) {</span>
<span class="udiff-line-modified-removed">-                     WNode pp, c; Thread w;</span>
<span class="udiff-line-modified-removed">-                     if ((h = whead) != null &amp;&amp; (c = h.cowait) != null &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                         WCOWAIT.compareAndSet(h, c, c.cowait) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                         (w = c.thread) != null) // help release</span>
<span class="udiff-line-removed">-                         LockSupport.unpark(w);</span>
<span class="udiff-line-removed">-                     if (Thread.interrupted()) {</span>
<span class="udiff-line-removed">-                         if (interruptible)</span>
<span class="udiff-line-removed">-                             return cancelWaiter(node, p, true);</span>
<span class="udiff-line-removed">-                         wasInterrupted = true;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (h == (pp = p.prev) || h == p || pp == null) {</span>
<span class="udiff-line-removed">-                         long m, s, ns;</span>
<span class="udiff-line-removed">-                         do {</span>
<span class="udiff-line-removed">-                             if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="udiff-line-removed">-                                 casState(s, ns = s + RUNIT) :</span>
<span class="udiff-line-removed">-                                 (m &lt; WBIT &amp;&amp;</span>
<span class="udiff-line-removed">-                                  (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
<span class="udiff-line-removed">-                                 if (wasInterrupted)</span>
<span class="udiff-line-removed">-                                     Thread.currentThread().interrupt();</span>
<span class="udiff-line-removed">-                                 return ns;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         } while (m &lt; WBIT);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (whead == h &amp;&amp; p.prev == pp) {</span>
<span class="udiff-line-removed">-                         long time;</span>
<span class="udiff-line-removed">-                         if (pp == null || h == p || p.status &gt; 0) {</span>
<span class="udiff-line-removed">-                             node = null; // throw away</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (deadline == 0L)</span>
<span class="udiff-line-removed">-                             time = 0L;</span>
<span class="udiff-line-removed">-                         else if ((time = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="udiff-line-removed">-                             if (wasInterrupted)</span>
<span class="udiff-line-removed">-                                 Thread.currentThread().interrupt();</span>
<span class="udiff-line-removed">-                             return cancelWaiter(node, p, false);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         Thread wt = Thread.currentThread();</span>
<span class="udiff-line-removed">-                         node.thread = wt;</span>
<span class="udiff-line-removed">-                         if ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span>
<span class="udiff-line-removed">-                             whead == h &amp;&amp; p.prev == pp) {</span>
<span class="udiff-line-removed">-                             if (time == 0L)</span>
<span class="udiff-line-removed">-                                 LockSupport.park(this);</span>
<span class="udiff-line-removed">-                             else</span>
<span class="udiff-line-removed">-                                 LockSupport.parkNanos(this, time);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         node.thread = null;</span>
<span class="udiff-line-modified-added">+             } else if ((leader = (ReaderNode)t) == tail) { // try to cowait</span>
<span class="udiff-line-modified-added">+                 for (boolean attached = false;;) {</span>
<span class="udiff-line-modified-added">+                     if (leader.status &lt; 0 || leader.prev == null)</span>
<span class="udiff-line-modified-added">+                         break;</span>
<span class="udiff-line-modified-added">+                     else if (node == null)</span>
<span class="udiff-line-modified-added">+                         node = new ReaderNode();</span>
<span class="udiff-line-modified-added">+                     else if (node.waiter == null)</span>
<span class="udiff-line-modified-added">+                         node.waiter = Thread.currentThread();</span>
<span class="udiff-line-modified-added">+                     else if (!attached) {</span>
<span class="udiff-line-modified-added">+                         ReaderNode c = leader.cowaiters;</span>
<span class="udiff-line-modified-added">+                         node.setCowaitersRelaxed(c);</span>
<span class="udiff-line-modified-added">+                         attached = leader.casCowaiters(c, node);</span>
<span class="udiff-line-modified-added">+                         if (!attached)</span>
<span class="udiff-line-modified-added">+                             node.setCowaitersRelaxed(null);</span>
<span class="udiff-line-modified-added">+                     } else {</span>
<span class="udiff-line-modified-added">+                         long nanos = 0L;</span>
<span class="udiff-line-modified-added">+                         if (!timed)</span>
<span class="udiff-line-modified-added">+                             LockSupport.park(this);</span>
<span class="udiff-line-modified-added">+                         else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="udiff-line-modified-added">+                             LockSupport.parkNanos(this, nanos);</span>
<span class="udiff-line-modified-added">+                         interrupted |= Thread.interrupted();</span>
<span class="udiff-line-modified-added">+                         if ((interrupted &amp;&amp; interruptible) ||</span>
<span class="udiff-line-modified-added">+                             (timed &amp;&amp; nanos &lt;= 0L))</span>
<span class="udiff-line-modified-added">+                             return cancelCowaiter(node, leader, interrupted);</span>
                      }
                  }
<span class="udiff-line-added">+                 if (node != null)</span>
<span class="udiff-line-added">+                     node.waiter = null;</span>
<span class="udiff-line-added">+                 long ns = tryAcquireRead();</span>
<span class="udiff-line-added">+                 signalCowaiters(leader);</span>
<span class="udiff-line-added">+                 if (interrupted)</span>
<span class="udiff-line-added">+                     Thread.currentThread().interrupt();</span>
<span class="udiff-line-added">+                 if (ns != 0L)</span>
<span class="udiff-line-added">+                     return ns;</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     node = null; // restart if stale, missed, or leader cancelled</span>
              }
          }
  
<span class="udiff-line-modified-removed">-         for (int spins = -1;;) {</span>
<span class="udiff-line-modified-removed">-             WNode h, np, pp; int ps;</span>
<span class="udiff-line-modified-removed">-             if ((h = whead) == p) {</span>
<span class="udiff-line-modified-removed">-                 if (spins &lt; 0)</span>
<span class="udiff-line-modified-removed">-                     spins = HEAD_SPINS;</span>
<span class="udiff-line-modified-removed">-                 else if (spins &lt; MAX_HEAD_SPINS)</span>
<span class="udiff-line-modified-removed">-                     spins &lt;&lt;= 1;</span>
<span class="udiff-line-modified-removed">-                 for (int k = spins;;) { // spin at head</span>
<span class="udiff-line-modified-removed">-                     long m, s, ns;</span>
<span class="udiff-line-modified-removed">-                     if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="udiff-line-modified-removed">-                         casState(s, ns = s + RUNIT) :</span>
<span class="udiff-line-modified-removed">-                         (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
<span class="udiff-line-modified-removed">-                         WNode c; Thread w;</span>
<span class="udiff-line-removed">-                         whead = node;</span>
<span class="udiff-line-removed">-                         node.prev = null;</span>
<span class="udiff-line-removed">-                         while ((c = node.cowait) != null) {</span>
<span class="udiff-line-removed">-                             if (WCOWAIT.compareAndSet(node, c, c.cowait) &amp;&amp;</span>
<span class="udiff-line-removed">-                                 (w = c.thread) != null)</span>
<span class="udiff-line-removed">-                                 LockSupport.unpark(w);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (wasInterrupted)</span>
<span class="udiff-line-removed">-                             Thread.currentThread().interrupt();</span>
<span class="udiff-line-removed">-                         return ns;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     else if (m &gt;= WBIT &amp;&amp; --k &lt;= 0)</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     else</span>
<span class="udiff-line-removed">-                         Thread.onSpinWait();</span>
<span class="udiff-line-modified-added">+         // node is leader of a cowait group; almost same as acquireWrite</span>
<span class="udiff-line-modified-added">+         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="udiff-line-modified-added">+         boolean first = false;</span>
<span class="udiff-line-modified-added">+         Node pred = null;</span>
<span class="udiff-line-modified-added">+         for (long nextState;;) {</span>
<span class="udiff-line-modified-added">+             if (!first &amp;&amp; (pred = node.prev) != null &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 !(first = (head == pred))) {</span>
<span class="udiff-line-modified-added">+                 if (pred.status &lt; 0) {</span>
<span class="udiff-line-modified-added">+                     cleanQueue();           // predecessor cancelled</span>
<span class="udiff-line-modified-added">+                     continue;</span>
<span class="udiff-line-modified-added">+                 } else if (pred.prev == null) {</span>
<span class="udiff-line-modified-added">+                     Thread.onSpinWait();    // ensure serialization</span>
<span class="udiff-line-modified-added">+                     continue;</span>
                  }
              }
<span class="udiff-line-modified-removed">-             else if (h != null) {</span>
<span class="udiff-line-modified-removed">-                 WNode c; Thread w;</span>
<span class="udiff-line-modified-removed">-                 while ((c = h.cowait) != null) {</span>
<span class="udiff-line-modified-removed">-                     if (WCOWAIT.compareAndSet(h, c, c.cowait) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                         (w = c.thread) != null)</span>
<span class="udiff-line-modified-removed">-                         LockSupport.unpark(w);</span>
<span class="udiff-line-modified-added">+             if ((first || pred == null) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 (nextState = tryAcquireRead()) != 0L) {</span>
<span class="udiff-line-modified-added">+                 if (first) {</span>
<span class="udiff-line-modified-added">+                     node.prev = null;</span>
<span class="udiff-line-modified-added">+                     head = node;</span>
<span class="udiff-line-modified-added">+                     pred.next = null;</span>
<span class="udiff-line-added">+                     node.waiter = null;</span>
                  }
<span class="udiff-line-added">+                 signalCowaiters(node);</span>
<span class="udiff-line-added">+                 if (interrupted)</span>
<span class="udiff-line-added">+                     Thread.currentThread().interrupt();</span>
<span class="udiff-line-added">+                 return nextState;</span>
<span class="udiff-line-added">+             } else if (first &amp;&amp; spins != 0) {</span>
<span class="udiff-line-added">+                 --spins;</span>
<span class="udiff-line-added">+                 Thread.onSpinWait();</span>
<span class="udiff-line-added">+             } else if (node.status == 0) {</span>
<span class="udiff-line-added">+                 if (node.waiter == null)</span>
<span class="udiff-line-added">+                     node.waiter = Thread.currentThread();</span>
<span class="udiff-line-added">+                 node.status = WAITING;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 long nanos;</span>
<span class="udiff-line-added">+                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="udiff-line-added">+                 if (!timed)</span>
<span class="udiff-line-added">+                     LockSupport.park(this);</span>
<span class="udiff-line-added">+                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="udiff-line-added">+                     LockSupport.parkNanos(this, nanos);</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 node.clearStatus();</span>
<span class="udiff-line-added">+                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="udiff-line-added">+                     break;</span>
              }
<span class="udiff-line-modified-removed">-             if (whead == h) {</span>
<span class="udiff-line-modified-removed">-                 if ((np = node.prev) != p) {</span>
<span class="udiff-line-modified-removed">-                     if (np != null)</span>
<span class="udiff-line-modified-removed">-                         (p = np).next = node;   // stale</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-                 else if ((ps = p.status) == 0)</span>
<span class="udiff-line-modified-removed">-                     WSTATUS.compareAndSet(p, 0, WAITING);</span>
<span class="udiff-line-modified-removed">-                 else if (ps == CANCELLED) {</span>
<span class="udiff-line-modified-removed">-                     if ((pp = p.prev) != null) {</span>
<span class="udiff-line-modified-removed">-                         node.prev = pp;</span>
<span class="udiff-line-modified-removed">-                         pp.next = node;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         return cancelAcquire(node, interrupted);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Cancellation support</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Possibly repeatedly traverses from tail, unsplicing cancelled</span>
<span class="udiff-line-modified-added">+      * nodes until none are found. Unparks nodes that may have been</span>
<span class="udiff-line-modified-added">+      * relinked to be next eligible acquirer.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-added">+     private void cleanQueue() {</span>
<span class="udiff-line-added">+         for (;;) {                               // restart point</span>
<span class="udiff-line-added">+             for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples</span>
<span class="udiff-line-added">+                 if (q == null || (p = q.prev) == null)</span>
<span class="udiff-line-added">+                     return;                      // end of list</span>
<span class="udiff-line-added">+                 if (s == null ? tail != q : (s.prev != q || s.status &lt; 0))</span>
<span class="udiff-line-added">+                     break;                       // inconsistent</span>
<span class="udiff-line-added">+                 if (q.status &lt; 0) {              // cancelled</span>
<span class="udiff-line-added">+                     if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;</span>
<span class="udiff-line-added">+                         q.prev == p) {</span>
<span class="udiff-line-added">+                         p.casNext(q, s);         // OK if fails</span>
<span class="udiff-line-added">+                         if (p.prev == null)</span>
<span class="udiff-line-added">+                             signalNext(p);</span>
                      }
<span class="udiff-line-added">+                     break;</span>
                  }
<span class="udiff-line-modified-removed">-                 else {</span>
<span class="udiff-line-modified-removed">-                     long time;</span>
<span class="udiff-line-modified-removed">-                     if (deadline == 0L)</span>
<span class="udiff-line-modified-removed">-                         time = 0L;</span>
<span class="udiff-line-modified-removed">-                     else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="udiff-line-removed">-                         return cancelWaiter(node, node, false);</span>
<span class="udiff-line-removed">-                     Thread wt = Thread.currentThread();</span>
<span class="udiff-line-removed">-                     node.thread = wt;</span>
<span class="udiff-line-removed">-                     if (p.status &lt; 0 &amp;&amp;</span>
<span class="udiff-line-removed">-                         (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span>
<span class="udiff-line-removed">-                         whead == h &amp;&amp; node.prev == p) {</span>
<span class="udiff-line-removed">-                             if (time == 0L)</span>
<span class="udiff-line-removed">-                                 LockSupport.park(this);</span>
<span class="udiff-line-removed">-                             else</span>
<span class="udiff-line-removed">-                                 LockSupport.parkNanos(this, time);</span>
<span class="udiff-line-modified-added">+                 if ((n = p.next) != q) {         // help finish</span>
<span class="udiff-line-modified-added">+                     if (n != null &amp;&amp; q.prev == p &amp;&amp; q.status &gt;= 0) {</span>
<span class="udiff-line-modified-added">+                         p.casNext(n, q);</span>
<span class="udiff-line-modified-added">+                         if (p.prev == null)</span>
<span class="udiff-line-modified-added">+                             signalNext(p);</span>
                      }
<span class="udiff-line-modified-removed">-                     node.thread = null;</span>
<span class="udiff-line-modified-removed">-                     if (Thread.interrupted()) {</span>
<span class="udiff-line-modified-removed">-                         if (interruptible)</span>
<span class="udiff-line-modified-removed">-                             return cancelWaiter(node, node, true);</span>
<span class="udiff-line-modified-removed">-                         wasInterrupted = true;</span>
<span class="udiff-line-modified-added">+                     break;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+                 s = q;</span>
<span class="udiff-line-modified-added">+                 q = q.prev;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * If leader exists, possibly repeatedly traverses cowaiters,</span>
<span class="udiff-line-added">+      * unsplicing the given cancelled node until not found.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void unlinkCowaiter(ReaderNode node, ReaderNode leader) {</span>
<span class="udiff-line-added">+         if (leader != null) {</span>
<span class="udiff-line-added">+             while (leader.prev != null &amp;&amp; leader.status &gt;= 0) {</span>
<span class="udiff-line-added">+                 for (ReaderNode p = leader, q; ; p = q) {</span>
<span class="udiff-line-added">+                     if ((q = p.cowaiters) == null)</span>
<span class="udiff-line-added">+                         return;</span>
<span class="udiff-line-added">+                     if (q == node) {</span>
<span class="udiff-line-added">+                         p.casCowaiters(q, q.cowaiters);</span>
<span class="udiff-line-added">+                         break;  // recheck even if succeeded</span>
                      }
                  }
              }
          }
      }
  
      /**
       * If node non-null, forces cancel status and unsplices it from
<span class="udiff-line-modified-removed">-      * queue if possible and wakes up any cowaiters (of the node, or</span>
<span class="udiff-line-modified-removed">-      * group, as applicable), and in any case helps release current</span>
<span class="udiff-line-removed">-      * first waiter if lock is free. (Calling with null arguments</span>
<span class="udiff-line-removed">-      * serves as a conditional form of release, which is not currently</span>
<span class="udiff-line-removed">-      * needed but may be needed under possible future cancellation</span>
<span class="udiff-line-removed">-      * policies). This is a variant of cancellation methods in</span>
<span class="udiff-line-removed">-      * AbstractQueuedSynchronizer (see its detailed explanation in AQS</span>
<span class="udiff-line-removed">-      * internal documentation).</span>
<span class="udiff-line-modified-added">+      * queue, wakes up any cowaiters, and possibly wakes up successor</span>
<span class="udiff-line-modified-added">+      * to recheck status.</span>
       *
<span class="udiff-line-modified-removed">-      * @param node if non-null, the waiter</span>
<span class="udiff-line-removed">-      * @param group either node or the group node is cowaiting with</span>
<span class="udiff-line-modified-added">+      * @param node the waiter (may be null if not yet enqueued)</span>
       * @param interrupted if already interrupted
       * @return INTERRUPTED if interrupted or Thread.interrupted, else zero
       */
<span class="udiff-line-modified-removed">-     private long cancelWaiter(WNode node, WNode group, boolean interrupted) {</span>
<span class="udiff-line-modified-removed">-         if (node != null &amp;&amp; group != null) {</span>
<span class="udiff-line-modified-removed">-             Thread w;</span>
<span class="udiff-line-modified-added">+     private long cancelAcquire(Node node, boolean interrupted) {</span>
<span class="udiff-line-modified-added">+         if (node != null) {</span>
<span class="udiff-line-modified-added">+             node.waiter = null;</span>
              node.status = CANCELLED;
<span class="udiff-line-modified-removed">-             // unsplice cancelled nodes from group</span>
<span class="udiff-line-modified-removed">-             for (WNode p = group, q; (q = p.cowait) != null;) {</span>
<span class="udiff-line-modified-removed">-                 if (q.status == CANCELLED) {</span>
<span class="udiff-line-removed">-                     WCOWAIT.compareAndSet(p, q, q.cowait);</span>
<span class="udiff-line-removed">-                     p = group; // restart</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 else</span>
<span class="udiff-line-removed">-                     p = q;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (group == node) {</span>
<span class="udiff-line-removed">-                 for (WNode r = group.cowait; r != null; r = r.cowait) {</span>
<span class="udiff-line-removed">-                     if ((w = r.thread) != null)</span>
<span class="udiff-line-removed">-                         LockSupport.unpark(w); // wake up uncancelled co-waiters</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 for (WNode pred = node.prev; pred != null; ) { // unsplice</span>
<span class="udiff-line-removed">-                     WNode succ, pp;        // find valid successor</span>
<span class="udiff-line-removed">-                     while ((succ = node.next) == null ||</span>
<span class="udiff-line-removed">-                            succ.status == CANCELLED) {</span>
<span class="udiff-line-removed">-                         WNode q = null;    // find successor the slow way</span>
<span class="udiff-line-removed">-                         for (WNode t = wtail; t != null &amp;&amp; t != node; t = t.prev)</span>
<span class="udiff-line-removed">-                             if (t.status != CANCELLED)</span>
<span class="udiff-line-removed">-                                 q = t;     // don&#39;t link if succ cancelled</span>
<span class="udiff-line-removed">-                         if (succ == q ||   // ensure accurate successor</span>
<span class="udiff-line-removed">-                             WNEXT.compareAndSet(node, succ, succ = q)) {</span>
<span class="udiff-line-removed">-                             if (succ == null &amp;&amp; node == wtail)</span>
<span class="udiff-line-removed">-                                 WTAIL.compareAndSet(this, node, pred);</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (pred.next == node) // unsplice pred link</span>
<span class="udiff-line-removed">-                         WNEXT.compareAndSet(pred, node, succ);</span>
<span class="udiff-line-removed">-                     if (succ != null &amp;&amp; (w = succ.thread) != null) {</span>
<span class="udiff-line-removed">-                         // wake up succ to observe new pred</span>
<span class="udiff-line-removed">-                         succ.thread = null;</span>
<span class="udiff-line-removed">-                         LockSupport.unpark(w);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (pred.status != CANCELLED || (pp = pred.prev) == null)</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     node.prev = pp;        // repeat if new pred wrong/cancelled</span>
<span class="udiff-line-removed">-                     WNEXT.compareAndSet(pp, pred, succ);</span>
<span class="udiff-line-removed">-                     pred = pp;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             cleanQueue();</span>
<span class="udiff-line-modified-added">+             if (node instanceof ReaderNode)</span>
<span class="udiff-line-modified-added">+                 signalCowaiters((ReaderNode)node);</span>
          }
<span class="udiff-line-modified-removed">-         WNode h; // Possibly release first waiter</span>
<span class="udiff-line-modified-removed">-         while ((h = whead) != null) {</span>
<span class="udiff-line-modified-removed">-             long s; WNode q; // similar to release() but check eligibility</span>
<span class="udiff-line-modified-removed">-             if ((q = h.next) == null || q.status == CANCELLED) {</span>
<span class="udiff-line-modified-removed">-                 for (WNode t = wtail; t != null &amp;&amp; t != h; t = t.prev)</span>
<span class="udiff-line-modified-removed">-                     if (t.status &lt;= 0)</span>
<span class="udiff-line-modified-removed">-                         q = t;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (h == whead) {</span>
<span class="udiff-line-modified-removed">-                 if (q != null &amp;&amp; h.status == 0 &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                     ((s = state) &amp; ABITS) != WBIT &amp;&amp; // waiter is eligible</span>
<span class="udiff-line-modified-removed">-                     (s == 0L || q.mode == RMODE))</span>
<span class="udiff-line-modified-removed">-                     release(h);</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-added">+         return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * If node non-null, forces cancel status and unsplices from</span>
<span class="udiff-line-modified-added">+      * leader&#39;s cowaiters list unless/until it is also cancelled.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param node if non-null, the waiter</span>
<span class="udiff-line-modified-added">+      * @param leader if non-null, the node heading cowaiters list</span>
<span class="udiff-line-modified-added">+      * @param interrupted if already interrupted</span>
<span class="udiff-line-modified-added">+      * @return INTERRUPTED if interrupted or Thread.interrupted, else zero</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private long cancelCowaiter(ReaderNode node, ReaderNode leader,</span>
<span class="udiff-line-modified-added">+                                 boolean interrupted) {</span>
<span class="udiff-line-modified-added">+         if (node != null) {</span>
<span class="udiff-line-added">+             node.waiter = null;</span>
<span class="udiff-line-added">+             node.status = CANCELLED;</span>
<span class="udiff-line-added">+             unlinkCowaiter(node, leader);</span>
          }
          return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;
      }
  
<span class="udiff-line-modified-removed">-     // VarHandle mechanics</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle STATE;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle WHEAD;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle WTAIL;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle WNEXT;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle WSTATUS;</span>
<span class="udiff-line-modified-removed">-     private static final VarHandle WCOWAIT;</span>
<span class="udiff-line-modified-added">+     // Unsafe</span>
<span class="udiff-line-modified-added">+     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="udiff-line-modified-added">+     private static final long STATE</span>
<span class="udiff-line-modified-added">+         = U.objectFieldOffset(StampedLock.class, &quot;state&quot;);</span>
<span class="udiff-line-modified-added">+     private static final long HEAD</span>
<span class="udiff-line-modified-added">+         = U.objectFieldOffset(StampedLock.class, &quot;head&quot;);</span>
<span class="udiff-line-modified-added">+     private static final long TAIL</span>
<span class="udiff-line-added">+         = U.objectFieldOffset(StampedLock.class, &quot;tail&quot;);</span>
<span class="udiff-line-added">+ </span>
      static {
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-removed">-             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="udiff-line-removed">-             STATE = l.findVarHandle(StampedLock.class, &quot;state&quot;, long.class);</span>
<span class="udiff-line-removed">-             WHEAD = l.findVarHandle(StampedLock.class, &quot;whead&quot;, WNode.class);</span>
<span class="udiff-line-removed">-             WTAIL = l.findVarHandle(StampedLock.class, &quot;wtail&quot;, WNode.class);</span>
<span class="udiff-line-removed">-             WSTATUS = l.findVarHandle(WNode.class, &quot;status&quot;, int.class);</span>
<span class="udiff-line-removed">-             WNEXT = l.findVarHandle(WNode.class, &quot;next&quot;, WNode.class);</span>
<span class="udiff-line-removed">-             WCOWAIT = l.findVarHandle(WNode.class, &quot;cowait&quot;, WNode.class);</span>
<span class="udiff-line-removed">-         } catch (ReflectiveOperationException e) {</span>
<span class="udiff-line-removed">-             throw new ExceptionInInitializerError(e);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         Class&lt;?&gt; ensureLoaded = LockSupport.class;</span>
      }
  }
</pre>
<center><a href="ReentrantReadWriteLock.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../package-info.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
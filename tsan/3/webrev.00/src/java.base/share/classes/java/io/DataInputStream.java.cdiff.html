<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/DataInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DataInput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DataOutput.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/DataInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,12 ***</span>
   *
   * @author  Arthur van Hoff
   * @see     java.io.DataOutputStream
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class DataInputStream extends FilterInputStream implements DataInput {</span>
  
      /**
       * Creates a DataInputStream that uses the specified
       * underlying InputStream.
       *
<span class="line-new-header">--- 37,11 ---</span>
   *
   * @author  Arthur van Hoff
   * @see     java.io.DataOutputStream
   * @since   1.0
   */
<span class="line-modified">! public class DataInputStream extends FilterInputStream implements DataInput {</span>
  
      /**
       * Creates a DataInputStream that uses the specified
       * underlying InputStream.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,92 ***</span>
      private byte bytearr[] = new byte[80];
      private char chararr[] = new char[80];
  
      /**
       * Reads some number of bytes from the contained input stream and
<span class="line-modified">!      * stores them into the buffer array &lt;code&gt;b&lt;/code&gt;. The number of</span>
       * bytes actually read is returned as an integer. This method blocks
       * until input data is available, end of file is detected, or an
       * exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt;If &lt;code&gt;b&lt;/code&gt; is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is</span>
<span class="line-modified">!      * thrown. If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are</span>
<span class="line-modified">!      * read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt</span>
       * to read at least one byte. If no byte is available because the
<span class="line-modified">!      * stream is at end of file, the value &lt;code&gt;-1&lt;/code&gt; is returned;</span>
<span class="line-modified">!      * otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt;The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span>
<span class="line-modified">!      * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified">!      * is, at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;code&gt;k&lt;/code&gt;</span>
       * be the number of bytes actually read; these bytes will be stored in
<span class="line-modified">!      * elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[k-1]&lt;/code&gt;, leaving</span>
<span class="line-modified">!      * elements &lt;code&gt;b[k]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt;</span>
       * unaffected.
       *
<span class="line-modified">!      * &lt;p&gt;The &lt;code&gt;read(b)&lt;/code&gt; method has the same effect as:</span>
       * &lt;blockquote&gt;&lt;pre&gt;
       * read(b, 0, b.length)
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end</span>
       *             of the stream has been reached.
<span class="line-modified">!      * @exception  IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">!      * other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">!      * input stream does not support reading after close, or another I/O</span>
<span class="line-modified">!      * error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.InputStream#read(byte[], int, int)
       */
      public final int read(byte b[]) throws IOException {
          return in.read(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the contained</span>
       * input stream into an array of bytes.  An attempt is made to read
<span class="line-modified">!      * as many as &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read,</span>
       * possibly zero. The number of bytes actually read is returned as an
       * integer.
       *
       * &lt;p&gt; This method blocks until input data is available, end of file is
       * detected, or an exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">!      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
       * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">!      * file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one</span>
<span class="line-modified">!      * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the</span>
<span class="line-modified">!      * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified">!      * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
       * bytes actually read; these bytes will be stored in elements
<span class="line-modified">!      * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">!      * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.</span>
       *
<span class="line-modified">!      * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</span>
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end</span>
       *             of the stream has been reached.
<span class="line-modified">!      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">!      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">!      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">!      * @exception  IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">!      * other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">!      * input stream does not support reading after close, or another I/O</span>
<span class="line-modified">!      * error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.InputStream#read(byte[], int, int)
       */
      public final int read(byte b[], int off, int len) throws IOException {
          return in.read(b, off, len);
<span class="line-new-header">--- 57,92 ---</span>
      private byte bytearr[] = new byte[80];
      private char chararr[] = new char[80];
  
      /**
       * Reads some number of bytes from the contained input stream and
<span class="line-modified">!      * stores them into the buffer array {@code b}. The number of</span>
       * bytes actually read is returned as an integer. This method blocks
       * until input data is available, end of file is detected, or an
       * exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt;If {@code b} is null, a {@code NullPointerException} is</span>
<span class="line-modified">!      * thrown. If the length of {@code b} is zero, then no bytes are</span>
<span class="line-modified">!      * read and {@code 0} is returned; otherwise, there is an attempt</span>
       * to read at least one byte. If no byte is available because the
<span class="line-modified">!      * stream is at end of file, the value {@code -1} is returned;</span>
<span class="line-modified">!      * otherwise, at least one byte is read and stored into {@code b}.</span>
       *
<span class="line-modified">!      * &lt;p&gt;The first byte read is stored into element {@code b[0]}, the</span>
<span class="line-modified">!      * next one into {@code b[1]}, and so on. The number of bytes read</span>
<span class="line-modified">!      * is, at most, equal to the length of {@code b}. Let {@code k}</span>
       * be the number of bytes actually read; these bytes will be stored in
<span class="line-modified">!      * elements {@code b[0]} through {@code b[k-1]}, leaving</span>
<span class="line-modified">!      * elements {@code b[k]} through {@code b[b.length-1]}</span>
       * unaffected.
       *
<span class="line-modified">!      * &lt;p&gt;The {@code read(b)} method has the same effect as:</span>
       * &lt;blockquote&gt;&lt;pre&gt;
       * read(b, 0, b.length)
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end</span>
       *             of the stream has been reached.
<span class="line-modified">!      * @throws     IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">!      *             other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">!      *             input stream does not support reading after close, or another I/O</span>
<span class="line-modified">!      *             error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.InputStream#read(byte[], int, int)
       */
      public final int read(byte b[]) throws IOException {
          return in.read(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to {@code len} bytes of data from the contained</span>
       * input stream into an array of bytes.  An attempt is made to read
<span class="line-modified">!      * as many as {@code len} bytes, but a smaller number may be read,</span>
       * possibly zero. The number of bytes actually read is returned as an
       * integer.
       *
       * &lt;p&gt; This method blocks until input data is available, end of file is
       * detected, or an exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt; If {@code len} is zero, then no bytes are read and</span>
<span class="line-modified">!      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
       * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">!      * file, the value {@code -1} is returned; otherwise, at least one</span>
<span class="line-modified">!      * byte is read and stored into {@code b}.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the</span>
<span class="line-modified">!      * next one into {@code b[off+1]}, and so on. The number of bytes read</span>
<span class="line-modified">!      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
       * bytes actually read; these bytes will be stored in elements
<span class="line-modified">!      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">!      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">!      * {@code b[off+len-1]} unaffected.</span>
       *
<span class="line-modified">!      * &lt;p&gt; In every case, elements {@code b[0]} through</span>
<span class="line-modified">!      * {@code b[off]} and elements {@code b[off+len]} through</span>
<span class="line-modified">!      * {@code b[b.length-1]} are unaffected.</span>
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off the start offset in the destination array {@code b}</span>
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end</span>
       *             of the stream has been reached.
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      *             {@code b.length - off}</span>
<span class="line-modified">!      * @throws     IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">!      *             other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">!      *             input stream does not support reading after close, or another I/O</span>
<span class="line-modified">!      *             error occurs.</span>
       * @see        java.io.FilterInputStream#in
       * @see        java.io.InputStream#read(byte[], int, int)
       */
      public final int read(byte b[], int off, int len) throws IOException {
          return in.read(b, off, len);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,17 ***</span>
       * input stream.
       *
       * @param      b     the buffer into which the data is read.
       * @param      off   the start offset in the data array {@code b}.
       * @param      len   the number of bytes to read.
<span class="line-modified">!      * @exception  NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException if {@code off} is negative,</span>
       *             {@code len} is negative, or {@code len} is greater than
       *             {@code b.length - off}.
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *             reading all the bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final void readFully(byte b[], int off, int len) throws IOException {
<span class="line-new-header">--- 178,17 ---</span>
       * input stream.
       *
       * @param      b     the buffer into which the data is read.
       * @param      off   the start offset in the data array {@code b}.
       * @param      len   the number of bytes to read.
<span class="line-modified">!      * @throws     NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException if {@code off} is negative,</span>
       *             {@code len} is negative, or {@code len} is greater than
       *             {@code b.length - off}.
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *             reading all the bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final void readFully(byte b[], int off, int len) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,19 ***</span>
              n += count;
          }
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;skipBytes&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes for this operation are read from the contained
       * input stream.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @exception  IOException  if the contained input stream does not support</span>
       *             seek, or the stream has been closed and
       *             the contained input stream does not support
       *             reading after close, or another I/O error occurs.
       */
      public final int skipBytes(int n) throws IOException {
<span class="line-new-header">--- 202,19 ---</span>
              n += count;
          }
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code skipBytes}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes for this operation are read from the contained
       * input stream.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @throws     IOException  if the contained input stream does not support</span>
       *             seek, or the stream has been closed and
       *             the contained input stream does not support
       *             reading after close, or another I/O error occurs.
       */
      public final int skipBytes(int n) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,19 ***</span>
  
          return total;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readBoolean&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes for this operation are read from the contained
       * input stream.
       *
<span class="line-modified">!      * @return     the &lt;code&gt;boolean&lt;/code&gt; value read.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final boolean readBoolean() throws IOException {
<span class="line-new-header">--- 227,19 ---</span>
  
          return total;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readBoolean}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes for this operation are read from the contained
       * input stream.
       *
<span class="line-modified">!      * @return     the {@code boolean} value read.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final boolean readBoolean() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,21 ***</span>
              throw new EOFException();
          return (ch != 0);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readByte&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next byte of this input stream as a signed 8-bit
<span class="line-modified">!      *             &lt;code&gt;byte&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final byte readByte() throws IOException {
<span class="line-new-header">--- 248,21 ---</span>
              throw new EOFException();
          return (ch != 0);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readByte}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next byte of this input stream as a signed 8-bit
<span class="line-modified">!      *             {@code byte}.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final byte readByte() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,21 ***</span>
              throw new EOFException();
          return (byte)(ch);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readUnsignedByte&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next byte of this input stream, interpreted as an
       *             unsigned 8-bit number.
<span class="line-modified">!      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see         java.io.FilterInputStream#in
       */
      public final int readUnsignedByte() throws IOException {
<span class="line-new-header">--- 271,21 ---</span>
              throw new EOFException();
          return (byte)(ch);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readUnsignedByte}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next byte of this input stream, interpreted as an
       *             unsigned 8-bit number.
<span class="line-modified">!      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see         java.io.FilterInputStream#in
       */
      public final int readUnsignedByte() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,22 ***</span>
              throw new EOFException();
          return ch;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readShort&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next two bytes of this input stream, interpreted as a
       *             signed 16-bit number.
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading two bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final short readShort() throws IOException {
<span class="line-new-header">--- 294,22 ---</span>
              throw new EOFException();
          return ch;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readShort}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next two bytes of this input stream, interpreted as a
       *             signed 16-bit number.
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading two bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final short readShort() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,22 ***</span>
              throw new EOFException();
          return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readUnsignedShort&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next two bytes of this input stream, interpreted as an
       *             unsigned 16-bit integer.
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *             reading two bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final int readUnsignedShort() throws IOException {
<span class="line-new-header">--- 319,22 ---</span>
              throw new EOFException();
          return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readUnsignedShort}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next two bytes of this input stream, interpreted as an
       *             unsigned 16-bit integer.
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *             reading two bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final int readUnsignedShort() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,22 ***</span>
              throw new EOFException();
          return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readChar&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next two bytes of this input stream, interpreted as a
<span class="line-modified">!      *             &lt;code&gt;char&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading two bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final char readChar() throws IOException {
<span class="line-new-header">--- 344,22 ---</span>
              throw new EOFException();
          return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readChar}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next two bytes of this input stream, interpreted as a
<span class="line-modified">!      *             {@code char}.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading two bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final char readChar() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,22 ***</span>
              throw new EOFException();
          return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readInt&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next four bytes of this input stream, interpreted as an
<span class="line-modified">!      *             &lt;code&gt;int&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading four bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final int readInt() throws IOException {
<span class="line-new-header">--- 369,22 ---</span>
              throw new EOFException();
          return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readInt}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next four bytes of this input stream, interpreted as an
<span class="line-modified">!      *             {@code int}.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading four bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final int readInt() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,22 ***</span>
      }
  
      private byte readBuffer[] = new byte[8];
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readLong&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">!      *             &lt;code&gt;long&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading eight bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final long readLong() throws IOException {
<span class="line-new-header">--- 398,22 ---</span>
      }
  
      private byte readBuffer[] = new byte[8];
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readLong}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">!      *             {@code long}.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading eight bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public final long readLong() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,44 ***</span>
                  ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
                  ((readBuffer[7] &amp; 255) &lt;&lt;  0));
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readFloat&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next four bytes of this input stream, interpreted as a
<span class="line-modified">!      *             &lt;code&gt;float&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading four bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.DataInputStream#readInt()
       * @see        java.lang.Float#intBitsToFloat(int)
       */
      public final float readFloat() throws IOException {
          return Float.intBitsToFloat(readInt());
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readDouble&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">!      *             &lt;code&gt;double&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading eight bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.DataInputStream#readLong()
       * @see        java.lang.Double#longBitsToDouble(long)
       */
<span class="line-new-header">--- 427,44 ---</span>
                  ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
                  ((readBuffer[7] &amp; 255) &lt;&lt;  0));
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readFloat}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next four bytes of this input stream, interpreted as a
<span class="line-modified">!      *             {@code float}.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading four bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.DataInputStream#readInt()
       * @see        java.lang.Float#intBitsToFloat(int)
       */
      public final float readFloat() throws IOException {
          return Float.intBitsToFloat(readInt());
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readDouble}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">!      *             {@code double}.</span>
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading eight bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
       * @see        java.io.DataInputStream#readLong()
       * @see        java.lang.Double#longBitsToDouble(long)
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,33 ***</span>
      }
  
      private char lineBuffer[];
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readLine&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @deprecated This method does not properly convert bytes to characters.
       * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
<span class="line-modified">!      * &lt;code&gt;BufferedReader.readLine()&lt;/code&gt; method.  Programs that use the</span>
<span class="line-modified">!      * &lt;code&gt;DataInputStream&lt;/code&gt; class to read lines can be converted to use</span>
<span class="line-modified">!      * the &lt;code&gt;BufferedReader&lt;/code&gt; class by replacing code of the form:</span>
       * &lt;blockquote&gt;&lt;pre&gt;
       *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
       * &lt;/pre&gt;&lt;/blockquote&gt;
       * with:
       * &lt;blockquote&gt;&lt;pre&gt;
       *     BufferedReader d
       *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @return     the next line of text from this input stream.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.BufferedReader#readLine()
       * @see        java.io.FilterInputStream#in
       */
      @Deprecated
      public final String readLine() throws IOException {
<span class="line-new-header">--- 473,33 ---</span>
      }
  
      private char lineBuffer[];
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readLine}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @deprecated This method does not properly convert bytes to characters.
       * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
<span class="line-modified">!      * {@code BufferedReader.readLine()} method.  Programs that use the</span>
<span class="line-modified">!      * {@code DataInputStream} class to read lines can be converted to use</span>
<span class="line-modified">!      * the {@code BufferedReader} class by replacing code of the form:</span>
       * &lt;blockquote&gt;&lt;pre&gt;
       *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
       * &lt;/pre&gt;&lt;/blockquote&gt;
       * with:
       * &lt;blockquote&gt;&lt;pre&gt;
       *     BufferedReader d
       *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @return     the next line of text from this input stream.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.BufferedReader#readLine()
       * @see        java.io.FilterInputStream#in
       */
      @Deprecated
      public final String readLine() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,49 ***</span>
          }
          return String.copyValueOf(buf, 0, offset);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;readUTF&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     a Unicode string.
<span class="line-modified">!      * @exception  EOFException  if this input stream reaches the end before</span>
       *               reading all the bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
<span class="line-modified">!      * @exception  UTFDataFormatException if the bytes do not represent a valid</span>
       *             modified UTF-8 encoding of a string.
       * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
       */
      public final String readUTF() throws IOException {
          return readUTF(this);
      }
  
      /**
       * Reads from the
<span class="line-modified">!      * stream &lt;code&gt;in&lt;/code&gt; a representation</span>
       * of a Unicode  character string encoded in
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
<span class="line-modified">!      * this string of characters is then returned as a &lt;code&gt;String&lt;/code&gt;.</span>
       * The details of the modified UTF-8 representation
<span class="line-modified">!      * are  exactly the same as for the &lt;code&gt;readUTF&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
       *
       * @param      in   a data input stream.
       * @return     a Unicode string.
<span class="line-modified">!      * @exception  EOFException            if the input stream reaches the end</span>
       *               before all the bytes.
<span class="line-modified">!      * @exception  IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
<span class="line-modified">!      * @exception  UTFDataFormatException  if the bytes do not represent a</span>
       *               valid modified UTF-8 encoding of a Unicode string.
       * @see        java.io.DataInputStream#readUnsignedShort()
       */
      public static final String readUTF(DataInput in) throws IOException {
          int utflen = in.readUnsignedShort();
<span class="line-new-header">--- 545,49 ---</span>
          }
          return String.copyValueOf(buf, 0, offset);
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code readUTF}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       * &lt;p&gt;
       * Bytes
       * for this operation are read from the contained
       * input stream.
       *
       * @return     a Unicode string.
<span class="line-modified">!      * @throws     EOFException  if this input stream reaches the end before</span>
       *               reading all the bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
<span class="line-modified">!      * @throws     UTFDataFormatException if the bytes do not represent a valid</span>
       *             modified UTF-8 encoding of a string.
       * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
       */
      public final String readUTF() throws IOException {
          return readUTF(this);
      }
  
      /**
       * Reads from the
<span class="line-modified">!      * stream {@code in} a representation</span>
       * of a Unicode  character string encoded in
       * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
<span class="line-modified">!      * this string of characters is then returned as a {@code String}.</span>
       * The details of the modified UTF-8 representation
<span class="line-modified">!      * are  exactly the same as for the {@code readUTF}</span>
<span class="line-modified">!      * method of {@code DataInput}.</span>
       *
       * @param      in   a data input stream.
       * @return     a Unicode string.
<span class="line-modified">!      * @throws     EOFException            if the input stream reaches the end</span>
       *               before all the bytes.
<span class="line-modified">!      * @throws     IOException   the stream has been closed and the contained</span>
       *             input stream does not support reading after close, or
       *             another I/O error occurs.
<span class="line-modified">!      * @throws     UTFDataFormatException  if the bytes do not represent a</span>
       *               valid modified UTF-8 encoding of a Unicode string.
       * @see        java.io.DataInputStream#readUnsignedShort()
       */
      public static final String readUTF(DataInput in) throws IOException {
          int utflen = in.readUnsignedShort();
</pre>
<center><a href="DataInput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DataOutput.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
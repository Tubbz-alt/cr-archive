diff a/src/java.base/share/classes/java/lang/StringLatin1.java b/src/java.base/share/classes/java/lang/StringLatin1.java
--- a/src/java.base/share/classes/java/lang/StringLatin1.java
+++ b/src/java.base/share/classes/java/lang/StringLatin1.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,10 +33,11 @@
 import java.util.function.IntConsumer;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import jdk.internal.HotSpotIntrinsicCandidate;
+import jdk.internal.util.ArraysSupport;
 
 import static java.lang.String.LATIN1;
 import static java.lang.String.UTF16;
 import static java.lang.String.checkOffset;
 
@@ -174,11 +175,11 @@
         int lim = Math.min(len1, len2);
         for (int k = 0; k < lim; k++) {
             char c1 = getChar(value, k);
             char c2 = StringUTF16.getChar(other, k);
             if (c1 != c2) {
-                c1 = Character.toUpperCase(c1);
+                c1 = (char) CharacterDataLatin1.instance.toUpperCase(c1);
                 c2 = Character.toUpperCase(c2);
                 if (c1 != c2) {
                     c1 = Character.toLowerCase(c1);
                     c2 = Character.toLowerCase(c2);
                     if (c1 != c2) {
@@ -302,11 +303,11 @@
                     break;
                 }
             }
             if (i < len) {
                 if (canEncode(newChar)) {
-                    byte buf[] = new byte[len];
+                    byte[] buf = StringConcatHelper.newArray(len);
                     for (int j = 0; j < i; j++) {    // TBD arraycopy?
                         buf[j] = value[j];
                     }
                     while (i < len) {
                         byte c = value[i];
@@ -328,22 +329,72 @@
             }
         }
         return null; // for string to return this;
     }
 
+    public static String replace(byte[] value, int valLen, byte[] targ,
+                                 int targLen, byte[] repl, int replLen)
+    {
+        assert targLen > 0;
+        int i, j, p = 0;
+        if (valLen == 0 || (i = indexOf(value, valLen, targ, targLen, 0)) < 0) {
+            return null; // for string to return this;
+        }
+
+        // find and store indices of substrings to replace
+        int[] pos = new int[16];
+        pos[0] = i;
+        i += targLen;
+        while ((j = indexOf(value, valLen, targ, targLen, i)) > 0) {
+            if (++p == pos.length) {
+                pos = Arrays.copyOf(pos, ArraysSupport.newLength(p, 1, p >> 1));
+            }
+            pos[p] = j;
+            i = j + targLen;
+        }
+
+        int resultLen;
+        try {
+            resultLen = Math.addExact(valLen,
+                    Math.multiplyExact(++p, replLen - targLen));
+        } catch (ArithmeticException ignored) {
+            throw new OutOfMemoryError();
+        }
+        if (resultLen == 0) {
+            return "";
+        }
+
+        byte[] result = StringConcatHelper.newArray(resultLen);
+        int posFrom = 0, posTo = 0;
+        for (int q = 0; q < p; ++q) {
+            int nextPos = pos[q];
+            while (posFrom < nextPos) {
+                result[posTo++] = value[posFrom++];
+            }
+            posFrom += targLen;
+            for (int k = 0; k < replLen; ++k) {
+                result[posTo++] = repl[k];
+            }
+        }
+        while (posFrom < valLen) {
+            result[posTo++] = value[posFrom++];
+        }
+        return new String(result, LATIN1);
+    }
+
     // case insensitive
     public static boolean regionMatchesCI(byte[] value, int toffset,
                                           byte[] other, int ooffset, int len) {
         int last = toffset + len;
         while (toffset < last) {
             char c1 = (char)(value[toffset++] & 0xff);
             char c2 = (char)(other[ooffset++] & 0xff);
             if (c1 == c2) {
                 continue;
             }
-            char u1 = Character.toUpperCase(c1);
-            char u2 = Character.toUpperCase(c2);
+            int u1 = CharacterDataLatin1.instance.toUpperCase(c1);
+            int u2 = CharacterDataLatin1.instance.toUpperCase(c2);
             if (u1 == u2) {
                 continue;
             }
             if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {
                 continue;
@@ -360,11 +411,11 @@
             char c1 = (char)(value[toffset++] & 0xff);
             char c2 = StringUTF16.getChar(other, ooffset++);
             if (c1 == c2) {
                 continue;
             }
-            char u1 = Character.toUpperCase(c1);
+            char u1 = (char) CharacterDataLatin1.instance.toUpperCase(c1);
             char u2 = Character.toUpperCase(c2);
             if (u1 == u2) {
                 continue;
             }
             if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {
@@ -382,11 +433,11 @@
         int first;
         final int len = value.length;
         // Now check if there are any characters that need to be changed, or are surrogate
         for (first = 0 ; first < len; first++) {
             int cp = value[first] & 0xff;
-            if (cp != Character.toLowerCase(cp)) {  // no need to check Character.ERROR
+            if (cp != CharacterDataLatin1.instance.toLowerCase(cp)) {  // no need to check Character.ERROR
                 break;
             }
         }
         if (first == len)
             return str;
@@ -397,11 +448,11 @@
         byte[] result = new byte[len];
         System.arraycopy(value, 0, result, 0, first);  // Just copy the first few
                                                        // lowerCase characters.
         for (int i = first; i < len; i++) {
             int cp = value[i] & 0xff;
-            cp = Character.toLowerCase(cp);
+            cp = CharacterDataLatin1.instance.toLowerCase(cp);
             if (!canEncode(cp)) {                      // not a latin1 character
                 return toLowerCaseEx(str, value, first, locale, false);
             }
             result[i] = (byte)cp;
         }
@@ -421,11 +472,11 @@
             int lowerChar;
             char[] lowerCharArray;
             if (localeDependent) {
                 lowerChar = ConditionalSpecialCasing.toLowerCaseEx(str, i, locale);
             } else {
-                lowerChar = Character.toLowerCase(srcChar);
+                lowerChar = CharacterDataLatin1.instance.toLowerCase(srcChar);
             }
             if (Character.isBmpCodePoint(lowerChar)) {    // Character.ERROR is not a bmp
                 StringUTF16.putChar(result, resultOffset++, lowerChar);
             } else {
                 if (lowerChar == Character.ERROR) {
@@ -456,11 +507,11 @@
         final int len = value.length;
 
         // Now check if there are any characters that need to be changed, or are surrogate
         for (first = 0 ; first < len; first++ ) {
             int cp = value[first] & 0xff;
-            if (cp != Character.toUpperCaseEx(cp)) {   // no need to check Character.ERROR
+            if (cp != CharacterDataLatin1.instance.toUpperCaseEx(cp)) {   // no need to check Character.ERROR
                 break;
             }
         }
         if (first == len) {
             return str;
@@ -472,11 +523,11 @@
         byte[] result = new byte[len];
         System.arraycopy(value, 0, result, 0, first);  // Just copy the first few
                                                        // upperCase characters.
         for (int i = first; i < len; i++) {
             int cp = value[i] & 0xff;
-            cp = Character.toUpperCaseEx(cp);
+            cp = CharacterDataLatin1.instance.toUpperCaseEx(cp);
             if (!canEncode(cp)) {                      // not a latin1 character
                 return toUpperCaseEx(str, value, first, locale, false);
             }
             result[i] = (byte)cp;
         }
@@ -496,21 +547,21 @@
             int upperChar;
             char[] upperCharArray;
             if (localeDependent) {
                 upperChar = ConditionalSpecialCasing.toUpperCaseEx(str, i, locale);
             } else {
-                upperChar = Character.toUpperCaseEx(srcChar);
+                upperChar = CharacterDataLatin1.instance.toUpperCaseEx(srcChar);
             }
             if (Character.isBmpCodePoint(upperChar)) {
                 StringUTF16.putChar(result, resultOffset++, upperChar);
             } else {
                 if (upperChar == Character.ERROR) {
                     if (localeDependent) {
                         upperCharArray =
                             ConditionalSpecialCasing.toUpperCaseCharArray(str, i, locale);
                     } else {
-                        upperCharArray = Character.toUpperCaseCharArray(srcChar);
+                        upperCharArray = CharacterDataLatin1.instance.toUpperCaseCharArray(srcChar);
                     }
                 } else {
                     upperCharArray = Character.toChars(upperChar);
                 }
                 /* Grow result if needed */
@@ -544,11 +595,11 @@
     public static int indexOfNonWhitespace(byte[] value) {
         int length = value.length;
         int left = 0;
         while (left < length) {
             char ch = getChar(value, left);
-            if (ch != ' ' && ch != '\t' && !Character.isWhitespace(ch)) {
+            if (ch != ' ' && ch != '\t' && !CharacterDataLatin1.instance.isWhitespace(ch)) {
                 break;
             }
             left++;
         }
         return left;
@@ -557,11 +608,11 @@
     public static int lastIndexOfNonWhitespace(byte[] value) {
         int length = value.length;
         int right = length;
         while (0 < right) {
             char ch = getChar(value, right - 1);
-            if (ch != ' ' && ch != '\t' && !Character.isWhitespace(ch)) {
+            if (ch != ' ' && ch != '\t' && !CharacterDataLatin1.instance.isWhitespace(ch)) {
                 break;
             }
             right--;
         }
         return right;
@@ -679,80 +730,14 @@
         }
 
         static LinesSpliterator spliterator(byte[] value) {
             return new LinesSpliterator(value, 0, value.length);
         }
-
-        static LinesSpliterator spliterator(byte[] value, int leading, int trailing) {
-            int length = value.length;
-            int left = 0;
-            int index;
-            for (int l = 0; l < leading; l++) {
-                index = skipBlankForward(value, left, length);
-                if (index == left) {
-                    break;
-                }
-                left = index;
-            }
-            int right = length;
-            for (int t = 0; t < trailing; t++) {
-                index = skipBlankBackward(value, left, right);
-                if (index == right) {
-                    break;
-                }
-                right = index;
-            }
-            return new LinesSpliterator(value, left, right - left);
-        }
-
-        private static int skipBlankForward(byte[] value, int start, int length) {
-            int index = start;
-            while (index < length) {
-                char ch = getChar(value, index++);
-                if (ch == '\n') {
-                    return index;
-                }
-                if (ch == '\r') {
-                    if (index < length && getChar(value, index) == '\n') {
-                        return index + 1;
-                    }
-                    return index;
-                }
-                if (ch != ' ' && ch != '\t' && !Character.isWhitespace(ch)) {
-                    return start;
-                }
-            }
-            return length;
-        }
-
-        private static int skipBlankBackward(byte[] value, int start, int fence) {
-            int index = fence;
-            if (start < index && getChar(value, index - 1) == '\n') {
-                index--;
-            }
-            if (start < index && getChar(value, index - 1) == '\r') {
-                index--;
-            }
-            while (start < index) {
-                char ch = getChar(value, --index);
-                if (ch == '\r' || ch == '\n') {
-                    return index + 1;
-                }
-                if (ch != ' ' && ch != '\t' && !Character.isWhitespace(ch)) {
-                    return fence;
-                }
-            }
-            return start;
-        }
     }
 
-    static Stream<String> lines(byte[] value, int leading, int trailing) {
-        if (leading == 0 && trailing == 0) {
-            return StreamSupport.stream(LinesSpliterator.spliterator(value), false);
-        } else {
-            return StreamSupport.stream(LinesSpliterator.spliterator(value, leading, trailing), false);
-        }
+    static Stream<String> lines(byte[] value) {
+        return StreamSupport.stream(LinesSpliterator.spliterator(value), false);
     }
 
     public static void putChar(byte[] val, int index, int c) {
         //assert (canEncode(c));
         val[index] = (byte)(c);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/regex/Grapheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
<a name="2" id="anc2"></a>

 28 final class Grapheme {
 29 
 30     /**
 31      * Determines if there is an extended  grapheme cluster boundary between two
 32      * continuing characters {@code cp1} and {@code cp2}.
 33      * &lt;p&gt;
 34      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
 35      * for the extended grapheme cluster boundary rules
<a name="3" id="anc3"></a>

 36      */
 37     static boolean isBoundary(int cp1, int cp2) {
 38         return rules[getType(cp1)][getType(cp2)];
 39     }
 40 
<a name="4" id="anc4"></a>
















































 41     // types
 42     private static final int OTHER = 0;
 43     private static final int CR = 1;
 44     private static final int LF = 2;
 45     private static final int CONTROL = 3;
 46     private static final int EXTEND = 4;
<a name="5" id="anc5"></a><span class="line-modified"> 47     private static final int RI = 5;</span>
<span class="line-modified"> 48     private static final int PREPEND = 6;</span>
<span class="line-modified"> 49     private static final int SPACINGMARK = 7;</span>
<span class="line-modified"> 50     private static final int L = 8;</span>
<span class="line-modified"> 51     private static final int V = 9;</span>
<span class="line-modified"> 52     private static final int T = 10;</span>
<span class="line-modified"> 53     private static final int LV = 11;</span>
<span class="line-modified"> 54     private static final int LVT = 12;</span>


 55 
 56     private static final int FIRST_TYPE = 0;
<a name="6" id="anc6"></a><span class="line-modified"> 57     private static final int LAST_TYPE = 12;</span>
 58 
 59     private static boolean[][] rules;
 60     static {
 61         rules = new boolean[LAST_TYPE + 1][LAST_TYPE + 1];
<a name="7" id="anc7"></a><span class="line-modified"> 62         // default, any + any</span>
 63         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
 64             for (int j = FIRST_TYPE; j &lt;= LAST_TYPE; j++)
 65                 rules[i][j] = true;
 66         // GB 6 L x (L | V | LV | VT)
 67         rules[L][L] = false;
 68         rules[L][V] = false;
 69         rules[L][LV] = false;
 70         rules[L][LVT] = false;
 71         // GB 7 (LV | V) x (V | T)
 72         rules[LV][V] = false;
 73         rules[LV][T] = false;
 74         rules[V][V] = false;
 75         rules[V][T] = false;
 76         // GB 8 (LVT | T) x T
 77         rules[LVT][T] = false;
 78         rules[T][T] = false;
<a name="8" id="anc8"></a><span class="line-modified"> 79         // GB 8a RI x RI</span>
<span class="line-removed"> 80         rules[RI][RI] = false;</span>
<span class="line-removed"> 81         // GB 9 x Extend</span>
 82         // GB 9a x Spacing Mark
 83         // GB 9b Prepend x
 84         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++) {
 85             rules[i][EXTEND] = false;
<a name="9" id="anc9"></a>
 86             rules[i][SPACINGMARK] = false;
 87             rules[PREPEND][i] = false;
 88         }
 89         // GB 4  (Control | CR | LF) +
 90         // GB 5  + (Control | CR | LF)
 91         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
 92             for (int j = CR; j &lt;= CONTROL; j++) {
 93                 rules[i][j] = true;
 94                 rules[j][i] = true;
 95             }
 96         // GB 3 CR x LF
 97         rules[CR][LF] = false;
<a name="10" id="anc10"></a><span class="line-modified"> 98         // GB 10 Any + Any  -&gt; default</span>


 99     }
100 
101     // Hangul syllables
102     private static final int SYLLABLE_BASE = 0xAC00;
103     private static final int LCOUNT = 19;
104     private static final int VCOUNT = 21;
105     private static final int TCOUNT = 28;
106     private static final int NCOUNT = VCOUNT * TCOUNT; // 588
107     private static final int SCOUNT = LCOUNT * NCOUNT; // 11172
108 
109     // #tr29: SpacingMark exceptions: The following (which have
110     // General_Category = Spacing_Mark and would otherwise be included)
111     // are specifically excluded
112     private static boolean isExcludedSpacingMark(int cp) {
113        return  cp == 0x102B || cp == 0x102C || cp == 0x1038 ||
114                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x1064 ||
115                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x106D ||
116                cp == 0x1083 ||
117                cp &gt;= 0x1087 &amp;&amp; cp &lt;= 0x108C ||
118                cp == 0x108F ||
119                cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
120                cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
121                cp == 0xAA7B || cp == 0xAA7D;
122     }
123 
<a name="11" id="anc11"></a>













124     @SuppressWarnings(&quot;fallthrough&quot;)
125     private static int getType(int cp) {
<a name="12" id="anc12"></a>



126         int type = Character.getType(cp);
127         switch(type) {
<a name="13" id="anc13"></a><span class="line-modified">128         case Character.CONTROL:</span>
<span class="line-removed">129             if (cp == 0x000D)</span>
<span class="line-removed">130                 return CR;</span>
<span class="line-removed">131             if (cp == 0x000A)</span>
<span class="line-removed">132                 return LF;</span>
<span class="line-removed">133             return CONTROL;</span>
<span class="line-removed">134          case Character.UNASSIGNED:</span>
135             // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
136             // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
137             // so type it as &quot;Other&quot; to make the test happy
<a name="14" id="anc14"></a><span class="line-modified">138              if (cp == 0x0378)</span>
<span class="line-modified">139                  return OTHER;</span>
140 
<a name="15" id="anc15"></a>
141         case Character.LINE_SEPARATOR:
142         case Character.PARAGRAPH_SEPARATOR:
143         case Character.SURROGATE:
144             return CONTROL;
145         case Character.FORMAT:
<a name="16" id="anc16"></a><span class="line-modified">146             if (cp == 0x200C || cp == 0x200D)</span>

147                 return EXTEND;
<a name="17" id="anc17"></a>





148             return CONTROL;
149         case Character.NON_SPACING_MARK:
150         case Character.ENCLOSING_MARK:
<a name="18" id="anc18"></a><span class="line-modified">151              // NOTE:</span>
<span class="line-modified">152              // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for</span>
<span class="line-modified">153              // canonical equivalence.&quot;</span>
<span class="line-modified">154              // but for &quot;extended grapheme clusters&quot; support, there is no</span>
<span class="line-modified">155              // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a</span>
<span class="line-modified">156              return EXTEND;</span>
157         case  Character.COMBINING_SPACING_MARK:
158             if (isExcludedSpacingMark(cp))
159                 return OTHER;
160             // NOTE:
161             // 0x11720 and 0x11721 are mentioned in #tr29 as
162             // OTHER_LETTER but it appears their category has been updated to
163             // COMBING_SPACING_MARK already (verified in ver.8)
164             return SPACINGMARK;
165         case Character.OTHER_SYMBOL:
166             if (cp &gt;= 0x1F1E6 &amp;&amp; cp &lt;= 0x1F1FF)
167                 return RI;
168             return OTHER;
169         case Character.MODIFIER_LETTER:
<a name="19" id="anc19"></a>
170             // WARNING:
171             // not mentioned in #tr29 but listed in GraphemeBreakProperty.txt
<a name="20" id="anc20"></a><span class="line-modified">172             if (cp == 0xFF9E || cp == 0xFF9F)</span>

173                 return EXTEND;
174             return OTHER;
175         case Character.OTHER_LETTER:
176             if (cp == 0x0E33 || cp == 0x0EB3)
177                 return SPACINGMARK;
178             // hangul jamo
179             if (cp &gt;= 0x1100 &amp;&amp; cp &lt;= 0x11FF) {
180                 if (cp &lt;= 0x115F)
181                     return L;
182                 if (cp &lt;= 0x11A7)
183                     return V;
184                 return T;
185             }
186             // hangul syllables
187             int sindex = cp - SYLLABLE_BASE;
188             if (sindex &gt;= 0 &amp;&amp; sindex &lt; SCOUNT) {
189 
190                 if (sindex % TCOUNT == 0)
191                     return LV;
192                 return LVT;
193             }
194             //  hangul jamo_extended A
195             if (cp &gt;= 0xA960 &amp;&amp; cp &lt;= 0xA97C)
196                 return L;
197             //  hangul jamo_extended B
198             if (cp &gt;= 0xD7B0 &amp;&amp; cp &lt;= 0xD7C6)
199                 return V;
200             if (cp &gt;= 0xD7CB &amp;&amp; cp &lt;= 0xD7FB)
201                 return T;
<a name="21" id="anc21"></a>















202         }
203         return OTHER;
204     }
205 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
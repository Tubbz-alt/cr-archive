<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodType.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodTypeForm.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodType.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,13 ***</span>
<span class="line-new-header">--- 44,15 ---</span>
  
  import jdk.internal.vm.annotation.Stable;
  import sun.invoke.util.BytecodeDescriptor;
  import sun.invoke.util.VerifyType;
  import sun.invoke.util.Wrapper;
<span class="line-added">+ import sun.security.util.SecurityConstants;</span>
  
  import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
<span class="line-added">+ import static java.lang.invoke.MethodType.fromDescriptor;</span>
  
  /**
   * A method type represents the arguments and return type accepted and
   * returned by a method handle, or the arguments and return type passed
   * and expected  by a method handle caller.  Method types must be properly
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,12 ***</span>
   * Like classes and strings, method types can also be represented directly
   * in a class file&#39;s constant pool as constants.
   * A method type may be loaded by an {@code ldc} instruction which refers
   * to a suitable {@code CONSTANT_MethodType} constant pool entry.
   * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
<span class="line-modified">!  * (For full details on method type constants,</span>
<span class="line-modified">!  * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)</span>
   * &lt;p&gt;
   * When the JVM materializes a {@code MethodType} from a descriptor string,
   * all classes named in the descriptor must be accessible, and will be loaded.
   * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
   * This loading may occur at any time before the {@code MethodType} object is first derived.
<span class="line-new-header">--- 89,13 ---</span>
   * Like classes and strings, method types can also be represented directly
   * in a class file&#39;s constant pool as constants.
   * A method type may be loaded by an {@code ldc} instruction which refers
   * to a suitable {@code CONSTANT_MethodType} constant pool entry.
   * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
<span class="line-modified">!  * (For full details on method type constants, see sections {@jvms</span>
<span class="line-modified">!  * 4.4.8} and {@jvms 5.4.3.5} of the Java Virtual Machine</span>
<span class="line-added">+  * Specification.)</span>
   * &lt;p&gt;
   * When the JVM materializes a {@code MethodType} from a descriptor string,
   * all classes named in the descriptor must be accessible, and will be loaded.
   * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
   * This loading may occur at any time before the {@code MethodType} object is first derived.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,10 ***</span>
<span class="line-new-header">--- 105,11 ---</span>
  public final
  class MethodType
          implements Constable,
                     TypeDescriptor.OfMethod&lt;Class&lt;?&gt;, MethodType&gt;,
                     java.io.Serializable {
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
  
      // The rtype and ptypes fields define the structural identity of the method type:
      private final @Stable Class&lt;?&gt;   rtype;
      private final @Stable Class&lt;?&gt;[] ptypes;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,31 ***</span>
       *  It limits both JVM signatures and method type objects.
       *  The longest possible invocation will look like
       *  {@code staticMethod(arg1, arg2, ..., arg255)} or
       *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
       */
<span class="line-modified">!     /*non-public*/ static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.</span>
  
      /** This number is the maximum arity of a method handle, 254.
       *  It is derived from the absolute JVM-imposed arity by subtracting one,
       *  which is the slot occupied by the method handle itself at the
       *  beginning of the argument list used to invoke the method handle.
       *  The longest possible invocation will look like
       *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
       */
      // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
<span class="line-modified">!     /*non-public*/ static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver</span>
  
      /** This number is the maximum arity of a method handle invoker, 253.
       *  It is derived from the absolute JVM-imposed arity by subtracting two,
       *  which are the slots occupied by invoke method handle, and the
       *  target method handle, which are both at the beginning of the argument
       *  list used to invoke the target method handle.
       *  The longest possible invocation will look like
       *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
       */
<span class="line-modified">!     /*non-public*/ static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker</span>
  
      private static void checkRtype(Class&lt;?&gt; rtype) {
          Objects.requireNonNull(rtype);
      }
      private static void checkPtype(Class&lt;?&gt; ptype) {
<span class="line-new-header">--- 141,34 ---</span>
       *  It limits both JVM signatures and method type objects.
       *  The longest possible invocation will look like
       *  {@code staticMethod(arg1, arg2, ..., arg255)} or
       *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.</span>
  
      /** This number is the maximum arity of a method handle, 254.
       *  It is derived from the absolute JVM-imposed arity by subtracting one,
       *  which is the slot occupied by the method handle itself at the
       *  beginning of the argument list used to invoke the method handle.
       *  The longest possible invocation will look like
       *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
       */
      // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver</span>
  
      /** This number is the maximum arity of a method handle invoker, 253.
       *  It is derived from the absolute JVM-imposed arity by subtracting two,
       *  which are the slots occupied by invoke method handle, and the
       *  target method handle, which are both at the beginning of the argument
       *  list used to invoke the target method handle.
       *  The longest possible invocation will look like
       *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker</span>
  
      private static void checkRtype(Class&lt;?&gt; rtype) {
          Objects.requireNonNull(rtype);
      }
      private static void checkPtype(Class&lt;?&gt; ptype) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,12 ***</span>
       * @param ptypes the parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
       * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</span>
          return makeImpl(rtype, ptypes, false);
      }
  
      /**
       * Finds or creates a method type with the given components.
<span class="line-new-header">--- 212,11 ---</span>
       * @param ptypes the parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
       * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
       */
<span class="line-modified">!     public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</span>
          return makeImpl(rtype, ptypes, false);
      }
  
      /**
       * Finds or creates a method type with the given components.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,12 ***</span>
       * @param ptypes the parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
       * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) {</span>
          boolean notrust = false;  // random List impl. could return evil ptypes array
          return makeImpl(rtype, listToArray(ptypes), notrust);
      }
  
      private static Class&lt;?&gt;[] listToArray(List&lt;Class&lt;?&gt;&gt; ptypes) {
<span class="line-new-header">--- 225,11 ---</span>
       * @param ptypes the parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
       * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
       */
<span class="line-modified">!     public static MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) {</span>
          boolean notrust = false;  // random List impl. could return evil ptypes array
          return makeImpl(rtype, listToArray(ptypes), notrust);
      }
  
      private static Class&lt;?&gt;[] listToArray(List&lt;Class&lt;?&gt;&gt; ptypes) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,12 ***</span>
       * @param ptypes the remaining parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
       * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) {</span>
          Class&lt;?&gt;[] ptypes1 = new Class&lt;?&gt;[1+ptypes.length];
          ptypes1[0] = ptype0;
          System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
          return makeImpl(rtype, ptypes1, true);
      }
<span class="line-new-header">--- 247,11 ---</span>
       * @param ptypes the remaining parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
       * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
       */
<span class="line-modified">!     public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) {</span>
          Class&lt;?&gt;[] ptypes1 = new Class&lt;?&gt;[1+ptypes.length];
          ptypes1[0] = ptype0;
          System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
          return makeImpl(rtype, ptypes1, true);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,12 ***</span>
       * The resulting method has no parameter types.
       * @param rtype  the return type
       * @return a method type with the given return value
       * @throws NullPointerException if {@code rtype} is null
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType methodType(Class&lt;?&gt; rtype) {</span>
          return makeImpl(rtype, NO_PTYPES, true);
      }
  
      /**
       * Finds or creates a method type with the given components.
<span class="line-new-header">--- 262,11 ---</span>
       * The resulting method has no parameter types.
       * @param rtype  the return type
       * @return a method type with the given return value
       * @throws NullPointerException if {@code rtype} is null
       */
<span class="line-modified">!     public static MethodType methodType(Class&lt;?&gt; rtype) {</span>
          return makeImpl(rtype, NO_PTYPES, true);
      }
  
      /**
       * Finds or creates a method type with the given components.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,12 ***</span>
       * @param ptype0 the parameter type
       * @return a method type with the given return value and parameter type
       * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
       * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) {</span>
          return makeImpl(rtype, new Class&lt;?&gt;[]{ ptype0 }, true);
      }
  
      /**
       * Finds or creates a method type with the given components.
<span class="line-new-header">--- 276,11 ---</span>
       * @param ptype0 the parameter type
       * @return a method type with the given return value and parameter type
       * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
       * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
       */
<span class="line-modified">!     public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) {</span>
          return makeImpl(rtype, new Class&lt;?&gt;[]{ ptype0 }, true);
      }
  
      /**
       * Finds or creates a method type with the given components.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,24 ***</span>
       * @param rtype  the return type
       * @param ptypes the method type which supplies the parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) {</span>
          return makeImpl(rtype, ptypes.ptypes, true);
      }
  
      /**
       * Sole factory method to find or create an interned method type.
       * @param rtype desired return type
       * @param ptypes desired parameter types
       * @param trusted whether the ptypes can be used without cloning
       * @return the unique method type of the desired structure
       */
<span class="line-modified">!     /*trusted*/ static</span>
<span class="line-modified">!     MethodType makeImpl(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {</span>
          if (ptypes.length == 0) {
              ptypes = NO_PTYPES; trusted = true;
          }
          MethodType primordialMT = new MethodType(rtype, ptypes);
          MethodType mt = internTable.get(primordialMT);
<span class="line-new-header">--- 290,23 ---</span>
       * @param rtype  the return type
       * @param ptypes the method type which supplies the parameter types
       * @return a method type with the given components
       * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
       */
<span class="line-modified">!     public static MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) {</span>
          return makeImpl(rtype, ptypes.ptypes, true);
      }
  
      /**
       * Sole factory method to find or create an interned method type.
       * @param rtype desired return type
       * @param ptypes desired parameter types
       * @param trusted whether the ptypes can be used without cloning
       * @return the unique method type of the desired structure
       */
<span class="line-modified">!     /*trusted*/</span>
<span class="line-modified">!     static MethodType makeImpl(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {</span>
          if (ptypes.length == 0) {
              ptypes = NO_PTYPES; trusted = true;
          }
          MethodType primordialMT = new MethodType(rtype, ptypes);
          MethodType mt = internTable.get(primordialMT);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,12 ***</span>
       * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
       * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
       * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
       * @see #genericMethodType(int)
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType genericMethodType(int objectArgCount, boolean finalArray) {</span>
          MethodType mt;
          checkSlotCount(objectArgCount);
          int ivarargs = (!finalArray ? 0 : 1);
          int ootIndex = objectArgCount*2 + ivarargs;
          if (ootIndex &lt; objectOnlyTypes.length) {
<span class="line-new-header">--- 338,11 ---</span>
       * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
       * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
       * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
       * @see #genericMethodType(int)
       */
<span class="line-modified">!     public static MethodType genericMethodType(int objectArgCount, boolean finalArray) {</span>
          MethodType mt;
          checkSlotCount(objectArgCount);
          int ivarargs = (!finalArray ? 0 : 1);
          int ootIndex = objectArgCount*2 + ivarargs;
          if (ootIndex &lt; objectOnlyTypes.length) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,12 ***</span>
       * @param objectArgCount number of parameters
       * @return a generally applicable method type, for all calls of the given argument count
       * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255
       * @see #genericMethodType(int, boolean)
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodType genericMethodType(int objectArgCount) {</span>
          return genericMethodType(objectArgCount, false);
      }
  
      /**
       * Finds or creates a method type with a single different parameter type.
<span class="line-new-header">--- 366,11 ---</span>
       * @param objectArgCount number of parameters
       * @return a generally applicable method type, for all calls of the given argument count
       * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255
       * @see #genericMethodType(int, boolean)
       */
<span class="line-modified">!     public static MethodType genericMethodType(int objectArgCount) {</span>
          return genericMethodType(objectArgCount, false);
      }
  
      /**
       * Finds or creates a method type with a single different parameter type.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,11 ***</span>
       *                                  or if {@code start} is greater than {@code end}
       * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
       *                                  or if the resulting method type would have more than 255 parameter slots
       * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
       */
<span class="line-modified">!     /*non-public*/ MethodType replaceParameterTypes(int start, int end, Class&lt;?&gt;... ptypesToInsert) {</span>
          if (start == end)
              return insertParameterTypes(start, ptypesToInsert);
          int len = ptypes.length;
          if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))
              throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);
<span class="line-new-header">--- 473,12 ---</span>
       *                                  or if {@code start} is greater than {@code end}
       * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
       *                                  or if the resulting method type would have more than 255 parameter slots
       * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodType replaceParameterTypes(int start, int end, Class&lt;?&gt;... ptypesToInsert) {</span>
          if (start == end)
              return insertParameterTypes(start, ptypesToInsert);
          int len = ptypes.length;
          if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))
              throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,11 ***</span>
       * @param arrayType any array type
       * @param pos position at which to spread
       * @param arrayLength the number of parameter types to change
       * @return the resulting type
       */
<span class="line-modified">!     /*non-public*/ MethodType asSpreaderType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
          assert(parameterCount() &gt;= arrayLength);
          int spreadPos = pos;
          if (arrayLength == 0)  return this;  // nothing to change
          if (arrayType == Object[].class) {
              if (isGeneric())  return this;  // nothing to change
<span class="line-new-header">--- 492,12 ---</span>
       * @param arrayType any array type
       * @param pos position at which to spread
       * @param arrayLength the number of parameter types to change
       * @return the resulting type
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodType asSpreaderType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
          assert(parameterCount() &gt;= arrayLength);
          int spreadPos = pos;
          if (arrayLength == 0)  return this;  // nothing to change
          if (arrayType == Object[].class) {
              if (isGeneric())  return this;  // nothing to change
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,11 ***</span>
      }
  
      /** Return the leading parameter type, which must exist and be a reference.
       *  @return the leading parameter type, after error checks
       */
<span class="line-modified">!     /*non-public*/ Class&lt;?&gt; leadingReferenceParameter() {</span>
          Class&lt;?&gt; ptype;
          if (ptypes.length == 0 ||
              (ptype = ptypes[0]).isPrimitive())
              throw newIllegalArgumentException(&quot;no leading reference parameter&quot;);
          return ptype;
<span class="line-new-header">--- 523,12 ---</span>
      }
  
      /** Return the leading parameter type, which must exist and be a reference.
       *  @return the leading parameter type, after error checks
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     Class&lt;?&gt; leadingReferenceParameter() {</span>
          Class&lt;?&gt; ptype;
          if (ptypes.length == 0 ||
              (ptype = ptypes[0]).isPrimitive())
              throw newIllegalArgumentException(&quot;no leading reference parameter&quot;);
          return ptype;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,11 ***</span>
       * @param arrayType any array type
       * @param pos position at which to insert parameters
       * @param arrayLength the number of parameter types to insert
       * @return the resulting type
       */
<span class="line-modified">!     /*non-public*/ MethodType asCollectorType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
          assert(parameterCount() &gt;= 1);
          assert(pos &lt; ptypes.length);
          assert(ptypes[pos].isAssignableFrom(arrayType));
          MethodType res;
          if (arrayType == Object[].class) {
<span class="line-new-header">--- 538,12 ---</span>
       * @param arrayType any array type
       * @param pos position at which to insert parameters
       * @param arrayLength the number of parameter types to insert
       * @return the resulting type
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodType asCollectorType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
          assert(parameterCount() &gt;= 1);
          assert(pos &lt; ptypes.length);
          assert(ptypes[pos].isAssignableFrom(arrayType));
          MethodType res;
          if (arrayType == Object[].class) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,21 ***</span>
       * Erases all reference types to {@code Object}, and all subword types to {@code int}.
       * This is the reduced type polymorphism used by private methods
       * such as {@link MethodHandle#invokeBasic invokeBasic}.
       * @return a version of the original type with all reference and subword types replaced
       */
<span class="line-modified">!     /*non-public*/ MethodType basicType() {</span>
          return form.basicType();
      }
  
      private static final @Stable Class&lt;?&gt;[] METHOD_HANDLE_ARRAY
              = new Class&lt;?&gt;[] { MethodHandle.class };
  
      /**
       * @return a version of the original type with MethodHandle prepended as the first argument
       */
<span class="line-modified">!     /*non-public*/ MethodType invokerType() {</span>
          return insertParameterTypes(0, METHOD_HANDLE_ARRAY);
      }
  
      /**
       * Converts all types, both reference and primitive, to {@code Object}.
<span class="line-new-header">--- 650,23 ---</span>
       * Erases all reference types to {@code Object}, and all subword types to {@code int}.
       * This is the reduced type polymorphism used by private methods
       * such as {@link MethodHandle#invokeBasic invokeBasic}.
       * @return a version of the original type with all reference and subword types replaced
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodType basicType() {</span>
          return form.basicType();
      }
  
      private static final @Stable Class&lt;?&gt;[] METHOD_HANDLE_ARRAY
              = new Class&lt;?&gt;[] { MethodHandle.class };
  
      /**
       * @return a version of the original type with MethodHandle prepended as the first argument
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     MethodType invokerType() {</span>
          return insertParameterTypes(0, METHOD_HANDLE_ARRAY);
      }
  
      /**
       * Converts all types, both reference and primitive, to {@code Object}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,11 ***</span>
       */
      public MethodType generic() {
          return genericMethodType(parameterCount());
      }
  
<span class="line-modified">!     /*non-public*/ boolean isGeneric() {</span>
          return this == erase() &amp;&amp; !hasPrimitives();
      }
  
      /**
       * Converts all primitive types to their corresponding wrapper types.
<span class="line-new-header">--- 677,12 ---</span>
       */
      public MethodType generic() {
          return genericMethodType(parameterCount());
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     boolean isGeneric() {</span>
          return this == erase() &amp;&amp; !hasPrimitives();
      }
  
      /**
       * Converts all primitive types to their corresponding wrapper types.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 923,12 ***</span>
          if (argc &lt;= 1) {
              if (argc == 1 &amp;&amp; !canConvert(srcTypes[0], dstTypes[0]))
                  return false;
              return true;
          }
<span class="line-modified">!         if ((oldForm.primitiveParameterCount() == 0 &amp;&amp; oldForm.erasedType == this) ||</span>
<span class="line-modified">!             (newForm.primitiveParameterCount() == 0 &amp;&amp; newForm.erasedType == newType)) {</span>
              // Somewhat complicated test to avoid a loop of 2 or more trips.
              // If either type has only Object parameters, we know we can convert.
              assert(canConvertParameters(srcTypes, dstTypes));
              return true;
          }
<span class="line-new-header">--- 929,12 ---</span>
          if (argc &lt;= 1) {
              if (argc == 1 &amp;&amp; !canConvert(srcTypes[0], dstTypes[0]))
                  return false;
              return true;
          }
<span class="line-modified">!         if ((!oldForm.hasPrimitives() &amp;&amp; oldForm.erasedType == this) ||</span>
<span class="line-modified">!             (!newForm.hasPrimitives() &amp;&amp; newForm.erasedType == newType)) {</span>
              // Somewhat complicated test to avoid a loop of 2 or more trips.
              // If either type has only Object parameters, we know we can convert.
              assert(canConvertParameters(srcTypes, dstTypes));
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1059,70 ***</span>
       * &lt;p&gt;
       * This method is included for the benefit of applications that must
       * generate bytecodes that process method handles and invokedynamic.
       * @return the number of JVM stack slots for this type&#39;s parameters
       */
<span class="line-modified">!     /*non-public*/ int parameterSlotCount() {</span>
          return form.parameterSlotCount();
      }
  
<span class="line-modified">!     /*non-public*/ Invokers invokers() {</span>
          Invokers inv = invokers;
          if (inv != null)  return inv;
          invokers = inv = new Invokers(this);
          return inv;
      }
  
<span class="line-removed">-     /** Reports the number of JVM stack slots which carry all parameters including and after</span>
<span class="line-removed">-      * the given position, which must be in the range of 0 to</span>
<span class="line-removed">-      * {@code parameterCount} inclusive.  Successive parameters are</span>
<span class="line-removed">-      * more shallowly stacked, and parameters are indexed in the bytecodes</span>
<span class="line-removed">-      * according to their trailing edge.  Thus, to obtain the depth</span>
<span class="line-removed">-      * in the outgoing call stack of parameter {@code N}, obtain</span>
<span class="line-removed">-      * the {@code parameterSlotDepth} of its trailing edge</span>
<span class="line-removed">-      * at position {@code N+1}.</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * Parameters of type {@code long} and {@code double} occupy</span>
<span class="line-removed">-      * two stack slots (for historical reasons) and all others occupy one.</span>
<span class="line-removed">-      * Therefore, the number returned is the number of arguments</span>
<span class="line-removed">-      * &lt;em&gt;including&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; the given parameter,</span>
<span class="line-removed">-      * &lt;em&gt;plus&lt;/em&gt; the number of long or double arguments</span>
<span class="line-removed">-      * at or after the argument for the given parameter.</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * This method is included for the benefit of applications that must</span>
<span class="line-removed">-      * generate bytecodes that process method handles and invokedynamic.</span>
<span class="line-removed">-      * @param num an index (zero-based, inclusive) within the parameter types</span>
<span class="line-removed">-      * @return the index of the (shallowest) JVM stack slot transmitting the</span>
<span class="line-removed">-      *         given parameter</span>
<span class="line-removed">-      * @throws IllegalArgumentException if {@code num} is negative or greater than {@code parameterCount()}</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     /*non-public*/ int parameterSlotDepth(int num) {</span>
<span class="line-removed">-         if (num &lt; 0 || num &gt; ptypes.length)</span>
<span class="line-removed">-             parameterType(num);  // force a range check</span>
<span class="line-removed">-         return form.parameterToArgSlot(num-1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Reports the number of JVM stack slots required to receive a return value</span>
<span class="line-removed">-      * from a method of this type.</span>
<span class="line-removed">-      * If the {@link #returnType() return type} is void, it will be zero,</span>
<span class="line-removed">-      * else if the return type is long or double, it will be two, else one.</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * This method is included for the benefit of applications that must</span>
<span class="line-removed">-      * generate bytecodes that process method handles and invokedynamic.</span>
<span class="line-removed">-      * @return the number of JVM stack slots (0, 1, or 2) for this type&#39;s return value</span>
<span class="line-removed">-      * Will be removed for PFD.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     /*non-public*/ int returnSlotCount() {</span>
<span class="line-removed">-         return form.returnSlotCount();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
       * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<span class="line-modified">!      * Any class or interface name embedded in the descriptor string</span>
<span class="line-modified">!      * will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}</span>
<span class="line-removed">-      * on the given loader (or if it is null, on the system class loader).</span>
       * &lt;p&gt;
       * Note that it is possible to encounter method types which cannot be
       * constructed by this method, because their component types are
       * not all reachable from a common class loader.
       * &lt;p&gt;
<span class="line-new-header">--- 1065,28 ---</span>
       * &lt;p&gt;
       * This method is included for the benefit of applications that must
       * generate bytecodes that process method handles and invokedynamic.
       * @return the number of JVM stack slots for this type&#39;s parameters
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     int parameterSlotCount() {</span>
          return form.parameterSlotCount();
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     Invokers invokers() {</span>
          Invokers inv = invokers;
          if (inv != null)  return inv;
          invokers = inv = new Invokers(this);
          return inv;
      }
  
      /**
       * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
       * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<span class="line-modified">!      * Any class or interface name embedded in the descriptor string will be</span>
<span class="line-modified">!      * resolved by the given loader (or if it is null, on the system class loader).</span>
       * &lt;p&gt;
       * Note that it is possible to encounter method types which cannot be
       * constructed by this method, because their component types are
       * not all reachable from a common class loader.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1132,14 ***</span>
<span class="line-new-header">--- 1096,23 ---</span>
       * @param loader the class loader in which to look up the types
       * @return a method type matching the bytecode-level type descriptor
       * @throws NullPointerException if the string is null
       * @throws IllegalArgumentException if the string is not well-formed
       * @throws TypeNotPresentException if a named type cannot be found
<span class="line-added">+      * @throws SecurityException if the security manager is present and</span>
<span class="line-added">+      *         {@code loader} is {@code null} and the caller does not have the</span>
<span class="line-added">+      *         {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}</span>
       */
      public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
          throws IllegalArgumentException, TypeNotPresentException
      {
<span class="line-added">+         if (loader == null) {</span>
<span class="line-added">+             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+             if (sm != null) {</span>
<span class="line-added">+                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          return fromDescriptor(descriptor,
                                (loader == null) ? ClassLoader.getSystemClassLoader() : loader);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1197,11 ***</span>
      @Override
      public String descriptorString() {
          return toMethodDescriptorString();
      }
  
<span class="line-modified">!     /*non-public*/ static String toFieldDescriptorString(Class&lt;?&gt; cls) {</span>
          return BytecodeDescriptor.unparse(cls);
      }
  
      /**
       * Return a nominal descriptor for this instance, if one can be
<span class="line-new-header">--- 1170,12 ---</span>
      @Override
      public String descriptorString() {
          return toMethodDescriptorString();
      }
  
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static String toFieldDescriptorString(Class&lt;?&gt; cls) {</span>
          return BytecodeDescriptor.unparse(cls);
      }
  
      /**
       * Return a nominal descriptor for this instance, if one can be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1227,10 ***</span>
<span class="line-new-header">--- 1201,11 ---</span>
      /// Serialization.
  
      /**
       * There are no serializable fields for {@code MethodType}.
       */
<span class="line-added">+     @java.io.Serial</span>
      private static final java.io.ObjectStreamField[] serialPersistentFields = { };
  
      /**
       * Save the {@code MethodType} instance to a stream.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,10 ***</span>
<span class="line-new-header">--- 1224,11 ---</span>
       * For example, null values, or {@code void} parameter types,
       * will lead to exceptions during deserialization.
       * @param s the stream to write the object to
       * @throws java.io.IOException if there is a problem writing the object
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
          s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
          s.writeObject(returnType());
          s.writeObject(parameterArray());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,10 ***</span>
<span class="line-new-header">--- 1244,11 ---</span>
       * @throws java.io.IOException if there is a problem reading the object
       * @throws ClassNotFoundException if one of the component classes cannot be resolved
       * @see #readResolve
       * @see #writeObject
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
          // Assign temporary defaults in case this object escapes
          MethodType_init(void.class, NO_PTYPES);
  
          s.defaultReadObject();  // requires serialPersistentFields to be an empty array
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1307,10 ***</span>
<span class="line-new-header">--- 1284,11 ---</span>
      /**
       * Resolves and initializes a {@code MethodType} object
       * after serialization.
       * @return the fully initialized {@code MethodType} object
       */
<span class="line-added">+     @java.io.Serial</span>
      private Object readResolve() {
          // Do not use a trusted path for deserialization:
          //    return makeImpl(rtype, ptypes, true);
          // Verify all operands, and make sure ptypes is unshared:
          try {
</pre>
<center><a href="MethodHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodTypeForm.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
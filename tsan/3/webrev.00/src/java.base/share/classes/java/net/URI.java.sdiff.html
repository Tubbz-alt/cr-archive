<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/URI.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StandardSocketOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URISyntaxException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/URI.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  25 
  26 package java.net;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InvalidObjectException;
  31 import java.io.ObjectInputStream;
  32 import java.io.ObjectOutputStream;
  33 import java.io.Serializable;
  34 import java.nio.ByteBuffer;
  35 import java.nio.CharBuffer;
  36 import java.nio.charset.CharsetDecoder;
  37 import java.nio.charset.CoderResult;
  38 import java.nio.charset.CodingErrorAction;
  39 import java.nio.charset.CharacterCodingException;
  40 import java.nio.file.Path;
  41 import java.text.Normalizer;
  42 import jdk.internal.access.JavaNetUriAccess;
  43 import jdk.internal.access.SharedSecrets;
  44 import sun.nio.cs.ThreadLocalCoders;

  45 
  46 import java.lang.Character;             // for javadoc
  47 import java.lang.NullPointerException;  // for javadoc
  48 
<span class="line-removed">  49 </span>
  50 /**
  51  * Represents a Uniform Resource Identifier (URI) reference.
  52  *
  53  * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
  54  * class represents a URI reference as defined by
  55  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
  56  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
  57  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
  58  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
  59  * also supports scope_ids. The syntax and usage of scope_ids is described
  60  * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
  61  * This class provides constructors for creating URI instances from
  62  * their components or by parsing their string forms, methods for accessing the
  63  * various components of an instance, and methods for normalizing, resolving,
  64  * and relativizing URI instances.  Instances of this class are immutable.
  65  *
  66  *
<span class="line-modified">  67  * &lt;h3&gt; URI syntax and components &lt;/h3&gt;</span>
  68  *
  69  * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
  70  * form has the syntax
  71  *
  72  * &lt;blockquote&gt;
  73  * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
  74  * &lt;/blockquote&gt;
  75  *
  76  * where square brackets [...] delineate optional components and the characters
  77  * &lt;b&gt;{@code :}&lt;/b&gt; and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.
  78  *
  79  * &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
  80  * said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
  81  * they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
  82  *
  83  * &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
  84  * not begin with a slash character ({@code &#39;/&#39;}).  Opaque URIs are not
  85  * subject to further parsing.  Some examples of opaque URIs are:
  86  *
  87  * &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
</pre>
<hr />
<pre>
 151  * &lt;/tbody&gt;
 152  * &lt;/table&gt;
 153  *
 154  * In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
 155  * &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
 156  * represented by {@code null}, while undefined integer components are
 157  * represented by {@code -1}.  A string component may be defined to have the
 158  * empty string as its value; this is not equivalent to that component being
 159  * undefined.
 160  *
 161  * &lt;p&gt; Whether a particular component is or is not defined in an instance
 162  * depends upon the type of the URI being represented.  An absolute URI has a
 163  * scheme component.  An opaque URI has a scheme, a scheme-specific part, and
 164  * possibly a fragment, but has no other components.  A hierarchical URI always
 165  * has a path (though it may be empty) and a scheme-specific-part (which at
 166  * least contains the path), and may have any of the other components.  If the
 167  * authority component is present and is server-based then the host component
 168  * will be defined and the user-information and port components may be defined.
 169  *
 170  *
<span class="line-modified"> 171  * &lt;h4&gt; Operations on URI instances &lt;/h4&gt;</span>
 172  *
 173  * The key operations supported by this class are those of
 174  * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
 175  *
 176  * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
 177  * and {@code &quot;..&quot;} segments from the path component of a hierarchical URI.
 178  * Each {@code &quot;.&quot;} segment is simply removed.  A {@code &quot;..&quot;} segment is
 179  * removed only if it is preceded by a non-{@code &quot;..&quot;} segment.
 180  * Normalization has no effect upon opaque URIs.
 181  *
 182  * &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
 183  * &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
 184  * URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
 185  * base URI for those not specified in the original.  For hierarchical URIs,
 186  * the path of the original is resolved against the path of the base and then
 187  * normalized.  The result, for example, of resolving
 188  *
 189  * &lt;blockquote&gt;
 190  * {@code sample/a/index.html#28}
 191  * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
</pre>
<hr />
<pre>
 230  *   &lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;.&lt;br&gt;
 231  * &lt;/blockquote&gt;
 232  *
 233  * This operation is often useful when constructing a document containing URIs
 234  * that must be made relative to the base URI of the document wherever
 235  * possible.  For example, relativizing the URI
 236  *
 237  * &lt;blockquote&gt;
 238  * {@code http://example.com/languages/java/sample/a/index.html#28}
 239  * &lt;/blockquote&gt;
 240  *
 241  * against the base URI
 242  *
 243  * &lt;blockquote&gt;
 244  * {@code http://example.com/languages/java/}
 245  * &lt;/blockquote&gt;
 246  *
 247  * yields the relative URI {@code sample/a/index.html#28}.
 248  *
 249  *
<span class="line-modified"> 250  * &lt;h4&gt; Character categories &lt;/h4&gt;</span>
 251  *
 252  * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
 253  * various components of a URI reference.  The following categories, most of
 254  * which are taken from that specification, are used below to describe these
 255  * constraints:
 256  *
 257  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 258  * &lt;caption style=&quot;display:none&quot;&gt;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&lt;/caption&gt;
 259  *   &lt;thead&gt;
 260  *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Category&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 261  *   &lt;/thead&gt;
 262  *   &lt;tbody style=&quot;text-align:left&quot;&gt;
 263  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alpha&lt;/th&gt;
 264  *       &lt;td&gt;The US-ASCII alphabetic characters,
 265  *        {@code &#39;A&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;Z&#39;}
 266  *        and {@code &#39;a&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;z&#39;}&lt;/td&gt;&lt;/tr&gt;
 267  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;digit&lt;/th&gt;
 268  *       &lt;td&gt;The US-ASCII decimal digit characters,
 269  *       {@code &#39;0&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;9&#39;}&lt;/td&gt;&lt;/tr&gt;
 270  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alphanum&lt;/th&gt;
</pre>
<hr />
<pre>
 281  *       &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
 282  *           character ({@code &#39;%&#39;}) followed by two hexadecimal digits
 283  *           ({@code &#39;0&#39;}-{@code &#39;9&#39;}, {@code &#39;A&#39;}-{@code &#39;F&#39;}, and
 284  *           {@code &#39;a&#39;}-{@code &#39;f&#39;})&lt;/td&gt;&lt;/tr&gt;
 285  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;other&lt;/th&gt;
 286  *       &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
 287  *           are not control characters (according to the {@link
 288  *           java.lang.Character#isISOControl(char) Character.isISOControl}
 289  *           method), and are not space characters (according to the {@link
 290  *           java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
 291  *           method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
 292  *           limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 293  * &lt;/tbody&gt;
 294  * &lt;/table&gt;
 295  *
 296  * &lt;p&gt;&lt;a id=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
 297  * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
 298  * characters.
 299  *
 300  *
<span class="line-modified"> 301  * &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;</span>
 302  *
 303  * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
 304  * fragment components.  Escaping serves two purposes in URIs:
 305  *
 306  * &lt;ul&gt;
 307  *
 308  *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
 309  *   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
 310  *   characters.  &lt;/p&gt;&lt;/li&gt;
 311  *
 312  *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
 313  *   component.  The user-info, path, query, and fragment components differ
 314  *   slightly in terms of which characters are considered legal and illegal.
 315  *   &lt;/p&gt;&lt;/li&gt;
 316  *
 317  * &lt;/ul&gt;
 318  *
 319  * These purposes are served in this class by three related operations:
 320  *
 321  * &lt;ul&gt;
</pre>
<hr />
<pre>
 373  *
 374  *   &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
 375  *   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
 376  *   getFragment}, {@link #getAuthority() getAuthority}, and {@link
 377  *   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
 378  *   octets in their corresponding components.  The strings returned by these
 379  *   methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
 380  *   and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
 381  *
 382  *   &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
 383  *   all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
 384  *   &lt;/p&gt;&lt;/li&gt;
 385  *
 386  *   &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
 387  *   quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
 388  *   characters.  &lt;/p&gt;&lt;/li&gt;
 389  *
 390  * &lt;/ul&gt;
 391  *
 392  *
<span class="line-modified"> 393  * &lt;h4&gt; Identities &lt;/h4&gt;</span>
 394  *
 395  * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
 396  *
 397  * &lt;blockquote&gt;
 398  * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
 399  * &lt;/blockquote&gt;
 400  *
 401  * For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
 402  * slashes before an empty authority (as in {@code file:///tmp/}&amp;nbsp;) or a
 403  * colon following a host name but no port (as in
 404  * {@code http://www.example.com:}&amp;nbsp;), and that does not encode characters
 405  * except those that must be quoted, the following identities also hold:
 406  * &lt;pre&gt;
 407  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 408  *             &lt;i&gt;u&lt;/i&gt;.getSchemeSpecificPart(),
 409  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 410  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 411  * in all cases,
 412  * &lt;pre&gt;
 413  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 414  *             &lt;i&gt;u&lt;/i&gt;.getAuthority(),
 415  *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 416  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 417  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 418  * if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
 419  * &lt;pre&gt;
 420  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 421  *             &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getHost(), &lt;i&gt;u&lt;/i&gt;.getPort(),
 422  *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 423  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 424  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 425  * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
 426  * authority.
 427  *
 428  *
<span class="line-modified"> 429  * &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;</span>
 430  *
 431  * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
 432  * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
 433  * not every URI is a URL.  This is because there is another subcategory of
 434  * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
 435  * specify how to locate them.  The {@code mailto}, {@code news}, and
 436  * {@code isbn} URIs shown above are examples of URNs.
 437  *
 438  * &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
 439  * differences between this class and the {@link URL} class.
 440  *
 441  * &lt;p&gt; An instance of this class represents a URI reference in the syntactic
 442  * sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
 443  * A URI string is parsed according to the generic syntax without regard to the
 444  * scheme, if any, that it specifies.  No lookup of the host, if any, is
 445  * performed, and no scheme-dependent stream handler is constructed.  Equality,
 446  * hashing, and comparison are defined strictly in terms of the character
 447  * content of the instance.  In other words, a URI instance is little more than
 448  * a structured string that supports the syntactic, scheme-independent
 449  * operations of comparison, normalization, resolution, and relativization.
</pre>
<hr />
<pre>
 486  * @since 1.4
 487  *
 488  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
 489  * transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 490  * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
 491  * Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 492  * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 493  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 494  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 495  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 496  * href=&quot;URISyntaxException.html&quot;&gt;URISyntaxException&lt;/a&gt;
 497  */
 498 
 499 public final class URI
 500     implements Comparable&lt;URI&gt;, Serializable
 501 {
 502 
 503     // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
 504     // throw of an InternalError should be replaced by an appropriate assertion
 505     // statement once asserts are enabled in the build.
<span class="line-modified"> 506 </span>
 507     static final long serialVersionUID = -6052424284110960213L;
 508 
 509 
 510     // -- Properties and components of this instance --
 511 
 512     // Components of all URIs: [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
 513     private transient String scheme;            // null ==&gt; relative URI
 514     private transient String fragment;
 515 
 516     // Hierarchical URI components: [//&lt;authority&gt;]&lt;path&gt;[?&lt;query&gt;]
 517     private transient String authority;         // Registry or server
 518 
 519     // Server-based authority: [&lt;userInfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
 520     private transient String userInfo;
 521     private transient String host;              // null ==&gt; registry-based
 522     private transient int port = -1;            // -1 ==&gt; undefined
 523 
 524     // Remaining components of hierarchical URIs
 525     private transient String path;              // null ==&gt; opaque
 526     private transient String query;
</pre>
<hr />
<pre>
1555                     h = hashIgnoringCase(h, host);
1556                     h += 1949 * port;
1557                 } else {
1558                     h = hash(h, authority);
1559                 }
1560             }
1561             if (h != 0) {
1562                 hash = h;
1563             }
1564         }
1565         return h;
1566     }
1567 
1568     /**
1569      * Compares this URI to another object, which must be a URI.
1570      *
1571      * &lt;p&gt; When comparing corresponding components of two URIs, if one
1572      * component is undefined but the other is defined then the first is
1573      * considered to be less than the second.  Unless otherwise noted, string
1574      * components are ordered according to their natural, case-sensitive
<span class="line-modified">1575      * ordering as defined by the {@link java.lang.String#compareTo(Object)</span>
1576      * String.compareTo} method.  String components that are subject to
1577      * encoding are compared by comparing their raw forms rather than their
<span class="line-modified">1578      * encoded forms.</span>

1579      *
1580      * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
1581      *
1582      * &lt;ul&gt;
1583      *
1584      *   &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the
1585      *   ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;
1586      *
1587      *   &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
1588      *   with an identical scheme. &lt;/p&gt;&lt;/li&gt;
1589      *
1590      *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according
1591      *   to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;
1592      *
1593      *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific
1594      *   parts are ordered according to the ordering of their
1595      *   fragments. &lt;/p&gt;&lt;/li&gt;
1596      *
1597      *   &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
1598      *   according to the ordering of their authority components: &lt;/p&gt;
</pre>
<hr />
<pre>
1760      *          charset
1761      */
1762     public String toASCIIString() {
1763         return encode(toString());
1764     }
1765 
1766 
1767     // -- Serialization support --
1768 
1769     /**
1770      * Saves the content of this URI to the given serial stream.
1771      *
1772      * &lt;p&gt; The only serializable field of a URI instance is its {@code string}
1773      * field.  That field is given a value, if it does not have one already,
1774      * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}
1775      * method of the given object-output stream is invoked. &lt;/p&gt;
1776      *
1777      * @param  os  The object-output stream to which this object
1778      *             is to be written
1779      */

1780     private void writeObject(ObjectOutputStream os)
1781         throws IOException
1782     {
1783         defineString();
1784         os.defaultWriteObject();        // Writes the string field only
1785     }
1786 
1787     /**
1788      * Reconstitutes a URI from the given serial stream.
1789      *
1790      * &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
1791      * invoked to read the value of the {@code string} field.  The result is
1792      * then parsed in the usual way.
1793      *
1794      * @param  is  The object-input stream from which this object
1795      *             is being read
1796      */

1797     private void readObject(ObjectInputStream is)
1798         throws ClassNotFoundException, IOException
1799     {
1800         port = -1;                      // Argh
1801         is.defaultReadObject();
1802         try {
1803             new Parser(string).parse(false);
1804         } catch (URISyntaxException x) {
1805             IOException y = new InvalidObjectException(&quot;Invalid URI&quot;);
1806             y.initCause(x);
1807             throw y;
1808         }
1809     }
1810 
1811 
1812     // -- End of public methods --
1813 
1814 
1815     // -- Utility methods for string-field comparison and hashing --
1816 
</pre>
<hr />
<pre>
1819     //
1820     // The case-ignoring methods should only be applied to strings whose
1821     // characters are all known to be US-ASCII.  Because of this restriction,
1822     // these methods are faster than the similar methods in the String class.
1823 
1824     // US-ASCII only
1825     private static int toLower(char c) {
1826         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
1827             return c + (&#39;a&#39; - &#39;A&#39;);
1828         return c;
1829     }
1830 
1831     // US-ASCII only
1832     private static int toUpper(char c) {
1833         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;))
1834             return c - (&#39;a&#39; - &#39;A&#39;);
1835         return c;
1836     }
1837 
1838     private static boolean equal(String s, String t) {
<span class="line-modified">1839         if (s == t) return true;</span>
<span class="line-modified">1840         if ((s != null) &amp;&amp; (t != null)) {</span>
<span class="line-modified">1841             if (s.length() != t.length())</span>
<span class="line-removed">1842                 return false;</span>
<span class="line-removed">1843             if (s.indexOf(&#39;%&#39;) &lt; 0)</span>
<span class="line-removed">1844                 return s.equals(t);</span>
<span class="line-removed">1845             int n = s.length();</span>
<span class="line-removed">1846             for (int i = 0; i &lt; n;) {</span>
<span class="line-removed">1847                 char c = s.charAt(i);</span>
<span class="line-removed">1848                 char d = t.charAt(i);</span>
<span class="line-removed">1849                 if (c != &#39;%&#39;) {</span>
<span class="line-removed">1850                     if (c != d)</span>
<span class="line-removed">1851                         return false;</span>
<span class="line-removed">1852                     i++;</span>
<span class="line-removed">1853                     continue;</span>
<span class="line-removed">1854                 }</span>
<span class="line-removed">1855                 if (d != &#39;%&#39;)</span>
<span class="line-removed">1856                     return false;</span>
<span class="line-removed">1857                 i++;</span>
<span class="line-removed">1858                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="line-removed">1859                     return false;</span>
<span class="line-removed">1860                 i++;</span>
<span class="line-removed">1861                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="line-removed">1862                     return false;</span>
<span class="line-removed">1863                 i++;</span>
<span class="line-removed">1864             }</span>
<span class="line-removed">1865             return true;</span>
<span class="line-removed">1866         }</span>
<span class="line-removed">1867         return false;</span>
1868     }
1869 
1870     // US-ASCII only
1871     private static boolean equalIgnoringCase(String s, String t) {
1872         if (s == t) return true;
1873         if ((s != null) &amp;&amp; (t != null)) {
1874             int n = s.length();
1875             if (t.length() != n)
1876                 return false;
1877             for (int i = 0; i &lt; n; i++) {
1878                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))
1879                     return false;
1880             }
1881             return true;
1882         }
1883         return false;
1884     }
1885 
1886     private static int hash(int hash, String s) {
1887         if (s == null) return hash;
</pre>
<hr />
<pre>
1901                  */
1902                 for (int i = index + 1; i &lt; index + 3; i++)
1903                     h = 31 * h + toUpper(s.charAt(i));
1904                 index += 2;
1905             }
1906         }
1907         return hash * 127 + h;
1908     }
1909 
1910     // US-ASCII only
1911     private static int hashIgnoringCase(int hash, String s) {
1912         if (s == null) return hash;
1913         int h = hash;
1914         int n = s.length();
1915         for (int i = 0; i &lt; n; i++)
1916             h = 31 * h + toLower(s.charAt(i));
1917         return h;
1918     }
1919 
1920     private static int compare(String s, String t) {

















1921         if (s == t) return 0;
1922         if (s != null) {
<span class="line-modified">1923             if (t != null)</span>
<span class="line-modified">1924                 return s.compareTo(t);</span>
<span class="line-modified">1925             else</span>

































1926                 return +1;
1927         } else {
1928             return -1;
1929         }
1930     }
1931 
1932     // US-ASCII only
1933     private static int compareIgnoringCase(String s, String t) {
1934         if (s == t) return 0;
1935         if (s != null) {
1936             if (t != null) {
1937                 int sn = s.length();
1938                 int tn = t.length();
1939                 int n = sn &lt; tn ? sn : tn;
1940                 for (int i = 0; i &lt; n; i++) {
1941                     int c = toLower(s.charAt(i)) - toLower(t.charAt(i));
1942                     if (c != 0)
1943                         return c;
1944                 }
1945                 return sn - tn;
</pre>
<hr />
<pre>
2720         = L_ALPHANUM | 0x400000000000L; // lowMask(&quot;_.&quot;);
2721     private static final long H_SCOPE_ID
2722         = H_ALPHANUM | 0x80000000L; // highMask(&quot;_.&quot;);
2723 
2724     // -- Escaping and encoding --
2725 
2726     private static final char[] hexDigits = {
2727         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
2728         &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
2729     };
2730 
2731     private static void appendEscape(StringBuilder sb, byte b) {
2732         sb.append(&#39;%&#39;);
2733         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
2734         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
2735     }
2736 
2737     private static void appendEncoded(StringBuilder sb, char c) {
2738         ByteBuffer bb = null;
2739         try {
<span class="line-modified">2740             bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
2741                 .encode(CharBuffer.wrap(&quot;&quot; + c));
2742         } catch (CharacterCodingException x) {
2743             assert false;
2744         }
2745         while (bb.hasRemaining()) {
2746             int b = bb.get() &amp; 0xff;
2747             if (b &gt;= 0x80)
2748                 appendEscape(sb, (byte)b);
2749             else
2750                 sb.append((char)b);
2751         }
2752     }
2753 
2754     // Quote any characters in s that are not permitted
2755     // by the given mask pair
2756     //
2757     private static String quote(String s, long lowMask, long highMask) {
2758         StringBuilder sb = null;
2759         boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);
2760         for (int i = 0; i &lt; s.length(); i++) {
</pre>
<hr />
<pre>
2788 
2789     // Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,
2790     // assuming that s is otherwise legal
2791     //
2792     private static String encode(String s) {
2793         int n = s.length();
2794         if (n == 0)
2795             return s;
2796 
2797         // First check whether we actually need to encode
2798         for (int i = 0;;) {
2799             if (s.charAt(i) &gt;= &#39;\u0080&#39;)
2800                 break;
2801             if (++i &gt;= n)
2802                 return s;
2803         }
2804 
2805         String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
2806         ByteBuffer bb = null;
2807         try {
<span class="line-modified">2808             bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
2809                 .encode(CharBuffer.wrap(ns));
2810         } catch (CharacterCodingException x) {
2811             assert false;
2812         }
2813 
2814         StringBuilder sb = new StringBuilder();
2815         while (bb.hasRemaining()) {
2816             int b = bb.get() &amp; 0xff;
2817             if (b &gt;= 0x80)
2818                 appendEscape(sb, (byte)b);
2819             else
2820                 sb.append((char)b);
2821         }
2822         return sb.toString();
2823     }
2824 
2825     private static int decode(char c) {
2826         if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
2827             return c - &#39;0&#39;;
2828         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
</pre>
<hr />
<pre>
2846     //            with a scope_id
2847     //
2848     private static String decode(String s) {
2849         return decode(s, true);
2850     }
2851 
2852     // This method was introduced as a generalization of URI.decode method
2853     // to provide a fix for JDK-8037396
2854     private static String decode(String s, boolean ignorePercentInBrackets) {
2855         if (s == null)
2856             return s;
2857         int n = s.length();
2858         if (n == 0)
2859             return s;
2860         if (s.indexOf(&#39;%&#39;) &lt; 0)
2861             return s;
2862 
2863         StringBuilder sb = new StringBuilder(n);
2864         ByteBuffer bb = ByteBuffer.allocate(n);
2865         CharBuffer cb = CharBuffer.allocate(n);
<span class="line-modified">2866         CharsetDecoder dec = ThreadLocalCoders.decoderFor(&quot;UTF-8&quot;)</span>
2867                 .onMalformedInput(CodingErrorAction.REPLACE)
2868                 .onUnmappableCharacter(CodingErrorAction.REPLACE);
2869 
2870         // This is not horribly efficient, but it will do for now
2871         char c = s.charAt(0);
2872         boolean betweenBrackets = false;
2873 
2874         for (int i = 0; i &lt; n;) {
2875             assert c == s.charAt(i);    // Loop invariant
2876             if (c == &#39;[&#39;) {
2877                 betweenBrackets = true;
2878             } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
2879                 betweenBrackets = false;
2880             }
2881             if (c != &#39;%&#39; || (betweenBrackets &amp;&amp; ignorePercentInBrackets)) {
2882                 sb.append(c);
2883                 if (++i &gt;= n)
2884                     break;
2885                 c = s.charAt(i);
2886                 continue;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  25 
  26 package java.net;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InvalidObjectException;
  31 import java.io.ObjectInputStream;
  32 import java.io.ObjectOutputStream;
  33 import java.io.Serializable;
  34 import java.nio.ByteBuffer;
  35 import java.nio.CharBuffer;
  36 import java.nio.charset.CharsetDecoder;
  37 import java.nio.charset.CoderResult;
  38 import java.nio.charset.CodingErrorAction;
  39 import java.nio.charset.CharacterCodingException;
  40 import java.nio.file.Path;
  41 import java.text.Normalizer;
  42 import jdk.internal.access.JavaNetUriAccess;
  43 import jdk.internal.access.SharedSecrets;
  44 import sun.nio.cs.ThreadLocalCoders;
<span class="line-added">  45 import sun.nio.cs.UTF_8;</span>
  46 
  47 import java.lang.Character;             // for javadoc
  48 import java.lang.NullPointerException;  // for javadoc
  49 

  50 /**
  51  * Represents a Uniform Resource Identifier (URI) reference.
  52  *
  53  * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
  54  * class represents a URI reference as defined by
  55  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
  56  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
  57  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
  58  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
  59  * also supports scope_ids. The syntax and usage of scope_ids is described
  60  * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
  61  * This class provides constructors for creating URI instances from
  62  * their components or by parsing their string forms, methods for accessing the
  63  * various components of an instance, and methods for normalizing, resolving,
  64  * and relativizing URI instances.  Instances of this class are immutable.
  65  *
  66  *
<span class="line-modified">  67  * &lt;h2&gt; URI syntax and components &lt;/h2&gt;</span>
  68  *
  69  * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
  70  * form has the syntax
  71  *
  72  * &lt;blockquote&gt;
  73  * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
  74  * &lt;/blockquote&gt;
  75  *
  76  * where square brackets [...] delineate optional components and the characters
  77  * &lt;b&gt;{@code :}&lt;/b&gt; and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.
  78  *
  79  * &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
  80  * said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
  81  * they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
  82  *
  83  * &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
  84  * not begin with a slash character ({@code &#39;/&#39;}).  Opaque URIs are not
  85  * subject to further parsing.  Some examples of opaque URIs are:
  86  *
  87  * &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
</pre>
<hr />
<pre>
 151  * &lt;/tbody&gt;
 152  * &lt;/table&gt;
 153  *
 154  * In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
 155  * &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
 156  * represented by {@code null}, while undefined integer components are
 157  * represented by {@code -1}.  A string component may be defined to have the
 158  * empty string as its value; this is not equivalent to that component being
 159  * undefined.
 160  *
 161  * &lt;p&gt; Whether a particular component is or is not defined in an instance
 162  * depends upon the type of the URI being represented.  An absolute URI has a
 163  * scheme component.  An opaque URI has a scheme, a scheme-specific part, and
 164  * possibly a fragment, but has no other components.  A hierarchical URI always
 165  * has a path (though it may be empty) and a scheme-specific-part (which at
 166  * least contains the path), and may have any of the other components.  If the
 167  * authority component is present and is server-based then the host component
 168  * will be defined and the user-information and port components may be defined.
 169  *
 170  *
<span class="line-modified"> 171  * &lt;h3&gt; Operations on URI instances &lt;/h3&gt;</span>
 172  *
 173  * The key operations supported by this class are those of
 174  * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
 175  *
 176  * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
 177  * and {@code &quot;..&quot;} segments from the path component of a hierarchical URI.
 178  * Each {@code &quot;.&quot;} segment is simply removed.  A {@code &quot;..&quot;} segment is
 179  * removed only if it is preceded by a non-{@code &quot;..&quot;} segment.
 180  * Normalization has no effect upon opaque URIs.
 181  *
 182  * &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
 183  * &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
 184  * URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
 185  * base URI for those not specified in the original.  For hierarchical URIs,
 186  * the path of the original is resolved against the path of the base and then
 187  * normalized.  The result, for example, of resolving
 188  *
 189  * &lt;blockquote&gt;
 190  * {@code sample/a/index.html#28}
 191  * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
</pre>
<hr />
<pre>
 230  *   &lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;.&lt;br&gt;
 231  * &lt;/blockquote&gt;
 232  *
 233  * This operation is often useful when constructing a document containing URIs
 234  * that must be made relative to the base URI of the document wherever
 235  * possible.  For example, relativizing the URI
 236  *
 237  * &lt;blockquote&gt;
 238  * {@code http://example.com/languages/java/sample/a/index.html#28}
 239  * &lt;/blockquote&gt;
 240  *
 241  * against the base URI
 242  *
 243  * &lt;blockquote&gt;
 244  * {@code http://example.com/languages/java/}
 245  * &lt;/blockquote&gt;
 246  *
 247  * yields the relative URI {@code sample/a/index.html#28}.
 248  *
 249  *
<span class="line-modified"> 250  * &lt;h3&gt; Character categories &lt;/h3&gt;</span>
 251  *
 252  * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
 253  * various components of a URI reference.  The following categories, most of
 254  * which are taken from that specification, are used below to describe these
 255  * constraints:
 256  *
 257  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 258  * &lt;caption style=&quot;display:none&quot;&gt;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&lt;/caption&gt;
 259  *   &lt;thead&gt;
 260  *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Category&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 261  *   &lt;/thead&gt;
 262  *   &lt;tbody style=&quot;text-align:left&quot;&gt;
 263  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alpha&lt;/th&gt;
 264  *       &lt;td&gt;The US-ASCII alphabetic characters,
 265  *        {@code &#39;A&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;Z&#39;}
 266  *        and {@code &#39;a&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;z&#39;}&lt;/td&gt;&lt;/tr&gt;
 267  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;digit&lt;/th&gt;
 268  *       &lt;td&gt;The US-ASCII decimal digit characters,
 269  *       {@code &#39;0&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;9&#39;}&lt;/td&gt;&lt;/tr&gt;
 270  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alphanum&lt;/th&gt;
</pre>
<hr />
<pre>
 281  *       &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
 282  *           character ({@code &#39;%&#39;}) followed by two hexadecimal digits
 283  *           ({@code &#39;0&#39;}-{@code &#39;9&#39;}, {@code &#39;A&#39;}-{@code &#39;F&#39;}, and
 284  *           {@code &#39;a&#39;}-{@code &#39;f&#39;})&lt;/td&gt;&lt;/tr&gt;
 285  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;other&lt;/th&gt;
 286  *       &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
 287  *           are not control characters (according to the {@link
 288  *           java.lang.Character#isISOControl(char) Character.isISOControl}
 289  *           method), and are not space characters (according to the {@link
 290  *           java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
 291  *           method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
 292  *           limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 293  * &lt;/tbody&gt;
 294  * &lt;/table&gt;
 295  *
 296  * &lt;p&gt;&lt;a id=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
 297  * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
 298  * characters.
 299  *
 300  *
<span class="line-modified"> 301  * &lt;h3&gt; Escaped octets, quotation, encoding, and decoding &lt;/h3&gt;</span>
 302  *
 303  * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
 304  * fragment components.  Escaping serves two purposes in URIs:
 305  *
 306  * &lt;ul&gt;
 307  *
 308  *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
 309  *   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
 310  *   characters.  &lt;/p&gt;&lt;/li&gt;
 311  *
 312  *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
 313  *   component.  The user-info, path, query, and fragment components differ
 314  *   slightly in terms of which characters are considered legal and illegal.
 315  *   &lt;/p&gt;&lt;/li&gt;
 316  *
 317  * &lt;/ul&gt;
 318  *
 319  * These purposes are served in this class by three related operations:
 320  *
 321  * &lt;ul&gt;
</pre>
<hr />
<pre>
 373  *
 374  *   &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
 375  *   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
 376  *   getFragment}, {@link #getAuthority() getAuthority}, and {@link
 377  *   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
 378  *   octets in their corresponding components.  The strings returned by these
 379  *   methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
 380  *   and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
 381  *
 382  *   &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
 383  *   all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
 384  *   &lt;/p&gt;&lt;/li&gt;
 385  *
 386  *   &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
 387  *   quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
 388  *   characters.  &lt;/p&gt;&lt;/li&gt;
 389  *
 390  * &lt;/ul&gt;
 391  *
 392  *
<span class="line-modified"> 393  * &lt;h3&gt; Identities &lt;/h3&gt;</span>
 394  *
 395  * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
 396  *
 397  * &lt;blockquote&gt;
 398  * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
 399  * &lt;/blockquote&gt;
 400  *
 401  * For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
 402  * slashes before an empty authority (as in {@code file:///tmp/}&amp;nbsp;) or a
 403  * colon following a host name but no port (as in
 404  * {@code http://www.example.com:}&amp;nbsp;), and that does not encode characters
 405  * except those that must be quoted, the following identities also hold:
 406  * &lt;pre&gt;
 407  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 408  *             &lt;i&gt;u&lt;/i&gt;.getSchemeSpecificPart(),
 409  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 410  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 411  * in all cases,
 412  * &lt;pre&gt;
 413  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 414  *             &lt;i&gt;u&lt;/i&gt;.getAuthority(),
 415  *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 416  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 417  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 418  * if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
 419  * &lt;pre&gt;
 420  *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
 421  *             &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getHost(), &lt;i&gt;u&lt;/i&gt;.getPort(),
 422  *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
 423  *             &lt;i&gt;u&lt;/i&gt;.getFragment())
 424  *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
 425  * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
 426  * authority.
 427  *
 428  *
<span class="line-modified"> 429  * &lt;h3&gt; URIs, URLs, and URNs &lt;/h3&gt;</span>
 430  *
 431  * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
 432  * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
 433  * not every URI is a URL.  This is because there is another subcategory of
 434  * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
 435  * specify how to locate them.  The {@code mailto}, {@code news}, and
 436  * {@code isbn} URIs shown above are examples of URNs.
 437  *
 438  * &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
 439  * differences between this class and the {@link URL} class.
 440  *
 441  * &lt;p&gt; An instance of this class represents a URI reference in the syntactic
 442  * sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
 443  * A URI string is parsed according to the generic syntax without regard to the
 444  * scheme, if any, that it specifies.  No lookup of the host, if any, is
 445  * performed, and no scheme-dependent stream handler is constructed.  Equality,
 446  * hashing, and comparison are defined strictly in terms of the character
 447  * content of the instance.  In other words, a URI instance is little more than
 448  * a structured string that supports the syntactic, scheme-independent
 449  * operations of comparison, normalization, resolution, and relativization.
</pre>
<hr />
<pre>
 486  * @since 1.4
 487  *
 488  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
 489  * transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 490  * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
 491  * Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 492  * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 493  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 494  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 495  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 496  * href=&quot;URISyntaxException.html&quot;&gt;URISyntaxException&lt;/a&gt;
 497  */
 498 
 499 public final class URI
 500     implements Comparable&lt;URI&gt;, Serializable
 501 {
 502 
 503     // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
 504     // throw of an InternalError should be replaced by an appropriate assertion
 505     // statement once asserts are enabled in the build.
<span class="line-modified"> 506     @java.io.Serial</span>
 507     static final long serialVersionUID = -6052424284110960213L;
 508 
 509 
 510     // -- Properties and components of this instance --
 511 
 512     // Components of all URIs: [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
 513     private transient String scheme;            // null ==&gt; relative URI
 514     private transient String fragment;
 515 
 516     // Hierarchical URI components: [//&lt;authority&gt;]&lt;path&gt;[?&lt;query&gt;]
 517     private transient String authority;         // Registry or server
 518 
 519     // Server-based authority: [&lt;userInfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
 520     private transient String userInfo;
 521     private transient String host;              // null ==&gt; registry-based
 522     private transient int port = -1;            // -1 ==&gt; undefined
 523 
 524     // Remaining components of hierarchical URIs
 525     private transient String path;              // null ==&gt; opaque
 526     private transient String query;
</pre>
<hr />
<pre>
1555                     h = hashIgnoringCase(h, host);
1556                     h += 1949 * port;
1557                 } else {
1558                     h = hash(h, authority);
1559                 }
1560             }
1561             if (h != 0) {
1562                 hash = h;
1563             }
1564         }
1565         return h;
1566     }
1567 
1568     /**
1569      * Compares this URI to another object, which must be a URI.
1570      *
1571      * &lt;p&gt; When comparing corresponding components of two URIs, if one
1572      * component is undefined but the other is defined then the first is
1573      * considered to be less than the second.  Unless otherwise noted, string
1574      * components are ordered according to their natural, case-sensitive
<span class="line-modified">1575      * ordering as defined by the {@link java.lang.String#compareTo(String)</span>
1576      * String.compareTo} method.  String components that are subject to
1577      * encoding are compared by comparing their raw forms rather than their
<span class="line-modified">1578      * encoded forms and the hexadecimal digits of escaped octets are compared</span>
<span class="line-added">1579      * without regard to case.</span>
1580      *
1581      * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
1582      *
1583      * &lt;ul&gt;
1584      *
1585      *   &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the
1586      *   ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;
1587      *
1588      *   &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
1589      *   with an identical scheme. &lt;/p&gt;&lt;/li&gt;
1590      *
1591      *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according
1592      *   to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;
1593      *
1594      *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific
1595      *   parts are ordered according to the ordering of their
1596      *   fragments. &lt;/p&gt;&lt;/li&gt;
1597      *
1598      *   &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
1599      *   according to the ordering of their authority components: &lt;/p&gt;
</pre>
<hr />
<pre>
1761      *          charset
1762      */
1763     public String toASCIIString() {
1764         return encode(toString());
1765     }
1766 
1767 
1768     // -- Serialization support --
1769 
1770     /**
1771      * Saves the content of this URI to the given serial stream.
1772      *
1773      * &lt;p&gt; The only serializable field of a URI instance is its {@code string}
1774      * field.  That field is given a value, if it does not have one already,
1775      * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}
1776      * method of the given object-output stream is invoked. &lt;/p&gt;
1777      *
1778      * @param  os  The object-output stream to which this object
1779      *             is to be written
1780      */
<span class="line-added">1781     @java.io.Serial</span>
1782     private void writeObject(ObjectOutputStream os)
1783         throws IOException
1784     {
1785         defineString();
1786         os.defaultWriteObject();        // Writes the string field only
1787     }
1788 
1789     /**
1790      * Reconstitutes a URI from the given serial stream.
1791      *
1792      * &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
1793      * invoked to read the value of the {@code string} field.  The result is
1794      * then parsed in the usual way.
1795      *
1796      * @param  is  The object-input stream from which this object
1797      *             is being read
1798      */
<span class="line-added">1799     @java.io.Serial</span>
1800     private void readObject(ObjectInputStream is)
1801         throws ClassNotFoundException, IOException
1802     {
1803         port = -1;                      // Argh
1804         is.defaultReadObject();
1805         try {
1806             new Parser(string).parse(false);
1807         } catch (URISyntaxException x) {
1808             IOException y = new InvalidObjectException(&quot;Invalid URI&quot;);
1809             y.initCause(x);
1810             throw y;
1811         }
1812     }
1813 
1814 
1815     // -- End of public methods --
1816 
1817 
1818     // -- Utility methods for string-field comparison and hashing --
1819 
</pre>
<hr />
<pre>
1822     //
1823     // The case-ignoring methods should only be applied to strings whose
1824     // characters are all known to be US-ASCII.  Because of this restriction,
1825     // these methods are faster than the similar methods in the String class.
1826 
1827     // US-ASCII only
1828     private static int toLower(char c) {
1829         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
1830             return c + (&#39;a&#39; - &#39;A&#39;);
1831         return c;
1832     }
1833 
1834     // US-ASCII only
1835     private static int toUpper(char c) {
1836         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;))
1837             return c - (&#39;a&#39; - &#39;A&#39;);
1838         return c;
1839     }
1840 
1841     private static boolean equal(String s, String t) {
<span class="line-modified">1842         boolean testForEquality = true;</span>
<span class="line-modified">1843         int result = percentNormalizedComparison(s, t, testForEquality);</span>
<span class="line-modified">1844         return result == 0;</span>


























1845     }
1846 
1847     // US-ASCII only
1848     private static boolean equalIgnoringCase(String s, String t) {
1849         if (s == t) return true;
1850         if ((s != null) &amp;&amp; (t != null)) {
1851             int n = s.length();
1852             if (t.length() != n)
1853                 return false;
1854             for (int i = 0; i &lt; n; i++) {
1855                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))
1856                     return false;
1857             }
1858             return true;
1859         }
1860         return false;
1861     }
1862 
1863     private static int hash(int hash, String s) {
1864         if (s == null) return hash;
</pre>
<hr />
<pre>
1878                  */
1879                 for (int i = index + 1; i &lt; index + 3; i++)
1880                     h = 31 * h + toUpper(s.charAt(i));
1881                 index += 2;
1882             }
1883         }
1884         return hash * 127 + h;
1885     }
1886 
1887     // US-ASCII only
1888     private static int hashIgnoringCase(int hash, String s) {
1889         if (s == null) return hash;
1890         int h = hash;
1891         int n = s.length();
1892         for (int i = 0; i &lt; n; i++)
1893             h = 31 * h + toLower(s.charAt(i));
1894         return h;
1895     }
1896 
1897     private static int compare(String s, String t) {
<span class="line-added">1898         boolean testForEquality = false;</span>
<span class="line-added">1899         int result = percentNormalizedComparison(s, t, testForEquality);</span>
<span class="line-added">1900         return result;</span>
<span class="line-added">1901     }</span>
<span class="line-added">1902 </span>
<span class="line-added">1903     // The percentNormalizedComparison method does not verify two</span>
<span class="line-added">1904     // characters that follow the % sign are hexadecimal digits.</span>
<span class="line-added">1905     // Reason being:</span>
<span class="line-added">1906     // 1) percentNormalizedComparison method is not called with</span>
<span class="line-added">1907     // &#39;decoded&#39; strings</span>
<span class="line-added">1908     // 2) The only place where a percent can be followed by anything</span>
<span class="line-added">1909     // other than hexadecimal digits is in the authority component</span>
<span class="line-added">1910     // (for a IPv6 scope) and the whole authority component is case</span>
<span class="line-added">1911     // insensitive.</span>
<span class="line-added">1912     private static int percentNormalizedComparison(String s, String t,</span>
<span class="line-added">1913                                                    boolean testForEquality) {</span>
<span class="line-added">1914 </span>
1915         if (s == t) return 0;
1916         if (s != null) {
<span class="line-modified">1917             if (t != null) {</span>
<span class="line-modified">1918                 if (s.indexOf(&#39;%&#39;) &lt; 0) {</span>
<span class="line-modified">1919                     return s.compareTo(t);</span>
<span class="line-added">1920                 }</span>
<span class="line-added">1921                 int sn = s.length();</span>
<span class="line-added">1922                 int tn = t.length();</span>
<span class="line-added">1923                 if ((sn != tn) &amp;&amp; testForEquality)</span>
<span class="line-added">1924                     return sn - tn;</span>
<span class="line-added">1925                 int val = 0;</span>
<span class="line-added">1926                 int n = sn &lt; tn ? sn : tn;</span>
<span class="line-added">1927                 for (int i = 0; i &lt; n; ) {</span>
<span class="line-added">1928                     char c = s.charAt(i);</span>
<span class="line-added">1929                     char d = t.charAt(i);</span>
<span class="line-added">1930                     val = c - d;</span>
<span class="line-added">1931                     if (c != &#39;%&#39;) {</span>
<span class="line-added">1932                         if (val != 0)</span>
<span class="line-added">1933                             return val;</span>
<span class="line-added">1934                         i++;</span>
<span class="line-added">1935                         continue;</span>
<span class="line-added">1936                     }</span>
<span class="line-added">1937                     if (d != &#39;%&#39;) {</span>
<span class="line-added">1938                         if (val != 0)</span>
<span class="line-added">1939                             return val;</span>
<span class="line-added">1940                     }</span>
<span class="line-added">1941                     i++;</span>
<span class="line-added">1942                     val = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="line-added">1943                     if (val != 0)</span>
<span class="line-added">1944                         return val;</span>
<span class="line-added">1945                     i++;</span>
<span class="line-added">1946                     val = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="line-added">1947                     if (val != 0)</span>
<span class="line-added">1948                         return val;</span>
<span class="line-added">1949                     i++;</span>
<span class="line-added">1950                 }</span>
<span class="line-added">1951                 return sn - tn;</span>
<span class="line-added">1952             } else</span>
1953                 return +1;
1954         } else {
1955             return -1;
1956         }
1957     }
1958 
1959     // US-ASCII only
1960     private static int compareIgnoringCase(String s, String t) {
1961         if (s == t) return 0;
1962         if (s != null) {
1963             if (t != null) {
1964                 int sn = s.length();
1965                 int tn = t.length();
1966                 int n = sn &lt; tn ? sn : tn;
1967                 for (int i = 0; i &lt; n; i++) {
1968                     int c = toLower(s.charAt(i)) - toLower(t.charAt(i));
1969                     if (c != 0)
1970                         return c;
1971                 }
1972                 return sn - tn;
</pre>
<hr />
<pre>
2747         = L_ALPHANUM | 0x400000000000L; // lowMask(&quot;_.&quot;);
2748     private static final long H_SCOPE_ID
2749         = H_ALPHANUM | 0x80000000L; // highMask(&quot;_.&quot;);
2750 
2751     // -- Escaping and encoding --
2752 
2753     private static final char[] hexDigits = {
2754         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
2755         &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
2756     };
2757 
2758     private static void appendEscape(StringBuilder sb, byte b) {
2759         sb.append(&#39;%&#39;);
2760         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
2761         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
2762     }
2763 
2764     private static void appendEncoded(StringBuilder sb, char c) {
2765         ByteBuffer bb = null;
2766         try {
<span class="line-modified">2767             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
2768                 .encode(CharBuffer.wrap(&quot;&quot; + c));
2769         } catch (CharacterCodingException x) {
2770             assert false;
2771         }
2772         while (bb.hasRemaining()) {
2773             int b = bb.get() &amp; 0xff;
2774             if (b &gt;= 0x80)
2775                 appendEscape(sb, (byte)b);
2776             else
2777                 sb.append((char)b);
2778         }
2779     }
2780 
2781     // Quote any characters in s that are not permitted
2782     // by the given mask pair
2783     //
2784     private static String quote(String s, long lowMask, long highMask) {
2785         StringBuilder sb = null;
2786         boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);
2787         for (int i = 0; i &lt; s.length(); i++) {
</pre>
<hr />
<pre>
2815 
2816     // Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,
2817     // assuming that s is otherwise legal
2818     //
2819     private static String encode(String s) {
2820         int n = s.length();
2821         if (n == 0)
2822             return s;
2823 
2824         // First check whether we actually need to encode
2825         for (int i = 0;;) {
2826             if (s.charAt(i) &gt;= &#39;\u0080&#39;)
2827                 break;
2828             if (++i &gt;= n)
2829                 return s;
2830         }
2831 
2832         String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
2833         ByteBuffer bb = null;
2834         try {
<span class="line-modified">2835             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
2836                 .encode(CharBuffer.wrap(ns));
2837         } catch (CharacterCodingException x) {
2838             assert false;
2839         }
2840 
2841         StringBuilder sb = new StringBuilder();
2842         while (bb.hasRemaining()) {
2843             int b = bb.get() &amp; 0xff;
2844             if (b &gt;= 0x80)
2845                 appendEscape(sb, (byte)b);
2846             else
2847                 sb.append((char)b);
2848         }
2849         return sb.toString();
2850     }
2851 
2852     private static int decode(char c) {
2853         if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
2854             return c - &#39;0&#39;;
2855         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
</pre>
<hr />
<pre>
2873     //            with a scope_id
2874     //
2875     private static String decode(String s) {
2876         return decode(s, true);
2877     }
2878 
2879     // This method was introduced as a generalization of URI.decode method
2880     // to provide a fix for JDK-8037396
2881     private static String decode(String s, boolean ignorePercentInBrackets) {
2882         if (s == null)
2883             return s;
2884         int n = s.length();
2885         if (n == 0)
2886             return s;
2887         if (s.indexOf(&#39;%&#39;) &lt; 0)
2888             return s;
2889 
2890         StringBuilder sb = new StringBuilder(n);
2891         ByteBuffer bb = ByteBuffer.allocate(n);
2892         CharBuffer cb = CharBuffer.allocate(n);
<span class="line-modified">2893         CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)</span>
2894                 .onMalformedInput(CodingErrorAction.REPLACE)
2895                 .onUnmappableCharacter(CodingErrorAction.REPLACE);
2896 
2897         // This is not horribly efficient, but it will do for now
2898         char c = s.charAt(0);
2899         boolean betweenBrackets = false;
2900 
2901         for (int i = 0; i &lt; n;) {
2902             assert c == s.charAt(i);    // Loop invariant
2903             if (c == &#39;[&#39;) {
2904                 betweenBrackets = true;
2905             } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
2906                 betweenBrackets = false;
2907             }
2908             if (c != &#39;%&#39; || (betweenBrackets &amp;&amp; ignorePercentInBrackets)) {
2909                 sb.append(c);
2910                 if (++i &gt;= n)
2911                     break;
2912                 c = s.charAt(i);
2913                 continue;
</pre>
</td>
</tr>
</table>
<center><a href="StandardSocketOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URISyntaxException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
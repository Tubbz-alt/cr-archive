<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/URI.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StandardSocketOptions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URISyntaxException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/URI.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,15 ***</span>
  import java.nio.file.Path;
  import java.text.Normalizer;
  import jdk.internal.access.JavaNetUriAccess;
  import jdk.internal.access.SharedSecrets;
  import sun.nio.cs.ThreadLocalCoders;
  
  import java.lang.Character;             // for javadoc
  import java.lang.NullPointerException;  // for javadoc
  
<span class="line-removed">- </span>
  /**
   * Represents a Uniform Resource Identifier (URI) reference.
   *
   * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
   * class represents a URI reference as defined by
<span class="line-new-header">--- 40,15 ---</span>
  import java.nio.file.Path;
  import java.text.Normalizer;
  import jdk.internal.access.JavaNetUriAccess;
  import jdk.internal.access.SharedSecrets;
  import sun.nio.cs.ThreadLocalCoders;
<span class="line-added">+ import sun.nio.cs.UTF_8;</span>
  
  import java.lang.Character;             // for javadoc
  import java.lang.NullPointerException;  // for javadoc
  
  /**
   * Represents a Uniform Resource Identifier (URI) reference.
   *
   * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
   * class represents a URI reference as defined by
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
   * their components or by parsing their string forms, methods for accessing the
   * various components of an instance, and methods for normalizing, resolving,
   * and relativizing URI instances.  Instances of this class are immutable.
   *
   *
<span class="line-modified">!  * &lt;h3&gt; URI syntax and components &lt;/h3&gt;</span>
   *
   * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
   * form has the syntax
   *
   * &lt;blockquote&gt;
<span class="line-new-header">--- 62,11 ---</span>
   * their components or by parsing their string forms, methods for accessing the
   * various components of an instance, and methods for normalizing, resolving,
   * and relativizing URI instances.  Instances of this class are immutable.
   *
   *
<span class="line-modified">!  * &lt;h2&gt; URI syntax and components &lt;/h2&gt;</span>
   *
   * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
   * form has the syntax
   *
   * &lt;blockquote&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,11 ***</span>
   * least contains the path), and may have any of the other components.  If the
   * authority component is present and is server-based then the host component
   * will be defined and the user-information and port components may be defined.
   *
   *
<span class="line-modified">!  * &lt;h4&gt; Operations on URI instances &lt;/h4&gt;</span>
   *
   * The key operations supported by this class are those of
   * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
   *
   * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
<span class="line-new-header">--- 166,11 ---</span>
   * least contains the path), and may have any of the other components.  If the
   * authority component is present and is server-based then the host component
   * will be defined and the user-information and port components may be defined.
   *
   *
<span class="line-modified">!  * &lt;h3&gt; Operations on URI instances &lt;/h3&gt;</span>
   *
   * The key operations supported by this class are those of
   * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
   *
   * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,11 ***</span>
   * &lt;/blockquote&gt;
   *
   * yields the relative URI {@code sample/a/index.html#28}.
   *
   *
<span class="line-modified">!  * &lt;h4&gt; Character categories &lt;/h4&gt;</span>
   *
   * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
   * various components of a URI reference.  The following categories, most of
   * which are taken from that specification, are used below to describe these
   * constraints:
<span class="line-new-header">--- 245,11 ---</span>
   * &lt;/blockquote&gt;
   *
   * yields the relative URI {@code sample/a/index.html#28}.
   *
   *
<span class="line-modified">!  * &lt;h3&gt; Character categories &lt;/h3&gt;</span>
   *
   * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
   * various components of a URI reference.  The following categories, most of
   * which are taken from that specification, are used below to describe these
   * constraints:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,11 ***</span>
   * &lt;p&gt;&lt;a id=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
   * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
   * characters.
   *
   *
<span class="line-modified">!  * &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;</span>
   *
   * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
   * fragment components.  Escaping serves two purposes in URIs:
   *
   * &lt;ul&gt;
<span class="line-new-header">--- 296,11 ---</span>
   * &lt;p&gt;&lt;a id=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
   * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
   * characters.
   *
   *
<span class="line-modified">!  * &lt;h3&gt; Escaped octets, quotation, encoding, and decoding &lt;/h3&gt;</span>
   *
   * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
   * fragment components.  Escaping serves two purposes in URIs:
   *
   * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
   *   characters.  &lt;/p&gt;&lt;/li&gt;
   *
   * &lt;/ul&gt;
   *
   *
<span class="line-modified">!  * &lt;h4&gt; Identities &lt;/h4&gt;</span>
   *
   * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
   *
   * &lt;blockquote&gt;
   * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
<span class="line-new-header">--- 388,11 ---</span>
   *   characters.  &lt;/p&gt;&lt;/li&gt;
   *
   * &lt;/ul&gt;
   *
   *
<span class="line-modified">!  * &lt;h3&gt; Identities &lt;/h3&gt;</span>
   *
   * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
   *
   * &lt;blockquote&gt;
   * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,11 ***</span>
   *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
   * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
   * authority.
   *
   *
<span class="line-modified">!  * &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;</span>
   *
   * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
   * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
   * not every URI is a URL.  This is because there is another subcategory of
   * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
<span class="line-new-header">--- 424,11 ---</span>
   *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
   * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
   * authority.
   *
   *
<span class="line-modified">!  * &lt;h3&gt; URIs, URLs, and URNs &lt;/h3&gt;</span>
   *
   * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
   * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
   * not every URI is a URL.  This is because there is another subcategory of
   * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,11 ***</span>
  {
  
      // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
      // throw of an InternalError should be replaced by an appropriate assertion
      // statement once asserts are enabled in the build.
<span class="line-modified">! </span>
      static final long serialVersionUID = -6052424284110960213L;
  
  
      // -- Properties and components of this instance --
  
<span class="line-new-header">--- 501,11 ---</span>
  {
  
      // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
      // throw of an InternalError should be replaced by an appropriate assertion
      // statement once asserts are enabled in the build.
<span class="line-modified">!     @java.io.Serial</span>
      static final long serialVersionUID = -6052424284110960213L;
  
  
      // -- Properties and components of this instance --
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1570,14 ***</span>
       *
       * &lt;p&gt; When comparing corresponding components of two URIs, if one
       * component is undefined but the other is defined then the first is
       * considered to be less than the second.  Unless otherwise noted, string
       * components are ordered according to their natural, case-sensitive
<span class="line-modified">!      * ordering as defined by the {@link java.lang.String#compareTo(Object)</span>
       * String.compareTo} method.  String components that are subject to
       * encoding are compared by comparing their raw forms rather than their
<span class="line-modified">!      * encoded forms.</span>
       *
       * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
       *
       * &lt;ul&gt;
       *
<span class="line-new-header">--- 1570,15 ---</span>
       *
       * &lt;p&gt; When comparing corresponding components of two URIs, if one
       * component is undefined but the other is defined then the first is
       * considered to be less than the second.  Unless otherwise noted, string
       * components are ordered according to their natural, case-sensitive
<span class="line-modified">!      * ordering as defined by the {@link java.lang.String#compareTo(String)</span>
       * String.compareTo} method.  String components that are subject to
       * encoding are compared by comparing their raw forms rather than their
<span class="line-modified">!      * encoded forms and the hexadecimal digits of escaped octets are compared</span>
<span class="line-added">+      * without regard to case.</span>
       *
       * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
       *
       * &lt;ul&gt;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1775,10 ***</span>
<span class="line-new-header">--- 1776,11 ---</span>
       * method of the given object-output stream is invoked. &lt;/p&gt;
       *
       * @param  os  The object-output stream to which this object
       *             is to be written
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream os)
          throws IOException
      {
          defineString();
          os.defaultWriteObject();        // Writes the string field only
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1792,10 ***</span>
<span class="line-new-header">--- 1794,11 ---</span>
       * then parsed in the usual way.
       *
       * @param  is  The object-input stream from which this object
       *             is being read
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream is)
          throws ClassNotFoundException, IOException
      {
          port = -1;                      // Argh
          is.defaultReadObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1834,39 ***</span>
              return c - (&#39;a&#39; - &#39;A&#39;);
          return c;
      }
  
      private static boolean equal(String s, String t) {
<span class="line-modified">!         if (s == t) return true;</span>
<span class="line-modified">!         if ((s != null) &amp;&amp; (t != null)) {</span>
<span class="line-modified">!             if (s.length() != t.length())</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             if (s.indexOf(&#39;%&#39;) &lt; 0)</span>
<span class="line-removed">-                 return s.equals(t);</span>
<span class="line-removed">-             int n = s.length();</span>
<span class="line-removed">-             for (int i = 0; i &lt; n;) {</span>
<span class="line-removed">-                 char c = s.charAt(i);</span>
<span class="line-removed">-                 char d = t.charAt(i);</span>
<span class="line-removed">-                 if (c != &#39;%&#39;) {</span>
<span class="line-removed">-                     if (c != d)</span>
<span class="line-removed">-                         return false;</span>
<span class="line-removed">-                     i++;</span>
<span class="line-removed">-                     continue;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (d != &#39;%&#39;)</span>
<span class="line-removed">-                     return false;</span>
<span class="line-removed">-                 i++;</span>
<span class="line-removed">-                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="line-removed">-                     return false;</span>
<span class="line-removed">-                 i++;</span>
<span class="line-removed">-                 if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</span>
<span class="line-removed">-                     return false;</span>
<span class="line-removed">-                 i++;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return false;</span>
      }
  
      // US-ASCII only
      private static boolean equalIgnoringCase(String s, String t) {
          if (s == t) return true;
<span class="line-new-header">--- 1837,13 ---</span>
              return c - (&#39;a&#39; - &#39;A&#39;);
          return c;
      }
  
      private static boolean equal(String s, String t) {
<span class="line-modified">!         boolean testForEquality = true;</span>
<span class="line-modified">!         int result = percentNormalizedComparison(s, t, testForEquality);</span>
<span class="line-modified">!         return result == 0;</span>
      }
  
      // US-ASCII only
      private static boolean equalIgnoringCase(String s, String t) {
          if (s == t) return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1916,15 ***</span>
              h = 31 * h + toLower(s.charAt(i));
          return h;
      }
  
      private static int compare(String s, String t) {
          if (s == t) return 0;
          if (s != null) {
<span class="line-modified">!             if (t != null)</span>
<span class="line-modified">!                 return s.compareTo(t);</span>
<span class="line-modified">!             else</span>
                  return +1;
          } else {
              return -1;
          }
      }
<span class="line-new-header">--- 1893,65 ---</span>
              h = 31 * h + toLower(s.charAt(i));
          return h;
      }
  
      private static int compare(String s, String t) {
<span class="line-added">+         boolean testForEquality = false;</span>
<span class="line-added">+         int result = percentNormalizedComparison(s, t, testForEquality);</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The percentNormalizedComparison method does not verify two</span>
<span class="line-added">+     // characters that follow the % sign are hexadecimal digits.</span>
<span class="line-added">+     // Reason being:</span>
<span class="line-added">+     // 1) percentNormalizedComparison method is not called with</span>
<span class="line-added">+     // &#39;decoded&#39; strings</span>
<span class="line-added">+     // 2) The only place where a percent can be followed by anything</span>
<span class="line-added">+     // other than hexadecimal digits is in the authority component</span>
<span class="line-added">+     // (for a IPv6 scope) and the whole authority component is case</span>
<span class="line-added">+     // insensitive.</span>
<span class="line-added">+     private static int percentNormalizedComparison(String s, String t,</span>
<span class="line-added">+                                                    boolean testForEquality) {</span>
<span class="line-added">+ </span>
          if (s == t) return 0;
          if (s != null) {
<span class="line-modified">!             if (t != null) {</span>
<span class="line-modified">!                 if (s.indexOf(&#39;%&#39;) &lt; 0) {</span>
<span class="line-modified">!                     return s.compareTo(t);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 int sn = s.length();</span>
<span class="line-added">+                 int tn = t.length();</span>
<span class="line-added">+                 if ((sn != tn) &amp;&amp; testForEquality)</span>
<span class="line-added">+                     return sn - tn;</span>
<span class="line-added">+                 int val = 0;</span>
<span class="line-added">+                 int n = sn &lt; tn ? sn : tn;</span>
<span class="line-added">+                 for (int i = 0; i &lt; n; ) {</span>
<span class="line-added">+                     char c = s.charAt(i);</span>
<span class="line-added">+                     char d = t.charAt(i);</span>
<span class="line-added">+                     val = c - d;</span>
<span class="line-added">+                     if (c != &#39;%&#39;) {</span>
<span class="line-added">+                         if (val != 0)</span>
<span class="line-added">+                             return val;</span>
<span class="line-added">+                         i++;</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (d != &#39;%&#39;) {</span>
<span class="line-added">+                         if (val != 0)</span>
<span class="line-added">+                             return val;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     i++;</span>
<span class="line-added">+                     val = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="line-added">+                     if (val != 0)</span>
<span class="line-added">+                         return val;</span>
<span class="line-added">+                     i++;</span>
<span class="line-added">+                     val = toLower(s.charAt(i)) - toLower(t.charAt(i));</span>
<span class="line-added">+                     if (val != 0)</span>
<span class="line-added">+                         return val;</span>
<span class="line-added">+                     i++;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return sn - tn;</span>
<span class="line-added">+             } else</span>
                  return +1;
          } else {
              return -1;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2735,11 ***</span>
      }
  
      private static void appendEncoded(StringBuilder sb, char c) {
          ByteBuffer bb = null;
          try {
<span class="line-modified">!             bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
                  .encode(CharBuffer.wrap(&quot;&quot; + c));
          } catch (CharacterCodingException x) {
              assert false;
          }
          while (bb.hasRemaining()) {
<span class="line-new-header">--- 2762,11 ---</span>
      }
  
      private static void appendEncoded(StringBuilder sb, char c) {
          ByteBuffer bb = null;
          try {
<span class="line-modified">!             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
                  .encode(CharBuffer.wrap(&quot;&quot; + c));
          } catch (CharacterCodingException x) {
              assert false;
          }
          while (bb.hasRemaining()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2803,11 ***</span>
          }
  
          String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
          ByteBuffer bb = null;
          try {
<span class="line-modified">!             bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
                  .encode(CharBuffer.wrap(ns));
          } catch (CharacterCodingException x) {
              assert false;
          }
  
<span class="line-new-header">--- 2830,11 ---</span>
          }
  
          String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
          ByteBuffer bb = null;
          try {
<span class="line-modified">!             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
                  .encode(CharBuffer.wrap(ns));
          } catch (CharacterCodingException x) {
              assert false;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2861,11 ***</span>
              return s;
  
          StringBuilder sb = new StringBuilder(n);
          ByteBuffer bb = ByteBuffer.allocate(n);
          CharBuffer cb = CharBuffer.allocate(n);
<span class="line-modified">!         CharsetDecoder dec = ThreadLocalCoders.decoderFor(&quot;UTF-8&quot;)</span>
                  .onMalformedInput(CodingErrorAction.REPLACE)
                  .onUnmappableCharacter(CodingErrorAction.REPLACE);
  
          // This is not horribly efficient, but it will do for now
          char c = s.charAt(0);
<span class="line-new-header">--- 2888,11 ---</span>
              return s;
  
          StringBuilder sb = new StringBuilder(n);
          ByteBuffer bb = ByteBuffer.allocate(n);
          CharBuffer cb = CharBuffer.allocate(n);
<span class="line-modified">!         CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)</span>
                  .onMalformedInput(CodingErrorAction.REPLACE)
                  .onUnmappableCharacter(CodingErrorAction.REPLACE);
  
          // This is not horribly efficient, but it will do for now
          char c = s.charAt(0);
</pre>
<center><a href="StandardSocketOptions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URISyntaxException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
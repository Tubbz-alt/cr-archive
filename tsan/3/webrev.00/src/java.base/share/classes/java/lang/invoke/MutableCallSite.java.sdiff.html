<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MutableCallSite.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodTypeForm.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SerializedLambda.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MutableCallSite.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
135      * Updates the target method of this call site, as a normal variable.
136      * The type of the new target must agree with the type of the old target.
137      * &lt;p&gt;
138      * The interactions with memory are the same
139      * as of a write to an ordinary variable, such as an array element or a
140      * non-volatile, non-final field.
141      * &lt;p&gt;
142      * In particular, unrelated threads may fail to see the updated target
143      * until they perform a read from memory.
144      * Stronger guarantees can be created by putting appropriate operations
145      * into the bootstrap method and/or the target methods used
146      * at any given call site.
147      *
148      * @param newTarget the new target
149      * @throws NullPointerException if the proposed new target is null
150      * @throws WrongMethodTypeException if the proposed new target
151      *         has a method type that differs from the previous target
152      * @see #getTarget
153      */
154     @Override public void setTarget(MethodHandle newTarget) {
<span class="line-removed">155         checkTargetChange(this.target, newTarget);</span>
156         setTargetNormal(newTarget);
157     }
158 
159     /**
160      * {@inheritDoc}
161      */
162     @Override
163     public final MethodHandle dynamicInvoker() {
164         return makeDynamicInvoker();
165     }
166 
167     /**
168      * Performs a synchronization operation on each call site in the given array,
169      * forcing all other threads to throw away any cached values previously
170      * loaded from the target of any of the call sites.
171      * &lt;p&gt;
172      * This operation does not reverse any calls that have already started
173      * on an old target value.
174      * (Java supports {@linkplain java.lang.Object#wait() forward time travel} only.)
175      * &lt;p&gt;
</pre>
<hr />
<pre>
180      * (somehow) decached all previous versions of each call site&#39;s target.
181      * &lt;p&gt;
182      * To avoid race conditions, calls to {@code setTarget} and {@code syncAll}
183      * should generally be performed under some sort of mutual exclusion.
184      * Note that reader threads may observe an updated target as early
185      * as the {@code setTarget} call that install the value
186      * (and before the {@code syncAll} that confirms the value).
187      * On the other hand, reader threads may observe previous versions of
188      * the target until the {@code syncAll} call returns
189      * (and after the {@code setTarget} that attempts to convey the updated version).
190      * &lt;p&gt;
191      * This operation is likely to be expensive and should be used sparingly.
192      * If possible, it should be buffered for batch processing on sets of call sites.
193      * &lt;p&gt;
194      * If {@code sites} contains a null element,
195      * a {@code NullPointerException} will be raised.
196      * In this case, some non-null elements in the array may be
197      * processed before the method returns abnormally.
198      * Which elements these are (if any) is implementation-dependent.
199      *
<span class="line-modified">200      * &lt;h1&gt;Java Memory Model details&lt;/h1&gt;</span>
201      * In terms of the Java Memory Model, this operation performs a synchronization
202      * action which is comparable in effect to the writing of a volatile variable
203      * by the current thread, and an eventual volatile read by every other thread
204      * that may access one of the affected call sites.
205      * &lt;p&gt;
206      * The following effects are apparent, for each individual call site {@code S}:
207      * &lt;ul&gt;
208      * &lt;li&gt;A new volatile variable {@code V} is created, and written by the current thread.
209      *     As defined by the JMM, this write is a global synchronization event.
210      * &lt;li&gt;As is normal with thread-local ordering of write events,
211      *     every action already performed by the current thread is
212      *     taken to happen before the volatile write to {@code V}.
213      *     (In some implementations, this means that the current thread
214      *     performs a global release operation.)
215      * &lt;li&gt;Specifically, the write to the current target of {@code S} is
216      *     taken to happen before the volatile write to {@code V}.
217      * &lt;li&gt;The volatile write to {@code V} is placed
218      *     (in an implementation specific manner)
219      *     in the global synchronization order.
220      * &lt;li&gt;Consider an arbitrary thread {@code T} (other than the current thread).
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
135      * Updates the target method of this call site, as a normal variable.
136      * The type of the new target must agree with the type of the old target.
137      * &lt;p&gt;
138      * The interactions with memory are the same
139      * as of a write to an ordinary variable, such as an array element or a
140      * non-volatile, non-final field.
141      * &lt;p&gt;
142      * In particular, unrelated threads may fail to see the updated target
143      * until they perform a read from memory.
144      * Stronger guarantees can be created by putting appropriate operations
145      * into the bootstrap method and/or the target methods used
146      * at any given call site.
147      *
148      * @param newTarget the new target
149      * @throws NullPointerException if the proposed new target is null
150      * @throws WrongMethodTypeException if the proposed new target
151      *         has a method type that differs from the previous target
152      * @see #getTarget
153      */
154     @Override public void setTarget(MethodHandle newTarget) {

155         setTargetNormal(newTarget);
156     }
157 
158     /**
159      * {@inheritDoc}
160      */
161     @Override
162     public final MethodHandle dynamicInvoker() {
163         return makeDynamicInvoker();
164     }
165 
166     /**
167      * Performs a synchronization operation on each call site in the given array,
168      * forcing all other threads to throw away any cached values previously
169      * loaded from the target of any of the call sites.
170      * &lt;p&gt;
171      * This operation does not reverse any calls that have already started
172      * on an old target value.
173      * (Java supports {@linkplain java.lang.Object#wait() forward time travel} only.)
174      * &lt;p&gt;
</pre>
<hr />
<pre>
179      * (somehow) decached all previous versions of each call site&#39;s target.
180      * &lt;p&gt;
181      * To avoid race conditions, calls to {@code setTarget} and {@code syncAll}
182      * should generally be performed under some sort of mutual exclusion.
183      * Note that reader threads may observe an updated target as early
184      * as the {@code setTarget} call that install the value
185      * (and before the {@code syncAll} that confirms the value).
186      * On the other hand, reader threads may observe previous versions of
187      * the target until the {@code syncAll} call returns
188      * (and after the {@code setTarget} that attempts to convey the updated version).
189      * &lt;p&gt;
190      * This operation is likely to be expensive and should be used sparingly.
191      * If possible, it should be buffered for batch processing on sets of call sites.
192      * &lt;p&gt;
193      * If {@code sites} contains a null element,
194      * a {@code NullPointerException} will be raised.
195      * In this case, some non-null elements in the array may be
196      * processed before the method returns abnormally.
197      * Which elements these are (if any) is implementation-dependent.
198      *
<span class="line-modified">199      * &lt;h4&gt;Java Memory Model details&lt;/h4&gt;</span>
200      * In terms of the Java Memory Model, this operation performs a synchronization
201      * action which is comparable in effect to the writing of a volatile variable
202      * by the current thread, and an eventual volatile read by every other thread
203      * that may access one of the affected call sites.
204      * &lt;p&gt;
205      * The following effects are apparent, for each individual call site {@code S}:
206      * &lt;ul&gt;
207      * &lt;li&gt;A new volatile variable {@code V} is created, and written by the current thread.
208      *     As defined by the JMM, this write is a global synchronization event.
209      * &lt;li&gt;As is normal with thread-local ordering of write events,
210      *     every action already performed by the current thread is
211      *     taken to happen before the volatile write to {@code V}.
212      *     (In some implementations, this means that the current thread
213      *     performs a global release operation.)
214      * &lt;li&gt;Specifically, the write to the current target of {@code S} is
215      *     taken to happen before the volatile write to {@code V}.
216      * &lt;li&gt;The volatile write to {@code V} is placed
217      *     (in an implementation specific manner)
218      *     in the global synchronization order.
219      * &lt;li&gt;Consider an arbitrary thread {@code T} (other than the current thread).
</pre>
</td>
</tr>
</table>
<center><a href="MethodTypeForm.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SerializedLambda.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/Arrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayPrefixHelpers.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArraysParallelSortHelpers.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Arrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,94 +72,44 @@</span>
   * @author John Rose
   * @since  1.2
   */
  public class Arrays {
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * The minimum array length below which a parallel sorting</span>
<span class="udiff-line-removed">-      * algorithm will not further partition the sorting task. Using</span>
<span class="udiff-line-removed">-      * smaller sizes typically results in memory contention across</span>
<span class="udiff-line-removed">-      * tasks that makes parallel speedups unlikely.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;</span>
<span class="udiff-line-removed">- </span>
      // Suppresses default constructor, ensuring non-instantiability.
      private Arrays() {}
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * A comparator that implements the natural ordering of a group of</span>
<span class="udiff-line-removed">-      * mutually comparable elements. May be used when a supplied</span>
<span class="udiff-line-removed">-      * comparator is null. To simplify code-sharing within underlying</span>
<span class="udiff-line-removed">-      * implementations, the compare method only declares type Object</span>
<span class="udiff-line-removed">-      * for its second argument.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Arrays class implementor&#39;s note: It is an empirical matter</span>
<span class="udiff-line-removed">-      * whether ComparableTimSort offers any performance benefit over</span>
<span class="udiff-line-removed">-      * TimSort used with this comparator.  If not, you are better off</span>
<span class="udiff-line-removed">-      * deleting or bypassing ComparableTimSort.  There is currently no</span>
<span class="udiff-line-removed">-      * empirical case for separating them for parallel sorting, so all</span>
<span class="udiff-line-removed">-      * public Object parallelSort methods use the same comparator</span>
<span class="udiff-line-removed">-      * based implementation.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static final class NaturalOrder implements Comparator&lt;Object&gt; {</span>
<span class="udiff-line-removed">-         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="udiff-line-removed">-         public int compare(Object first, Object second) {</span>
<span class="udiff-line-removed">-             return ((Comparable&lt;Object&gt;)first).compareTo(second);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         static final NaturalOrder INSTANCE = new NaturalOrder();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Checks that {@code fromIndex} and {@code toIndex} are in</span>
<span class="udiff-line-removed">-      * the range and throws an exception if they aren&#39;t.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {</span>
<span class="udiff-line-removed">-         if (fromIndex &gt; toIndex) {</span>
<span class="udiff-line-removed">-             throw new IllegalArgumentException(</span>
<span class="udiff-line-removed">-                     &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (fromIndex &lt; 0) {</span>
<span class="udiff-line-removed">-             throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (toIndex &gt; arrayLength) {</span>
<span class="udiff-line-removed">-             throw new ArrayIndexOutOfBoundsException(toIndex);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /*
       * Sorting methods. Note that all public &quot;sort&quot; methods take the
<span class="udiff-line-modified-removed">-      * same form: Performing argument checks if necessary, and then</span>
<span class="udiff-line-modified-added">+      * same form: performing argument checks if necessary, and then</span>
       * expanding arguments into those required for the internal
       * implementation methods residing in other package-private
       * classes (except for legacyMergeSort, included in this class).
       */
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(int[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
       * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
       * the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,38 +118,36 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(int[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(long[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
       * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
       * the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -208,38 +156,36 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(long[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(short[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
       * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
       * the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,38 +194,36 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(short[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(char[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
       * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
       * the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -288,38 +232,36 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(char[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(byte[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
       * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
       * the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -328,11 +270,11 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(byte[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -342,20 +284,19 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
       * {@code 0.0f} and {@code Float.NaN} is considered greater than any
       * other value and all {@code Float.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(float[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -368,14 +309,13 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
       * {@code 0.0f} and {@code Float.NaN} is considered greater than any
       * other value and all {@code Float.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,11 +324,11 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(float[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -398,20 +338,19 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
       * {@code 0.0d} and {@code Double.NaN} is considered greater than any
       * other value and all {@code Double.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       */
      public static void sort(double[] a) {
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending order. The range
       * to be sorted extends from the index {@code fromIndex}, inclusive, to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -424,14 +363,13 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
       * {@code 0.0d} and {@code Double.NaN} is considered greater than any
       * other value and all {@code Double.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
       * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="udiff-line-modified-removed">-      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="udiff-line-removed">-      * quicksorts to degrade to quadratic performance, and is typically</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
       * faster than traditional (one-pivot) Quicksort implementations.
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,59 +378,39 @@</span>
       * @throws ArrayIndexOutOfBoundsException
       *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
       */
      public static void sort(double[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(byte[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJByte.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new byte[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
       * inclusive, to the index {@code toIndex}, exclusive. If
       * {@code fromIndex == toIndex}, the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -502,67 +420,39 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(byte[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJByte.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new byte[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(char[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJChar.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new char[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
       * inclusive, to the index {@code toIndex}, exclusive. If
       * {@code fromIndex == toIndex}, the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-       @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,67 +462,39 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(char[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJChar.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new char[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(short[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJShort.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new short[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
       * inclusive, to the index {@code toIndex}, exclusive. If
       * {@code fromIndex == toIndex}, the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -642,67 +504,39 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(short[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJShort.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new short[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(int[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJInt.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new int[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
       * inclusive, to the index {@code toIndex}, exclusive. If
       * {@code fromIndex == toIndex}, the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,67 +546,39 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(int[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJInt.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new int[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(long[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJLong.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new long[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
       * inclusive, to the index {@code toIndex}, exclusive. If
       * {@code fromIndex == toIndex}, the range to be sorted is empty.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -782,19 +588,11 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(long[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJLong.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new long[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -804,35 +602,21 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
       * {@code 0.0f} and {@code Float.NaN} is considered greater than any
       * other value and all {@code Float.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(float[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJFloat.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new float[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -845,20 +629,14 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
       * {@code 0.0f} and {@code Float.NaN} is considered greater than any
       * other value and all {@code Float.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -868,19 +646,11 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(float[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJFloat.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new float[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>
      }
  
      /**
       * Sorts the specified array into ascending numerical order.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -890,35 +660,21 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
       * {@code 0.0d} and {@code Double.NaN} is considered greater than any
       * other value and all {@code Double.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a</span>
<span class="udiff-line-removed">-      * working space no greater than the size of the original array. The</span>
<span class="udiff-line-removed">-      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="udiff-line-removed">-      * execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       *
       * @since 1.8
       */
      public static void parallelSort(double[] a) {
<span class="udiff-line-modified-removed">-         int n = a.length, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJDouble.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new double[n], 0, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>
      }
  
      /**
       * Sorts the specified range of the array into ascending numerical order.
       * The range to be sorted extends from the index {@code fromIndex},
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -931,20 +687,14 @@</span>
       * even itself. This method uses the total order imposed by the method
       * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
       * {@code 0.0d} and {@code Double.NaN} is considered greater than any
       * other value and all {@code Double.NaN} values are considered equal.
       *
<span class="udiff-line-modified-removed">-      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="udiff-line-modified-removed">-      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="udiff-line-modified-removed">-      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="udiff-line-modified-removed">-      * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}</span>
<span class="udiff-line-removed">-      * method. If the length of the specified array is less than the minimum</span>
<span class="udiff-line-removed">-      * granularity, then it is sorted using the appropriate {@link</span>
<span class="udiff-line-removed">-      * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="udiff-line-removed">-      * space no greater than the size of the specified range of the original</span>
<span class="udiff-line-removed">-      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="udiff-line-removed">-      * used to execute any parallel tasks.</span>
<span class="udiff-line-modified-added">+      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="udiff-line-modified-added">+      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="udiff-line-modified-added">+      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="udiff-line-modified-added">+      * faster than traditional (one-pivot) Quicksort implementations.</span>
       *
       * @param a the array to be sorted
       * @param fromIndex the index of the first element, inclusive, to be sorted
       * @param toIndex the index of the last element, exclusive, to be sorted
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -954,21 +704,61 @@</span>
       *
       * @since 1.8
       */
      public static void parallelSort(double[] a, int fromIndex, int toIndex) {
          rangeCheck(a.length, fromIndex, toIndex);
<span class="udiff-line-modified-removed">-         int n = toIndex - fromIndex, p, g;</span>
<span class="udiff-line-removed">-         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="udiff-line-removed">-             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="udiff-line-removed">-             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             new ArraysParallelSortHelpers.FJDouble.Sorter</span>
<span class="udiff-line-removed">-                 (null, a, new double[n], fromIndex, n, 0,</span>
<span class="udiff-line-removed">-                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="udiff-line-removed">-                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
<span class="udiff-line-modified-added">+         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Checks that {@code fromIndex} and {@code toIndex} are in</span>
<span class="udiff-line-added">+      * the range and throws an exception if they aren&#39;t.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {</span>
<span class="udiff-line-added">+         if (fromIndex &gt; toIndex) {</span>
<span class="udiff-line-added">+             throw new IllegalArgumentException(</span>
<span class="udiff-line-added">+                 &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (fromIndex &lt; 0) {</span>
<span class="udiff-line-added">+             throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (toIndex &gt; arrayLength) {</span>
<span class="udiff-line-added">+             throw new ArrayIndexOutOfBoundsException(toIndex);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * A comparator that implements the natural ordering of a group of</span>
<span class="udiff-line-added">+      * mutually comparable elements. May be used when a supplied</span>
<span class="udiff-line-added">+      * comparator is null. To simplify code-sharing within underlying</span>
<span class="udiff-line-added">+      * implementations, the compare method only declares type Object</span>
<span class="udiff-line-added">+      * for its second argument.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Arrays class implementor&#39;s note: It is an empirical matter</span>
<span class="udiff-line-added">+      * whether ComparableTimSort offers any performance benefit over</span>
<span class="udiff-line-added">+      * TimSort used with this comparator.  If not, you are better off</span>
<span class="udiff-line-added">+      * deleting or bypassing ComparableTimSort.  There is currently no</span>
<span class="udiff-line-added">+      * empirical case for separating them for parallel sorting, so all</span>
<span class="udiff-line-added">+      * public Object parallelSort methods use the same comparator</span>
<span class="udiff-line-added">+      * based implementation.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static final class NaturalOrder implements Comparator&lt;Object&gt; {</span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="udiff-line-added">+         public int compare(Object first, Object second) {</span>
<span class="udiff-line-added">+             return ((Comparable&lt;Object&gt;)first).compareTo(second);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         static final NaturalOrder INSTANCE = new NaturalOrder();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * The minimum array length below which a parallel sorting</span>
<span class="udiff-line-added">+      * algorithm will not further partition the sorting task. Using</span>
<span class="udiff-line-added">+      * smaller sizes typically results in memory contention across</span>
<span class="udiff-line-added">+      * tasks that makes parallel speedups unlikely.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;</span>
<span class="udiff-line-added">+ </span>
      /**
       * Sorts the specified array of objects into ascending order, according
       * to the {@linkplain Comparable natural ordering} of its elements.
       * All elements in the array must implement the {@link Comparable}
       * interface.  Furthermore, all elements in the array must be
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2597,11 +2387,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2669,11 +2459,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2741,11 +2531,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2814,11 +2604,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2887,11 +2677,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2959,11 +2749,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3042,11 +2832,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3125,11 +2915,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3208,11 +2998,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @return {@code true} if the two arrays, over the specified ranges, are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3301,11 +3091,11 @@</span>
       * @param a the first array to be tested for equality
       * @param aFromIndex the index (inclusive) of the first element in the
       *                   first array to be tested
       * @param aToIndex the index (exclusive) of the last element in the
       *                 first array to be tested
<span class="udiff-line-modified-removed">-      * @param b the second array to be tested fro equality</span>
<span class="udiff-line-modified-added">+      * @param b the second array to be tested for equality</span>
       * @param bFromIndex the index (inclusive) of the first element in the
       *                   second array to be tested
       * @param bToIndex the index (exclusive) of the last element in the
       *                 second array to be tested
       * @param cmp the comparator to compare array elements
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4335,11 +4125,13 @@</span>
       * @serial include
       */
      private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
          implements RandomAccess, java.io.Serializable
      {
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = -2764017481108945198L;
<span class="udiff-line-added">+         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
          private final E[] a;
  
          ArrayList(E[] array) {
              a = Objects.requireNonNull(array);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7323,14 +7115,14 @@</span>
       * comparison is the result of comparing the two array lengths.
       * (See {@link #mismatch(Object[], Object[])} for the definition of a common
       * and proper prefix.)
       *
       * &lt;p&gt;A {@code null} array reference is considered lexicographically less
<span class="udiff-line-modified-removed">-      * than a non-{@code null} array reference.  Two {@code null} array</span>
<span class="udiff-line-modified-added">+      * than a non-{@code null} array reference. Two {@code null} array</span>
       * references are considered equal.
<span class="udiff-line-modified-removed">-      * A {@code null} array element is considered lexicographically than a</span>
<span class="udiff-line-modified-removed">-      * non-{@code null} array element.  Two {@code null} array elements are</span>
<span class="udiff-line-modified-added">+      * A {@code null} array element is considered lexicographically less than a</span>
<span class="udiff-line-modified-added">+      * non-{@code null} array element. Two {@code null} array elements are</span>
       * considered equal.
       *
       * &lt;p&gt;The comparison is consistent with {@link #equals(Object[], Object[]) equals},
       * more specifically the following holds for arrays {@code a} and {@code b}:
       * &lt;pre&gt;{@code
</pre>
<center><a href="ArrayPrefixHelpers.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArraysParallelSortHelpers.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/PushbackReader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PushbackInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="RandomAccessFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/PushbackReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 30  * A character-stream reader that allows characters to be pushed back into the
 31  * stream.
 32  *
 33  * @author      Mark Reinhold
 34  * @since       1.1
 35  */
 36 
 37 public class PushbackReader extends FilterReader {
 38 
 39     /** Pushback buffer */
 40     private char[] buf;
 41 
 42     /** Current position in buffer */
 43     private int pos;
 44 
 45     /**
 46      * Creates a new pushback reader with a pushback buffer of the given size.
 47      *
 48      * @param   in   The reader from which characters will be read
 49      * @param   size The size of the pushback buffer
<span class="line-modified"> 50      * @exception IllegalArgumentException if {@code size &lt;= 0}</span>
 51      */
 52     public PushbackReader(Reader in, int size) {
 53         super(in);
 54         if (size &lt;= 0) {
 55             throw new IllegalArgumentException(&quot;size &lt;= 0&quot;);
 56         }
 57         this.buf = new char[size];
 58         this.pos = size;
 59     }
 60 
 61     /**
 62      * Creates a new pushback reader with a one-character pushback buffer.
 63      *
 64      * @param   in  The reader from which characters will be read
 65      */
 66     public PushbackReader(Reader in) {
 67         this(in, 1);
 68     }
 69 
 70     /** Checks to make sure that the stream has not been closed. */
 71     private void ensureOpen() throws IOException {
 72         if (buf == null)
 73             throw new IOException(&quot;Stream closed&quot;);
 74     }
 75 
 76     /**
 77      * Reads a single character.
 78      *
 79      * @return     The character read, or -1 if the end of the stream has been
 80      *             reached
 81      *
<span class="line-modified"> 82      * @exception  IOException  If an I/O error occurs</span>
 83      */
 84     public int read() throws IOException {
 85         synchronized (lock) {
 86             ensureOpen();
 87             if (pos &lt; buf.length)
 88                 return buf[pos++];
 89             else
 90                 return super.read();
 91         }
 92     }
 93 
 94     /**
 95      * Reads characters into a portion of an array.
 96      *
 97      * @param      cbuf  Destination buffer
 98      * @param      off   Offset at which to start writing characters
 99      * @param      len   Maximum number of characters to read
100      *
101      * @return     The number of characters read, or -1 if the end of the
102      *             stream has been reached
103      *
<span class="line-modified">104      * @exception  IOException  If an I/O error occurs</span>
<span class="line-modified">105      * @exception  IndexOutOfBoundsException {@inheritDoc}</span>
106      */
107     public int read(char cbuf[], int off, int len) throws IOException {
108         synchronized (lock) {
109             ensureOpen();
110             try {
111                 if (len &lt;= 0) {
112                     if (len &lt; 0) {
113                         throw new IndexOutOfBoundsException();
114                     } else if ((off &lt; 0) || (off &gt; cbuf.length)) {
115                         throw new IndexOutOfBoundsException();
116                     }
117                     return 0;
118                 }
119                 int avail = buf.length - pos;
120                 if (avail &gt; 0) {
121                     if (len &lt; avail)
122                         avail = len;
123                     System.arraycopy(buf, pos, cbuf, off, avail);
124                     pos += avail;
125                     off += avail;
126                     len -= avail;
127                 }
128                 if (len &gt; 0) {
129                     len = super.read(cbuf, off, len);
130                     if (len == -1) {
131                         return (avail == 0) ? -1 : avail;
132                     }
133                     return avail + len;
134                 }
135                 return avail;
136             } catch (ArrayIndexOutOfBoundsException e) {
137                 throw new IndexOutOfBoundsException();
138             }
139         }
140     }
141 
142     /**
143      * Pushes back a single character by copying it to the front of the
144      * pushback buffer. After this method returns, the next character to be read
<span class="line-modified">145      * will have the value &lt;code&gt;(char)c&lt;/code&gt;.</span>
146      *
147      * @param  c  The int value representing a character to be pushed back
148      *
<span class="line-modified">149      * @exception  IOException  If the pushback buffer is full,</span>
<span class="line-modified">150      *                          or if some other I/O error occurs</span>
151      */
152     public void unread(int c) throws IOException {
153         synchronized (lock) {
154             ensureOpen();
155             if (pos == 0)
156                 throw new IOException(&quot;Pushback buffer overflow&quot;);
157             buf[--pos] = (char) c;
158         }
159     }
160 
161     /**
162      * Pushes back a portion of an array of characters by copying it to the
163      * front of the pushback buffer.  After this method returns, the next
<span class="line-modified">164      * character to be read will have the value &lt;code&gt;cbuf[off]&lt;/code&gt;, the</span>
<span class="line-modified">165      * character after that will have the value &lt;code&gt;cbuf[off+1]&lt;/code&gt;, and</span>
166      * so forth.
167      *
<span class="line-modified">168      * @param  cbuf  Character array</span>
<span class="line-modified">169      * @param  off   Offset of first character to push back</span>
<span class="line-modified">170      * @param  len   Number of characters to push back</span>
171      *
<span class="line-modified">172      * @exception  IOException  If there is insufficient room in the pushback</span>
173      *                          buffer, or if some other I/O error occurs
174      */
175     public void unread(char cbuf[], int off, int len) throws IOException {
176         synchronized (lock) {
177             ensureOpen();
178             if (len &gt; pos)
179                 throw new IOException(&quot;Pushback buffer overflow&quot;);
180             pos -= len;
181             System.arraycopy(cbuf, off, buf, pos, len);
182         }
183     }
184 
185     /**
186      * Pushes back an array of characters by copying it to the front of the
187      * pushback buffer.  After this method returns, the next character to be
<span class="line-modified">188      * read will have the value &lt;code&gt;cbuf[0]&lt;/code&gt;, the character after that</span>
<span class="line-modified">189      * will have the value &lt;code&gt;cbuf[1]&lt;/code&gt;, and so forth.</span>
190      *
<span class="line-modified">191      * @param  cbuf  Character array to push back</span>
192      *
<span class="line-modified">193      * @exception  IOException  If there is insufficient room in the pushback</span>
194      *                          buffer, or if some other I/O error occurs
195      */
196     public void unread(char cbuf[]) throws IOException {
197         unread(cbuf, 0, cbuf.length);
198     }
199 
200     /**
201      * Tells whether this stream is ready to be read.
202      *
<span class="line-modified">203      * @exception  IOException  If an I/O error occurs</span>
204      */
205     public boolean ready() throws IOException {
206         synchronized (lock) {
207             ensureOpen();
208             return (pos &lt; buf.length) || super.ready();
209         }
210     }
211 
212     /**
<span class="line-modified">213      * Marks the present position in the stream. The &lt;code&gt;mark&lt;/code&gt;</span>
<span class="line-modified">214      * for class &lt;code&gt;PushbackReader&lt;/code&gt; always throws an exception.</span>
215      *
<span class="line-modified">216      * @exception  IOException  Always, since mark is not supported</span>
217      */
218     public void mark(int readAheadLimit) throws IOException {
219         throw new IOException(&quot;mark/reset not supported&quot;);
220     }
221 
222     /**
<span class="line-modified">223      * Resets the stream. The &lt;code&gt;reset&lt;/code&gt; method of</span>
<span class="line-modified">224      * &lt;code&gt;PushbackReader&lt;/code&gt; always throws an exception.</span>
225      *
<span class="line-modified">226      * @exception  IOException  Always, since reset is not supported</span>
227      */
228     public void reset() throws IOException {
229         throw new IOException(&quot;mark/reset not supported&quot;);
230     }
231 
232     /**
233      * Tells whether this stream supports the mark() operation, which it does
234      * not.
235      */
236     public boolean markSupported() {
237         return false;
238     }
239 
240     /**
241      * Closes the stream and releases any system resources associated with
242      * it. Once the stream has been closed, further read(),
243      * unread(), ready(), or skip() invocations will throw an IOException.
244      * Closing a previously closed stream has no effect. This method will block
245      * while there is another thread blocking on the reader.
246      *
<span class="line-modified">247      * @exception  IOException  If an I/O error occurs</span>
248      */
249     public void close() throws IOException {
250         synchronized (lock) {
251             super.close();
252             buf = null;
253         }
254     }
255 
256     /**
257      * Skips characters.  This method will block until some characters are
258      * available, an I/O error occurs, or the end of the stream is reached.
259      *
<span class="line-modified">260      * @param  n  The number of characters to skip</span>
261      *
262      * @return    The number of characters actually skipped
263      *
<span class="line-modified">264      * @exception  IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</span>
<span class="line-modified">265      * @exception  IOException  If an I/O error occurs</span>
266      */
267     public long skip(long n) throws IOException {
268         if (n &lt; 0L)
269             throw new IllegalArgumentException(&quot;skip value is negative&quot;);
270         synchronized (lock) {
271             ensureOpen();
272             int avail = buf.length - pos;
273             if (avail &gt; 0) {
274                 if (n &lt;= avail) {
275                     pos += n;
276                     return n;
277                 } else {
278                     pos = buf.length;
279                     n -= avail;
280                 }
281             }
282             return avail + super.skip(n);
283         }
284     }
285 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 30  * A character-stream reader that allows characters to be pushed back into the
 31  * stream.
 32  *
 33  * @author      Mark Reinhold
 34  * @since       1.1
 35  */
 36 
 37 public class PushbackReader extends FilterReader {
 38 
 39     /** Pushback buffer */
 40     private char[] buf;
 41 
 42     /** Current position in buffer */
 43     private int pos;
 44 
 45     /**
 46      * Creates a new pushback reader with a pushback buffer of the given size.
 47      *
 48      * @param   in   The reader from which characters will be read
 49      * @param   size The size of the pushback buffer
<span class="line-modified"> 50      * @throws  IllegalArgumentException if {@code size &lt;= 0}</span>
 51      */
 52     public PushbackReader(Reader in, int size) {
 53         super(in);
 54         if (size &lt;= 0) {
 55             throw new IllegalArgumentException(&quot;size &lt;= 0&quot;);
 56         }
 57         this.buf = new char[size];
 58         this.pos = size;
 59     }
 60 
 61     /**
 62      * Creates a new pushback reader with a one-character pushback buffer.
 63      *
 64      * @param   in  The reader from which characters will be read
 65      */
 66     public PushbackReader(Reader in) {
 67         this(in, 1);
 68     }
 69 
 70     /** Checks to make sure that the stream has not been closed. */
 71     private void ensureOpen() throws IOException {
 72         if (buf == null)
 73             throw new IOException(&quot;Stream closed&quot;);
 74     }
 75 
 76     /**
 77      * Reads a single character.
 78      *
 79      * @return     The character read, or -1 if the end of the stream has been
 80      *             reached
 81      *
<span class="line-modified"> 82      * @throws     IOException  If an I/O error occurs</span>
 83      */
 84     public int read() throws IOException {
 85         synchronized (lock) {
 86             ensureOpen();
 87             if (pos &lt; buf.length)
 88                 return buf[pos++];
 89             else
 90                 return super.read();
 91         }
 92     }
 93 
 94     /**
 95      * Reads characters into a portion of an array.
 96      *
 97      * @param      cbuf  Destination buffer
 98      * @param      off   Offset at which to start writing characters
 99      * @param      len   Maximum number of characters to read
100      *
101      * @return     The number of characters read, or -1 if the end of the
102      *             stream has been reached
103      *
<span class="line-modified">104      * @throws     IOException  If an I/O error occurs</span>
<span class="line-modified">105      * @throws     IndexOutOfBoundsException {@inheritDoc}</span>
106      */
107     public int read(char cbuf[], int off, int len) throws IOException {
108         synchronized (lock) {
109             ensureOpen();
110             try {
111                 if (len &lt;= 0) {
112                     if (len &lt; 0) {
113                         throw new IndexOutOfBoundsException();
114                     } else if ((off &lt; 0) || (off &gt; cbuf.length)) {
115                         throw new IndexOutOfBoundsException();
116                     }
117                     return 0;
118                 }
119                 int avail = buf.length - pos;
120                 if (avail &gt; 0) {
121                     if (len &lt; avail)
122                         avail = len;
123                     System.arraycopy(buf, pos, cbuf, off, avail);
124                     pos += avail;
125                     off += avail;
126                     len -= avail;
127                 }
128                 if (len &gt; 0) {
129                     len = super.read(cbuf, off, len);
130                     if (len == -1) {
131                         return (avail == 0) ? -1 : avail;
132                     }
133                     return avail + len;
134                 }
135                 return avail;
136             } catch (ArrayIndexOutOfBoundsException e) {
137                 throw new IndexOutOfBoundsException();
138             }
139         }
140     }
141 
142     /**
143      * Pushes back a single character by copying it to the front of the
144      * pushback buffer. After this method returns, the next character to be read
<span class="line-modified">145      * will have the value {@code (char)c}.</span>
146      *
147      * @param  c  The int value representing a character to be pushed back
148      *
<span class="line-modified">149      * @throws IOException  If the pushback buffer is full,</span>
<span class="line-modified">150      *                      or if some other I/O error occurs</span>
151      */
152     public void unread(int c) throws IOException {
153         synchronized (lock) {
154             ensureOpen();
155             if (pos == 0)
156                 throw new IOException(&quot;Pushback buffer overflow&quot;);
157             buf[--pos] = (char) c;
158         }
159     }
160 
161     /**
162      * Pushes back a portion of an array of characters by copying it to the
163      * front of the pushback buffer.  After this method returns, the next
<span class="line-modified">164      * character to be read will have the value {@code cbuf[off]}, the</span>
<span class="line-modified">165      * character after that will have the value {@code cbuf[off+1]}, and</span>
166      * so forth.
167      *
<span class="line-modified">168      * @param      cbuf  Character array</span>
<span class="line-modified">169      * @param      off   Offset of first character to push back</span>
<span class="line-modified">170      * @param      len   Number of characters to push back</span>
171      *
<span class="line-modified">172      * @throws     IOException  If there is insufficient room in the pushback</span>
173      *                          buffer, or if some other I/O error occurs
174      */
175     public void unread(char cbuf[], int off, int len) throws IOException {
176         synchronized (lock) {
177             ensureOpen();
178             if (len &gt; pos)
179                 throw new IOException(&quot;Pushback buffer overflow&quot;);
180             pos -= len;
181             System.arraycopy(cbuf, off, buf, pos, len);
182         }
183     }
184 
185     /**
186      * Pushes back an array of characters by copying it to the front of the
187      * pushback buffer.  After this method returns, the next character to be
<span class="line-modified">188      * read will have the value {@code cbuf[0]}, the character after that</span>
<span class="line-modified">189      * will have the value {@code cbuf[1]}, and so forth.</span>
190      *
<span class="line-modified">191      * @param      cbuf  Character array to push back</span>
192      *
<span class="line-modified">193      * @throws     IOException  If there is insufficient room in the pushback</span>
194      *                          buffer, or if some other I/O error occurs
195      */
196     public void unread(char cbuf[]) throws IOException {
197         unread(cbuf, 0, cbuf.length);
198     }
199 
200     /**
201      * Tells whether this stream is ready to be read.
202      *
<span class="line-modified">203      * @throws     IOException  If an I/O error occurs</span>
204      */
205     public boolean ready() throws IOException {
206         synchronized (lock) {
207             ensureOpen();
208             return (pos &lt; buf.length) || super.ready();
209         }
210     }
211 
212     /**
<span class="line-modified">213      * Marks the present position in the stream. The {@code mark}</span>
<span class="line-modified">214      * for class {@code PushbackReader} always throws an exception.</span>
215      *
<span class="line-modified">216      * @throws     IOException  Always, since mark is not supported</span>
217      */
218     public void mark(int readAheadLimit) throws IOException {
219         throw new IOException(&quot;mark/reset not supported&quot;);
220     }
221 
222     /**
<span class="line-modified">223      * Resets the stream. The {@code reset} method of</span>
<span class="line-modified">224      * {@code PushbackReader} always throws an exception.</span>
225      *
<span class="line-modified">226      * @throws     IOException  Always, since reset is not supported</span>
227      */
228     public void reset() throws IOException {
229         throw new IOException(&quot;mark/reset not supported&quot;);
230     }
231 
232     /**
233      * Tells whether this stream supports the mark() operation, which it does
234      * not.
235      */
236     public boolean markSupported() {
237         return false;
238     }
239 
240     /**
241      * Closes the stream and releases any system resources associated with
242      * it. Once the stream has been closed, further read(),
243      * unread(), ready(), or skip() invocations will throw an IOException.
244      * Closing a previously closed stream has no effect. This method will block
245      * while there is another thread blocking on the reader.
246      *
<span class="line-modified">247      * @throws     IOException  If an I/O error occurs</span>
248      */
249     public void close() throws IOException {
250         synchronized (lock) {
251             super.close();
252             buf = null;
253         }
254     }
255 
256     /**
257      * Skips characters.  This method will block until some characters are
258      * available, an I/O error occurs, or the end of the stream is reached.
259      *
<span class="line-modified">260      * @param     n  The number of characters to skip</span>
261      *
262      * @return    The number of characters actually skipped
263      *
<span class="line-modified">264      * @throws    IllegalArgumentException  If {@code n} is negative.</span>
<span class="line-modified">265      * @throws    IOException  If an I/O error occurs</span>
266      */
267     public long skip(long n) throws IOException {
268         if (n &lt; 0L)
269             throw new IllegalArgumentException(&quot;skip value is negative&quot;);
270         synchronized (lock) {
271             ensureOpen();
272             int avail = buf.length - pos;
273             if (avail &gt; 0) {
274                 if (n &lt;= avail) {
275                     pos += n;
276                     return n;
277                 } else {
278                     pos = buf.length;
279                     n -= avail;
280                 }
281             }
282             return avail + super.skip(n);
283         }
284     }
285 }
</pre>
</td>
</tr>
</table>
<center><a href="PushbackInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="RandomAccessFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
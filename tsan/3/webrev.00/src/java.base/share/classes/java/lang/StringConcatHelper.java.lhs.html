<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/StringConcatHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
<a name="2" id="anc2"></a>


 28 /**
 29  * Helper for string concatenation. These methods are mostly looked up with private lookups
 30  * from {@link java.lang.invoke.StringConcatFactory}, and used in {@link java.lang.invoke.MethodHandle}
 31  * combinators there.
 32  */
 33 final class StringConcatHelper {
 34 
 35     private StringConcatHelper() {
 36         // no instantiation
 37     }
 38 
 39     /**
 40      * Check for overflow, throw exception on overflow.
<a name="3" id="anc3"></a><span class="line-modified"> 41      * @param lengthCoder String length and coder</span>
<span class="line-modified"> 42      * @return lengthCoder</span>


 43      */
 44     private static long checkOverflow(long lengthCoder) {
 45         if ((int)lengthCoder &gt;= 0) {
 46             return lengthCoder;
 47         }
 48         throw new OutOfMemoryError(&quot;Overflow: String length out of range&quot;);
 49     }
 50 
 51     /**
 52      * Mix value length and coder into current length and coder.
<a name="4" id="anc4"></a><span class="line-modified"> 53      * @param current current length</span>
<span class="line-modified"> 54      * @param value   value to mix in</span>
<span class="line-modified"> 55      * @return new length and coder</span>

 56      */
<a name="5" id="anc5"></a><span class="line-modified"> 57     static long mix(long current, boolean value) {</span>
<span class="line-modified"> 58         return checkOverflow(current + (value ? 4 : 5));</span>
 59     }
 60 
 61     /**
 62      * Mix value length and coder into current length and coder.
<a name="6" id="anc6"></a><span class="line-modified"> 63      * @param current current length</span>
<span class="line-modified"> 64      * @param value   value to mix in</span>
<span class="line-modified"> 65      * @return new length and coder</span>

 66      */
<a name="7" id="anc7"></a><span class="line-modified"> 67     static long mix(long current, byte value) {</span>
<span class="line-modified"> 68         return mix(current, (int)value);</span>
 69     }
 70 
 71     /**
 72      * Mix value length and coder into current length and coder.
<a name="8" id="anc8"></a><span class="line-modified"> 73      * @param current current length</span>
<span class="line-modified"> 74      * @param value   value to mix in</span>
<span class="line-modified"> 75      * @return new length and coder</span>

 76      */
<a name="9" id="anc9"></a><span class="line-modified"> 77     static long mix(long current, char value) {</span>
<span class="line-modified"> 78         return checkOverflow(current + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);</span>
 79     }
 80 
 81     /**
 82      * Mix value length and coder into current length and coder.
<a name="10" id="anc10"></a><span class="line-modified"> 83      * @param current current length</span>
<span class="line-modified"> 84      * @param value   value to mix in</span>
<span class="line-modified"> 85      * @return new length and coder</span>

 86      */
<a name="11" id="anc11"></a><span class="line-modified"> 87     static long mix(long current, short value) {</span>
<span class="line-modified"> 88         return mix(current, (int)value);</span>
 89     }
 90 
 91     /**
 92      * Mix value length and coder into current length and coder.
<a name="12" id="anc12"></a><span class="line-modified"> 93      * @param current current length</span>
<span class="line-modified"> 94      * @param value   value to mix in</span>
<span class="line-modified"> 95      * @return new length and coder</span>

 96      */
<a name="13" id="anc13"></a><span class="line-modified"> 97     static long mix(long current, int value) {</span>
<span class="line-modified"> 98         return checkOverflow(current + Integer.stringSize(value));</span>
 99     }
100 
101     /**
102      * Mix value length and coder into current length and coder.
<a name="14" id="anc14"></a><span class="line-modified">103      * @param current current length</span>
<span class="line-modified">104      * @param value   value to mix in</span>
<span class="line-modified">105      * @return new length and coder</span>

106      */
<a name="15" id="anc15"></a><span class="line-modified">107     static long mix(long current, long value) {</span>
<span class="line-modified">108         return checkOverflow(current + Long.stringSize(value));</span>
109     }
110 
111     /**
112      * Mix value length and coder into current length and coder.
<a name="16" id="anc16"></a><span class="line-modified">113      * @param current current length</span>
<span class="line-modified">114      * @param value   value to mix in</span>
<span class="line-modified">115      * @return new length and coder</span>

116      */
<a name="17" id="anc17"></a><span class="line-modified">117     static long mix(long current, String value) {</span>
<span class="line-modified">118         current += value.length();</span>
119         if (value.coder() == String.UTF16) {
<a name="18" id="anc18"></a><span class="line-modified">120             current |= UTF16;</span>
121         }
<a name="19" id="anc19"></a><span class="line-modified">122         return checkOverflow(current);</span>
123     }
124 
125     /**
126      * Prepends the stringly representation of boolean value into buffer,
127      * given the coder and final index. Index is measured in chars, not in bytes!
128      *
129      * @param indexCoder final char index in the buffer, along with coder packed
130      *                   into higher bits.
131      * @param buf        buffer to append to
132      * @param value      boolean value to encode
133      * @return           updated index (coder value retained)
134      */
<a name="20" id="anc20"></a><span class="line-modified">135     static long prepend(long indexCoder, byte[] buf, boolean value) {</span>
136         int index = (int)indexCoder;
137         if (indexCoder &lt; UTF16) {
138             if (value) {
139                 buf[--index] = &#39;e&#39;;
140                 buf[--index] = &#39;u&#39;;
141                 buf[--index] = &#39;r&#39;;
142                 buf[--index] = &#39;t&#39;;
143             } else {
144                 buf[--index] = &#39;e&#39;;
145                 buf[--index] = &#39;s&#39;;
146                 buf[--index] = &#39;l&#39;;
147                 buf[--index] = &#39;a&#39;;
148                 buf[--index] = &#39;f&#39;;
149             }
150             return index;
151         } else {
152             if (value) {
153                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
154                 StringUTF16.putChar(buf, --index, &#39;u&#39;);
155                 StringUTF16.putChar(buf, --index, &#39;r&#39;);
156                 StringUTF16.putChar(buf, --index, &#39;t&#39;);
157             } else {
158                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
159                 StringUTF16.putChar(buf, --index, &#39;s&#39;);
160                 StringUTF16.putChar(buf, --index, &#39;l&#39;);
161                 StringUTF16.putChar(buf, --index, &#39;a&#39;);
162                 StringUTF16.putChar(buf, --index, &#39;f&#39;);
163             }
164             return index | UTF16;
165         }
166     }
167 
168     /**
<a name="21" id="anc21"></a><span class="line-modified">169      * Prepends the stringly representation of byte value into buffer,</span>
170      * given the coder and final index. Index is measured in chars, not in bytes!
171      *
172      * @param indexCoder final char index in the buffer, along with coder packed
173      *                   into higher bits.
174      * @param buf        buffer to append to
<a name="22" id="anc22"></a><span class="line-modified">175      * @param value      byte value to encode</span>


176      * @return           updated index (coder value retained)
177      */
<a name="23" id="anc23"></a><span class="line-modified">178     static long prepend(long indexCoder, byte[] buf, byte value) {</span>
<span class="line-modified">179         return prepend(indexCoder, buf, (int)value);</span>






















180     }
181 
182     /**
183      * Prepends the stringly representation of char value into buffer,
184      * given the coder and final index. Index is measured in chars, not in bytes!
185      *
186      * @param indexCoder final char index in the buffer, along with coder packed
187      *                   into higher bits.
188      * @param buf        buffer to append to
189      * @param value      char value to encode
190      * @return           updated index (coder value retained)
191      */
<a name="24" id="anc24"></a><span class="line-modified">192     static long prepend(long indexCoder, byte[] buf, char value) {</span>
193         if (indexCoder &lt; UTF16) {
194             buf[(int)(--indexCoder)] = (byte) (value &amp; 0xFF);
195         } else {
196             StringUTF16.putChar(buf, (int)(--indexCoder), value);
197         }
198         return indexCoder;
199     }
200 
201     /**
<a name="25" id="anc25"></a><span class="line-modified">202      * Prepends the stringly representation of short value into buffer,</span>
203      * given the coder and final index. Index is measured in chars, not in bytes!
204      *
205      * @param indexCoder final char index in the buffer, along with coder packed
206      *                   into higher bits.
207      * @param buf        buffer to append to
<a name="26" id="anc26"></a><span class="line-modified">208      * @param value      short value to encode</span>


209      * @return           updated index (coder value retained)
210      */
<a name="27" id="anc27"></a><span class="line-modified">211     static long prepend(long indexCoder, byte[] buf, short value) {</span>
<span class="line-modified">212         return prepend(indexCoder, buf, (int)value);</span>






















213     }
214 
215     /**
216      * Prepends the stringly representation of integer value into buffer,
217      * given the coder and final index. Index is measured in chars, not in bytes!
218      *
219      * @param indexCoder final char index in the buffer, along with coder packed
220      *                   into higher bits.
221      * @param buf        buffer to append to
222      * @param value      integer value to encode
223      * @return           updated index (coder value retained)
224      */
<a name="28" id="anc28"></a><span class="line-modified">225     static long prepend(long indexCoder, byte[] buf, int value) {</span>
226         if (indexCoder &lt; UTF16) {
227             return Integer.getChars(value, (int)indexCoder, buf);
228         } else {
229             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
230         }
231     }
232 
<a name="29" id="anc29"></a>


















233     /**
234      * Prepends the stringly representation of long value into buffer,
235      * given the coder and final index. Index is measured in chars, not in bytes!
236      *
237      * @param indexCoder final char index in the buffer, along with coder packed
238      *                   into higher bits.
239      * @param buf        buffer to append to
240      * @param value      long value to encode
241      * @return           updated index (coder value retained)
242      */
<a name="30" id="anc30"></a><span class="line-modified">243     static long prepend(long indexCoder, byte[] buf, long value) {</span>
244         if (indexCoder &lt; UTF16) {
245             return Long.getChars(value, (int)indexCoder, buf);
246         } else {
247             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
248         }
249     }
250 
<a name="31" id="anc31"></a>


















251     /**
252      * Prepends the stringly representation of String value into buffer,
253      * given the coder and final index. Index is measured in chars, not in bytes!
254      *
255      * @param indexCoder final char index in the buffer, along with coder packed
256      *                   into higher bits.
257      * @param buf        buffer to append to
258      * @param value      String value to encode
259      * @return           updated index (coder value retained)
260      */
<a name="32" id="anc32"></a><span class="line-modified">261     static long prepend(long indexCoder, byte[] buf, String value) {</span>
262         indexCoder -= value.length();
263         if (indexCoder &lt; UTF16) {
264             value.getBytes(buf, (int)indexCoder, String.LATIN1);
265         } else {
266             value.getBytes(buf, (int)indexCoder, String.UTF16);
267         }
268         return indexCoder;
269     }
270 
<a name="33" id="anc33"></a>


















271     /**
272      * Instantiates the String with given buffer and coder
273      * @param buf           buffer to use
274      * @param indexCoder    remaining index (should be zero) and coder
275      * @return String       resulting string
276      */
277     static String newString(byte[] buf, long indexCoder) {
278         // Use the private, non-copying constructor (unsafe!)
279         if (indexCoder == LATIN1) {
280             return new String(buf, String.LATIN1);
281         } else if (indexCoder == UTF16) {
282             return new String(buf, String.UTF16);
283         } else {
284             throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
285         }
286     }
287 
<a name="34" id="anc34"></a>




































288     private static final long LATIN1 = (long)String.LATIN1 &lt;&lt; 32;
289 
290     private static final long UTF16 = (long)String.UTF16 &lt;&lt; 32;
291 
<a name="35" id="anc35"></a>














292     /**
293      * Provides the initial coder for the String.
294      * @return initial coder, adjusted into the upper half
295      */
296     static long initialCoder() {
297         return String.COMPACT_STRINGS ? LATIN1 : UTF16;
298     }
299 
300 }
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
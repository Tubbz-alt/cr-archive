<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/reflect/Method.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.reflect;
 27 
 28 import jdk.internal.HotSpotIntrinsicCandidate;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.reflect.CallerSensitive;
 31 import jdk.internal.reflect.MethodAccessor;
 32 import jdk.internal.reflect.Reflection;
 33 import jdk.internal.vm.annotation.ForceInline;
 34 import sun.reflect.annotation.ExceptionProxy;
 35 import sun.reflect.annotation.TypeNotPresentExceptionProxy;
 36 import sun.reflect.generics.repository.MethodRepository;
 37 import sun.reflect.generics.factory.CoreReflectionFactory;
 38 import sun.reflect.generics.factory.GenericsFactory;
 39 import sun.reflect.generics.scope.MethodScope;
 40 import sun.reflect.annotation.AnnotationType;
 41 import sun.reflect.annotation.AnnotationParser;
 42 import java.lang.annotation.Annotation;
 43 import java.lang.annotation.AnnotationFormatError;
 44 import java.nio.ByteBuffer;
 45 import java.util.StringJoiner;
 46 
 47 /**
 48  * A {@code Method} provides information about, and access to, a single method
 49  * on a class or interface.  The reflected method may be a class method
 50  * or an instance method (including an abstract method).
 51  *
 52  * &lt;p&gt;A {@code Method} permits widening conversions to occur when matching the
 53  * actual parameters to invoke with the underlying method&#39;s formal
 54  * parameters, but it throws an {@code IllegalArgumentException} if a
 55  * narrowing conversion would occur.
 56  *
 57  * @see Member
 58  * @see java.lang.Class
 59  * @see java.lang.Class#getMethods()
 60  * @see java.lang.Class#getMethod(String, Class[])
 61  * @see java.lang.Class#getDeclaredMethods()
 62  * @see java.lang.Class#getDeclaredMethod(String, Class[])
 63  *
 64  * @author Kenneth Russell
 65  * @author Nakul Saraiya
 66  * @since 1.1
 67  */
 68 public final class Method extends Executable {
 69     private Class&lt;?&gt;            clazz;
 70     private int                 slot;
 71     // This is guaranteed to be interned by the VM in the 1.4
 72     // reflection implementation
 73     private String              name;
 74     private Class&lt;?&gt;            returnType;
 75     private Class&lt;?&gt;[]          parameterTypes;
 76     private Class&lt;?&gt;[]          exceptionTypes;
 77     private int                 modifiers;
 78     // Generics and annotations support
 79     private transient String              signature;
 80     // generic info repository; lazily initialized
 81     private transient MethodRepository genericInfo;
 82     private byte[]              annotations;
 83     private byte[]              parameterAnnotations;
 84     private byte[]              annotationDefault;
 85     private volatile MethodAccessor methodAccessor;
 86     // For sharing of MethodAccessors. This branching structure is
 87     // currently only two levels deep (i.e., one root Method and
 88     // potentially many Method objects pointing to it.)
 89     //
 90     // If this branching structure would ever contain cycles, deadlocks can
 91     // occur in annotation code.
 92     private Method              root;
 93 
 94     // Generics infrastructure
 95     private String getGenericSignature() {return signature;}
 96 
 97     // Accessor for factory
 98     private GenericsFactory getFactory() {
 99         // create scope and factory
100         return CoreReflectionFactory.make(this, MethodScope.make(this));
101     }
102 
103     // Accessor for generic info repository
104     @Override
105     MethodRepository getGenericInfo() {
106         // lazily initialize repository if necessary
107         if (genericInfo == null) {
108             // create and cache generic info repository
109             genericInfo = MethodRepository.make(getGenericSignature(),
110                                                 getFactory());
111         }
112         return genericInfo; //return cached repository
113     }
114 
115     /**
116      * Package-private constructor used by ReflectAccess to enable
117      * instantiation of these objects in Java code from the java.lang
118      * package via sun.reflect.LangReflectAccess.
119      */
120     Method(Class&lt;?&gt; declaringClass,
121            String name,
122            Class&lt;?&gt;[] parameterTypes,
123            Class&lt;?&gt; returnType,
124            Class&lt;?&gt;[] checkedExceptions,
125            int modifiers,
126            int slot,
127            String signature,
128            byte[] annotations,
129            byte[] parameterAnnotations,
130            byte[] annotationDefault) {
131         this.clazz = declaringClass;
132         this.name = name;
133         this.parameterTypes = parameterTypes;
134         this.returnType = returnType;
135         this.exceptionTypes = checkedExceptions;
136         this.modifiers = modifiers;
137         this.slot = slot;
138         this.signature = signature;
139         this.annotations = annotations;
140         this.parameterAnnotations = parameterAnnotations;
141         this.annotationDefault = annotationDefault;
142     }
143 
144     /**
145      * Package-private routine (exposed to java.lang.Class via
146      * ReflectAccess) which returns a copy of this Method. The copy&#39;s
147      * &quot;root&quot; field points to this Method.
148      */
149     Method copy() {
150         // This routine enables sharing of MethodAccessor objects
151         // among Method objects which refer to the same underlying
152         // method in the VM. (All of this contortion is only necessary
153         // because of the &quot;accessibility&quot; bit in AccessibleObject,
154         // which implicitly requires that new java.lang.reflect
155         // objects be fabricated for each reflective call on Class
156         // objects.)
157         if (this.root != null)
158             throw new IllegalArgumentException(&quot;Can not copy a non-root Method&quot;);
159 
160         Method res = new Method(clazz, name, parameterTypes, returnType,
161                                 exceptionTypes, modifiers, slot, signature,
162                                 annotations, parameterAnnotations, annotationDefault);
163         res.root = this;
164         // Might as well eagerly propagate this if already present
165         res.methodAccessor = methodAccessor;
166         return res;
167     }
168 
169     /**
170      * Make a copy of a leaf method.
171      */
172     Method leafCopy() {
173         if (this.root == null)
174             throw new IllegalArgumentException(&quot;Can only leafCopy a non-root Method&quot;);
175 
176         Method res = new Method(clazz, name, parameterTypes, returnType,
177                 exceptionTypes, modifiers, slot, signature,
178                 annotations, parameterAnnotations, annotationDefault);
179         res.root = root;
180         res.methodAccessor = methodAccessor;
181         return res;
182     }
183 
184     /**
185      * @throws InaccessibleObjectException {@inheritDoc}
186      * @throws SecurityException {@inheritDoc}
187      */
188     @Override
189     @CallerSensitive
190     public void setAccessible(boolean flag) {
191         AccessibleObject.checkPermission();
192         if (flag) checkCanSetAccessible(Reflection.getCallerClass());
193         setAccessible0(flag);
194     }
195 
196     @Override
197     void checkCanSetAccessible(Class&lt;?&gt; caller) {
198         checkCanSetAccessible(caller, clazz);
199     }
200 
201     @Override
202     Method getRoot() {
203         return root;
204     }
205 
206     @Override
207     boolean hasGenericInformation() {
208         return (getGenericSignature() != null);
209     }
210 
211     @Override
212     byte[] getAnnotationBytes() {
213         return annotations;
214     }
215 
216     /**
217      * Returns the {@code Class} object representing the class or interface
218      * that declares the method represented by this object.
219      */
220     @Override
221     public Class&lt;?&gt; getDeclaringClass() {
222         return clazz;
223     }
224 
225     /**
226      * Returns the name of the method represented by this {@code Method}
227      * object, as a {@code String}.
228      */
229     @Override
230     public String getName() {
231         return name;
232     }
233 
234     /**
235      * {@inheritDoc}
236      */
237     @Override
238     public int getModifiers() {
239         return modifiers;
240     }
241 
242     /**
243      * {@inheritDoc}
244      * @throws GenericSignatureFormatError {@inheritDoc}
245      * @since 1.5
246      */
247     @Override
248     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
249     public TypeVariable&lt;Method&gt;[] getTypeParameters() {
250         if (getGenericSignature() != null)
251             return (TypeVariable&lt;Method&gt;[])getGenericInfo().getTypeParameters();
252         else
253             return (TypeVariable&lt;Method&gt;[])new TypeVariable[0];
254     }
255 
256     /**
257      * Returns a {@code Class} object that represents the formal return type
258      * of the method represented by this {@code Method} object.
259      *
260      * @return the return type for the method this object represents
261      */
262     public Class&lt;?&gt; getReturnType() {
263         return returnType;
264     }
265 
266     /**
267      * Returns a {@code Type} object that represents the formal return
268      * type of the method represented by this {@code Method} object.
269      *
270      * &lt;p&gt;If the return type is a parameterized type,
271      * the {@code Type} object returned must accurately reflect
272      * the actual type parameters used in the source code.
273      *
274      * &lt;p&gt;If the return type is a type variable or a parameterized type, it
275      * is created. Otherwise, it is resolved.
276      *
277      * @return  a {@code Type} object that represents the formal return
278      *     type of the underlying  method
279      * @throws GenericSignatureFormatError
280      *     if the generic method signature does not conform to the format
281      *     specified in
282      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
283      * @throws TypeNotPresentException if the underlying method&#39;s
284      *     return type refers to a non-existent type declaration
285      * @throws MalformedParameterizedTypeException if the
286      *     underlying method&#39;s return typed refers to a parameterized
287      *     type that cannot be instantiated for any reason
288      * @since 1.5
289      */
290     public Type getGenericReturnType() {
291       if (getGenericSignature() != null) {
292         return getGenericInfo().getReturnType();
293       } else { return getReturnType();}
294     }
295 
296     @Override
297     Class&lt;?&gt;[] getSharedParameterTypes() {
298         return parameterTypes;
299     }
300 
301     @Override
302     Class&lt;?&gt;[] getSharedExceptionTypes() {
303         return exceptionTypes;
304     }
305 
306     /**
307      * {@inheritDoc}
308      */
309     @Override
310     public Class&lt;?&gt;[] getParameterTypes() {
311         return parameterTypes.clone();
312     }
313 
314     /**
315      * {@inheritDoc}
316      * @since 1.8
317      */
318     public int getParameterCount() { return parameterTypes.length; }
319 
320 
321     /**
322      * {@inheritDoc}
323      * @throws GenericSignatureFormatError {@inheritDoc}
324      * @throws TypeNotPresentException {@inheritDoc}
325      * @throws MalformedParameterizedTypeException {@inheritDoc}
326      * @since 1.5
327      */
328     @Override
329     public Type[] getGenericParameterTypes() {
330         return super.getGenericParameterTypes();
331     }
332 
333     /**
334      * {@inheritDoc}
335      */
336     @Override
337     public Class&lt;?&gt;[] getExceptionTypes() {
338         return exceptionTypes.clone();
339     }
340 
341     /**
342      * {@inheritDoc}
343      * @throws GenericSignatureFormatError {@inheritDoc}
344      * @throws TypeNotPresentException {@inheritDoc}
345      * @throws MalformedParameterizedTypeException {@inheritDoc}
346      * @since 1.5
347      */
348     @Override
349     public Type[] getGenericExceptionTypes() {
350         return super.getGenericExceptionTypes();
351     }
352 
353     /**
354      * Compares this {@code Method} against the specified object.  Returns
355      * true if the objects are the same.  Two {@code Methods} are the same if
356      * they were declared by the same class and have the same name
357      * and formal parameter types and return type.
358      */
359     public boolean equals(Object obj) {
360         if (obj != null &amp;&amp; obj instanceof Method) {
361             Method other = (Method)obj;
362             if ((getDeclaringClass() == other.getDeclaringClass())
363                 &amp;&amp; (getName() == other.getName())) {
364                 if (!returnType.equals(other.getReturnType()))
365                     return false;
366                 return equalParamTypes(parameterTypes, other.parameterTypes);
367             }
368         }
369         return false;
370     }
371 
372     /**
373      * Returns a hashcode for this {@code Method}.  The hashcode is computed
374      * as the exclusive-or of the hashcodes for the underlying
375      * method&#39;s declaring class name and the method&#39;s name.
376      */
377     public int hashCode() {
378         return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
379     }
380 
381     /**
382      * Returns a string describing this {@code Method}.  The string is
383      * formatted as the method access modifiers, if any, followed by
384      * the method return type, followed by a space, followed by the
385      * class declaring the method, followed by a period, followed by
386      * the method name, followed by a parenthesized, comma-separated
387      * list of the method&#39;s formal parameter types. If the method
388      * throws checked exceptions, the parameter list is followed by a
389      * space, followed by the word &quot;{@code throws}&quot; followed by a
390      * comma-separated list of the thrown exception types.
391      * For example:
392      * &lt;pre&gt;
393      *    public boolean java.lang.Object.equals(java.lang.Object)
394      * &lt;/pre&gt;
395      *
396      * &lt;p&gt;The access modifiers are placed in canonical order as
397      * specified by &quot;The Java Language Specification&quot;.  This is
398      * {@code public}, {@code protected} or {@code private} first,
399      * and then other modifiers in the following order:
400      * {@code abstract}, {@code default}, {@code static}, {@code final},
401      * {@code synchronized}, {@code native}, {@code strictfp}.
402      *
403      * @return a string describing this {@code Method}
404      *
405      * @jls 8.4.3 Method Modifiers
406      * @jls 9.4   Method Declarations
407      * @jls 9.6.1 Annotation Type Elements
408      */
409     public String toString() {
410         return sharedToString(Modifier.methodModifiers(),
411                               isDefault(),
412                               parameterTypes,
413                               exceptionTypes);
414     }
415 
416     @Override
417     void specificToStringHeader(StringBuilder sb) {
418         sb.append(getReturnType().getTypeName()).append(&#39; &#39;);
419         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
420         sb.append(getName());
421     }
422 
423     @Override
424     String toShortString() {
425         StringBuilder sb = new StringBuilder(&quot;method &quot;);
426         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
427         sb.append(getName());
428         sb.append(&#39;(&#39;);
429         StringJoiner sj = new StringJoiner(&quot;,&quot;);
430         for (Class&lt;?&gt; parameterType : getParameterTypes()) {
431             sj.add(parameterType.getTypeName());
432         }
433         sb.append(sj);
434         sb.append(&#39;)&#39;);
435         return sb.toString();
436     }
437 
438     /**
439      * Returns a string describing this {@code Method}, including type
440      * parameters.  The string is formatted as the method access
441      * modifiers, if any, followed by an angle-bracketed
442      * comma-separated list of the method&#39;s type parameters, if any,
443      * including informative bounds of the type parameters, if any,
444      * followed by the method&#39;s generic return type, followed by a
445      * space, followed by the class declaring the method, followed by
446      * a period, followed by the method name, followed by a
447      * parenthesized, comma-separated list of the method&#39;s generic
448      * formal parameter types.
449      *
450      * If this method was declared to take a variable number of
451      * arguments, instead of denoting the last parameter as
452      * &quot;&lt;code&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/code&gt;&quot;, it is denoted as
453      * &quot;&lt;code&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/code&gt;&quot;.
454      *
455      * A space is used to separate access modifiers from one another
456      * and from the type parameters or return type.  If there are no
457      * type parameters, the type parameter list is elided; if the type
458      * parameter list is present, a space separates the list from the
459      * class name.  If the method is declared to throw exceptions, the
460      * parameter list is followed by a space, followed by the word
461      * &quot;{@code throws}&quot; followed by a comma-separated list of the generic
462      * thrown exception types.
463      *
464      * &lt;p&gt;The access modifiers are placed in canonical order as
465      * specified by &quot;The Java Language Specification&quot;.  This is
466      * {@code public}, {@code protected} or {@code private} first,
467      * and then other modifiers in the following order:
468      * {@code abstract}, {@code default}, {@code static}, {@code final},
469      * {@code synchronized}, {@code native}, {@code strictfp}.
470      *
471      * @return a string describing this {@code Method},
472      * include type parameters
473      *
474      * @since 1.5
475      *
476      * @jls 8.4.3 Method Modifiers
477      * @jls 9.4   Method Declarations
478      * @jls 9.6.1 Annotation Type Elements
479      */
480     @Override
481     public String toGenericString() {
482         return sharedToGenericString(Modifier.methodModifiers(), isDefault());
483     }
484 
485     @Override
486     void specificToGenericStringHeader(StringBuilder sb) {
487         Type genRetType = getGenericReturnType();
488         sb.append(genRetType.getTypeName()).append(&#39; &#39;);
489         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);
490         sb.append(getName());
491     }
492 
493     /**
494      * Invokes the underlying method represented by this {@code Method}
495      * object, on the specified object with the specified parameters.
496      * Individual parameters are automatically unwrapped to match
497      * primitive formal parameters, and both primitive and reference
498      * parameters are subject to method invocation conversions as
499      * necessary.
500      *
501      * &lt;p&gt;If the underlying method is static, then the specified {@code obj}
502      * argument is ignored. It may be null.
503      *
504      * &lt;p&gt;If the number of formal parameters required by the underlying method is
505      * 0, the supplied {@code args} array may be of length 0 or null.
506      *
507      * &lt;p&gt;If the underlying method is an instance method, it is invoked
508      * using dynamic method lookup as documented in The Java Language
509      * Specification, section 15.12.4.4; in particular,
510      * overriding based on the runtime type of the target object may occur.
511      *
512      * &lt;p&gt;If the underlying method is static, the class that declared
513      * the method is initialized if it has not already been initialized.
514      *
515      * &lt;p&gt;If the method completes normally, the value it returns is
516      * returned to the caller of invoke; if the value has a primitive
517      * type, it is first appropriately wrapped in an object. However,
518      * if the value has the type of an array of a primitive type, the
519      * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in
520      * other words, an array of primitive type is returned.  If the
521      * underlying method return type is void, the invocation returns
522      * null.
523      *
524      * @param obj  the object the underlying method is invoked from
525      * @param args the arguments used for the method call
526      * @return the result of dispatching the method represented by
527      * this object on {@code obj} with parameters
528      * {@code args}
529      *
530      * @exception IllegalAccessException    if this {@code Method} object
531      *              is enforcing Java language access control and the underlying
532      *              method is inaccessible.
533      * @exception IllegalArgumentException  if the method is an
534      *              instance method and the specified object argument
535      *              is not an instance of the class or interface
536      *              declaring the underlying method (or of a subclass
537      *              or implementor thereof); if the number of actual
538      *              and formal parameters differ; if an unwrapping
539      *              conversion for primitive arguments fails; or if,
540      *              after possible unwrapping, a parameter value
541      *              cannot be converted to the corresponding formal
542      *              parameter type by a method invocation conversion.
543      * @exception InvocationTargetException if the underlying method
544      *              throws an exception.
545      * @exception NullPointerException      if the specified object is null
546      *              and the method is an instance method.
547      * @exception ExceptionInInitializerError if the initialization
548      * provoked by this method fails.
549      */
550     @CallerSensitive
551     @ForceInline // to ensure Reflection.getCallerClass optimization
552     @HotSpotIntrinsicCandidate
553     public Object invoke(Object obj, Object... args)
554         throws IllegalAccessException, IllegalArgumentException,
555            InvocationTargetException
556     {
557         if (!override) {
558             Class&lt;?&gt; caller = Reflection.getCallerClass();
559             checkAccess(caller, clazz,
560                         Modifier.isStatic(modifiers) ? null : obj.getClass(),
561                         modifiers);
562         }
563         MethodAccessor ma = methodAccessor;             // read volatile
564         if (ma == null) {
565             ma = acquireMethodAccessor();
566         }
567         return ma.invoke(obj, args);
568     }
569 
570     /**
571      * Returns {@code true} if this method is a bridge
572      * method; returns {@code false} otherwise.
573      *
574      * @return true if and only if this method is a bridge
575      * method as defined by the Java Language Specification.
576      * @since 1.5
577      */
578     public boolean isBridge() {
579         return (getModifiers() &amp; Modifier.BRIDGE) != 0;
580     }
581 
582     /**
583      * {@inheritDoc}
584      * @since 1.5
585      */
586     @Override
587     public boolean isVarArgs() {
588         return super.isVarArgs();
589     }
590 
591     /**
592      * {@inheritDoc}
593      * @jls 13.1 The Form of a Binary
594      * @since 1.5
595      */
596     @Override
597     public boolean isSynthetic() {
598         return super.isSynthetic();
599     }
600 
601     /**
602      * Returns {@code true} if this method is a default
603      * method; returns {@code false} otherwise.
604      *
605      * A default method is a public non-abstract instance method, that
606      * is, a non-static method with a body, declared in an interface
607      * type.
608      *
609      * @return true if and only if this method is a default
610      * method as defined by the Java Language Specification.
611      * @since 1.8
612      */
613     public boolean isDefault() {
614         // Default methods are public non-abstract instance methods
615         // declared in an interface.
616         return ((getModifiers() &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) ==
617                 Modifier.PUBLIC) &amp;&amp; getDeclaringClass().isInterface();
618     }
619 
620     // NOTE that there is no synchronization used here. It is correct
621     // (though not efficient) to generate more than one MethodAccessor
622     // for a given Method. However, avoiding synchronization will
623     // probably make the implementation more scalable.
624     private MethodAccessor acquireMethodAccessor() {
625         // First check to see if one has been created yet, and take it
626         // if so
627         MethodAccessor tmp = null;
628         if (root != null) tmp = root.getMethodAccessor();
629         if (tmp != null) {
630             methodAccessor = tmp;
631         } else {
632             // Otherwise fabricate one and propagate it up to the root
633             tmp = reflectionFactory.newMethodAccessor(this);
634             setMethodAccessor(tmp);
635         }
636 
637         return tmp;
638     }
639 
640     // Returns MethodAccessor for this Method object, not looking up
641     // the chain to the root
642     MethodAccessor getMethodAccessor() {
643         return methodAccessor;
644     }
645 
646     // Sets the MethodAccessor for this Method object and
647     // (recursively) its root
648     void setMethodAccessor(MethodAccessor accessor) {
649         methodAccessor = accessor;
650         // Propagate up
651         if (root != null) {
652             root.setMethodAccessor(accessor);
653         }
654     }
655 
656     /**
657      * Returns the default value for the annotation member represented by
658      * this {@code Method} instance.  If the member is of a primitive type,
659      * an instance of the corresponding wrapper type is returned. Returns
660      * null if no default is associated with the member, or if the method
661      * instance does not represent a declared member of an annotation type.
662      *
663      * @return the default value for the annotation member represented
664      *     by this {@code Method} instance.
665      * @throws TypeNotPresentException if the annotation is of type
666      *     {@link Class} and no definition can be found for the
667      *     default class value.
668      * @since  1.5
669      */
670     public Object getDefaultValue() {
671         if  (annotationDefault == null)
672             return null;
673         Class&lt;?&gt; memberType = AnnotationType.invocationHandlerReturnType(
674             getReturnType());
675         Object result = AnnotationParser.parseMemberValue(
676             memberType, ByteBuffer.wrap(annotationDefault),
677             SharedSecrets.getJavaLangAccess().
678                 getConstantPool(getDeclaringClass()),
679             getDeclaringClass());
680         if (result instanceof ExceptionProxy) {
681             if (result instanceof TypeNotPresentExceptionProxy) {
682                 TypeNotPresentExceptionProxy proxy = (TypeNotPresentExceptionProxy)result;
683                 throw new TypeNotPresentException(proxy.typeName(), proxy.getCause());
684             }
685             throw new AnnotationFormatError(&quot;Invalid default: &quot; + this);
686         }
687         return result;
688     }
689 
690     /**
691      * {@inheritDoc}
692      * @throws NullPointerException  {@inheritDoc}
693      * @since 1.5
694      */
695     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
696         return super.getAnnotation(annotationClass);
697     }
698 
699     /**
700      * {@inheritDoc}
701      * @since 1.5
702      */
703     public Annotation[] getDeclaredAnnotations()  {
704         return super.getDeclaredAnnotations();
705     }
706 
707     /**
708      * {@inheritDoc}
709      * @since 1.5
710      */
711     @Override
712     public Annotation[][] getParameterAnnotations() {
713         return sharedGetParameterAnnotations(parameterTypes, parameterAnnotations);
714     }
715 
716     /**
717      * {@inheritDoc}
718      * @since 1.8
719      */
720     @Override
721     public AnnotatedType getAnnotatedReturnType() {
722         return getAnnotatedReturnType0(getGenericReturnType());
723     }
724 
725     @Override
726     boolean handleParameterNumberMismatch(int resultLength, int numParameters) {
727         throw new AnnotationFormatError(&quot;Parameter annotations don&#39;t match number of parameters&quot;);
728     }
729 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/regex/PrintPattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PatternSyntaxException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/PrintPattern.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
 28 import java.util.HashMap;
 29 import java.util.regex.Pattern.CharPredicate;
 30 import static java.util.regex.ASCII.*;
 31 
 32 /**
 33  * A utility class to print out the pattern node tree.
 34  */
 35 
 36 class PrintPattern {
 37 
 38     private static HashMap&lt;Pattern.Node, Integer&gt; ids = new HashMap&lt;&gt;();
 39 
 40     private static void print(Pattern.Node node, String text, int depth) {
 41         if (!ids.containsKey(node))
 42             ids.put(node, ids.size());
<span class="line-modified"> 43         print(&quot;%6d:%&quot; + (depth==0? &quot;&quot;: depth&lt;&lt;1) + &quot;s&lt;%s&gt;&quot;, ids.get(node), &quot;&quot;, text);</span>

 44         if (ids.containsKey(node.next))
<span class="line-modified"> 45             print(&quot; (=&gt;%d)&quot;, ids.get(node.next));</span>
<span class="line-modified"> 46         print(&quot;%n&quot;);</span>
 47     }
 48 
 49     private static void print(String s, int depth) {
<span class="line-modified"> 50         print(&quot;       %&quot; + (depth==0?&quot;&quot;:depth&lt;&lt;1) + &quot;s&lt;%s&gt;%n&quot;, &quot;&quot;, s);</span>
<span class="line-modified"> 51     }</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53     private static void print(String fmt, Object ... args) {</span>
<span class="line-removed"> 54         System.err.printf(fmt, args);</span>
 55     }
 56 
 57     private static String toStringCPS(int[] cps) {
 58         StringBuilder sb = new StringBuilder(cps.length);
 59         for (int cp : cps)
 60             sb.append(toStringCP(cp));
 61         return sb.toString();
 62     }
 63 
 64     private static String toStringCP(int cp) {
 65         return (isPrint(cp) ? &quot;&quot; + (char)cp
 66                             : &quot;\\u&quot; + Integer.toString(cp, 16));
 67     }
 68 
 69     private static String toStringRange(int min, int max) {
 70        if (max == Pattern.MAX_REPS) {
 71            if (min == 0)
 72                return &quot; * &quot;;
 73            else if (min == 1)
 74                return &quot; + &quot;;
</pre>
<hr />
<pre>
178             } else if (node instanceof Pattern.BranchConn) {
179                 return;
180             } else if (node instanceof Pattern.CharProperty) {
181                 str = pmap.get(((Pattern.CharProperty)node).predicate);
182                 if (str == null)
183                     str = toString(node);
184                 else
185                     str = &quot;Single \&quot;&quot; + str + &quot;\&quot;&quot;;
186                 print(node, str, depth);
187             } else if (node instanceof Pattern.SliceNode) {
188                 str = name + &quot;  \&quot;&quot; +
189                       toStringCPS(((Pattern.SliceNode)node).buffer) + &quot;\&quot;&quot;;
190                 print(node, str, depth);
191             } else if (node instanceof Pattern.CharPropertyGreedy) {
192                 Pattern.CharPropertyGreedy gcp = (Pattern.CharPropertyGreedy)node;
193                 String pstr = pmap.get(gcp.predicate);
194                 if (pstr == null)
195                     pstr = gcp.predicate.toString();
196                 else
197                     pstr = &quot;Single \&quot;&quot; + pstr + &quot;\&quot;&quot;;
<span class="line-modified">198                 str = name + &quot; &quot; + pstr + ((gcp.cmin == 0) ? &quot;*&quot; : &quot;+&quot;);</span>






199                 print(node, str, depth);
200             } else if (node instanceof Pattern.BackRef) {
201                 str = &quot;GroupBackRef &quot; + ((Pattern.BackRef)node).groupIndex / 2;
202                 print(node, str, depth);
203             } else if (node instanceof Pattern.LastNode) {
204                 print(node, &quot;END&quot;, depth);
205             } else if (node == Pattern.accept) {
206                 return;
207             } else {
208                 print(node, name, depth);
209             }
210             node = node.next;
211         }
212     }
213 
214     public static void main(String[] args) {
215         Pattern p = Pattern.compile(args[0]);
216         System.out.println(&quot;   Pattern: &quot; + p);
217         walk(p.root, 0);
218     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
 28 import java.util.HashMap;
 29 import java.util.regex.Pattern.CharPredicate;
 30 import static java.util.regex.ASCII.*;
 31 
 32 /**
 33  * A utility class to print out the pattern node tree.
 34  */
 35 
 36 class PrintPattern {
 37 
 38     private static HashMap&lt;Pattern.Node, Integer&gt; ids = new HashMap&lt;&gt;();
 39 
 40     private static void print(Pattern.Node node, String text, int depth) {
 41         if (!ids.containsKey(node))
 42             ids.put(node, ids.size());
<span class="line-modified"> 43         System.out.printf(&quot;%6d:%&quot; + (depth==0? &quot;&quot;: depth&lt;&lt;1) + &quot;s&lt;%s&gt;&quot;,</span>
<span class="line-added"> 44                           ids.get(node), &quot;&quot;, text);</span>
 45         if (ids.containsKey(node.next))
<span class="line-modified"> 46             System.out.printf(&quot; (=&gt;%d)&quot;, ids.get(node.next));</span>
<span class="line-modified"> 47         System.out.printf(&quot;%n&quot;);</span>
 48     }
 49 
 50     private static void print(String s, int depth) {
<span class="line-modified"> 51         System.out.printf(&quot;       %&quot; + (depth==0?&quot;&quot;:depth&lt;&lt;1) + &quot;s&lt;%s&gt;%n&quot;,</span>
<span class="line-modified"> 52                           &quot;&quot;, s);</span>



 53     }
 54 
 55     private static String toStringCPS(int[] cps) {
 56         StringBuilder sb = new StringBuilder(cps.length);
 57         for (int cp : cps)
 58             sb.append(toStringCP(cp));
 59         return sb.toString();
 60     }
 61 
 62     private static String toStringCP(int cp) {
 63         return (isPrint(cp) ? &quot;&quot; + (char)cp
 64                             : &quot;\\u&quot; + Integer.toString(cp, 16));
 65     }
 66 
 67     private static String toStringRange(int min, int max) {
 68        if (max == Pattern.MAX_REPS) {
 69            if (min == 0)
 70                return &quot; * &quot;;
 71            else if (min == 1)
 72                return &quot; + &quot;;
</pre>
<hr />
<pre>
176             } else if (node instanceof Pattern.BranchConn) {
177                 return;
178             } else if (node instanceof Pattern.CharProperty) {
179                 str = pmap.get(((Pattern.CharProperty)node).predicate);
180                 if (str == null)
181                     str = toString(node);
182                 else
183                     str = &quot;Single \&quot;&quot; + str + &quot;\&quot;&quot;;
184                 print(node, str, depth);
185             } else if (node instanceof Pattern.SliceNode) {
186                 str = name + &quot;  \&quot;&quot; +
187                       toStringCPS(((Pattern.SliceNode)node).buffer) + &quot;\&quot;&quot;;
188                 print(node, str, depth);
189             } else if (node instanceof Pattern.CharPropertyGreedy) {
190                 Pattern.CharPropertyGreedy gcp = (Pattern.CharPropertyGreedy)node;
191                 String pstr = pmap.get(gcp.predicate);
192                 if (pstr == null)
193                     pstr = gcp.predicate.toString();
194                 else
195                     pstr = &quot;Single \&quot;&quot; + pstr + &quot;\&quot;&quot;;
<span class="line-modified">196                 str = name + &quot; &quot; + pstr;</span>
<span class="line-added">197                 if (gcp.cmin == 0)</span>
<span class="line-added">198                     str += &quot;*&quot;;</span>
<span class="line-added">199                 else if (gcp.cmin == 1)</span>
<span class="line-added">200                     str += &quot;+&quot;;</span>
<span class="line-added">201                 else</span>
<span class="line-added">202                     str += &quot;{&quot; + gcp.cmin + &quot;,}&quot;;</span>
203                 print(node, str, depth);
204             } else if (node instanceof Pattern.BackRef) {
205                 str = &quot;GroupBackRef &quot; + ((Pattern.BackRef)node).groupIndex / 2;
206                 print(node, str, depth);
207             } else if (node instanceof Pattern.LastNode) {
208                 print(node, &quot;END&quot;, depth);
209             } else if (node == Pattern.accept) {
210                 return;
211             } else {
212                 print(node, name, depth);
213             }
214             node = node.next;
215         }
216     }
217 
218     public static void main(String[] args) {
219         Pattern p = Pattern.compile(args[0]);
220         System.out.println(&quot;   Pattern: &quot; + p);
221         walk(p.root, 0);
222     }
</pre>
</td>
</tr>
</table>
<center><a href="PatternSyntaxException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
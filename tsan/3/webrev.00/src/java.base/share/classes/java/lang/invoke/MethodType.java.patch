diff a/src/java.base/share/classes/java/lang/invoke/MethodType.java b/src/java.base/share/classes/java/lang/invoke/MethodType.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodType.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodType.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -44,13 +44,15 @@
 
 import jdk.internal.vm.annotation.Stable;
 import sun.invoke.util.BytecodeDescriptor;
 import sun.invoke.util.VerifyType;
 import sun.invoke.util.Wrapper;
+import sun.security.util.SecurityConstants;
 
 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
+import static java.lang.invoke.MethodType.fromDescriptor;
 
 /**
  * A method type represents the arguments and return type accepted and
  * returned by a method handle, or the arguments and return type passed
  * and expected  by a method handle caller.  Method types must be properly
@@ -87,12 +89,13 @@
  * Like classes and strings, method types can also be represented directly
  * in a class file's constant pool as constants.
  * A method type may be loaded by an {@code ldc} instruction which refers
  * to a suitable {@code CONSTANT_MethodType} constant pool entry.
  * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
- * (For full details on method type constants,
- * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
+ * (For full details on method type constants, see sections {@jvms
+ * 4.4.8} and {@jvms 5.4.3.5} of the Java Virtual Machine
+ * Specification.)
  * <p>
  * When the JVM materializes a {@code MethodType} from a descriptor string,
  * all classes named in the descriptor must be accessible, and will be loaded.
  * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
  * This loading may occur at any time before the {@code MethodType} object is first derived.
@@ -102,10 +105,11 @@
 public final
 class MethodType
         implements Constable,
                    TypeDescriptor.OfMethod<Class<?>, MethodType>,
                    java.io.Serializable {
+    @java.io.Serial
     private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
 
     // The rtype and ptypes fields define the structural identity of the method type:
     private final @Stable Class<?>   rtype;
     private final @Stable Class<?>[] ptypes;
@@ -137,31 +141,34 @@
      *  It limits both JVM signatures and method type objects.
      *  The longest possible invocation will look like
      *  {@code staticMethod(arg1, arg2, ..., arg255)} or
      *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
      */
-    /*non-public*/ static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.
+    /*non-public*/
+    static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.
 
     /** This number is the maximum arity of a method handle, 254.
      *  It is derived from the absolute JVM-imposed arity by subtracting one,
      *  which is the slot occupied by the method handle itself at the
      *  beginning of the argument list used to invoke the method handle.
      *  The longest possible invocation will look like
      *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
      */
     // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
-    /*non-public*/ static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver
+    /*non-public*/
+    static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver
 
     /** This number is the maximum arity of a method handle invoker, 253.
      *  It is derived from the absolute JVM-imposed arity by subtracting two,
      *  which are the slots occupied by invoke method handle, and the
      *  target method handle, which are both at the beginning of the argument
      *  list used to invoke the target method handle.
      *  The longest possible invocation will look like
      *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
      */
-    /*non-public*/ static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker
+    /*non-public*/
+    static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker
 
     private static void checkRtype(Class<?> rtype) {
         Objects.requireNonNull(rtype);
     }
     private static void checkPtype(Class<?> ptype) {
@@ -205,12 +212,11 @@
      * @param ptypes the parameter types
      * @return a method type with the given components
      * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
      * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
      */
-    public static
-    MethodType methodType(Class<?> rtype, Class<?>[] ptypes) {
+    public static MethodType methodType(Class<?> rtype, Class<?>[] ptypes) {
         return makeImpl(rtype, ptypes, false);
     }
 
     /**
      * Finds or creates a method type with the given components.
@@ -219,12 +225,11 @@
      * @param ptypes the parameter types
      * @return a method type with the given components
      * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
      * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
      */
-    public static
-    MethodType methodType(Class<?> rtype, List<Class<?>> ptypes) {
+    public static MethodType methodType(Class<?> rtype, List<Class<?>> ptypes) {
         boolean notrust = false;  // random List impl. could return evil ptypes array
         return makeImpl(rtype, listToArray(ptypes), notrust);
     }
 
     private static Class<?>[] listToArray(List<Class<?>> ptypes) {
@@ -242,12 +247,11 @@
      * @param ptypes the remaining parameter types
      * @return a method type with the given components
      * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
      * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
      */
-    public static
-    MethodType methodType(Class<?> rtype, Class<?> ptype0, Class<?>... ptypes) {
+    public static MethodType methodType(Class<?> rtype, Class<?> ptype0, Class<?>... ptypes) {
         Class<?>[] ptypes1 = new Class<?>[1+ptypes.length];
         ptypes1[0] = ptype0;
         System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
         return makeImpl(rtype, ptypes1, true);
     }
@@ -258,12 +262,11 @@
      * The resulting method has no parameter types.
      * @param rtype  the return type
      * @return a method type with the given return value
      * @throws NullPointerException if {@code rtype} is null
      */
-    public static
-    MethodType methodType(Class<?> rtype) {
+    public static MethodType methodType(Class<?> rtype) {
         return makeImpl(rtype, NO_PTYPES, true);
     }
 
     /**
      * Finds or creates a method type with the given components.
@@ -273,12 +276,11 @@
      * @param ptype0 the parameter type
      * @return a method type with the given return value and parameter type
      * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
      * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
      */
-    public static
-    MethodType methodType(Class<?> rtype, Class<?> ptype0) {
+    public static MethodType methodType(Class<?> rtype, Class<?> ptype0) {
         return makeImpl(rtype, new Class<?>[]{ ptype0 }, true);
     }
 
     /**
      * Finds or creates a method type with the given components.
@@ -288,24 +290,23 @@
      * @param rtype  the return type
      * @param ptypes the method type which supplies the parameter types
      * @return a method type with the given components
      * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
      */
-    public static
-    MethodType methodType(Class<?> rtype, MethodType ptypes) {
+    public static MethodType methodType(Class<?> rtype, MethodType ptypes) {
         return makeImpl(rtype, ptypes.ptypes, true);
     }
 
     /**
      * Sole factory method to find or create an interned method type.
      * @param rtype desired return type
      * @param ptypes desired parameter types
      * @param trusted whether the ptypes can be used without cloning
      * @return the unique method type of the desired structure
      */
-    /*trusted*/ static
-    MethodType makeImpl(Class<?> rtype, Class<?>[] ptypes, boolean trusted) {
+    /*trusted*/
+    static MethodType makeImpl(Class<?> rtype, Class<?>[] ptypes, boolean trusted) {
         if (ptypes.length == 0) {
             ptypes = NO_PTYPES; trusted = true;
         }
         MethodType primordialMT = new MethodType(rtype, ptypes);
         MethodType mt = internTable.get(primordialMT);
@@ -337,12 +338,11 @@
      * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
      * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
      * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
      * @see #genericMethodType(int)
      */
-    public static
-    MethodType genericMethodType(int objectArgCount, boolean finalArray) {
+    public static MethodType genericMethodType(int objectArgCount, boolean finalArray) {
         MethodType mt;
         checkSlotCount(objectArgCount);
         int ivarargs = (!finalArray ? 0 : 1);
         int ootIndex = objectArgCount*2 + ivarargs;
         if (ootIndex < objectOnlyTypes.length) {
@@ -366,12 +366,11 @@
      * @param objectArgCount number of parameters
      * @return a generally applicable method type, for all calls of the given argument count
      * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255
      * @see #genericMethodType(int, boolean)
      */
-    public static
-    MethodType genericMethodType(int objectArgCount) {
+    public static MethodType genericMethodType(int objectArgCount) {
         return genericMethodType(objectArgCount, false);
     }
 
     /**
      * Finds or creates a method type with a single different parameter type.
@@ -474,11 +473,12 @@
      *                                  or if {@code start} is greater than {@code end}
      * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
      *                                  or if the resulting method type would have more than 255 parameter slots
      * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
      */
-    /*non-public*/ MethodType replaceParameterTypes(int start, int end, Class<?>... ptypesToInsert) {
+    /*non-public*/
+    MethodType replaceParameterTypes(int start, int end, Class<?>... ptypesToInsert) {
         if (start == end)
             return insertParameterTypes(start, ptypesToInsert);
         int len = ptypes.length;
         if (!(0 <= start && start <= end && end <= len))
             throw newIndexOutOfBoundsException("start="+start+" end="+end);
@@ -492,11 +492,12 @@
      * @param arrayType any array type
      * @param pos position at which to spread
      * @param arrayLength the number of parameter types to change
      * @return the resulting type
      */
-    /*non-public*/ MethodType asSpreaderType(Class<?> arrayType, int pos, int arrayLength) {
+    /*non-public*/
+    MethodType asSpreaderType(Class<?> arrayType, int pos, int arrayLength) {
         assert(parameterCount() >= arrayLength);
         int spreadPos = pos;
         if (arrayLength == 0)  return this;  // nothing to change
         if (arrayType == Object[].class) {
             if (isGeneric())  return this;  // nothing to change
@@ -522,11 +523,12 @@
     }
 
     /** Return the leading parameter type, which must exist and be a reference.
      *  @return the leading parameter type, after error checks
      */
-    /*non-public*/ Class<?> leadingReferenceParameter() {
+    /*non-public*/
+    Class<?> leadingReferenceParameter() {
         Class<?> ptype;
         if (ptypes.length == 0 ||
             (ptype = ptypes[0]).isPrimitive())
             throw newIllegalArgumentException("no leading reference parameter");
         return ptype;
@@ -536,11 +538,12 @@
      * @param arrayType any array type
      * @param pos position at which to insert parameters
      * @param arrayLength the number of parameter types to insert
      * @return the resulting type
      */
-    /*non-public*/ MethodType asCollectorType(Class<?> arrayType, int pos, int arrayLength) {
+    /*non-public*/
+    MethodType asCollectorType(Class<?> arrayType, int pos, int arrayLength) {
         assert(parameterCount() >= 1);
         assert(pos < ptypes.length);
         assert(ptypes[pos].isAssignableFrom(arrayType));
         MethodType res;
         if (arrayType == Object[].class) {
@@ -647,21 +650,23 @@
      * Erases all reference types to {@code Object}, and all subword types to {@code int}.
      * This is the reduced type polymorphism used by private methods
      * such as {@link MethodHandle#invokeBasic invokeBasic}.
      * @return a version of the original type with all reference and subword types replaced
      */
-    /*non-public*/ MethodType basicType() {
+    /*non-public*/
+    MethodType basicType() {
         return form.basicType();
     }
 
     private static final @Stable Class<?>[] METHOD_HANDLE_ARRAY
             = new Class<?>[] { MethodHandle.class };
 
     /**
      * @return a version of the original type with MethodHandle prepended as the first argument
      */
-    /*non-public*/ MethodType invokerType() {
+    /*non-public*/
+    MethodType invokerType() {
         return insertParameterTypes(0, METHOD_HANDLE_ARRAY);
     }
 
     /**
      * Converts all types, both reference and primitive, to {@code Object}.
@@ -672,11 +677,12 @@
      */
     public MethodType generic() {
         return genericMethodType(parameterCount());
     }
 
-    /*non-public*/ boolean isGeneric() {
+    /*non-public*/
+    boolean isGeneric() {
         return this == erase() && !hasPrimitives();
     }
 
     /**
      * Converts all primitive types to their corresponding wrapper types.
@@ -923,12 +929,12 @@
         if (argc <= 1) {
             if (argc == 1 && !canConvert(srcTypes[0], dstTypes[0]))
                 return false;
             return true;
         }
-        if ((oldForm.primitiveParameterCount() == 0 && oldForm.erasedType == this) ||
-            (newForm.primitiveParameterCount() == 0 && newForm.erasedType == newType)) {
+        if ((!oldForm.hasPrimitives() && oldForm.erasedType == this) ||
+            (!newForm.hasPrimitives() && newForm.erasedType == newType)) {
             // Somewhat complicated test to avoid a loop of 2 or more trips.
             // If either type has only Object parameters, we know we can convert.
             assert(canConvertParameters(srcTypes, dstTypes));
             return true;
         }
@@ -1059,70 +1065,28 @@
      * <p>
      * This method is included for the benefit of applications that must
      * generate bytecodes that process method handles and invokedynamic.
      * @return the number of JVM stack slots for this type's parameters
      */
-    /*non-public*/ int parameterSlotCount() {
+    /*non-public*/
+    int parameterSlotCount() {
         return form.parameterSlotCount();
     }
 
-    /*non-public*/ Invokers invokers() {
+    /*non-public*/
+    Invokers invokers() {
         Invokers inv = invokers;
         if (inv != null)  return inv;
         invokers = inv = new Invokers(this);
         return inv;
     }
 
-    /** Reports the number of JVM stack slots which carry all parameters including and after
-     * the given position, which must be in the range of 0 to
-     * {@code parameterCount} inclusive.  Successive parameters are
-     * more shallowly stacked, and parameters are indexed in the bytecodes
-     * according to their trailing edge.  Thus, to obtain the depth
-     * in the outgoing call stack of parameter {@code N}, obtain
-     * the {@code parameterSlotDepth} of its trailing edge
-     * at position {@code N+1}.
-     * <p>
-     * Parameters of type {@code long} and {@code double} occupy
-     * two stack slots (for historical reasons) and all others occupy one.
-     * Therefore, the number returned is the number of arguments
-     * <em>including</em> and <em>after</em> the given parameter,
-     * <em>plus</em> the number of long or double arguments
-     * at or after the argument for the given parameter.
-     * <p>
-     * This method is included for the benefit of applications that must
-     * generate bytecodes that process method handles and invokedynamic.
-     * @param num an index (zero-based, inclusive) within the parameter types
-     * @return the index of the (shallowest) JVM stack slot transmitting the
-     *         given parameter
-     * @throws IllegalArgumentException if {@code num} is negative or greater than {@code parameterCount()}
-     */
-    /*non-public*/ int parameterSlotDepth(int num) {
-        if (num < 0 || num > ptypes.length)
-            parameterType(num);  // force a range check
-        return form.parameterToArgSlot(num-1);
-    }
-
-    /** Reports the number of JVM stack slots required to receive a return value
-     * from a method of this type.
-     * If the {@link #returnType() return type} is void, it will be zero,
-     * else if the return type is long or double, it will be two, else one.
-     * <p>
-     * This method is included for the benefit of applications that must
-     * generate bytecodes that process method handles and invokedynamic.
-     * @return the number of JVM stack slots (0, 1, or 2) for this type's return value
-     * Will be removed for PFD.
-     */
-    /*non-public*/ int returnSlotCount() {
-        return form.returnSlotCount();
-    }
-
     /**
      * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
-     * Any class or interface name embedded in the descriptor string
-     * will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}
-     * on the given loader (or if it is null, on the system class loader).
+     * Any class or interface name embedded in the descriptor string will be
+     * resolved by the given loader (or if it is null, on the system class loader).
      * <p>
      * Note that it is possible to encounter method types which cannot be
      * constructed by this method, because their component types are
      * not all reachable from a common class loader.
      * <p>
@@ -1132,14 +1096,23 @@
      * @param loader the class loader in which to look up the types
      * @return a method type matching the bytecode-level type descriptor
      * @throws NullPointerException if the string is null
      * @throws IllegalArgumentException if the string is not well-formed
      * @throws TypeNotPresentException if a named type cannot be found
+     * @throws SecurityException if the security manager is present and
+     *         {@code loader} is {@code null} and the caller does not have the
+     *         {@link RuntimePermission}{@code ("getClassLoader")}
      */
     public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
         throws IllegalArgumentException, TypeNotPresentException
     {
+        if (loader == null) {
+            SecurityManager sm = System.getSecurityManager();
+            if (sm != null) {
+                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
+            }
+        }
         return fromDescriptor(descriptor,
                               (loader == null) ? ClassLoader.getSystemClassLoader() : loader);
     }
 
     /**
@@ -1197,11 +1170,12 @@
     @Override
     public String descriptorString() {
         return toMethodDescriptorString();
     }
 
-    /*non-public*/ static String toFieldDescriptorString(Class<?> cls) {
+    /*non-public*/
+    static String toFieldDescriptorString(Class<?> cls) {
         return BytecodeDescriptor.unparse(cls);
     }
 
     /**
      * Return a nominal descriptor for this instance, if one can be
@@ -1227,10 +1201,11 @@
     /// Serialization.
 
     /**
      * There are no serializable fields for {@code MethodType}.
      */
+    @java.io.Serial
     private static final java.io.ObjectStreamField[] serialPersistentFields = { };
 
     /**
      * Save the {@code MethodType} instance to a stream.
      *
@@ -1249,10 +1224,11 @@
      * For example, null values, or {@code void} parameter types,
      * will lead to exceptions during deserialization.
      * @param s the stream to write the object to
      * @throws java.io.IOException if there is a problem writing the object
      */
+    @java.io.Serial
     private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
         s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
         s.writeObject(returnType());
         s.writeObject(parameterArray());
     }
@@ -1268,10 +1244,11 @@
      * @throws java.io.IOException if there is a problem reading the object
      * @throws ClassNotFoundException if one of the component classes cannot be resolved
      * @see #readResolve
      * @see #writeObject
      */
+    @java.io.Serial
     private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
         // Assign temporary defaults in case this object escapes
         MethodType_init(void.class, NO_PTYPES);
 
         s.defaultReadObject();  // requires serialPersistentFields to be an empty array
@@ -1307,10 +1284,11 @@
     /**
      * Resolves and initializes a {@code MethodType} object
      * after serialization.
      * @return the fully initialized {@code MethodType} object
      */
+    @java.io.Serial
     private Object readResolve() {
         // Do not use a trusted path for deserialization:
         //    return makeImpl(rtype, ptypes, true);
         // Verify all operands, and make sure ptypes is unshared:
         try {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/regex/Grapheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jar/package-info.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Matcher.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Grapheme.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,45 ***</span>
   * questions.
   */
  
  package java.util.regex;
  
  final class Grapheme {
  
      /**
       * Determines if there is an extended  grapheme cluster boundary between two
       * continuing characters {@code cp1} and {@code cp2}.
       * &lt;p&gt;
       * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
       * for the extended grapheme cluster boundary rules
       */
      static boolean isBoundary(int cp1, int cp2) {
          return rules[getType(cp1)][getType(cp2)];
      }
  
      // types
      private static final int OTHER = 0;
      private static final int CR = 1;
      private static final int LF = 2;
      private static final int CONTROL = 3;
      private static final int EXTEND = 4;
<span class="line-modified">!     private static final int RI = 5;</span>
<span class="line-modified">!     private static final int PREPEND = 6;</span>
<span class="line-modified">!     private static final int SPACINGMARK = 7;</span>
<span class="line-modified">!     private static final int L = 8;</span>
<span class="line-modified">!     private static final int V = 9;</span>
<span class="line-modified">!     private static final int T = 10;</span>
<span class="line-modified">!     private static final int LV = 11;</span>
<span class="line-modified">!     private static final int LVT = 12;</span>
  
      private static final int FIRST_TYPE = 0;
<span class="line-modified">!     private static final int LAST_TYPE = 12;</span>
  
      private static boolean[][] rules;
      static {
          rules = new boolean[LAST_TYPE + 1][LAST_TYPE + 1];
<span class="line-modified">!         // default, any + any</span>
          for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
              for (int j = FIRST_TYPE; j &lt;= LAST_TYPE; j++)
                  rules[i][j] = true;
          // GB 6 L x (L | V | LV | VT)
          rules[L][L] = false;
<span class="line-new-header">--- 23,100 ---</span>
   * questions.
   */
  
  package java.util.regex;
  
<span class="line-added">+ import java.util.Objects;</span>
<span class="line-added">+ </span>
  final class Grapheme {
  
      /**
       * Determines if there is an extended  grapheme cluster boundary between two
       * continuing characters {@code cp1} and {@code cp2}.
       * &lt;p&gt;
       * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
       * for the extended grapheme cluster boundary rules
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * Note: this method does not take care of stateful breaking.</span>
       */
      static boolean isBoundary(int cp1, int cp2) {
          return rules[getType(cp1)][getType(cp2)];
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Look for the next extended grapheme cluster boundary in a CharSequence. It assumes</span>
<span class="line-added">+      * the start of the char sequence is a boundary.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification</span>
<span class="line-added">+      * for the extended grapheme cluster boundary rules. The following implementation</span>
<span class="line-added">+      * is based on version 12.0 of the annex.</span>
<span class="line-added">+      * (http://www.unicode.org/reports/tr29/tr29-35.html)</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param src the {@code CharSequence} to be scanned</span>
<span class="line-added">+      * @param off offset to start looking for the next boundary in the src</span>
<span class="line-added">+      * @param limit limit offset in the src (exclusive)</span>
<span class="line-added">+      * @return the next possible boundary</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static int nextBoundary(CharSequence src, int off, int limit) {</span>
<span class="line-added">+         Objects.checkFromToIndex(off, limit, src.length());</span>
<span class="line-added">+ </span>
<span class="line-added">+         int ch0 = Character.codePointAt(src, 0);</span>
<span class="line-added">+         int ret = Character.charCount(ch0);</span>
<span class="line-added">+         int ch1;</span>
<span class="line-added">+         // indicates whether gb11 or gb12 is underway</span>
<span class="line-added">+         int t0 = getGraphemeType(ch0);</span>
<span class="line-added">+         int riCount = t0 == RI ? 1 : 0;</span>
<span class="line-added">+         boolean gb11 = t0 == EXTENDED_PICTOGRAPHIC;</span>
<span class="line-added">+         while (ret &lt; limit) {</span>
<span class="line-added">+             ch1 = Character.codePointAt(src, ret);</span>
<span class="line-added">+             int t1 = getGraphemeType(ch1);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (gb11 &amp;&amp; t0 == ZWJ &amp;&amp; t1 == EXTENDED_PICTOGRAPHIC) {</span>
<span class="line-added">+                 gb11 = false;</span>
<span class="line-added">+             } else if (riCount % 2 == 1 &amp;&amp; t0 == RI &amp;&amp; t1 == RI) {</span>
<span class="line-added">+                 // continue for gb12</span>
<span class="line-added">+             } else if (rules[t0][t1]) {</span>
<span class="line-added">+                 if (ret &gt; off) {</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     gb11 = t1 == EXTENDED_PICTOGRAPHIC;</span>
<span class="line-added">+                     riCount = 0;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             riCount += (t1 == RI) ? 1 : 0;</span>
<span class="line-added">+             t0 = t1;</span>
<span class="line-added">+ </span>
<span class="line-added">+             ret += Character.charCount(ch1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return ret;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // types
      private static final int OTHER = 0;
      private static final int CR = 1;
      private static final int LF = 2;
      private static final int CONTROL = 3;
      private static final int EXTEND = 4;
<span class="line-modified">!     private static final int ZWJ = 5;</span>
<span class="line-modified">!     private static final int RI = 6;</span>
<span class="line-modified">!     private static final int PREPEND = 7;</span>
<span class="line-modified">!     private static final int SPACINGMARK = 8;</span>
<span class="line-modified">!     private static final int L = 9;</span>
<span class="line-modified">!     private static final int V = 10;</span>
<span class="line-modified">!     private static final int T = 11;</span>
<span class="line-modified">!     private static final int LV = 12;</span>
<span class="line-added">+     private static final int LVT = 13;</span>
<span class="line-added">+     private static final int EXTENDED_PICTOGRAPHIC = 14;</span>
  
      private static final int FIRST_TYPE = 0;
<span class="line-modified">!     private static final int LAST_TYPE = 14;</span>
  
      private static boolean[][] rules;
      static {
          rules = new boolean[LAST_TYPE + 1][LAST_TYPE + 1];
<span class="line-modified">!         // GB 999 Any + Any  -&gt; default</span>
          for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
              for (int j = FIRST_TYPE; j &lt;= LAST_TYPE; j++)
                  rules[i][j] = true;
          // GB 6 L x (L | V | LV | VT)
          rules[L][L] = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,17 ***</span>
          rules[V][V] = false;
          rules[V][T] = false;
          // GB 8 (LVT | T) x T
          rules[LVT][T] = false;
          rules[T][T] = false;
<span class="line-modified">!         // GB 8a RI x RI</span>
<span class="line-removed">-         rules[RI][RI] = false;</span>
<span class="line-removed">-         // GB 9 x Extend</span>
          // GB 9a x Spacing Mark
          // GB 9b Prepend x
          for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++) {
              rules[i][EXTEND] = false;
              rules[i][SPACINGMARK] = false;
              rules[PREPEND][i] = false;
          }
          // GB 4  (Control | CR | LF) +
          // GB 5  + (Control | CR | LF)
<span class="line-new-header">--- 129,16 ---</span>
          rules[V][V] = false;
          rules[V][T] = false;
          // GB 8 (LVT | T) x T
          rules[LVT][T] = false;
          rules[T][T] = false;
<span class="line-modified">!         // GB 9 x (Extend|ZWJ)</span>
          // GB 9a x Spacing Mark
          // GB 9b Prepend x
          for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++) {
              rules[i][EXTEND] = false;
<span class="line-added">+             rules[i][ZWJ] = false;</span>
              rules[i][SPACINGMARK] = false;
              rules[PREPEND][i] = false;
          }
          // GB 4  (Control | CR | LF) +
          // GB 5  + (Control | CR | LF)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
                  rules[i][j] = true;
                  rules[j][i] = true;
              }
          // GB 3 CR x LF
          rules[CR][LF] = false;
<span class="line-modified">!         // GB 10 Any + Any  -&gt; default</span>
      }
  
      // Hangul syllables
      private static final int SYLLABLE_BASE = 0xAC00;
      private static final int LCOUNT = 19;
<span class="line-new-header">--- 147,13 ---</span>
                  rules[i][j] = true;
                  rules[j][i] = true;
              }
          // GB 3 CR x LF
          rules[CR][LF] = false;
<span class="line-modified">!         // GB 11 Exended_Pictographic x (Extend|ZWJ)</span>
<span class="line-added">+         rules[EXTENDED_PICTOGRAPHIC][EXTEND] = false;</span>
<span class="line-added">+         rules[EXTENDED_PICTOGRAPHIC][ZWJ] = false;</span>
      }
  
      // Hangul syllables
      private static final int SYLLABLE_BASE = 0xAC00;
      private static final int LCOUNT = 19;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,43 ***</span>
                 cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
                 cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
                 cp == 0xAA7B || cp == 0xAA7D;
      }
  
      @SuppressWarnings(&quot;fallthrough&quot;)
      private static int getType(int cp) {
          int type = Character.getType(cp);
          switch(type) {
<span class="line-modified">!         case Character.CONTROL:</span>
<span class="line-removed">-             if (cp == 0x000D)</span>
<span class="line-removed">-                 return CR;</span>
<span class="line-removed">-             if (cp == 0x000A)</span>
<span class="line-removed">-                 return LF;</span>
<span class="line-removed">-             return CONTROL;</span>
<span class="line-removed">-          case Character.UNASSIGNED:</span>
              // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
              // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
              // so type it as &quot;Other&quot; to make the test happy
<span class="line-modified">!              if (cp == 0x0378)</span>
<span class="line-modified">!                  return OTHER;</span>
  
          case Character.LINE_SEPARATOR:
          case Character.PARAGRAPH_SEPARATOR:
          case Character.SURROGATE:
              return CONTROL;
          case Character.FORMAT:
<span class="line-modified">!             if (cp == 0x200C || cp == 0x200D)</span>
                  return EXTEND;
              return CONTROL;
          case Character.NON_SPACING_MARK:
          case Character.ENCLOSING_MARK:
<span class="line-modified">!              // NOTE:</span>
<span class="line-modified">!              // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for</span>
<span class="line-modified">!              // canonical equivalence.&quot;</span>
<span class="line-modified">!              // but for &quot;extended grapheme clusters&quot; support, there is no</span>
<span class="line-modified">!              // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a</span>
<span class="line-modified">!              return EXTEND;</span>
          case  Character.COMBINING_SPACING_MARK:
              if (isExcludedSpacingMark(cp))
                  return OTHER;
              // NOTE:
              // 0x11720 and 0x11721 are mentioned in #tr29 as
<span class="line-new-header">--- 175,63 ---</span>
                 cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
                 cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
                 cp == 0xAA7B || cp == 0xAA7D;
      }
  
<span class="line-added">+     private static int getGraphemeType(int cp) {</span>
<span class="line-added">+         if (cp &lt; 0x007F) { // ASCII</span>
<span class="line-added">+             if (cp &lt; 32) { // Control characters</span>
<span class="line-added">+                 if (cp == 0x000D)</span>
<span class="line-added">+                     return CR;</span>
<span class="line-added">+                 if (cp == 0x000A)</span>
<span class="line-added">+                     return LF;</span>
<span class="line-added">+                 return CONTROL;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return OTHER;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return getType(cp);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @SuppressWarnings(&quot;fallthrough&quot;)
      private static int getType(int cp) {
<span class="line-added">+         if (EmojiData.isExtendedPictographic(cp)) {</span>
<span class="line-added">+             return EXTENDED_PICTOGRAPHIC;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          int type = Character.getType(cp);
          switch(type) {
<span class="line-modified">!         case Character.UNASSIGNED:</span>
              // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
              // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
              // so type it as &quot;Other&quot; to make the test happy
<span class="line-modified">!             if (cp == 0x0378)</span>
<span class="line-modified">!                 return OTHER;</span>
  
<span class="line-added">+         case Character.CONTROL:</span>
          case Character.LINE_SEPARATOR:
          case Character.PARAGRAPH_SEPARATOR:
          case Character.SURROGATE:
              return CONTROL;
          case Character.FORMAT:
<span class="line-modified">!             if (cp == 0x200C ||</span>
<span class="line-added">+                 cp &gt;= 0xE0020 &amp;&amp; cp &lt;= 0xE007F)</span>
                  return EXTEND;
<span class="line-added">+             if (cp == 0x200D)</span>
<span class="line-added">+                 return ZWJ;</span>
<span class="line-added">+             if (cp &gt;= 0x0600 &amp;&amp; cp &lt;= 0x0605 ||</span>
<span class="line-added">+                 cp == 0x06DD || cp == 0x070F || cp == 0x08E2 ||</span>
<span class="line-added">+                 cp == 0x110BD || cp == 0x110CD)</span>
<span class="line-added">+                 return PREPEND;</span>
              return CONTROL;
          case Character.NON_SPACING_MARK:
          case Character.ENCLOSING_MARK:
<span class="line-modified">!             // NOTE:</span>
<span class="line-modified">!             // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for</span>
<span class="line-modified">!             // canonical equivalence.&quot;</span>
<span class="line-modified">!             // but for &quot;extended grapheme clusters&quot; support, there is no</span>
<span class="line-modified">!             // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a</span>
<span class="line-modified">!             return EXTEND;</span>
          case  Character.COMBINING_SPACING_MARK:
              if (isExcludedSpacingMark(cp))
                  return OTHER;
              // NOTE:
              // 0x11720 and 0x11721 are mentioned in #tr29 as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,13 ***</span>
          case Character.OTHER_SYMBOL:
              if (cp &gt;= 0x1F1E6 &amp;&amp; cp &lt;= 0x1F1FF)
                  return RI;
              return OTHER;
          case Character.MODIFIER_LETTER:
              // WARNING:
              // not mentioned in #tr29 but listed in GraphemeBreakProperty.txt
<span class="line-modified">!             if (cp == 0xFF9E || cp == 0xFF9F)</span>
                  return EXTEND;
              return OTHER;
          case Character.OTHER_LETTER:
              if (cp == 0x0E33 || cp == 0x0EB3)
                  return SPACINGMARK;
<span class="line-new-header">--- 241,15 ---</span>
          case Character.OTHER_SYMBOL:
              if (cp &gt;= 0x1F1E6 &amp;&amp; cp &lt;= 0x1F1FF)
                  return RI;
              return OTHER;
          case Character.MODIFIER_LETTER:
<span class="line-added">+         case Character.MODIFIER_SYMBOL:</span>
              // WARNING:
              // not mentioned in #tr29 but listed in GraphemeBreakProperty.txt
<span class="line-modified">!             if (cp == 0xFF9E || cp == 0xFF9F ||</span>
<span class="line-added">+                 cp &gt;= 0x1F3FB &amp;&amp; cp &lt;= 0x1F3FF)</span>
                  return EXTEND;
              return OTHER;
          case Character.OTHER_LETTER:
              if (cp == 0x0E33 || cp == 0x0EB3)
                  return SPACINGMARK;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,9 ***</span>
<span class="line-new-header">--- 275,25 ---</span>
              //  hangul jamo_extended B
              if (cp &gt;= 0xD7B0 &amp;&amp; cp &lt;= 0xD7C6)
                  return V;
              if (cp &gt;= 0xD7CB &amp;&amp; cp &lt;= 0xD7FB)
                  return T;
<span class="line-added">+ </span>
<span class="line-added">+             // Prepend</span>
<span class="line-added">+             switch (cp) {</span>
<span class="line-added">+                 case 0x0D4E:</span>
<span class="line-added">+                 case 0x111C2:</span>
<span class="line-added">+                 case 0x111C3:</span>
<span class="line-added">+                 case 0x11A3A:</span>
<span class="line-added">+                 case 0x11A84:</span>
<span class="line-added">+                 case 0x11A85:</span>
<span class="line-added">+                 case 0x11A86:</span>
<span class="line-added">+                 case 0x11A87:</span>
<span class="line-added">+                 case 0x11A88:</span>
<span class="line-added">+                 case 0x11A89:</span>
<span class="line-added">+                 case 0x11D46:</span>
<span class="line-added">+                     return PREPEND;</span>
<span class="line-added">+             }</span>
          }
          return OTHER;
      }
  }
</pre>
<center><a href="../jar/package-info.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Matcher.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/SignedObject.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SignatureSpi.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Signer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/SignedObject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
101  * internally to any Java runtime as an unforgeable authorization
102  * token -- one that can be passed around without the fear that the
103  * token can be maliciously modified without being detected.
104  * &lt;li&gt; It
105  * can be used to sign and serialize data/object for storage outside
106  * the Java runtime (e.g., storing critical access control data on
107  * disk).
108  * &lt;li&gt; Nested SignedObjects can be used to construct a logical
109  * sequence of signatures, resembling a chain of authorization and
110  * delegation.
111  * &lt;/ul&gt;
112  *
113  * @see Signature
114  *
115  * @author Li Gong
116  * @since 1.2
117  */
118 
119 public final class SignedObject implements Serializable {
120 

121     private static final long serialVersionUID = 720502720485447167L;
122 
123     /*
124      * The original content is &quot;deep copied&quot; in its serialized format
125      * and stored in a byte array.  The signature field is also in the
126      * form of byte array.
127      */
128 
129     private byte[] content;
130     private byte[] signature;
131     private String thealgorithm;
132 
133     /**
134      * Constructs a SignedObject from any Serializable object.
135      * The given object is signed with the given signing key, using the
136      * designated signature engine.
137      *
138      * @param object the object to be signed.
139      * @param signingKey the private key for signing.
140      * @param signingEngine the signature signing engine.
141      *
<span class="line-modified">142      * @exception IOException if an error occurs during serialization</span>
<span class="line-modified">143      * @exception InvalidKeyException if the key is invalid.</span>
<span class="line-modified">144      * @exception SignatureException if signing fails.</span>
145      */
146     public SignedObject(Serializable object, PrivateKey signingKey,
147                         Signature signingEngine)
148         throws IOException, InvalidKeyException, SignatureException {
149             // creating a stream pipe-line, from a to b
150             ByteArrayOutputStream b = new ByteArrayOutputStream();
151             ObjectOutput a = new ObjectOutputStream(b);
152 
153             // write and flush the object content to byte array
154             a.writeObject(object);
155             a.flush();
156             a.close();
157             this.content = b.toByteArray();
158             b.close();
159 
160             // now sign the encapsulated object
161             this.sign(signingKey, signingEngine);
162     }
163 
164     /**
165      * Retrieves the encapsulated object.
166      * The encapsulated object is de-serialized before it is returned.
167      *
168      * @return the encapsulated object.
169      *
<span class="line-modified">170      * @exception IOException if an error occurs during de-serialization</span>
<span class="line-modified">171      * @exception ClassNotFoundException if an error occurs during</span>
172      * de-serialization
173      */
174     public Object getObject()
175         throws IOException, ClassNotFoundException
176     {
177         // creating a stream pipe-line, from b to a
178         ByteArrayInputStream b = new ByteArrayInputStream(this.content);
179         ObjectInput a = new ObjectInputStream(b);
180         Object obj = a.readObject();
181         b.close();
182         a.close();
183         return obj;
184     }
185 
186     /**
187      * Retrieves the signature on the signed object, in the form of a
188      * byte array.
189      *
190      * @return the signature. Returns a new array each time this
191      * method is called.
</pre>
<hr />
<pre>
194         return this.signature.clone();
195     }
196 
197     /**
198      * Retrieves the name of the signature algorithm.
199      *
200      * @return the signature algorithm name.
201      */
202     public String getAlgorithm() {
203         return this.thealgorithm;
204     }
205 
206     /**
207      * Verifies that the signature in this SignedObject is the valid
208      * signature for the object stored inside, with the given
209      * verification key, using the designated verification engine.
210      *
211      * @param verificationKey the public key for verification.
212      * @param verificationEngine the signature verification engine.
213      *
<span class="line-modified">214      * @exception SignatureException if signature verification failed (an</span>
215      *     exception prevented the signature verification engine from completing
216      *     normally).
<span class="line-modified">217      * @exception InvalidKeyException if the verification key is invalid.</span>
218      *
219      * @return {@code true} if the signature
220      * is valid, {@code false} otherwise
221      */
222     public boolean verify(PublicKey verificationKey,
223                           Signature verificationEngine)
224          throws InvalidKeyException, SignatureException {
225              verificationEngine.initVerify(verificationKey);
226              verificationEngine.update(this.content.clone());
227              return verificationEngine.verify(this.signature.clone());
228     }
229 
230     /*
231      * Signs the encapsulated object with the given signing key, using the
232      * designated signature engine.
233      *
234      * @param signingKey the private key for signing.
235      * @param signingEngine the signature signing engine.
236      *
<span class="line-modified">237      * @exception InvalidKeyException if the key is invalid.</span>
<span class="line-modified">238      * @exception SignatureException if signing fails.</span>
239      */
240     private void sign(PrivateKey signingKey, Signature signingEngine)
241         throws InvalidKeyException, SignatureException {
242             // initialize the signing engine
243             signingEngine.initSign(signingKey);
244             signingEngine.update(this.content.clone());
245             this.signature = signingEngine.sign().clone();
246             this.thealgorithm = signingEngine.getAlgorithm();
247     }
248 
249     /**
250      * readObject is called to restore the state of the SignedObject from
251      * a stream.
252      */

253     private void readObject(java.io.ObjectInputStream s)
254         throws java.io.IOException, ClassNotFoundException {
255             java.io.ObjectInputStream.GetField fields = s.readFields();
256             content = ((byte[])fields.get(&quot;content&quot;, null)).clone();
257             signature = ((byte[])fields.get(&quot;signature&quot;, null)).clone();
258             thealgorithm = (String)fields.get(&quot;thealgorithm&quot;, null);
259     }
260 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
101  * internally to any Java runtime as an unforgeable authorization
102  * token -- one that can be passed around without the fear that the
103  * token can be maliciously modified without being detected.
104  * &lt;li&gt; It
105  * can be used to sign and serialize data/object for storage outside
106  * the Java runtime (e.g., storing critical access control data on
107  * disk).
108  * &lt;li&gt; Nested SignedObjects can be used to construct a logical
109  * sequence of signatures, resembling a chain of authorization and
110  * delegation.
111  * &lt;/ul&gt;
112  *
113  * @see Signature
114  *
115  * @author Li Gong
116  * @since 1.2
117  */
118 
119 public final class SignedObject implements Serializable {
120 
<span class="line-added">121     @java.io.Serial</span>
122     private static final long serialVersionUID = 720502720485447167L;
123 
124     /*
125      * The original content is &quot;deep copied&quot; in its serialized format
126      * and stored in a byte array.  The signature field is also in the
127      * form of byte array.
128      */
129 
130     private byte[] content;
131     private byte[] signature;
132     private String thealgorithm;
133 
134     /**
135      * Constructs a SignedObject from any Serializable object.
136      * The given object is signed with the given signing key, using the
137      * designated signature engine.
138      *
139      * @param object the object to be signed.
140      * @param signingKey the private key for signing.
141      * @param signingEngine the signature signing engine.
142      *
<span class="line-modified">143      * @throws    IOException if an error occurs during serialization</span>
<span class="line-modified">144      * @throws    InvalidKeyException if the key is invalid.</span>
<span class="line-modified">145      * @throws    SignatureException if signing fails.</span>
146      */
147     public SignedObject(Serializable object, PrivateKey signingKey,
148                         Signature signingEngine)
149         throws IOException, InvalidKeyException, SignatureException {
150             // creating a stream pipe-line, from a to b
151             ByteArrayOutputStream b = new ByteArrayOutputStream();
152             ObjectOutput a = new ObjectOutputStream(b);
153 
154             // write and flush the object content to byte array
155             a.writeObject(object);
156             a.flush();
157             a.close();
158             this.content = b.toByteArray();
159             b.close();
160 
161             // now sign the encapsulated object
162             this.sign(signingKey, signingEngine);
163     }
164 
165     /**
166      * Retrieves the encapsulated object.
167      * The encapsulated object is de-serialized before it is returned.
168      *
169      * @return the encapsulated object.
170      *
<span class="line-modified">171      * @throws    IOException if an error occurs during de-serialization</span>
<span class="line-modified">172      * @throws    ClassNotFoundException if an error occurs during</span>
173      * de-serialization
174      */
175     public Object getObject()
176         throws IOException, ClassNotFoundException
177     {
178         // creating a stream pipe-line, from b to a
179         ByteArrayInputStream b = new ByteArrayInputStream(this.content);
180         ObjectInput a = new ObjectInputStream(b);
181         Object obj = a.readObject();
182         b.close();
183         a.close();
184         return obj;
185     }
186 
187     /**
188      * Retrieves the signature on the signed object, in the form of a
189      * byte array.
190      *
191      * @return the signature. Returns a new array each time this
192      * method is called.
</pre>
<hr />
<pre>
195         return this.signature.clone();
196     }
197 
198     /**
199      * Retrieves the name of the signature algorithm.
200      *
201      * @return the signature algorithm name.
202      */
203     public String getAlgorithm() {
204         return this.thealgorithm;
205     }
206 
207     /**
208      * Verifies that the signature in this SignedObject is the valid
209      * signature for the object stored inside, with the given
210      * verification key, using the designated verification engine.
211      *
212      * @param verificationKey the public key for verification.
213      * @param verificationEngine the signature verification engine.
214      *
<span class="line-modified">215      * @throws    SignatureException if signature verification failed (an</span>
216      *     exception prevented the signature verification engine from completing
217      *     normally).
<span class="line-modified">218      * @throws    InvalidKeyException if the verification key is invalid.</span>
219      *
220      * @return {@code true} if the signature
221      * is valid, {@code false} otherwise
222      */
223     public boolean verify(PublicKey verificationKey,
224                           Signature verificationEngine)
225          throws InvalidKeyException, SignatureException {
226              verificationEngine.initVerify(verificationKey);
227              verificationEngine.update(this.content.clone());
228              return verificationEngine.verify(this.signature.clone());
229     }
230 
231     /*
232      * Signs the encapsulated object with the given signing key, using the
233      * designated signature engine.
234      *
235      * @param signingKey the private key for signing.
236      * @param signingEngine the signature signing engine.
237      *
<span class="line-modified">238      * @throws    InvalidKeyException if the key is invalid.</span>
<span class="line-modified">239      * @throws    SignatureException if signing fails.</span>
240      */
241     private void sign(PrivateKey signingKey, Signature signingEngine)
242         throws InvalidKeyException, SignatureException {
243             // initialize the signing engine
244             signingEngine.initSign(signingKey);
245             signingEngine.update(this.content.clone());
246             this.signature = signingEngine.sign().clone();
247             this.thealgorithm = signingEngine.getAlgorithm();
248     }
249 
250     /**
251      * readObject is called to restore the state of the SignedObject from
252      * a stream.
253      */
<span class="line-added">254     @java.io.Serial</span>
255     private void readObject(java.io.ObjectInputStream s)
256         throws java.io.IOException, ClassNotFoundException {
257             java.io.ObjectInputStream.GetField fields = s.readFields();
258             content = ((byte[])fields.get(&quot;content&quot;, null)).clone();
259             signature = ((byte[])fields.get(&quot;signature&quot;, null)).clone();
260             thealgorithm = (String)fields.get(&quot;thealgorithm&quot;, null);
261     }
262 }
</pre>
</td>
</tr>
</table>
<center><a href="SignatureSpi.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Signer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/InflaterInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="GZIPOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipCoder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/InflaterInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.FilterInputStream;
 29 import java.io.InputStream;
 30 import java.io.IOException;
 31 import java.io.EOFException;
 32 
 33 /**
 34  * This class implements a stream filter for uncompressing data in the
 35  * &quot;deflate&quot; compression format. It is also used as the basis for other
 36  * decompression filters, such as GZIPInputStream.
 37  *
 38  * @see         Inflater
 39  * @author      David Connelly
 40  * @since 1.1
 41  */
<span class="line-modified"> 42 public</span>
<span class="line-removed"> 43 class InflaterInputStream extends FilterInputStream {</span>
 44     /**
 45      * Decompressor for this stream.
 46      */
 47     protected Inflater inf;
 48 
 49     /**
 50      * Input buffer for decompression.
 51      */
 52     protected byte[] buf;
 53 
 54     /**
 55      * Length of input buffer.
 56      */
 57     protected int len;
 58 
 59     private boolean closed = false;
 60     // this flag is set to true after EOF has reached
 61     private boolean reachEOF = false;
 62 
 63     /**
 64      * Check to make sure that this stream has not been closed
 65      */
 66     private void ensureOpen() throws IOException {
 67         if (closed) {
 68             throw new IOException(&quot;Stream closed&quot;);
 69         }
 70     }
 71 
 72 
 73     /**
 74      * Creates a new input stream with the specified decompressor and
 75      * buffer size.
 76      * @param in the input stream
 77      * @param inf the decompressor (&quot;inflater&quot;)
 78      * @param size the input buffer size
<span class="line-modified"> 79      * @exception IllegalArgumentException if {@code size &lt;= 0}</span>
 80      */
 81     public InflaterInputStream(InputStream in, Inflater inf, int size) {
 82         super(in);
 83         if (in == null || inf == null) {
 84             throw new NullPointerException();
 85         } else if (size &lt;= 0) {
 86             throw new IllegalArgumentException(&quot;buffer size &lt;= 0&quot;);
 87         }
 88         this.inf = inf;
 89         buf = new byte[size];
 90     }
 91 
 92     /**
 93      * Creates a new input stream with the specified decompressor and a
 94      * default buffer size.
 95      * @param in the input stream
 96      * @param inf the decompressor (&quot;inflater&quot;)
 97      */
 98     public InflaterInputStream(InputStream in, Inflater inf) {
 99         this(in, inf, 512);
100     }
101 
102     boolean usesDefaultInflater = false;
103 
104     /**
105      * Creates a new input stream with a default decompressor and buffer size.
106      * @param in the input stream
107      */
108     public InflaterInputStream(InputStream in) {
109         this(in, new Inflater());
110         usesDefaultInflater = true;
111     }
112 
113     private byte[] singleByteBuf = new byte[1];
114 
115     /**
116      * Reads a byte of uncompressed data. This method will block until
117      * enough input is available for decompression.
118      * @return the byte read, or -1 if end of compressed input is reached
<span class="line-modified">119      * @exception IOException if an I/O error has occurred</span>
120      */
121     public int read() throws IOException {
122         ensureOpen();
123         return read(singleByteBuf, 0, 1) == -1 ? -1 : Byte.toUnsignedInt(singleByteBuf[0]);
124     }
125 
126     /**
<span class="line-modified">127      * Reads uncompressed data into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not</span>
128      * zero, the method will block until some input can be decompressed; otherwise,
<span class="line-modified">129      * no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
130      * @param b the buffer into which the data is read
<span class="line-modified">131      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
132      * @param len the maximum number of bytes read
133      * @return the actual number of bytes read, or -1 if the end of the
134      *         compressed input is reached or a preset dictionary is needed
<span class="line-modified">135      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">136      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">137      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">138      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">139      * @exception ZipException if a ZIP format error has occurred</span>
<span class="line-modified">140      * @exception IOException if an I/O error has occurred</span>
141      */
142     public int read(byte[] b, int off, int len) throws IOException {
143         ensureOpen();
144         if (b == null) {
145             throw new NullPointerException();
146         } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
147             throw new IndexOutOfBoundsException();
148         } else if (len == 0) {
149             return 0;
150         }
151         try {
152             int n;
153             while ((n = inf.inflate(b, off, len)) == 0) {
154                 if (inf.finished() || inf.needsDictionary()) {
155                     reachEOF = true;
156                     return -1;
157                 }
158                 if (inf.needsInput()) {
159                     fill();
160                 }
161             }
162             return n;
163         } catch (DataFormatException e) {
164             String s = e.getMessage();
165             throw new ZipException(s != null ? s : &quot;Invalid ZLIB data format&quot;);
166         }
167     }
168 
169     /**
170      * Returns 0 after EOF has been reached, otherwise always return 1.
171      * &lt;p&gt;
172      * Programs should not count on this method to return the actual number
173      * of bytes that could be read without blocking.
174      *
175      * @return     1 before EOF and 0 after EOF.
<span class="line-modified">176      * @exception  IOException  if an I/O error occurs.</span>
177      *
178      */
179     public int available() throws IOException {
180         ensureOpen();
181         if (reachEOF) {
182             return 0;
183         } else if (inf.finished()) {
184             // the end of the compressed data stream has been reached
185             reachEOF = true;
186             return 0;
187         } else {
188             return 1;
189         }
190     }
191 
192     private byte[] b = new byte[512];
193 
194     /**
195      * Skips specified number of bytes of uncompressed data.
196      * @param n the number of bytes to skip
197      * @return the actual number of bytes skipped.
<span class="line-modified">198      * @exception IOException if an I/O error has occurred</span>
<span class="line-modified">199      * @exception IllegalArgumentException if {@code n &lt; 0}</span>
200      */
201     public long skip(long n) throws IOException {
202         if (n &lt; 0) {
203             throw new IllegalArgumentException(&quot;negative skip length&quot;);
204         }
205         ensureOpen();
206         int max = (int)Math.min(n, Integer.MAX_VALUE);
207         int total = 0;
208         while (total &lt; max) {
209             int len = max - total;
210             if (len &gt; b.length) {
211                 len = b.length;
212             }
213             len = read(b, 0, len);
214             if (len == -1) {
215                 reachEOF = true;
216                 break;
217             }
218             total += len;
219         }
220         return total;
221     }
222 
223     /**
224      * Closes this input stream and releases any system resources associated
225      * with the stream.
<span class="line-modified">226      * @exception IOException if an I/O error has occurred</span>
227      */
228     public void close() throws IOException {
229         if (!closed) {
230             if (usesDefaultInflater)
231                 inf.end();
232             in.close();
233             closed = true;
234         }
235     }
236 
237     /**
238      * Fills input buffer with more data to decompress.
<span class="line-modified">239      * @exception IOException if an I/O error has occurred</span>
240      */
241     protected void fill() throws IOException {
242         ensureOpen();
243         len = in.read(buf, 0, buf.length);
244         if (len == -1) {
245             throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
246         }
247         inf.setInput(buf, 0, len);
248     }
249 
250     /**
<span class="line-modified">251      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and</span>
<span class="line-modified">252      * &lt;code&gt;reset&lt;/code&gt; methods. The &lt;code&gt;markSupported&lt;/code&gt;</span>
<span class="line-modified">253      * method of &lt;code&gt;InflaterInputStream&lt;/code&gt; returns</span>
<span class="line-modified">254      * &lt;code&gt;false&lt;/code&gt;.</span>
255      *
<span class="line-modified">256      * @return  a &lt;code&gt;boolean&lt;/code&gt; indicating if this stream type supports</span>
<span class="line-modified">257      *          the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods.</span>
258      * @see     java.io.InputStream#mark(int)
259      * @see     java.io.InputStream#reset()
260      */
261     public boolean markSupported() {
262         return false;
263     }
264 
265     /**
266      * Marks the current position in this input stream.
267      *
<span class="line-modified">268      * &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InflaterInputStream&lt;/code&gt;</span>
269      * does nothing.
270      *
271      * @param   readlimit   the maximum limit of bytes that can be read before
272      *                      the mark position becomes invalid.
273      * @see     java.io.InputStream#reset()
274      */
275     public synchronized void mark(int readlimit) {
276     }
277 
278     /**
279      * Repositions this stream to the position at the time the
<span class="line-modified">280      * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.</span>
281      *
<span class="line-modified">282      * &lt;p&gt; The method &lt;code&gt;reset&lt;/code&gt; for class</span>
<span class="line-modified">283      * &lt;code&gt;InflaterInputStream&lt;/code&gt; does nothing except throw an</span>
<span class="line-modified">284      * &lt;code&gt;IOException&lt;/code&gt;.</span>
285      *
<span class="line-modified">286      * @exception  IOException  if this method is invoked.</span>
287      * @see     java.io.InputStream#mark(int)
288      * @see     java.io.IOException
289      */
290     public synchronized void reset() throws IOException {
291         throw new IOException(&quot;mark/reset not supported&quot;);
292     }
293 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.FilterInputStream;
 29 import java.io.InputStream;
 30 import java.io.IOException;
 31 import java.io.EOFException;
 32 
 33 /**
 34  * This class implements a stream filter for uncompressing data in the
 35  * &quot;deflate&quot; compression format. It is also used as the basis for other
 36  * decompression filters, such as GZIPInputStream.
 37  *
 38  * @see         Inflater
 39  * @author      David Connelly
 40  * @since 1.1
 41  */
<span class="line-modified"> 42 public class InflaterInputStream extends FilterInputStream {</span>

 43     /**
 44      * Decompressor for this stream.
 45      */
 46     protected Inflater inf;
 47 
 48     /**
 49      * Input buffer for decompression.
 50      */
 51     protected byte[] buf;
 52 
 53     /**
 54      * Length of input buffer.
 55      */
 56     protected int len;
 57 
 58     private boolean closed = false;
 59     // this flag is set to true after EOF has reached
 60     private boolean reachEOF = false;
 61 
 62     /**
 63      * Check to make sure that this stream has not been closed
 64      */
 65     private void ensureOpen() throws IOException {
 66         if (closed) {
 67             throw new IOException(&quot;Stream closed&quot;);
 68         }
 69     }
 70 
 71 
 72     /**
 73      * Creates a new input stream with the specified decompressor and
 74      * buffer size.
 75      * @param in the input stream
 76      * @param inf the decompressor (&quot;inflater&quot;)
 77      * @param size the input buffer size
<span class="line-modified"> 78      * @throws    IllegalArgumentException if {@code size &lt;= 0}</span>
 79      */
 80     public InflaterInputStream(InputStream in, Inflater inf, int size) {
 81         super(in);
 82         if (in == null || inf == null) {
 83             throw new NullPointerException();
 84         } else if (size &lt;= 0) {
 85             throw new IllegalArgumentException(&quot;buffer size &lt;= 0&quot;);
 86         }
 87         this.inf = inf;
 88         buf = new byte[size];
 89     }
 90 
 91     /**
 92      * Creates a new input stream with the specified decompressor and a
 93      * default buffer size.
 94      * @param in the input stream
 95      * @param inf the decompressor (&quot;inflater&quot;)
 96      */
 97     public InflaterInputStream(InputStream in, Inflater inf) {
 98         this(in, inf, 512);
 99     }
100 
101     boolean usesDefaultInflater = false;
102 
103     /**
104      * Creates a new input stream with a default decompressor and buffer size.
105      * @param in the input stream
106      */
107     public InflaterInputStream(InputStream in) {
108         this(in, new Inflater());
109         usesDefaultInflater = true;
110     }
111 
112     private byte[] singleByteBuf = new byte[1];
113 
114     /**
115      * Reads a byte of uncompressed data. This method will block until
116      * enough input is available for decompression.
117      * @return the byte read, or -1 if end of compressed input is reached
<span class="line-modified">118      * @throws    IOException if an I/O error has occurred</span>
119      */
120     public int read() throws IOException {
121         ensureOpen();
122         return read(singleByteBuf, 0, 1) == -1 ? -1 : Byte.toUnsignedInt(singleByteBuf[0]);
123     }
124 
125     /**
<span class="line-modified">126      * Reads uncompressed data into an array of bytes. If {@code len} is not</span>
127      * zero, the method will block until some input can be decompressed; otherwise,
<span class="line-modified">128      * no bytes are read and {@code 0} is returned.</span>
129      * @param b the buffer into which the data is read
<span class="line-modified">130      * @param off the start offset in the destination array {@code b}</span>
131      * @param len the maximum number of bytes read
132      * @return the actual number of bytes read, or -1 if the end of the
133      *         compressed input is reached or a preset dictionary is needed
<span class="line-modified">134      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">135      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">136      * {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">137      * {@code b.length - off}</span>
<span class="line-modified">138      * @throws    ZipException if a ZIP format error has occurred</span>
<span class="line-modified">139      * @throws    IOException if an I/O error has occurred</span>
140      */
141     public int read(byte[] b, int off, int len) throws IOException {
142         ensureOpen();
143         if (b == null) {
144             throw new NullPointerException();
145         } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
146             throw new IndexOutOfBoundsException();
147         } else if (len == 0) {
148             return 0;
149         }
150         try {
151             int n;
152             while ((n = inf.inflate(b, off, len)) == 0) {
153                 if (inf.finished() || inf.needsDictionary()) {
154                     reachEOF = true;
155                     return -1;
156                 }
157                 if (inf.needsInput()) {
158                     fill();
159                 }
160             }
161             return n;
162         } catch (DataFormatException e) {
163             String s = e.getMessage();
164             throw new ZipException(s != null ? s : &quot;Invalid ZLIB data format&quot;);
165         }
166     }
167 
168     /**
169      * Returns 0 after EOF has been reached, otherwise always return 1.
170      * &lt;p&gt;
171      * Programs should not count on this method to return the actual number
172      * of bytes that could be read without blocking.
173      *
174      * @return     1 before EOF and 0 after EOF.
<span class="line-modified">175      * @throws     IOException  if an I/O error occurs.</span>
176      *
177      */
178     public int available() throws IOException {
179         ensureOpen();
180         if (reachEOF) {
181             return 0;
182         } else if (inf.finished()) {
183             // the end of the compressed data stream has been reached
184             reachEOF = true;
185             return 0;
186         } else {
187             return 1;
188         }
189     }
190 
191     private byte[] b = new byte[512];
192 
193     /**
194      * Skips specified number of bytes of uncompressed data.
195      * @param n the number of bytes to skip
196      * @return the actual number of bytes skipped.
<span class="line-modified">197      * @throws    IOException if an I/O error has occurred</span>
<span class="line-modified">198      * @throws    IllegalArgumentException if {@code n &lt; 0}</span>
199      */
200     public long skip(long n) throws IOException {
201         if (n &lt; 0) {
202             throw new IllegalArgumentException(&quot;negative skip length&quot;);
203         }
204         ensureOpen();
205         int max = (int)Math.min(n, Integer.MAX_VALUE);
206         int total = 0;
207         while (total &lt; max) {
208             int len = max - total;
209             if (len &gt; b.length) {
210                 len = b.length;
211             }
212             len = read(b, 0, len);
213             if (len == -1) {
214                 reachEOF = true;
215                 break;
216             }
217             total += len;
218         }
219         return total;
220     }
221 
222     /**
223      * Closes this input stream and releases any system resources associated
224      * with the stream.
<span class="line-modified">225      * @throws    IOException if an I/O error has occurred</span>
226      */
227     public void close() throws IOException {
228         if (!closed) {
229             if (usesDefaultInflater)
230                 inf.end();
231             in.close();
232             closed = true;
233         }
234     }
235 
236     /**
237      * Fills input buffer with more data to decompress.
<span class="line-modified">238      * @throws    IOException if an I/O error has occurred</span>
239      */
240     protected void fill() throws IOException {
241         ensureOpen();
242         len = in.read(buf, 0, buf.length);
243         if (len == -1) {
244             throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
245         }
246         inf.setInput(buf, 0, len);
247     }
248 
249     /**
<span class="line-modified">250      * Tests if this input stream supports the {@code mark} and</span>
<span class="line-modified">251      * {@code reset} methods. The {@code markSupported}</span>
<span class="line-modified">252      * method of {@code InflaterInputStream} returns</span>
<span class="line-modified">253      * {@code false}.</span>
254      *
<span class="line-modified">255      * @return  a {@code boolean} indicating if this stream type supports</span>
<span class="line-modified">256      *          the {@code mark} and {@code reset} methods.</span>
257      * @see     java.io.InputStream#mark(int)
258      * @see     java.io.InputStream#reset()
259      */
260     public boolean markSupported() {
261         return false;
262     }
263 
264     /**
265      * Marks the current position in this input stream.
266      *
<span class="line-modified">267      * &lt;p&gt; The {@code mark} method of {@code InflaterInputStream}</span>
268      * does nothing.
269      *
270      * @param   readlimit   the maximum limit of bytes that can be read before
271      *                      the mark position becomes invalid.
272      * @see     java.io.InputStream#reset()
273      */
274     public synchronized void mark(int readlimit) {
275     }
276 
277     /**
278      * Repositions this stream to the position at the time the
<span class="line-modified">279      * {@code mark} method was last called on this input stream.</span>
280      *
<span class="line-modified">281      * &lt;p&gt; The method {@code reset} for class</span>
<span class="line-modified">282      * {@code InflaterInputStream} does nothing except throw an</span>
<span class="line-modified">283      * {@code IOException}.</span>
284      *
<span class="line-modified">285      * @throws     IOException  if this method is invoked.</span>
286      * @see     java.io.InputStream#mark(int)
287      * @see     java.io.IOException
288      */
289     public synchronized void reset() throws IOException {
290         throw new IOException(&quot;mark/reset not supported&quot;);
291     }
292 }
</pre>
</td>
</tr>
</table>
<center><a href="GZIPOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipCoder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/zip/ZipInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.io.EOFException;
 31 import java.io.PushbackInputStream;
 32 import java.nio.charset.Charset;
<a name="2" id="anc2"></a><span class="line-modified"> 33 </span>
<span class="line-added"> 34 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 35 </span>
 36 import static java.util.zip.ZipConstants64.*;
 37 import static java.util.zip.ZipUtils.*;
 38 
 39 /**
 40  * This class implements an input stream filter for reading files in the
 41  * ZIP file format. Includes support for both compressed and uncompressed
 42  * entries.
 43  *
 44  * @author      David Connelly
 45  * @since 1.1
 46  */
<a name="3" id="anc3"></a><span class="line-modified"> 47 public class ZipInputStream extends InflaterInputStream implements ZipConstants {</span>

 48     private ZipEntry entry;
 49     private int flag;
 50     private CRC32 crc = new CRC32();
 51     private long remaining;
 52     private byte[] tmpbuf = new byte[512];
 53 
 54     private static final int STORED = ZipEntry.STORED;
 55     private static final int DEFLATED = ZipEntry.DEFLATED;
 56 
 57     private boolean closed = false;
 58     // this flag is set to true after EOF has reached for
 59     // one entry
 60     private boolean entryEOF = false;
 61 
 62     private ZipCoder zc;
 63 
 64     /**
 65      * Check to make sure that this stream has not been closed
 66      */
 67     private void ensureOpen() throws IOException {
 68         if (closed) {
 69             throw new IOException(&quot;Stream closed&quot;);
 70         }
 71     }
 72 
 73     /**
 74      * Creates a new ZIP input stream.
 75      *
 76      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 77      * decode the entry names.
 78      *
 79      * @param in the actual input stream
 80      */
 81     public ZipInputStream(InputStream in) {
<a name="4" id="anc4"></a><span class="line-modified"> 82         this(in, UTF_8.INSTANCE);</span>
 83     }
 84 
 85     /**
 86      * Creates a new ZIP input stream.
 87      *
 88      * @param in the actual input stream
 89      *
 90      * @param charset
 91      *        The {@linkplain java.nio.charset.Charset charset} to be
 92      *        used to decode the ZIP entry name (ignored if the
 93      *        &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 94      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 95      *        flag is set).
 96      *
 97      * @since 1.7
 98      */
 99     public ZipInputStream(InputStream in, Charset charset) {
100         super(new PushbackInputStream(in, 512), new Inflater(true), 512);
101         usesDefaultInflater = true;
102         if (in == null) {
103             throw new NullPointerException(&quot;in is null&quot;);
104         }
105         if (charset == null)
106             throw new NullPointerException(&quot;charset is null&quot;);
107         this.zc = ZipCoder.get(charset);
108     }
109 
110     /**
111      * Reads the next ZIP file entry and positions the stream at the
112      * beginning of the entry data.
113      * @return the next ZIP file entry, or null if there are no more entries
<a name="5" id="anc5"></a><span class="line-modified">114      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">115      * @throws    IOException if an I/O error has occurred</span>
116      */
117     public ZipEntry getNextEntry() throws IOException {
118         ensureOpen();
119         if (entry != null) {
120             closeEntry();
121         }
122         crc.reset();
123         inf.reset();
124         if ((entry = readLOC()) == null) {
125             return null;
126         }
127         if (entry.method == STORED) {
128             remaining = entry.size;
129         }
130         entryEOF = false;
131         return entry;
132     }
133 
134     /**
135      * Closes the current ZIP entry and positions the stream for reading the
136      * next entry.
<a name="6" id="anc6"></a><span class="line-modified">137      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">138      * @throws    IOException if an I/O error has occurred</span>
139      */
140     public void closeEntry() throws IOException {
141         ensureOpen();
142         while (read(tmpbuf, 0, tmpbuf.length) != -1) ;
143         entryEOF = true;
144     }
145 
146     /**
147      * Returns 0 after EOF has reached for the current entry data,
148      * otherwise always return 1.
149      * &lt;p&gt;
150      * Programs should not count on this method to return the actual number
151      * of bytes that could be read without blocking.
152      *
153      * @return     1 before EOF and 0 after EOF has reached for current entry.
<a name="7" id="anc7"></a><span class="line-modified">154      * @throws     IOException  if an I/O error occurs.</span>
155      *
156      */
157     public int available() throws IOException {
158         ensureOpen();
159         if (entryEOF) {
160             return 0;
161         } else {
162             return 1;
163         }
164     }
165 
166     /**
167      * Reads from the current ZIP entry into an array of bytes.
<a name="8" id="anc8"></a><span class="line-modified">168      * If {@code len} is not zero, the method</span>
169      * blocks until some input is available; otherwise, no
<a name="9" id="anc9"></a><span class="line-modified">170      * bytes are read and {@code 0} is returned.</span>
171      * @param b the buffer into which the data is read
<a name="10" id="anc10"></a><span class="line-modified">172      * @param off the start offset in the destination array {@code b}</span>
173      * @param len the maximum number of bytes read
174      * @return the actual number of bytes read, or -1 if the end of the
175      *         entry is reached
<a name="11" id="anc11"></a><span class="line-modified">176      * @throws     NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">177      * @throws     IndexOutOfBoundsException if {@code off} is negative,</span>
<span class="line-modified">178      * {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">179      * {@code b.length - off}</span>
<span class="line-modified">180      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">181      * @throws    IOException if an I/O error has occurred</span>
182      */
183     public int read(byte[] b, int off, int len) throws IOException {
184         ensureOpen();
185         if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {
186             throw new IndexOutOfBoundsException();
187         } else if (len == 0) {
188             return 0;
189         }
190 
191         if (entry == null) {
192             return -1;
193         }
194         switch (entry.method) {
195         case DEFLATED:
196             len = super.read(b, off, len);
197             if (len == -1) {
198                 readEnd(entry);
199                 entryEOF = true;
200                 entry = null;
201             } else {
202                 crc.update(b, off, len);
203             }
204             return len;
205         case STORED:
206             if (remaining &lt;= 0) {
207                 entryEOF = true;
208                 entry = null;
209                 return -1;
210             }
211             if (len &gt; remaining) {
212                 len = (int)remaining;
213             }
214             len = in.read(b, off, len);
215             if (len == -1) {
216                 throw new ZipException(&quot;unexpected EOF&quot;);
217             }
218             crc.update(b, off, len);
219             remaining -= len;
220             if (remaining == 0 &amp;&amp; entry.crc != crc.getValue()) {
221                 throw new ZipException(
222                     &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(entry.crc) +
223                     &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);
224             }
225             return len;
226         default:
227             throw new ZipException(&quot;invalid compression method&quot;);
228         }
229     }
230 
231     /**
232      * Skips specified number of bytes in the current ZIP entry.
233      * @param n the number of bytes to skip
234      * @return the actual number of bytes skipped
<a name="12" id="anc12"></a><span class="line-modified">235      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">236      * @throws    IOException if an I/O error has occurred</span>
<span class="line-modified">237      * @throws    IllegalArgumentException if {@code n &lt; 0}</span>
238      */
239     public long skip(long n) throws IOException {
240         if (n &lt; 0) {
241             throw new IllegalArgumentException(&quot;negative skip length&quot;);
242         }
243         ensureOpen();
244         int max = (int)Math.min(n, Integer.MAX_VALUE);
245         int total = 0;
246         while (total &lt; max) {
247             int len = max - total;
248             if (len &gt; tmpbuf.length) {
249                 len = tmpbuf.length;
250             }
251             len = read(tmpbuf, 0, len);
252             if (len == -1) {
253                 entryEOF = true;
254                 break;
255             }
256             total += len;
257         }
258         return total;
259     }
260 
261     /**
262      * Closes this input stream and releases any system resources associated
263      * with the stream.
<a name="13" id="anc13"></a><span class="line-modified">264      * @throws    IOException if an I/O error has occurred</span>
265      */
266     public void close() throws IOException {
267         if (!closed) {
268             super.close();
269             closed = true;
270         }
271     }
272 
273     private byte[] b = new byte[256];
274 
275     /*
276      * Reads local file (LOC) header for next entry.
277      */
278     private ZipEntry readLOC() throws IOException {
279         try {
280             readFully(tmpbuf, 0, LOCHDR);
281         } catch (EOFException e) {
282             return null;
283         }
284         if (get32(tmpbuf, 0) != LOCSIG) {
285             return null;
286         }
287         // get flag first, we need check USE_UTF8.
288         flag = get16(tmpbuf, LOCFLG);
289         // get the entry name and create the ZipEntry first
290         int len = get16(tmpbuf, LOCNAM);
291         int blen = b.length;
292         if (len &gt; blen) {
293             do {
294                 blen = blen * 2;
295             } while (len &gt; blen);
296             b = new byte[blen];
297         }
298         readFully(b, 0, len);
299         // Force to use UTF-8 if the USE_UTF8 bit is ON
300         ZipEntry e = createZipEntry(((flag &amp; USE_UTF8) != 0)
301                                     ? zc.toStringUTF8(b, len)
302                                     : zc.toString(b, len));
303         // now get the remaining fields for the entry
304         if ((flag &amp; 1) == 1) {
305             throw new ZipException(&quot;encrypted ZIP entry not supported&quot;);
306         }
307         e.method = get16(tmpbuf, LOCHOW);
308         e.xdostime = get32(tmpbuf, LOCTIM);
309         if ((flag &amp; 8) == 8) {
310             /* &quot;Data Descriptor&quot; present */
311             if (e.method != DEFLATED) {
312                 throw new ZipException(
313                         &quot;only DEFLATED entries can have EXT descriptor&quot;);
314             }
315         } else {
316             e.crc = get32(tmpbuf, LOCCRC);
317             e.csize = get32(tmpbuf, LOCSIZ);
318             e.size = get32(tmpbuf, LOCLEN);
319         }
320         len = get16(tmpbuf, LOCEXT);
321         if (len &gt; 0) {
322             byte[] extra = new byte[len];
323             readFully(extra, 0, len);
324             e.setExtra0(extra,
<a name="14" id="anc14"></a><span class="line-modified">325                         e.csize == ZIP64_MAGICVAL || e.size == ZIP64_MAGICVAL, true);</span>
326         }
327         return e;
328     }
329 
330     /**
<a name="15" id="anc15"></a><span class="line-modified">331      * Creates a new {@code ZipEntry} object for the specified</span>
332      * entry name.
333      *
334      * @param name the ZIP file entry name
335      * @return the ZipEntry just created
336      */
337     protected ZipEntry createZipEntry(String name) {
338         return new ZipEntry(name);
339     }
340 
341     /**
342      * Reads end of deflated entry as well as EXT descriptor if present.
343      *
344      * Local headers for DEFLATED entries may optionally be followed by a
345      * data descriptor, and that data descriptor may optionally contain a
346      * leading signature (EXTSIG).
347      *
348      * From the zip spec http://www.pkware.com/documents/casestudies/APPNOTE.TXT
349      *
350      * &quot;&quot;&quot;Although not originally assigned a signature, the value 0x08074b50
351      * has commonly been adopted as a signature value for the data descriptor
352      * record.  Implementers should be aware that ZIP files may be
353      * encountered with or without this signature marking data descriptors
354      * and should account for either case when reading ZIP files to ensure
355      * compatibility.&quot;&quot;&quot;
356      */
357     private void readEnd(ZipEntry e) throws IOException {
358         int n = inf.getRemaining();
359         if (n &gt; 0) {
360             ((PushbackInputStream)in).unread(buf, len - n, n);
361         }
362         if ((flag &amp; 8) == 8) {
363             /* &quot;Data Descriptor&quot; present */
364             if (inf.getBytesWritten() &gt; ZIP64_MAGICVAL ||
365                 inf.getBytesRead() &gt; ZIP64_MAGICVAL) {
366                 // ZIP64 format
367                 readFully(tmpbuf, 0, ZIP64_EXTHDR);
368                 long sig = get32(tmpbuf, 0);
369                 if (sig != EXTSIG) { // no EXTSIG present
370                     e.crc = sig;
371                     e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);
372                     e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);
373                     ((PushbackInputStream)in).unread(
374                         tmpbuf, ZIP64_EXTHDR - ZIP64_EXTCRC, ZIP64_EXTCRC);
375                 } else {
376                     e.crc = get32(tmpbuf, ZIP64_EXTCRC);
377                     e.csize = get64(tmpbuf, ZIP64_EXTSIZ);
378                     e.size = get64(tmpbuf, ZIP64_EXTLEN);
379                 }
380             } else {
381                 readFully(tmpbuf, 0, EXTHDR);
382                 long sig = get32(tmpbuf, 0);
383                 if (sig != EXTSIG) { // no EXTSIG present
384                     e.crc = sig;
385                     e.csize = get32(tmpbuf, EXTSIZ - EXTCRC);
386                     e.size = get32(tmpbuf, EXTLEN - EXTCRC);
387                     ((PushbackInputStream)in).unread(
388                                                tmpbuf, EXTHDR - EXTCRC, EXTCRC);
389                 } else {
390                     e.crc = get32(tmpbuf, EXTCRC);
391                     e.csize = get32(tmpbuf, EXTSIZ);
392                     e.size = get32(tmpbuf, EXTLEN);
393                 }
394             }
395         }
396         if (e.size != inf.getBytesWritten()) {
397             throw new ZipException(
398                 &quot;invalid entry size (expected &quot; + e.size +
399                 &quot; but got &quot; + inf.getBytesWritten() + &quot; bytes)&quot;);
400         }
401         if (e.csize != inf.getBytesRead()) {
402             throw new ZipException(
403                 &quot;invalid entry compressed size (expected &quot; + e.csize +
404                 &quot; but got &quot; + inf.getBytesRead() + &quot; bytes)&quot;);
405         }
406         if (e.crc != crc.getValue()) {
407             throw new ZipException(
408                 &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(e.crc) +
409                 &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);
410         }
411     }
412 
413     /*
414      * Reads bytes, blocking until all bytes are read.
415      */
416     private void readFully(byte[] b, int off, int len) throws IOException {
417         while (len &gt; 0) {
418             int n = in.read(b, off, len);
419             if (n == -1) {
420                 throw new EOFException();
421             }
422             off += n;
423             len -= n;
424         }
425     }
426 
427 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
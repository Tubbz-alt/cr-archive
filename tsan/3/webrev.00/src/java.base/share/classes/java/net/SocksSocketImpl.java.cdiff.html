<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/SocksSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketTimeoutException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StandardSocketOptions.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocksSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,41 ***</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package java.net;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
  import java.io.BufferedOutputStream;
  import java.security.AccessController;
  
  import jdk.internal.util.StaticProperty;
  import sun.net.SocksProxy;
  import sun.net.spi.DefaultProxySelector;
  import sun.net.www.ParseUtil;
  
  /**
   * SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).
<span class="line-removed">-  * This is a subclass of PlainSocketImpl.</span>
<span class="line-removed">-  * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.</span>
   */
  
<span class="line-modified">! class SocksSocketImpl extends PlainSocketImpl implements SocksConsts {</span>
      private String server = null;
      private int serverPort = DEFAULT_PORT;
      private InetSocketAddress external_address;
      private boolean useV4 = false;
      private Socket cmdsock = null;
      private InputStream cmdIn = null;
      private OutputStream cmdOut = null;
  
<span class="line-modified">!     SocksSocketImpl() {</span>
<span class="line-modified">!         // Nothing needed</span>
      }
  
<span class="line-modified">!     SocksSocketImpl(Proxy proxy) {</span>
          SocketAddress a = proxy.address();
          if (a instanceof InetSocketAddress) {
              InetSocketAddress ad = (InetSocketAddress) a;
              // Use getHostString() to avoid reverse lookups
              server = ad.getHostString();
<span class="line-new-header">--- 21,43 ---</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package java.net;
<span class="line-added">+ </span>
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
  import java.io.BufferedOutputStream;
<span class="line-added">+ import java.nio.charset.StandardCharsets;</span>
  import java.security.AccessController;
<span class="line-added">+ import java.util.Iterator;</span>
  
  import jdk.internal.util.StaticProperty;
  import sun.net.SocksProxy;
  import sun.net.spi.DefaultProxySelector;
  import sun.net.www.ParseUtil;
  
  /**
   * SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).
   */
  
<span class="line-modified">! class SocksSocketImpl extends DelegatingSocketImpl implements SocksConsts {</span>
      private String server = null;
      private int serverPort = DEFAULT_PORT;
      private InetSocketAddress external_address;
      private boolean useV4 = false;
      private Socket cmdsock = null;
      private InputStream cmdIn = null;
      private OutputStream cmdOut = null;
  
<span class="line-modified">!     SocksSocketImpl(SocketImpl delegate) {</span>
<span class="line-modified">!         super(delegate);</span>
      }
  
<span class="line-modified">!     SocksSocketImpl(Proxy proxy, SocketImpl delegate) {</span>
<span class="line-added">+         super(delegate);</span>
          SocketAddress a = proxy.address();
          if (a instanceof InetSocketAddress) {
              InetSocketAddress ad = (InetSocketAddress) a;
              // Use getHostString() to avoid reverse lookups
              server = ad.getHostString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,11 ***</span>
      }
  
      private synchronized void privilegedConnect(final String host,
                                                final int port,
                                                final int timeout)
<span class="line-modified">!          throws IOException</span>
      {
          try {
              AccessController.doPrivileged(
                  new java.security.PrivilegedExceptionAction&lt;&gt;() {
                      public Void run() throws IOException {
<span class="line-new-header">--- 75,11 ---</span>
      }
  
      private synchronized void privilegedConnect(final String host,
                                                final int port,
                                                final int timeout)
<span class="line-modified">!         throws IOException</span>
      {
          try {
              AccessController.doPrivileged(
                  new java.security.PrivilegedExceptionAction&lt;&gt;() {
                      public Void run() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
          }
      }
  
      private void superConnectServer(String host, int port,
                                      int timeout) throws IOException {
<span class="line-modified">!         super.connect(new InetSocketAddress(host, port), timeout);</span>
      }
  
      private static int remainingMillis(long deadlineMillis) throws IOException {
          if (deadlineMillis == 0L)
              return 0;
<span class="line-new-header">--- 94,11 ---</span>
          }
      }
  
      private void superConnectServer(String host, int port,
                                      int timeout) throws IOException {
<span class="line-modified">!         delegate.connect(new InetSocketAddress(host, port), timeout);</span>
      }
  
      private static int remainingMillis(long deadlineMillis) throws IOException {
          if (deadlineMillis == 0L)
              return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,20 ***</span>
      }
  
      private int readSocksReply(InputStream in, byte[] data, long deadlineMillis) throws IOException {
          int len = data.length;
          int received = 0;
<span class="line-modified">!         while (received &lt; len) {</span>
<span class="line-modified">!             int count;</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 count = ((SocketInputStream)in).read(data, received, len - received, remainingMillis(deadlineMillis));</span>
<span class="line-modified">!             } catch (SocketTimeoutException e) {</span>
<span class="line-modified">!                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>
              }
<span class="line-modified">!             if (count &lt; 0)</span>
<span class="line-modified">!                 throw new SocketException(&quot;Malformed reply from SOCKS server&quot;);</span>
<span class="line-removed">-             received += count;</span>
          }
          return received;
      }
  
      private boolean authenticate(byte method, InputStream in,
<span class="line-new-header">--- 111,27 ---</span>
      }
  
      private int readSocksReply(InputStream in, byte[] data, long deadlineMillis) throws IOException {
          int len = data.length;
          int received = 0;
<span class="line-modified">!         int originalTimeout = (int) getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             while (received &lt; len) {</span>
<span class="line-modified">!                 int count;</span>
<span class="line-modified">!                 int remaining = remainingMillis(deadlineMillis);</span>
<span class="line-modified">!                 setOption(SocketOptions.SO_TIMEOUT, remaining);</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     count = in.read(data, received, len - received);</span>
<span class="line-added">+                 } catch (SocketTimeoutException e) {</span>
<span class="line-added">+                     throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (count &lt; 0)</span>
<span class="line-added">+                     throw new SocketException(&quot;Malformed reply from SOCKS server&quot;);</span>
<span class="line-added">+                 received += count;</span>
              }
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             setOption(SocketOptions.SO_TIMEOUT, originalTimeout);</span>
          }
          return received;
      }
  
      private boolean authenticate(byte method, InputStream in,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,22 ***</span>
              }
              if (userName == null)
                  return false;
              out.write(1);
              out.write(userName.length());
<span class="line-modified">!             try {</span>
<span class="line-removed">-                 out.write(userName.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">-             } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">-                 assert false;</span>
<span class="line-removed">-             }</span>
              if (password != null) {
                  out.write(password.length());
<span class="line-modified">!                 try {</span>
<span class="line-removed">-                     out.write(password.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">-                 } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">-                     assert false;</span>
<span class="line-removed">-                 }</span>
              } else
                  out.write(0);
              out.flush();
              byte[] data = new byte[2];
              int i = readSocksReply(in, data, deadlineMillis);
<span class="line-new-header">--- 165,14 ---</span>
              }
              if (userName == null)
                  return false;
              out.write(1);
              out.write(userName.length());
<span class="line-modified">!             out.write(userName.getBytes(StandardCharsets.ISO_8859_1));</span>
              if (password != null) {
                  out.write(password.length());
<span class="line-modified">!                 out.write(password.getBytes(StandardCharsets.ISO_8859_1));</span>
              } else
                  out.write(0);
              out.flush();
              byte[] data = new byte[2];
              int i = readSocksReply(in, data, deadlineMillis);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,15 ***</span>
          out.write(CONNECT);
          out.write((endpoint.getPort() &gt;&gt; 8) &amp; 0xff);
          out.write((endpoint.getPort() &gt;&gt; 0) &amp; 0xff);
          out.write(endpoint.getAddress().getAddress());
          String userName = getUserName();
<span class="line-modified">!         try {</span>
<span class="line-removed">-             out.write(userName.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">-         } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">-             assert false;</span>
<span class="line-removed">-         }</span>
          out.write(0);
          out.flush();
          byte[] data = new byte[8];
          int n = readSocksReply(in, data, deadlineMillis);
          if (n != 8)
<span class="line-new-header">--- 199,11 ---</span>
          out.write(CONNECT);
          out.write((endpoint.getPort() &gt;&gt; 8) &amp; 0xff);
          out.write((endpoint.getPort() &gt;&gt; 0) &amp; 0xff);
          out.write(endpoint.getAddress().getAddress());
          String userName = getUserName();
<span class="line-modified">!         out.write(userName.getBytes(StandardCharsets.ISO_8859_1));</span>
          out.write(0);
          out.flush();
          byte[] data = new byte[8];
          int n = readSocksReply(in, data, deadlineMillis);
          if (n != 8)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,10 ***</span>
<span class="line-new-header">--- 234,20 ---</span>
              out.close();
              throw ex;
          }
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void connect(String host, int port) throws IOException {</span>
<span class="line-added">+         connect(new InetSocketAddress(host, port), 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void connect(InetAddress address, int port) throws IOException {</span>
<span class="line-added">+         connect(new InetSocketAddress(address, port), 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Connects the Socks Socket to the specified endpoint. It will first
       * connect to the SOCKS proxy and negotiate the access. If the proxy
       * grants the connections, then the connect is successful and all
       * further traffic will go to the &quot;real&quot; endpoint.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,11 ***</span>
                      });
              if (sel == null) {
                  /*
                   * No default proxySelector --&gt; direct connection
                   */
<span class="line-modified">!                 super.connect(epoint, remainingMillis(deadlineMillis));</span>
                  return;
              }
              URI uri;
              // Use getHostString() to avoid reverse lookups
              String host = epoint.getHostString();
<span class="line-new-header">--- 295,11 ---</span>
                      });
              if (sel == null) {
                  /*
                   * No default proxySelector --&gt; direct connection
                   */
<span class="line-modified">!                 delegate.connect(epoint, remainingMillis(deadlineMillis));</span>
                  return;
              }
              URI uri;
              // Use getHostString() to avoid reverse lookups
              String host = epoint.getHostString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,20 ***</span>
                  assert false : e;
                  uri = null;
              }
              Proxy p = null;
              IOException savedExc = null;
<span class="line-modified">!             java.util.Iterator&lt;Proxy&gt; iProxy = null;</span>
<span class="line-modified">!             iProxy = sel.select(uri).iterator();</span>
              if (iProxy == null || !(iProxy.hasNext())) {
<span class="line-modified">!                 super.connect(epoint, remainingMillis(deadlineMillis));</span>
                  return;
              }
              while (iProxy.hasNext()) {
                  p = iProxy.next();
                  if (p == null || p.type() != Proxy.Type.SOCKS) {
<span class="line-modified">!                     super.connect(epoint, remainingMillis(deadlineMillis));</span>
                      return;
                  }
  
                  if (!(p.address() instanceof InetSocketAddress))
                      throw new SocketException(&quot;Unknown address type for proxy: &quot; + p);
<span class="line-new-header">--- 315,24 ---</span>
                  assert false : e;
                  uri = null;
              }
              Proxy p = null;
              IOException savedExc = null;
<span class="line-modified">!             final Iterator&lt;Proxy&gt; iProxy;</span>
<span class="line-modified">!             try {</span>
<span class="line-added">+                 iProxy = sel.select(uri).iterator();</span>
<span class="line-added">+             } catch (IllegalArgumentException iae) {</span>
<span class="line-added">+                 throw new IOException(&quot;Failed to select a proxy&quot;, iae);</span>
<span class="line-added">+             }</span>
              if (iProxy == null || !(iProxy.hasNext())) {
<span class="line-modified">!                 delegate.connect(epoint, remainingMillis(deadlineMillis));</span>
                  return;
              }
              while (iProxy.hasNext()) {
                  p = iProxy.next();
                  if (p == null || p.type() != Proxy.Type.SOCKS) {
<span class="line-modified">!                     delegate.connect(epoint, remainingMillis(deadlineMillis));</span>
                      return;
                  }
  
                  if (!(p.address() instanceof InetSocketAddress))
                      throw new SocketException(&quot;Unknown address type for proxy: &quot; + p);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,15 ***</span>
          out.write(0);
          /* Test for IPV4/IPV6/Unresolved */
          if (epoint.isUnresolved()) {
              out.write(DOMAIN_NAME);
              out.write(epoint.getHostName().length());
<span class="line-modified">!             try {</span>
<span class="line-removed">-                 out.write(epoint.getHostName().getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">-             } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">-                 assert false;</span>
<span class="line-removed">-             }</span>
              out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
              out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
          } else if (epoint.getAddress() instanceof Inet6Address) {
              out.write(IPV6);
              out.write(epoint.getAddress().getAddress());
<span class="line-new-header">--- 414,11 ---</span>
          out.write(0);
          /* Test for IPV4/IPV6/Unresolved */
          if (epoint.isUnresolved()) {
              out.write(DOMAIN_NAME);
              out.write(epoint.getHostName().length());
<span class="line-modified">!             out.write(epoint.getHostName().getBytes(StandardCharsets.ISO_8859_1));</span>
              out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
              out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
          } else if (epoint.getAddress() instanceof Inet6Address) {
              out.write(IPV6);
              out.write(epoint.getAddress().getAddress());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,11 ***</span>
<span class="line-new-header">--- 514,19 ---</span>
              throw ex;
          }
          external_address = epoint;
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void listen(int backlog) {</span>
<span class="line-added">+         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void accept(SocketImpl s) {</span>
<span class="line-added">+         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">+     }</span>
  
      /**
       * Returns the value of this socket&#39;s {@code address} field.
       *
       * @return  the value of this socket&#39;s {@code address} field.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,11 ***</span>
      @Override
      protected InetAddress getInetAddress() {
          if (external_address != null)
              return external_address.getAddress();
          else
<span class="line-modified">!             return super.getInetAddress();</span>
      }
  
      /**
       * Returns the value of this socket&#39;s {@code port} field.
       *
<span class="line-new-header">--- 535,11 ---</span>
      @Override
      protected InetAddress getInetAddress() {
          if (external_address != null)
              return external_address.getAddress();
          else
<span class="line-modified">!             return delegate.getInetAddress();</span>
      }
  
      /**
       * Returns the value of this socket&#39;s {@code port} field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,20 ***</span>
      @Override
      protected int getPort() {
          if (external_address != null)
              return external_address.getPort();
          else
<span class="line-modified">!             return super.getPort();</span>
      }
  
      @Override
      protected void close() throws IOException {
          if (cmdsock != null)
              cmdsock.close();
          cmdsock = null;
<span class="line-modified">!         super.close();</span>
      }
  
      private String getUserName() {
          return StaticProperty.userName();
      }
  }
<span class="line-new-header">--- 549,25 ---</span>
      @Override
      protected int getPort() {
          if (external_address != null)
              return external_address.getPort();
          else
<span class="line-modified">!             return delegate.getPort();</span>
      }
  
      @Override
      protected void close() throws IOException {
          if (cmdsock != null)
              cmdsock.close();
          cmdsock = null;
<span class="line-modified">!         delegate.close();</span>
      }
  
      private String getUserName() {
          return StaticProperty.userName();
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     void reset() {</span>
<span class="line-added">+         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="SocketTimeoutException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StandardSocketOptions.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
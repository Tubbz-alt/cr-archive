<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/math/BigDecimal.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../lang/reflect/UndeclaredThrowableException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BigInteger.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/math/BigDecimal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,10 ***</span>
<span class="line-new-header">--- 278,11 ---</span>
      // All 18-digit base ten strings fit into a long; not all 19-digit
      // strings will
      private static final int MAX_COMPACT_DIGITS = 18;
  
      /* Appease the serialization gods */
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 6108874887143696463L;
  
      private static final ThreadLocal&lt;StringBuilderHelper&gt;
          threadLocalStringBuilderHelper = new ThreadLocal&lt;StringBuilderHelper&gt;() {
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2116,11 ***</span>
              // precision for the cohort of the numerical value. To
              // allow binary floating-point hardware to be used to get
              // approximately a 15 digit approximation to the square
              // root, it is helpful to instead normalize this so that
              // the significand portion is to right of the decimal
<span class="line-modified">!             // point by roughly (scale() - precision() +1).</span>
  
              // Now the precision / scale adjustment
              int scaleAdjust = 0;
              int scale = stripped.scale() - stripped.precision() + 1;
              if (scale % 2 == 0) {
<span class="line-new-header">--- 2117,11 ---</span>
              // precision for the cohort of the numerical value. To
              // allow binary floating-point hardware to be used to get
              // approximately a 15 digit approximation to the square
              // root, it is helpful to instead normalize this so that
              // the significand portion is to right of the decimal
<span class="line-modified">!             // point by roughly (scale() - precision() + 1).</span>
  
              // Now the precision / scale adjustment
              int scaleAdjust = 0;
              int scale = stripped.scale() - stripped.precision() + 1;
              if (scale % 2 == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2144,11 ***</span>
              // Newton iterations in BigDecimal arithmetic to get the
              // working answer to 15 digits of precision. If many fewer
              // than 15 digits were needed, it might be faster to do
              // the loop entirely in BigDecimal arithmetic.
              //
<span class="line-modified">!             // (A double value might have as much many as 17 decimal</span>
              // digits of precision; it depends on the relative density
              // of binary and decimal numbers at different regions of
              // the number line.)
              //
              // (It would be possible to check for certain special
<span class="line-new-header">--- 2145,11 ---</span>
              // Newton iterations in BigDecimal arithmetic to get the
              // working answer to 15 digits of precision. If many fewer
              // than 15 digits were needed, it might be faster to do
              // the loop entirely in BigDecimal arithmetic.
              //
<span class="line-modified">!             // (A double value might have as many as 17 decimal</span>
              // digits of precision; it depends on the relative density
              // of binary and decimal numbers at different regions of
              // the number line.)
              //
              // (It would be possible to check for certain special
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2168,11 ***</span>
              // an N digit number by itself yield a 2N-1 digit or 2N
              // digit result.
              if (originalPrecision == 0) {
                  targetPrecision = stripped.precision()/2 + 1;
              } else {
<span class="line-modified">!                 targetPrecision = originalPrecision;</span>
              }
  
              // When setting the precision to use inside the Newton
              // iteration loop, take care to avoid the case where the
              // precision of the input exceeds the requested precision
<span class="line-new-header">--- 2169,29 ---</span>
              // an N digit number by itself yield a 2N-1 digit or 2N
              // digit result.
              if (originalPrecision == 0) {
                  targetPrecision = stripped.precision()/2 + 1;
              } else {
<span class="line-modified">!                 /*</span>
<span class="line-added">+                  * To avoid the need for post-Newton fix-up logic, in</span>
<span class="line-added">+                  * the case of half-way rounding modes, double the</span>
<span class="line-added">+                  * target precision so that the &quot;2p + 2&quot; property can</span>
<span class="line-added">+                  * be relied on to accomplish the final rounding.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 switch (mc.getRoundingMode()) {</span>
<span class="line-added">+                 case HALF_UP:</span>
<span class="line-added">+                 case HALF_DOWN:</span>
<span class="line-added">+                 case HALF_EVEN:</span>
<span class="line-added">+                     targetPrecision = 2 * originalPrecision;</span>
<span class="line-added">+                     if (targetPrecision &lt; 0) // Overflow</span>
<span class="line-added">+                         targetPrecision = Integer.MAX_VALUE - 2;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     targetPrecision = originalPrecision;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
              }
  
              // When setting the precision to use inside the Newton
              // iteration loop, take care to avoid the case where the
              // precision of the input exceeds the requested precision
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2196,111 ***</span>
                  MathContext mcTmp = new MathContext(targetPrecision, tmpRm);
                  result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);
  
                  // If result*result != this numerically, the square
                  // root isn&#39;t exact
<span class="line-modified">!                 if (this.subtract(result.multiply(result)).compareTo(ZERO) != 0) {</span>
                      throw new ArithmeticException(&quot;Computed square root not exact.&quot;);
                  }
              } else {
                  result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);
              }
  
              if (result.scale() != preferredScale) {
                  // The preferred scale of an add is
                  // max(addend.scale(), augend.scale()). Therefore, if
                  // the scale of the result is first minimized using
                  // stripTrailingZeros(), adding a zero of the
<span class="line-modified">!                 // preferred scale rounding the correct precision will</span>
<span class="line-modified">!                 // perform the proper scale vs precision tradeoffs.</span>
                  result = result.stripTrailingZeros().
                      add(zeroWithFinalPreferredScale,
                          new MathContext(originalPrecision, RoundingMode.UNNECESSARY));
              }
<span class="line-removed">-             assert squareRootResultAssertions(result, mc);</span>
              return result;
          } else {
              switch (signum) {
              case -1:
                  throw new ArithmeticException(&quot;Attempted square root &quot; +
                                                &quot;of negative BigDecimal&quot;);
              case 0:
<span class="line-modified">!                 return valueOf(0L, scale()/2);</span>
  
              default:
                  throw new AssertionError(&quot;Bad value from signum&quot;);
              }
          }
      }
  
      private boolean isPowerOfTen() {
          return BigInteger.ONE.equals(this.unscaledValue());
      }
  
      /**
       * For nonzero values, check numerical correctness properties of
       * the computed result for the chosen rounding mode.
       *
<span class="line-modified">!      * For the directed roundings, for DOWN and FLOOR, result^2 must</span>
<span class="line-modified">!      * be {@code &lt;=} the input and (result+ulp)^2 must be {@code &gt;} the</span>
<span class="line-modified">!      * input. Conversely, for UP and CEIL, result^2 must be {@code &gt;=} the</span>
<span class="line-modified">!      * input and (result-ulp)^2 must be {@code &lt;} the input.</span>
       */
      private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {
          if (result.signum() == 0) {
              return squareRootZeroResultAssertions(result, mc);
          } else {
              RoundingMode rm = mc.getRoundingMode();
              BigDecimal ulp = result.ulp();
              BigDecimal neighborUp   = result.add(ulp);
              // Make neighbor down accurate even for powers of ten
<span class="line-modified">!             if (this.isPowerOfTen()) {</span>
                  ulp = ulp.divide(TEN);
              }
              BigDecimal neighborDown = result.subtract(ulp);
  
              // Both the starting value and result should be nonzero and positive.
<span class="line-modified">!             if (result.signum() != 1 ||</span>
<span class="line-modified">!                 this.signum() != 1) {</span>
<span class="line-modified">!                 return false;</span>
<span class="line-removed">-             }</span>
  
              switch (rm) {
              case DOWN:
              case FLOOR:
<span class="line-modified">!                 return</span>
<span class="line-modified">!                     result.multiply(result).compareTo(this)         &lt;= 0 &amp;&amp;</span>
<span class="line-modified">!                     neighborUp.multiply(neighborUp).compareTo(this) &gt; 0;</span>
  
              case UP:
              case CEILING:
<span class="line-modified">!                 return</span>
<span class="line-modified">!                     result.multiply(result).compareTo(this)             &gt;= 0 &amp;&amp;</span>
<span class="line-modified">!                     neighborDown.multiply(neighborDown).compareTo(this) &lt; 0;</span>
  
              case HALF_DOWN:
              case HALF_EVEN:
              case HALF_UP:
<span class="line-modified">!                 BigDecimal err = result.multiply(result).subtract(this).abs();</span>
<span class="line-modified">!                 BigDecimal errUp = neighborUp.multiply(neighborUp).subtract(this);</span>
<span class="line-modified">!                 BigDecimal errDown =  this.subtract(neighborDown.multiply(neighborDown));</span>
                  // All error values should be positive so don&#39;t need to
                  // compare absolute values.
  
                  int err_comp_errUp = err.compareTo(errUp);
                  int err_comp_errDown = err.compareTo(errDown);
  
<span class="line-modified">!                 return</span>
                      errUp.signum()   == 1 &amp;&amp;
<span class="line-modified">!                     errDown.signum() == 1 &amp;&amp;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     err_comp_errUp   &lt;= 0 &amp;&amp;</span>
<span class="line-modified">!                     err_comp_errDown &lt;= 0 &amp;&amp;</span>
<span class="line-modified">! </span>
                      ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;
<span class="line-modified">!                     ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true);</span>
                  // &amp;&amp; could check for digit conditions for ties too
  
              default: // Definition of UNNECESSARY already verified.
                  return true;
              }
          }
<span class="line-new-header">--- 2215,185 ---</span>
                  MathContext mcTmp = new MathContext(targetPrecision, tmpRm);
                  result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);
  
                  // If result*result != this numerically, the square
                  // root isn&#39;t exact
<span class="line-modified">!                 if (this.subtract(result.square()).compareTo(ZERO) != 0) {</span>
                      throw new ArithmeticException(&quot;Computed square root not exact.&quot;);
                  }
              } else {
                  result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);
<span class="line-added">+ </span>
<span class="line-added">+                 switch (targetRm) {</span>
<span class="line-added">+                 case DOWN:</span>
<span class="line-added">+                 case FLOOR:</span>
<span class="line-added">+                     // Check if too big</span>
<span class="line-added">+                     if (result.square().compareTo(this) &gt; 0) {</span>
<span class="line-added">+                         BigDecimal ulp = result.ulp();</span>
<span class="line-added">+                         // Adjust increment down in case of 1.0 = 10^0</span>
<span class="line-added">+                         // since the next smaller number is only 1/10</span>
<span class="line-added">+                         // as far way as the next larger at exponent</span>
<span class="line-added">+                         // boundaries. Test approx and *not* result to</span>
<span class="line-added">+                         // avoid having to detect an arbitrary power</span>
<span class="line-added">+                         // of ten.</span>
<span class="line-added">+                         if (approx.compareTo(ONE) == 0) {</span>
<span class="line-added">+                             ulp = ulp.multiply(ONE_TENTH);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         result = result.subtract(ulp);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case UP:</span>
<span class="line-added">+                 case CEILING:</span>
<span class="line-added">+                     // Check if too small</span>
<span class="line-added">+                     if (result.square().compareTo(this) &lt; 0) {</span>
<span class="line-added">+                         result = result.add(result.ulp());</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     // No additional work, rely on &quot;2p + 2&quot; property</span>
<span class="line-added">+                     // for correct rounding. Alternatively, could</span>
<span class="line-added">+                     // instead run the Newton iteration to around p</span>
<span class="line-added">+                     // digits and then do tests and fix-ups on the</span>
<span class="line-added">+                     // rounded value. One possible set of tests and</span>
<span class="line-added">+                     // fix-ups is given in the Hull and Abrham paper;</span>
<span class="line-added">+                     // however, additional half-way cases can occur</span>
<span class="line-added">+                     // for BigDecimal given the more varied</span>
<span class="line-added">+                     // combinations of input and output precisions</span>
<span class="line-added">+                     // supported.</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
              }
  
<span class="line-added">+             // Test numerical properties at full precision before any</span>
<span class="line-added">+             // scale adjustments.</span>
<span class="line-added">+             assert squareRootResultAssertions(result, mc);</span>
              if (result.scale() != preferredScale) {
                  // The preferred scale of an add is
                  // max(addend.scale(), augend.scale()). Therefore, if
                  // the scale of the result is first minimized using
                  // stripTrailingZeros(), adding a zero of the
<span class="line-modified">!                 // preferred scale rounding to the correct precision</span>
<span class="line-modified">!                 // will perform the proper scale vs precision</span>
<span class="line-added">+                 // tradeoffs.</span>
                  result = result.stripTrailingZeros().
                      add(zeroWithFinalPreferredScale,
                          new MathContext(originalPrecision, RoundingMode.UNNECESSARY));
              }
              return result;
          } else {
<span class="line-added">+             BigDecimal result = null;</span>
              switch (signum) {
              case -1:
                  throw new ArithmeticException(&quot;Attempted square root &quot; +
                                                &quot;of negative BigDecimal&quot;);
              case 0:
<span class="line-modified">!                 result = valueOf(0L, scale()/2);</span>
<span class="line-added">+                 assert squareRootResultAssertions(result, mc);</span>
<span class="line-added">+                 return result;</span>
  
              default:
                  throw new AssertionError(&quot;Bad value from signum&quot;);
              }
          }
      }
  
<span class="line-added">+     private BigDecimal square() {</span>
<span class="line-added">+         return this.multiply(this);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private boolean isPowerOfTen() {
          return BigInteger.ONE.equals(this.unscaledValue());
      }
  
      /**
       * For nonzero values, check numerical correctness properties of
       * the computed result for the chosen rounding mode.
       *
<span class="line-modified">!      * For the directed rounding modes:</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;ul&gt;</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * &lt;li&gt; For DOWN and FLOOR, result^2 must be {@code &lt;=} the input</span>
<span class="line-added">+      * and (result+ulp)^2 must be {@code &gt;} the input.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;li&gt;Conversely, for UP and CEIL, result^2 must be {@code &gt;=}</span>
<span class="line-added">+      * the input and (result-ulp)^2 must be {@code &lt;} the input.</span>
<span class="line-added">+      * &lt;/ul&gt;</span>
       */
      private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {
          if (result.signum() == 0) {
              return squareRootZeroResultAssertions(result, mc);
          } else {
              RoundingMode rm = mc.getRoundingMode();
              BigDecimal ulp = result.ulp();
              BigDecimal neighborUp   = result.add(ulp);
              // Make neighbor down accurate even for powers of ten
<span class="line-modified">!             if (result.isPowerOfTen()) {</span>
                  ulp = ulp.divide(TEN);
              }
              BigDecimal neighborDown = result.subtract(ulp);
  
              // Both the starting value and result should be nonzero and positive.
<span class="line-modified">!             assert (result.signum() == 1 &amp;&amp;</span>
<span class="line-modified">!                     this.signum() == 1) :</span>
<span class="line-modified">!                 &quot;Bad signum of this and/or its sqrt.&quot;;</span>
  
              switch (rm) {
              case DOWN:
              case FLOOR:
<span class="line-modified">!                 assert</span>
<span class="line-modified">!                     result.square().compareTo(this)     &lt;= 0 &amp;&amp;</span>
<span class="line-modified">!                     neighborUp.square().compareTo(this) &gt; 0:</span>
<span class="line-added">+                 &quot;Square of result out for bounds rounding &quot; + rm;</span>
<span class="line-added">+                 return true;</span>
  
              case UP:
              case CEILING:
<span class="line-modified">!                 assert</span>
<span class="line-modified">!                     result.square().compareTo(this)       &gt;= 0 &amp;&amp;</span>
<span class="line-modified">!                     neighborDown.square().compareTo(this) &lt; 0:</span>
<span class="line-added">+                 &quot;Square of result out for bounds rounding &quot; + rm;</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+ </span>
  
              case HALF_DOWN:
              case HALF_EVEN:
              case HALF_UP:
<span class="line-modified">!                 BigDecimal err = result.square().subtract(this).abs();</span>
<span class="line-modified">!                 BigDecimal errUp = neighborUp.square().subtract(this);</span>
<span class="line-modified">!                 BigDecimal errDown =  this.subtract(neighborDown.square());</span>
                  // All error values should be positive so don&#39;t need to
                  // compare absolute values.
  
                  int err_comp_errUp = err.compareTo(errUp);
                  int err_comp_errDown = err.compareTo(errDown);
  
<span class="line-modified">!                 assert</span>
                      errUp.signum()   == 1 &amp;&amp;
<span class="line-modified">!                     errDown.signum() == 1 :</span>
<span class="line-modified">!                 &quot;Errors of neighbors squared don&#39;t have correct signs&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // For breaking a half-way tie, the return value may</span>
<span class="line-modified">!                 // have a larger error than one of the neighbors. For</span>
<span class="line-added">+                 // example, the square root of 2.25 to a precision of</span>
<span class="line-added">+                 // 1 digit is either 1 or 2 depending on how the exact</span>
<span class="line-added">+                 // value of 1.5 is rounded. If 2 is returned, it will</span>
<span class="line-added">+                 // have a larger rounding error than its neighbor 1.</span>
<span class="line-added">+                 assert</span>
<span class="line-added">+                     err_comp_errUp   &lt;= 0 ||</span>
<span class="line-added">+                     err_comp_errDown &lt;= 0 :</span>
<span class="line-added">+                 &quot;Computed square root has larger error than neighbors for &quot; + rm;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 assert</span>
                      ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;
<span class="line-modified">!                     ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true) :</span>
<span class="line-added">+                         &quot;Incorrect error relationships&quot;;</span>
                  // &amp;&amp; could check for digit conditions for ties too
<span class="line-added">+                 return true;</span>
  
              default: // Definition of UNNECESSARY already verified.
                  return true;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3412,13 ***</span>
       * @return this {@code BigDecimal} converted to a {@code long}.
       * @jls 5.1.3 Narrowing Primitive Conversion
       */
      @Override
      public long longValue(){
<span class="line-modified">!         return (intCompact != INFLATED &amp;&amp; scale == 0) ?</span>
<span class="line-modified">!             intCompact:</span>
<span class="line-modified">!             toBigInteger().longValue();</span>
      }
  
      /**
       * Converts this {@code BigDecimal} to a {@code long}, checking
       * for lost information.  If this {@code BigDecimal} has a
<span class="line-new-header">--- 3505,36 ---</span>
       * @return this {@code BigDecimal} converted to a {@code long}.
       * @jls 5.1.3 Narrowing Primitive Conversion
       */
      @Override
      public long longValue(){
<span class="line-modified">!         if (intCompact != INFLATED &amp;&amp; scale == 0) {</span>
<span class="line-modified">!             return intCompact;</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+             // Fastpath zero and small values</span>
<span class="line-added">+             if (this.signum() == 0 || fractionOnly() ||</span>
<span class="line-added">+                 // Fastpath very large-scale values that will result</span>
<span class="line-added">+                 // in a truncated value of zero. If the scale is -64</span>
<span class="line-added">+                 // or less, there are at least 64 powers of 10 in the</span>
<span class="line-added">+                 // value of the numerical result. Since 10 = 2*5, in</span>
<span class="line-added">+                 // that case there would also be 64 powers of 2 in the</span>
<span class="line-added">+                 // result, meaning all 64 bits of a long will be zero.</span>
<span class="line-added">+                 scale &lt;= -64) {</span>
<span class="line-added">+                 return 0;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return toBigInteger().longValue();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return true if a nonzero BigDecimal has an absolute value less</span>
<span class="line-added">+      * than one; i.e. only has fraction digits.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean fractionOnly() {</span>
<span class="line-added">+         assert this.signum() != 0;</span>
<span class="line-added">+         return (this.precision() - this.scale) &lt;= 0;</span>
      }
  
      /**
       * Converts this {@code BigDecimal} to a {@code long}, checking
       * for lost information.  If this {@code BigDecimal} has a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3432,19 ***</span>
       * @since  1.5
       */
      public long longValueExact() {
          if (intCompact != INFLATED &amp;&amp; scale == 0)
              return intCompact;
<span class="line-modified">!         // If more than 19 digits in integer part it cannot possibly fit</span>
<span class="line-modified">!         if ((precision() - scale) &gt; 19) // [OK for negative scale too]</span>
<span class="line-removed">-             throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="line-removed">-         // Fastpath zero and &lt; 1.0 numbers (the latter can be very slow</span>
<span class="line-removed">-         // to round if very small)</span>
          if (this.signum() == 0)
              return 0;
<span class="line-modified">!         if ((this.precision() - this.scale) &lt;= 0)</span>
              throw new ArithmeticException(&quot;Rounding necessary&quot;);
          // round to an integer, with Exception if decimal part non-0
          BigDecimal num = this.setScale(0, ROUND_UNNECESSARY);
          if (num.precision() &gt;= 19) // need to check carefully
              LongOverflow.check(num);
          return num.inflated().longValue();
<span class="line-new-header">--- 3548,24 ---</span>
       * @since  1.5
       */
      public long longValueExact() {
          if (intCompact != INFLATED &amp;&amp; scale == 0)
              return intCompact;
<span class="line-modified">! </span>
<span class="line-modified">!         // Fastpath zero</span>
          if (this.signum() == 0)
              return 0;
<span class="line-modified">! </span>
<span class="line-added">+         // Fastpath numbers less than 1.0 (the latter can be very slow</span>
<span class="line-added">+         // to round if very small)</span>
<span class="line-added">+         if (fractionOnly())</span>
              throw new ArithmeticException(&quot;Rounding necessary&quot;);
<span class="line-added">+ </span>
<span class="line-added">+         // If more than 19 digits in integer part it cannot possibly fit</span>
<span class="line-added">+         if ((precision() - scale) &gt; 19) // [OK for negative scale too]</span>
<span class="line-added">+             throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="line-added">+ </span>
          // round to an integer, with Exception if decimal part non-0
          BigDecimal num = this.setScale(0, ROUND_UNNECESSARY);
          if (num.precision() &gt;= 19) // need to check carefully
              LongOverflow.check(num);
          return num.inflated().longValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3484,11 ***</span>
       */
      @Override
      public int intValue() {
          return  (intCompact != INFLATED &amp;&amp; scale == 0) ?
              (int)intCompact :
<span class="line-modified">!             toBigInteger().intValue();</span>
      }
  
      /**
       * Converts this {@code BigDecimal} to an {@code int}, checking
       * for lost information.  If this {@code BigDecimal} has a
<span class="line-new-header">--- 3605,11 ---</span>
       */
      @Override
      public int intValue() {
          return  (intCompact != INFLATED &amp;&amp; scale == 0) ?
              (int)intCompact :
<span class="line-modified">!             (int)longValue();</span>
      }
  
      /**
       * Converts this {@code BigDecimal} to an {@code int}, checking
       * for lost information.  If this {@code BigDecimal} has a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4097,10 ***</span>
<span class="line-new-header">--- 4218,11 ---</span>
       * Reconstitute the {@code BigDecimal} instance from a stream (that is,
       * deserialize it).
       *
       * @param s the stream being read.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(java.io.ObjectInputStream s)
          throws java.io.IOException, ClassNotFoundException {
          // Read in all fields
          s.defaultReadObject();
          // validate possibly bad fields
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4115,10 ***</span>
<span class="line-new-header">--- 4237,11 ---</span>
     /**
      * Serialize this {@code BigDecimal} to the stream in question
      *
      * @param s the stream to serialize to.
      */
<span class="line-added">+     @java.io.Serial</span>
     private void writeObject(java.io.ObjectOutputStream s)
         throws java.io.IOException {
         // Must inflate to maintain compatible serial form.
         if (this.intVal == null)
             UnsafeHolder.setIntValVolatile(this, BigInteger.valueOf(this.intCompact));
</pre>
<center><a href="../lang/reflect/UndeclaredThrowableException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BigInteger.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
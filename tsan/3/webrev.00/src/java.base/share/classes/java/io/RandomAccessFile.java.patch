diff a/src/java.base/share/classes/java/io/RandomAccessFile.java b/src/java.base/share/classes/java/io/RandomAccessFile.java
--- a/src/java.base/share/classes/java/io/RandomAccessFile.java
+++ b/src/java.base/share/classes/java/io/RandomAccessFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -101,21 +101,21 @@
      * is also called with the {@code name} argument
      * as its argument to see if write access to the file is allowed.
      *
      * @param      name   the system-dependent filename
      * @param      mode   the access <a href="#mode">mode</a>
-     * @exception  IllegalArgumentException  if the mode argument is not equal
+     * @throws     IllegalArgumentException  if the mode argument is not equal
      *             to one of {@code "r"}, {@code "rw"}, {@code "rws"}, or
      *             {@code "rwd"}
-     * @exception FileNotFoundException
-     *            if the mode is {@code "r"} but the given string does not
-     *            denote an existing regular file, or if the mode begins with
-     *            {@code "rw"} but the given string does not denote an
-     *            existing, writable regular file and a new regular file of
-     *            that name cannot be created, or if some other error occurs
-     *            while opening or creating the file
-     * @exception  SecurityException   if a security manager exists and its
+     * @throws     FileNotFoundException
+     *             if the mode is {@code "r"} but the given string does not
+     *             denote an existing regular file, or if the mode begins with
+     *             {@code "rw"} but the given string does not denote an
+     *             existing, writable regular file and a new regular file of
+     *             that name cannot be created, or if some other error occurs
+     *             while opening or creating the file
+     * @throws      SecurityException   if a security manager exists and its
      *             {@code checkRead} method denies read access to the file
      *             or the mode is {@code "rw"} and the security manager's
      *             {@code checkWrite} method denies write access to the file
      * @see        java.lang.SecurityException
      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
@@ -188,21 +188,21 @@
      * allowed.
      *
      * @param      file   the file object
      * @param      mode   the access mode, as described
      *                    <a href="#mode">above</a>
-     * @exception  IllegalArgumentException  if the mode argument is not equal
+     * @throws     IllegalArgumentException  if the mode argument is not equal
      *             to one of {@code "r"}, {@code "rw"}, {@code "rws"}, or
      *             {@code "rwd"}
-     * @exception FileNotFoundException
-     *            if the mode is {@code "r"} but the given file object does
-     *            not denote an existing regular file, or if the mode begins
-     *            with {@code "rw"} but the given file object does not denote
-     *            an existing, writable regular file and a new regular file of
-     *            that name cannot be created, or if some other error occurs
-     *            while opening or creating the file
-     * @exception  SecurityException  if a security manager exists and its
+     * @throws     FileNotFoundException
+     *             if the mode is {@code "r"} but the given file object does
+     *             not denote an existing regular file, or if the mode begins
+     *             with {@code "rw"} but the given file object does not denote
+     *             an existing, writable regular file and a new regular file of
+     *             that name cannot be created, or if some other error occurs
+     *             while opening or creating the file
+     * @throws      SecurityException  if a security manager exists and its
      *             {@code checkRead} method denies read access to the file
      *             or the mode is {@code "rw"} and the security manager's
      *             {@code checkWrite} method denies write access to the file
      * @see        java.lang.SecurityManager#checkRead(java.lang.String)
      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
@@ -265,11 +265,11 @@
     /**
      * Returns the opaque file descriptor object associated with this
      * stream.
      *
      * @return     the file descriptor object associated with this stream.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.FileDescriptor
      */
     public final FileDescriptor getFD() throws IOException {
         if (fd != null) {
             return fd;
@@ -359,25 +359,25 @@
      * way as the {@link InputStream#read()} method of
      * {@code InputStream}.
      *
      * @return     the next byte of data, or {@code -1} if the end of the
      *             file has been reached.
-     * @exception  IOException  if an I/O error occurs. Not thrown if
+     * @throws     IOException  if an I/O error occurs. Not thrown if
      *                          end-of-file has been reached.
      */
     public int read() throws IOException {
         return read0();
     }
 
     private native int read0() throws IOException;
 
     /**
      * Reads a sub array as a sequence of bytes.
-     * @param b the buffer into which the data is read.
-     * @param off the start offset of the data.
-     * @param len the number of bytes to read.
-     * @exception IOException If an I/O error has occurred.
+     * @param     b the buffer into which the data is read.
+     * @param     off the start offset of the data.
+     * @param     len the number of bytes to read.
+     * @throws    IOException If an I/O error has occurred.
      */
     private native int readBytes(byte b[], int off, int len) throws IOException;
 
     /**
      * Reads up to {@code len} bytes of data from this file into an
@@ -394,17 +394,17 @@
      *                   at which the data is written.
      * @param      len   the maximum number of bytes read.
      * @return     the total number of bytes read into the buffer, or
      *             {@code -1} if there is no more data because the end of
      *             the file has been reached.
-     * @exception  IOException If the first byte cannot be read for any reason
-     * other than end of file, or if the random access file has been closed, or if
-     * some other I/O error occurs.
-     * @exception  NullPointerException If {@code b} is {@code null}.
-     * @exception  IndexOutOfBoundsException If {@code off} is negative,
-     * {@code len} is negative, or {@code len} is greater than
-     * {@code b.length - off}
+     * @throws     IOException If the first byte cannot be read for any reason
+     *             other than end of file, or if the random access file has been closed,
+     *             or if some other I/O error occurs.
+     * @throws     NullPointerException If {@code b} is {@code null}.
+     * @throws     IndexOutOfBoundsException If {@code off} is negative,
+     *             {@code len} is negative, or {@code len} is greater than
+     *             {@code b.length - off}
      */
     public int read(byte b[], int off, int len) throws IOException {
         return readBytes(b, off, len);
     }
 
@@ -420,14 +420,14 @@
      *
      * @param      b   the buffer into which the data is read.
      * @return     the total number of bytes read into the buffer, or
      *             {@code -1} if there is no more data because the end of
      *             this file has been reached.
-     * @exception  IOException If the first byte cannot be read for any reason
-     * other than end of file, or if the random access file has been closed, or if
-     * some other I/O error occurs.
-     * @exception  NullPointerException If {@code b} is {@code null}.
+     * @throws     IOException If the first byte cannot be read for any reason
+     *             other than end of file, or if the random access file has been closed,
+     *             or if some other I/O error occurs.
+     * @throws     NullPointerException If {@code b} is {@code null}.
      */
     public int read(byte b[]) throws IOException {
         return readBytes(b, 0, b.length);
     }
 
@@ -488,11 +488,11 @@
      * The actual number of bytes skipped is returned.  If {@code n}
      * is negative, no bytes are skipped.
      *
      * @param      n   the number of bytes to be skipped.
      * @return     the actual number of bytes skipped.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public int skipBytes(int n) throws IOException {
         long pos;
         long len;
         long newpos;
@@ -517,34 +517,34 @@
     /**
      * Writes the specified byte to this file. The write starts at
      * the current file pointer.
      *
      * @param      b   the {@code byte} to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public void write(int b) throws IOException {
         write0(b);
     }
 
     private native void write0(int b) throws IOException;
 
     /**
      * Writes a sub array as a sequence of bytes.
-     * @param b the data to be written
+     * @param     b the data to be written
 
-     * @param off the start offset in the data
-     * @param len the number of bytes that are written
-     * @exception IOException If an I/O error has occurred.
+     * @param     off the start offset in the data
+     * @param     len the number of bytes that are written
+     * @throws    IOException If an I/O error has occurred.
      */
     private native void writeBytes(byte b[], int off, int len) throws IOException;
 
     /**
      * Writes {@code b.length} bytes from the specified byte array
      * to this file, starting at the current file pointer.
      *
      * @param      b   the data.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public void write(byte b[]) throws IOException {
         writeBytes(b, 0, b.length);
     }
 
@@ -553,11 +553,11 @@
      * starting at offset {@code off} to this file.
      *
      * @param      b     the data.
      * @param      off   the start offset in the data.
      * @param      len   the number of bytes to write.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public void write(byte b[], int off, int len) throws IOException {
         writeBytes(b, off, len);
     }
 
@@ -566,11 +566,11 @@
     /**
      * Returns the current offset in this file.
      *
      * @return     the offset from the beginning of the file, in bytes,
      *             at which the next read or write occurs.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public native long getFilePointer() throws IOException;
 
     /**
      * Sets the file-pointer offset, measured from the beginning of this
@@ -581,11 +581,11 @@
      * of the file.
      *
      * @param      pos   the offset position, measured in bytes from the
      *                   beginning of the file, at which to set the file
      *                   pointer.
-     * @exception  IOException  if {@code pos} is less than
+     * @throws     IOException  if {@code pos} is less than
      *                          {@code 0} or if an I/O error occurs.
      */
     public void seek(long pos) throws IOException {
         if (pos < 0) {
             throw new IOException("Negative seek offset");
@@ -598,11 +598,11 @@
 
     /**
      * Returns the length of this file.
      *
      * @return     the length of this file, measured in bytes.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public native long length() throws IOException;
 
     /**
      * Sets the length of this file.
@@ -618,11 +618,11 @@
      * {@code length} method is smaller than the {@code newLength}
      * argument then the file will be extended.  In this case, the contents of
      * the extended portion of the file are not defined.
      *
      * @param      newLength    The desired length of the file
-     * @exception  IOException  If an I/O error occurs
+     * @throws     IOException  If an I/O error occurs
      * @since      1.2
      */
     public native void setLength(long newLength) throws IOException;
 
     /**
@@ -632,11 +632,11 @@
      * reopened.
      *
      * <p> If this file has an associated channel then the channel is closed
      * as well.
      *
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      *
      * @revised 1.4
      * @spec JSR-51
      */
     public void close() throws IOException {
@@ -676,12 +676,12 @@
      * {@code false}. Any other value represents {@code true}.
      * This method blocks until the byte is read, the end of the stream
      * is detected, or an exception is thrown.
      *
      * @return     the {@code boolean} value read.
-     * @exception  EOFException  if this file has reached the end.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     EOFException  if this file has reached the end.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final boolean readBoolean() throws IOException {
         int ch = this.read();
         if (ch < 0)
             throw new EOFException();
@@ -701,12 +701,12 @@
      * This method blocks until the byte is read, the end of the stream
      * is detected, or an exception is thrown.
      *
      * @return     the next byte of this file as a signed eight-bit
      *             {@code byte}.
-     * @exception  EOFException  if this file has reached the end.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     EOFException  if this file has reached the end.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final byte readByte() throws IOException {
         int ch = this.read();
         if (ch < 0)
             throw new EOFException();
@@ -721,12 +721,12 @@
      * This method blocks until the byte is read, the end of the stream
      * is detected, or an exception is thrown.
      *
      * @return     the next byte of this file, interpreted as an unsigned
      *             eight-bit number.
-     * @exception  EOFException  if this file has reached the end.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     EOFException  if this file has reached the end.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final int readUnsignedByte() throws IOException {
         int ch = this.read();
         if (ch < 0)
             throw new EOFException();
@@ -747,13 +747,13 @@
      * This method blocks until the two bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next two bytes of this file, interpreted as a signed
      *             16-bit number.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *               two bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final short readShort() throws IOException {
         int ch1 = this.read();
         int ch2 = this.read();
         if ((ch1 | ch2) < 0)
@@ -775,13 +775,13 @@
      * This method blocks until the two bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next two bytes of this file, interpreted as an unsigned
      *             16-bit integer.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *               two bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final int readUnsignedShort() throws IOException {
         int ch1 = this.read();
         int ch2 = this.read();
         if ((ch1 | ch2) < 0)
@@ -803,13 +803,13 @@
      * This method blocks until the two bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next two bytes of this file, interpreted as a
      *                  {@code char}.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *               two bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final char readChar() throws IOException {
         int ch1 = this.read();
         int ch2 = this.read();
         if ((ch1 | ch2) < 0)
@@ -831,13 +831,13 @@
      * This method blocks until the four bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next four bytes of this file, interpreted as an
      *             {@code int}.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *               four bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final int readInt() throws IOException {
         int ch1 = this.read();
         int ch2 = this.read();
         int ch3 = this.read();
@@ -869,13 +869,13 @@
      * This method blocks until the eight bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next eight bytes of this file, interpreted as a
      *             {@code long}.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *               eight bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      */
     public final long readLong() throws IOException {
         return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
     }
 
@@ -890,13 +890,13 @@
      * This method blocks until the four bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next four bytes of this file, interpreted as a
      *             {@code float}.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *             four bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      * @see        java.io.RandomAccessFile#readInt()
      * @see        java.lang.Float#intBitsToFloat(int)
      */
     public final float readFloat() throws IOException {
         return Float.intBitsToFloat(readInt());
@@ -913,13 +913,13 @@
      * This method blocks until the eight bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     the next eight bytes of this file, interpreted as a
      *             {@code double}.
-     * @exception  EOFException  if this file reaches the end before reading
+     * @throws     EOFException  if this file reaches the end before reading
      *             eight bytes.
-     * @exception  IOException   if an I/O error occurs.
+     * @throws     IOException   if an I/O error occurs.
      * @see        java.io.RandomAccessFile#readLong()
      * @see        java.lang.Double#longBitsToDouble(long)
      */
     public final double readDouble() throws IOException {
         return Double.longBitsToDouble(readLong());
@@ -944,11 +944,11 @@
      * return and the byte following it are read (to see if it is a newline),
      * the end of the file is reached, or an exception is thrown.
      *
      * @return     the next line of text from this file, or null if end
      *             of file is encountered before even one byte is read.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
 
     public final String readLine() throws IOException {
         StringBuilder input = new StringBuilder();
         int c = -1;
@@ -995,14 +995,14 @@
      * <p>
      * This method blocks until all the bytes are read, the end of the
      * stream is detected, or an exception is thrown.
      *
      * @return     a Unicode string.
-     * @exception  EOFException            if this file reaches the end before
+     * @throws     EOFException            if this file reaches the end before
      *               reading all the bytes.
-     * @exception  IOException             if an I/O error occurs.
-     * @exception  UTFDataFormatException  if the bytes do not represent
+     * @throws     IOException             if an I/O error occurs.
+     * @throws     UTFDataFormatException  if the bytes do not represent
      *               valid modified UTF-8 encoding of a Unicode string.
      * @see        java.io.RandomAccessFile#readUnsignedShort()
      */
     public final String readUTF() throws IOException {
         return DataInputStream.readUTF(this);
@@ -1014,11 +1014,11 @@
      * {@code (byte)1}; the value {@code false} is written out
      * as the value {@code (byte)0}. The write starts at
      * the current position of the file pointer.
      *
      * @param      v   a {@code boolean} value to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeBoolean(boolean v) throws IOException {
         write(v ? 1 : 0);
         //written++;
     }
@@ -1026,11 +1026,11 @@
     /**
      * Writes a {@code byte} to the file as a one-byte value. The
      * write starts at the current position of the file pointer.
      *
      * @param      v   a {@code byte} value to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeByte(int v) throws IOException {
         write(v);
         //written++;
     }
@@ -1038,11 +1038,11 @@
     /**
      * Writes a {@code short} to the file as two bytes, high byte first.
      * The write starts at the current position of the file pointer.
      *
      * @param      v   a {@code short} to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeShort(int v) throws IOException {
         write((v >>> 8) & 0xFF);
         write((v >>> 0) & 0xFF);
         //written += 2;
@@ -1052,11 +1052,11 @@
      * Writes a {@code char} to the file as a two-byte value, high
      * byte first. The write starts at the current position of the
      * file pointer.
      *
      * @param      v   a {@code char} value to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeChar(int v) throws IOException {
         write((v >>> 8) & 0xFF);
         write((v >>> 0) & 0xFF);
         //written += 2;
@@ -1065,11 +1065,11 @@
     /**
      * Writes an {@code int} to the file as four bytes, high byte first.
      * The write starts at the current position of the file pointer.
      *
      * @param      v   an {@code int} to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeInt(int v) throws IOException {
         write((v >>> 24) & 0xFF);
         write((v >>> 16) & 0xFF);
         write((v >>>  8) & 0xFF);
@@ -1080,11 +1080,11 @@
     /**
      * Writes a {@code long} to the file as eight bytes, high byte first.
      * The write starts at the current position of the file pointer.
      *
      * @param      v   a {@code long} to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeLong(long v) throws IOException {
         write((int)(v >>> 56) & 0xFF);
         write((int)(v >>> 48) & 0xFF);
         write((int)(v >>> 40) & 0xFF);
@@ -1102,11 +1102,11 @@
      * and then writes that {@code int} value to the file as a
      * four-byte quantity, high byte first. The write starts at the
      * current position of the file pointer.
      *
      * @param      v   a {@code float} value to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.lang.Float#floatToIntBits(float)
      */
     public final void writeFloat(float v) throws IOException {
         writeInt(Float.floatToIntBits(v));
     }
@@ -1117,11 +1117,11 @@
      * and then writes that {@code long} value to the file as an
      * eight-byte quantity, high byte first. The write starts at the current
      * position of the file pointer.
      *
      * @param      v   a {@code double} value to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.lang.Double#doubleToLongBits(double)
      */
     public final void writeDouble(double v) throws IOException {
         writeLong(Double.doubleToLongBits(v));
     }
@@ -1131,11 +1131,11 @@
      * character in the string is written out, in sequence, by discarding
      * its high eight bits. The write starts at the current position of
      * the file pointer.
      *
      * @param      s   a string of bytes to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     @SuppressWarnings("deprecation")
     public final void writeBytes(String s) throws IOException {
         int len = s.length();
         byte[] b = new byte[len];
@@ -1148,11 +1148,11 @@
      * character is written to the data output stream as if by the
      * {@code writeChar} method. The write starts at the current
      * position of the file pointer.
      *
      * @param      s   a {@code String} value to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.RandomAccessFile#writeChar(int)
      */
     public final void writeChars(String s) throws IOException {
         int clen = s.length();
         int blen = 2*clen;
@@ -1178,11 +1178,11 @@
      * not the length of the string. Following the length, each character
      * of the string is output, in sequence, using the modified UTF-8 encoding
      * for each character.
      *
      * @param      str   a string to be written.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public final void writeUTF(String str) throws IOException {
         DataOutputStream.writeUTF(str, this);
     }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/UnresolvedPermissionCollection.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 
 28 import java.io.IOException;
 29 import java.io.ObjectInputStream;
 30 import java.io.ObjectOutputStream;
 31 import java.io.ObjectStreamField;
 32 import java.util.*;
 33 import java.util.concurrent.ConcurrentHashMap;
 34 import java.util.concurrent.CopyOnWriteArrayList;
 35 
 36 /**
 37  * A UnresolvedPermissionCollection stores a collection
 38  * of UnresolvedPermission permissions.
 39  *
 40  * @see java.security.Permission
 41  * @see java.security.Permissions
 42  * @see java.security.UnresolvedPermission
 43  *
 44  *
 45  * @author Roland Schemers
 46  * @since 1.2
 47  *
 48  * @serial include
 49  */
 50 
 51 final class UnresolvedPermissionCollection
 52 extends PermissionCollection
 53 implements java.io.Serializable
 54 {
 55     /**
 56      * Key is permission type, value is a list of the UnresolvedPermissions
 57      * of the same type.
 58      * Not serialized; see serialization section at end of class.
 59      */
 60     private transient ConcurrentHashMap&lt;String, List&lt;UnresolvedPermission&gt;&gt; perms;
 61 
 62     /**
 63      * Create an empty UnresolvedPermissionCollection object.
 64      *
 65      */
 66     public UnresolvedPermissionCollection() {
 67         perms = new ConcurrentHashMap&lt;&gt;(11);
 68     }
 69 
 70     /**
 71      * Adds a permission to this UnresolvedPermissionCollection.
 72      * The key for the hash is the unresolved permission&#39;s type (class) name.
 73      *
 74      * @param permission the Permission object to add.
 75      */
 76     @Override
 77     public void add(Permission permission) {
 78         if (! (permission instanceof UnresolvedPermission))
 79             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
 80                                                permission);
 81         UnresolvedPermission up = (UnresolvedPermission) permission;
 82 
 83         // Add permission to map. NOTE: cannot use lambda for
 84         // remappingFunction parameter until JDK-8076596 is fixed.
 85         perms.compute(up.getName(),
 86             new java.util.function.BiFunction&lt;&gt;() {
 87                 @Override
 88                 public List&lt;UnresolvedPermission&gt; apply(String key,
 89                                         List&lt;UnresolvedPermission&gt; oldValue) {
 90                     if (oldValue == null) {
 91                         List&lt;UnresolvedPermission&gt; v =
 92                             new CopyOnWriteArrayList&lt;&gt;();
 93                         v.add(up);
 94                         return v;
 95                     } else {
 96                         oldValue.add(up);
 97                         return oldValue;
 98                     }
 99                 }
100             }
101         );
102     }
103 
104     /**
105      * get any unresolved permissions of the same type as p,
106      * and return the List containing them.
107      */
108     List&lt;UnresolvedPermission&gt; getUnresolvedPermissions(Permission p) {
109         return perms.get(p.getClass().getName());
110     }
111 
112     /**
113      * always returns false for unresolved permissions
114      *
115      */
116     @Override
117     public boolean implies(Permission permission) {
118         return false;
119     }
120 
121     /**
122      * Returns an enumeration of all the UnresolvedPermission lists in the
123      * container.
124      *
125      * @return an enumeration of all the UnresolvedPermission objects.
126      */
127     @Override
128     public Enumeration&lt;Permission&gt; elements() {
129         List&lt;Permission&gt; results =
130             new ArrayList&lt;&gt;(); // where results are stored
131 
132         // Get iterator of Map values (which are lists of permissions)
133         for (List&lt;UnresolvedPermission&gt; l : perms.values()) {
134             results.addAll(l);
135         }
136 
137         return Collections.enumeration(results);
138     }
139 
<a name="2" id="anc2"></a><span class="line-added">140     @java.io.Serial</span>
141     private static final long serialVersionUID = -7176153071733132400L;
142 
143     // Need to maintain serialization interoperability with earlier releases,
144     // which had the serializable field:
145     // private Hashtable permissions; // keyed on type
146 
147     /**
148      * @serialField permissions java.util.Hashtable
149      *     A table of the UnresolvedPermissions keyed on type, value is Vector
150      *     of permissions
151      */
<a name="3" id="anc3"></a><span class="line-added">152     @java.io.Serial</span>
153     private static final ObjectStreamField[] serialPersistentFields = {
154         new ObjectStreamField(&quot;permissions&quot;, Hashtable.class),
155     };
156 
157     /**
158      * @serialData Default field.
159      */
160     /*
161      * Writes the contents of the perms field out as a Hashtable
162      * in which the values are Vectors for
163      * serialization compatibility with earlier releases.
164      */
<a name="4" id="anc4"></a><span class="line-added">165     @java.io.Serial</span>
166     private void writeObject(ObjectOutputStream out) throws IOException {
167         // Don&#39;t call out.defaultWriteObject()
168 
169         // Copy perms into a Hashtable
170         Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; permissions =
171             new Hashtable&lt;&gt;(perms.size()*2);
172 
173         // Convert each entry (List) into a Vector
174         Set&lt;Map.Entry&lt;String, List&lt;UnresolvedPermission&gt;&gt;&gt; set = perms.entrySet();
175         for (Map.Entry&lt;String, List&lt;UnresolvedPermission&gt;&gt; e : set) {
176             // Convert list into Vector
177             List&lt;UnresolvedPermission&gt; list = e.getValue();
178             Vector&lt;UnresolvedPermission&gt; vec = new Vector&lt;&gt;(list);
179 
180             // Add to Hashtable being serialized
181             permissions.put(e.getKey(), vec);
182         }
183 
184         // Write out serializable fields
185         ObjectOutputStream.PutField pfields = out.putFields();
186         pfields.put(&quot;permissions&quot;, permissions);
187         out.writeFields();
188     }
189 
190     /*
191      * Reads in a Hashtable in which the values are Vectors of
192      * UnresolvedPermissions and saves them in the perms field.
193      */
<a name="5" id="anc5"></a><span class="line-added">194     @java.io.Serial</span>
195     private void readObject(ObjectInputStream in) throws IOException,
196     ClassNotFoundException {
197         // Don&#39;t call defaultReadObject()
198 
199         // Read in serialized fields
200         ObjectInputStream.GetField gfields = in.readFields();
201 
202         // Get permissions
203         @SuppressWarnings(&quot;unchecked&quot;)
204         // writeObject writes a Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;
205         // for the permissions key, so this cast is safe, unless the data is corrupt.
206         Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; permissions =
207                 (Hashtable&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;)
208                 gfields.get(&quot;permissions&quot;, null);
209         perms = new ConcurrentHashMap&lt;&gt;(permissions.size()*2);
210 
211         // Convert each entry (Vector) into a List
212         Set&lt;Map.Entry&lt;String, Vector&lt;UnresolvedPermission&gt;&gt;&gt; set = permissions.entrySet();
213         for (Map.Entry&lt;String, Vector&lt;UnresolvedPermission&gt;&gt; e : set) {
214             // Convert Vector into ArrayList
215             Vector&lt;UnresolvedPermission&gt; vec = e.getValue();
216             List&lt;UnresolvedPermission&gt; list = new CopyOnWriteArrayList&lt;&gt;(vec);
217 
218             // Add to Hashtable being serialized
219             perms.put(e.getKey(), list);
220         }
221     }
222 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/SignedObject.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 
 28 import java.io.*;
 29 
 30 /**
 31  * &lt;p&gt; SignedObject is a class for the purpose of creating authentic
 32  * runtime objects whose integrity cannot be compromised without being
 33  * detected.
 34  *
 35  * &lt;p&gt; More specifically, a SignedObject contains another Serializable
 36  * object, the (to-be-)signed object and its signature.
 37  *
 38  * &lt;p&gt; The signed object is a &quot;deep copy&quot; (in serialized form) of an
 39  * original object.  Once the copy is made, further manipulation of
 40  * the original object has no side effect on the copy.
 41  *
 42  * &lt;p&gt; The underlying signing algorithm is designated by the Signature
 43  * object passed to the constructor and the {@code verify} method.
 44  * A typical usage for signing is the following:
 45  *
 46  * &lt;pre&gt;{@code
 47  * Signature signingEngine = Signature.getInstance(algorithm,
 48  *                                                 provider);
 49  * SignedObject so = new SignedObject(myobject, signingKey,
 50  *                                    signingEngine);
 51  * }&lt;/pre&gt;
 52  *
 53  * &lt;p&gt; A typical usage for verification is the following (having
 54  * received SignedObject {@code so}):
 55  *
 56  * &lt;pre&gt;{@code
 57  * Signature verificationEngine =
 58  *     Signature.getInstance(algorithm, provider);
 59  * if (so.verify(publickey, verificationEngine))
 60  *     try {
 61  *         Object myobj = so.getObject();
 62  *     } catch (java.lang.ClassNotFoundException e) {};
 63  * }&lt;/pre&gt;
 64  *
 65  * &lt;p&gt; Several points are worth noting.  First, there is no need to
 66  * initialize the signing or verification engine, as it will be
 67  * re-initialized inside the constructor and the {@code verify}
 68  * method. Secondly, for verification to succeed, the specified
 69  * public key must be the public key corresponding to the private key
 70  * used to generate the SignedObject.
 71  *
 72  * &lt;p&gt; More importantly, for flexibility reasons, the
 73  * constructor and {@code verify} method allow for
 74  * customized signature engines, which can implement signature
 75  * algorithms that are not installed formally as part of a crypto
 76  * provider.  However, it is crucial that the programmer writing the
 77  * verifier code be aware what {@code Signature} engine is being
 78  * used, as its own implementation of the {@code verify} method
 79  * is invoked to verify a signature.  In other words, a malicious
 80  * {@code Signature} may choose to always return true on
 81  * verification in an attempt to bypass a security check.
 82  *
 83  * &lt;p&gt; The signature algorithm can be, among others, the NIST standard
 84  * DSA, using DSA and SHA-256.  The algorithm is specified using the
 85  * same convention as that for signatures. The DSA algorithm using the
 86  * SHA-256 message digest algorithm can be specified, for example, as
 87  * &quot;SHA256withDSA&quot;.  In the case of
 88  * RSA the signing algorithm could be specified as, for example,
 89  * &quot;SHA256withRSA&quot;.  The algorithm name must be
 90  * specified, as there is no default.
 91  *
 92  * &lt;p&gt; The name of the Cryptography Package Provider is designated
 93  * also by the Signature parameter to the constructor and the
 94  * {@code verify} method.  If the provider is not
 95  * specified, the default provider is used.  Each installation can
 96  * be configured to use a particular provider as default.
 97  *
 98  * &lt;p&gt; Potential applications of SignedObject include:
 99  * &lt;ul&gt;
100  * &lt;li&gt; It can be used
101  * internally to any Java runtime as an unforgeable authorization
102  * token -- one that can be passed around without the fear that the
103  * token can be maliciously modified without being detected.
104  * &lt;li&gt; It
105  * can be used to sign and serialize data/object for storage outside
106  * the Java runtime (e.g., storing critical access control data on
107  * disk).
108  * &lt;li&gt; Nested SignedObjects can be used to construct a logical
109  * sequence of signatures, resembling a chain of authorization and
110  * delegation.
111  * &lt;/ul&gt;
112  *
113  * @see Signature
114  *
115  * @author Li Gong
116  * @since 1.2
117  */
118 
119 public final class SignedObject implements Serializable {
120 
<a name="2" id="anc2"></a>
121     private static final long serialVersionUID = 720502720485447167L;
122 
123     /*
124      * The original content is &quot;deep copied&quot; in its serialized format
125      * and stored in a byte array.  The signature field is also in the
126      * form of byte array.
127      */
128 
129     private byte[] content;
130     private byte[] signature;
131     private String thealgorithm;
132 
133     /**
134      * Constructs a SignedObject from any Serializable object.
135      * The given object is signed with the given signing key, using the
136      * designated signature engine.
137      *
138      * @param object the object to be signed.
139      * @param signingKey the private key for signing.
140      * @param signingEngine the signature signing engine.
141      *
<a name="3" id="anc3"></a><span class="line-modified">142      * @exception IOException if an error occurs during serialization</span>
<span class="line-modified">143      * @exception InvalidKeyException if the key is invalid.</span>
<span class="line-modified">144      * @exception SignatureException if signing fails.</span>
145      */
146     public SignedObject(Serializable object, PrivateKey signingKey,
147                         Signature signingEngine)
148         throws IOException, InvalidKeyException, SignatureException {
149             // creating a stream pipe-line, from a to b
150             ByteArrayOutputStream b = new ByteArrayOutputStream();
151             ObjectOutput a = new ObjectOutputStream(b);
152 
153             // write and flush the object content to byte array
154             a.writeObject(object);
155             a.flush();
156             a.close();
157             this.content = b.toByteArray();
158             b.close();
159 
160             // now sign the encapsulated object
161             this.sign(signingKey, signingEngine);
162     }
163 
164     /**
165      * Retrieves the encapsulated object.
166      * The encapsulated object is de-serialized before it is returned.
167      *
168      * @return the encapsulated object.
169      *
<a name="4" id="anc4"></a><span class="line-modified">170      * @exception IOException if an error occurs during de-serialization</span>
<span class="line-modified">171      * @exception ClassNotFoundException if an error occurs during</span>
172      * de-serialization
173      */
174     public Object getObject()
175         throws IOException, ClassNotFoundException
176     {
177         // creating a stream pipe-line, from b to a
178         ByteArrayInputStream b = new ByteArrayInputStream(this.content);
179         ObjectInput a = new ObjectInputStream(b);
180         Object obj = a.readObject();
181         b.close();
182         a.close();
183         return obj;
184     }
185 
186     /**
187      * Retrieves the signature on the signed object, in the form of a
188      * byte array.
189      *
190      * @return the signature. Returns a new array each time this
191      * method is called.
192      */
193     public byte[] getSignature() {
194         return this.signature.clone();
195     }
196 
197     /**
198      * Retrieves the name of the signature algorithm.
199      *
200      * @return the signature algorithm name.
201      */
202     public String getAlgorithm() {
203         return this.thealgorithm;
204     }
205 
206     /**
207      * Verifies that the signature in this SignedObject is the valid
208      * signature for the object stored inside, with the given
209      * verification key, using the designated verification engine.
210      *
211      * @param verificationKey the public key for verification.
212      * @param verificationEngine the signature verification engine.
213      *
<a name="5" id="anc5"></a><span class="line-modified">214      * @exception SignatureException if signature verification failed (an</span>
215      *     exception prevented the signature verification engine from completing
216      *     normally).
<a name="6" id="anc6"></a><span class="line-modified">217      * @exception InvalidKeyException if the verification key is invalid.</span>
218      *
219      * @return {@code true} if the signature
220      * is valid, {@code false} otherwise
221      */
222     public boolean verify(PublicKey verificationKey,
223                           Signature verificationEngine)
224          throws InvalidKeyException, SignatureException {
225              verificationEngine.initVerify(verificationKey);
226              verificationEngine.update(this.content.clone());
227              return verificationEngine.verify(this.signature.clone());
228     }
229 
230     /*
231      * Signs the encapsulated object with the given signing key, using the
232      * designated signature engine.
233      *
234      * @param signingKey the private key for signing.
235      * @param signingEngine the signature signing engine.
236      *
<a name="7" id="anc7"></a><span class="line-modified">237      * @exception InvalidKeyException if the key is invalid.</span>
<span class="line-modified">238      * @exception SignatureException if signing fails.</span>
239      */
240     private void sign(PrivateKey signingKey, Signature signingEngine)
241         throws InvalidKeyException, SignatureException {
242             // initialize the signing engine
243             signingEngine.initSign(signingKey);
244             signingEngine.update(this.content.clone());
245             this.signature = signingEngine.sign().clone();
246             this.thealgorithm = signingEngine.getAlgorithm();
247     }
248 
249     /**
250      * readObject is called to restore the state of the SignedObject from
251      * a stream.
252      */
<a name="8" id="anc8"></a>
253     private void readObject(java.io.ObjectInputStream s)
254         throws java.io.IOException, ClassNotFoundException {
255             java.io.ObjectInputStream.GetField fields = s.readFields();
256             content = ((byte[])fields.get(&quot;content&quot;, null)).clone();
257             signature = ((byte[])fields.get(&quot;signature&quot;, null)).clone();
258             thealgorithm = (String)fields.get(&quot;thealgorithm&quot;, null);
259     }
260 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
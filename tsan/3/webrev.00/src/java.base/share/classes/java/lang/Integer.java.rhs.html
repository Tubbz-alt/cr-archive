<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Integer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Native;
  29 import java.lang.invoke.MethodHandles;
  30 import java.lang.constant.Constable;
  31 import java.lang.constant.ConstantDesc;
  32 import java.util.Objects;
  33 import java.util.Optional;
  34 
  35 import jdk.internal.HotSpotIntrinsicCandidate;
  36 import jdk.internal.misc.VM;
  37 
  38 import static java.lang.String.COMPACT_STRINGS;
  39 import static java.lang.String.LATIN1;
  40 import static java.lang.String.UTF16;
  41 
  42 /**
  43  * The {@code Integer} class wraps a value of the primitive type
  44  * {@code int} in an object. An object of type {@code Integer}
  45  * contains a single field whose type is {@code int}.
  46  *
  47  * &lt;p&gt;In addition, this class provides several methods for converting
  48  * an {@code int} to a {@code String} and a {@code String} to an
  49  * {@code int}, as well as other constants and methods useful when
  50  * dealing with an {@code int}.
  51  *
  52  * &lt;p&gt;Implementation note: The implementations of the &quot;bit twiddling&quot;
  53  * methods (such as {@link #highestOneBit(int) highestOneBit} and
  54  * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are
  55  * based on material from Henry S. Warren, Jr.&#39;s &lt;i&gt;Hacker&#39;s
  56  * Delight&lt;/i&gt;, (Addison Wesley, 2002).
  57  *
  58  * @author  Lee Boynton
  59  * @author  Arthur van Hoff
  60  * @author  Josh Bloch
  61  * @author  Joseph D. Darcy
  62  * @since 1.0
  63  */
  64 public final class Integer extends Number
  65         implements Comparable&lt;Integer&gt;, Constable, ConstantDesc {
  66     /**
  67      * A constant holding the minimum value an {@code int} can
  68      * have, -2&lt;sup&gt;31&lt;/sup&gt;.
  69      */
  70     @Native public static final int   MIN_VALUE = 0x80000000;
  71 
  72     /**
  73      * A constant holding the maximum value an {@code int} can
  74      * have, 2&lt;sup&gt;31&lt;/sup&gt;-1.
  75      */
  76     @Native public static final int   MAX_VALUE = 0x7fffffff;
  77 
  78     /**
  79      * The {@code Class} instance representing the primitive type
  80      * {@code int}.
  81      *
  82      * @since   1.1
  83      */
  84     @SuppressWarnings(&quot;unchecked&quot;)
  85     public static final Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);
  86 
  87     /**
  88      * All possible chars for representing a number as a String
  89      */
  90     static final char[] digits = {
  91         &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; ,
  92         &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; ,
  93         &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; ,
  94         &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; ,
  95         &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; ,
  96         &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39;
  97     };
  98 
  99     /**
 100      * Returns a string representation of the first argument in the
 101      * radix specified by the second argument.
 102      *
 103      * &lt;p&gt;If the radix is smaller than {@code Character.MIN_RADIX}
 104      * or larger than {@code Character.MAX_RADIX}, then the radix
 105      * {@code 10} is used instead.
 106      *
 107      * &lt;p&gt;If the first argument is negative, the first element of the
 108      * result is the ASCII minus character {@code &#39;-&#39;}
 109      * ({@code &#39;\u005Cu002D&#39;}). If the first argument is not
 110      * negative, no sign character appears in the result.
 111      *
 112      * &lt;p&gt;The remaining characters of the result represent the magnitude
 113      * of the first argument. If the magnitude is zero, it is
 114      * represented by a single zero character {@code &#39;0&#39;}
 115      * ({@code &#39;\u005Cu0030&#39;}); otherwise, the first character of
 116      * the representation of the magnitude will not be the zero
 117      * character.  The following ASCII characters are used as digits:
 118      *
 119      * &lt;blockquote&gt;
 120      *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}
 121      * &lt;/blockquote&gt;
 122      *
 123      * These are {@code &#39;\u005Cu0030&#39;} through
 124      * {@code &#39;\u005Cu0039&#39;} and {@code &#39;\u005Cu0061&#39;} through
 125      * {@code &#39;\u005Cu007A&#39;}. If {@code radix} is
 126      * &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters
 127      * are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus,
 128      * the digits for hexadecimal (radix 16) are
 129      * {@code 0123456789abcdef}. If uppercase letters are
 130      * desired, the {@link java.lang.String#toUpperCase()} method may
 131      * be called on the result:
 132      *
 133      * &lt;blockquote&gt;
 134      *  {@code Integer.toString(n, 16).toUpperCase()}
 135      * &lt;/blockquote&gt;
 136      *
 137      * @param   i       an integer to be converted to a string.
 138      * @param   radix   the radix to use in the string representation.
 139      * @return  a string representation of the argument in the specified radix.
 140      * @see     java.lang.Character#MAX_RADIX
 141      * @see     java.lang.Character#MIN_RADIX
 142      */
 143     public static String toString(int i, int radix) {
 144         if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)
 145             radix = 10;
 146 
 147         /* Use the faster version */
 148         if (radix == 10) {
 149             return toString(i);
 150         }
 151 
 152         if (COMPACT_STRINGS) {
 153             byte[] buf = new byte[33];
 154             boolean negative = (i &lt; 0);
 155             int charPos = 32;
 156 
 157             if (!negative) {
 158                 i = -i;
 159             }
 160 
 161             while (i &lt;= -radix) {
 162                 buf[charPos--] = (byte)digits[-(i % radix)];
 163                 i = i / radix;
 164             }
 165             buf[charPos] = (byte)digits[-i];
 166 
 167             if (negative) {
 168                 buf[--charPos] = &#39;-&#39;;
 169             }
 170 
 171             return StringLatin1.newString(buf, charPos, (33 - charPos));
 172         }
 173         return toStringUTF16(i, radix);
 174     }
 175 
 176     private static String toStringUTF16(int i, int radix) {
 177         byte[] buf = new byte[33 * 2];
 178         boolean negative = (i &lt; 0);
 179         int charPos = 32;
 180         if (!negative) {
 181             i = -i;
 182         }
 183         while (i &lt;= -radix) {
 184             StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);
 185             i = i / radix;
 186         }
 187         StringUTF16.putChar(buf, charPos, digits[-i]);
 188 
 189         if (negative) {
 190             StringUTF16.putChar(buf, --charPos, &#39;-&#39;);
 191         }
 192         return StringUTF16.newString(buf, charPos, (33 - charPos));
 193     }
 194 
 195     /**
 196      * Returns a string representation of the first argument as an
 197      * unsigned integer value in the radix specified by the second
 198      * argument.
 199      *
 200      * &lt;p&gt;If the radix is smaller than {@code Character.MIN_RADIX}
 201      * or larger than {@code Character.MAX_RADIX}, then the radix
 202      * {@code 10} is used instead.
 203      *
 204      * &lt;p&gt;Note that since the first argument is treated as an unsigned
 205      * value, no leading sign character is printed.
 206      *
 207      * &lt;p&gt;If the magnitude is zero, it is represented by a single zero
 208      * character {@code &#39;0&#39;} ({@code &#39;\u005Cu0030&#39;}); otherwise,
 209      * the first character of the representation of the magnitude will
 210      * not be the zero character.
 211      *
 212      * &lt;p&gt;The behavior of radixes and the characters used as digits
 213      * are the same as {@link #toString(int, int) toString}.
 214      *
 215      * @param   i       an integer to be converted to an unsigned string.
 216      * @param   radix   the radix to use in the string representation.
 217      * @return  an unsigned string representation of the argument in the specified radix.
 218      * @see     #toString(int, int)
 219      * @since 1.8
 220      */
 221     public static String toUnsignedString(int i, int radix) {
 222         return Long.toUnsignedString(toUnsignedLong(i), radix);
 223     }
 224 
 225     /**
 226      * Returns a string representation of the integer argument as an
 227      * unsigned integer in base&amp;nbsp;16.
 228      *
 229      * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt;
 230      * if the argument is negative; otherwise, it is equal to the
 231      * argument.  This value is converted to a string of ASCII digits
 232      * in hexadecimal (base&amp;nbsp;16) with no extra leading
 233      * {@code 0}s.
 234      *
 235      * &lt;p&gt;The value of the argument can be recovered from the returned
 236      * string {@code s} by calling {@link
 237      * Integer#parseUnsignedInt(String, int)
 238      * Integer.parseUnsignedInt(s, 16)}.
 239      *
 240      * &lt;p&gt;If the unsigned magnitude is zero, it is represented by a
 241      * single zero character {@code &#39;0&#39;} ({@code &#39;\u005Cu0030&#39;});
 242      * otherwise, the first character of the representation of the
 243      * unsigned magnitude will not be the zero character. The
 244      * following characters are used as hexadecimal digits:
 245      *
 246      * &lt;blockquote&gt;
 247      *  {@code 0123456789abcdef}
 248      * &lt;/blockquote&gt;
 249      *
 250      * These are the characters {@code &#39;\u005Cu0030&#39;} through
 251      * {@code &#39;\u005Cu0039&#39;} and {@code &#39;\u005Cu0061&#39;} through
 252      * {@code &#39;\u005Cu0066&#39;}. If uppercase letters are
 253      * desired, the {@link java.lang.String#toUpperCase()} method may
 254      * be called on the result:
 255      *
 256      * &lt;blockquote&gt;
 257      *  {@code Integer.toHexString(n).toUpperCase()}
 258      * &lt;/blockquote&gt;
 259      *
 260      * @param   i   an integer to be converted to a string.
 261      * @return  the string representation of the unsigned integer value
 262      *          represented by the argument in hexadecimal (base&amp;nbsp;16).
 263      * @see #parseUnsignedInt(String, int)
 264      * @see #toUnsignedString(int, int)
 265      * @since   1.0.2
 266      */
 267     public static String toHexString(int i) {
 268         return toUnsignedString0(i, 4);
 269     }
 270 
 271     /**
 272      * Returns a string representation of the integer argument as an
 273      * unsigned integer in base&amp;nbsp;8.
 274      *
 275      * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt;
 276      * if the argument is negative; otherwise, it is equal to the
 277      * argument.  This value is converted to a string of ASCII digits
 278      * in octal (base&amp;nbsp;8) with no extra leading {@code 0}s.
 279      *
 280      * &lt;p&gt;The value of the argument can be recovered from the returned
 281      * string {@code s} by calling {@link
 282      * Integer#parseUnsignedInt(String, int)
 283      * Integer.parseUnsignedInt(s, 8)}.
 284      *
 285      * &lt;p&gt;If the unsigned magnitude is zero, it is represented by a
 286      * single zero character {@code &#39;0&#39;} ({@code &#39;\u005Cu0030&#39;});
 287      * otherwise, the first character of the representation of the
 288      * unsigned magnitude will not be the zero character. The
 289      * following characters are used as octal digits:
 290      *
 291      * &lt;blockquote&gt;
 292      * {@code 01234567}
 293      * &lt;/blockquote&gt;
 294      *
 295      * These are the characters {@code &#39;\u005Cu0030&#39;} through
 296      * {@code &#39;\u005Cu0037&#39;}.
 297      *
 298      * @param   i   an integer to be converted to a string.
 299      * @return  the string representation of the unsigned integer value
 300      *          represented by the argument in octal (base&amp;nbsp;8).
 301      * @see #parseUnsignedInt(String, int)
 302      * @see #toUnsignedString(int, int)
 303      * @since   1.0.2
 304      */
 305     public static String toOctalString(int i) {
 306         return toUnsignedString0(i, 3);
 307     }
 308 
 309     /**
 310      * Returns a string representation of the integer argument as an
 311      * unsigned integer in base&amp;nbsp;2.
 312      *
 313      * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt;
 314      * if the argument is negative; otherwise it is equal to the
 315      * argument.  This value is converted to a string of ASCII digits
 316      * in binary (base&amp;nbsp;2) with no extra leading {@code 0}s.
 317      *
 318      * &lt;p&gt;The value of the argument can be recovered from the returned
 319      * string {@code s} by calling {@link
 320      * Integer#parseUnsignedInt(String, int)
 321      * Integer.parseUnsignedInt(s, 2)}.
 322      *
 323      * &lt;p&gt;If the unsigned magnitude is zero, it is represented by a
 324      * single zero character {@code &#39;0&#39;} ({@code &#39;\u005Cu0030&#39;});
 325      * otherwise, the first character of the representation of the
 326      * unsigned magnitude will not be the zero character. The
 327      * characters {@code &#39;0&#39;} ({@code &#39;\u005Cu0030&#39;}) and {@code
 328      * &#39;1&#39;} ({@code &#39;\u005Cu0031&#39;}) are used as binary digits.
 329      *
 330      * @param   i   an integer to be converted to a string.
 331      * @return  the string representation of the unsigned integer value
 332      *          represented by the argument in binary (base&amp;nbsp;2).
 333      * @see #parseUnsignedInt(String, int)
 334      * @see #toUnsignedString(int, int)
 335      * @since   1.0.2
 336      */
 337     public static String toBinaryString(int i) {
 338         return toUnsignedString0(i, 1);
 339     }
 340 
 341     /**
 342      * Convert the integer to an unsigned number.
 343      */
 344     private static String toUnsignedString0(int val, int shift) {
 345         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
 346         int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
 347         int chars = Math.max(((mag + (shift - 1)) / shift), 1);
 348         if (COMPACT_STRINGS) {
 349             byte[] buf = new byte[chars];
<a name="2" id="anc2"></a><span class="line-modified"> 350             formatUnsignedInt(val, shift, buf, chars);</span>
 351             return new String(buf, LATIN1);
 352         } else {
 353             byte[] buf = new byte[chars * 2];
<a name="3" id="anc3"></a><span class="line-modified"> 354             formatUnsignedIntUTF16(val, shift, buf, chars);</span>
 355             return new String(buf, UTF16);
 356         }
 357     }
 358 
 359     /**
<a name="4" id="anc4"></a><span class="line-modified"> 360      * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If</span>
 361      * {@code len} exceeds the formatted ASCII representation of {@code val},
 362      * {@code buf} will be padded with leading zeroes.
 363      *
 364      * @param val the unsigned int to format
 365      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<a name="5" id="anc5"></a><span class="line-modified"> 366      * @param buf the byte buffer to write to</span>

 367      * @param len the number of characters to write
 368      */
<a name="6" id="anc6"></a><span class="line-modified"> 369     private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {</span>
<span class="line-modified"> 370         int charPos = len;</span>














 371         int radix = 1 &lt;&lt; shift;
 372         int mask = radix - 1;
 373         do {
 374             buf[--charPos] = (byte)Integer.digits[val &amp; mask];
 375             val &gt;&gt;&gt;= shift;
<a name="7" id="anc7"></a><span class="line-modified"> 376         } while (charPos &gt; 0);</span>
 377     }
 378 
<a name="8" id="anc8"></a><span class="line-modified"> 379     /**</span>
<span class="line-modified"> 380      * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If</span>
<span class="line-modified"> 381      * {@code len} exceeds the formatted ASCII representation of {@code val},</span>
<span class="line-added"> 382      * {@code buf} will be padded with leading zeroes.</span>
<span class="line-added"> 383      *</span>
<span class="line-added"> 384      * @param val the unsigned int to format</span>
<span class="line-added"> 385      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)</span>
<span class="line-added"> 386      * @param buf the byte buffer to write to</span>
<span class="line-added"> 387      * @param len the number of characters to write</span>
<span class="line-added"> 388      */</span>
<span class="line-added"> 389     private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {</span>
<span class="line-added"> 390         int charPos = len;</span>
 391         int radix = 1 &lt;&lt; shift;
 392         int mask = radix - 1;
 393         do {
 394             StringUTF16.putChar(buf, --charPos, Integer.digits[val &amp; mask]);
 395             val &gt;&gt;&gt;= shift;
<a name="9" id="anc9"></a><span class="line-modified"> 396         } while (charPos &gt; 0);</span>
 397     }
 398 
 399     static final byte[] DigitTens = {
 400         &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;,
 401         &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;,
 402         &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;,
 403         &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;,
 404         &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;,
 405         &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;,
 406         &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;,
 407         &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;,
 408         &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;,
 409         &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;,
 410         } ;
 411 
 412     static final byte[] DigitOnes = {
 413         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 414         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 415         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 416         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 417         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 418         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 419         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 420         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 421         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 422         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
 423         } ;
 424 
 425 
 426     /**
 427      * Returns a {@code String} object representing the
 428      * specified integer. The argument is converted to signed decimal
 429      * representation and returned as a string, exactly as if the
 430      * argument and radix 10 were given as arguments to the {@link
 431      * #toString(int, int)} method.
 432      *
 433      * @param   i   an integer to be converted.
 434      * @return  a string representation of the argument in base&amp;nbsp;10.
 435      */
 436     @HotSpotIntrinsicCandidate
 437     public static String toString(int i) {
 438         int size = stringSize(i);
 439         if (COMPACT_STRINGS) {
 440             byte[] buf = new byte[size];
 441             getChars(i, size, buf);
 442             return new String(buf, LATIN1);
 443         } else {
 444             byte[] buf = new byte[size * 2];
 445             StringUTF16.getChars(i, size, buf);
 446             return new String(buf, UTF16);
 447         }
 448     }
 449 
 450     /**
 451      * Returns a string representation of the argument as an unsigned
 452      * decimal value.
 453      *
 454      * The argument is converted to unsigned decimal representation
 455      * and returned as a string exactly as if the argument and radix
 456      * 10 were given as arguments to the {@link #toUnsignedString(int,
 457      * int)} method.
 458      *
 459      * @param   i  an integer to be converted to an unsigned string.
 460      * @return  an unsigned string representation of the argument.
 461      * @see     #toUnsignedString(int, int)
 462      * @since 1.8
 463      */
 464     public static String toUnsignedString(int i) {
 465         return Long.toString(toUnsignedLong(i));
 466     }
 467 
 468     /**
 469      * Places characters representing the integer i into the
 470      * character array buf. The characters are placed into
 471      * the buffer backwards starting with the least significant
 472      * digit at the specified index (exclusive), and working
 473      * backwards from there.
 474      *
 475      * @implNote This method converts positive inputs into negative
 476      * values, to cover the Integer.MIN_VALUE case. Converting otherwise
 477      * (negative to positive) will expose -Integer.MIN_VALUE that overflows
 478      * integer.
 479      *
 480      * @param i     value to convert
 481      * @param index next index, after the least significant digit
 482      * @param buf   target buffer, Latin1-encoded
 483      * @return index of the most significant digit or minus sign, if present
 484      */
 485     static int getChars(int i, int index, byte[] buf) {
 486         int q, r;
 487         int charPos = index;
 488 
 489         boolean negative = i &lt; 0;
 490         if (!negative) {
 491             i = -i;
 492         }
 493 
 494         // Generate two digits per iteration
 495         while (i &lt;= -100) {
 496             q = i / 100;
 497             r = (q * 100) - i;
 498             i = q;
 499             buf[--charPos] = DigitOnes[r];
 500             buf[--charPos] = DigitTens[r];
 501         }
 502 
 503         // We know there are at most two digits left at this point.
 504         q = i / 10;
 505         r = (q * 10) - i;
 506         buf[--charPos] = (byte)(&#39;0&#39; + r);
 507 
 508         // Whatever left is the remaining digit.
 509         if (q &lt; 0) {
 510             buf[--charPos] = (byte)(&#39;0&#39; - q);
 511         }
 512 
 513         if (negative) {
 514             buf[--charPos] = (byte)&#39;-&#39;;
 515         }
 516         return charPos;
 517     }
 518 
 519     // Left here for compatibility reasons, see JDK-8143900.
 520     static final int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
 521                                       99999999, 999999999, Integer.MAX_VALUE };
 522 
 523     /**
 524      * Returns the string representation size for a given int value.
 525      *
 526      * @param x int value
 527      * @return string size
 528      *
 529      * @implNote There are other ways to compute this: e.g. binary search,
 530      * but values are biased heavily towards zero, and therefore linear search
 531      * wins. The iteration results are also routinely inlined in the generated
 532      * code after loop unrolling.
 533      */
 534     static int stringSize(int x) {
 535         int d = 1;
 536         if (x &gt;= 0) {
 537             d = 0;
 538             x = -x;
 539         }
 540         int p = -10;
 541         for (int i = 1; i &lt; 10; i++) {
 542             if (x &gt; p)
 543                 return i + d;
 544             p = 10 * p;
 545         }
 546         return 10 + d;
 547     }
 548 
 549     /**
 550      * Parses the string argument as a signed integer in the radix
 551      * specified by the second argument. The characters in the string
 552      * must all be digits of the specified radix (as determined by
 553      * whether {@link java.lang.Character#digit(char, int)} returns a
 554      * nonnegative value), except that the first character may be an
 555      * ASCII minus sign {@code &#39;-&#39;} ({@code &#39;\u005Cu002D&#39;}) to
 556      * indicate a negative value or an ASCII plus sign {@code &#39;+&#39;}
 557      * ({@code &#39;\u005Cu002B&#39;}) to indicate a positive value. The
 558      * resulting integer value is returned.
 559      *
 560      * &lt;p&gt;An exception of type {@code NumberFormatException} is
 561      * thrown if any of the following situations occurs:
 562      * &lt;ul&gt;
 563      * &lt;li&gt;The first argument is {@code null} or is a string of
 564      * length zero.
 565      *
 566      * &lt;li&gt;The radix is either smaller than
 567      * {@link java.lang.Character#MIN_RADIX} or
 568      * larger than {@link java.lang.Character#MAX_RADIX}.
 569      *
 570      * &lt;li&gt;Any character of the string is not a digit of the specified
 571      * radix, except that the first character may be a minus sign
 572      * {@code &#39;-&#39;} ({@code &#39;\u005Cu002D&#39;}) or plus sign
 573      * {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) provided that the
 574      * string is longer than length 1.
 575      *
 576      * &lt;li&gt;The value represented by the string is not a value of type
 577      * {@code int}.
 578      * &lt;/ul&gt;
 579      *
 580      * &lt;p&gt;Examples:
 581      * &lt;blockquote&gt;&lt;pre&gt;
 582      * parseInt(&quot;0&quot;, 10) returns 0
 583      * parseInt(&quot;473&quot;, 10) returns 473
 584      * parseInt(&quot;+42&quot;, 10) returns 42
 585      * parseInt(&quot;-0&quot;, 10) returns 0
 586      * parseInt(&quot;-FF&quot;, 16) returns -255
 587      * parseInt(&quot;1100110&quot;, 2) returns 102
 588      * parseInt(&quot;2147483647&quot;, 10) returns 2147483647
 589      * parseInt(&quot;-2147483648&quot;, 10) returns -2147483648
 590      * parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException
 591      * parseInt(&quot;99&quot;, 8) throws a NumberFormatException
 592      * parseInt(&quot;Kona&quot;, 10) throws a NumberFormatException
 593      * parseInt(&quot;Kona&quot;, 27) returns 411787
 594      * &lt;/pre&gt;&lt;/blockquote&gt;
 595      *
 596      * @param      s   the {@code String} containing the integer
 597      *                  representation to be parsed
 598      * @param      radix   the radix to be used while parsing {@code s}.
 599      * @return     the integer represented by the string argument in the
 600      *             specified radix.
<a name="10" id="anc10"></a><span class="line-modified"> 601      * @throws     NumberFormatException if the {@code String}</span>
 602      *             does not contain a parsable {@code int}.
 603      */
 604     public static int parseInt(String s, int radix)
 605                 throws NumberFormatException
 606     {
 607         /*
 608          * WARNING: This method may be invoked early during VM initialization
 609          * before IntegerCache is initialized. Care must be taken to not use
 610          * the valueOf method.
 611          */
 612 
 613         if (s == null) {
 614             throw new NumberFormatException(&quot;null&quot;);
 615         }
 616 
 617         if (radix &lt; Character.MIN_RADIX) {
 618             throw new NumberFormatException(&quot;radix &quot; + radix +
 619                                             &quot; less than Character.MIN_RADIX&quot;);
 620         }
 621 
 622         if (radix &gt; Character.MAX_RADIX) {
 623             throw new NumberFormatException(&quot;radix &quot; + radix +
 624                                             &quot; greater than Character.MAX_RADIX&quot;);
 625         }
 626 
 627         boolean negative = false;
 628         int i = 0, len = s.length();
 629         int limit = -Integer.MAX_VALUE;
 630 
 631         if (len &gt; 0) {
 632             char firstChar = s.charAt(0);
 633             if (firstChar &lt; &#39;0&#39;) { // Possible leading &quot;+&quot; or &quot;-&quot;
 634                 if (firstChar == &#39;-&#39;) {
 635                     negative = true;
 636                     limit = Integer.MIN_VALUE;
 637                 } else if (firstChar != &#39;+&#39;) {
 638                     throw NumberFormatException.forInputString(s, radix);
 639                 }
 640 
 641                 if (len == 1) { // Cannot have lone &quot;+&quot; or &quot;-&quot;
 642                     throw NumberFormatException.forInputString(s, radix);
 643                 }
 644                 i++;
 645             }
 646             int multmin = limit / radix;
 647             int result = 0;
 648             while (i &lt; len) {
 649                 // Accumulating negatively avoids surprises near MAX_VALUE
 650                 int digit = Character.digit(s.charAt(i++), radix);
 651                 if (digit &lt; 0 || result &lt; multmin) {
 652                     throw NumberFormatException.forInputString(s, radix);
 653                 }
 654                 result *= radix;
 655                 if (result &lt; limit + digit) {
 656                     throw NumberFormatException.forInputString(s, radix);
 657                 }
 658                 result -= digit;
 659             }
 660             return negative ? result : -result;
 661         } else {
 662             throw NumberFormatException.forInputString(s, radix);
 663         }
 664     }
 665 
 666     /**
 667      * Parses the {@link CharSequence} argument as a signed {@code int} in the
 668      * specified {@code radix}, beginning at the specified {@code beginIndex}
 669      * and extending to {@code endIndex - 1}.
 670      *
 671      * &lt;p&gt;The method does not take steps to guard against the
 672      * {@code CharSequence} being mutated while parsing.
 673      *
 674      * @param      s   the {@code CharSequence} containing the {@code int}
 675      *                  representation to be parsed
 676      * @param      beginIndex   the beginning index, inclusive.
 677      * @param      endIndex     the ending index, exclusive.
 678      * @param      radix   the radix to be used while parsing {@code s}.
 679      * @return     the signed {@code int} represented by the subsequence in
 680      *             the specified radix.
 681      * @throws     NullPointerException  if {@code s} is null.
 682      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 683      *             negative, or if {@code beginIndex} is greater than
 684      *             {@code endIndex} or if {@code endIndex} is greater than
 685      *             {@code s.length()}.
 686      * @throws     NumberFormatException  if the {@code CharSequence} does not
 687      *             contain a parsable {@code int} in the specified
 688      *             {@code radix}, or if {@code radix} is either smaller than
 689      *             {@link java.lang.Character#MIN_RADIX} or larger than
 690      *             {@link java.lang.Character#MAX_RADIX}.
 691      * @since  9
 692      */
 693     public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
 694                 throws NumberFormatException {
<a name="11" id="anc11"></a><span class="line-modified"> 695         Objects.requireNonNull(s);</span>
 696 
 697         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 698             throw new IndexOutOfBoundsException();
 699         }
 700         if (radix &lt; Character.MIN_RADIX) {
 701             throw new NumberFormatException(&quot;radix &quot; + radix +
 702                                             &quot; less than Character.MIN_RADIX&quot;);
 703         }
 704         if (radix &gt; Character.MAX_RADIX) {
 705             throw new NumberFormatException(&quot;radix &quot; + radix +
 706                                             &quot; greater than Character.MAX_RADIX&quot;);
 707         }
 708 
 709         boolean negative = false;
 710         int i = beginIndex;
 711         int limit = -Integer.MAX_VALUE;
 712 
 713         if (i &lt; endIndex) {
 714             char firstChar = s.charAt(i);
 715             if (firstChar &lt; &#39;0&#39;) { // Possible leading &quot;+&quot; or &quot;-&quot;
 716                 if (firstChar == &#39;-&#39;) {
 717                     negative = true;
 718                     limit = Integer.MIN_VALUE;
 719                 } else if (firstChar != &#39;+&#39;) {
 720                     throw NumberFormatException.forCharSequence(s, beginIndex,
 721                             endIndex, i);
 722                 }
 723                 i++;
 724                 if (i == endIndex) { // Cannot have lone &quot;+&quot; or &quot;-&quot;
 725                     throw NumberFormatException.forCharSequence(s, beginIndex,
 726                             endIndex, i);
 727                 }
 728             }
 729             int multmin = limit / radix;
 730             int result = 0;
 731             while (i &lt; endIndex) {
 732                 // Accumulating negatively avoids surprises near MAX_VALUE
 733                 int digit = Character.digit(s.charAt(i), radix);
 734                 if (digit &lt; 0 || result &lt; multmin) {
 735                     throw NumberFormatException.forCharSequence(s, beginIndex,
 736                             endIndex, i);
 737                 }
 738                 result *= radix;
 739                 if (result &lt; limit + digit) {
 740                     throw NumberFormatException.forCharSequence(s, beginIndex,
 741                             endIndex, i);
 742                 }
 743                 i++;
 744                 result -= digit;
 745             }
 746             return negative ? result : -result;
 747         } else {
 748             throw NumberFormatException.forInputString(&quot;&quot;, radix);
 749         }
 750     }
 751 
 752     /**
 753      * Parses the string argument as a signed decimal integer. The
 754      * characters in the string must all be decimal digits, except
 755      * that the first character may be an ASCII minus sign {@code &#39;-&#39;}
 756      * ({@code &#39;\u005Cu002D&#39;}) to indicate a negative value or an
 757      * ASCII plus sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) to
 758      * indicate a positive value. The resulting integer value is
 759      * returned, exactly as if the argument and the radix 10 were
 760      * given as arguments to the {@link #parseInt(java.lang.String,
 761      * int)} method.
 762      *
 763      * @param s    a {@code String} containing the {@code int}
 764      *             representation to be parsed
 765      * @return     the integer value represented by the argument in decimal.
<a name="12" id="anc12"></a><span class="line-modified"> 766      * @throws     NumberFormatException  if the string does not contain a</span>
 767      *               parsable integer.
 768      */
 769     public static int parseInt(String s) throws NumberFormatException {
 770         return parseInt(s,10);
 771     }
 772 
 773     /**
 774      * Parses the string argument as an unsigned integer in the radix
 775      * specified by the second argument.  An unsigned integer maps the
 776      * values usually associated with negative numbers to positive
 777      * numbers larger than {@code MAX_VALUE}.
 778      *
 779      * The characters in the string must all be digits of the
 780      * specified radix (as determined by whether {@link
 781      * java.lang.Character#digit(char, int)} returns a nonnegative
 782      * value), except that the first character may be an ASCII plus
 783      * sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}). The resulting
 784      * integer value is returned.
 785      *
 786      * &lt;p&gt;An exception of type {@code NumberFormatException} is
 787      * thrown if any of the following situations occurs:
 788      * &lt;ul&gt;
 789      * &lt;li&gt;The first argument is {@code null} or is a string of
 790      * length zero.
 791      *
 792      * &lt;li&gt;The radix is either smaller than
 793      * {@link java.lang.Character#MIN_RADIX} or
 794      * larger than {@link java.lang.Character#MAX_RADIX}.
 795      *
 796      * &lt;li&gt;Any character of the string is not a digit of the specified
 797      * radix, except that the first character may be a plus sign
 798      * {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) provided that the
 799      * string is longer than length 1.
 800      *
 801      * &lt;li&gt;The value represented by the string is larger than the
 802      * largest unsigned {@code int}, 2&lt;sup&gt;32&lt;/sup&gt;-1.
 803      *
 804      * &lt;/ul&gt;
 805      *
 806      *
 807      * @param      s   the {@code String} containing the unsigned integer
 808      *                  representation to be parsed
 809      * @param      radix   the radix to be used while parsing {@code s}.
 810      * @return     the integer represented by the string argument in the
 811      *             specified radix.
 812      * @throws     NumberFormatException if the {@code String}
 813      *             does not contain a parsable {@code int}.
 814      * @since 1.8
 815      */
 816     public static int parseUnsignedInt(String s, int radix)
 817                 throws NumberFormatException {
 818         if (s == null)  {
 819             throw new NumberFormatException(&quot;null&quot;);
 820         }
 821 
 822         int len = s.length();
 823         if (len &gt; 0) {
 824             char firstChar = s.charAt(0);
 825             if (firstChar == &#39;-&#39;) {
 826                 throw new
 827                     NumberFormatException(String.format(&quot;Illegal leading minus sign &quot; +
 828                                                        &quot;on unsigned string %s.&quot;, s));
 829             } else {
 830                 if (len &lt;= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits
 831                     (radix == 10 &amp;&amp; len &lt;= 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits
 832                     return parseInt(s, radix);
 833                 } else {
 834                     long ell = Long.parseLong(s, radix);
 835                     if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) {
 836                         return (int) ell;
 837                     } else {
 838                         throw new
 839                             NumberFormatException(String.format(&quot;String value %s exceeds &quot; +
 840                                                                 &quot;range of unsigned int.&quot;, s));
 841                     }
 842                 }
 843             }
 844         } else {
 845             throw NumberFormatException.forInputString(s, radix);
 846         }
 847     }
 848 
 849     /**
 850      * Parses the {@link CharSequence} argument as an unsigned {@code int} in
 851      * the specified {@code radix}, beginning at the specified
 852      * {@code beginIndex} and extending to {@code endIndex - 1}.
 853      *
 854      * &lt;p&gt;The method does not take steps to guard against the
 855      * {@code CharSequence} being mutated while parsing.
 856      *
 857      * @param      s   the {@code CharSequence} containing the unsigned
 858      *                 {@code int} representation to be parsed
 859      * @param      beginIndex   the beginning index, inclusive.
 860      * @param      endIndex     the ending index, exclusive.
 861      * @param      radix   the radix to be used while parsing {@code s}.
 862      * @return     the unsigned {@code int} represented by the subsequence in
 863      *             the specified radix.
 864      * @throws     NullPointerException  if {@code s} is null.
 865      * @throws     IndexOutOfBoundsException  if {@code beginIndex} is
 866      *             negative, or if {@code beginIndex} is greater than
 867      *             {@code endIndex} or if {@code endIndex} is greater than
 868      *             {@code s.length()}.
 869      * @throws     NumberFormatException  if the {@code CharSequence} does not
 870      *             contain a parsable unsigned {@code int} in the specified
 871      *             {@code radix}, or if {@code radix} is either smaller than
 872      *             {@link java.lang.Character#MIN_RADIX} or larger than
 873      *             {@link java.lang.Character#MAX_RADIX}.
 874      * @since  9
 875      */
 876     public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)
 877                 throws NumberFormatException {
<a name="13" id="anc13"></a><span class="line-modified"> 878         Objects.requireNonNull(s);</span>
 879 
 880         if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
 881             throw new IndexOutOfBoundsException();
 882         }
 883         int start = beginIndex, len = endIndex - beginIndex;
 884 
 885         if (len &gt; 0) {
 886             char firstChar = s.charAt(start);
 887             if (firstChar == &#39;-&#39;) {
 888                 throw new
 889                     NumberFormatException(String.format(&quot;Illegal leading minus sign &quot; +
 890                                                        &quot;on unsigned string %s.&quot;, s));
 891             } else {
 892                 if (len &lt;= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits
 893                         (radix == 10 &amp;&amp; len &lt;= 9)) { // Integer.MAX_VALUE in base 10 is 10 digits
 894                     return parseInt(s, start, start + len, radix);
 895                 } else {
 896                     long ell = Long.parseLong(s, start, start + len, radix);
 897                     if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) {
 898                         return (int) ell;
 899                     } else {
 900                         throw new
 901                             NumberFormatException(String.format(&quot;String value %s exceeds &quot; +
 902                                                                 &quot;range of unsigned int.&quot;, s));
 903                     }
 904                 }
 905             }
 906         } else {
 907             throw new NumberFormatException(&quot;&quot;);
 908         }
 909     }
 910 
 911     /**
 912      * Parses the string argument as an unsigned decimal integer. The
 913      * characters in the string must all be decimal digits, except
 914      * that the first character may be an ASCII plus sign {@code
 915      * &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}). The resulting integer value
 916      * is returned, exactly as if the argument and the radix 10 were
 917      * given as arguments to the {@link
 918      * #parseUnsignedInt(java.lang.String, int)} method.
 919      *
 920      * @param s   a {@code String} containing the unsigned {@code int}
 921      *            representation to be parsed
 922      * @return    the unsigned integer value represented by the argument in decimal.
 923      * @throws    NumberFormatException  if the string does not contain a
 924      *            parsable unsigned integer.
 925      * @since 1.8
 926      */
 927     public static int parseUnsignedInt(String s) throws NumberFormatException {
 928         return parseUnsignedInt(s, 10);
 929     }
 930 
 931     /**
 932      * Returns an {@code Integer} object holding the value
 933      * extracted from the specified {@code String} when parsed
 934      * with the radix given by the second argument. The first argument
 935      * is interpreted as representing a signed integer in the radix
 936      * specified by the second argument, exactly as if the arguments
 937      * were given to the {@link #parseInt(java.lang.String, int)}
 938      * method. The result is an {@code Integer} object that
 939      * represents the integer value specified by the string.
 940      *
 941      * &lt;p&gt;In other words, this method returns an {@code Integer}
 942      * object equal to the value of:
 943      *
 944      * &lt;blockquote&gt;
 945      *  {@code new Integer(Integer.parseInt(s, radix))}
 946      * &lt;/blockquote&gt;
 947      *
 948      * @param      s   the string to be parsed.
 949      * @param      radix the radix to be used in interpreting {@code s}
 950      * @return     an {@code Integer} object holding the value
 951      *             represented by the string argument in the specified
 952      *             radix.
<a name="14" id="anc14"></a><span class="line-modified"> 953      * @throws    NumberFormatException if the {@code String}</span>
 954      *            does not contain a parsable {@code int}.
 955      */
 956     public static Integer valueOf(String s, int radix) throws NumberFormatException {
 957         return Integer.valueOf(parseInt(s,radix));
 958     }
 959 
 960     /**
 961      * Returns an {@code Integer} object holding the
 962      * value of the specified {@code String}. The argument is
 963      * interpreted as representing a signed decimal integer, exactly
 964      * as if the argument were given to the {@link
 965      * #parseInt(java.lang.String)} method. The result is an
 966      * {@code Integer} object that represents the integer value
 967      * specified by the string.
 968      *
 969      * &lt;p&gt;In other words, this method returns an {@code Integer}
 970      * object equal to the value of:
 971      *
 972      * &lt;blockquote&gt;
 973      *  {@code new Integer(Integer.parseInt(s))}
 974      * &lt;/blockquote&gt;
 975      *
 976      * @param      s   the string to be parsed.
 977      * @return     an {@code Integer} object holding the value
 978      *             represented by the string argument.
<a name="15" id="anc15"></a><span class="line-modified"> 979      * @throws     NumberFormatException  if the string cannot be parsed</span>
 980      *             as an integer.
 981      */
 982     public static Integer valueOf(String s) throws NumberFormatException {
 983         return Integer.valueOf(parseInt(s, 10));
 984     }
 985 
 986     /**
 987      * Cache to support the object identity semantics of autoboxing for values between
 988      * -128 and 127 (inclusive) as required by JLS.
 989      *
 990      * The cache is initialized on first usage.  The size of the cache
 991      * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.
 992      * During VM initialization, java.lang.Integer.IntegerCache.high property
 993      * may be set and saved in the private system properties in the
 994      * jdk.internal.misc.VM class.
 995      *
 996      * WARNING: The cache is archived with CDS and reloaded from the shared
 997      * archive at runtime. The archived cache (Integer[]) and Integer objects
 998      * reside in the closed archive heap regions. Care should be taken when
 999      * changing the implementation and the cache array should not be assigned
1000      * with new Integer object(s) after initialization.
1001      */
1002 
1003     private static class IntegerCache {
1004         static final int low = -128;
1005         static final int high;
1006         static final Integer[] cache;
1007         static Integer[] archivedCache;
1008 
1009         static {
1010             // high value may be configured by property
1011             int h = 127;
1012             String integerCacheHighPropValue =
1013                 VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
1014             if (integerCacheHighPropValue != null) {
1015                 try {
1016                     h = Math.max(parseInt(integerCacheHighPropValue), 127);
1017                     // Maximum array size is Integer.MAX_VALUE
1018                     h = Math.min(h, Integer.MAX_VALUE - (-low) -1);
1019                 } catch( NumberFormatException nfe) {
1020                     // If the property cannot be parsed into an int, ignore it.
1021                 }
1022             }
1023             high = h;
1024 
1025             // Load IntegerCache.archivedCache from archive, if possible
1026             VM.initializeFromArchive(IntegerCache.class);
1027             int size = (high - low) + 1;
1028 
1029             // Use the archived cache if it exists and is large enough
1030             if (archivedCache == null || size &gt; archivedCache.length) {
1031                 Integer[] c = new Integer[size];
1032                 int j = low;
1033                 for(int i = 0; i &lt; c.length; i++) {
1034                     c[i] = new Integer(j++);
1035                 }
1036                 archivedCache = c;
1037             }
1038             cache = archivedCache;
1039             // range [-128, 127] must be interned (JLS7 5.1.7)
1040             assert IntegerCache.high &gt;= 127;
1041         }
1042 
1043         private IntegerCache() {}
1044     }
1045 
1046     /**
1047      * Returns an {@code Integer} instance representing the specified
1048      * {@code int} value.  If a new {@code Integer} instance is not
1049      * required, this method should generally be used in preference to
1050      * the constructor {@link #Integer(int)}, as this method is likely
1051      * to yield significantly better space and time performance by
1052      * caching frequently requested values.
1053      *
1054      * This method will always cache values in the range -128 to 127,
1055      * inclusive, and may cache other values outside of this range.
1056      *
1057      * @param  i an {@code int} value.
1058      * @return an {@code Integer} instance representing {@code i}.
1059      * @since  1.5
1060      */
1061     @HotSpotIntrinsicCandidate
1062     public static Integer valueOf(int i) {
1063         if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
1064             return IntegerCache.cache[i + (-IntegerCache.low)];
1065         return new Integer(i);
1066     }
1067 
1068     /**
1069      * The value of the {@code Integer}.
1070      *
1071      * @serial
1072      */
1073     private final int value;
1074 
1075     /**
1076      * Constructs a newly allocated {@code Integer} object that
1077      * represents the specified {@code int} value.
1078      *
1079      * @param   value   the value to be represented by the
1080      *                  {@code Integer} object.
1081      *
1082      * @deprecated
1083      * It is rarely appropriate to use this constructor. The static factory
1084      * {@link #valueOf(int)} is generally a better choice, as it is
1085      * likely to yield significantly better space and time performance.
1086      */
1087     @Deprecated(since=&quot;9&quot;)
1088     public Integer(int value) {
1089         this.value = value;
1090     }
1091 
1092     /**
1093      * Constructs a newly allocated {@code Integer} object that
1094      * represents the {@code int} value indicated by the
1095      * {@code String} parameter. The string is converted to an
1096      * {@code int} value in exactly the manner used by the
1097      * {@code parseInt} method for radix 10.
1098      *
1099      * @param   s   the {@code String} to be converted to an {@code Integer}.
1100      * @throws      NumberFormatException if the {@code String} does not
1101      *              contain a parsable integer.
1102      *
1103      * @deprecated
1104      * It is rarely appropriate to use this constructor.
1105      * Use {@link #parseInt(String)} to convert a string to a
1106      * {@code int} primitive, or use {@link #valueOf(String)}
1107      * to convert a string to an {@code Integer} object.
1108      */
1109     @Deprecated(since=&quot;9&quot;)
1110     public Integer(String s) throws NumberFormatException {
1111         this.value = parseInt(s, 10);
1112     }
1113 
1114     /**
1115      * Returns the value of this {@code Integer} as a {@code byte}
1116      * after a narrowing primitive conversion.
<a name="16" id="anc16"></a><span class="line-modified">1117      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1118      */
1119     public byte byteValue() {
1120         return (byte)value;
1121     }
1122 
1123     /**
1124      * Returns the value of this {@code Integer} as a {@code short}
1125      * after a narrowing primitive conversion.
<a name="17" id="anc17"></a><span class="line-modified">1126      * @jls 5.1.3 Narrowing Primitive Conversion</span>
1127      */
1128     public short shortValue() {
1129         return (short)value;
1130     }
1131 
1132     /**
1133      * Returns the value of this {@code Integer} as an
1134      * {@code int}.
1135      */
1136     @HotSpotIntrinsicCandidate
1137     public int intValue() {
1138         return value;
1139     }
1140 
1141     /**
1142      * Returns the value of this {@code Integer} as a {@code long}
1143      * after a widening primitive conversion.
<a name="18" id="anc18"></a><span class="line-modified">1144      * @jls 5.1.2 Widening Primitive Conversion</span>
1145      * @see Integer#toUnsignedLong(int)
1146      */
1147     public long longValue() {
1148         return (long)value;
1149     }
1150 
1151     /**
1152      * Returns the value of this {@code Integer} as a {@code float}
1153      * after a widening primitive conversion.
<a name="19" id="anc19"></a><span class="line-modified">1154      * @jls 5.1.2 Widening Primitive Conversion</span>
1155      */
1156     public float floatValue() {
1157         return (float)value;
1158     }
1159 
1160     /**
1161      * Returns the value of this {@code Integer} as a {@code double}
1162      * after a widening primitive conversion.
<a name="20" id="anc20"></a><span class="line-modified">1163      * @jls 5.1.2 Widening Primitive Conversion</span>
1164      */
1165     public double doubleValue() {
1166         return (double)value;
1167     }
1168 
1169     /**
1170      * Returns a {@code String} object representing this
1171      * {@code Integer}&#39;s value. The value is converted to signed
1172      * decimal representation and returned as a string, exactly as if
1173      * the integer value were given as an argument to the {@link
1174      * java.lang.Integer#toString(int)} method.
1175      *
1176      * @return  a string representation of the value of this object in
1177      *          base&amp;nbsp;10.
1178      */
1179     public String toString() {
1180         return toString(value);
1181     }
1182 
1183     /**
1184      * Returns a hash code for this {@code Integer}.
1185      *
1186      * @return  a hash code value for this object, equal to the
1187      *          primitive {@code int} value represented by this
1188      *          {@code Integer} object.
1189      */
1190     @Override
1191     public int hashCode() {
1192         return Integer.hashCode(value);
1193     }
1194 
1195     /**
1196      * Returns a hash code for an {@code int} value; compatible with
1197      * {@code Integer.hashCode()}.
1198      *
1199      * @param value the value to hash
1200      * @since 1.8
1201      *
1202      * @return a hash code value for an {@code int} value.
1203      */
1204     public static int hashCode(int value) {
1205         return value;
1206     }
1207 
1208     /**
1209      * Compares this object to the specified object.  The result is
1210      * {@code true} if and only if the argument is not
1211      * {@code null} and is an {@code Integer} object that
1212      * contains the same {@code int} value as this object.
1213      *
1214      * @param   obj   the object to compare with.
1215      * @return  {@code true} if the objects are the same;
1216      *          {@code false} otherwise.
1217      */
1218     public boolean equals(Object obj) {
1219         if (obj instanceof Integer) {
1220             return value == ((Integer)obj).intValue();
1221         }
1222         return false;
1223     }
1224 
1225     /**
1226      * Determines the integer value of the system property with the
1227      * specified name.
1228      *
1229      * &lt;p&gt;The first argument is treated as the name of a system
1230      * property.  System properties are accessible through the {@link
1231      * java.lang.System#getProperty(java.lang.String)} method. The
1232      * string value of this property is then interpreted as an integer
1233      * value using the grammar supported by {@link Integer#decode decode} and
1234      * an {@code Integer} object representing this value is returned.
1235      *
1236      * &lt;p&gt;If there is no property with the specified name, if the
1237      * specified name is empty or {@code null}, or if the property
1238      * does not have the correct numeric format, then {@code null} is
1239      * returned.
1240      *
1241      * &lt;p&gt;In other words, this method returns an {@code Integer}
1242      * object equal to the value of:
1243      *
1244      * &lt;blockquote&gt;
1245      *  {@code getInteger(nm, null)}
1246      * &lt;/blockquote&gt;
1247      *
1248      * @param   nm   property name.
1249      * @return  the {@code Integer} value of the property.
1250      * @throws  SecurityException for the same reasons as
1251      *          {@link System#getProperty(String) System.getProperty}
1252      * @see     java.lang.System#getProperty(java.lang.String)
1253      * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)
1254      */
1255     public static Integer getInteger(String nm) {
1256         return getInteger(nm, null);
1257     }
1258 
1259     /**
1260      * Determines the integer value of the system property with the
1261      * specified name.
1262      *
1263      * &lt;p&gt;The first argument is treated as the name of a system
1264      * property.  System properties are accessible through the {@link
1265      * java.lang.System#getProperty(java.lang.String)} method. The
1266      * string value of this property is then interpreted as an integer
1267      * value using the grammar supported by {@link Integer#decode decode} and
1268      * an {@code Integer} object representing this value is returned.
1269      *
1270      * &lt;p&gt;The second argument is the default value. An {@code Integer} object
1271      * that represents the value of the second argument is returned if there
1272      * is no property of the specified name, if the property does not have
1273      * the correct numeric format, or if the specified name is empty or
1274      * {@code null}.
1275      *
1276      * &lt;p&gt;In other words, this method returns an {@code Integer} object
1277      * equal to the value of:
1278      *
1279      * &lt;blockquote&gt;
1280      *  {@code getInteger(nm, new Integer(val))}
1281      * &lt;/blockquote&gt;
1282      *
1283      * but in practice it may be implemented in a manner such as:
1284      *
1285      * &lt;blockquote&gt;&lt;pre&gt;
1286      * Integer result = getInteger(nm, null);
1287      * return (result == null) ? new Integer(val) : result;
1288      * &lt;/pre&gt;&lt;/blockquote&gt;
1289      *
1290      * to avoid the unnecessary allocation of an {@code Integer}
1291      * object when the default value is not needed.
1292      *
1293      * @param   nm   property name.
1294      * @param   val   default value.
1295      * @return  the {@code Integer} value of the property.
1296      * @throws  SecurityException for the same reasons as
1297      *          {@link System#getProperty(String) System.getProperty}
1298      * @see     java.lang.System#getProperty(java.lang.String)
1299      * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)
1300      */
1301     public static Integer getInteger(String nm, int val) {
1302         Integer result = getInteger(nm, null);
1303         return (result == null) ? Integer.valueOf(val) : result;
1304     }
1305 
1306     /**
1307      * Returns the integer value of the system property with the
1308      * specified name.  The first argument is treated as the name of a
1309      * system property.  System properties are accessible through the
1310      * {@link java.lang.System#getProperty(java.lang.String)} method.
1311      * The string value of this property is then interpreted as an
1312      * integer value, as per the {@link Integer#decode decode} method,
1313      * and an {@code Integer} object representing this value is
1314      * returned; in summary:
1315      *
1316      * &lt;ul&gt;&lt;li&gt;If the property value begins with the two ASCII characters
1317      *         {@code 0x} or the ASCII character {@code #}, not
1318      *      followed by a minus sign, then the rest of it is parsed as a
1319      *      hexadecimal integer exactly as by the method
1320      *      {@link #valueOf(java.lang.String, int)} with radix 16.
1321      * &lt;li&gt;If the property value begins with the ASCII character
1322      *     {@code 0} followed by another character, it is parsed as an
1323      *     octal integer exactly as by the method
1324      *     {@link #valueOf(java.lang.String, int)} with radix 8.
1325      * &lt;li&gt;Otherwise, the property value is parsed as a decimal integer
1326      * exactly as by the method {@link #valueOf(java.lang.String, int)}
1327      * with radix 10.
1328      * &lt;/ul&gt;
1329      *
1330      * &lt;p&gt;The second argument is the default value. The default value is
1331      * returned if there is no property of the specified name, if the
1332      * property does not have the correct numeric format, or if the
1333      * specified name is empty or {@code null}.
1334      *
1335      * @param   nm   property name.
1336      * @param   val   default value.
1337      * @return  the {@code Integer} value of the property.
1338      * @throws  SecurityException for the same reasons as
1339      *          {@link System#getProperty(String) System.getProperty}
1340      * @see     System#getProperty(java.lang.String)
1341      * @see     System#getProperty(java.lang.String, java.lang.String)
1342      */
1343     public static Integer getInteger(String nm, Integer val) {
1344         String v = null;
1345         try {
1346             v = System.getProperty(nm);
1347         } catch (IllegalArgumentException | NullPointerException e) {
1348         }
1349         if (v != null) {
1350             try {
1351                 return Integer.decode(v);
1352             } catch (NumberFormatException e) {
1353             }
1354         }
1355         return val;
1356     }
1357 
1358     /**
1359      * Decodes a {@code String} into an {@code Integer}.
1360      * Accepts decimal, hexadecimal, and octal numbers given
1361      * by the following grammar:
1362      *
1363      * &lt;blockquote&gt;
1364      * &lt;dl&gt;
1365      * &lt;dt&gt;&lt;i&gt;DecodableString:&lt;/i&gt;
1366      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; DecimalNumeral&lt;/i&gt;
1367      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code 0x} &lt;i&gt;HexDigits&lt;/i&gt;
1368      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code 0X} &lt;i&gt;HexDigits&lt;/i&gt;
1369      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code #} &lt;i&gt;HexDigits&lt;/i&gt;
1370      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code 0} &lt;i&gt;OctalDigits&lt;/i&gt;
1371      *
1372      * &lt;dt&gt;&lt;i&gt;Sign:&lt;/i&gt;
1373      * &lt;dd&gt;{@code -}
1374      * &lt;dd&gt;{@code +}
1375      * &lt;/dl&gt;
1376      * &lt;/blockquote&gt;
1377      *
1378      * &lt;i&gt;DecimalNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, and &lt;i&gt;OctalDigits&lt;/i&gt;
1379      * are as defined in section 3.10.1 of
1380      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1381      * except that underscores are not accepted between digits.
1382      *
1383      * &lt;p&gt;The sequence of characters following an optional
1384      * sign and/or radix specifier (&quot;{@code 0x}&quot;, &quot;{@code 0X}&quot;,
1385      * &quot;{@code #}&quot;, or leading zero) is parsed as by the {@code
1386      * Integer.parseInt} method with the indicated radix (10, 16, or
1387      * 8).  This sequence of characters must represent a positive
1388      * value or a {@link NumberFormatException} will be thrown.  The
1389      * result is negated if first character of the specified {@code
1390      * String} is the minus sign.  No whitespace characters are
1391      * permitted in the {@code String}.
1392      *
1393      * @param     nm the {@code String} to decode.
1394      * @return    an {@code Integer} object holding the {@code int}
1395      *             value represented by {@code nm}
<a name="21" id="anc21"></a><span class="line-modified">1396      * @throws    NumberFormatException  if the {@code String} does not</span>
1397      *            contain a parsable integer.
1398      * @see java.lang.Integer#parseInt(java.lang.String, int)
1399      */
1400     public static Integer decode(String nm) throws NumberFormatException {
1401         int radix = 10;
1402         int index = 0;
1403         boolean negative = false;
1404         Integer result;
1405 
1406         if (nm.isEmpty())
1407             throw new NumberFormatException(&quot;Zero length string&quot;);
1408         char firstChar = nm.charAt(0);
1409         // Handle sign, if present
1410         if (firstChar == &#39;-&#39;) {
1411             negative = true;
1412             index++;
1413         } else if (firstChar == &#39;+&#39;)
1414             index++;
1415 
1416         // Handle radix specifier, if present
1417         if (nm.startsWith(&quot;0x&quot;, index) || nm.startsWith(&quot;0X&quot;, index)) {
1418             index += 2;
1419             radix = 16;
1420         }
1421         else if (nm.startsWith(&quot;#&quot;, index)) {
1422             index ++;
1423             radix = 16;
1424         }
1425         else if (nm.startsWith(&quot;0&quot;, index) &amp;&amp; nm.length() &gt; 1 + index) {
1426             index ++;
1427             radix = 8;
1428         }
1429 
1430         if (nm.startsWith(&quot;-&quot;, index) || nm.startsWith(&quot;+&quot;, index))
1431             throw new NumberFormatException(&quot;Sign character in wrong position&quot;);
1432 
1433         try {
1434             result = Integer.valueOf(nm.substring(index), radix);
1435             result = negative ? Integer.valueOf(-result.intValue()) : result;
1436         } catch (NumberFormatException e) {
1437             // If number is Integer.MIN_VALUE, we&#39;ll end up here. The next line
1438             // handles this case, and causes any genuine format error to be
1439             // rethrown.
1440             String constant = negative ? (&quot;-&quot; + nm.substring(index))
1441                                        : nm.substring(index);
1442             result = Integer.valueOf(constant, radix);
1443         }
1444         return result;
1445     }
1446 
1447     /**
1448      * Compares two {@code Integer} objects numerically.
1449      *
1450      * @param   anotherInteger   the {@code Integer} to be compared.
1451      * @return  the value {@code 0} if this {@code Integer} is
1452      *          equal to the argument {@code Integer}; a value less than
1453      *          {@code 0} if this {@code Integer} is numerically less
1454      *          than the argument {@code Integer}; and a value greater
1455      *          than {@code 0} if this {@code Integer} is numerically
1456      *           greater than the argument {@code Integer} (signed
1457      *           comparison).
1458      * @since   1.2
1459      */
1460     public int compareTo(Integer anotherInteger) {
1461         return compare(this.value, anotherInteger.value);
1462     }
1463 
1464     /**
1465      * Compares two {@code int} values numerically.
1466      * The value returned is identical to what would be returned by:
1467      * &lt;pre&gt;
1468      *    Integer.valueOf(x).compareTo(Integer.valueOf(y))
1469      * &lt;/pre&gt;
1470      *
1471      * @param  x the first {@code int} to compare
1472      * @param  y the second {@code int} to compare
1473      * @return the value {@code 0} if {@code x == y};
1474      *         a value less than {@code 0} if {@code x &lt; y}; and
1475      *         a value greater than {@code 0} if {@code x &gt; y}
1476      * @since 1.7
1477      */
1478     public static int compare(int x, int y) {
1479         return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);
1480     }
1481 
1482     /**
1483      * Compares two {@code int} values numerically treating the values
1484      * as unsigned.
1485      *
1486      * @param  x the first {@code int} to compare
1487      * @param  y the second {@code int} to compare
1488      * @return the value {@code 0} if {@code x == y}; a value less
1489      *         than {@code 0} if {@code x &lt; y} as unsigned values; and
1490      *         a value greater than {@code 0} if {@code x &gt; y} as
1491      *         unsigned values
1492      * @since 1.8
1493      */
1494     public static int compareUnsigned(int x, int y) {
1495         return compare(x + MIN_VALUE, y + MIN_VALUE);
1496     }
1497 
1498     /**
1499      * Converts the argument to a {@code long} by an unsigned
1500      * conversion.  In an unsigned conversion to a {@code long}, the
1501      * high-order 32 bits of the {@code long} are zero and the
1502      * low-order 32 bits are equal to the bits of the integer
1503      * argument.
1504      *
1505      * Consequently, zero and positive {@code int} values are mapped
1506      * to a numerically equal {@code long} value and negative {@code
1507      * int} values are mapped to a {@code long} value equal to the
1508      * input plus 2&lt;sup&gt;32&lt;/sup&gt;.
1509      *
1510      * @param  x the value to convert to an unsigned {@code long}
1511      * @return the argument converted to {@code long} by an unsigned
1512      *         conversion
1513      * @since 1.8
1514      */
1515     public static long toUnsignedLong(int x) {
1516         return ((long) x) &amp; 0xffffffffL;
1517     }
1518 
1519     /**
1520      * Returns the unsigned quotient of dividing the first argument by
1521      * the second where each argument and the result is interpreted as
1522      * an unsigned value.
1523      *
1524      * &lt;p&gt;Note that in two&#39;s complement arithmetic, the three other
1525      * basic arithmetic operations of add, subtract, and multiply are
1526      * bit-wise identical if the two operands are regarded as both
1527      * being signed or both being unsigned.  Therefore separate {@code
1528      * addUnsigned}, etc. methods are not provided.
1529      *
1530      * @param dividend the value to be divided
1531      * @param divisor the value doing the dividing
1532      * @return the unsigned quotient of the first argument divided by
1533      * the second argument
1534      * @see #remainderUnsigned
1535      * @since 1.8
1536      */
1537     public static int divideUnsigned(int dividend, int divisor) {
1538         // In lieu of tricky code, for now just use long arithmetic.
1539         return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));
1540     }
1541 
1542     /**
1543      * Returns the unsigned remainder from dividing the first argument
1544      * by the second where each argument and the result is interpreted
1545      * as an unsigned value.
1546      *
1547      * @param dividend the value to be divided
1548      * @param divisor the value doing the dividing
1549      * @return the unsigned remainder of the first argument divided by
1550      * the second argument
1551      * @see #divideUnsigned
1552      * @since 1.8
1553      */
1554     public static int remainderUnsigned(int dividend, int divisor) {
1555         // In lieu of tricky code, for now just use long arithmetic.
1556         return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));
1557     }
1558 
1559 
1560     // Bit twiddling
1561 
1562     /**
1563      * The number of bits used to represent an {@code int} value in two&#39;s
1564      * complement binary form.
1565      *
1566      * @since 1.5
1567      */
1568     @Native public static final int SIZE = 32;
1569 
1570     /**
1571      * The number of bytes used to represent an {@code int} value in two&#39;s
1572      * complement binary form.
1573      *
1574      * @since 1.8
1575      */
1576     public static final int BYTES = SIZE / Byte.SIZE;
1577 
1578     /**
1579      * Returns an {@code int} value with at most a single one-bit, in the
1580      * position of the highest-order (&quot;leftmost&quot;) one-bit in the specified
1581      * {@code int} value.  Returns zero if the specified value has no
1582      * one-bits in its two&#39;s complement binary representation, that is, if it
1583      * is equal to zero.
1584      *
1585      * @param i the value whose highest one bit is to be computed
1586      * @return an {@code int} value with a single one-bit, in the position
1587      *     of the highest-order one-bit in the specified value, or zero if
1588      *     the specified value is itself equal to zero.
1589      * @since 1.5
1590      */
1591     public static int highestOneBit(int i) {
1592         return i &amp; (MIN_VALUE &gt;&gt;&gt; numberOfLeadingZeros(i));
1593     }
1594 
1595     /**
1596      * Returns an {@code int} value with at most a single one-bit, in the
1597      * position of the lowest-order (&quot;rightmost&quot;) one-bit in the specified
1598      * {@code int} value.  Returns zero if the specified value has no
1599      * one-bits in its two&#39;s complement binary representation, that is, if it
1600      * is equal to zero.
1601      *
1602      * @param i the value whose lowest one bit is to be computed
1603      * @return an {@code int} value with a single one-bit, in the position
1604      *     of the lowest-order one-bit in the specified value, or zero if
1605      *     the specified value is itself equal to zero.
1606      * @since 1.5
1607      */
1608     public static int lowestOneBit(int i) {
1609         // HD, Section 2-1
1610         return i &amp; -i;
1611     }
1612 
1613     /**
1614      * Returns the number of zero bits preceding the highest-order
1615      * (&quot;leftmost&quot;) one-bit in the two&#39;s complement binary representation
1616      * of the specified {@code int} value.  Returns 32 if the
1617      * specified value has no one-bits in its two&#39;s complement representation,
1618      * in other words if it is equal to zero.
1619      *
1620      * &lt;p&gt;Note that this method is closely related to the logarithm base 2.
1621      * For all positive {@code int} values x:
1622      * &lt;ul&gt;
1623      * &lt;li&gt;floor(log&lt;sub&gt;2&lt;/sub&gt;(x)) = {@code 31 - numberOfLeadingZeros(x)}
1624      * &lt;li&gt;ceil(log&lt;sub&gt;2&lt;/sub&gt;(x)) = {@code 32 - numberOfLeadingZeros(x - 1)}
1625      * &lt;/ul&gt;
1626      *
1627      * @param i the value whose number of leading zeros is to be computed
1628      * @return the number of zero bits preceding the highest-order
1629      *     (&quot;leftmost&quot;) one-bit in the two&#39;s complement binary representation
1630      *     of the specified {@code int} value, or 32 if the value
1631      *     is equal to zero.
1632      * @since 1.5
1633      */
1634     @HotSpotIntrinsicCandidate
1635     public static int numberOfLeadingZeros(int i) {
1636         // HD, Count leading 0&#39;s
1637         if (i &lt;= 0)
1638             return i == 0 ? 32 : 0;
1639         int n = 31;
1640         if (i &gt;= 1 &lt;&lt; 16) { n -= 16; i &gt;&gt;&gt;= 16; }
1641         if (i &gt;= 1 &lt;&lt;  8) { n -=  8; i &gt;&gt;&gt;=  8; }
1642         if (i &gt;= 1 &lt;&lt;  4) { n -=  4; i &gt;&gt;&gt;=  4; }
1643         if (i &gt;= 1 &lt;&lt;  2) { n -=  2; i &gt;&gt;&gt;=  2; }
1644         return n - (i &gt;&gt;&gt; 1);
1645     }
1646 
1647     /**
1648      * Returns the number of zero bits following the lowest-order (&quot;rightmost&quot;)
1649      * one-bit in the two&#39;s complement binary representation of the specified
1650      * {@code int} value.  Returns 32 if the specified value has no
1651      * one-bits in its two&#39;s complement representation, in other words if it is
1652      * equal to zero.
1653      *
1654      * @param i the value whose number of trailing zeros is to be computed
1655      * @return the number of zero bits following the lowest-order (&quot;rightmost&quot;)
1656      *     one-bit in the two&#39;s complement binary representation of the
1657      *     specified {@code int} value, or 32 if the value is equal
1658      *     to zero.
1659      * @since 1.5
1660      */
1661     @HotSpotIntrinsicCandidate
1662     public static int numberOfTrailingZeros(int i) {
1663         // HD, Count trailing 0&#39;s
1664         i = ~i &amp; (i - 1);
1665         if (i &lt;= 0) return i &amp; 32;
1666         int n = 1;
1667         if (i &gt; 1 &lt;&lt; 16) { n += 16; i &gt;&gt;&gt;= 16; }
1668         if (i &gt; 1 &lt;&lt;  8) { n +=  8; i &gt;&gt;&gt;=  8; }
1669         if (i &gt; 1 &lt;&lt;  4) { n +=  4; i &gt;&gt;&gt;=  4; }
1670         if (i &gt; 1 &lt;&lt;  2) { n +=  2; i &gt;&gt;&gt;=  2; }
1671         return n + (i &gt;&gt;&gt; 1);
1672     }
1673 
1674     /**
1675      * Returns the number of one-bits in the two&#39;s complement binary
1676      * representation of the specified {@code int} value.  This function is
1677      * sometimes referred to as the &lt;i&gt;population count&lt;/i&gt;.
1678      *
1679      * @param i the value whose bits are to be counted
1680      * @return the number of one-bits in the two&#39;s complement binary
1681      *     representation of the specified {@code int} value.
1682      * @since 1.5
1683      */
1684     @HotSpotIntrinsicCandidate
1685     public static int bitCount(int i) {
1686         // HD, Figure 5-2
1687         i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);
1688         i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);
1689         i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;
1690         i = i + (i &gt;&gt;&gt; 8);
1691         i = i + (i &gt;&gt;&gt; 16);
1692         return i &amp; 0x3f;
1693     }
1694 
1695     /**
1696      * Returns the value obtained by rotating the two&#39;s complement binary
1697      * representation of the specified {@code int} value left by the
1698      * specified number of bits.  (Bits shifted out of the left hand, or
1699      * high-order, side reenter on the right, or low-order.)
1700      *
1701      * &lt;p&gt;Note that left rotation with a negative distance is equivalent to
1702      * right rotation: {@code rotateLeft(val, -distance) == rotateRight(val,
1703      * distance)}.  Note also that rotation by any multiple of 32 is a
1704      * no-op, so all but the last five bits of the rotation distance can be
1705      * ignored, even if the distance is negative: {@code rotateLeft(val,
1706      * distance) == rotateLeft(val, distance &amp; 0x1F)}.
1707      *
1708      * @param i the value whose bits are to be rotated left
1709      * @param distance the number of bit positions to rotate left
1710      * @return the value obtained by rotating the two&#39;s complement binary
1711      *     representation of the specified {@code int} value left by the
1712      *     specified number of bits.
1713      * @since 1.5
1714      */
1715     public static int rotateLeft(int i, int distance) {
1716         return (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);
1717     }
1718 
1719     /**
1720      * Returns the value obtained by rotating the two&#39;s complement binary
1721      * representation of the specified {@code int} value right by the
1722      * specified number of bits.  (Bits shifted out of the right hand, or
1723      * low-order, side reenter on the left, or high-order.)
1724      *
1725      * &lt;p&gt;Note that right rotation with a negative distance is equivalent to
1726      * left rotation: {@code rotateRight(val, -distance) == rotateLeft(val,
1727      * distance)}.  Note also that rotation by any multiple of 32 is a
1728      * no-op, so all but the last five bits of the rotation distance can be
1729      * ignored, even if the distance is negative: {@code rotateRight(val,
1730      * distance) == rotateRight(val, distance &amp; 0x1F)}.
1731      *
1732      * @param i the value whose bits are to be rotated right
1733      * @param distance the number of bit positions to rotate right
1734      * @return the value obtained by rotating the two&#39;s complement binary
1735      *     representation of the specified {@code int} value right by the
1736      *     specified number of bits.
1737      * @since 1.5
1738      */
1739     public static int rotateRight(int i, int distance) {
1740         return (i &gt;&gt;&gt; distance) | (i &lt;&lt; -distance);
1741     }
1742 
1743     /**
1744      * Returns the value obtained by reversing the order of the bits in the
1745      * two&#39;s complement binary representation of the specified {@code int}
1746      * value.
1747      *
1748      * @param i the value to be reversed
1749      * @return the value obtained by reversing order of the bits in the
1750      *     specified {@code int} value.
1751      * @since 1.5
1752      */
1753     public static int reverse(int i) {
1754         // HD, Figure 7-1
1755         i = (i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555;
1756         i = (i &amp; 0x33333333) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x33333333;
1757         i = (i &amp; 0x0f0f0f0f) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;
1758 
1759         return reverseBytes(i);
1760     }
1761 
1762     /**
1763      * Returns the signum function of the specified {@code int} value.  (The
1764      * return value is -1 if the specified value is negative; 0 if the
1765      * specified value is zero; and 1 if the specified value is positive.)
1766      *
1767      * @param i the value whose signum is to be computed
1768      * @return the signum function of the specified {@code int} value.
1769      * @since 1.5
1770      */
1771     public static int signum(int i) {
1772         // HD, Section 2-7
1773         return (i &gt;&gt; 31) | (-i &gt;&gt;&gt; 31);
1774     }
1775 
1776     /**
1777      * Returns the value obtained by reversing the order of the bytes in the
1778      * two&#39;s complement representation of the specified {@code int} value.
1779      *
1780      * @param i the value whose bytes are to be reversed
1781      * @return the value obtained by reversing the bytes in the specified
1782      *     {@code int} value.
1783      * @since 1.5
1784      */
1785     @HotSpotIntrinsicCandidate
1786     public static int reverseBytes(int i) {
1787         return (i &lt;&lt; 24)            |
1788                ((i &amp; 0xff00) &lt;&lt; 8)  |
1789                ((i &gt;&gt;&gt; 8) &amp; 0xff00) |
1790                (i &gt;&gt;&gt; 24);
1791     }
1792 
1793     /**
1794      * Adds two integers together as per the + operator.
1795      *
1796      * @param a the first operand
1797      * @param b the second operand
1798      * @return the sum of {@code a} and {@code b}
1799      * @see java.util.function.BinaryOperator
1800      * @since 1.8
1801      */
1802     public static int sum(int a, int b) {
1803         return a + b;
1804     }
1805 
1806     /**
1807      * Returns the greater of two {@code int} values
1808      * as if by calling {@link Math#max(int, int) Math.max}.
1809      *
1810      * @param a the first operand
1811      * @param b the second operand
1812      * @return the greater of {@code a} and {@code b}
1813      * @see java.util.function.BinaryOperator
1814      * @since 1.8
1815      */
1816     public static int max(int a, int b) {
1817         return Math.max(a, b);
1818     }
1819 
1820     /**
1821      * Returns the smaller of two {@code int} values
1822      * as if by calling {@link Math#min(int, int) Math.min}.
1823      *
1824      * @param a the first operand
1825      * @param b the second operand
1826      * @return the smaller of {@code a} and {@code b}
1827      * @see java.util.function.BinaryOperator
1828      * @since 1.8
1829      */
1830     public static int min(int a, int b) {
1831         return Math.min(a, b);
1832     }
1833 
1834     /**
1835      * Returns an {@link Optional} containing the nominal descriptor for this
1836      * instance, which is the instance itself.
1837      *
1838      * @return an {@link Optional} describing the {@linkplain Integer} instance
1839      * @since 12
1840      */
1841     @Override
1842     public Optional&lt;Integer&gt; describeConstable() {
1843         return Optional.of(this);
1844     }
1845 
1846     /**
1847      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1848      * the instance itself.
1849      *
1850      * @param lookup ignored
1851      * @return the {@linkplain Integer} instance
1852      * @since 12
1853      */
1854     @Override
1855     public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {
1856         return this;
1857     }
1858 
1859     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<a name="22" id="anc22"></a><span class="line-added">1860     @java.io.Serial</span>
1861     @Native private static final long serialVersionUID = 1360826667806852920L;
1862 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
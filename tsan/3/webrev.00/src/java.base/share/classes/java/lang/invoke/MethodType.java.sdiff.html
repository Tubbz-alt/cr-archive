<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodType.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodTypeForm.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodType.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.lang.constant.Constable;
  30 import java.lang.constant.MethodTypeDesc;
  31 import java.lang.ref.Reference;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.ref.WeakReference;
  34 import java.util.Arrays;
  35 import java.util.Collections;
  36 import java.util.List;
  37 import java.util.NoSuchElementException;
  38 import java.util.Objects;
  39 import java.util.Optional;
  40 import java.util.StringJoiner;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.stream.Stream;
  44 
  45 import jdk.internal.vm.annotation.Stable;
  46 import sun.invoke.util.BytecodeDescriptor;
  47 import sun.invoke.util.VerifyType;
  48 import sun.invoke.util.Wrapper;

  49 
  50 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  51 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;

  52 
  53 /**
  54  * A method type represents the arguments and return type accepted and
  55  * returned by a method handle, or the arguments and return type passed
  56  * and expected  by a method handle caller.  Method types must be properly
  57  * matched between a method handle and all its callers,
  58  * and the JVM&#39;s operations enforce this matching at, specifically
  59  * during calls to {@link MethodHandle#invokeExact MethodHandle.invokeExact}
  60  * and {@link MethodHandle#invoke MethodHandle.invoke}, and during execution
  61  * of {@code invokedynamic} instructions.
  62  * &lt;p&gt;
  63  * The structure is a return type accompanied by any number of parameter types.
  64  * The types (primitive, {@code void}, and reference) are represented by {@link Class} objects.
  65  * (For ease of exposition, we treat {@code void} as if it were a type.
  66  * In fact, it denotes the absence of a return type.)
  67  * &lt;p&gt;
  68  * All instances of {@code MethodType} are immutable.
  69  * Two instances are completely interchangeable if they compare equal.
  70  * Equality depends on pairwise correspondence of the return and parameter types and on nothing else.
  71  * &lt;p&gt;
  72  * This type can be created only by factory methods.
  73  * All factory methods may cache values, though caching is not guaranteed.
  74  * Some factory methods are static, while others are virtual methods which
  75  * modify precursor method types, e.g., by changing a selected parameter.
  76  * &lt;p&gt;
  77  * Factory methods which operate on groups of parameter types
  78  * are systematically presented in two versions, so that both Java arrays and
  79  * Java lists can be used to work with groups of parameter types.
  80  * The query methods {@code parameterArray} and {@code parameterList}
  81  * also provide a choice between arrays and lists.
  82  * &lt;p&gt;
  83  * {@code MethodType} objects are sometimes derived from bytecode instructions
  84  * such as {@code invokedynamic}, specifically from the type descriptor strings associated
  85  * with the instructions in a class file&#39;s constant pool.
  86  * &lt;p&gt;
  87  * Like classes and strings, method types can also be represented directly
  88  * in a class file&#39;s constant pool as constants.
  89  * A method type may be loaded by an {@code ldc} instruction which refers
  90  * to a suitable {@code CONSTANT_MethodType} constant pool entry.
  91  * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
<span class="line-modified">  92  * (For full details on method type constants,</span>
<span class="line-modified">  93  * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)</span>

  94  * &lt;p&gt;
  95  * When the JVM materializes a {@code MethodType} from a descriptor string,
  96  * all classes named in the descriptor must be accessible, and will be loaded.
  97  * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
  98  * This loading may occur at any time before the {@code MethodType} object is first derived.
  99  * @author John Rose, JSR 292 EG
 100  * @since 1.7
 101  */
 102 public final
 103 class MethodType
 104         implements Constable,
 105                    TypeDescriptor.OfMethod&lt;Class&lt;?&gt;, MethodType&gt;,
 106                    java.io.Serializable {

 107     private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
 108 
 109     // The rtype and ptypes fields define the structural identity of the method type:
 110     private final @Stable Class&lt;?&gt;   rtype;
 111     private final @Stable Class&lt;?&gt;[] ptypes;
 112 
 113     // The remaining fields are caches of various sorts:
 114     private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
 115     private @Stable MethodType wrapAlt;  // alternative wrapped/unwrapped version
 116     private @Stable Invokers invokers;   // cache of handy higher-order adapters
 117     private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
 118 
 119     /**
 120      * Constructor that performs no copying or validation.
 121      * Should only be called from the factory method makeImpl
 122      */
 123     private MethodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
 124         this.rtype = rtype;
 125         this.ptypes = ptypes;
 126     }
 127 
 128     /*trusted*/ MethodTypeForm form() { return form; }
 129     /*trusted*/ Class&lt;?&gt; rtype() { return rtype; }
 130     /*trusted*/ Class&lt;?&gt;[] ptypes() { return ptypes; }
 131 
 132     void setForm(MethodTypeForm f) { form = f; }
 133 
 134     /** This number, mandated by the JVM spec as 255,
 135      *  is the maximum number of &lt;em&gt;slots&lt;/em&gt;
 136      *  that any Java method can receive in its argument list.
 137      *  It limits both JVM signatures and method type objects.
 138      *  The longest possible invocation will look like
 139      *  {@code staticMethod(arg1, arg2, ..., arg255)} or
 140      *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
 141      */
<span class="line-modified"> 142     /*non-public*/ static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.</span>

 143 
 144     /** This number is the maximum arity of a method handle, 254.
 145      *  It is derived from the absolute JVM-imposed arity by subtracting one,
 146      *  which is the slot occupied by the method handle itself at the
 147      *  beginning of the argument list used to invoke the method handle.
 148      *  The longest possible invocation will look like
 149      *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
 150      */
 151     // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
<span class="line-modified"> 152     /*non-public*/ static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver</span>

 153 
 154     /** This number is the maximum arity of a method handle invoker, 253.
 155      *  It is derived from the absolute JVM-imposed arity by subtracting two,
 156      *  which are the slots occupied by invoke method handle, and the
 157      *  target method handle, which are both at the beginning of the argument
 158      *  list used to invoke the target method handle.
 159      *  The longest possible invocation will look like
 160      *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
 161      */
<span class="line-modified"> 162     /*non-public*/ static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker</span>

 163 
 164     private static void checkRtype(Class&lt;?&gt; rtype) {
 165         Objects.requireNonNull(rtype);
 166     }
 167     private static void checkPtype(Class&lt;?&gt; ptype) {
 168         Objects.requireNonNull(ptype);
 169         if (ptype == void.class)
 170             throw newIllegalArgumentException(&quot;parameter type cannot be void&quot;);
 171     }
 172     /** Return number of extra slots (count of long/double args). */
 173     private static int checkPtypes(Class&lt;?&gt;[] ptypes) {
 174         int slots = 0;
 175         for (Class&lt;?&gt; ptype : ptypes) {
 176             checkPtype(ptype);
 177             if (ptype == double.class || ptype == long.class) {
 178                 slots++;
 179             }
 180         }
 181         checkSlotCount(ptypes.length + slots);
 182         return slots;
</pre>
<hr />
<pre>
 190         if ((count &amp; MAX_JVM_ARITY) != count)
 191             throw newIllegalArgumentException(&quot;bad parameter count &quot;+count);
 192     }
 193     private static IndexOutOfBoundsException newIndexOutOfBoundsException(Object num) {
 194         if (num instanceof Integer)  num = &quot;bad index: &quot;+num;
 195         return new IndexOutOfBoundsException(num.toString());
 196     }
 197 
 198     static final ConcurrentWeakInternSet&lt;MethodType&gt; internTable = new ConcurrentWeakInternSet&lt;&gt;();
 199 
 200     static final Class&lt;?&gt;[] NO_PTYPES = {};
 201 
 202     /**
 203      * Finds or creates an instance of the given method type.
 204      * @param rtype  the return type
 205      * @param ptypes the parameter types
 206      * @return a method type with the given components
 207      * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
 208      * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
 209      */
<span class="line-modified"> 210     public static</span>
<span class="line-removed"> 211     MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</span>
 212         return makeImpl(rtype, ptypes, false);
 213     }
 214 
 215     /**
 216      * Finds or creates a method type with the given components.
 217      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 218      * @param rtype  the return type
 219      * @param ptypes the parameter types
 220      * @return a method type with the given components
 221      * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
 222      * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
 223      */
<span class="line-modified"> 224     public static</span>
<span class="line-removed"> 225     MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) {</span>
 226         boolean notrust = false;  // random List impl. could return evil ptypes array
 227         return makeImpl(rtype, listToArray(ptypes), notrust);
 228     }
 229 
 230     private static Class&lt;?&gt;[] listToArray(List&lt;Class&lt;?&gt;&gt; ptypes) {
 231         // sanity check the size before the toArray call, since size might be huge
 232         checkSlotCount(ptypes.size());
 233         return ptypes.toArray(NO_PTYPES);
 234     }
 235 
 236     /**
 237      * Finds or creates a method type with the given components.
 238      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 239      * The leading parameter type is prepended to the remaining array.
 240      * @param rtype  the return type
 241      * @param ptype0 the first parameter type
 242      * @param ptypes the remaining parameter types
 243      * @return a method type with the given components
 244      * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
 245      * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
 246      */
<span class="line-modified"> 247     public static</span>
<span class="line-removed"> 248     MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) {</span>
 249         Class&lt;?&gt;[] ptypes1 = new Class&lt;?&gt;[1+ptypes.length];
 250         ptypes1[0] = ptype0;
 251         System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
 252         return makeImpl(rtype, ptypes1, true);
 253     }
 254 
 255     /**
 256      * Finds or creates a method type with the given components.
 257      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 258      * The resulting method has no parameter types.
 259      * @param rtype  the return type
 260      * @return a method type with the given return value
 261      * @throws NullPointerException if {@code rtype} is null
 262      */
<span class="line-modified"> 263     public static</span>
<span class="line-removed"> 264     MethodType methodType(Class&lt;?&gt; rtype) {</span>
 265         return makeImpl(rtype, NO_PTYPES, true);
 266     }
 267 
 268     /**
 269      * Finds or creates a method type with the given components.
 270      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 271      * The resulting method has the single given parameter type.
 272      * @param rtype  the return type
 273      * @param ptype0 the parameter type
 274      * @return a method type with the given return value and parameter type
 275      * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
 276      * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
 277      */
<span class="line-modified"> 278     public static</span>
<span class="line-removed"> 279     MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) {</span>
 280         return makeImpl(rtype, new Class&lt;?&gt;[]{ ptype0 }, true);
 281     }
 282 
 283     /**
 284      * Finds or creates a method type with the given components.
 285      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 286      * The resulting method has the same parameter types as {@code ptypes},
 287      * and the specified return type.
 288      * @param rtype  the return type
 289      * @param ptypes the method type which supplies the parameter types
 290      * @return a method type with the given components
 291      * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
 292      */
<span class="line-modified"> 293     public static</span>
<span class="line-removed"> 294     MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) {</span>
 295         return makeImpl(rtype, ptypes.ptypes, true);
 296     }
 297 
 298     /**
 299      * Sole factory method to find or create an interned method type.
 300      * @param rtype desired return type
 301      * @param ptypes desired parameter types
 302      * @param trusted whether the ptypes can be used without cloning
 303      * @return the unique method type of the desired structure
 304      */
<span class="line-modified"> 305     /*trusted*/ static</span>
<span class="line-modified"> 306     MethodType makeImpl(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {</span>
 307         if (ptypes.length == 0) {
 308             ptypes = NO_PTYPES; trusted = true;
 309         }
 310         MethodType primordialMT = new MethodType(rtype, ptypes);
 311         MethodType mt = internTable.get(primordialMT);
 312         if (mt != null)
 313             return mt;
 314 
 315         // promote the object to the Real Thing, and reprobe
 316         MethodType.checkRtype(rtype);
 317         if (trusted) {
 318             MethodType.checkPtypes(ptypes);
 319             mt = primordialMT;
 320         } else {
 321             // Make defensive copy then validate
 322             ptypes = Arrays.copyOf(ptypes, ptypes.length);
 323             MethodType.checkPtypes(ptypes);
 324             mt = new MethodType(rtype, ptypes);
 325         }
 326         mt.form = MethodTypeForm.findForm(mt);
 327         return internTable.add(mt);
 328     }
 329     private static final @Stable MethodType[] objectOnlyTypes = new MethodType[20];
 330 
 331     /**
 332      * Finds or creates a method type whose components are {@code Object} with an optional trailing {@code Object[]} array.
 333      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 334      * All parameters and the return type will be {@code Object},
 335      * except the final array parameter if any, which will be {@code Object[]}.
 336      * @param objectArgCount number of parameters (excluding the final array parameter if any)
 337      * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
 338      * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
 339      * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
 340      * @see #genericMethodType(int)
 341      */
<span class="line-modified"> 342     public static</span>
<span class="line-removed"> 343     MethodType genericMethodType(int objectArgCount, boolean finalArray) {</span>
 344         MethodType mt;
 345         checkSlotCount(objectArgCount);
 346         int ivarargs = (!finalArray ? 0 : 1);
 347         int ootIndex = objectArgCount*2 + ivarargs;
 348         if (ootIndex &lt; objectOnlyTypes.length) {
 349             mt = objectOnlyTypes[ootIndex];
 350             if (mt != null)  return mt;
 351         }
 352         Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[objectArgCount + ivarargs];
 353         Arrays.fill(ptypes, Object.class);
 354         if (ivarargs != 0)  ptypes[objectArgCount] = Object[].class;
 355         mt = makeImpl(Object.class, ptypes, true);
 356         if (ootIndex &lt; objectOnlyTypes.length) {
 357             objectOnlyTypes[ootIndex] = mt;     // cache it here also!
 358         }
 359         return mt;
 360     }
 361 
 362     /**
 363      * Finds or creates a method type whose components are all {@code Object}.
 364      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 365      * All parameters and the return type will be Object.
 366      * @param objectArgCount number of parameters
 367      * @return a generally applicable method type, for all calls of the given argument count
 368      * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255
 369      * @see #genericMethodType(int, boolean)
 370      */
<span class="line-modified"> 371     public static</span>
<span class="line-removed"> 372     MethodType genericMethodType(int objectArgCount) {</span>
 373         return genericMethodType(objectArgCount, false);
 374     }
 375 
 376     /**
 377      * Finds or creates a method type with a single different parameter type.
 378      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 379      * @param num    the index (zero-based) of the parameter type to change
 380      * @param nptype a new parameter type to replace the old one with
 381      * @return the same type, except with the selected parameter changed
 382      * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
 383      * @throws IllegalArgumentException if {@code nptype} is {@code void.class}
 384      * @throws NullPointerException if {@code nptype} is null
 385      */
 386     public MethodType changeParameterType(int num, Class&lt;?&gt; nptype) {
 387         if (parameterType(num) == nptype)  return this;
 388         checkPtype(nptype);
 389         Class&lt;?&gt;[] nptypes = ptypes.clone();
 390         nptypes[num] = nptype;
 391         return makeImpl(rtype, nptypes, true);
 392     }
</pre>
<hr />
<pre>
 459      * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
 460      */
 461     public MethodType appendParameterTypes(List&lt;Class&lt;?&gt;&gt; ptypesToInsert) {
 462         return insertParameterTypes(parameterCount(), ptypesToInsert);
 463     }
 464 
 465      /**
 466      * Finds or creates a method type with modified parameter types.
 467      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 468      * @param start  the position (zero-based) of the first replaced parameter type(s)
 469      * @param end    the position (zero-based) after the last replaced parameter type(s)
 470      * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
 471      * @return the same type, except with the selected parameter(s) replaced
 472      * @throws IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}
 473      *                                  or if {@code end} is negative or greater than {@code parameterCount()}
 474      *                                  or if {@code start} is greater than {@code end}
 475      * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
 476      *                                  or if the resulting method type would have more than 255 parameter slots
 477      * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
 478      */
<span class="line-modified"> 479     /*non-public*/ MethodType replaceParameterTypes(int start, int end, Class&lt;?&gt;... ptypesToInsert) {</span>

 480         if (start == end)
 481             return insertParameterTypes(start, ptypesToInsert);
 482         int len = ptypes.length;
 483         if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))
 484             throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);
 485         int ilen = ptypesToInsert.length;
 486         if (ilen == 0)
 487             return dropParameterTypes(start, end);
 488         return dropParameterTypes(start, end).insertParameterTypes(start, ptypesToInsert);
 489     }
 490 
 491     /** Replace the last arrayLength parameter types with the component type of arrayType.
 492      * @param arrayType any array type
 493      * @param pos position at which to spread
 494      * @param arrayLength the number of parameter types to change
 495      * @return the resulting type
 496      */
<span class="line-modified"> 497     /*non-public*/ MethodType asSpreaderType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>

 498         assert(parameterCount() &gt;= arrayLength);
 499         int spreadPos = pos;
 500         if (arrayLength == 0)  return this;  // nothing to change
 501         if (arrayType == Object[].class) {
 502             if (isGeneric())  return this;  // nothing to change
 503             if (spreadPos == 0) {
 504                 // no leading arguments to preserve; go generic
 505                 MethodType res = genericMethodType(arrayLength);
 506                 if (rtype != Object.class) {
 507                     res = res.changeReturnType(rtype);
 508                 }
 509                 return res;
 510             }
 511         }
 512         Class&lt;?&gt; elemType = arrayType.getComponentType();
 513         assert(elemType != null);
 514         for (int i = spreadPos; i &lt; spreadPos + arrayLength; i++) {
 515             if (ptypes[i] != elemType) {
 516                 Class&lt;?&gt;[] fixedPtypes = ptypes.clone();
 517                 Arrays.fill(fixedPtypes, i, spreadPos + arrayLength, elemType);
 518                 return methodType(rtype, fixedPtypes);
 519             }
 520         }
 521         return this;  // arguments check out; no change
 522     }
 523 
 524     /** Return the leading parameter type, which must exist and be a reference.
 525      *  @return the leading parameter type, after error checks
 526      */
<span class="line-modified"> 527     /*non-public*/ Class&lt;?&gt; leadingReferenceParameter() {</span>

 528         Class&lt;?&gt; ptype;
 529         if (ptypes.length == 0 ||
 530             (ptype = ptypes[0]).isPrimitive())
 531             throw newIllegalArgumentException(&quot;no leading reference parameter&quot;);
 532         return ptype;
 533     }
 534 
 535     /** Delete the last parameter type and replace it with arrayLength copies of the component type of arrayType.
 536      * @param arrayType any array type
 537      * @param pos position at which to insert parameters
 538      * @param arrayLength the number of parameter types to insert
 539      * @return the resulting type
 540      */
<span class="line-modified"> 541     /*non-public*/ MethodType asCollectorType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>

 542         assert(parameterCount() &gt;= 1);
 543         assert(pos &lt; ptypes.length);
 544         assert(ptypes[pos].isAssignableFrom(arrayType));
 545         MethodType res;
 546         if (arrayType == Object[].class) {
 547             res = genericMethodType(arrayLength);
 548             if (rtype != Object.class) {
 549                 res = res.changeReturnType(rtype);
 550             }
 551         } else {
 552             Class&lt;?&gt; elemType = arrayType.getComponentType();
 553             assert(elemType != null);
 554             res = methodType(rtype, Collections.nCopies(arrayLength, elemType));
 555         }
 556         if (ptypes.length == 1) {
 557             return res;
 558         } else {
 559             // insert after (if need be), then before
 560             if (pos &lt; ptypes.length - 1) {
 561                 res = res.insertParameterTypes(arrayLength, Arrays.copyOfRange(ptypes, pos + 1, ptypes.length));
</pre>
<hr />
<pre>
 632     public boolean hasWrappers() {
 633         return unwrap() != this;
 634     }
 635 
 636     /**
 637      * Erases all reference types to {@code Object}.
 638      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 639      * All primitive types (including {@code void}) will remain unchanged.
 640      * @return a version of the original type with all reference types replaced
 641      */
 642     public MethodType erase() {
 643         return form.erasedType();
 644     }
 645 
 646     /**
 647      * Erases all reference types to {@code Object}, and all subword types to {@code int}.
 648      * This is the reduced type polymorphism used by private methods
 649      * such as {@link MethodHandle#invokeBasic invokeBasic}.
 650      * @return a version of the original type with all reference and subword types replaced
 651      */
<span class="line-modified"> 652     /*non-public*/ MethodType basicType() {</span>

 653         return form.basicType();
 654     }
 655 
 656     private static final @Stable Class&lt;?&gt;[] METHOD_HANDLE_ARRAY
 657             = new Class&lt;?&gt;[] { MethodHandle.class };
 658 
 659     /**
 660      * @return a version of the original type with MethodHandle prepended as the first argument
 661      */
<span class="line-modified"> 662     /*non-public*/ MethodType invokerType() {</span>

 663         return insertParameterTypes(0, METHOD_HANDLE_ARRAY);
 664     }
 665 
 666     /**
 667      * Converts all types, both reference and primitive, to {@code Object}.
 668      * Convenience method for {@link #genericMethodType(int) genericMethodType}.
 669      * The expression {@code type.wrap().erase()} produces the same value
 670      * as {@code type.generic()}.
 671      * @return a version of the original type with all types replaced
 672      */
 673     public MethodType generic() {
 674         return genericMethodType(parameterCount());
 675     }
 676 
<span class="line-modified"> 677     /*non-public*/ boolean isGeneric() {</span>

 678         return this == erase() &amp;&amp; !hasPrimitives();
 679     }
 680 
 681     /**
 682      * Converts all primitive types to their corresponding wrapper types.
 683      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 684      * All reference types (including wrapper types) will remain unchanged.
 685      * A {@code void} return type is changed to the type {@code java.lang.Void}.
 686      * The expression {@code type.wrap().erase()} produces the same value
 687      * as {@code type.generic()}.
 688      * @return a version of the original type with all primitive types replaced
 689      */
 690     public MethodType wrap() {
 691         return hasPrimitives() ? wrapWithPrims(this) : this;
 692     }
 693 
 694     /**
 695      * Converts all wrapper types to their corresponding primitive types.
 696      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 697      * All primitive types (including {@code void}) will remain unchanged.
</pre>
<hr />
<pre>
 908     boolean isConvertibleTo(MethodType newType) {
 909         MethodTypeForm oldForm = this.form();
 910         MethodTypeForm newForm = newType.form();
 911         if (oldForm == newForm)
 912             // same parameter count, same primitive/object mix
 913             return true;
 914         if (!canConvert(returnType(), newType.returnType()))
 915             return false;
 916         Class&lt;?&gt;[] srcTypes = newType.ptypes;
 917         Class&lt;?&gt;[] dstTypes = ptypes;
 918         if (srcTypes == dstTypes)
 919             return true;
 920         int argc;
 921         if ((argc = srcTypes.length) != dstTypes.length)
 922             return false;
 923         if (argc &lt;= 1) {
 924             if (argc == 1 &amp;&amp; !canConvert(srcTypes[0], dstTypes[0]))
 925                 return false;
 926             return true;
 927         }
<span class="line-modified"> 928         if ((oldForm.primitiveParameterCount() == 0 &amp;&amp; oldForm.erasedType == this) ||</span>
<span class="line-modified"> 929             (newForm.primitiveParameterCount() == 0 &amp;&amp; newForm.erasedType == newType)) {</span>
 930             // Somewhat complicated test to avoid a loop of 2 or more trips.
 931             // If either type has only Object parameters, we know we can convert.
 932             assert(canConvertParameters(srcTypes, dstTypes));
 933             return true;
 934         }
 935         return canConvertParameters(srcTypes, dstTypes);
 936     }
 937 
 938     /** Returns true if MHs.explicitCastArguments produces the same result as MH.asType.
 939      *  If the type conversion is impossible for either, the result should be false.
 940      */
 941     /*non-public*/
 942     boolean explicitCastEquivalentToAsType(MethodType newType) {
 943         if (this == newType)  return true;
 944         if (!explicitCastEquivalentToAsType(rtype, newType.rtype)) {
 945             return false;
 946         }
 947         Class&lt;?&gt;[] srcTypes = newType.ptypes;
 948         Class&lt;?&gt;[] dstTypes = ptypes;
 949         if (dstTypes == srcTypes) {
</pre>
<hr />
<pre>
1044             // Since there is none, we don&#39;t need an extra check here to cover char or boolean.
1045             return false;
1046         } else {
1047             // R-&gt;R always works, since null is always valid dynamically
1048             return true;
1049         }
1050     }
1051 
1052     /// Queries which have to do with the bytecode architecture
1053 
1054     /** Reports the number of JVM stack slots required to invoke a method
1055      * of this type.  Note that (for historical reasons) the JVM requires
1056      * a second stack slot to pass long and double arguments.
1057      * So this method returns {@link #parameterCount() parameterCount} plus the
1058      * number of long and double parameters (if any).
1059      * &lt;p&gt;
1060      * This method is included for the benefit of applications that must
1061      * generate bytecodes that process method handles and invokedynamic.
1062      * @return the number of JVM stack slots for this type&#39;s parameters
1063      */
<span class="line-modified">1064     /*non-public*/ int parameterSlotCount() {</span>

1065         return form.parameterSlotCount();
1066     }
1067 
<span class="line-modified">1068     /*non-public*/ Invokers invokers() {</span>

1069         Invokers inv = invokers;
1070         if (inv != null)  return inv;
1071         invokers = inv = new Invokers(this);
1072         return inv;
1073     }
1074 
<span class="line-removed">1075     /** Reports the number of JVM stack slots which carry all parameters including and after</span>
<span class="line-removed">1076      * the given position, which must be in the range of 0 to</span>
<span class="line-removed">1077      * {@code parameterCount} inclusive.  Successive parameters are</span>
<span class="line-removed">1078      * more shallowly stacked, and parameters are indexed in the bytecodes</span>
<span class="line-removed">1079      * according to their trailing edge.  Thus, to obtain the depth</span>
<span class="line-removed">1080      * in the outgoing call stack of parameter {@code N}, obtain</span>
<span class="line-removed">1081      * the {@code parameterSlotDepth} of its trailing edge</span>
<span class="line-removed">1082      * at position {@code N+1}.</span>
<span class="line-removed">1083      * &lt;p&gt;</span>
<span class="line-removed">1084      * Parameters of type {@code long} and {@code double} occupy</span>
<span class="line-removed">1085      * two stack slots (for historical reasons) and all others occupy one.</span>
<span class="line-removed">1086      * Therefore, the number returned is the number of arguments</span>
<span class="line-removed">1087      * &lt;em&gt;including&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; the given parameter,</span>
<span class="line-removed">1088      * &lt;em&gt;plus&lt;/em&gt; the number of long or double arguments</span>
<span class="line-removed">1089      * at or after the argument for the given parameter.</span>
<span class="line-removed">1090      * &lt;p&gt;</span>
<span class="line-removed">1091      * This method is included for the benefit of applications that must</span>
<span class="line-removed">1092      * generate bytecodes that process method handles and invokedynamic.</span>
<span class="line-removed">1093      * @param num an index (zero-based, inclusive) within the parameter types</span>
<span class="line-removed">1094      * @return the index of the (shallowest) JVM stack slot transmitting the</span>
<span class="line-removed">1095      *         given parameter</span>
<span class="line-removed">1096      * @throws IllegalArgumentException if {@code num} is negative or greater than {@code parameterCount()}</span>
<span class="line-removed">1097      */</span>
<span class="line-removed">1098     /*non-public*/ int parameterSlotDepth(int num) {</span>
<span class="line-removed">1099         if (num &lt; 0 || num &gt; ptypes.length)</span>
<span class="line-removed">1100             parameterType(num);  // force a range check</span>
<span class="line-removed">1101         return form.parameterToArgSlot(num-1);</span>
<span class="line-removed">1102     }</span>
<span class="line-removed">1103 </span>
<span class="line-removed">1104     /** Reports the number of JVM stack slots required to receive a return value</span>
<span class="line-removed">1105      * from a method of this type.</span>
<span class="line-removed">1106      * If the {@link #returnType() return type} is void, it will be zero,</span>
<span class="line-removed">1107      * else if the return type is long or double, it will be two, else one.</span>
<span class="line-removed">1108      * &lt;p&gt;</span>
<span class="line-removed">1109      * This method is included for the benefit of applications that must</span>
<span class="line-removed">1110      * generate bytecodes that process method handles and invokedynamic.</span>
<span class="line-removed">1111      * @return the number of JVM stack slots (0, 1, or 2) for this type&#39;s return value</span>
<span class="line-removed">1112      * Will be removed for PFD.</span>
<span class="line-removed">1113      */</span>
<span class="line-removed">1114     /*non-public*/ int returnSlotCount() {</span>
<span class="line-removed">1115         return form.returnSlotCount();</span>
<span class="line-removed">1116     }</span>
<span class="line-removed">1117 </span>
1118     /**
1119      * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
1120      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<span class="line-modified">1121      * Any class or interface name embedded in the descriptor string</span>
<span class="line-modified">1122      * will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}</span>
<span class="line-removed">1123      * on the given loader (or if it is null, on the system class loader).</span>
1124      * &lt;p&gt;
1125      * Note that it is possible to encounter method types which cannot be
1126      * constructed by this method, because their component types are
1127      * not all reachable from a common class loader.
1128      * &lt;p&gt;
1129      * This method is included for the benefit of applications that must
1130      * generate bytecodes that process method handles and {@code invokedynamic}.
1131      * @param descriptor a bytecode-level type descriptor string &quot;(T...)T&quot;
1132      * @param loader the class loader in which to look up the types
1133      * @return a method type matching the bytecode-level type descriptor
1134      * @throws NullPointerException if the string is null
1135      * @throws IllegalArgumentException if the string is not well-formed
1136      * @throws TypeNotPresentException if a named type cannot be found



1137      */
1138     public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
1139         throws IllegalArgumentException, TypeNotPresentException
1140     {






1141         return fromDescriptor(descriptor,
1142                               (loader == null) ? ClassLoader.getSystemClassLoader() : loader);
1143     }
1144 
1145     /**
1146      * Same as {@link #fromMethodDescriptorString(String, ClassLoader)}, but
1147      * {@code null} ClassLoader means the bootstrap loader is used here.
1148      * &lt;p&gt;
1149      * IMPORTANT: This method is preferable for JDK internal use as it more
1150      * correctly interprets {@code null} ClassLoader than
1151      * {@link #fromMethodDescriptorString(String, ClassLoader)}.
1152      * Use of this method also avoids early initialization issues when system
1153      * ClassLoader is not initialized yet.
1154      */
1155     static MethodType fromDescriptor(String descriptor, ClassLoader loader)
1156         throws IllegalArgumentException, TypeNotPresentException
1157     {
1158         if (!descriptor.startsWith(&quot;(&quot;) ||  // also generates NPE if needed
1159             descriptor.indexOf(&#39;)&#39;) &lt; 0 ||
1160             descriptor.indexOf(&#39;.&#39;) &gt;= 0)
</pre>
<hr />
<pre>
1182         String desc = methodDescriptor;
1183         if (desc == null) {
1184             desc = BytecodeDescriptor.unparseMethod(this.rtype, this.ptypes);
1185             methodDescriptor = desc;
1186         }
1187         return desc;
1188     }
1189 
1190     /**
1191      * Return a field type descriptor string for this type
1192      *
1193      * @return the descriptor string
1194      * @jvms 4.3.2 Field Descriptors
1195      * @since 12
1196      */
1197     @Override
1198     public String descriptorString() {
1199         return toMethodDescriptorString();
1200     }
1201 
<span class="line-modified">1202     /*non-public*/ static String toFieldDescriptorString(Class&lt;?&gt; cls) {</span>

1203         return BytecodeDescriptor.unparse(cls);
1204     }
1205 
1206     /**
1207      * Return a nominal descriptor for this instance, if one can be
1208      * constructed, or an empty {@link Optional} if one cannot be.
1209      *
1210      * @return An {@link Optional} containing the resulting nominal descriptor,
1211      * or an empty {@link Optional} if one cannot be constructed.
1212      * @since 12
1213      */
1214     @Override
1215     public Optional&lt;MethodTypeDesc&gt; describeConstable() {
1216         try {
1217             return Optional.of(MethodTypeDesc.of(returnType().describeConstable().orElseThrow(),
1218                                                  Stream.of(parameterArray())
1219                                                       .map(p -&gt; p.describeConstable().orElseThrow())
1220                                                       .toArray(ClassDesc[]::new)));
1221         }
1222         catch (NoSuchElementException e) {
1223             return Optional.empty();
1224         }
1225     }
1226 
1227     /// Serialization.
1228 
1229     /**
1230      * There are no serializable fields for {@code MethodType}.
1231      */

1232     private static final java.io.ObjectStreamField[] serialPersistentFields = { };
1233 
1234     /**
1235      * Save the {@code MethodType} instance to a stream.
1236      *
1237      * @serialData
1238      * For portability, the serialized format does not refer to named fields.
1239      * Instead, the return type and parameter type arrays are written directly
1240      * from the {@code writeObject} method, using two calls to {@code s.writeObject}
1241      * as follows:
1242      * &lt;blockquote&gt;&lt;pre&gt;{@code
1243 s.writeObject(this.returnType());
1244 s.writeObject(this.parameterArray());
1245      * }&lt;/pre&gt;&lt;/blockquote&gt;
1246      * &lt;p&gt;
1247      * The deserialized field values are checked as if they were
1248      * provided to the factory method {@link #methodType(Class,Class[]) methodType}.
1249      * For example, null values, or {@code void} parameter types,
1250      * will lead to exceptions during deserialization.
1251      * @param s the stream to write the object to
1252      * @throws java.io.IOException if there is a problem writing the object
1253      */

1254     private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
1255         s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
1256         s.writeObject(returnType());
1257         s.writeObject(parameterArray());
1258     }
1259 
1260     /**
1261      * Reconstitute the {@code MethodType} instance from a stream (that is,
1262      * deserialize it).
1263      * This instance is a scratch object with bogus final fields.
1264      * It provides the parameters to the factory method called by
1265      * {@link #readResolve readResolve}.
1266      * After that call it is discarded.
1267      * @param s the stream to read the object from
1268      * @throws java.io.IOException if there is a problem reading the object
1269      * @throws ClassNotFoundException if one of the component classes cannot be resolved
1270      * @see #readResolve
1271      * @see #writeObject
1272      */

1273     private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
1274         // Assign temporary defaults in case this object escapes
1275         MethodType_init(void.class, NO_PTYPES);
1276 
1277         s.defaultReadObject();  // requires serialPersistentFields to be an empty array
1278 
1279         Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
1280         Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();
1281         parameterArray = parameterArray.clone();  // make sure it is unshared
1282 
1283         // Assign deserialized values
1284         MethodType_init(returnType, parameterArray);
1285     }
1286 
1287     // Initialization of state for deserialization only
1288     private void MethodType_init(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
1289         // In order to communicate these values to readResolve, we must
1290         // store them into the implementation-specific final fields.
1291         checkRtype(rtype);
1292         checkPtypes(ptypes);
1293         UNSAFE.putReference(this, OffsetHolder.rtypeOffset, rtype);
1294         UNSAFE.putReference(this, OffsetHolder.ptypesOffset, ptypes);
1295     }
1296 
1297     // Support for resetting final fields while deserializing. Implement Holder
1298     // pattern to make the rarely needed offset calculation lazy.
1299     private static class OffsetHolder {
1300         static final long rtypeOffset
1301                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;rtype&quot;);
1302 
1303         static final long ptypesOffset
1304                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;ptypes&quot;);
1305     }
1306 
1307     /**
1308      * Resolves and initializes a {@code MethodType} object
1309      * after serialization.
1310      * @return the fully initialized {@code MethodType} object
1311      */

1312     private Object readResolve() {
1313         // Do not use a trusted path for deserialization:
1314         //    return makeImpl(rtype, ptypes, true);
1315         // Verify all operands, and make sure ptypes is unshared:
1316         try {
1317             return methodType(rtype, ptypes);
1318         } finally {
1319             // Re-assign defaults in case this object escapes
1320             MethodType_init(void.class, NO_PTYPES);
1321         }
1322     }
1323 
1324     /**
1325      * Simple implementation of weak concurrent intern set.
1326      *
1327      * @param &lt;T&gt; interned type
1328      */
1329     private static class ConcurrentWeakInternSet&lt;T&gt; {
1330 
1331         private final ConcurrentMap&lt;WeakEntry&lt;T&gt;, WeakEntry&lt;T&gt;&gt; map;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.lang.constant.Constable;
  30 import java.lang.constant.MethodTypeDesc;
  31 import java.lang.ref.Reference;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.ref.WeakReference;
  34 import java.util.Arrays;
  35 import java.util.Collections;
  36 import java.util.List;
  37 import java.util.NoSuchElementException;
  38 import java.util.Objects;
  39 import java.util.Optional;
  40 import java.util.StringJoiner;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.stream.Stream;
  44 
  45 import jdk.internal.vm.annotation.Stable;
  46 import sun.invoke.util.BytecodeDescriptor;
  47 import sun.invoke.util.VerifyType;
  48 import sun.invoke.util.Wrapper;
<span class="line-added">  49 import sun.security.util.SecurityConstants;</span>
  50 
  51 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  52 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
<span class="line-added">  53 import static java.lang.invoke.MethodType.fromDescriptor;</span>
  54 
  55 /**
  56  * A method type represents the arguments and return type accepted and
  57  * returned by a method handle, or the arguments and return type passed
  58  * and expected  by a method handle caller.  Method types must be properly
  59  * matched between a method handle and all its callers,
  60  * and the JVM&#39;s operations enforce this matching at, specifically
  61  * during calls to {@link MethodHandle#invokeExact MethodHandle.invokeExact}
  62  * and {@link MethodHandle#invoke MethodHandle.invoke}, and during execution
  63  * of {@code invokedynamic} instructions.
  64  * &lt;p&gt;
  65  * The structure is a return type accompanied by any number of parameter types.
  66  * The types (primitive, {@code void}, and reference) are represented by {@link Class} objects.
  67  * (For ease of exposition, we treat {@code void} as if it were a type.
  68  * In fact, it denotes the absence of a return type.)
  69  * &lt;p&gt;
  70  * All instances of {@code MethodType} are immutable.
  71  * Two instances are completely interchangeable if they compare equal.
  72  * Equality depends on pairwise correspondence of the return and parameter types and on nothing else.
  73  * &lt;p&gt;
  74  * This type can be created only by factory methods.
  75  * All factory methods may cache values, though caching is not guaranteed.
  76  * Some factory methods are static, while others are virtual methods which
  77  * modify precursor method types, e.g., by changing a selected parameter.
  78  * &lt;p&gt;
  79  * Factory methods which operate on groups of parameter types
  80  * are systematically presented in two versions, so that both Java arrays and
  81  * Java lists can be used to work with groups of parameter types.
  82  * The query methods {@code parameterArray} and {@code parameterList}
  83  * also provide a choice between arrays and lists.
  84  * &lt;p&gt;
  85  * {@code MethodType} objects are sometimes derived from bytecode instructions
  86  * such as {@code invokedynamic}, specifically from the type descriptor strings associated
  87  * with the instructions in a class file&#39;s constant pool.
  88  * &lt;p&gt;
  89  * Like classes and strings, method types can also be represented directly
  90  * in a class file&#39;s constant pool as constants.
  91  * A method type may be loaded by an {@code ldc} instruction which refers
  92  * to a suitable {@code CONSTANT_MethodType} constant pool entry.
  93  * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
<span class="line-modified">  94  * (For full details on method type constants, see sections {@jvms</span>
<span class="line-modified">  95  * 4.4.8} and {@jvms 5.4.3.5} of the Java Virtual Machine</span>
<span class="line-added">  96  * Specification.)</span>
  97  * &lt;p&gt;
  98  * When the JVM materializes a {@code MethodType} from a descriptor string,
  99  * all classes named in the descriptor must be accessible, and will be loaded.
 100  * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
 101  * This loading may occur at any time before the {@code MethodType} object is first derived.
 102  * @author John Rose, JSR 292 EG
 103  * @since 1.7
 104  */
 105 public final
 106 class MethodType
 107         implements Constable,
 108                    TypeDescriptor.OfMethod&lt;Class&lt;?&gt;, MethodType&gt;,
 109                    java.io.Serializable {
<span class="line-added"> 110     @java.io.Serial</span>
 111     private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
 112 
 113     // The rtype and ptypes fields define the structural identity of the method type:
 114     private final @Stable Class&lt;?&gt;   rtype;
 115     private final @Stable Class&lt;?&gt;[] ptypes;
 116 
 117     // The remaining fields are caches of various sorts:
 118     private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
 119     private @Stable MethodType wrapAlt;  // alternative wrapped/unwrapped version
 120     private @Stable Invokers invokers;   // cache of handy higher-order adapters
 121     private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
 122 
 123     /**
 124      * Constructor that performs no copying or validation.
 125      * Should only be called from the factory method makeImpl
 126      */
 127     private MethodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
 128         this.rtype = rtype;
 129         this.ptypes = ptypes;
 130     }
 131 
 132     /*trusted*/ MethodTypeForm form() { return form; }
 133     /*trusted*/ Class&lt;?&gt; rtype() { return rtype; }
 134     /*trusted*/ Class&lt;?&gt;[] ptypes() { return ptypes; }
 135 
 136     void setForm(MethodTypeForm f) { form = f; }
 137 
 138     /** This number, mandated by the JVM spec as 255,
 139      *  is the maximum number of &lt;em&gt;slots&lt;/em&gt;
 140      *  that any Java method can receive in its argument list.
 141      *  It limits both JVM signatures and method type objects.
 142      *  The longest possible invocation will look like
 143      *  {@code staticMethod(arg1, arg2, ..., arg255)} or
 144      *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
 145      */
<span class="line-modified"> 146     /*non-public*/</span>
<span class="line-added"> 147     static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.</span>
 148 
 149     /** This number is the maximum arity of a method handle, 254.
 150      *  It is derived from the absolute JVM-imposed arity by subtracting one,
 151      *  which is the slot occupied by the method handle itself at the
 152      *  beginning of the argument list used to invoke the method handle.
 153      *  The longest possible invocation will look like
 154      *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
 155      */
 156     // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
<span class="line-modified"> 157     /*non-public*/</span>
<span class="line-added"> 158     static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver</span>
 159 
 160     /** This number is the maximum arity of a method handle invoker, 253.
 161      *  It is derived from the absolute JVM-imposed arity by subtracting two,
 162      *  which are the slots occupied by invoke method handle, and the
 163      *  target method handle, which are both at the beginning of the argument
 164      *  list used to invoke the target method handle.
 165      *  The longest possible invocation will look like
 166      *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
 167      */
<span class="line-modified"> 168     /*non-public*/</span>
<span class="line-added"> 169     static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker</span>
 170 
 171     private static void checkRtype(Class&lt;?&gt; rtype) {
 172         Objects.requireNonNull(rtype);
 173     }
 174     private static void checkPtype(Class&lt;?&gt; ptype) {
 175         Objects.requireNonNull(ptype);
 176         if (ptype == void.class)
 177             throw newIllegalArgumentException(&quot;parameter type cannot be void&quot;);
 178     }
 179     /** Return number of extra slots (count of long/double args). */
 180     private static int checkPtypes(Class&lt;?&gt;[] ptypes) {
 181         int slots = 0;
 182         for (Class&lt;?&gt; ptype : ptypes) {
 183             checkPtype(ptype);
 184             if (ptype == double.class || ptype == long.class) {
 185                 slots++;
 186             }
 187         }
 188         checkSlotCount(ptypes.length + slots);
 189         return slots;
</pre>
<hr />
<pre>
 197         if ((count &amp; MAX_JVM_ARITY) != count)
 198             throw newIllegalArgumentException(&quot;bad parameter count &quot;+count);
 199     }
 200     private static IndexOutOfBoundsException newIndexOutOfBoundsException(Object num) {
 201         if (num instanceof Integer)  num = &quot;bad index: &quot;+num;
 202         return new IndexOutOfBoundsException(num.toString());
 203     }
 204 
 205     static final ConcurrentWeakInternSet&lt;MethodType&gt; internTable = new ConcurrentWeakInternSet&lt;&gt;();
 206 
 207     static final Class&lt;?&gt;[] NO_PTYPES = {};
 208 
 209     /**
 210      * Finds or creates an instance of the given method type.
 211      * @param rtype  the return type
 212      * @param ptypes the parameter types
 213      * @return a method type with the given components
 214      * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
 215      * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
 216      */
<span class="line-modified"> 217     public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</span>

 218         return makeImpl(rtype, ptypes, false);
 219     }
 220 
 221     /**
 222      * Finds or creates a method type with the given components.
 223      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 224      * @param rtype  the return type
 225      * @param ptypes the parameter types
 226      * @return a method type with the given components
 227      * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
 228      * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
 229      */
<span class="line-modified"> 230     public static MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) {</span>

 231         boolean notrust = false;  // random List impl. could return evil ptypes array
 232         return makeImpl(rtype, listToArray(ptypes), notrust);
 233     }
 234 
 235     private static Class&lt;?&gt;[] listToArray(List&lt;Class&lt;?&gt;&gt; ptypes) {
 236         // sanity check the size before the toArray call, since size might be huge
 237         checkSlotCount(ptypes.size());
 238         return ptypes.toArray(NO_PTYPES);
 239     }
 240 
 241     /**
 242      * Finds or creates a method type with the given components.
 243      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 244      * The leading parameter type is prepended to the remaining array.
 245      * @param rtype  the return type
 246      * @param ptype0 the first parameter type
 247      * @param ptypes the remaining parameter types
 248      * @return a method type with the given components
 249      * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
 250      * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
 251      */
<span class="line-modified"> 252     public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) {</span>

 253         Class&lt;?&gt;[] ptypes1 = new Class&lt;?&gt;[1+ptypes.length];
 254         ptypes1[0] = ptype0;
 255         System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
 256         return makeImpl(rtype, ptypes1, true);
 257     }
 258 
 259     /**
 260      * Finds or creates a method type with the given components.
 261      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 262      * The resulting method has no parameter types.
 263      * @param rtype  the return type
 264      * @return a method type with the given return value
 265      * @throws NullPointerException if {@code rtype} is null
 266      */
<span class="line-modified"> 267     public static MethodType methodType(Class&lt;?&gt; rtype) {</span>

 268         return makeImpl(rtype, NO_PTYPES, true);
 269     }
 270 
 271     /**
 272      * Finds or creates a method type with the given components.
 273      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 274      * The resulting method has the single given parameter type.
 275      * @param rtype  the return type
 276      * @param ptype0 the parameter type
 277      * @return a method type with the given return value and parameter type
 278      * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
 279      * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
 280      */
<span class="line-modified"> 281     public static MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) {</span>

 282         return makeImpl(rtype, new Class&lt;?&gt;[]{ ptype0 }, true);
 283     }
 284 
 285     /**
 286      * Finds or creates a method type with the given components.
 287      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 288      * The resulting method has the same parameter types as {@code ptypes},
 289      * and the specified return type.
 290      * @param rtype  the return type
 291      * @param ptypes the method type which supplies the parameter types
 292      * @return a method type with the given components
 293      * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
 294      */
<span class="line-modified"> 295     public static MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) {</span>

 296         return makeImpl(rtype, ptypes.ptypes, true);
 297     }
 298 
 299     /**
 300      * Sole factory method to find or create an interned method type.
 301      * @param rtype desired return type
 302      * @param ptypes desired parameter types
 303      * @param trusted whether the ptypes can be used without cloning
 304      * @return the unique method type of the desired structure
 305      */
<span class="line-modified"> 306     /*trusted*/</span>
<span class="line-modified"> 307     static MethodType makeImpl(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {</span>
 308         if (ptypes.length == 0) {
 309             ptypes = NO_PTYPES; trusted = true;
 310         }
 311         MethodType primordialMT = new MethodType(rtype, ptypes);
 312         MethodType mt = internTable.get(primordialMT);
 313         if (mt != null)
 314             return mt;
 315 
 316         // promote the object to the Real Thing, and reprobe
 317         MethodType.checkRtype(rtype);
 318         if (trusted) {
 319             MethodType.checkPtypes(ptypes);
 320             mt = primordialMT;
 321         } else {
 322             // Make defensive copy then validate
 323             ptypes = Arrays.copyOf(ptypes, ptypes.length);
 324             MethodType.checkPtypes(ptypes);
 325             mt = new MethodType(rtype, ptypes);
 326         }
 327         mt.form = MethodTypeForm.findForm(mt);
 328         return internTable.add(mt);
 329     }
 330     private static final @Stable MethodType[] objectOnlyTypes = new MethodType[20];
 331 
 332     /**
 333      * Finds or creates a method type whose components are {@code Object} with an optional trailing {@code Object[]} array.
 334      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 335      * All parameters and the return type will be {@code Object},
 336      * except the final array parameter if any, which will be {@code Object[]}.
 337      * @param objectArgCount number of parameters (excluding the final array parameter if any)
 338      * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
 339      * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
 340      * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
 341      * @see #genericMethodType(int)
 342      */
<span class="line-modified"> 343     public static MethodType genericMethodType(int objectArgCount, boolean finalArray) {</span>

 344         MethodType mt;
 345         checkSlotCount(objectArgCount);
 346         int ivarargs = (!finalArray ? 0 : 1);
 347         int ootIndex = objectArgCount*2 + ivarargs;
 348         if (ootIndex &lt; objectOnlyTypes.length) {
 349             mt = objectOnlyTypes[ootIndex];
 350             if (mt != null)  return mt;
 351         }
 352         Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[objectArgCount + ivarargs];
 353         Arrays.fill(ptypes, Object.class);
 354         if (ivarargs != 0)  ptypes[objectArgCount] = Object[].class;
 355         mt = makeImpl(Object.class, ptypes, true);
 356         if (ootIndex &lt; objectOnlyTypes.length) {
 357             objectOnlyTypes[ootIndex] = mt;     // cache it here also!
 358         }
 359         return mt;
 360     }
 361 
 362     /**
 363      * Finds or creates a method type whose components are all {@code Object}.
 364      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 365      * All parameters and the return type will be Object.
 366      * @param objectArgCount number of parameters
 367      * @return a generally applicable method type, for all calls of the given argument count
 368      * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255
 369      * @see #genericMethodType(int, boolean)
 370      */
<span class="line-modified"> 371     public static MethodType genericMethodType(int objectArgCount) {</span>

 372         return genericMethodType(objectArgCount, false);
 373     }
 374 
 375     /**
 376      * Finds or creates a method type with a single different parameter type.
 377      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 378      * @param num    the index (zero-based) of the parameter type to change
 379      * @param nptype a new parameter type to replace the old one with
 380      * @return the same type, except with the selected parameter changed
 381      * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
 382      * @throws IllegalArgumentException if {@code nptype} is {@code void.class}
 383      * @throws NullPointerException if {@code nptype} is null
 384      */
 385     public MethodType changeParameterType(int num, Class&lt;?&gt; nptype) {
 386         if (parameterType(num) == nptype)  return this;
 387         checkPtype(nptype);
 388         Class&lt;?&gt;[] nptypes = ptypes.clone();
 389         nptypes[num] = nptype;
 390         return makeImpl(rtype, nptypes, true);
 391     }
</pre>
<hr />
<pre>
 458      * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
 459      */
 460     public MethodType appendParameterTypes(List&lt;Class&lt;?&gt;&gt; ptypesToInsert) {
 461         return insertParameterTypes(parameterCount(), ptypesToInsert);
 462     }
 463 
 464      /**
 465      * Finds or creates a method type with modified parameter types.
 466      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 467      * @param start  the position (zero-based) of the first replaced parameter type(s)
 468      * @param end    the position (zero-based) after the last replaced parameter type(s)
 469      * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
 470      * @return the same type, except with the selected parameter(s) replaced
 471      * @throws IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}
 472      *                                  or if {@code end} is negative or greater than {@code parameterCount()}
 473      *                                  or if {@code start} is greater than {@code end}
 474      * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
 475      *                                  or if the resulting method type would have more than 255 parameter slots
 476      * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
 477      */
<span class="line-modified"> 478     /*non-public*/</span>
<span class="line-added"> 479     MethodType replaceParameterTypes(int start, int end, Class&lt;?&gt;... ptypesToInsert) {</span>
 480         if (start == end)
 481             return insertParameterTypes(start, ptypesToInsert);
 482         int len = ptypes.length;
 483         if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))
 484             throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);
 485         int ilen = ptypesToInsert.length;
 486         if (ilen == 0)
 487             return dropParameterTypes(start, end);
 488         return dropParameterTypes(start, end).insertParameterTypes(start, ptypesToInsert);
 489     }
 490 
 491     /** Replace the last arrayLength parameter types with the component type of arrayType.
 492      * @param arrayType any array type
 493      * @param pos position at which to spread
 494      * @param arrayLength the number of parameter types to change
 495      * @return the resulting type
 496      */
<span class="line-modified"> 497     /*non-public*/</span>
<span class="line-added"> 498     MethodType asSpreaderType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
 499         assert(parameterCount() &gt;= arrayLength);
 500         int spreadPos = pos;
 501         if (arrayLength == 0)  return this;  // nothing to change
 502         if (arrayType == Object[].class) {
 503             if (isGeneric())  return this;  // nothing to change
 504             if (spreadPos == 0) {
 505                 // no leading arguments to preserve; go generic
 506                 MethodType res = genericMethodType(arrayLength);
 507                 if (rtype != Object.class) {
 508                     res = res.changeReturnType(rtype);
 509                 }
 510                 return res;
 511             }
 512         }
 513         Class&lt;?&gt; elemType = arrayType.getComponentType();
 514         assert(elemType != null);
 515         for (int i = spreadPos; i &lt; spreadPos + arrayLength; i++) {
 516             if (ptypes[i] != elemType) {
 517                 Class&lt;?&gt;[] fixedPtypes = ptypes.clone();
 518                 Arrays.fill(fixedPtypes, i, spreadPos + arrayLength, elemType);
 519                 return methodType(rtype, fixedPtypes);
 520             }
 521         }
 522         return this;  // arguments check out; no change
 523     }
 524 
 525     /** Return the leading parameter type, which must exist and be a reference.
 526      *  @return the leading parameter type, after error checks
 527      */
<span class="line-modified"> 528     /*non-public*/</span>
<span class="line-added"> 529     Class&lt;?&gt; leadingReferenceParameter() {</span>
 530         Class&lt;?&gt; ptype;
 531         if (ptypes.length == 0 ||
 532             (ptype = ptypes[0]).isPrimitive())
 533             throw newIllegalArgumentException(&quot;no leading reference parameter&quot;);
 534         return ptype;
 535     }
 536 
 537     /** Delete the last parameter type and replace it with arrayLength copies of the component type of arrayType.
 538      * @param arrayType any array type
 539      * @param pos position at which to insert parameters
 540      * @param arrayLength the number of parameter types to insert
 541      * @return the resulting type
 542      */
<span class="line-modified"> 543     /*non-public*/</span>
<span class="line-added"> 544     MethodType asCollectorType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
 545         assert(parameterCount() &gt;= 1);
 546         assert(pos &lt; ptypes.length);
 547         assert(ptypes[pos].isAssignableFrom(arrayType));
 548         MethodType res;
 549         if (arrayType == Object[].class) {
 550             res = genericMethodType(arrayLength);
 551             if (rtype != Object.class) {
 552                 res = res.changeReturnType(rtype);
 553             }
 554         } else {
 555             Class&lt;?&gt; elemType = arrayType.getComponentType();
 556             assert(elemType != null);
 557             res = methodType(rtype, Collections.nCopies(arrayLength, elemType));
 558         }
 559         if (ptypes.length == 1) {
 560             return res;
 561         } else {
 562             // insert after (if need be), then before
 563             if (pos &lt; ptypes.length - 1) {
 564                 res = res.insertParameterTypes(arrayLength, Arrays.copyOfRange(ptypes, pos + 1, ptypes.length));
</pre>
<hr />
<pre>
 635     public boolean hasWrappers() {
 636         return unwrap() != this;
 637     }
 638 
 639     /**
 640      * Erases all reference types to {@code Object}.
 641      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 642      * All primitive types (including {@code void}) will remain unchanged.
 643      * @return a version of the original type with all reference types replaced
 644      */
 645     public MethodType erase() {
 646         return form.erasedType();
 647     }
 648 
 649     /**
 650      * Erases all reference types to {@code Object}, and all subword types to {@code int}.
 651      * This is the reduced type polymorphism used by private methods
 652      * such as {@link MethodHandle#invokeBasic invokeBasic}.
 653      * @return a version of the original type with all reference and subword types replaced
 654      */
<span class="line-modified"> 655     /*non-public*/</span>
<span class="line-added"> 656     MethodType basicType() {</span>
 657         return form.basicType();
 658     }
 659 
 660     private static final @Stable Class&lt;?&gt;[] METHOD_HANDLE_ARRAY
 661             = new Class&lt;?&gt;[] { MethodHandle.class };
 662 
 663     /**
 664      * @return a version of the original type with MethodHandle prepended as the first argument
 665      */
<span class="line-modified"> 666     /*non-public*/</span>
<span class="line-added"> 667     MethodType invokerType() {</span>
 668         return insertParameterTypes(0, METHOD_HANDLE_ARRAY);
 669     }
 670 
 671     /**
 672      * Converts all types, both reference and primitive, to {@code Object}.
 673      * Convenience method for {@link #genericMethodType(int) genericMethodType}.
 674      * The expression {@code type.wrap().erase()} produces the same value
 675      * as {@code type.generic()}.
 676      * @return a version of the original type with all types replaced
 677      */
 678     public MethodType generic() {
 679         return genericMethodType(parameterCount());
 680     }
 681 
<span class="line-modified"> 682     /*non-public*/</span>
<span class="line-added"> 683     boolean isGeneric() {</span>
 684         return this == erase() &amp;&amp; !hasPrimitives();
 685     }
 686 
 687     /**
 688      * Converts all primitive types to their corresponding wrapper types.
 689      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 690      * All reference types (including wrapper types) will remain unchanged.
 691      * A {@code void} return type is changed to the type {@code java.lang.Void}.
 692      * The expression {@code type.wrap().erase()} produces the same value
 693      * as {@code type.generic()}.
 694      * @return a version of the original type with all primitive types replaced
 695      */
 696     public MethodType wrap() {
 697         return hasPrimitives() ? wrapWithPrims(this) : this;
 698     }
 699 
 700     /**
 701      * Converts all wrapper types to their corresponding primitive types.
 702      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 703      * All primitive types (including {@code void}) will remain unchanged.
</pre>
<hr />
<pre>
 914     boolean isConvertibleTo(MethodType newType) {
 915         MethodTypeForm oldForm = this.form();
 916         MethodTypeForm newForm = newType.form();
 917         if (oldForm == newForm)
 918             // same parameter count, same primitive/object mix
 919             return true;
 920         if (!canConvert(returnType(), newType.returnType()))
 921             return false;
 922         Class&lt;?&gt;[] srcTypes = newType.ptypes;
 923         Class&lt;?&gt;[] dstTypes = ptypes;
 924         if (srcTypes == dstTypes)
 925             return true;
 926         int argc;
 927         if ((argc = srcTypes.length) != dstTypes.length)
 928             return false;
 929         if (argc &lt;= 1) {
 930             if (argc == 1 &amp;&amp; !canConvert(srcTypes[0], dstTypes[0]))
 931                 return false;
 932             return true;
 933         }
<span class="line-modified"> 934         if ((!oldForm.hasPrimitives() &amp;&amp; oldForm.erasedType == this) ||</span>
<span class="line-modified"> 935             (!newForm.hasPrimitives() &amp;&amp; newForm.erasedType == newType)) {</span>
 936             // Somewhat complicated test to avoid a loop of 2 or more trips.
 937             // If either type has only Object parameters, we know we can convert.
 938             assert(canConvertParameters(srcTypes, dstTypes));
 939             return true;
 940         }
 941         return canConvertParameters(srcTypes, dstTypes);
 942     }
 943 
 944     /** Returns true if MHs.explicitCastArguments produces the same result as MH.asType.
 945      *  If the type conversion is impossible for either, the result should be false.
 946      */
 947     /*non-public*/
 948     boolean explicitCastEquivalentToAsType(MethodType newType) {
 949         if (this == newType)  return true;
 950         if (!explicitCastEquivalentToAsType(rtype, newType.rtype)) {
 951             return false;
 952         }
 953         Class&lt;?&gt;[] srcTypes = newType.ptypes;
 954         Class&lt;?&gt;[] dstTypes = ptypes;
 955         if (dstTypes == srcTypes) {
</pre>
<hr />
<pre>
1050             // Since there is none, we don&#39;t need an extra check here to cover char or boolean.
1051             return false;
1052         } else {
1053             // R-&gt;R always works, since null is always valid dynamically
1054             return true;
1055         }
1056     }
1057 
1058     /// Queries which have to do with the bytecode architecture
1059 
1060     /** Reports the number of JVM stack slots required to invoke a method
1061      * of this type.  Note that (for historical reasons) the JVM requires
1062      * a second stack slot to pass long and double arguments.
1063      * So this method returns {@link #parameterCount() parameterCount} plus the
1064      * number of long and double parameters (if any).
1065      * &lt;p&gt;
1066      * This method is included for the benefit of applications that must
1067      * generate bytecodes that process method handles and invokedynamic.
1068      * @return the number of JVM stack slots for this type&#39;s parameters
1069      */
<span class="line-modified">1070     /*non-public*/</span>
<span class="line-added">1071     int parameterSlotCount() {</span>
1072         return form.parameterSlotCount();
1073     }
1074 
<span class="line-modified">1075     /*non-public*/</span>
<span class="line-added">1076     Invokers invokers() {</span>
1077         Invokers inv = invokers;
1078         if (inv != null)  return inv;
1079         invokers = inv = new Invokers(this);
1080         return inv;
1081     }
1082 











































1083     /**
1084      * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
1085      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<span class="line-modified">1086      * Any class or interface name embedded in the descriptor string will be</span>
<span class="line-modified">1087      * resolved by the given loader (or if it is null, on the system class loader).</span>

1088      * &lt;p&gt;
1089      * Note that it is possible to encounter method types which cannot be
1090      * constructed by this method, because their component types are
1091      * not all reachable from a common class loader.
1092      * &lt;p&gt;
1093      * This method is included for the benefit of applications that must
1094      * generate bytecodes that process method handles and {@code invokedynamic}.
1095      * @param descriptor a bytecode-level type descriptor string &quot;(T...)T&quot;
1096      * @param loader the class loader in which to look up the types
1097      * @return a method type matching the bytecode-level type descriptor
1098      * @throws NullPointerException if the string is null
1099      * @throws IllegalArgumentException if the string is not well-formed
1100      * @throws TypeNotPresentException if a named type cannot be found
<span class="line-added">1101      * @throws SecurityException if the security manager is present and</span>
<span class="line-added">1102      *         {@code loader} is {@code null} and the caller does not have the</span>
<span class="line-added">1103      *         {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}</span>
1104      */
1105     public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
1106         throws IllegalArgumentException, TypeNotPresentException
1107     {
<span class="line-added">1108         if (loader == null) {</span>
<span class="line-added">1109             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">1110             if (sm != null) {</span>
<span class="line-added">1111                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>
<span class="line-added">1112             }</span>
<span class="line-added">1113         }</span>
1114         return fromDescriptor(descriptor,
1115                               (loader == null) ? ClassLoader.getSystemClassLoader() : loader);
1116     }
1117 
1118     /**
1119      * Same as {@link #fromMethodDescriptorString(String, ClassLoader)}, but
1120      * {@code null} ClassLoader means the bootstrap loader is used here.
1121      * &lt;p&gt;
1122      * IMPORTANT: This method is preferable for JDK internal use as it more
1123      * correctly interprets {@code null} ClassLoader than
1124      * {@link #fromMethodDescriptorString(String, ClassLoader)}.
1125      * Use of this method also avoids early initialization issues when system
1126      * ClassLoader is not initialized yet.
1127      */
1128     static MethodType fromDescriptor(String descriptor, ClassLoader loader)
1129         throws IllegalArgumentException, TypeNotPresentException
1130     {
1131         if (!descriptor.startsWith(&quot;(&quot;) ||  // also generates NPE if needed
1132             descriptor.indexOf(&#39;)&#39;) &lt; 0 ||
1133             descriptor.indexOf(&#39;.&#39;) &gt;= 0)
</pre>
<hr />
<pre>
1155         String desc = methodDescriptor;
1156         if (desc == null) {
1157             desc = BytecodeDescriptor.unparseMethod(this.rtype, this.ptypes);
1158             methodDescriptor = desc;
1159         }
1160         return desc;
1161     }
1162 
1163     /**
1164      * Return a field type descriptor string for this type
1165      *
1166      * @return the descriptor string
1167      * @jvms 4.3.2 Field Descriptors
1168      * @since 12
1169      */
1170     @Override
1171     public String descriptorString() {
1172         return toMethodDescriptorString();
1173     }
1174 
<span class="line-modified">1175     /*non-public*/</span>
<span class="line-added">1176     static String toFieldDescriptorString(Class&lt;?&gt; cls) {</span>
1177         return BytecodeDescriptor.unparse(cls);
1178     }
1179 
1180     /**
1181      * Return a nominal descriptor for this instance, if one can be
1182      * constructed, or an empty {@link Optional} if one cannot be.
1183      *
1184      * @return An {@link Optional} containing the resulting nominal descriptor,
1185      * or an empty {@link Optional} if one cannot be constructed.
1186      * @since 12
1187      */
1188     @Override
1189     public Optional&lt;MethodTypeDesc&gt; describeConstable() {
1190         try {
1191             return Optional.of(MethodTypeDesc.of(returnType().describeConstable().orElseThrow(),
1192                                                  Stream.of(parameterArray())
1193                                                       .map(p -&gt; p.describeConstable().orElseThrow())
1194                                                       .toArray(ClassDesc[]::new)));
1195         }
1196         catch (NoSuchElementException e) {
1197             return Optional.empty();
1198         }
1199     }
1200 
1201     /// Serialization.
1202 
1203     /**
1204      * There are no serializable fields for {@code MethodType}.
1205      */
<span class="line-added">1206     @java.io.Serial</span>
1207     private static final java.io.ObjectStreamField[] serialPersistentFields = { };
1208 
1209     /**
1210      * Save the {@code MethodType} instance to a stream.
1211      *
1212      * @serialData
1213      * For portability, the serialized format does not refer to named fields.
1214      * Instead, the return type and parameter type arrays are written directly
1215      * from the {@code writeObject} method, using two calls to {@code s.writeObject}
1216      * as follows:
1217      * &lt;blockquote&gt;&lt;pre&gt;{@code
1218 s.writeObject(this.returnType());
1219 s.writeObject(this.parameterArray());
1220      * }&lt;/pre&gt;&lt;/blockquote&gt;
1221      * &lt;p&gt;
1222      * The deserialized field values are checked as if they were
1223      * provided to the factory method {@link #methodType(Class,Class[]) methodType}.
1224      * For example, null values, or {@code void} parameter types,
1225      * will lead to exceptions during deserialization.
1226      * @param s the stream to write the object to
1227      * @throws java.io.IOException if there is a problem writing the object
1228      */
<span class="line-added">1229     @java.io.Serial</span>
1230     private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
1231         s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
1232         s.writeObject(returnType());
1233         s.writeObject(parameterArray());
1234     }
1235 
1236     /**
1237      * Reconstitute the {@code MethodType} instance from a stream (that is,
1238      * deserialize it).
1239      * This instance is a scratch object with bogus final fields.
1240      * It provides the parameters to the factory method called by
1241      * {@link #readResolve readResolve}.
1242      * After that call it is discarded.
1243      * @param s the stream to read the object from
1244      * @throws java.io.IOException if there is a problem reading the object
1245      * @throws ClassNotFoundException if one of the component classes cannot be resolved
1246      * @see #readResolve
1247      * @see #writeObject
1248      */
<span class="line-added">1249     @java.io.Serial</span>
1250     private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
1251         // Assign temporary defaults in case this object escapes
1252         MethodType_init(void.class, NO_PTYPES);
1253 
1254         s.defaultReadObject();  // requires serialPersistentFields to be an empty array
1255 
1256         Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
1257         Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();
1258         parameterArray = parameterArray.clone();  // make sure it is unshared
1259 
1260         // Assign deserialized values
1261         MethodType_init(returnType, parameterArray);
1262     }
1263 
1264     // Initialization of state for deserialization only
1265     private void MethodType_init(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
1266         // In order to communicate these values to readResolve, we must
1267         // store them into the implementation-specific final fields.
1268         checkRtype(rtype);
1269         checkPtypes(ptypes);
1270         UNSAFE.putReference(this, OffsetHolder.rtypeOffset, rtype);
1271         UNSAFE.putReference(this, OffsetHolder.ptypesOffset, ptypes);
1272     }
1273 
1274     // Support for resetting final fields while deserializing. Implement Holder
1275     // pattern to make the rarely needed offset calculation lazy.
1276     private static class OffsetHolder {
1277         static final long rtypeOffset
1278                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;rtype&quot;);
1279 
1280         static final long ptypesOffset
1281                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;ptypes&quot;);
1282     }
1283 
1284     /**
1285      * Resolves and initializes a {@code MethodType} object
1286      * after serialization.
1287      * @return the fully initialized {@code MethodType} object
1288      */
<span class="line-added">1289     @java.io.Serial</span>
1290     private Object readResolve() {
1291         // Do not use a trusted path for deserialization:
1292         //    return makeImpl(rtype, ptypes, true);
1293         // Verify all operands, and make sure ptypes is unshared:
1294         try {
1295             return methodType(rtype, ptypes);
1296         } finally {
1297             // Re-assign defaults in case this object escapes
1298             MethodType_init(void.class, NO_PTYPES);
1299         }
1300     }
1301 
1302     /**
1303      * Simple implementation of weak concurrent intern set.
1304      *
1305      * @param &lt;T&gt; interned type
1306      */
1307     private static class ConcurrentWeakInternSet&lt;T&gt; {
1308 
1309         private final ConcurrentMap&lt;WeakEntry&lt;T&gt;, WeakEntry&lt;T&gt;&gt; map;
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodTypeForm.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/Record.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang;
 26 
 27 /**
 28  * {@preview Associated with records, a preview feature of the Java language.
 29  *
 30  *           This class is associated with &lt;i&gt;records&lt;/i&gt;, a preview
 31  *           feature of the Java language. Programs can only use this
 32  *           class when preview features are enabled. Preview features
 33  *           may be removed in a future release, or upgraded to permanent
 34  *           features of the Java language.}
 35  *
 36  * This is the common base class of all Java language record classes.
 37  *
 38  * &lt;p&gt;More information about records, including descriptions of the
 39  * implicitly declared methods synthesized by the compiler, can be
 40  * found in section 8.10 of
 41  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 42  *
 43  * &lt;p&gt;A &lt;em&gt;record class&lt;/em&gt; is a shallowly immutable, transparent carrier for
 44  * a fixed set of values, called the &lt;em&gt;record components&lt;/em&gt;.  The Java&amp;trade;
 45  * language provides concise syntax for declaring record classes, whereby the
 46  * record components are declared in the record header.  The list of record
 47  * components declared in the record header form the &lt;em&gt;record descriptor&lt;/em&gt;.
 48  *
 49  * &lt;p&gt;A record class has the following mandated members: a public &lt;em&gt;canonical
 50  * constructor&lt;/em&gt;, whose descriptor is the same as the record descriptor;
 51  * a private final field corresponding to each component, whose name and
 52  * type are the same as that of the component; a public accessor method
 53  * corresponding to each component, whose name and return type are the same as
 54  * that of the component.  If not explicitly declared in the body of the record,
 55  * implicit implementations for these members are provided.
 56  *
 57  * &lt;p&gt;The implicit declaration of the canonical constructor initializes the
 58  * component fields from the corresponding constructor arguments.  The implicit
 59  * declaration of the accessor methods returns the value of the corresponding
 60  * component field.  The implicit declaration of the {@link Object#equals(Object)},
 61  * {@link Object#hashCode()}, and {@link Object#toString()} methods are derived
 62  * from all of the component fields.
 63  *
 64  * &lt;p&gt;The primary reasons to provide an explicit declaration for the
 65  * canonical constructor or accessor methods are to validate constructor
 66  * arguments, perform defensive copies on mutable components, or normalize groups
 67  * of components (such as reducing a rational number to lowest terms.)
 68  *
 69  * &lt;p&gt;For all record classes, the following invariant must hold: if a record R&#39;s
 70  * components are {@code c1, c2, ... cn}, then if a record instance is copied
 71  * as follows:
 72  * &lt;pre&gt;
 73  *     R copy = new R(r.c1(), r.c2(), ..., r.cn());
 74  * &lt;/pre&gt;
 75  * then it must be the case that {@code r.equals(copy)}.
 76  *
 77  * @apiNote
 78  * A record class that {@code implements} {@link java.io.Serializable} is said
 79  * to be a &lt;i&gt;serializable record&lt;/i&gt;. Serializable records are serialized and
 80  * deserialized differently than ordinary serializable objects. During
 81  * deserialization the record&#39;s canonical constructor is invoked to construct
 82  * the record object. Certain serialization-related methods, such as readObject
 83  * and writeObject, are ignored for serializable records. More information about
 84  * serializable records can be found in
 85  * &lt;a href=&quot;{@docRoot}/java.base/java/io/ObjectInputStream.html#record-serialization&quot;&gt;record serialization&lt;/a&gt;.
 86  *
 87  * @jls 8.10 Record Types
 88  * @since 14
 89  */
 90 @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
 91                              essentialAPI=true)
 92 public abstract class Record {
 93     /**
 94      * Constructor for record classes to call.
 95      */
 96     protected Record() {}
 97 
 98     /**
 99      * Indicates whether some other object is &quot;equal to&quot; this one.  In addition
100      * to the general contract of {@link Object#equals(Object) Object.equals},
101      * record classes must further obey the invariant that when
102      * a record instance is &quot;copied&quot; by passing the result of the record component
103      * accessor methods to the canonical constructor, as follows:
104      * &lt;pre&gt;
105      *     R copy = new R(r.c1(), r.c2(), ..., r.cn());
106      * &lt;/pre&gt;
107      * then it must be the case that {@code r.equals(copy)}.
108      *
109      * @implSpec
110      * The implicitly provided implementation returns {@code true} if
111      * and only if the argument is an instance of the same record type
112      * as this record, and each component of this record is equal to
113      * the corresponding component of the argument; otherwise, {@code
114      * false} is returned. Equality of a component {@code c} is
115      * determined as follows:
116      * &lt;ul&gt;
117      *
118      * &lt;li&gt; If the component is of a reference type, the component is
119      * considered equal if and only if {@link
120      * java.util.Objects#equals(Object,Object)
121      * Objects.equals(this.c(), r.c()} would return {@code true}.
122      *
123      * &lt;li&gt; If the component is of a primitive type, using the
124      * corresponding primitive wrapper class {@code PW} (the
125      * corresponding wrapper class for {@code int} is {@code
126      * java.lang.Integer}, and so on), the component is considered
127      * equal if and only if {@code
128      * PW.valueOf(this.c()).equals(PW.valueOf(r.c()))} would return
129      * {@code true}.
130      *
131      * &lt;/ul&gt;
132      *
133      * Apart from the semantics described above, the precise algorithm
134      * used in the implicitly provided implementation is unspecified
135      * and is subject to change. The implementation may or may not use
136      * calls to the particular methods listed, and may or may not
137      * perform comparisons in the order of component declaration.
138      *
139      * @see java.util.Objects#equals(Object,Object)
140      *
141      * @param   obj   the reference object with which to compare.
142      * @return  {@code true} if this record is equal to the
143      *          argument; {@code false} otherwise.
144      */
145     @Override
146     public abstract boolean equals(Object obj);
147 
148     /**
149      * Returns a hash code value for the record.
150      * Obeys the general contract of {@link Object#hashCode Object.hashCode}.
151      * For records, hashing behavior is constrained by the refined contract
152      * of {@link Record#equals Record.equals}, so that any two records
153      * created from the same components must have the same hash code.
154      *
155      * @implSpec
156      * The implicitly provided implementation returns a hash code value derived
157      * by combining appropriate hashes from each component.
158      * The precise algorithm used in the implicitly provided implementation
159      * is unspecified and is subject to change within the above limits.
160      * The resulting integer need not remain consistent from one
161      * execution of an application to another execution of the same
162      * application, even if the hashes of the component values were to
163      * remain consistent in this way.  Also, a component of primitive
164      * type may contribute its bits to the hash code differently than
165      * the {@code hashCode} of its primitive wrapper class.
166      *
167      * @see     Object#hashCode()
168      *
169      * @return  a hash code value for this record.
170      */
171     @Override
172     public abstract int hashCode();
173 
174     /**
175      * Returns a string representation of the record.
176      * In accordance with the general contract of {@link Object#toString()},
177      * the {@code toString} method returns a string that
178      * &quot;textually represents&quot; this record. The result should
179      * be a concise but informative representation that is easy for a
180      * person to read.
181      * &lt;p&gt;
182      * In addition to this general contract, record classes must further
183      * participate in the invariant that any two records which are
184      * {@linkplain Record#equals(Object) equal} must produce equal
185      * strings.  This invariant is necessarily relaxed in the rare
186      * case where corresponding equal component values might fail
187      * to produce equal strings for themselves.
188      *
189      * @implSpec
190      * The implicitly provided implementation returns a string which
191      * contains the name of the record class, the names of components
192      * of the record, and string representations of component values,
193      * so as to fulfill the contract of this method.
194      * The precise format produced by this implicitly provided implementation
195      * is subject to change, so the present syntax should not be parsed
196      * by applications to recover record component values.
197      *
198      * @see     Object#toString()
199      *
200      * @return  a string representation of the object.
201      */
202     @Override
203     public abstract String toString();
204 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/OutputStreamWriter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="OutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PipedInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/OutputStreamWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 70  * @see java.nio.charset.Charset
 71  *
 72  * @author      Mark Reinhold
 73  * @since       1.1
 74  */
 75 
 76 public class OutputStreamWriter extends Writer {
 77 
 78     private final StreamEncoder se;
 79 
 80     /**
 81      * Creates an OutputStreamWriter that uses the named charset.
 82      *
 83      * @param  out
 84      *         An OutputStream
 85      *
 86      * @param  charsetName
 87      *         The name of a supported
 88      *         {@link java.nio.charset.Charset charset}
 89      *
<span class="line-modified"> 90      * @exception  UnsupportedEncodingException</span>
 91      *             If the named encoding is not supported
 92      */
 93     public OutputStreamWriter(OutputStream out, String charsetName)
 94         throws UnsupportedEncodingException
 95     {
 96         super(out);
 97         if (charsetName == null)
 98             throw new NullPointerException(&quot;charsetName&quot;);
 99         se = StreamEncoder.forOutputStreamWriter(out, this, charsetName);
100     }
101 
102     /**
103      * Creates an OutputStreamWriter that uses the default character encoding.
104      *
105      * @param  out  An OutputStream
106      */
107     public OutputStreamWriter(OutputStream out) {
108         super(out);
<span class="line-modified">109         try {</span>
<span class="line-modified">110             se = StreamEncoder.forOutputStreamWriter(out, this, (String)null);</span>
<span class="line-removed">111         } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">112             throw new Error(e);</span>
<span class="line-removed">113         }</span>
114     }
115 
116     /**
117      * Creates an OutputStreamWriter that uses the given charset.
118      *
119      * @param  out
120      *         An OutputStream
121      *
122      * @param  cs
123      *         A charset
124      *
125      * @since 1.4
126      * @spec JSR-51
127      */
128     public OutputStreamWriter(OutputStream out, Charset cs) {
129         super(out);
130         if (cs == null)
131             throw new NullPointerException(&quot;charset&quot;);
132         se = StreamEncoder.forOutputStreamWriter(out, this, cs);
133     }
</pre>
<hr />
<pre>
147     public OutputStreamWriter(OutputStream out, CharsetEncoder enc) {
148         super(out);
149         if (enc == null)
150             throw new NullPointerException(&quot;charset encoder&quot;);
151         se = StreamEncoder.forOutputStreamWriter(out, this, enc);
152     }
153 
154     /**
155      * Returns the name of the character encoding being used by this stream.
156      *
157      * &lt;p&gt; If the encoding has an historical name then that name is returned;
158      * otherwise the encoding&#39;s canonical name is returned.
159      *
160      * &lt;p&gt; If this instance was created with the {@link
161      * #OutputStreamWriter(OutputStream, String)} constructor then the returned
162      * name, being unique for the encoding, may differ from the name passed to
163      * the constructor.  This method may return {@code null} if the stream has
164      * been closed. &lt;/p&gt;
165      *
166      * @return The historical name of this encoding, or possibly
<span class="line-modified">167      *         &lt;code&gt;null&lt;/code&gt; if the stream has been closed</span>
168      *
169      * @see java.nio.charset.Charset
170      *
171      * @revised 1.4
172      * @spec JSR-51
173      */
174     public String getEncoding() {
175         return se.getEncoding();
176     }
177 
178     /**
179      * Flushes the output buffer to the underlying byte stream, without flushing
180      * the byte stream itself.  This method is non-private only so that it may
181      * be invoked by PrintStream.
182      */
183     void flushBuffer() throws IOException {
184         se.flushBuffer();
185     }
186 
187     /**
188      * Writes a single character.
189      *
<span class="line-modified">190      * @exception  IOException  If an I/O error occurs</span>
191      */
192     public void write(int c) throws IOException {
193         se.write(c);
194     }
195 
196     /**
197      * Writes a portion of an array of characters.
198      *
199      * @param  cbuf  Buffer of characters
200      * @param  off   Offset from which to start writing characters
201      * @param  len   Number of characters to write
202      *
203      * @throws  IndexOutOfBoundsException
204      *          If {@code off} is negative, or {@code len} is negative,
205      *          or {@code off + len} is negative or greater than the length
206      *          of the given array
207      *
208      * @throws  IOException  If an I/O error occurs
209      */
210     public void write(char cbuf[], int off, int len) throws IOException {
</pre>
<hr />
<pre>
231 
232     @Override
233     public Writer append(CharSequence csq, int start, int end) throws IOException {
234         if (csq == null) csq = &quot;null&quot;;
235         return append(csq.subSequence(start, end));
236     }
237 
238     @Override
239     public Writer append(CharSequence csq) throws IOException {
240         if (csq instanceof CharBuffer) {
241             se.write((CharBuffer) csq);
242         } else {
243             se.write(String.valueOf(csq));
244         }
245         return this;
246     }
247 
248     /**
249      * Flushes the stream.
250      *
<span class="line-modified">251      * @exception  IOException  If an I/O error occurs</span>
252      */
253     public void flush() throws IOException {
254         se.flush();
255     }
256 
257     public void close() throws IOException {
258         se.close();
259     }
260 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 70  * @see java.nio.charset.Charset
 71  *
 72  * @author      Mark Reinhold
 73  * @since       1.1
 74  */
 75 
 76 public class OutputStreamWriter extends Writer {
 77 
 78     private final StreamEncoder se;
 79 
 80     /**
 81      * Creates an OutputStreamWriter that uses the named charset.
 82      *
 83      * @param  out
 84      *         An OutputStream
 85      *
 86      * @param  charsetName
 87      *         The name of a supported
 88      *         {@link java.nio.charset.Charset charset}
 89      *
<span class="line-modified"> 90      * @throws     UnsupportedEncodingException</span>
 91      *             If the named encoding is not supported
 92      */
 93     public OutputStreamWriter(OutputStream out, String charsetName)
 94         throws UnsupportedEncodingException
 95     {
 96         super(out);
 97         if (charsetName == null)
 98             throw new NullPointerException(&quot;charsetName&quot;);
 99         se = StreamEncoder.forOutputStreamWriter(out, this, charsetName);
100     }
101 
102     /**
103      * Creates an OutputStreamWriter that uses the default character encoding.
104      *
105      * @param  out  An OutputStream
106      */
107     public OutputStreamWriter(OutputStream out) {
108         super(out);
<span class="line-modified">109         se = StreamEncoder.forOutputStreamWriter(out, this,</span>
<span class="line-modified">110                 Charset.defaultCharset());</span>



111     }
112 
113     /**
114      * Creates an OutputStreamWriter that uses the given charset.
115      *
116      * @param  out
117      *         An OutputStream
118      *
119      * @param  cs
120      *         A charset
121      *
122      * @since 1.4
123      * @spec JSR-51
124      */
125     public OutputStreamWriter(OutputStream out, Charset cs) {
126         super(out);
127         if (cs == null)
128             throw new NullPointerException(&quot;charset&quot;);
129         se = StreamEncoder.forOutputStreamWriter(out, this, cs);
130     }
</pre>
<hr />
<pre>
144     public OutputStreamWriter(OutputStream out, CharsetEncoder enc) {
145         super(out);
146         if (enc == null)
147             throw new NullPointerException(&quot;charset encoder&quot;);
148         se = StreamEncoder.forOutputStreamWriter(out, this, enc);
149     }
150 
151     /**
152      * Returns the name of the character encoding being used by this stream.
153      *
154      * &lt;p&gt; If the encoding has an historical name then that name is returned;
155      * otherwise the encoding&#39;s canonical name is returned.
156      *
157      * &lt;p&gt; If this instance was created with the {@link
158      * #OutputStreamWriter(OutputStream, String)} constructor then the returned
159      * name, being unique for the encoding, may differ from the name passed to
160      * the constructor.  This method may return {@code null} if the stream has
161      * been closed. &lt;/p&gt;
162      *
163      * @return The historical name of this encoding, or possibly
<span class="line-modified">164      *         {@code null} if the stream has been closed</span>
165      *
166      * @see java.nio.charset.Charset
167      *
168      * @revised 1.4
169      * @spec JSR-51
170      */
171     public String getEncoding() {
172         return se.getEncoding();
173     }
174 
175     /**
176      * Flushes the output buffer to the underlying byte stream, without flushing
177      * the byte stream itself.  This method is non-private only so that it may
178      * be invoked by PrintStream.
179      */
180     void flushBuffer() throws IOException {
181         se.flushBuffer();
182     }
183 
184     /**
185      * Writes a single character.
186      *
<span class="line-modified">187      * @throws     IOException  If an I/O error occurs</span>
188      */
189     public void write(int c) throws IOException {
190         se.write(c);
191     }
192 
193     /**
194      * Writes a portion of an array of characters.
195      *
196      * @param  cbuf  Buffer of characters
197      * @param  off   Offset from which to start writing characters
198      * @param  len   Number of characters to write
199      *
200      * @throws  IndexOutOfBoundsException
201      *          If {@code off} is negative, or {@code len} is negative,
202      *          or {@code off + len} is negative or greater than the length
203      *          of the given array
204      *
205      * @throws  IOException  If an I/O error occurs
206      */
207     public void write(char cbuf[], int off, int len) throws IOException {
</pre>
<hr />
<pre>
228 
229     @Override
230     public Writer append(CharSequence csq, int start, int end) throws IOException {
231         if (csq == null) csq = &quot;null&quot;;
232         return append(csq.subSequence(start, end));
233     }
234 
235     @Override
236     public Writer append(CharSequence csq) throws IOException {
237         if (csq instanceof CharBuffer) {
238             se.write((CharBuffer) csq);
239         } else {
240             se.write(String.valueOf(csq));
241         }
242         return this;
243     }
244 
245     /**
246      * Flushes the stream.
247      *
<span class="line-modified">248      * @throws     IOException  If an I/O error occurs</span>
249      */
250     public void flush() throws IOException {
251         se.flush();
252     }
253 
254     public void close() throws IOException {
255         se.close();
256     }
257 }
</pre>
</td>
</tr>
</table>
<center><a href="OutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PipedInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Random.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PropertyResourceBundle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="RegularEnumSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Random.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  56  * {@code protected} utility method that on each invocation can supply
  57  * up to 32 pseudorandomly generated bits.
  58  * &lt;p&gt;
  59  * Many applications will find the method {@link Math#random} simpler to use.
  60  *
  61  * &lt;p&gt;Instances of {@code java.util.Random} are threadsafe.
  62  * However, the concurrent use of the same {@code java.util.Random}
  63  * instance across threads may encounter contention and consequent
  64  * poor performance. Consider instead using
  65  * {@link java.util.concurrent.ThreadLocalRandom} in multithreaded
  66  * designs.
  67  *
  68  * &lt;p&gt;Instances of {@code java.util.Random} are not cryptographically
  69  * secure.  Consider instead using {@link java.security.SecureRandom} to
  70  * get a cryptographically secure pseudo-random number generator for use
  71  * by security-sensitive applications.
  72  *
  73  * @author  Frank Yellin
  74  * @since   1.0
  75  */
<span class="line-modified">  76 public</span>
<span class="line-removed">  77 class Random implements java.io.Serializable {</span>
  78     /** use serialVersionUID from JDK 1.1 for interoperability */

  79     static final long serialVersionUID = 3905348978240129619L;
  80 
  81     /**
  82      * The internal state associated with this pseudorandom number generator.
  83      * (The specs for the methods in this class describe the ongoing
  84      * computation of this value.)
  85      */
  86     private final AtomicLong seed;
  87 
  88     private static final long multiplier = 0x5DEECE66DL;
  89     private static final long addend = 0xBL;
  90     private static final long mask = (1L &lt;&lt; 48) - 1;
  91 
  92     private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53)
  93 
  94     // IllegalArgumentException messages
  95     static final String BadBound = &quot;bound must be positive&quot;;
  96     static final String BadRange = &quot;bound must be greater than origin&quot;;
  97     static final String BadSize  = &quot;size must be non-negative&quot;;
  98 
</pre>
<hr />
<pre>
1151                 index = f;
1152                 Random r = rng;
1153                 double o = origin, b = bound;
1154                 do {
1155                     consumer.accept(r.internalNextDouble(o, b));
1156                 } while (++i &lt; f);
1157             }
1158         }
1159     }
1160 
1161     /**
1162      * Serializable fields for Random.
1163      *
1164      * @serialField    seed long
1165      *              seed for random computations
1166      * @serialField    nextNextGaussian double
1167      *              next Gaussian to be returned
1168      * @serialField      haveNextNextGaussian boolean
1169      *              nextNextGaussian is valid
1170      */

1171     private static final ObjectStreamField[] serialPersistentFields = {
1172         new ObjectStreamField(&quot;seed&quot;, Long.TYPE),
1173         new ObjectStreamField(&quot;nextNextGaussian&quot;, Double.TYPE),
1174         new ObjectStreamField(&quot;haveNextNextGaussian&quot;, Boolean.TYPE)
1175     };
1176 
1177     /**
1178      * Reconstitute the {@code Random} instance from a stream (that is,
1179      * deserialize it).
1180      */

1181     private void readObject(java.io.ObjectInputStream s)
1182         throws java.io.IOException, ClassNotFoundException {
1183 
1184         ObjectInputStream.GetField fields = s.readFields();
1185 
1186         // The seed is read in as {@code long} for
1187         // historical reasons, but it is converted to an AtomicLong.
1188         long seedVal = fields.get(&quot;seed&quot;, -1L);
1189         if (seedVal &lt; 0)
1190           throw new java.io.StreamCorruptedException(
1191                               &quot;Random: invalid seed&quot;);
1192         resetSeed(seedVal);
1193         nextNextGaussian = fields.get(&quot;nextNextGaussian&quot;, 0.0);
1194         haveNextNextGaussian = fields.get(&quot;haveNextNextGaussian&quot;, false);
1195     }
1196 
1197     /**
1198      * Save the {@code Random} instance to a stream.
1199      */

1200     private synchronized void writeObject(ObjectOutputStream s)
1201         throws IOException {
1202 
1203         // set the values of the Serializable fields
1204         ObjectOutputStream.PutField fields = s.putFields();
1205 
1206         // The seed is serialized as a long for historical reasons.
1207         fields.put(&quot;seed&quot;, seed.get());
1208         fields.put(&quot;nextNextGaussian&quot;, nextNextGaussian);
1209         fields.put(&quot;haveNextNextGaussian&quot;, haveNextNextGaussian);
1210 
1211         // save them
1212         s.writeFields();
1213     }
1214 
1215     // Support for resetting seed while deserializing
1216     private static final Unsafe unsafe = Unsafe.getUnsafe();
1217     private static final long seedOffset;
1218     static {
1219         try {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  56  * {@code protected} utility method that on each invocation can supply
  57  * up to 32 pseudorandomly generated bits.
  58  * &lt;p&gt;
  59  * Many applications will find the method {@link Math#random} simpler to use.
  60  *
  61  * &lt;p&gt;Instances of {@code java.util.Random} are threadsafe.
  62  * However, the concurrent use of the same {@code java.util.Random}
  63  * instance across threads may encounter contention and consequent
  64  * poor performance. Consider instead using
  65  * {@link java.util.concurrent.ThreadLocalRandom} in multithreaded
  66  * designs.
  67  *
  68  * &lt;p&gt;Instances of {@code java.util.Random} are not cryptographically
  69  * secure.  Consider instead using {@link java.security.SecureRandom} to
  70  * get a cryptographically secure pseudo-random number generator for use
  71  * by security-sensitive applications.
  72  *
  73  * @author  Frank Yellin
  74  * @since   1.0
  75  */
<span class="line-modified">  76 public class Random implements java.io.Serializable {</span>

  77     /** use serialVersionUID from JDK 1.1 for interoperability */
<span class="line-added">  78     @java.io.Serial</span>
  79     static final long serialVersionUID = 3905348978240129619L;
  80 
  81     /**
  82      * The internal state associated with this pseudorandom number generator.
  83      * (The specs for the methods in this class describe the ongoing
  84      * computation of this value.)
  85      */
  86     private final AtomicLong seed;
  87 
  88     private static final long multiplier = 0x5DEECE66DL;
  89     private static final long addend = 0xBL;
  90     private static final long mask = (1L &lt;&lt; 48) - 1;
  91 
  92     private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53)
  93 
  94     // IllegalArgumentException messages
  95     static final String BadBound = &quot;bound must be positive&quot;;
  96     static final String BadRange = &quot;bound must be greater than origin&quot;;
  97     static final String BadSize  = &quot;size must be non-negative&quot;;
  98 
</pre>
<hr />
<pre>
1151                 index = f;
1152                 Random r = rng;
1153                 double o = origin, b = bound;
1154                 do {
1155                     consumer.accept(r.internalNextDouble(o, b));
1156                 } while (++i &lt; f);
1157             }
1158         }
1159     }
1160 
1161     /**
1162      * Serializable fields for Random.
1163      *
1164      * @serialField    seed long
1165      *              seed for random computations
1166      * @serialField    nextNextGaussian double
1167      *              next Gaussian to be returned
1168      * @serialField      haveNextNextGaussian boolean
1169      *              nextNextGaussian is valid
1170      */
<span class="line-added">1171     @java.io.Serial</span>
1172     private static final ObjectStreamField[] serialPersistentFields = {
1173         new ObjectStreamField(&quot;seed&quot;, Long.TYPE),
1174         new ObjectStreamField(&quot;nextNextGaussian&quot;, Double.TYPE),
1175         new ObjectStreamField(&quot;haveNextNextGaussian&quot;, Boolean.TYPE)
1176     };
1177 
1178     /**
1179      * Reconstitute the {@code Random} instance from a stream (that is,
1180      * deserialize it).
1181      */
<span class="line-added">1182     @java.io.Serial</span>
1183     private void readObject(java.io.ObjectInputStream s)
1184         throws java.io.IOException, ClassNotFoundException {
1185 
1186         ObjectInputStream.GetField fields = s.readFields();
1187 
1188         // The seed is read in as {@code long} for
1189         // historical reasons, but it is converted to an AtomicLong.
1190         long seedVal = fields.get(&quot;seed&quot;, -1L);
1191         if (seedVal &lt; 0)
1192           throw new java.io.StreamCorruptedException(
1193                               &quot;Random: invalid seed&quot;);
1194         resetSeed(seedVal);
1195         nextNextGaussian = fields.get(&quot;nextNextGaussian&quot;, 0.0);
1196         haveNextNextGaussian = fields.get(&quot;haveNextNextGaussian&quot;, false);
1197     }
1198 
1199     /**
1200      * Save the {@code Random} instance to a stream.
1201      */
<span class="line-added">1202     @java.io.Serial</span>
1203     private synchronized void writeObject(ObjectOutputStream s)
1204         throws IOException {
1205 
1206         // set the values of the Serializable fields
1207         ObjectOutputStream.PutField fields = s.putFields();
1208 
1209         // The seed is serialized as a long for historical reasons.
1210         fields.put(&quot;seed&quot;, seed.get());
1211         fields.put(&quot;nextNextGaussian&quot;, nextNextGaussian);
1212         fields.put(&quot;haveNextNextGaussian&quot;, haveNextNextGaussian);
1213 
1214         // save them
1215         s.writeFields();
1216     }
1217 
1218     // Support for resetting seed while deserializing
1219     private static final Unsafe unsafe = Unsafe.getUnsafe();
1220     private static final long seedOffset;
1221     static {
1222         try {
</pre>
</td>
</tr>
</table>
<center><a href="PropertyResourceBundle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="RegularEnumSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
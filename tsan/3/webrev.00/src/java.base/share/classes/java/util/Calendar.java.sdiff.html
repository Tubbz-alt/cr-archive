<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Calendar.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="BitSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Collection.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Calendar.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  45 import java.io.Serializable;
  46 import java.security.AccessControlContext;
  47 import java.security.AccessController;
  48 import java.security.PermissionCollection;
  49 import java.security.PrivilegedActionException;
  50 import java.security.PrivilegedExceptionAction;
  51 import java.security.ProtectionDomain;
  52 import java.text.DateFormat;
  53 import java.text.DateFormatSymbols;
  54 import java.time.Instant;
  55 import java.util.concurrent.ConcurrentHashMap;
  56 import java.util.concurrent.ConcurrentMap;
  57 import sun.util.BuddhistCalendar;
  58 import sun.util.calendar.ZoneInfo;
  59 import sun.util.locale.provider.CalendarDataUtility;
  60 import sun.util.locale.provider.LocaleProviderAdapter;
  61 import sun.util.locale.provider.TimeZoneNameUtility;
  62 import sun.util.spi.CalendarProvider;
  63 
  64 /**
<span class="line-modified">  65  * The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods</span>
  66  * for converting between a specific instant in time and a set of {@link
<span class="line-modified">  67  * #fields calendar fields} such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,</span>
<span class="line-modified">  68  * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for</span>
  69  * manipulating the calendar fields, such as getting the date of the next
  70  * week. An instant in time can be represented by a millisecond value that is
  71  * an offset from the &lt;a id=&quot;Epoch&quot;&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970
  72  * 00:00:00.000 GMT (Gregorian).
  73  *
  74  * &lt;p&gt;The class also provides additional fields and methods for
  75  * implementing a concrete calendar system outside the package. Those
<span class="line-modified">  76  * fields and methods are defined as &lt;code&gt;protected&lt;/code&gt;.</span>
  77  *
  78  * &lt;p&gt;
<span class="line-modified">  79  * Like other locale-sensitive classes, &lt;code&gt;Calendar&lt;/code&gt; provides a</span>
<span class="line-modified">  80  * class method, &lt;code&gt;getInstance&lt;/code&gt;, for getting a generally useful</span>
<span class="line-modified">  81  * object of this type. &lt;code&gt;Calendar&lt;/code&gt;&#39;s &lt;code&gt;getInstance&lt;/code&gt; method</span>
<span class="line-modified">  82  * returns a &lt;code&gt;Calendar&lt;/code&gt; object whose</span>
  83  * calendar fields have been initialized with the current date and time:
  84  * &lt;blockquote&gt;
  85  * &lt;pre&gt;
  86  *     Calendar rightNow = Calendar.getInstance();
  87  * &lt;/pre&gt;
  88  * &lt;/blockquote&gt;
  89  *
<span class="line-modified">  90  * &lt;p&gt;A &lt;code&gt;Calendar&lt;/code&gt; object can produce all the calendar field values</span>
  91  * needed to implement the date-time formatting for a particular language and
  92  * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
<span class="line-modified">  93  * &lt;code&gt;Calendar&lt;/code&gt; defines the range of values returned by</span>
  94  * certain calendar fields, as well as their meaning.  For example,
  95  * the first month of the calendar system has value &lt;code&gt;MONTH ==
  96  * JANUARY&lt;/code&gt; for all calendars.  Other values are defined by the
<span class="line-modified">  97  * concrete subclass, such as &lt;code&gt;ERA&lt;/code&gt;.  See individual field</span>
  98  * documentation and subclass documentation for details.
  99  *
<span class="line-modified"> 100  * &lt;h3&gt;Getting and Setting Calendar Field Values&lt;/h3&gt;</span>
 101  *
<span class="line-modified"> 102  * &lt;p&gt;The calendar field values can be set by calling the &lt;code&gt;set&lt;/code&gt;</span>
<span class="line-modified"> 103  * methods. Any field values set in a &lt;code&gt;Calendar&lt;/code&gt; will not be</span>
 104  * interpreted until it needs to calculate its time value (milliseconds from
 105  * the Epoch) or values of the calendar fields. Calling the
<span class="line-modified"> 106  * &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;getTimeInMillis&lt;/code&gt;, &lt;code&gt;getTime&lt;/code&gt;,</span>
<span class="line-modified"> 107  * &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;roll&lt;/code&gt; involves such calculation.</span>
 108  *
<span class="line-modified"> 109  * &lt;h4&gt;Leniency&lt;/h4&gt;</span>
 110  *
<span class="line-modified"> 111  * &lt;p&gt;&lt;code&gt;Calendar&lt;/code&gt; has two modes for interpreting the calendar</span>
 112  * fields, &lt;em&gt;lenient&lt;/em&gt; and &lt;em&gt;non-lenient&lt;/em&gt;.  When a
<span class="line-modified"> 113  * &lt;code&gt;Calendar&lt;/code&gt; is in lenient mode, it accepts a wider range of</span>
<span class="line-modified"> 114  * calendar field values than it produces.  When a &lt;code&gt;Calendar&lt;/code&gt;</span>
<span class="line-modified"> 115  * recomputes calendar field values for return by &lt;code&gt;get()&lt;/code&gt;, all of</span>
 116  * the calendar fields are normalized. For example, a lenient
<span class="line-modified"> 117  * &lt;code&gt;GregorianCalendar&lt;/code&gt; interprets &lt;code&gt;MONTH == JANUARY&lt;/code&gt;,</span>
<span class="line-modified"> 118  * &lt;code&gt;DAY_OF_MONTH == 32&lt;/code&gt; as February 1.</span>
 119 
<span class="line-modified"> 120  * &lt;p&gt;When a &lt;code&gt;Calendar&lt;/code&gt; is in non-lenient mode, it throws an</span>
 121  * exception if there is any inconsistency in its calendar fields. For
<span class="line-modified"> 122  * example, a &lt;code&gt;GregorianCalendar&lt;/code&gt; always produces</span>
<span class="line-modified"> 123  * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; values between 1 and the length of the month. A</span>
<span class="line-modified"> 124  * non-lenient &lt;code&gt;GregorianCalendar&lt;/code&gt; throws an exception upon</span>
 125  * calculating its time or calendar field values if any out-of-range field
 126  * value has been set.
 127  *
<span class="line-modified"> 128  * &lt;h4&gt;&lt;a id=&quot;first_week&quot;&gt;First Week&lt;/a&gt;&lt;/h4&gt;</span>
 129  *
<span class="line-modified"> 130  * &lt;code&gt;Calendar&lt;/code&gt; defines a locale-specific seven day week using two</span>
 131  * parameters: the first day of the week and the minimal days in first week
 132  * (from 1 to 7).  These numbers are taken from the locale resource data or the
 133  * locale itself when a {@code Calendar} is constructed. If the designated
 134  * locale contains &quot;fw&quot; and/or &quot;rg&quot; &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;
 135  * Unicode extensions&lt;/a&gt;, the first day of the week will be obtained according to
 136  * those extensions. If both &quot;fw&quot; and &quot;rg&quot; are specified, the value from the &quot;fw&quot;
 137  * extension supersedes the implicit one from the &quot;rg&quot; extension.
 138  * They may also be specified explicitly through the methods for setting their
 139  * values.
 140  *
<span class="line-modified"> 141  * &lt;p&gt;When setting or getting the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; or</span>
<span class="line-modified"> 142  * &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; fields, &lt;code&gt;Calendar&lt;/code&gt; must determine the</span>
 143  * first week of the month or year as a reference point.  The first week of a
 144  * month or year is defined as the earliest seven day period beginning on
<span class="line-modified"> 145  * &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and containing at least</span>
<span class="line-modified"> 146  * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; days of that month or year.  Weeks</span>
 147  * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
<span class="line-modified"> 148  * it.  Note that the normalized numbering returned by &lt;code&gt;get()&lt;/code&gt; may be</span>
<span class="line-modified"> 149  * different.  For example, a specific &lt;code&gt;Calendar&lt;/code&gt; subclass may</span>
 150  * designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of
 151  * the previous year.
 152  *
<span class="line-modified"> 153  * &lt;h4&gt;Calendar Fields Resolution&lt;/h4&gt;</span>
 154  *
 155  * When computing a date and time from the calendar fields, there
 156  * may be insufficient information for the computation (such as only
 157  * year and month with no day of month), or there may be inconsistent
 158  * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,
<span class="line-modified"> 159  * 1996 is actually a Monday). &lt;code&gt;Calendar&lt;/code&gt; will resolve</span>
 160  * calendar field values to determine the date and time in the
 161  * following way.
 162  *
 163  * &lt;p&gt;&lt;a id=&quot;resolution&quot;&gt;If there is any conflict in calendar field values,
<span class="line-modified"> 164  * &lt;code&gt;Calendar&lt;/code&gt; gives priorities to calendar fields that have been set</span>
 165  * more recently.&lt;/a&gt; The following are the default combinations of the
 166  * calendar fields. The most recent combination, as determined by the
 167  * most recently set single field, will be used.
 168  *
 169  * &lt;p&gt;&lt;a id=&quot;date_resolution&quot;&gt;For the date fields&lt;/a&gt;:
 170  * &lt;blockquote&gt;
 171  * &lt;pre&gt;
 172  * YEAR + MONTH + DAY_OF_MONTH
 173  * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
 174  * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
 175  * YEAR + DAY_OF_YEAR
 176  * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
 177  * &lt;/pre&gt;&lt;/blockquote&gt;
 178  *
 179  * &lt;a id=&quot;time_resolution&quot;&gt;For the time of day fields&lt;/a&gt;:
 180  * &lt;blockquote&gt;
 181  * &lt;pre&gt;
 182  * HOUR_OF_DAY
 183  * AM_PM + HOUR
 184  * &lt;/pre&gt;&lt;/blockquote&gt;
 185  *
 186  * &lt;p&gt;If there are any calendar fields whose values haven&#39;t been set in the selected
<span class="line-modified"> 187  * field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default</span>
 188  * value of each field may vary by concrete calendar systems. For example, in
<span class="line-modified"> 189  * &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that</span>
<span class="line-modified"> 190  * of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =</span>
<span class="line-modified"> 191  * JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.</span>
 192  *
 193  * &lt;p&gt;
 194  * &lt;strong&gt;Note:&lt;/strong&gt; There are certain possible ambiguities in
 195  * interpretation of certain singular times, which are resolved in the
 196  * following ways:
 197  * &lt;ol&gt;
 198  *     &lt;li&gt; 23:59 is the last minute of the day and 00:00 is the first
 199  *          minute of the next day. Thus, 23:59 on Dec 31, 1999 &amp;lt; 00:00 on
 200  *          Jan 1, 2000 &amp;lt; 00:01 on Jan 1, 2000.
 201  *
 202  *     &lt;li&gt; Although historically not precise, midnight also belongs to &quot;am&quot;,
 203  *          and noon belongs to &quot;pm&quot;, so on the same day,
 204  *          12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm
 205  * &lt;/ol&gt;
 206  *
 207  * &lt;p&gt;
 208  * The date or time format strings are not part of the definition of a
 209  * calendar, as those must be modifiable or overridable by the user at
 210  * runtime. Use {@link DateFormat}
 211  * to format dates.
 212  *
<span class="line-modified"> 213  * &lt;h4&gt;Field Manipulation&lt;/h4&gt;</span>
 214  *
 215  * The calendar fields can be changed using three methods:
<span class="line-modified"> 216  * &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt;, and &lt;code&gt;roll()&lt;/code&gt;.</span>
 217  *
<span class="line-modified"> 218  * &lt;p&gt;&lt;strong&gt;&lt;code&gt;set(f, value)&lt;/code&gt;&lt;/strong&gt; changes calendar field</span>
<span class="line-modified"> 219  * &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.  In addition, it sets an</span>
<span class="line-modified"> 220  * internal member variable to indicate that calendar field &lt;code&gt;f&lt;/code&gt; has</span>
<span class="line-modified"> 221  * been changed. Although calendar field &lt;code&gt;f&lt;/code&gt; is changed immediately,</span>
 222  * the calendar&#39;s time value in milliseconds is not recomputed until the next call to
<span class="line-modified"> 223  * &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;getTime()&lt;/code&gt;, &lt;code&gt;getTimeInMillis()&lt;/code&gt;,</span>
<span class="line-modified"> 224  * &lt;code&gt;add()&lt;/code&gt;, or &lt;code&gt;roll()&lt;/code&gt; is made. Thus, multiple calls to</span>
<span class="line-modified"> 225  * &lt;code&gt;set()&lt;/code&gt; do not trigger multiple, unnecessary</span>
 226  * computations. As a result of changing a calendar field using
<span class="line-modified"> 227  * &lt;code&gt;set()&lt;/code&gt;, other calendar fields may also change, depending on the</span>
 228  * calendar field, the calendar field value, and the calendar system. In addition,
<span class="line-modified"> 229  * &lt;code&gt;get(f)&lt;/code&gt; will not necessarily return &lt;code&gt;value&lt;/code&gt; set by</span>
<span class="line-modified"> 230  * the call to the &lt;code&gt;set&lt;/code&gt; method</span>
 231  * after the calendar fields have been recomputed. The specifics are determined by
 232  * the concrete calendar class.&lt;/p&gt;
 233  *
<span class="line-modified"> 234  * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
 235  * originally set to August 31, 1999. Calling &lt;code&gt;set(Calendar.MONTH,
 236  * Calendar.SEPTEMBER)&lt;/code&gt; sets the date to September 31,
 237  * 1999. This is a temporary internal representation that resolves to
<span class="line-modified"> 238  * October 1, 1999 if &lt;code&gt;getTime()&lt;/code&gt;is then called. However, a</span>
<span class="line-modified"> 239  * call to &lt;code&gt;set(Calendar.DAY_OF_MONTH, 30)&lt;/code&gt; before the call to</span>
<span class="line-modified"> 240  * &lt;code&gt;getTime()&lt;/code&gt; sets the date to September 30, 1999, since</span>
<span class="line-modified"> 241  * no recomputation occurs after &lt;code&gt;set()&lt;/code&gt; itself.&lt;/p&gt;</span>
 242  *
<span class="line-modified"> 243  * &lt;p&gt;&lt;strong&gt;&lt;code&gt;add(f, delta)&lt;/code&gt;&lt;/strong&gt; adds &lt;code&gt;delta&lt;/code&gt;</span>
<span class="line-modified"> 244  * to field &lt;code&gt;f&lt;/code&gt;.  This is equivalent to calling &lt;code&gt;set(f,</span>
 245  * get(f) + delta)&lt;/code&gt; with two adjustments:&lt;/p&gt;
 246  *
 247  * &lt;blockquote&gt;
<span class="line-modified"> 248  *   &lt;p&gt;&lt;strong&gt;Add rule 1&lt;/strong&gt;. The value of field &lt;code&gt;f&lt;/code&gt;</span>
<span class="line-modified"> 249  *   after the call minus the value of field &lt;code&gt;f&lt;/code&gt; before the</span>
<span class="line-modified"> 250  *   call is &lt;code&gt;delta&lt;/code&gt;, modulo any overflow that has occurred in</span>
<span class="line-modified"> 251  *   field &lt;code&gt;f&lt;/code&gt;. Overflow occurs when a field value exceeds its</span>
 252  *   range and, as a result, the next larger field is incremented or
 253  *   decremented and the field value is adjusted back into its range.&lt;/p&gt;
 254  *
 255  *   &lt;p&gt;&lt;strong&gt;Add rule 2&lt;/strong&gt;. If a smaller field is expected to be
 256  *   invariant, but it is impossible for it to be equal to its
 257  *   prior value because of changes in its minimum or maximum after field
<span class="line-modified"> 258  *   &lt;code&gt;f&lt;/code&gt; is changed or other constraints, such as time zone</span>
 259  *   offset changes, then its value is adjusted to be as close
 260  *   as possible to its expected value. A smaller field represents a
<span class="line-modified"> 261  *   smaller unit of time. &lt;code&gt;HOUR&lt;/code&gt; is a smaller field than</span>
<span class="line-modified"> 262  *   &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;. No adjustment is made to smaller fields</span>
 263  *   that are not expected to be invariant. The calendar system
 264  *   determines what fields are expected to be invariant.&lt;/p&gt;
 265  * &lt;/blockquote&gt;
 266  *
<span class="line-modified"> 267  * &lt;p&gt;In addition, unlike &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt; forces</span>
 268  * an immediate recomputation of the calendar&#39;s milliseconds and all
 269  * fields.&lt;/p&gt;
 270  *
<span class="line-modified"> 271  * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
 272  * originally set to August 31, 1999. Calling &lt;code&gt;add(Calendar.MONTH,
 273  * 13)&lt;/code&gt; sets the calendar to September 30, 2000. &lt;strong&gt;Add rule
<span class="line-modified"> 274  * 1&lt;/strong&gt; sets the &lt;code&gt;MONTH&lt;/code&gt; field to September, since</span>
 275  * adding 13 months to August gives September of the next year. Since
<span class="line-modified"> 276  * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; cannot be 31 in September in a</span>
<span class="line-modified"> 277  * &lt;code&gt;GregorianCalendar&lt;/code&gt;, &lt;strong&gt;add rule 2&lt;/strong&gt; sets the</span>
<span class="line-modified"> 278  * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; to 30, the closest possible value. Although</span>
<span class="line-modified"> 279  * it is a smaller field, &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; is not adjusted by</span>
 280  * rule 2, since it is expected to change when the month changes in a
<span class="line-modified"> 281  * &lt;code&gt;GregorianCalendar&lt;/code&gt;.&lt;/p&gt;</span>
 282  *
<span class="line-modified"> 283  * &lt;p&gt;&lt;strong&gt;&lt;code&gt;roll(f, delta)&lt;/code&gt;&lt;/strong&gt; adds</span>
<span class="line-modified"> 284  * &lt;code&gt;delta&lt;/code&gt; to field &lt;code&gt;f&lt;/code&gt; without changing larger</span>
<span class="line-modified"> 285  * fields. This is equivalent to calling &lt;code&gt;add(f, delta)&lt;/code&gt; with</span>
 286  * the following adjustment:&lt;/p&gt;
 287  *
 288  * &lt;blockquote&gt;
 289  *   &lt;p&gt;&lt;strong&gt;Roll rule&lt;/strong&gt;. Larger fields are unchanged after the
 290  *   call. A larger field represents a larger unit of
<span class="line-modified"> 291  *   time. &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; is a larger field than</span>
<span class="line-modified"> 292  *   &lt;code&gt;HOUR&lt;/code&gt;.&lt;/p&gt;</span>
 293  * &lt;/blockquote&gt;
 294  *
 295  * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: See {@link java.util.GregorianCalendar#roll(int, int)}.
 296  *
 297  * &lt;p&gt;&lt;strong&gt;Usage model&lt;/strong&gt;. To motivate the behavior of
<span class="line-modified"> 298  * &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;roll()&lt;/code&gt;, consider a user interface</span>
 299  * component with increment and decrement buttons for the month, day, and
<span class="line-modified"> 300  * year, and an underlying &lt;code&gt;GregorianCalendar&lt;/code&gt;. If the</span>
 301  * interface reads January 31, 1999 and the user presses the month
 302  * increment button, what should it read? If the underlying
<span class="line-modified"> 303  * implementation uses &lt;code&gt;set()&lt;/code&gt;, it might read March 3, 1999. A</span>
 304  * better result would be February 28, 1999. Furthermore, if the user
 305  * presses the month increment button again, it should read March 31,
 306  * 1999, not March 28, 1999. By saving the original date and using either
<span class="line-modified"> 307  * &lt;code&gt;add()&lt;/code&gt; or &lt;code&gt;roll()&lt;/code&gt;, depending on whether larger</span>
 308  * fields should be affected, the user interface can behave as most users
 309  * will intuitively expect.&lt;/p&gt;
 310  *
 311  * @see          java.lang.System#currentTimeMillis()
 312  * @see          Date
 313  * @see          GregorianCalendar
 314  * @see          TimeZone
 315  * @see          java.text.DateFormat
 316  * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
 317  * @since 1.1
 318  */
 319 public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {
 320 
 321     // Data flow in Calendar
 322     // ---------------------
 323 
 324     // The current time is represented in two ways by Calendar: as UTC
 325     // milliseconds from the epoch (1 January 1970 0:00 UTC), and as local
 326     // fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the
 327     // millis from the fields, and vice versa.  The data needed to do this
</pre>
<hr />
<pre>
 352     // subclass&#39;s computeFields() method.
 353 
 354     //   UTC millis (in time data member)
 355     //           |
 356     //           | Using TimeZone getOffset()
 357     //           V
 358     //   local standard millis
 359     //           |
 360     //           | Using Calendar-specific algorithm
 361     //           V
 362     //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
 363 
 364     // In general, a round trip from fields, through local and UTC millis, and
 365     // back out to fields is made when necessary.  This is implemented by the
 366     // complete() method.  Resolving a partial set of fields into a UTC millis
 367     // value allows all remaining fields to be generated from that value.  If
 368     // the Calendar is lenient, the fields are also renormalized to standard
 369     // ranges when they are regenerated.
 370 
 371     /**
<span class="line-modified"> 372      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 373      * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
 374      * value; see subclass documentation.
 375      *
 376      * @see GregorianCalendar#AD
 377      * @see GregorianCalendar#BC
 378      */
 379     public static final int ERA = 0;
 380 
 381     /**
<span class="line-modified"> 382      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 383      * year. This is a calendar-specific value; see subclass documentation.
 384      */
 385     public static final int YEAR = 1;
 386 
 387     /**
<span class="line-modified"> 388      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 389      * month. This is a calendar-specific value. The first month of
 390      * the year in the Gregorian and Julian calendars is
<span class="line-modified"> 391      * &lt;code&gt;JANUARY&lt;/code&gt; which is 0; the last depends on the number</span>
 392      * of months in a year.
 393      *
 394      * @see #JANUARY
 395      * @see #FEBRUARY
 396      * @see #MARCH
 397      * @see #APRIL
 398      * @see #MAY
 399      * @see #JUNE
 400      * @see #JULY
 401      * @see #AUGUST
 402      * @see #SEPTEMBER
 403      * @see #OCTOBER
 404      * @see #NOVEMBER
 405      * @see #DECEMBER
 406      * @see #UNDECIMBER
 407      */
 408     public static final int MONTH = 2;
 409 
 410     /**
<span class="line-modified"> 411      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 412      * week number within the current year.  The first week of the year, as
<span class="line-modified"> 413      * defined by &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and</span>
<span class="line-modified"> 414      * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;, has value 1.  Subclasses define</span>
<span class="line-modified"> 415      * the value of &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; for days before the first week of</span>
 416      * the year.
 417      *
 418      * @see #getFirstDayOfWeek
 419      * @see #getMinimalDaysInFirstWeek
 420      */
 421     public static final int WEEK_OF_YEAR = 3;
 422 
 423     /**
<span class="line-modified"> 424      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 425      * week number within the current month.  The first week of the month, as
<span class="line-modified"> 426      * defined by &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and</span>
<span class="line-modified"> 427      * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;, has value 1.  Subclasses define</span>
<span class="line-modified"> 428      * the value of &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; for days before the first week of</span>
 429      * the month.
 430      *
 431      * @see #getFirstDayOfWeek
 432      * @see #getMinimalDaysInFirstWeek
 433      */
 434     public static final int WEEK_OF_MONTH = 4;
 435 
 436     /**
<span class="line-modified"> 437      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
<span class="line-modified"> 438      * day of the month. This is a synonym for &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.</span>
 439      * The first day of the month has value 1.
 440      *
 441      * @see #DAY_OF_MONTH
 442      */
 443     public static final int DATE = 5;
 444 
 445     /**
<span class="line-modified"> 446      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
<span class="line-modified"> 447      * day of the month. This is a synonym for &lt;code&gt;DATE&lt;/code&gt;.</span>
 448      * The first day of the month has value 1.
 449      *
 450      * @see #DATE
 451      */
 452     public static final int DAY_OF_MONTH = 5;
 453 
 454     /**
<span class="line-modified"> 455      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day</span>
 456      * number within the current year.  The first day of the year has value 1.
 457      */
 458     public static final int DAY_OF_YEAR = 6;
 459 
 460     /**
<span class="line-modified"> 461      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day</span>
<span class="line-modified"> 462      * of the week.  This field takes values &lt;code&gt;SUNDAY&lt;/code&gt;,</span>
<span class="line-modified"> 463      * &lt;code&gt;MONDAY&lt;/code&gt;, &lt;code&gt;TUESDAY&lt;/code&gt;, &lt;code&gt;WEDNESDAY&lt;/code&gt;,</span>
<span class="line-modified"> 464      * &lt;code&gt;THURSDAY&lt;/code&gt;, &lt;code&gt;FRIDAY&lt;/code&gt;, and &lt;code&gt;SATURDAY&lt;/code&gt;.</span>
 465      *
 466      * @see #SUNDAY
 467      * @see #MONDAY
 468      * @see #TUESDAY
 469      * @see #WEDNESDAY
 470      * @see #THURSDAY
 471      * @see #FRIDAY
 472      * @see #SATURDAY
 473      */
 474     public static final int DAY_OF_WEEK = 7;
 475 
 476     /**
<span class="line-modified"> 477      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 478      * ordinal number of the day of the week within the current month. Together
<span class="line-modified"> 479      * with the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; field, this uniquely specifies a day</span>
<span class="line-modified"> 480      * within a month.  Unlike &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; and</span>
<span class="line-modified"> 481      * &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt;, this field&#39;s value does &lt;em&gt;not&lt;/em&gt; depend on</span>
<span class="line-modified"> 482      * &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; or</span>
<span class="line-modified"> 483      * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;.  &lt;code&gt;DAY_OF_MONTH 1&lt;/code&gt;</span>
<span class="line-modified"> 484      * through &lt;code&gt;7&lt;/code&gt; always correspond to &lt;code&gt;DAY_OF_WEEK_IN_MONTH</span>
<span class="line-modified"> 485      * 1&lt;/code&gt;; &lt;code&gt;8&lt;/code&gt; through &lt;code&gt;14&lt;/code&gt; correspond to</span>
<span class="line-modified"> 486      * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 2&lt;/code&gt;, and so on.</span>
<span class="line-modified"> 487      * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 0&lt;/code&gt; indicates the week before</span>
<span class="line-modified"> 488      * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 1&lt;/code&gt;.  Negative values count back from the</span>
 489      * end of the month, so the last Sunday of a month is specified as
<span class="line-modified"> 490      * &lt;code&gt;DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1&lt;/code&gt;.  Because</span>
 491      * negative values count backward they will usually be aligned differently
 492      * within the month than positive values.  For example, if a month has 31
<span class="line-modified"> 493      * days, &lt;code&gt;DAY_OF_WEEK_IN_MONTH -1&lt;/code&gt; will overlap</span>
<span class="line-modified"> 494      * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 5&lt;/code&gt; and the end of &lt;code&gt;4&lt;/code&gt;.</span>
 495      *
 496      * @see #DAY_OF_WEEK
 497      * @see #WEEK_OF_MONTH
 498      */
 499     public static final int DAY_OF_WEEK_IN_MONTH = 8;
 500 
 501     /**
<span class="line-modified"> 502      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating</span>
<span class="line-modified"> 503      * whether the &lt;code&gt;HOUR&lt;/code&gt; is before or after noon.</span>
<span class="line-modified"> 504      * E.g., at 10:04:15.250 PM the &lt;code&gt;AM_PM&lt;/code&gt; is &lt;code&gt;PM&lt;/code&gt;.</span>
 505      *
 506      * @see #AM
 507      * @see #PM
 508      * @see #HOUR
 509      */
 510     public static final int AM_PM = 9;
 511 
 512     /**
<span class="line-modified"> 513      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
<span class="line-modified"> 514      * hour of the morning or afternoon. &lt;code&gt;HOUR&lt;/code&gt; is used for the</span>
 515      * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.
<span class="line-modified"> 516      * E.g., at 10:04:15.250 PM the &lt;code&gt;HOUR&lt;/code&gt; is 10.</span>
 517      *
 518      * @see #AM_PM
 519      * @see #HOUR_OF_DAY
 520      */
 521     public static final int HOUR = 10;
 522 
 523     /**
<span class="line-modified"> 524      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
<span class="line-modified"> 525      * hour of the day. &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; is used for the 24-hour clock.</span>
<span class="line-modified"> 526      * E.g., at 10:04:15.250 PM the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; is 22.</span>
 527      *
 528      * @see #HOUR
 529      */
 530     public static final int HOUR_OF_DAY = 11;
 531 
 532     /**
<span class="line-modified"> 533      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 534      * minute within the hour.
<span class="line-modified"> 535      * E.g., at 10:04:15.250 PM the &lt;code&gt;MINUTE&lt;/code&gt; is 4.</span>
 536      */
 537     public static final int MINUTE = 12;
 538 
 539     /**
<span class="line-modified"> 540      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 541      * second within the minute.
<span class="line-modified"> 542      * E.g., at 10:04:15.250 PM the &lt;code&gt;SECOND&lt;/code&gt; is 15.</span>
 543      */
 544     public static final int SECOND = 13;
 545 
 546     /**
<span class="line-modified"> 547      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 548      * millisecond within the second.
<span class="line-modified"> 549      * E.g., at 10:04:15.250 PM the &lt;code&gt;MILLISECOND&lt;/code&gt; is 250.</span>
 550      */
 551     public static final int MILLISECOND = 14;
 552 
 553     /**
<span class="line-modified"> 554      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;</span>
 555      * indicating the raw offset from GMT in milliseconds.
 556      * &lt;p&gt;
 557      * This field reflects the correct GMT offset value of the time
<span class="line-modified"> 558      * zone of this &lt;code&gt;Calendar&lt;/code&gt; if the</span>
<span class="line-modified"> 559      * &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports</span>
 560      * historical GMT offset changes.
 561      */
 562     public static final int ZONE_OFFSET = 15;
 563 
 564     /**
<span class="line-modified"> 565      * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the</span>
 566      * daylight saving offset in milliseconds.
 567      * &lt;p&gt;
 568      * This field reflects the correct daylight saving offset value of
<span class="line-modified"> 569      * the time zone of this &lt;code&gt;Calendar&lt;/code&gt; if the</span>
<span class="line-modified"> 570      * &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports</span>
 571      * historical Daylight Saving Time schedule changes.
 572      */
 573     public static final int DST_OFFSET = 16;
 574 
 575     /**
<span class="line-modified"> 576      * The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.</span>
<span class="line-modified"> 577      * Field numbers range from &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt;.</span>
 578      */
 579     public static final int FIELD_COUNT = 17;
 580 
 581     /**
 582      * Value of the {@link #DAY_OF_WEEK} field indicating
 583      * Sunday.
 584      */
 585     public static final int SUNDAY = 1;
 586 
 587     /**
 588      * Value of the {@link #DAY_OF_WEEK} field indicating
 589      * Monday.
 590      */
 591     public static final int MONDAY = 2;
 592 
 593     /**
 594      * Value of the {@link #DAY_OF_WEEK} field indicating
 595      * Tuesday.
 596      */
 597     public static final int TUESDAY = 3;
</pre>
<hr />
<pre>
 677     /**
 678      * Value of the {@link #MONTH} field indicating the
 679      * tenth month of the year in the Gregorian and Julian calendars.
 680      */
 681     public static final int OCTOBER = 9;
 682 
 683     /**
 684      * Value of the {@link #MONTH} field indicating the
 685      * eleventh month of the year in the Gregorian and Julian calendars.
 686      */
 687     public static final int NOVEMBER = 10;
 688 
 689     /**
 690      * Value of the {@link #MONTH} field indicating the
 691      * twelfth month of the year in the Gregorian and Julian calendars.
 692      */
 693     public static final int DECEMBER = 11;
 694 
 695     /**
 696      * Value of the {@link #MONTH} field indicating the
<span class="line-modified"> 697      * thirteenth month of the year. Although &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
 698      * does not use this value, lunar calendars do.
 699      */
 700     public static final int UNDECIMBER = 12;
 701 
 702     /**
 703      * Value of the {@link #AM_PM} field indicating the
 704      * period of the day from midnight to just before noon.
 705      */
 706     public static final int AM = 0;
 707 
 708     /**
 709      * Value of the {@link #AM_PM} field indicating the
 710      * period of the day from noon to just before midnight.
 711      */
 712     public static final int PM = 1;
 713 
 714     /**
 715      * A style specifier for {@link #getDisplayNames(int, int, Locale)
 716      * getDisplayNames} indicating names in all styles, such as
 717      * &quot;January&quot; and &quot;Jan&quot;.
</pre>
<hr />
<pre>
 822      * @see #LONG_FORMAT
 823      * @see #SHORT_FORMAT
 824      * @see #SHORT_STANDALONE
 825      * @since 1.8
 826      */
 827     public static final int LONG_STANDALONE = LONG | STANDALONE_MASK;
 828 
 829     // Internal notes:
 830     // Calendar contains two kinds of time representations: current &quot;time&quot; in
 831     // milliseconds, and a set of calendar &quot;fields&quot; representing the current time.
 832     // The two representations are usually in sync, but can get out of sync
 833     // as follows.
 834     // 1. Initially, no fields are set, and the time is invalid.
 835     // 2. If the time is set, all fields are computed and in sync.
 836     // 3. If a single field is set, the time is invalid.
 837     // Recomputation of the time and fields happens when the object needs
 838     // to return a result to the user, or use a result for a computation.
 839 
 840     /**
 841      * The calendar field values for the currently set time for this calendar.
<span class="line-modified"> 842      * This is an array of &lt;code&gt;FIELD_COUNT&lt;/code&gt; integers, with index values</span>
<span class="line-modified"> 843      * &lt;code&gt;ERA&lt;/code&gt; through &lt;code&gt;DST_OFFSET&lt;/code&gt;.</span>
 844      * @serial
 845      */
 846     @SuppressWarnings(&quot;ProtectedField&quot;)
 847     protected int           fields[];
 848 
 849     /**
 850      * The flags which tell if a specified calendar field for the calendar is set.
 851      * A new object has no fields set.  After the first call to a method
 852      * which generates the fields, they all remain set after that.
<span class="line-modified"> 853      * This is an array of &lt;code&gt;FIELD_COUNT&lt;/code&gt; booleans, with index values</span>
<span class="line-modified"> 854      * &lt;code&gt;ERA&lt;/code&gt; through &lt;code&gt;DST_OFFSET&lt;/code&gt;.</span>
 855      * @serial
 856      */
 857     @SuppressWarnings(&quot;ProtectedField&quot;)
 858     protected boolean       isSet[];
 859 
 860     /**
 861      * Pseudo-time-stamps which specify when each field was set. There
 862      * are two special values, UNSET and COMPUTED. Values from
 863      * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.
 864      */
 865     private transient int   stamp[];
 866 
 867     /**
 868      * The currently set time for this calendar, expressed in milliseconds after
 869      * January 1, 1970, 0:00:00 GMT.
 870      * @see #isTimeSet
 871      * @serial
 872      */
 873     @SuppressWarnings(&quot;ProtectedField&quot;)
 874     protected long          time;
 875 
 876     /**
<span class="line-modified"> 877      * True if then the value of &lt;code&gt;time&lt;/code&gt; is valid.</span>
<span class="line-modified"> 878      * The time is made invalid by a change to an item of &lt;code&gt;field[]&lt;/code&gt;.</span>
 879      * @see #time
 880      * @serial
 881      */
 882     @SuppressWarnings(&quot;ProtectedField&quot;)
 883     protected boolean       isTimeSet;
 884 
 885     /**
<span class="line-modified"> 886      * True if &lt;code&gt;fields[]&lt;/code&gt; are in sync with the currently set time.</span>
 887      * If false, then the next attempt to get the value of a field will
 888      * force a recomputation of all fields from the current value of
<span class="line-modified"> 889      * &lt;code&gt;time&lt;/code&gt;.</span>
 890      * @serial
 891      */
 892     @SuppressWarnings(&quot;ProtectedField&quot;)
 893     protected boolean       areFieldsSet;
 894 
 895     /**
 896      * True if all fields have been set.
 897      * @serial
 898      */
 899     transient boolean       areAllFieldsSet;
 900 
 901     /**
<span class="line-modified"> 902      * &lt;code&gt;True&lt;/code&gt; if this calendar allows out-of-range field values during computation</span>
<span class="line-modified"> 903      * of &lt;code&gt;time&lt;/code&gt; from &lt;code&gt;fields[]&lt;/code&gt;.</span>
 904      * @see #setLenient
 905      * @see #isLenient
 906      * @serial
 907      */
 908     private boolean         lenient = true;
 909 
 910     /**
<span class="line-modified"> 911      * The &lt;code&gt;TimeZone&lt;/code&gt; used by this calendar. &lt;code&gt;Calendar&lt;/code&gt;</span>
 912      * uses the time zone data to translate between locale and GMT time.
 913      * @serial
 914      */
 915     private TimeZone        zone;
 916 
 917     /**
<span class="line-modified"> 918      * &lt;code&gt;True&lt;/code&gt; if zone references to a shared TimeZone object.</span>
 919      */
 920     private transient boolean sharedZone = false;
 921 
 922     /**
<span class="line-modified"> 923      * The first day of the week, with possible values &lt;code&gt;SUNDAY&lt;/code&gt;,</span>
<span class="line-modified"> 924      * &lt;code&gt;MONDAY&lt;/code&gt;, etc.  This is a locale-dependent value.</span>
 925      * @serial
 926      */
 927     private int             firstDayOfWeek;
 928 
 929     /**
 930      * The number of days required for the first week in a month or year,
 931      * with possible values from 1 to 7.  This is a locale-dependent value.
 932      * @serial
 933      */
 934     private int             minimalDaysInFirstWeek;
 935 
 936     /**
 937      * Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek
 938      * of a Locale.
 939      */
 940     private static final ConcurrentMap&lt;Locale, int[]&gt; cachedLocaleData
 941         = new ConcurrentHashMap&lt;&gt;(3);
 942 
 943     // Special values of stamp[]
 944     /**
</pre>
<hr />
<pre>
 947     private static final int        UNSET = 0;
 948 
 949     /**
 950      * The value of the corresponding fields[] has been calculated internally.
 951      */
 952     private static final int        COMPUTED = 1;
 953 
 954     /**
 955      * The value of the corresponding fields[] has been set externally. Stamp
 956      * values which are greater than 1 represents the (pseudo) time when the
 957      * corresponding fields[] value was set.
 958      */
 959     private static final int        MINIMUM_USER_STAMP = 2;
 960 
 961     /**
 962      * The mask value that represents all of the fields.
 963      */
 964     static final int ALL_FIELDS = (1 &lt;&lt; FIELD_COUNT) - 1;
 965 
 966     /**
<span class="line-modified"> 967      * The next available value for &lt;code&gt;stamp[]&lt;/code&gt;, an internal array.</span>
 968      * This actually should not be written out to the stream, and will probably
 969      * be removed from the stream in the near future.  In the meantime,
<span class="line-modified"> 970      * a value of &lt;code&gt;MINIMUM_USER_STAMP&lt;/code&gt; should be used.</span>
 971      * @serial
 972      */
 973     private int             nextStamp = MINIMUM_USER_STAMP;
 974 
 975     // the internal serial version which says which version was written
 976     // - 0 (default) for version up to JDK 1.1.5
 977     // - 1 for version from JDK 1.1.6, which writes a correct &#39;time&#39; value
 978     //     as well as compatible values for other fields.  This is a
 979     //     transitional format.
 980     // - 2 (not implemented yet) a future version, in which fields[],
 981     //     areFieldsSet, and isTimeSet become transient, and isSet[] is
 982     //     removed. In JDK 1.1.6 we write a format compatible with version 2.
 983     static final int        currentSerialVersion = 1;
 984 
 985     /**
 986      * The version of the serialized data on the stream.  Possible values:
 987      * &lt;dl&gt;
 988      * &lt;dt&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream&lt;/dt&gt;
 989      * &lt;dd&gt;
 990      * JDK 1.1.5 or earlier.
 991      * &lt;/dd&gt;
 992      * &lt;dt&gt;&lt;b&gt;1&lt;/b&gt;&lt;/dt&gt;
 993      * &lt;dd&gt;
 994      * JDK 1.1.6 or later.  Writes a correct &#39;time&#39; value
 995      * as well as compatible values for other fields.  This is a
 996      * transitional format.
 997      * &lt;/dd&gt;
 998      * &lt;/dl&gt;
 999      * When streaming out this class, the most recent format
<span class="line-modified">1000      * and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;</span>
1001      * is written.
1002      * @serial
1003      * @since 1.1.6
1004      */
1005     private int             serialVersionOnStream = currentSerialVersion;
1006 
1007     // Proclaim serialization compatibility with JDK 1.1

1008     static final long       serialVersionUID = -1807547505821590642L;
1009 
1010     // Mask values for calendar fields
1011     @SuppressWarnings(&quot;PointlessBitwiseExpression&quot;)
1012     static final int ERA_MASK           = (1 &lt;&lt; ERA);
1013     static final int YEAR_MASK          = (1 &lt;&lt; YEAR);
1014     static final int MONTH_MASK         = (1 &lt;&lt; MONTH);
1015     static final int WEEK_OF_YEAR_MASK  = (1 &lt;&lt; WEEK_OF_YEAR);
1016     static final int WEEK_OF_MONTH_MASK = (1 &lt;&lt; WEEK_OF_MONTH);
1017     static final int DAY_OF_MONTH_MASK  = (1 &lt;&lt; DAY_OF_MONTH);
1018     static final int DATE_MASK          = DAY_OF_MONTH_MASK;
1019     static final int DAY_OF_YEAR_MASK   = (1 &lt;&lt; DAY_OF_YEAR);
1020     static final int DAY_OF_WEEK_MASK   = (1 &lt;&lt; DAY_OF_WEEK);
1021     static final int DAY_OF_WEEK_IN_MONTH_MASK  = (1 &lt;&lt; DAY_OF_WEEK_IN_MONTH);
1022     static final int AM_PM_MASK         = (1 &lt;&lt; AM_PM);
1023     static final int HOUR_MASK          = (1 &lt;&lt; HOUR);
1024     static final int HOUR_OF_DAY_MASK   = (1 &lt;&lt; HOUR_OF_DAY);
1025     static final int MINUTE_MASK        = (1 &lt;&lt; MINUTE);
1026     static final int SECOND_MASK        = (1 &lt;&lt; SECOND);
1027     static final int MILLISECOND_MASK   = (1 &lt;&lt; MILLISECOND);
</pre>
<hr />
<pre>
1289          * @param weekOfYear the week number based on {@code weekYear}
1290          * @param dayOfWeek  the day of week value: one of the constants
1291          *     for the {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} field:
1292          *     {@link Calendar#SUNDAY SUNDAY}, ..., {@link Calendar#SATURDAY SATURDAY}.
1293          * @return this {@code Calendar.Builder}
1294          * @see Calendar#setWeekDate(int, int, int)
1295          * @see Calendar#isWeekDateSupported()
1296          */
1297         public Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
1298             allocateFields();
1299             internalSet(WEEK_YEAR, weekYear);
1300             internalSet(WEEK_OF_YEAR, weekOfYear);
1301             internalSet(DAY_OF_WEEK, dayOfWeek);
1302             return this;
1303         }
1304 
1305         /**
1306          * Sets the time zone parameter to the given {@code zone}. If no time
1307          * zone parameter is given to this {@code Calendar.Builder}, the
1308          * {@linkplain TimeZone#getDefault() default
<span class="line-modified">1309          * &lt;code&gt;TimeZone&lt;/code&gt;} will be used in the {@link #build() build}</span>
1310          * method.
1311          *
1312          * @param zone the {@link TimeZone}
1313          * @return this {@code Calendar.Builder}
1314          * @throws NullPointerException if {@code zone} is {@code null}
1315          * @see Calendar#setTimeZone(TimeZone)
1316          */
1317         public Builder setTimeZone(TimeZone zone) {
1318             if (zone == null) {
1319                 throw new NullPointerException();
1320             }
1321             this.zone = zone;
1322             return this;
1323         }
1324 
1325         /**
1326          * Sets the lenient mode parameter to the value given by {@code lenient}.
1327          * If no lenient parameter is given to this {@code Calendar.Builder},
1328          * lenient mode will be used in the {@link #build() build} method.
1329          *
</pre>
<hr />
<pre>
1360             if (type.equals(&quot;gregorian&quot;)) { // NPE if type == null
1361                 type = &quot;gregory&quot;;
1362             }
1363             if (!Calendar.getAvailableCalendarTypes().contains(type)
1364                     &amp;&amp; !type.equals(&quot;iso8601&quot;)) {
1365                 throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);
1366             }
1367             if (this.type == null) {
1368                 this.type = type;
1369             } else {
1370                 if (!this.type.equals(type)) {
1371                     throw new IllegalStateException(&quot;calendar type override&quot;);
1372                 }
1373             }
1374             return this;
1375         }
1376 
1377         /**
1378          * Sets the locale parameter to the given {@code locale}. If no locale
1379          * is given to this {@code Calendar.Builder}, the {@linkplain
<span class="line-modified">1380          * Locale#getDefault(Locale.Category) default &lt;code&gt;Locale&lt;/code&gt;}</span>
1381          * for {@link Locale.Category#FORMAT} will be used.
1382          *
1383          * &lt;p&gt;If no calendar type is explicitly given by a call to the
1384          * {@link #setCalendarType(String) setCalendarType} method,
1385          * the {@code Locale} value is used to determine what type of
1386          * {@code Calendar} to be built.
1387          *
1388          * &lt;p&gt;If no week definition parameters are explicitly given by a call to
1389          * the {@link #setWeekDefinition(int,int) setWeekDefinition} method, the
1390          * {@code Locale}&#39;s default values are used.
1391          *
1392          * @param locale the {@link Locale}
1393          * @throws NullPointerException if {@code locale} is {@code null}
1394          * @return this {@code Calendar.Builder}
1395          * @see Calendar#getInstance(Locale)
1396          */
1397         public Builder setLocale(Locale locale) {
1398             if (locale == null) {
1399                 throw new NullPointerException();
1400             }
</pre>
<hr />
<pre>
1596     }
1597 
1598     /**
1599      * Constructs a calendar with the specified time zone and locale.
1600      *
1601      * @param zone the time zone to use
1602      * @param aLocale the locale for the week data
1603      */
1604     protected Calendar(TimeZone zone, Locale aLocale)
1605     {
1606         fields = new int[FIELD_COUNT];
1607         isSet = new boolean[FIELD_COUNT];
1608         stamp = new int[FIELD_COUNT];
1609 
1610         this.zone = zone;
1611         setWeekCountData(aLocale);
1612     }
1613 
1614     /**
1615      * Gets a calendar using the default time zone and locale. The
<span class="line-modified">1616      * &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time</span>
1617      * in the default time zone with the default
1618      * {@link Locale.Category#FORMAT FORMAT} locale.
1619      * &lt;p&gt;
1620      * If the locale contains the time zone with &quot;tz&quot;
1621      * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
1622      * that time zone is used instead.
1623      *
1624      * @return a Calendar.
1625      */
1626     public static Calendar getInstance()
1627     {
1628         Locale aLocale = Locale.getDefault(Locale.Category.FORMAT);
1629         return createCalendar(defaultTimeZone(aLocale), aLocale);
1630     }
1631 
1632     /**
1633      * Gets a calendar using the specified time zone and default locale.
<span class="line-modified">1634      * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time</span>
1635      * in the given time zone with the default
1636      * {@link Locale.Category#FORMAT FORMAT} locale.
1637      *
1638      * @param zone the time zone to use
1639      * @return a Calendar.
1640      */
1641     public static Calendar getInstance(TimeZone zone)
1642     {
1643         return createCalendar(zone, Locale.getDefault(Locale.Category.FORMAT));
1644     }
1645 
1646     /**
1647      * Gets a calendar using the default time zone and specified locale.
<span class="line-modified">1648      * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time</span>
1649      * in the default time zone with the given locale.
1650      * &lt;p&gt;
1651      * If the locale contains the time zone with &quot;tz&quot;
1652      * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
1653      * that time zone is used instead.
1654      *
1655      * @param aLocale the locale for the week data
1656      * @return a Calendar.
1657      */
1658     public static Calendar getInstance(Locale aLocale)
1659     {
1660         return createCalendar(defaultTimeZone(aLocale), aLocale);
1661     }
1662 
1663     /**
1664      * Gets a calendar with the specified time zone and locale.
<span class="line-modified">1665      * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time</span>
1666      * in the given time zone with the given locale.
1667      *
1668      * @param zone the time zone to use
1669      * @param aLocale the locale for the week data
1670      * @return a Calendar.
1671      */
1672     public static Calendar getInstance(TimeZone zone,
1673                                        Locale aLocale)
1674     {
1675         return createCalendar(zone, aLocale);
1676     }
1677 
1678     private static TimeZone defaultTimeZone(Locale l) {
1679         TimeZone defaultTZ = TimeZone.getDefault();
1680         String shortTZID = l.getUnicodeLocaleType(&quot;tz&quot;);
1681         return shortTZID != null ?
1682             TimeZoneNameUtility.convertLDMLShortID(shortTZID)
1683                 .map(TimeZone::getTimeZone)
1684                 .orElse(defaultTZ) :
1685             defaultTZ;
</pre>
<hr />
<pre>
1720         if (cal == null) {
1721             // If no known calendar type is explicitly specified,
1722             // perform the traditional way to create a Calendar:
1723             // create a BuddhistCalendar for th_TH locale,
1724             // a JapaneseImperialCalendar for ja_JP_JP locale, or
1725             // a GregorianCalendar for any other locales.
1726             // NOTE: The language, country and variant strings are interned.
1727             if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {
1728                 cal = new BuddhistCalendar(zone, aLocale);
1729             } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;
1730                        &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {
1731                 cal = new JapaneseImperialCalendar(zone, aLocale);
1732             } else {
1733                 cal = new GregorianCalendar(zone, aLocale);
1734             }
1735         }
1736         return cal;
1737     }
1738 
1739     /**
<span class="line-modified">1740      * Returns an array of all locales for which the &lt;code&gt;getInstance&lt;/code&gt;</span>
1741      * methods of this class can return localized instances.
<span class="line-modified">1742      * The array returned must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
1743      * instance equal to {@link java.util.Locale#US Locale.US}.
1744      *
1745      * @return An array of locales for which localized
<span class="line-modified">1746      *         &lt;code&gt;Calendar&lt;/code&gt; instances are available.</span>
1747      */
1748     public static synchronized Locale[] getAvailableLocales()
1749     {
1750         return DateFormat.getAvailableLocales();
1751     }
1752 
1753     /**
1754      * Converts the current calendar field values in {@link #fields fields[]}
1755      * to the millisecond time value
1756      * {@link #time}.
1757      *
1758      * @see #complete()
1759      * @see #computeFields()
1760      */
1761     protected abstract void computeTime();
1762 
1763     /**
1764      * Converts the current millisecond time value {@link #time}
1765      * to calendar field values in {@link #fields fields[]}.
1766      * This allows you to sync up the calendar field values with
1767      * a new time that is set for the calendar.  The time is &lt;em&gt;not&lt;/em&gt;
1768      * recomputed first; to recompute the time, then the fields, call the
1769      * {@link #complete()} method.
1770      *
1771      * @see #computeTime()
1772      */
1773     protected abstract void computeFields();
1774 
1775     /**
<span class="line-modified">1776      * Returns a &lt;code&gt;Date&lt;/code&gt; object representing this</span>
<span class="line-modified">1777      * &lt;code&gt;Calendar&lt;/code&gt;&#39;s time value (millisecond offset from the &lt;a</span>
1778      * href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;&quot;).
1779      *
<span class="line-modified">1780      * @return a &lt;code&gt;Date&lt;/code&gt; representing the time value.</span>
1781      * @see #setTime(Date)
1782      * @see #getTimeInMillis()
1783      */
1784     public final Date getTime() {
1785         return new Date(getTimeInMillis());
1786     }
1787 
1788     /**
<span class="line-modified">1789      * Sets this Calendar&#39;s time with the given &lt;code&gt;Date&lt;/code&gt;.</span>
1790      * &lt;p&gt;
<span class="line-modified">1791      * Note: Calling &lt;code&gt;setTime()&lt;/code&gt; with</span>
<span class="line-modified">1792      * &lt;code&gt;Date(Long.MAX_VALUE)&lt;/code&gt; or &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt;</span>
<span class="line-modified">1793      * may yield incorrect field values from &lt;code&gt;get()&lt;/code&gt;.</span>
1794      *
1795      * @param date the given Date.
1796      * @see #getTime()
1797      * @see #setTimeInMillis(long)
1798      */
1799     public final void setTime(Date date) {
1800         setTimeInMillis(date.getTime());
1801     }
1802 
1803     /**
1804      * Returns this Calendar&#39;s time value in milliseconds.
1805      *
1806      * @return the current time as UTC milliseconds from the epoch.
1807      * @see #getTime()
1808      * @see #setTimeInMillis(long)
1809      */
1810     public long getTimeInMillis() {
1811         if (!isTimeSet) {
1812             updateTime();
1813         }
</pre>
<hr />
<pre>
1856         complete();
1857         return internalGet(field);
1858     }
1859 
1860     /**
1861      * Returns the value of the given calendar field. This method does
1862      * not involve normalization or validation of the field value.
1863      *
1864      * @param field the given calendar field.
1865      * @return the value for the given calendar field.
1866      * @see #get(int)
1867      */
1868     protected final int internalGet(int field)
1869     {
1870         return fields[field];
1871     }
1872 
1873     /**
1874      * Sets the value of the given calendar field. This method does
1875      * not affect any setting state of the field in this
<span class="line-modified">1876      * &lt;code&gt;Calendar&lt;/code&gt; instance.</span>
1877      *
1878      * @throws IndexOutOfBoundsException if the specified field is out of range
1879      *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
1880      * @see #areFieldsSet
1881      * @see #isTimeSet
1882      * @see #areAllFieldsSet
1883      * @see #set(int,int)
1884      */
1885     final void internalSet(int field, int value)
1886     {
1887         fields[field] = value;
1888     }
1889 
1890     /**
1891      * Sets the given calendar field to the given value. The value is not
1892      * interpreted by this method regardless of the leniency mode.
1893      *
1894      * @param field the given calendar field.
1895      * @param value the value to be set for the given calendar field.
1896      * @throws ArrayIndexOutOfBoundsException if the specified field is out of range
</pre>
<hr />
<pre>
1902      * @see #get(int)
1903      */
1904     public void set(int field, int value)
1905     {
1906         // If the fields are partially normalized, calculate all the
1907         // fields before changing any fields.
1908         if (areFieldsSet &amp;&amp; !areAllFieldsSet) {
1909             computeFields();
1910         }
1911         internalSet(field, value);
1912         isTimeSet = false;
1913         areFieldsSet = false;
1914         isSet[field] = true;
1915         stamp[field] = nextStamp++;
1916         if (nextStamp == Integer.MAX_VALUE) {
1917             adjustStamp();
1918         }
1919     }
1920 
1921     /**
<span class="line-modified">1922      * Sets the values for the calendar fields &lt;code&gt;YEAR&lt;/code&gt;,</span>
<span class="line-modified">1923      * &lt;code&gt;MONTH&lt;/code&gt;, and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.</span>
1924      * Previous values of other calendar fields are retained.  If this is not desired,
1925      * call {@link #clear()} first.
1926      *
<span class="line-modified">1927      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field.</span>
<span class="line-modified">1928      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field.</span>
1929      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified">1930      * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field.</span>
1931      * @see #set(int,int)
1932      * @see #set(int,int,int,int,int)
1933      * @see #set(int,int,int,int,int,int)
1934      */
1935     public final void set(int year, int month, int date)
1936     {
1937         set(YEAR, year);
1938         set(MONTH, month);
1939         set(DATE, date);
1940     }
1941 
1942     /**
<span class="line-modified">1943      * Sets the values for the calendar fields &lt;code&gt;YEAR&lt;/code&gt;,</span>
<span class="line-modified">1944      * &lt;code&gt;MONTH&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;,</span>
<span class="line-modified">1945      * &lt;code&gt;HOUR_OF_DAY&lt;/code&gt;, and &lt;code&gt;MINUTE&lt;/code&gt;.</span>
1946      * Previous values of other fields are retained.  If this is not desired,
1947      * call {@link #clear()} first.
1948      *
<span class="line-modified">1949      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field.</span>
<span class="line-modified">1950      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field.</span>
1951      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified">1952      * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field.</span>
<span class="line-modified">1953      * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field.</span>
<span class="line-modified">1954      * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field.</span>
1955      * @see #set(int,int)
1956      * @see #set(int,int,int)
1957      * @see #set(int,int,int,int,int,int)
1958      */
1959     public final void set(int year, int month, int date, int hourOfDay, int minute)
1960     {
1961         set(YEAR, year);
1962         set(MONTH, month);
1963         set(DATE, date);
1964         set(HOUR_OF_DAY, hourOfDay);
1965         set(MINUTE, minute);
1966     }
1967 
1968     /**
<span class="line-modified">1969      * Sets the values for the fields &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,</span>
<span class="line-modified">1970      * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR_OF_DAY&lt;/code&gt;, &lt;code&gt;MINUTE&lt;/code&gt;, and</span>
<span class="line-modified">1971      * &lt;code&gt;SECOND&lt;/code&gt;.</span>
1972      * Previous values of other fields are retained.  If this is not desired,
1973      * call {@link #clear()} first.
1974      *
<span class="line-modified">1975      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field.</span>
<span class="line-modified">1976      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field.</span>
1977      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified">1978      * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field.</span>
<span class="line-modified">1979      * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field.</span>
<span class="line-modified">1980      * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field.</span>
<span class="line-modified">1981      * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field.</span>
1982      * @see #set(int,int)
1983      * @see #set(int,int,int)
1984      * @see #set(int,int,int,int,int)
1985      */
1986     public final void set(int year, int month, int date, int hourOfDay, int minute,
1987                           int second)
1988     {
1989         set(YEAR, year);
1990         set(MONTH, month);
1991         set(DATE, date);
1992         set(HOUR_OF_DAY, hourOfDay);
1993         set(MINUTE, minute);
1994         set(SECOND, second);
1995     }
1996 
1997     /**
1998      * Sets all the calendar field values and the time value
1999      * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) of
<span class="line-modified">2000      * this &lt;code&gt;Calendar&lt;/code&gt; undefined. This means that {@link</span>
<span class="line-modified">2001      * #isSet(int) isSet()} will return &lt;code&gt;false&lt;/code&gt; for all the</span>
2002      * calendar fields, and the date and time calculations will treat
2003      * the fields as if they had never been set. A
<span class="line-modified">2004      * &lt;code&gt;Calendar&lt;/code&gt; implementation class may use its specific</span>
2005      * default field values for date/time calculations. For example,
<span class="line-modified">2006      * &lt;code&gt;GregorianCalendar&lt;/code&gt; uses 1970 if the</span>
<span class="line-modified">2007      * &lt;code&gt;YEAR&lt;/code&gt; field value is undefined.</span>
2008      *
2009      * @see #clear(int)
2010      */
2011     public final void clear()
2012     {
2013         for (int i = 0; i &lt; fields.length; ) {
2014             stamp[i] = fields[i] = 0; // UNSET == 0
2015             isSet[i++] = false;
2016         }
2017         areAllFieldsSet = areFieldsSet = false;
2018         isTimeSet = false;
2019     }
2020 
2021     /**
2022      * Sets the given calendar field value and the time value
2023      * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) of
<span class="line-modified">2024      * this &lt;code&gt;Calendar&lt;/code&gt; undefined. This means that {@link</span>
<span class="line-modified">2025      * #isSet(int) isSet(field)} will return &lt;code&gt;false&lt;/code&gt;, and</span>
2026      * the date and time calculations will treat the field as if it
<span class="line-modified">2027      * had never been set. A &lt;code&gt;Calendar&lt;/code&gt; implementation</span>
2028      * class may use the field&#39;s specific default value for date and
2029      * time calculations.
2030      *
2031      * &lt;p&gt;The {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}
2032      * fields are handled independently and the &lt;a
2033      * href=&quot;#time_resolution&quot;&gt;the resolution rule for the time of
2034      * day&lt;/a&gt; is applied. Clearing one of the fields doesn&#39;t reset
<span class="line-modified">2035      * the hour of day value of this &lt;code&gt;Calendar&lt;/code&gt;. Use {@link</span>
2036      * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour
2037      * value.
2038      *
2039      * @param field the calendar field to be cleared.
2040      * @see #clear()
2041      */
2042     public final void clear(int field)
2043     {
2044         fields[field] = 0;
2045         stamp[field] = UNSET;
2046         isSet[field] = false;
2047 
2048         areAllFieldsSet = areFieldsSet = false;
2049         isTimeSet = false;
2050     }
2051 
2052     /**
2053      * Determines if the given calendar field has a value set,
2054      * including cases that the value has been set by internal fields
<span class="line-modified">2055      * calculations triggered by a &lt;code&gt;get&lt;/code&gt; method call.</span>
2056      *
2057      * @param field the calendar field to test
<span class="line-modified">2058      * @return &lt;code&gt;true&lt;/code&gt; if the given calendar field has a value set;</span>
<span class="line-modified">2059      * &lt;code&gt;false&lt;/code&gt; otherwise.</span>
2060      */
2061     public final boolean isSet(int field)
2062     {
2063         return stamp[field] != UNSET;
2064     }
2065 
2066     /**
2067      * Returns the string representation of the calendar
<span class="line-modified">2068      * &lt;code&gt;field&lt;/code&gt; value in the given &lt;code&gt;style&lt;/code&gt; and</span>
<span class="line-modified">2069      * &lt;code&gt;locale&lt;/code&gt;.  If no string representation is</span>
<span class="line-modified">2070      * applicable, &lt;code&gt;null&lt;/code&gt; is returned. This method calls</span>
2071      * {@link Calendar#get(int) get(field)} to get the calendar
<span class="line-modified">2072      * &lt;code&gt;field&lt;/code&gt; value if the string representation is</span>
<span class="line-modified">2073      * applicable to the given calendar &lt;code&gt;field&lt;/code&gt;.</span>
2074      *
<span class="line-modified">2075      * &lt;p&gt;For example, if this &lt;code&gt;Calendar&lt;/code&gt; is a</span>
<span class="line-modified">2076      * &lt;code&gt;GregorianCalendar&lt;/code&gt; and its date is 2005-01-01, then</span>
2077      * the string representation of the {@link #MONTH} field would be
2078      * &quot;January&quot; in the long style in an English locale or &quot;Jan&quot; in
2079      * the short style. However, no string representation would be
2080      * available for the {@link #DAY_OF_MONTH} field, and this method
<span class="line-modified">2081      * would return &lt;code&gt;null&lt;/code&gt;.</span>
2082      *
2083      * &lt;p&gt;The default implementation supports the calendar fields for
2084      * which a {@link DateFormatSymbols} has names in the given
<span class="line-modified">2085      * &lt;code&gt;locale&lt;/code&gt;.</span>
2086      *
2087      * @param field
2088      *        the calendar field for which the string representation
2089      *        is returned
2090      * @param style
2091      *        the style applied to the string representation; one of {@link
2092      *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
2093      *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
2094      *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}.
2095      * @param locale
2096      *        the locale for the string representation
2097      *        (any calendar types specified by {@code locale} are ignored)
2098      * @return the string representation of the given
2099      *        {@code field} in the given {@code style}, or
2100      *        {@code null} if no string representation is
2101      *        applicable.
<span class="line-modified">2102      * @exception IllegalArgumentException</span>
2103      *        if {@code field} or {@code style} is invalid,
2104      *        or if this {@code Calendar} is non-lenient and any
2105      *        of the calendar fields have invalid values
<span class="line-modified">2106      * @exception NullPointerException</span>
2107      *        if {@code locale} is null
2108      * @since 1.6
2109      */
2110     public String getDisplayName(int field, int style, Locale locale) {
2111         if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale,
2112                             ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {
2113             return null;
2114         }
2115 
2116         String calendarType = getCalendarType();
2117         int fieldValue = get(field);
2118         // the standalone/narrow styles and short era are supported only through
2119         // CalendarNameProviders.
2120         if (isStandaloneStyle(style) || isNarrowFormatStyle(style) ||
2121             field == ERA &amp;&amp; (style &amp; SHORT) == SHORT) {
2122             String val = CalendarDataUtility.retrieveFieldValueName(calendarType,
2123                                                                     field, fieldValue,
2124                                                                     style, locale);
2125             // Perform fallback here to follow the CLDR rules
2126             if (val == null) {
</pre>
<hr />
<pre>
2173      * &lt;p&gt;The default implementation supports display names contained in
2174      * a {@link DateFormatSymbols}. For example, if {@code field}
2175      * is {@link #MONTH} and {@code style} is {@link
2176      * #ALL_STYLES}, this method returns a {@code Map} containing
2177      * all strings returned by {@link DateFormatSymbols#getShortMonths()}
2178      * and {@link DateFormatSymbols#getMonths()}.
2179      *
2180      * @param field
2181      *        the calendar field for which the display names are returned
2182      * @param style
2183      *        the style applied to the string representation; one of {@link
2184      *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
2185      *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
2186      *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}
2187      * @param locale
2188      *        the locale for the display names
2189      * @return a {@code Map} containing all display names in
2190      *        {@code style} and {@code locale} and their
2191      *        field values, or {@code null} if no display names
2192      *        are defined for {@code field}
<span class="line-modified">2193      * @exception IllegalArgumentException</span>
2194      *        if {@code field} or {@code style} is invalid,
2195      *        or if this {@code Calendar} is non-lenient and any
2196      *        of the calendar fields have invalid values
<span class="line-modified">2197      * @exception NullPointerException</span>
2198      *        if {@code locale} is null
2199      * @since 1.6
2200      */
2201     public Map&lt;String, Integer&gt; getDisplayNames(int field, int style, Locale locale) {
2202         if (!checkDisplayNameParams(field, style, ALL_STYLES, NARROW_FORMAT, locale,
2203                                     ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {
2204             return null;
2205         }
2206 
2207         String calendarType = getCalendarType();
<span class="line-modified">2208         if (style == ALL_STYLES || isStandaloneStyle(style) || isNarrowFormatStyle(style)) {</span>

2209             Map&lt;String, Integer&gt; map;
2210             map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field, style, locale);
2211 
2212             // Perform fallback here to follow the CLDR rules
2213             if (map == null) {
2214                 if (isNarrowFormatStyle(style)) {
2215                     map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field,
2216                                                                       toStandaloneStyle(style), locale);
2217                 } else if (style != ALL_STYLES) {
2218                     map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field,
2219                                                                       getBaseStyle(style), locale);
2220                 }
2221             }
2222             return map;
2223         }
2224 
2225         // SHORT or LONG
2226         return getDisplayNamesImpl(field, style, locale);
2227     }
2228 
</pre>
<hr />
<pre>
2290      * from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) has not been calculated from
2291      * calendar field values. Then, the {@link #computeFields()} method is
2292      * called to calculate all calendar field values.
2293      */
2294     protected void complete()
2295     {
2296         if (!isTimeSet) {
2297             updateTime();
2298         }
2299         if (!areFieldsSet || !areAllFieldsSet) {
2300             computeFields(); // fills in unset fields
2301             areAllFieldsSet = areFieldsSet = true;
2302         }
2303     }
2304 
2305     /**
2306      * Returns whether the value of the specified calendar field has been set
2307      * externally by calling one of the setter methods rather than by the
2308      * internal time calculation.
2309      *
<span class="line-modified">2310      * @return &lt;code&gt;true&lt;/code&gt; if the field has been set externally,</span>
<span class="line-modified">2311      * &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">2312      * @exception IndexOutOfBoundsException if the specified</span>
<span class="line-modified">2313      *                &lt;code&gt;field&lt;/code&gt; is out of range</span>
2314      *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
2315      * @see #selectFields()
2316      * @see #setFieldsComputed(int)
2317      */
2318     final boolean isExternallySet(int field) {
2319         return stamp[field] &gt;= MINIMUM_USER_STAMP;
2320     }
2321 
2322     /**
2323      * Returns a field mask (bit mask) indicating all calendar fields that
2324      * have the state of externally or internally set.
2325      *
2326      * @return a bit mask indicating set state fields
2327      */
2328     final int getSetStateFields() {
2329         int mask = 0;
2330         for (int i = 0; i &lt; fields.length; i++) {
2331             if (stamp[i] != UNSET) {
2332                 mask |= 1 &lt;&lt; i;
2333             }
2334         }
2335         return mask;
2336     }
2337 
2338     /**
2339      * Sets the state of the specified calendar fields to
2340      * &lt;em&gt;computed&lt;/em&gt;. This state means that the specified calendar fields
2341      * have valid values that have been set by internal time calculation
2342      * rather than by calling one of the setter methods.
2343      *
2344      * @param fieldMask the field to be marked as computed.
<span class="line-modified">2345      * @exception IndexOutOfBoundsException if the specified</span>
<span class="line-modified">2346      *                &lt;code&gt;field&lt;/code&gt; is out of range</span>
2347      *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
2348      * @see #isExternallySet(int)
2349      * @see #selectFields()
2350      */
2351     final void setFieldsComputed(int fieldMask) {
2352         if (fieldMask == ALL_FIELDS) {
2353             for (int i = 0; i &lt; fields.length; i++) {
2354                 stamp[i] = COMPUTED;
2355                 isSet[i] = true;
2356             }
2357             areFieldsSet = areAllFieldsSet = true;
2358         } else {
2359             for (int i = 0; i &lt; fields.length; i++) {
2360                 if ((fieldMask &amp; 1) == 1) {
2361                     stamp[i] = COMPUTED;
2362                     isSet[i] = true;
2363                 } else {
2364                     if (areAllFieldsSet &amp;&amp; !isSet[i]) {
2365                         areAllFieldsSet = false;
2366                     }
2367                 }
2368                 fieldMask &gt;&gt;&gt;= 1;
2369             }
2370         }
2371     }
2372 
2373     /**
2374      * Sets the state of the calendar fields that are &lt;em&gt;not&lt;/em&gt; specified
<span class="line-modified">2375      * by &lt;code&gt;fieldMask&lt;/code&gt; to &lt;em&gt;unset&lt;/em&gt;. If &lt;code&gt;fieldMask&lt;/code&gt;</span>
2376      * specifies all the calendar fields, then the state of this
<span class="line-modified">2377      * &lt;code&gt;Calendar&lt;/code&gt; becomes that all the calendar fields are in sync</span>
2378      * with the time value (millisecond offset from the Epoch).
2379      *
2380      * @param fieldMask the field mask indicating which calendar fields are in
2381      * sync with the time value.
<span class="line-modified">2382      * @exception IndexOutOfBoundsException if the specified</span>
<span class="line-modified">2383      *                &lt;code&gt;field&lt;/code&gt; is out of range</span>
2384      *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
2385      * @see #isExternallySet(int)
2386      * @see #selectFields()
2387      */
2388     final void setFieldsNormalized(int fieldMask) {
2389         if (fieldMask != ALL_FIELDS) {
2390             for (int i = 0; i &lt; fields.length; i++) {
2391                 if ((fieldMask &amp; 1) == 0) {
2392                     stamp[i] = fields[i] = 0; // UNSET == 0
2393                     isSet[i] = false;
2394                 }
2395                 fieldMask &gt;&gt;= 1;
2396             }
2397         }
2398 
2399         // Some or all of the fields are in sync with the
2400         // milliseconds, but the stamp values are not normalized yet.
2401         areFieldsSet = true;
2402         areAllFieldsSet = false;
2403     }
</pre>
<hr />
<pre>
2409     final boolean isPartiallyNormalized() {
2410         return areFieldsSet &amp;&amp; !areAllFieldsSet;
2411     }
2412 
2413     /**
2414      * Returns whether the calendar fields are fully in sync with the time
2415      * value.
2416      */
2417     final boolean isFullyNormalized() {
2418         return areFieldsSet &amp;&amp; areAllFieldsSet;
2419     }
2420 
2421     /**
2422      * Marks this Calendar as not sync&#39;d.
2423      */
2424     final void setUnnormalized() {
2425         areFieldsSet = areAllFieldsSet = false;
2426     }
2427 
2428     /**
<span class="line-modified">2429      * Returns whether the specified &lt;code&gt;field&lt;/code&gt; is on in the</span>
<span class="line-modified">2430      * &lt;code&gt;fieldMask&lt;/code&gt;.</span>
2431      */
2432     static boolean isFieldSet(int fieldMask, int field) {
2433         return (fieldMask &amp; (1 &lt;&lt; field)) != 0;
2434     }
2435 
2436     /**
2437      * Returns a field mask indicating which calendar field values
2438      * to be used to calculate the time value. The calendar fields are
2439      * returned as a bit mask, each bit of which corresponds to a field, i.e.,
<span class="line-modified">2440      * the mask value of &lt;code&gt;field&lt;/code&gt; is &lt;code&gt;(1 &amp;lt;&amp;lt;</span>
<span class="line-modified">2441      * field)&lt;/code&gt;. For example, 0x26 represents the &lt;code&gt;YEAR&lt;/code&gt;,</span>
<span class="line-modified">2442      * &lt;code&gt;MONTH&lt;/code&gt;, and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields (i.e., 0x26 is</span>
2443      * equal to
2444      * &lt;code&gt;(1&amp;lt;&amp;lt;YEAR)|(1&amp;lt;&amp;lt;MONTH)|(1&amp;lt;&amp;lt;DAY_OF_MONTH))&lt;/code&gt;.
2445      *
2446      * &lt;p&gt;This method supports the calendar fields resolution as described in
2447      * the class description. If the bit mask for a given field is on and its
<span class="line-modified">2448      * field has not been set (i.e., &lt;code&gt;isSet(field)&lt;/code&gt; is</span>
<span class="line-modified">2449      * &lt;code&gt;false&lt;/code&gt;), then the default value of the field has to be</span>
2450      * used, which case means that the field has been selected because the
2451      * selected combination involves the field.
2452      *
2453      * @return a bit mask of selected fields
2454      * @see #isExternallySet(int)
2455      */
2456     final int selectFields() {
2457         // This implementation has been taken from the GregorianCalendar class.
2458 
2459         // The YEAR field must always be used regardless of its SET
2460         // state because YEAR is a mandatory field to determine the date
2461         // and the default value (EPOCH_YEAR) may change through the
2462         // normalization process.
2463         int fieldMask = YEAR_MASK;
2464 
2465         if (stamp[ERA] != UNSET) {
2466             fieldMask |= ERA_MASK;
2467         }
2468         // Find the most recent group of fields specifying the day within
2469         // the year.  These may be any of the following combinations:
</pre>
<hr />
<pre>
2674      * defined by the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt;
2675      * specification.
2676      *
2677      * &lt;p&gt;The default implementation of this method returns the class name of
2678      * this {@code Calendar} instance. Any subclasses that implement
2679      * LDML-defined calendar systems should override this method to return
2680      * appropriate calendar types.
2681      *
2682      * @return the LDML-defined calendar type or the class name of this
2683      *         {@code Calendar} instance
2684      * @since 1.8
2685      * @see &lt;a href=&quot;Locale.html#def_extensions&quot;&gt;Locale extensions&lt;/a&gt;
2686      * @see Locale.Builder#setLocale(Locale)
2687      * @see Locale.Builder#setUnicodeLocaleKeyword(String, String)
2688      */
2689     public String getCalendarType() {
2690         return this.getClass().getName();
2691     }
2692 
2693     /**
<span class="line-modified">2694      * Compares this &lt;code&gt;Calendar&lt;/code&gt; to the specified</span>
<span class="line-modified">2695      * &lt;code&gt;Object&lt;/code&gt;.  The result is &lt;code&gt;true&lt;/code&gt; if and only if</span>
<span class="line-modified">2696      * the argument is a &lt;code&gt;Calendar&lt;/code&gt; object of the same calendar</span>
2697      * system that represents the same time value (millisecond offset from the
2698      * &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
<span class="line-modified">2699      * &lt;code&gt;Calendar&lt;/code&gt; parameters as this object.</span>
2700      *
<span class="line-modified">2701      * &lt;p&gt;The &lt;code&gt;Calendar&lt;/code&gt; parameters are the values represented</span>
<span class="line-modified">2702      * by the &lt;code&gt;isLenient&lt;/code&gt;, &lt;code&gt;getFirstDayOfWeek&lt;/code&gt;,</span>
<span class="line-modified">2703      * &lt;code&gt;getMinimalDaysInFirstWeek&lt;/code&gt; and &lt;code&gt;getTimeZone&lt;/code&gt;</span>
2704      * methods. If there is any difference in those parameters
<span class="line-modified">2705      * between the two &lt;code&gt;Calendar&lt;/code&gt;s, this method returns</span>
<span class="line-modified">2706      * &lt;code&gt;false&lt;/code&gt;.</span>
2707      *
2708      * &lt;p&gt;Use the {@link #compareTo(Calendar) compareTo} method to
2709      * compare only the time values.
2710      *
2711      * @param obj the object to compare with.
<span class="line-modified">2712      * @return &lt;code&gt;true&lt;/code&gt; if this object is equal to &lt;code&gt;obj&lt;/code&gt;;</span>
<span class="line-modified">2713      * &lt;code&gt;false&lt;/code&gt; otherwise.</span>
2714      */
2715     @SuppressWarnings(&quot;EqualsWhichDoesntCheckParameterClass&quot;)
2716     @Override
2717     public boolean equals(Object obj) {
2718         if (this == obj) {
2719             return true;
2720         }
2721         try {
2722             Calendar that = (Calendar)obj;
2723             return compareTo(getMillisOf(that)) == 0 &amp;&amp;
2724                 lenient == that.lenient &amp;&amp;
2725                 firstDayOfWeek == that.firstDayOfWeek &amp;&amp;
2726                 minimalDaysInFirstWeek == that.minimalDaysInFirstWeek &amp;&amp;
2727                 zone.equals(that.zone);
2728         } catch (Exception e) {
2729             // Note: GregorianCalendar.computeTime throws
2730             // IllegalArgumentException if the ERA value is invalid
2731             // even it&#39;s in lenient mode.
2732         }
2733         return false;
2734     }
2735 
2736     /**
2737      * Returns a hash code for this calendar.
2738      *
2739      * @return a hash code value for this object.
2740      * @since 1.2
2741      */
2742     @Override
2743     public int hashCode() {
2744         // &#39;otheritems&#39; represents the hash code for the previous versions.
2745         int otheritems = (lenient ? 1 : 0)
2746             | (firstDayOfWeek &lt;&lt; 1)
2747             | (minimalDaysInFirstWeek &lt;&lt; 4)
2748             | (zone.hashCode() &lt;&lt; 7);
2749         long t = getMillisOf(this);
2750         return (int) t ^ (int)(t &gt;&gt; 32) ^ otheritems;
2751     }
2752 
2753     /**
<span class="line-modified">2754      * Returns whether this &lt;code&gt;Calendar&lt;/code&gt; represents a time</span>
2755      * before the time represented by the specified
<span class="line-modified">2756      * &lt;code&gt;Object&lt;/code&gt;. This method is equivalent to:</span>
2757      * &lt;pre&gt;{@code
2758      *         compareTo(when) &lt; 0
2759      * }&lt;/pre&gt;
<span class="line-modified">2760      * if and only if &lt;code&gt;when&lt;/code&gt; is a &lt;code&gt;Calendar&lt;/code&gt;</span>
<span class="line-modified">2761      * instance. Otherwise, the method returns &lt;code&gt;false&lt;/code&gt;.</span>
2762      *
<span class="line-modified">2763      * @param when the &lt;code&gt;Object&lt;/code&gt; to be compared</span>
<span class="line-modified">2764      * @return &lt;code&gt;true&lt;/code&gt; if the time of this</span>
<span class="line-modified">2765      * &lt;code&gt;Calendar&lt;/code&gt; is before the time represented by</span>
<span class="line-modified">2766      * &lt;code&gt;when&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
2767      * @see     #compareTo(Calendar)
2768      */
2769     public boolean before(Object when) {
2770         return when instanceof Calendar
2771             &amp;&amp; compareTo((Calendar)when) &lt; 0;
2772     }
2773 
2774     /**
<span class="line-modified">2775      * Returns whether this &lt;code&gt;Calendar&lt;/code&gt; represents a time</span>
2776      * after the time represented by the specified
<span class="line-modified">2777      * &lt;code&gt;Object&lt;/code&gt;. This method is equivalent to:</span>
2778      * &lt;pre&gt;{@code
2779      *         compareTo(when) &gt; 0
2780      * }&lt;/pre&gt;
<span class="line-modified">2781      * if and only if &lt;code&gt;when&lt;/code&gt; is a &lt;code&gt;Calendar&lt;/code&gt;</span>
<span class="line-modified">2782      * instance. Otherwise, the method returns &lt;code&gt;false&lt;/code&gt;.</span>
2783      *
<span class="line-modified">2784      * @param when the &lt;code&gt;Object&lt;/code&gt; to be compared</span>
<span class="line-modified">2785      * @return &lt;code&gt;true&lt;/code&gt; if the time of this &lt;code&gt;Calendar&lt;/code&gt; is</span>
<span class="line-modified">2786      * after the time represented by &lt;code&gt;when&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt;</span>
2787      * otherwise.
2788      * @see     #compareTo(Calendar)
2789      */
2790     public boolean after(Object when) {
2791         return when instanceof Calendar
2792             &amp;&amp; compareTo((Calendar)when) &gt; 0;
2793     }
2794 
2795     /**
2796      * Compares the time values (millisecond offsets from the &lt;a
2797      * href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) represented by two
<span class="line-modified">2798      * &lt;code&gt;Calendar&lt;/code&gt; objects.</span>
2799      *
<span class="line-modified">2800      * @param anotherCalendar the &lt;code&gt;Calendar&lt;/code&gt; to be compared.</span>
<span class="line-modified">2801      * @return the value &lt;code&gt;0&lt;/code&gt; if the time represented by the argument</span>
<span class="line-modified">2802      * is equal to the time represented by this &lt;code&gt;Calendar&lt;/code&gt;; a value</span>
<span class="line-modified">2803      * less than &lt;code&gt;0&lt;/code&gt; if the time of this &lt;code&gt;Calendar&lt;/code&gt; is</span>
2804      * before the time represented by the argument; and a value greater than
<span class="line-modified">2805      * &lt;code&gt;0&lt;/code&gt; if the time of this &lt;code&gt;Calendar&lt;/code&gt; is after the</span>
2806      * time represented by the argument.
<span class="line-modified">2807      * @exception NullPointerException if the specified &lt;code&gt;Calendar&lt;/code&gt; is</span>
<span class="line-modified">2808      *            &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">2809      * @exception IllegalArgumentException if the time value of the</span>
<span class="line-modified">2810      * specified &lt;code&gt;Calendar&lt;/code&gt; object can&#39;t be obtained due to</span>
2811      * any invalid calendar values.
2812      * @since   1.5
2813      */
2814     @Override
2815     public int compareTo(Calendar anotherCalendar) {
2816         return compareTo(getMillisOf(anotherCalendar));
2817     }
2818 
2819     /**
2820      * Adds or subtracts the specified amount of time to the given calendar field,
2821      * based on the calendar&#39;s rules. For example, to subtract 5 days from
2822      * the current time of the calendar, you can achieve it by calling:
<span class="line-modified">2823      * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;.</span>
2824      *
2825      * @param field the calendar field.
2826      * @param amount the amount of date or time to be added to the field.
2827      * @see #roll(int,int)
2828      * @see #set(int,int)
2829      */
2830     public abstract void add(int field, int amount);
2831 
2832     /**
2833      * Adds or subtracts (up/down) a single unit of time on the given time
2834      * field without changing larger fields. For example, to roll the current
2835      * date up by one day, you can achieve it by calling:
2836      * &lt;p&gt;roll(Calendar.DATE, true).
2837      * When rolling on the year or Calendar.YEAR field, it will roll the year
2838      * value in the range between 1 and the value returned by calling
<span class="line-modified">2839      * &lt;code&gt;getMaximum(Calendar.YEAR)&lt;/code&gt;.</span>
2840      * When rolling on the month or Calendar.MONTH field, other fields like
2841      * date might conflict and, need to be changed. For instance,
2842      * rolling the month on the date 01/31/96 will result in 02/29/96.
2843      * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will
2844      * roll the hour value in the range between 0 and 23, which is zero-based.
2845      *
2846      * @param field the time field.
2847      * @param up indicates if the value of the specified time field is to be
2848      * rolled up or rolled down. Use true if rolling up, false otherwise.
2849      * @see Calendar#add(int,int)
2850      * @see Calendar#set(int,int)
2851      */
2852     public abstract void roll(int field, boolean up);
2853 
2854     /**
2855      * Adds the specified (signed) amount to the specified calendar field
2856      * without changing larger fields.  A negative amount means to roll
2857      * down.
2858      *
<span class="line-modified">2859      * &lt;p&gt;NOTE:  This default implementation on &lt;code&gt;Calendar&lt;/code&gt; just repeatedly calls the</span>
2860      * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not
<span class="line-modified">2861      * always do the right thing.  For example, if the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field is 31,</span>
<span class="line-modified">2862      * rolling through February will leave it set to 28.  The &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
2863      * version of this function takes care of this problem.  Other subclasses
2864      * should also provide overrides of this function that do the right thing.
2865      *
2866      * @param field the calendar field.
<span class="line-modified">2867      * @param amount the signed amount to add to the calendar &lt;code&gt;field&lt;/code&gt;.</span>
2868      * @since 1.2
2869      * @see #roll(int,boolean)
2870      * @see #add(int,int)
2871      * @see #set(int,int)
2872      */
2873     public void roll(int field, int amount)
2874     {
2875         while (amount &gt; 0) {
2876             roll(field, true);
2877             amount--;
2878         }
2879         while (amount &lt; 0) {
2880             roll(field, false);
2881             amount++;
2882         }
2883     }
2884 
2885     /**
2886      * Sets the time zone with the given time zone value.
2887      *
</pre>
<hr />
<pre>
2910      */
2911     public TimeZone getTimeZone()
2912     {
2913         // If the TimeZone object is shared by other Calendar instances, then
2914         // create a clone.
2915         if (sharedZone) {
2916             zone = (TimeZone) zone.clone();
2917             sharedZone = false;
2918         }
2919         return zone;
2920     }
2921 
2922     /**
2923      * Returns the time zone (without cloning).
2924      */
2925     TimeZone getZone() {
2926         return zone;
2927     }
2928 
2929     /**
<span class="line-modified">2930      * Sets the sharedZone flag to &lt;code&gt;shared&lt;/code&gt;.</span>
2931      */
2932     void setZoneShared(boolean shared) {
2933         sharedZone = shared;
2934     }
2935 
2936     /**
2937      * Specifies whether or not date/time interpretation is to be lenient.  With
2938      * lenient interpretation, a date such as &quot;February 942, 1996&quot; will be
2939      * treated as being equivalent to the 941st day after February 1, 1996.
2940      * With strict (non-lenient) interpretation, such dates will cause an exception to be
2941      * thrown. The default is lenient.
2942      *
<span class="line-modified">2943      * @param lenient &lt;code&gt;true&lt;/code&gt; if the lenient mode is to be turned</span>
<span class="line-modified">2944      * on; &lt;code&gt;false&lt;/code&gt; if it is to be turned off.</span>
2945      * @see #isLenient()
2946      * @see java.text.DateFormat#setLenient
2947      */
2948     public void setLenient(boolean lenient)
2949     {
2950         this.lenient = lenient;
2951     }
2952 
2953     /**
2954      * Tells whether date/time interpretation is to be lenient.
2955      *
<span class="line-modified">2956      * @return &lt;code&gt;true&lt;/code&gt; if the interpretation mode of this calendar is lenient;</span>
<span class="line-modified">2957      * &lt;code&gt;false&lt;/code&gt; otherwise.</span>
2958      * @see #setLenient(boolean)
2959      */
2960     public boolean isLenient()
2961     {
2962         return lenient;
2963     }
2964 
2965     /**
<span class="line-modified">2966      * Sets what the first day of the week is; e.g., &lt;code&gt;SUNDAY&lt;/code&gt; in the U.S.,</span>
<span class="line-modified">2967      * &lt;code&gt;MONDAY&lt;/code&gt; in France.</span>
2968      *
2969      * @param value the given first day of the week.
2970      * @see #getFirstDayOfWeek()
2971      * @see #getMinimalDaysInFirstWeek()
2972      */
2973     public void setFirstDayOfWeek(int value)
2974     {
2975         if (firstDayOfWeek == value) {
2976             return;
2977         }
2978         firstDayOfWeek = value;
2979         invalidateWeekFields();
2980     }
2981 
2982     /**
<span class="line-modified">2983      * Gets what the first day of the week is; e.g., &lt;code&gt;SUNDAY&lt;/code&gt; in the U.S.,</span>
<span class="line-modified">2984      * &lt;code&gt;MONDAY&lt;/code&gt; in France.</span>
2985      *
2986      * @return the first day of the week.
2987      * @see #setFirstDayOfWeek(int)
2988      * @see #getMinimalDaysInFirstWeek()
2989      */
2990     public int getFirstDayOfWeek()
2991     {
2992         return firstDayOfWeek;
2993     }
2994 
2995     /**
2996      * Sets what the minimal days required in the first week of the year are;
2997      * For example, if the first week is defined as one that contains the first
2998      * day of the first month of a year, call this method with value 1. If it
2999      * must be a full week, use value 7.
3000      *
3001      * @param value the given minimal days required in the first week
3002      * of the year.
3003      * @see #getMinimalDaysInFirstWeek()
3004      */
</pre>
<hr />
<pre>
3035      *         {@code false} otherwise.
3036      * @see #getWeekYear()
3037      * @see #setWeekDate(int,int,int)
3038      * @see #getWeeksInWeekYear()
3039      * @since 1.7
3040      */
3041     public boolean isWeekDateSupported() {
3042         return false;
3043     }
3044 
3045     /**
3046      * Returns the week year represented by this {@code Calendar}. The
3047      * week year is in sync with the week cycle. The {@linkplain
3048      * #getFirstDayOfWeek() first day of the first week} is the first
3049      * day of the week year.
3050      *
3051      * &lt;p&gt;The default implementation of this method throws an
3052      * {@link UnsupportedOperationException}.
3053      *
3054      * @return the week year of this {@code Calendar}
<span class="line-modified">3055      * @exception UnsupportedOperationException</span>
3056      *            if any week year numbering isn&#39;t supported
3057      *            in this {@code Calendar}.
3058      * @see #isWeekDateSupported()
3059      * @see #getFirstDayOfWeek()
3060      * @see #getMinimalDaysInFirstWeek()
3061      * @since 1.7
3062      */
3063     public int getWeekYear() {
3064         throw new UnsupportedOperationException();
3065     }
3066 
3067     /**
3068      * Sets the date of this {@code Calendar} with the given date
3069      * specifiers - week year, week of year, and day of week.
3070      *
3071      * &lt;p&gt;Unlike the {@code set} method, all of the calendar fields
3072      * and {@code time} values are calculated upon return.
3073      *
3074      * &lt;p&gt;If {@code weekOfYear} is out of the valid week-of-year range
3075      * in {@code weekYear}, the {@code weekYear} and {@code
3076      * weekOfYear} values are adjusted in lenient mode, or an {@code
3077      * IllegalArgumentException} is thrown in non-lenient mode.
3078      *
3079      * &lt;p&gt;The default implementation of this method throws an
3080      * {@code UnsupportedOperationException}.
3081      *
3082      * @param weekYear   the week year
3083      * @param weekOfYear the week number based on {@code weekYear}
3084      * @param dayOfWeek  the day of week value: one of the constants
3085      *                   for the {@link #DAY_OF_WEEK} field: {@link
3086      *                   #SUNDAY}, ..., {@link #SATURDAY}.
<span class="line-modified">3087      * @exception IllegalArgumentException</span>
3088      *            if any of the given date specifiers is invalid
3089      *            or any of the calendar fields are inconsistent
3090      *            with the given date specifiers in non-lenient mode
<span class="line-modified">3091      * @exception UnsupportedOperationException</span>
3092      *            if any week year numbering isn&#39;t supported in this
3093      *            {@code Calendar}.
3094      * @see #isWeekDateSupported()
3095      * @see #getFirstDayOfWeek()
3096      * @see #getMinimalDaysInFirstWeek()
3097      * @since 1.7
3098      */
3099     public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
3100         throw new UnsupportedOperationException();
3101     }
3102 
3103     /**
3104      * Returns the number of weeks in the week year represented by this
3105      * {@code Calendar}.
3106      *
3107      * &lt;p&gt;The default implementation of this method throws an
3108      * {@code UnsupportedOperationException}.
3109      *
3110      * @return the number of weeks in the week year.
<span class="line-modified">3111      * @exception UnsupportedOperationException</span>
3112      *            if any week year numbering isn&#39;t supported in this
3113      *            {@code Calendar}.
3114      * @see #WEEK_OF_YEAR
3115      * @see #isWeekDateSupported()
3116      * @see #getWeekYear()
3117      * @see #getActualMaximum(int)
3118      * @since 1.7
3119      */
3120     public int getWeeksInWeekYear() {
3121         throw new UnsupportedOperationException();
3122     }
3123 
3124     /**
3125      * Returns the minimum value for the given calendar field of this
<span class="line-modified">3126      * &lt;code&gt;Calendar&lt;/code&gt; instance. The minimum value is defined as</span>
3127      * the smallest value returned by the {@link #get(int) get} method
3128      * for any possible time value.  The minimum value depends on
3129      * calendar system specific parameters of the instance.
3130      *
3131      * @param field the calendar field.
3132      * @return the minimum value for the given calendar field.
3133      * @see #getMaximum(int)
3134      * @see #getGreatestMinimum(int)
3135      * @see #getLeastMaximum(int)
3136      * @see #getActualMinimum(int)
3137      * @see #getActualMaximum(int)
3138      */
3139     public abstract int getMinimum(int field);
3140 
3141     /**
3142      * Returns the maximum value for the given calendar field of this
<span class="line-modified">3143      * &lt;code&gt;Calendar&lt;/code&gt; instance. The maximum value is defined as</span>
3144      * the largest value returned by the {@link #get(int) get} method
3145      * for any possible time value. The maximum value depends on
3146      * calendar system specific parameters of the instance.
3147      *
3148      * @param field the calendar field.
3149      * @return the maximum value for the given calendar field.
3150      * @see #getMinimum(int)
3151      * @see #getGreatestMinimum(int)
3152      * @see #getLeastMaximum(int)
3153      * @see #getActualMinimum(int)
3154      * @see #getActualMaximum(int)
3155      */
3156     public abstract int getMaximum(int field);
3157 
3158     /**
3159      * Returns the highest minimum value for the given calendar field
<span class="line-modified">3160      * of this &lt;code&gt;Calendar&lt;/code&gt; instance. The highest minimum</span>
3161      * value is defined as the largest value returned by {@link
3162      * #getActualMinimum(int)} for any possible time value. The
3163      * greatest minimum value depends on calendar system specific
3164      * parameters of the instance.
3165      *
3166      * @param field the calendar field.
3167      * @return the highest minimum value for the given calendar field.
3168      * @see #getMinimum(int)
3169      * @see #getMaximum(int)
3170      * @see #getLeastMaximum(int)
3171      * @see #getActualMinimum(int)
3172      * @see #getActualMaximum(int)
3173      */
3174     public abstract int getGreatestMinimum(int field);
3175 
3176     /**
3177      * Returns the lowest maximum value for the given calendar field
<span class="line-modified">3178      * of this &lt;code&gt;Calendar&lt;/code&gt; instance. The lowest maximum</span>
3179      * value is defined as the smallest value returned by {@link
3180      * #getActualMaximum(int)} for any possible time value. The least
3181      * maximum value depends on calendar system specific parameters of
<span class="line-modified">3182      * the instance. For example, a &lt;code&gt;Calendar&lt;/code&gt; for the</span>
3183      * Gregorian calendar system returns 28 for the
<span class="line-modified">3184      * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field, because the 28th is the last</span>
3185      * day of the shortest month of this calendar, February in a
3186      * common year.
3187      *
3188      * @param field the calendar field.
3189      * @return the lowest maximum value for the given calendar field.
3190      * @see #getMinimum(int)
3191      * @see #getMaximum(int)
3192      * @see #getGreatestMinimum(int)
3193      * @see #getActualMinimum(int)
3194      * @see #getActualMaximum(int)
3195      */
3196     public abstract int getLeastMaximum(int field);
3197 
3198     /**
3199      * Returns the minimum value that the specified calendar field
<span class="line-modified">3200      * could have, given the time value of this &lt;code&gt;Calendar&lt;/code&gt;.</span>
3201      *
3202      * &lt;p&gt;The default implementation of this method uses an iterative
3203      * algorithm to determine the actual minimum value for the
3204      * calendar field. Subclasses should, if possible, override this
3205      * with a more efficient implementation - in many cases, they can
<span class="line-modified">3206      * simply return &lt;code&gt;getMinimum()&lt;/code&gt;.</span>
3207      *
3208      * @param field the calendar field
3209      * @return the minimum of the given calendar field for the time
<span class="line-modified">3210      * value of this &lt;code&gt;Calendar&lt;/code&gt;</span>
3211      * @see #getMinimum(int)
3212      * @see #getMaximum(int)
3213      * @see #getGreatestMinimum(int)
3214      * @see #getLeastMaximum(int)
3215      * @see #getActualMaximum(int)
3216      * @since 1.2
3217      */
3218     public int getActualMinimum(int field) {
3219         int fieldValue = getGreatestMinimum(field);
3220         int endValue = getMinimum(field);
3221 
3222         // if we know that the minimum value is always the same, just return it
3223         if (fieldValue == endValue) {
3224             return fieldValue;
3225         }
3226 
3227         // clone the calendar so we don&#39;t mess with the real one, and set it to
3228         // accept anything for the field values
3229         Calendar work = (Calendar)this.clone();
3230         work.setLenient(true);
</pre>
<hr />
<pre>
3233         // we get a value that normalizes to another value.  The last value that
3234         // normalizes to itself is the actual minimum for the current date
3235         int result = fieldValue;
3236 
3237         do {
3238             work.set(field, fieldValue);
3239             if (work.get(field) != fieldValue) {
3240                 break;
3241             } else {
3242                 result = fieldValue;
3243                 fieldValue--;
3244             }
3245         } while (fieldValue &gt;= endValue);
3246 
3247         return result;
3248     }
3249 
3250     /**
3251      * Returns the maximum value that the specified calendar field
3252      * could have, given the time value of this
<span class="line-modified">3253      * &lt;code&gt;Calendar&lt;/code&gt;. For example, the actual maximum value of</span>
<span class="line-modified">3254      * the &lt;code&gt;MONTH&lt;/code&gt; field is 12 in some years, and 13 in</span>
3255      * other years in the Hebrew calendar system.
3256      *
3257      * &lt;p&gt;The default implementation of this method uses an iterative
3258      * algorithm to determine the actual maximum value for the
3259      * calendar field. Subclasses should, if possible, override this
3260      * with a more efficient implementation.
3261      *
3262      * @param field the calendar field
3263      * @return the maximum of the given calendar field for the time
<span class="line-modified">3264      * value of this &lt;code&gt;Calendar&lt;/code&gt;</span>
3265      * @see #getMinimum(int)
3266      * @see #getMaximum(int)
3267      * @see #getGreatestMinimum(int)
3268      * @see #getLeastMaximum(int)
3269      * @see #getActualMinimum(int)
3270      * @since 1.2
3271      */
3272     public int getActualMaximum(int field) {
3273         int fieldValue = getLeastMaximum(field);
3274         int endValue = getMaximum(field);
3275 
3276         // if we know that the maximum value is always the same, just return it.
3277         if (fieldValue == endValue) {
3278             return fieldValue;
3279         }
3280 
3281         // clone the calendar so we don&#39;t mess with the real one, and set it to
3282         // accept anything for the field values.
3283         Calendar work = (Calendar)this.clone();
3284         work.setLenient(true);
</pre>
<hr />
<pre>
3332             return other;
3333         }
3334         catch (CloneNotSupportedException e) {
3335             // this shouldn&#39;t happen, since we are Cloneable
3336             throw new InternalError(e);
3337         }
3338     }
3339 
3340     private static final String[] FIELD_NAME = {
3341         &quot;ERA&quot;, &quot;YEAR&quot;, &quot;MONTH&quot;, &quot;WEEK_OF_YEAR&quot;, &quot;WEEK_OF_MONTH&quot;, &quot;DAY_OF_MONTH&quot;,
3342         &quot;DAY_OF_YEAR&quot;, &quot;DAY_OF_WEEK&quot;, &quot;DAY_OF_WEEK_IN_MONTH&quot;, &quot;AM_PM&quot;, &quot;HOUR&quot;,
3343         &quot;HOUR_OF_DAY&quot;, &quot;MINUTE&quot;, &quot;SECOND&quot;, &quot;MILLISECOND&quot;, &quot;ZONE_OFFSET&quot;,
3344         &quot;DST_OFFSET&quot;
3345     };
3346 
3347     /**
3348      * Returns the name of the specified calendar field.
3349      *
3350      * @param field the calendar field
3351      * @return the calendar field name
<span class="line-modified">3352      * @exception IndexOutOfBoundsException if &lt;code&gt;field&lt;/code&gt; is negative,</span>
3353      * equal to or greater than {@code FIELD_COUNT}.
3354      */
3355     static String getFieldName(int field) {
3356         return FIELD_NAME[field];
3357     }
3358 
3359     /**
3360      * Return a string representation of this calendar. This method
3361      * is intended to be used only for debugging purposes, and the
3362      * format of the returned string may vary between implementations.
<span class="line-modified">3363      * The returned string may be empty but may not be &lt;code&gt;null&lt;/code&gt;.</span>
3364      *
3365      * @return  a string representation of this calendar.
3366      */
3367     @Override
3368     public String toString() {
3369         // NOTE: BuddhistCalendar.toString() interprets the string
3370         // produced by this method so that the Gregorian year number
3371         // is substituted by its B.E. year value. It relies on
3372         // &quot;...,YEAR=&lt;year&gt;,...&quot; or &quot;...,YEAR=?,...&quot;.
3373         StringBuilder buffer = new StringBuilder(800);
3374         buffer.append(getClass().getName()).append(&#39;[&#39;);
3375         appendValue(buffer, &quot;time&quot;, isTimeSet, time);
3376         buffer.append(&quot;,areFieldsSet=&quot;).append(areFieldsSet);
3377         buffer.append(&quot;,areAllFieldsSet=&quot;).append(areAllFieldsSet);
3378         buffer.append(&quot;,lenient=&quot;).append(lenient);
3379         buffer.append(&quot;,zone=&quot;).append(zone);
3380         appendValue(buffer, &quot;,firstDayOfWeek&quot;, true, (long) firstDayOfWeek);
3381         appendValue(buffer, &quot;,minimalDaysInFirstWeek&quot;, true, (long) minimalDaysInFirstWeek);
3382         for (int i = 0; i &lt; FIELD_COUNT; ++i) {
3383             buffer.append(&#39;,&#39;);
</pre>
<hr />
<pre>
3498         cal.clear(WEEK_OF_YEAR);
3499 
3500         if (stamp[WEEK_OF_MONTH] == COMPUTED) {
3501             int weekOfMonth = cal.get(WEEK_OF_MONTH);
3502             if (fields[WEEK_OF_MONTH] != weekOfMonth) {
3503                 fields[WEEK_OF_MONTH] = weekOfMonth;
3504             }
3505         }
3506 
3507         if (stamp[WEEK_OF_YEAR] == COMPUTED) {
3508             int weekOfYear = cal.get(WEEK_OF_YEAR);
3509             if (fields[WEEK_OF_YEAR] != weekOfYear) {
3510                 fields[WEEK_OF_YEAR] = weekOfYear;
3511             }
3512         }
3513     }
3514 
3515     /**
3516      * Save the state of this object to a stream (i.e., serialize it).
3517      *
<span class="line-modified">3518      * Ideally, &lt;code&gt;Calendar&lt;/code&gt; would only write out its state data and</span>
3519      * the current time, and not write any field data out, such as
<span class="line-modified">3520      * &lt;code&gt;fields[]&lt;/code&gt;, &lt;code&gt;isTimeSet&lt;/code&gt;, &lt;code&gt;areFieldsSet&lt;/code&gt;,</span>
<span class="line-modified">3521      * and &lt;code&gt;isSet[]&lt;/code&gt;.  &lt;code&gt;nextStamp&lt;/code&gt; also should not be part</span>
3522      * of the persistent state. Unfortunately, this didn&#39;t happen before JDK 1.1
3523      * shipped. To be compatible with JDK 1.1, we will always have to write out
<span class="line-modified">3524      * the field values and state flags.  However, &lt;code&gt;nextStamp&lt;/code&gt; can be</span>
3525      * removed from the serialization stream; this will probably happen in the
3526      * near future.
3527      */

3528     private synchronized void writeObject(ObjectOutputStream stream)
3529          throws IOException
3530     {
3531         // Try to compute the time correctly, for the future (stream
3532         // version 2) in which we don&#39;t write out fields[] or isSet[].
3533         if (!isTimeSet) {
3534             try {
3535                 updateTime();
3536             }
3537             catch (IllegalArgumentException e) {}
3538         }
3539 
3540         // If this Calendar has a ZoneInfo, save it and set a
3541         // SimpleTimeZone equivalent (as a single DST schedule) for
3542         // backward compatibility.
3543         TimeZone savedZone = null;
3544         if (zone instanceof ZoneInfo) {
3545             SimpleTimeZone stz = ((ZoneInfo)zone).getLastRuleInstance();
3546             if (stz == null) {
3547                 stz = new SimpleTimeZone(zone.getRawOffset(), zone.getID());
</pre>
<hr />
<pre>
3562         }
3563     }
3564 
3565     private static class CalendarAccessControlContext {
3566         private static final AccessControlContext INSTANCE;
3567         static {
3568             RuntimePermission perm = new RuntimePermission(&quot;accessClassInPackage.sun.util.calendar&quot;);
3569             PermissionCollection perms = perm.newPermissionCollection();
3570             perms.add(perm);
3571             INSTANCE = new AccessControlContext(new ProtectionDomain[] {
3572                                                     new ProtectionDomain(null, perms)
3573                                                 });
3574         }
3575         private CalendarAccessControlContext() {
3576         }
3577     }
3578 
3579     /**
3580      * Reconstitutes this object from a stream (i.e., deserialize it).
3581      */

3582     private void readObject(ObjectInputStream stream)
3583          throws IOException, ClassNotFoundException
3584     {
3585         final ObjectInputStream input = stream;
3586         input.defaultReadObject();
3587 
3588         stamp = new int[FIELD_COUNT];
3589 
3590         // Starting with version 2 (not implemented yet), we expect that
3591         // fields[], isSet[], isTimeSet, and areFieldsSet may not be
3592         // streamed out anymore.  We expect &#39;time&#39; to be correct.
3593         if (serialVersionOnStream &gt;= 2)
3594         {
3595             isTimeSet = true;
3596             if (fields == null) {
3597                 fields = new int[FIELD_COUNT];
3598             }
3599             if (isSet == null) {
3600                 isSet = new boolean[FIELD_COUNT];
3601             }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  45 import java.io.Serializable;
  46 import java.security.AccessControlContext;
  47 import java.security.AccessController;
  48 import java.security.PermissionCollection;
  49 import java.security.PrivilegedActionException;
  50 import java.security.PrivilegedExceptionAction;
  51 import java.security.ProtectionDomain;
  52 import java.text.DateFormat;
  53 import java.text.DateFormatSymbols;
  54 import java.time.Instant;
  55 import java.util.concurrent.ConcurrentHashMap;
  56 import java.util.concurrent.ConcurrentMap;
  57 import sun.util.BuddhistCalendar;
  58 import sun.util.calendar.ZoneInfo;
  59 import sun.util.locale.provider.CalendarDataUtility;
  60 import sun.util.locale.provider.LocaleProviderAdapter;
  61 import sun.util.locale.provider.TimeZoneNameUtility;
  62 import sun.util.spi.CalendarProvider;
  63 
  64 /**
<span class="line-modified">  65  * The {@code Calendar} class is an abstract class that provides methods</span>
  66  * for converting between a specific instant in time and a set of {@link
<span class="line-modified">  67  * #fields calendar fields} such as {@code YEAR}, {@code MONTH},</span>
<span class="line-modified">  68  * {@code DAY_OF_MONTH}, {@code HOUR}, and so on, and for</span>
  69  * manipulating the calendar fields, such as getting the date of the next
  70  * week. An instant in time can be represented by a millisecond value that is
  71  * an offset from the &lt;a id=&quot;Epoch&quot;&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970
  72  * 00:00:00.000 GMT (Gregorian).
  73  *
  74  * &lt;p&gt;The class also provides additional fields and methods for
  75  * implementing a concrete calendar system outside the package. Those
<span class="line-modified">  76  * fields and methods are defined as {@code protected}.</span>
  77  *
  78  * &lt;p&gt;
<span class="line-modified">  79  * Like other locale-sensitive classes, {@code Calendar} provides a</span>
<span class="line-modified">  80  * class method, {@code getInstance}, for getting a generally useful</span>
<span class="line-modified">  81  * object of this type. {@code Calendar}&#39;s {@code getInstance} method</span>
<span class="line-modified">  82  * returns a {@code Calendar} object whose</span>
  83  * calendar fields have been initialized with the current date and time:
  84  * &lt;blockquote&gt;
  85  * &lt;pre&gt;
  86  *     Calendar rightNow = Calendar.getInstance();
  87  * &lt;/pre&gt;
  88  * &lt;/blockquote&gt;
  89  *
<span class="line-modified">  90  * &lt;p&gt;A {@code Calendar} object can produce all the calendar field values</span>
  91  * needed to implement the date-time formatting for a particular language and
  92  * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
<span class="line-modified">  93  * {@code Calendar} defines the range of values returned by</span>
  94  * certain calendar fields, as well as their meaning.  For example,
  95  * the first month of the calendar system has value &lt;code&gt;MONTH ==
  96  * JANUARY&lt;/code&gt; for all calendars.  Other values are defined by the
<span class="line-modified">  97  * concrete subclass, such as {@code ERA}.  See individual field</span>
  98  * documentation and subclass documentation for details.
  99  *
<span class="line-modified"> 100  * &lt;h2&gt;Getting and Setting Calendar Field Values&lt;/h2&gt;</span>
 101  *
<span class="line-modified"> 102  * &lt;p&gt;The calendar field values can be set by calling the {@code set}</span>
<span class="line-modified"> 103  * methods. Any field values set in a {@code Calendar} will not be</span>
 104  * interpreted until it needs to calculate its time value (milliseconds from
 105  * the Epoch) or values of the calendar fields. Calling the
<span class="line-modified"> 106  * {@code get}, {@code getTimeInMillis}, {@code getTime},</span>
<span class="line-modified"> 107  * {@code add} and {@code roll} involves such calculation.</span>
 108  *
<span class="line-modified"> 109  * &lt;h3&gt;Leniency&lt;/h3&gt;</span>
 110  *
<span class="line-modified"> 111  * &lt;p&gt;{@code Calendar} has two modes for interpreting the calendar</span>
 112  * fields, &lt;em&gt;lenient&lt;/em&gt; and &lt;em&gt;non-lenient&lt;/em&gt;.  When a
<span class="line-modified"> 113  * {@code Calendar} is in lenient mode, it accepts a wider range of</span>
<span class="line-modified"> 114  * calendar field values than it produces.  When a {@code Calendar}</span>
<span class="line-modified"> 115  * recomputes calendar field values for return by {@code get()}, all of</span>
 116  * the calendar fields are normalized. For example, a lenient
<span class="line-modified"> 117  * {@code GregorianCalendar} interprets {@code MONTH == JANUARY},</span>
<span class="line-modified"> 118  * {@code DAY_OF_MONTH == 32} as February 1.</span>
 119 
<span class="line-modified"> 120  * &lt;p&gt;When a {@code Calendar} is in non-lenient mode, it throws an</span>
 121  * exception if there is any inconsistency in its calendar fields. For
<span class="line-modified"> 122  * example, a {@code GregorianCalendar} always produces</span>
<span class="line-modified"> 123  * {@code DAY_OF_MONTH} values between 1 and the length of the month. A</span>
<span class="line-modified"> 124  * non-lenient {@code GregorianCalendar} throws an exception upon</span>
 125  * calculating its time or calendar field values if any out-of-range field
 126  * value has been set.
 127  *
<span class="line-modified"> 128  * &lt;h3&gt;&lt;a id=&quot;first_week&quot;&gt;First Week&lt;/a&gt;&lt;/h3&gt;</span>
 129  *
<span class="line-modified"> 130  * {@code Calendar} defines a locale-specific seven day week using two</span>
 131  * parameters: the first day of the week and the minimal days in first week
 132  * (from 1 to 7).  These numbers are taken from the locale resource data or the
 133  * locale itself when a {@code Calendar} is constructed. If the designated
 134  * locale contains &quot;fw&quot; and/or &quot;rg&quot; &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;
 135  * Unicode extensions&lt;/a&gt;, the first day of the week will be obtained according to
 136  * those extensions. If both &quot;fw&quot; and &quot;rg&quot; are specified, the value from the &quot;fw&quot;
 137  * extension supersedes the implicit one from the &quot;rg&quot; extension.
 138  * They may also be specified explicitly through the methods for setting their
 139  * values.
 140  *
<span class="line-modified"> 141  * &lt;p&gt;When setting or getting the {@code WEEK_OF_MONTH} or</span>
<span class="line-modified"> 142  * {@code WEEK_OF_YEAR} fields, {@code Calendar} must determine the</span>
 143  * first week of the month or year as a reference point.  The first week of a
 144  * month or year is defined as the earliest seven day period beginning on
<span class="line-modified"> 145  * {@code getFirstDayOfWeek()} and containing at least</span>
<span class="line-modified"> 146  * {@code getMinimalDaysInFirstWeek()} days of that month or year.  Weeks</span>
 147  * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
<span class="line-modified"> 148  * it.  Note that the normalized numbering returned by {@code get()} may be</span>
<span class="line-modified"> 149  * different.  For example, a specific {@code Calendar} subclass may</span>
 150  * designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of
 151  * the previous year.
 152  *
<span class="line-modified"> 153  * &lt;h3&gt;Calendar Fields Resolution&lt;/h3&gt;</span>
 154  *
 155  * When computing a date and time from the calendar fields, there
 156  * may be insufficient information for the computation (such as only
 157  * year and month with no day of month), or there may be inconsistent
 158  * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,
<span class="line-modified"> 159  * 1996 is actually a Monday). {@code Calendar} will resolve</span>
 160  * calendar field values to determine the date and time in the
 161  * following way.
 162  *
 163  * &lt;p&gt;&lt;a id=&quot;resolution&quot;&gt;If there is any conflict in calendar field values,
<span class="line-modified"> 164  * {@code Calendar} gives priorities to calendar fields that have been set</span>
 165  * more recently.&lt;/a&gt; The following are the default combinations of the
 166  * calendar fields. The most recent combination, as determined by the
 167  * most recently set single field, will be used.
 168  *
 169  * &lt;p&gt;&lt;a id=&quot;date_resolution&quot;&gt;For the date fields&lt;/a&gt;:
 170  * &lt;blockquote&gt;
 171  * &lt;pre&gt;
 172  * YEAR + MONTH + DAY_OF_MONTH
 173  * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
 174  * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
 175  * YEAR + DAY_OF_YEAR
 176  * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
 177  * &lt;/pre&gt;&lt;/blockquote&gt;
 178  *
 179  * &lt;a id=&quot;time_resolution&quot;&gt;For the time of day fields&lt;/a&gt;:
 180  * &lt;blockquote&gt;
 181  * &lt;pre&gt;
 182  * HOUR_OF_DAY
 183  * AM_PM + HOUR
 184  * &lt;/pre&gt;&lt;/blockquote&gt;
 185  *
 186  * &lt;p&gt;If there are any calendar fields whose values haven&#39;t been set in the selected
<span class="line-modified"> 187  * field combination, {@code Calendar} uses their default values. The default</span>
 188  * value of each field may vary by concrete calendar systems. For example, in
<span class="line-modified"> 189  * {@code GregorianCalendar}, the default of a field is the same as that</span>
<span class="line-modified"> 190  * of the start of the Epoch: i.e., {@code YEAR = 1970}, &lt;code&gt;MONTH =</span>
<span class="line-modified"> 191  * JANUARY&lt;/code&gt;, {@code DAY_OF_MONTH = 1}, etc.</span>
 192  *
 193  * &lt;p&gt;
 194  * &lt;strong&gt;Note:&lt;/strong&gt; There are certain possible ambiguities in
 195  * interpretation of certain singular times, which are resolved in the
 196  * following ways:
 197  * &lt;ol&gt;
 198  *     &lt;li&gt; 23:59 is the last minute of the day and 00:00 is the first
 199  *          minute of the next day. Thus, 23:59 on Dec 31, 1999 &amp;lt; 00:00 on
 200  *          Jan 1, 2000 &amp;lt; 00:01 on Jan 1, 2000.
 201  *
 202  *     &lt;li&gt; Although historically not precise, midnight also belongs to &quot;am&quot;,
 203  *          and noon belongs to &quot;pm&quot;, so on the same day,
 204  *          12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm
 205  * &lt;/ol&gt;
 206  *
 207  * &lt;p&gt;
 208  * The date or time format strings are not part of the definition of a
 209  * calendar, as those must be modifiable or overridable by the user at
 210  * runtime. Use {@link DateFormat}
 211  * to format dates.
 212  *
<span class="line-modified"> 213  * &lt;h3&gt;Field Manipulation&lt;/h3&gt;</span>
 214  *
 215  * The calendar fields can be changed using three methods:
<span class="line-modified"> 216  * {@code set()}, {@code add()}, and {@code roll()}.</span>
 217  *
<span class="line-modified"> 218  * &lt;p&gt;&lt;strong&gt;{@code set(f, value)}&lt;/strong&gt; changes calendar field</span>
<span class="line-modified"> 219  * {@code f} to {@code value}.  In addition, it sets an</span>
<span class="line-modified"> 220  * internal member variable to indicate that calendar field {@code f} has</span>
<span class="line-modified"> 221  * been changed. Although calendar field {@code f} is changed immediately,</span>
 222  * the calendar&#39;s time value in milliseconds is not recomputed until the next call to
<span class="line-modified"> 223  * {@code get()}, {@code getTime()}, {@code getTimeInMillis()},</span>
<span class="line-modified"> 224  * {@code add()}, or {@code roll()} is made. Thus, multiple calls to</span>
<span class="line-modified"> 225  * {@code set()} do not trigger multiple, unnecessary</span>
 226  * computations. As a result of changing a calendar field using
<span class="line-modified"> 227  * {@code set()}, other calendar fields may also change, depending on the</span>
 228  * calendar field, the calendar field value, and the calendar system. In addition,
<span class="line-modified"> 229  * {@code get(f)} will not necessarily return {@code value} set by</span>
<span class="line-modified"> 230  * the call to the {@code set} method</span>
 231  * after the calendar fields have been recomputed. The specifics are determined by
 232  * the concrete calendar class.&lt;/p&gt;
 233  *
<span class="line-modified"> 234  * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a {@code GregorianCalendar}</span>
 235  * originally set to August 31, 1999. Calling &lt;code&gt;set(Calendar.MONTH,
 236  * Calendar.SEPTEMBER)&lt;/code&gt; sets the date to September 31,
 237  * 1999. This is a temporary internal representation that resolves to
<span class="line-modified"> 238  * October 1, 1999 if {@code getTime()}is then called. However, a</span>
<span class="line-modified"> 239  * call to {@code set(Calendar.DAY_OF_MONTH, 30)} before the call to</span>
<span class="line-modified"> 240  * {@code getTime()} sets the date to September 30, 1999, since</span>
<span class="line-modified"> 241  * no recomputation occurs after {@code set()} itself.&lt;/p&gt;</span>
 242  *
<span class="line-modified"> 243  * &lt;p&gt;&lt;strong&gt;{@code add(f, delta)}&lt;/strong&gt; adds {@code delta}</span>
<span class="line-modified"> 244  * to field {@code f}.  This is equivalent to calling &lt;code&gt;set(f,</span>
 245  * get(f) + delta)&lt;/code&gt; with two adjustments:&lt;/p&gt;
 246  *
 247  * &lt;blockquote&gt;
<span class="line-modified"> 248  *   &lt;p&gt;&lt;strong&gt;Add rule 1&lt;/strong&gt;. The value of field {@code f}</span>
<span class="line-modified"> 249  *   after the call minus the value of field {@code f} before the</span>
<span class="line-modified"> 250  *   call is {@code delta}, modulo any overflow that has occurred in</span>
<span class="line-modified"> 251  *   field {@code f}. Overflow occurs when a field value exceeds its</span>
 252  *   range and, as a result, the next larger field is incremented or
 253  *   decremented and the field value is adjusted back into its range.&lt;/p&gt;
 254  *
 255  *   &lt;p&gt;&lt;strong&gt;Add rule 2&lt;/strong&gt;. If a smaller field is expected to be
 256  *   invariant, but it is impossible for it to be equal to its
 257  *   prior value because of changes in its minimum or maximum after field
<span class="line-modified"> 258  *   {@code f} is changed or other constraints, such as time zone</span>
 259  *   offset changes, then its value is adjusted to be as close
 260  *   as possible to its expected value. A smaller field represents a
<span class="line-modified"> 261  *   smaller unit of time. {@code HOUR} is a smaller field than</span>
<span class="line-modified"> 262  *   {@code DAY_OF_MONTH}. No adjustment is made to smaller fields</span>
 263  *   that are not expected to be invariant. The calendar system
 264  *   determines what fields are expected to be invariant.&lt;/p&gt;
 265  * &lt;/blockquote&gt;
 266  *
<span class="line-modified"> 267  * &lt;p&gt;In addition, unlike {@code set()}, {@code add()} forces</span>
 268  * an immediate recomputation of the calendar&#39;s milliseconds and all
 269  * fields.&lt;/p&gt;
 270  *
<span class="line-modified"> 271  * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a {@code GregorianCalendar}</span>
 272  * originally set to August 31, 1999. Calling &lt;code&gt;add(Calendar.MONTH,
 273  * 13)&lt;/code&gt; sets the calendar to September 30, 2000. &lt;strong&gt;Add rule
<span class="line-modified"> 274  * 1&lt;/strong&gt; sets the {@code MONTH} field to September, since</span>
 275  * adding 13 months to August gives September of the next year. Since
<span class="line-modified"> 276  * {@code DAY_OF_MONTH} cannot be 31 in September in a</span>
<span class="line-modified"> 277  * {@code GregorianCalendar}, &lt;strong&gt;add rule 2&lt;/strong&gt; sets the</span>
<span class="line-modified"> 278  * {@code DAY_OF_MONTH} to 30, the closest possible value. Although</span>
<span class="line-modified"> 279  * it is a smaller field, {@code DAY_OF_WEEK} is not adjusted by</span>
 280  * rule 2, since it is expected to change when the month changes in a
<span class="line-modified"> 281  * {@code GregorianCalendar}.&lt;/p&gt;</span>
 282  *
<span class="line-modified"> 283  * &lt;p&gt;&lt;strong&gt;{@code roll(f, delta)}&lt;/strong&gt; adds</span>
<span class="line-modified"> 284  * {@code delta} to field {@code f} without changing larger</span>
<span class="line-modified"> 285  * fields. This is equivalent to calling {@code add(f, delta)} with</span>
 286  * the following adjustment:&lt;/p&gt;
 287  *
 288  * &lt;blockquote&gt;
 289  *   &lt;p&gt;&lt;strong&gt;Roll rule&lt;/strong&gt;. Larger fields are unchanged after the
 290  *   call. A larger field represents a larger unit of
<span class="line-modified"> 291  *   time. {@code DAY_OF_MONTH} is a larger field than</span>
<span class="line-modified"> 292  *   {@code HOUR}.&lt;/p&gt;</span>
 293  * &lt;/blockquote&gt;
 294  *
 295  * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: See {@link java.util.GregorianCalendar#roll(int, int)}.
 296  *
 297  * &lt;p&gt;&lt;strong&gt;Usage model&lt;/strong&gt;. To motivate the behavior of
<span class="line-modified"> 298  * {@code add()} and {@code roll()}, consider a user interface</span>
 299  * component with increment and decrement buttons for the month, day, and
<span class="line-modified"> 300  * year, and an underlying {@code GregorianCalendar}. If the</span>
 301  * interface reads January 31, 1999 and the user presses the month
 302  * increment button, what should it read? If the underlying
<span class="line-modified"> 303  * implementation uses {@code set()}, it might read March 3, 1999. A</span>
 304  * better result would be February 28, 1999. Furthermore, if the user
 305  * presses the month increment button again, it should read March 31,
 306  * 1999, not March 28, 1999. By saving the original date and using either
<span class="line-modified"> 307  * {@code add()} or {@code roll()}, depending on whether larger</span>
 308  * fields should be affected, the user interface can behave as most users
 309  * will intuitively expect.&lt;/p&gt;
 310  *
 311  * @see          java.lang.System#currentTimeMillis()
 312  * @see          Date
 313  * @see          GregorianCalendar
 314  * @see          TimeZone
 315  * @see          java.text.DateFormat
 316  * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
 317  * @since 1.1
 318  */
 319 public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {
 320 
 321     // Data flow in Calendar
 322     // ---------------------
 323 
 324     // The current time is represented in two ways by Calendar: as UTC
 325     // milliseconds from the epoch (1 January 1970 0:00 UTC), and as local
 326     // fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the
 327     // millis from the fields, and vice versa.  The data needed to do this
</pre>
<hr />
<pre>
 352     // subclass&#39;s computeFields() method.
 353 
 354     //   UTC millis (in time data member)
 355     //           |
 356     //           | Using TimeZone getOffset()
 357     //           V
 358     //   local standard millis
 359     //           |
 360     //           | Using Calendar-specific algorithm
 361     //           V
 362     //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
 363 
 364     // In general, a round trip from fields, through local and UTC millis, and
 365     // back out to fields is made when necessary.  This is implemented by the
 366     // complete() method.  Resolving a partial set of fields into a UTC millis
 367     // value allows all remaining fields to be generated from that value.  If
 368     // the Calendar is lenient, the fields are also renormalized to standard
 369     // ranges when they are regenerated.
 370 
 371     /**
<span class="line-modified"> 372      * Field number for {@code get} and {@code set} indicating the</span>
 373      * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
 374      * value; see subclass documentation.
 375      *
 376      * @see GregorianCalendar#AD
 377      * @see GregorianCalendar#BC
 378      */
 379     public static final int ERA = 0;
 380 
 381     /**
<span class="line-modified"> 382      * Field number for {@code get} and {@code set} indicating the</span>
 383      * year. This is a calendar-specific value; see subclass documentation.
 384      */
 385     public static final int YEAR = 1;
 386 
 387     /**
<span class="line-modified"> 388      * Field number for {@code get} and {@code set} indicating the</span>
 389      * month. This is a calendar-specific value. The first month of
 390      * the year in the Gregorian and Julian calendars is
<span class="line-modified"> 391      * {@code JANUARY} which is 0; the last depends on the number</span>
 392      * of months in a year.
 393      *
 394      * @see #JANUARY
 395      * @see #FEBRUARY
 396      * @see #MARCH
 397      * @see #APRIL
 398      * @see #MAY
 399      * @see #JUNE
 400      * @see #JULY
 401      * @see #AUGUST
 402      * @see #SEPTEMBER
 403      * @see #OCTOBER
 404      * @see #NOVEMBER
 405      * @see #DECEMBER
 406      * @see #UNDECIMBER
 407      */
 408     public static final int MONTH = 2;
 409 
 410     /**
<span class="line-modified"> 411      * Field number for {@code get} and {@code set} indicating the</span>
 412      * week number within the current year.  The first week of the year, as
<span class="line-modified"> 413      * defined by {@code getFirstDayOfWeek()} and</span>
<span class="line-modified"> 414      * {@code getMinimalDaysInFirstWeek()}, has value 1.  Subclasses define</span>
<span class="line-modified"> 415      * the value of {@code WEEK_OF_YEAR} for days before the first week of</span>
 416      * the year.
 417      *
 418      * @see #getFirstDayOfWeek
 419      * @see #getMinimalDaysInFirstWeek
 420      */
 421     public static final int WEEK_OF_YEAR = 3;
 422 
 423     /**
<span class="line-modified"> 424      * Field number for {@code get} and {@code set} indicating the</span>
 425      * week number within the current month.  The first week of the month, as
<span class="line-modified"> 426      * defined by {@code getFirstDayOfWeek()} and</span>
<span class="line-modified"> 427      * {@code getMinimalDaysInFirstWeek()}, has value 1.  Subclasses define</span>
<span class="line-modified"> 428      * the value of {@code WEEK_OF_MONTH} for days before the first week of</span>
 429      * the month.
 430      *
 431      * @see #getFirstDayOfWeek
 432      * @see #getMinimalDaysInFirstWeek
 433      */
 434     public static final int WEEK_OF_MONTH = 4;
 435 
 436     /**
<span class="line-modified"> 437      * Field number for {@code get} and {@code set} indicating the</span>
<span class="line-modified"> 438      * day of the month. This is a synonym for {@code DAY_OF_MONTH}.</span>
 439      * The first day of the month has value 1.
 440      *
 441      * @see #DAY_OF_MONTH
 442      */
 443     public static final int DATE = 5;
 444 
 445     /**
<span class="line-modified"> 446      * Field number for {@code get} and {@code set} indicating the</span>
<span class="line-modified"> 447      * day of the month. This is a synonym for {@code DATE}.</span>
 448      * The first day of the month has value 1.
 449      *
 450      * @see #DATE
 451      */
 452     public static final int DAY_OF_MONTH = 5;
 453 
 454     /**
<span class="line-modified"> 455      * Field number for {@code get} and {@code set} indicating the day</span>
 456      * number within the current year.  The first day of the year has value 1.
 457      */
 458     public static final int DAY_OF_YEAR = 6;
 459 
 460     /**
<span class="line-modified"> 461      * Field number for {@code get} and {@code set} indicating the day</span>
<span class="line-modified"> 462      * of the week.  This field takes values {@code SUNDAY},</span>
<span class="line-modified"> 463      * {@code MONDAY}, {@code TUESDAY}, {@code WEDNESDAY},</span>
<span class="line-modified"> 464      * {@code THURSDAY}, {@code FRIDAY}, and {@code SATURDAY}.</span>
 465      *
 466      * @see #SUNDAY
 467      * @see #MONDAY
 468      * @see #TUESDAY
 469      * @see #WEDNESDAY
 470      * @see #THURSDAY
 471      * @see #FRIDAY
 472      * @see #SATURDAY
 473      */
 474     public static final int DAY_OF_WEEK = 7;
 475 
 476     /**
<span class="line-modified"> 477      * Field number for {@code get} and {@code set} indicating the</span>
 478      * ordinal number of the day of the week within the current month. Together
<span class="line-modified"> 479      * with the {@code DAY_OF_WEEK} field, this uniquely specifies a day</span>
<span class="line-modified"> 480      * within a month.  Unlike {@code WEEK_OF_MONTH} and</span>
<span class="line-modified"> 481      * {@code WEEK_OF_YEAR}, this field&#39;s value does &lt;em&gt;not&lt;/em&gt; depend on</span>
<span class="line-modified"> 482      * {@code getFirstDayOfWeek()} or</span>
<span class="line-modified"> 483      * {@code getMinimalDaysInFirstWeek()}.  {@code DAY_OF_MONTH 1}</span>
<span class="line-modified"> 484      * through {@code 7} always correspond to &lt;code&gt;DAY_OF_WEEK_IN_MONTH</span>
<span class="line-modified"> 485      * 1&lt;/code&gt;; {@code 8} through {@code 14} correspond to</span>
<span class="line-modified"> 486      * {@code DAY_OF_WEEK_IN_MONTH 2}, and so on.</span>
<span class="line-modified"> 487      * {@code DAY_OF_WEEK_IN_MONTH 0} indicates the week before</span>
<span class="line-modified"> 488      * {@code DAY_OF_WEEK_IN_MONTH 1}.  Negative values count back from the</span>
 489      * end of the month, so the last Sunday of a month is specified as
<span class="line-modified"> 490      * {@code DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1}.  Because</span>
 491      * negative values count backward they will usually be aligned differently
 492      * within the month than positive values.  For example, if a month has 31
<span class="line-modified"> 493      * days, {@code DAY_OF_WEEK_IN_MONTH -1} will overlap</span>
<span class="line-modified"> 494      * {@code DAY_OF_WEEK_IN_MONTH 5} and the end of {@code 4}.</span>
 495      *
 496      * @see #DAY_OF_WEEK
 497      * @see #WEEK_OF_MONTH
 498      */
 499     public static final int DAY_OF_WEEK_IN_MONTH = 8;
 500 
 501     /**
<span class="line-modified"> 502      * Field number for {@code get} and {@code set} indicating</span>
<span class="line-modified"> 503      * whether the {@code HOUR} is before or after noon.</span>
<span class="line-modified"> 504      * E.g., at 10:04:15.250 PM the {@code AM_PM} is {@code PM}.</span>
 505      *
 506      * @see #AM
 507      * @see #PM
 508      * @see #HOUR
 509      */
 510     public static final int AM_PM = 9;
 511 
 512     /**
<span class="line-modified"> 513      * Field number for {@code get} and {@code set} indicating the</span>
<span class="line-modified"> 514      * hour of the morning or afternoon. {@code HOUR} is used for the</span>
 515      * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.
<span class="line-modified"> 516      * E.g., at 10:04:15.250 PM the {@code HOUR} is 10.</span>
 517      *
 518      * @see #AM_PM
 519      * @see #HOUR_OF_DAY
 520      */
 521     public static final int HOUR = 10;
 522 
 523     /**
<span class="line-modified"> 524      * Field number for {@code get} and {@code set} indicating the</span>
<span class="line-modified"> 525      * hour of the day. {@code HOUR_OF_DAY} is used for the 24-hour clock.</span>
<span class="line-modified"> 526      * E.g., at 10:04:15.250 PM the {@code HOUR_OF_DAY} is 22.</span>
 527      *
 528      * @see #HOUR
 529      */
 530     public static final int HOUR_OF_DAY = 11;
 531 
 532     /**
<span class="line-modified"> 533      * Field number for {@code get} and {@code set} indicating the</span>
 534      * minute within the hour.
<span class="line-modified"> 535      * E.g., at 10:04:15.250 PM the {@code MINUTE} is 4.</span>
 536      */
 537     public static final int MINUTE = 12;
 538 
 539     /**
<span class="line-modified"> 540      * Field number for {@code get} and {@code set} indicating the</span>
 541      * second within the minute.
<span class="line-modified"> 542      * E.g., at 10:04:15.250 PM the {@code SECOND} is 15.</span>
 543      */
 544     public static final int SECOND = 13;
 545 
 546     /**
<span class="line-modified"> 547      * Field number for {@code get} and {@code set} indicating the</span>
 548      * millisecond within the second.
<span class="line-modified"> 549      * E.g., at 10:04:15.250 PM the {@code MILLISECOND} is 250.</span>
 550      */
 551     public static final int MILLISECOND = 14;
 552 
 553     /**
<span class="line-modified"> 554      * Field number for {@code get} and {@code set}</span>
 555      * indicating the raw offset from GMT in milliseconds.
 556      * &lt;p&gt;
 557      * This field reflects the correct GMT offset value of the time
<span class="line-modified"> 558      * zone of this {@code Calendar} if the</span>
<span class="line-modified"> 559      * {@code TimeZone} implementation subclass supports</span>
 560      * historical GMT offset changes.
 561      */
 562     public static final int ZONE_OFFSET = 15;
 563 
 564     /**
<span class="line-modified"> 565      * Field number for {@code get} and {@code set} indicating the</span>
 566      * daylight saving offset in milliseconds.
 567      * &lt;p&gt;
 568      * This field reflects the correct daylight saving offset value of
<span class="line-modified"> 569      * the time zone of this {@code Calendar} if the</span>
<span class="line-modified"> 570      * {@code TimeZone} implementation subclass supports</span>
 571      * historical Daylight Saving Time schedule changes.
 572      */
 573     public static final int DST_OFFSET = 16;
 574 
 575     /**
<span class="line-modified"> 576      * The number of distinct fields recognized by {@code get} and {@code set}.</span>
<span class="line-modified"> 577      * Field numbers range from {@code 0..FIELD_COUNT-1}.</span>
 578      */
 579     public static final int FIELD_COUNT = 17;
 580 
 581     /**
 582      * Value of the {@link #DAY_OF_WEEK} field indicating
 583      * Sunday.
 584      */
 585     public static final int SUNDAY = 1;
 586 
 587     /**
 588      * Value of the {@link #DAY_OF_WEEK} field indicating
 589      * Monday.
 590      */
 591     public static final int MONDAY = 2;
 592 
 593     /**
 594      * Value of the {@link #DAY_OF_WEEK} field indicating
 595      * Tuesday.
 596      */
 597     public static final int TUESDAY = 3;
</pre>
<hr />
<pre>
 677     /**
 678      * Value of the {@link #MONTH} field indicating the
 679      * tenth month of the year in the Gregorian and Julian calendars.
 680      */
 681     public static final int OCTOBER = 9;
 682 
 683     /**
 684      * Value of the {@link #MONTH} field indicating the
 685      * eleventh month of the year in the Gregorian and Julian calendars.
 686      */
 687     public static final int NOVEMBER = 10;
 688 
 689     /**
 690      * Value of the {@link #MONTH} field indicating the
 691      * twelfth month of the year in the Gregorian and Julian calendars.
 692      */
 693     public static final int DECEMBER = 11;
 694 
 695     /**
 696      * Value of the {@link #MONTH} field indicating the
<span class="line-modified"> 697      * thirteenth month of the year. Although {@code GregorianCalendar}</span>
 698      * does not use this value, lunar calendars do.
 699      */
 700     public static final int UNDECIMBER = 12;
 701 
 702     /**
 703      * Value of the {@link #AM_PM} field indicating the
 704      * period of the day from midnight to just before noon.
 705      */
 706     public static final int AM = 0;
 707 
 708     /**
 709      * Value of the {@link #AM_PM} field indicating the
 710      * period of the day from noon to just before midnight.
 711      */
 712     public static final int PM = 1;
 713 
 714     /**
 715      * A style specifier for {@link #getDisplayNames(int, int, Locale)
 716      * getDisplayNames} indicating names in all styles, such as
 717      * &quot;January&quot; and &quot;Jan&quot;.
</pre>
<hr />
<pre>
 822      * @see #LONG_FORMAT
 823      * @see #SHORT_FORMAT
 824      * @see #SHORT_STANDALONE
 825      * @since 1.8
 826      */
 827     public static final int LONG_STANDALONE = LONG | STANDALONE_MASK;
 828 
 829     // Internal notes:
 830     // Calendar contains two kinds of time representations: current &quot;time&quot; in
 831     // milliseconds, and a set of calendar &quot;fields&quot; representing the current time.
 832     // The two representations are usually in sync, but can get out of sync
 833     // as follows.
 834     // 1. Initially, no fields are set, and the time is invalid.
 835     // 2. If the time is set, all fields are computed and in sync.
 836     // 3. If a single field is set, the time is invalid.
 837     // Recomputation of the time and fields happens when the object needs
 838     // to return a result to the user, or use a result for a computation.
 839 
 840     /**
 841      * The calendar field values for the currently set time for this calendar.
<span class="line-modified"> 842      * This is an array of {@code FIELD_COUNT} integers, with index values</span>
<span class="line-modified"> 843      * {@code ERA} through {@code DST_OFFSET}.</span>
 844      * @serial
 845      */
 846     @SuppressWarnings(&quot;ProtectedField&quot;)
 847     protected int           fields[];
 848 
 849     /**
 850      * The flags which tell if a specified calendar field for the calendar is set.
 851      * A new object has no fields set.  After the first call to a method
 852      * which generates the fields, they all remain set after that.
<span class="line-modified"> 853      * This is an array of {@code FIELD_COUNT} booleans, with index values</span>
<span class="line-modified"> 854      * {@code ERA} through {@code DST_OFFSET}.</span>
 855      * @serial
 856      */
 857     @SuppressWarnings(&quot;ProtectedField&quot;)
 858     protected boolean       isSet[];
 859 
 860     /**
 861      * Pseudo-time-stamps which specify when each field was set. There
 862      * are two special values, UNSET and COMPUTED. Values from
 863      * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.
 864      */
 865     private transient int   stamp[];
 866 
 867     /**
 868      * The currently set time for this calendar, expressed in milliseconds after
 869      * January 1, 1970, 0:00:00 GMT.
 870      * @see #isTimeSet
 871      * @serial
 872      */
 873     @SuppressWarnings(&quot;ProtectedField&quot;)
 874     protected long          time;
 875 
 876     /**
<span class="line-modified"> 877      * True if then the value of {@code time} is valid.</span>
<span class="line-modified"> 878      * The time is made invalid by a change to an item of {@code field[]}.</span>
 879      * @see #time
 880      * @serial
 881      */
 882     @SuppressWarnings(&quot;ProtectedField&quot;)
 883     protected boolean       isTimeSet;
 884 
 885     /**
<span class="line-modified"> 886      * True if {@code fields[]} are in sync with the currently set time.</span>
 887      * If false, then the next attempt to get the value of a field will
 888      * force a recomputation of all fields from the current value of
<span class="line-modified"> 889      * {@code time}.</span>
 890      * @serial
 891      */
 892     @SuppressWarnings(&quot;ProtectedField&quot;)
 893     protected boolean       areFieldsSet;
 894 
 895     /**
 896      * True if all fields have been set.
 897      * @serial
 898      */
 899     transient boolean       areAllFieldsSet;
 900 
 901     /**
<span class="line-modified"> 902      * {@code True} if this calendar allows out-of-range field values during computation</span>
<span class="line-modified"> 903      * of {@code time} from {@code fields[]}.</span>
 904      * @see #setLenient
 905      * @see #isLenient
 906      * @serial
 907      */
 908     private boolean         lenient = true;
 909 
 910     /**
<span class="line-modified"> 911      * The {@code TimeZone} used by this calendar. {@code Calendar}</span>
 912      * uses the time zone data to translate between locale and GMT time.
 913      * @serial
 914      */
 915     private TimeZone        zone;
 916 
 917     /**
<span class="line-modified"> 918      * {@code True} if zone references to a shared TimeZone object.</span>
 919      */
 920     private transient boolean sharedZone = false;
 921 
 922     /**
<span class="line-modified"> 923      * The first day of the week, with possible values {@code SUNDAY},</span>
<span class="line-modified"> 924      * {@code MONDAY}, etc.  This is a locale-dependent value.</span>
 925      * @serial
 926      */
 927     private int             firstDayOfWeek;
 928 
 929     /**
 930      * The number of days required for the first week in a month or year,
 931      * with possible values from 1 to 7.  This is a locale-dependent value.
 932      * @serial
 933      */
 934     private int             minimalDaysInFirstWeek;
 935 
 936     /**
 937      * Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek
 938      * of a Locale.
 939      */
 940     private static final ConcurrentMap&lt;Locale, int[]&gt; cachedLocaleData
 941         = new ConcurrentHashMap&lt;&gt;(3);
 942 
 943     // Special values of stamp[]
 944     /**
</pre>
<hr />
<pre>
 947     private static final int        UNSET = 0;
 948 
 949     /**
 950      * The value of the corresponding fields[] has been calculated internally.
 951      */
 952     private static final int        COMPUTED = 1;
 953 
 954     /**
 955      * The value of the corresponding fields[] has been set externally. Stamp
 956      * values which are greater than 1 represents the (pseudo) time when the
 957      * corresponding fields[] value was set.
 958      */
 959     private static final int        MINIMUM_USER_STAMP = 2;
 960 
 961     /**
 962      * The mask value that represents all of the fields.
 963      */
 964     static final int ALL_FIELDS = (1 &lt;&lt; FIELD_COUNT) - 1;
 965 
 966     /**
<span class="line-modified"> 967      * The next available value for {@code stamp[]}, an internal array.</span>
 968      * This actually should not be written out to the stream, and will probably
 969      * be removed from the stream in the near future.  In the meantime,
<span class="line-modified"> 970      * a value of {@code MINIMUM_USER_STAMP} should be used.</span>
 971      * @serial
 972      */
 973     private int             nextStamp = MINIMUM_USER_STAMP;
 974 
 975     // the internal serial version which says which version was written
 976     // - 0 (default) for version up to JDK 1.1.5
 977     // - 1 for version from JDK 1.1.6, which writes a correct &#39;time&#39; value
 978     //     as well as compatible values for other fields.  This is a
 979     //     transitional format.
 980     // - 2 (not implemented yet) a future version, in which fields[],
 981     //     areFieldsSet, and isTimeSet become transient, and isSet[] is
 982     //     removed. In JDK 1.1.6 we write a format compatible with version 2.
 983     static final int        currentSerialVersion = 1;
 984 
 985     /**
 986      * The version of the serialized data on the stream.  Possible values:
 987      * &lt;dl&gt;
 988      * &lt;dt&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream&lt;/dt&gt;
 989      * &lt;dd&gt;
 990      * JDK 1.1.5 or earlier.
 991      * &lt;/dd&gt;
 992      * &lt;dt&gt;&lt;b&gt;1&lt;/b&gt;&lt;/dt&gt;
 993      * &lt;dd&gt;
 994      * JDK 1.1.6 or later.  Writes a correct &#39;time&#39; value
 995      * as well as compatible values for other fields.  This is a
 996      * transitional format.
 997      * &lt;/dd&gt;
 998      * &lt;/dl&gt;
 999      * When streaming out this class, the most recent format
<span class="line-modified">1000      * and the highest allowable {@code serialVersionOnStream}</span>
1001      * is written.
1002      * @serial
1003      * @since 1.1.6
1004      */
1005     private int             serialVersionOnStream = currentSerialVersion;
1006 
1007     // Proclaim serialization compatibility with JDK 1.1
<span class="line-added">1008     @java.io.Serial</span>
1009     static final long       serialVersionUID = -1807547505821590642L;
1010 
1011     // Mask values for calendar fields
1012     @SuppressWarnings(&quot;PointlessBitwiseExpression&quot;)
1013     static final int ERA_MASK           = (1 &lt;&lt; ERA);
1014     static final int YEAR_MASK          = (1 &lt;&lt; YEAR);
1015     static final int MONTH_MASK         = (1 &lt;&lt; MONTH);
1016     static final int WEEK_OF_YEAR_MASK  = (1 &lt;&lt; WEEK_OF_YEAR);
1017     static final int WEEK_OF_MONTH_MASK = (1 &lt;&lt; WEEK_OF_MONTH);
1018     static final int DAY_OF_MONTH_MASK  = (1 &lt;&lt; DAY_OF_MONTH);
1019     static final int DATE_MASK          = DAY_OF_MONTH_MASK;
1020     static final int DAY_OF_YEAR_MASK   = (1 &lt;&lt; DAY_OF_YEAR);
1021     static final int DAY_OF_WEEK_MASK   = (1 &lt;&lt; DAY_OF_WEEK);
1022     static final int DAY_OF_WEEK_IN_MONTH_MASK  = (1 &lt;&lt; DAY_OF_WEEK_IN_MONTH);
1023     static final int AM_PM_MASK         = (1 &lt;&lt; AM_PM);
1024     static final int HOUR_MASK          = (1 &lt;&lt; HOUR);
1025     static final int HOUR_OF_DAY_MASK   = (1 &lt;&lt; HOUR_OF_DAY);
1026     static final int MINUTE_MASK        = (1 &lt;&lt; MINUTE);
1027     static final int SECOND_MASK        = (1 &lt;&lt; SECOND);
1028     static final int MILLISECOND_MASK   = (1 &lt;&lt; MILLISECOND);
</pre>
<hr />
<pre>
1290          * @param weekOfYear the week number based on {@code weekYear}
1291          * @param dayOfWeek  the day of week value: one of the constants
1292          *     for the {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} field:
1293          *     {@link Calendar#SUNDAY SUNDAY}, ..., {@link Calendar#SATURDAY SATURDAY}.
1294          * @return this {@code Calendar.Builder}
1295          * @see Calendar#setWeekDate(int, int, int)
1296          * @see Calendar#isWeekDateSupported()
1297          */
1298         public Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
1299             allocateFields();
1300             internalSet(WEEK_YEAR, weekYear);
1301             internalSet(WEEK_OF_YEAR, weekOfYear);
1302             internalSet(DAY_OF_WEEK, dayOfWeek);
1303             return this;
1304         }
1305 
1306         /**
1307          * Sets the time zone parameter to the given {@code zone}. If no time
1308          * zone parameter is given to this {@code Calendar.Builder}, the
1309          * {@linkplain TimeZone#getDefault() default
<span class="line-modified">1310          * {@code TimeZone}} will be used in the {@link #build() build}</span>
1311          * method.
1312          *
1313          * @param zone the {@link TimeZone}
1314          * @return this {@code Calendar.Builder}
1315          * @throws NullPointerException if {@code zone} is {@code null}
1316          * @see Calendar#setTimeZone(TimeZone)
1317          */
1318         public Builder setTimeZone(TimeZone zone) {
1319             if (zone == null) {
1320                 throw new NullPointerException();
1321             }
1322             this.zone = zone;
1323             return this;
1324         }
1325 
1326         /**
1327          * Sets the lenient mode parameter to the value given by {@code lenient}.
1328          * If no lenient parameter is given to this {@code Calendar.Builder},
1329          * lenient mode will be used in the {@link #build() build} method.
1330          *
</pre>
<hr />
<pre>
1361             if (type.equals(&quot;gregorian&quot;)) { // NPE if type == null
1362                 type = &quot;gregory&quot;;
1363             }
1364             if (!Calendar.getAvailableCalendarTypes().contains(type)
1365                     &amp;&amp; !type.equals(&quot;iso8601&quot;)) {
1366                 throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);
1367             }
1368             if (this.type == null) {
1369                 this.type = type;
1370             } else {
1371                 if (!this.type.equals(type)) {
1372                     throw new IllegalStateException(&quot;calendar type override&quot;);
1373                 }
1374             }
1375             return this;
1376         }
1377 
1378         /**
1379          * Sets the locale parameter to the given {@code locale}. If no locale
1380          * is given to this {@code Calendar.Builder}, the {@linkplain
<span class="line-modified">1381          * Locale#getDefault(Locale.Category) default {@code Locale}}</span>
1382          * for {@link Locale.Category#FORMAT} will be used.
1383          *
1384          * &lt;p&gt;If no calendar type is explicitly given by a call to the
1385          * {@link #setCalendarType(String) setCalendarType} method,
1386          * the {@code Locale} value is used to determine what type of
1387          * {@code Calendar} to be built.
1388          *
1389          * &lt;p&gt;If no week definition parameters are explicitly given by a call to
1390          * the {@link #setWeekDefinition(int,int) setWeekDefinition} method, the
1391          * {@code Locale}&#39;s default values are used.
1392          *
1393          * @param locale the {@link Locale}
1394          * @throws NullPointerException if {@code locale} is {@code null}
1395          * @return this {@code Calendar.Builder}
1396          * @see Calendar#getInstance(Locale)
1397          */
1398         public Builder setLocale(Locale locale) {
1399             if (locale == null) {
1400                 throw new NullPointerException();
1401             }
</pre>
<hr />
<pre>
1597     }
1598 
1599     /**
1600      * Constructs a calendar with the specified time zone and locale.
1601      *
1602      * @param zone the time zone to use
1603      * @param aLocale the locale for the week data
1604      */
1605     protected Calendar(TimeZone zone, Locale aLocale)
1606     {
1607         fields = new int[FIELD_COUNT];
1608         isSet = new boolean[FIELD_COUNT];
1609         stamp = new int[FIELD_COUNT];
1610 
1611         this.zone = zone;
1612         setWeekCountData(aLocale);
1613     }
1614 
1615     /**
1616      * Gets a calendar using the default time zone and locale. The
<span class="line-modified">1617      * {@code Calendar} returned is based on the current time</span>
1618      * in the default time zone with the default
1619      * {@link Locale.Category#FORMAT FORMAT} locale.
1620      * &lt;p&gt;
1621      * If the locale contains the time zone with &quot;tz&quot;
1622      * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
1623      * that time zone is used instead.
1624      *
1625      * @return a Calendar.
1626      */
1627     public static Calendar getInstance()
1628     {
1629         Locale aLocale = Locale.getDefault(Locale.Category.FORMAT);
1630         return createCalendar(defaultTimeZone(aLocale), aLocale);
1631     }
1632 
1633     /**
1634      * Gets a calendar using the specified time zone and default locale.
<span class="line-modified">1635      * The {@code Calendar} returned is based on the current time</span>
1636      * in the given time zone with the default
1637      * {@link Locale.Category#FORMAT FORMAT} locale.
1638      *
1639      * @param zone the time zone to use
1640      * @return a Calendar.
1641      */
1642     public static Calendar getInstance(TimeZone zone)
1643     {
1644         return createCalendar(zone, Locale.getDefault(Locale.Category.FORMAT));
1645     }
1646 
1647     /**
1648      * Gets a calendar using the default time zone and specified locale.
<span class="line-modified">1649      * The {@code Calendar} returned is based on the current time</span>
1650      * in the default time zone with the given locale.
1651      * &lt;p&gt;
1652      * If the locale contains the time zone with &quot;tz&quot;
1653      * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
1654      * that time zone is used instead.
1655      *
1656      * @param aLocale the locale for the week data
1657      * @return a Calendar.
1658      */
1659     public static Calendar getInstance(Locale aLocale)
1660     {
1661         return createCalendar(defaultTimeZone(aLocale), aLocale);
1662     }
1663 
1664     /**
1665      * Gets a calendar with the specified time zone and locale.
<span class="line-modified">1666      * The {@code Calendar} returned is based on the current time</span>
1667      * in the given time zone with the given locale.
1668      *
1669      * @param zone the time zone to use
1670      * @param aLocale the locale for the week data
1671      * @return a Calendar.
1672      */
1673     public static Calendar getInstance(TimeZone zone,
1674                                        Locale aLocale)
1675     {
1676         return createCalendar(zone, aLocale);
1677     }
1678 
1679     private static TimeZone defaultTimeZone(Locale l) {
1680         TimeZone defaultTZ = TimeZone.getDefault();
1681         String shortTZID = l.getUnicodeLocaleType(&quot;tz&quot;);
1682         return shortTZID != null ?
1683             TimeZoneNameUtility.convertLDMLShortID(shortTZID)
1684                 .map(TimeZone::getTimeZone)
1685                 .orElse(defaultTZ) :
1686             defaultTZ;
</pre>
<hr />
<pre>
1721         if (cal == null) {
1722             // If no known calendar type is explicitly specified,
1723             // perform the traditional way to create a Calendar:
1724             // create a BuddhistCalendar for th_TH locale,
1725             // a JapaneseImperialCalendar for ja_JP_JP locale, or
1726             // a GregorianCalendar for any other locales.
1727             // NOTE: The language, country and variant strings are interned.
1728             if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {
1729                 cal = new BuddhistCalendar(zone, aLocale);
1730             } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;
1731                        &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {
1732                 cal = new JapaneseImperialCalendar(zone, aLocale);
1733             } else {
1734                 cal = new GregorianCalendar(zone, aLocale);
1735             }
1736         }
1737         return cal;
1738     }
1739 
1740     /**
<span class="line-modified">1741      * Returns an array of all locales for which the {@code getInstance}</span>
1742      * methods of this class can return localized instances.
<span class="line-modified">1743      * The array returned must contain at least a {@code Locale}</span>
1744      * instance equal to {@link java.util.Locale#US Locale.US}.
1745      *
1746      * @return An array of locales for which localized
<span class="line-modified">1747      *         {@code Calendar} instances are available.</span>
1748      */
1749     public static synchronized Locale[] getAvailableLocales()
1750     {
1751         return DateFormat.getAvailableLocales();
1752     }
1753 
1754     /**
1755      * Converts the current calendar field values in {@link #fields fields[]}
1756      * to the millisecond time value
1757      * {@link #time}.
1758      *
1759      * @see #complete()
1760      * @see #computeFields()
1761      */
1762     protected abstract void computeTime();
1763 
1764     /**
1765      * Converts the current millisecond time value {@link #time}
1766      * to calendar field values in {@link #fields fields[]}.
1767      * This allows you to sync up the calendar field values with
1768      * a new time that is set for the calendar.  The time is &lt;em&gt;not&lt;/em&gt;
1769      * recomputed first; to recompute the time, then the fields, call the
1770      * {@link #complete()} method.
1771      *
1772      * @see #computeTime()
1773      */
1774     protected abstract void computeFields();
1775 
1776     /**
<span class="line-modified">1777      * Returns a {@code Date} object representing this</span>
<span class="line-modified">1778      * {@code Calendar}&#39;s time value (millisecond offset from the &lt;a</span>
1779      * href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;&quot;).
1780      *
<span class="line-modified">1781      * @return a {@code Date} representing the time value.</span>
1782      * @see #setTime(Date)
1783      * @see #getTimeInMillis()
1784      */
1785     public final Date getTime() {
1786         return new Date(getTimeInMillis());
1787     }
1788 
1789     /**
<span class="line-modified">1790      * Sets this Calendar&#39;s time with the given {@code Date}.</span>
1791      * &lt;p&gt;
<span class="line-modified">1792      * Note: Calling {@code setTime()} with</span>
<span class="line-modified">1793      * {@code Date(Long.MAX_VALUE)} or {@code Date(Long.MIN_VALUE)}</span>
<span class="line-modified">1794      * may yield incorrect field values from {@code get()}.</span>
1795      *
1796      * @param date the given Date.
1797      * @see #getTime()
1798      * @see #setTimeInMillis(long)
1799      */
1800     public final void setTime(Date date) {
1801         setTimeInMillis(date.getTime());
1802     }
1803 
1804     /**
1805      * Returns this Calendar&#39;s time value in milliseconds.
1806      *
1807      * @return the current time as UTC milliseconds from the epoch.
1808      * @see #getTime()
1809      * @see #setTimeInMillis(long)
1810      */
1811     public long getTimeInMillis() {
1812         if (!isTimeSet) {
1813             updateTime();
1814         }
</pre>
<hr />
<pre>
1857         complete();
1858         return internalGet(field);
1859     }
1860 
1861     /**
1862      * Returns the value of the given calendar field. This method does
1863      * not involve normalization or validation of the field value.
1864      *
1865      * @param field the given calendar field.
1866      * @return the value for the given calendar field.
1867      * @see #get(int)
1868      */
1869     protected final int internalGet(int field)
1870     {
1871         return fields[field];
1872     }
1873 
1874     /**
1875      * Sets the value of the given calendar field. This method does
1876      * not affect any setting state of the field in this
<span class="line-modified">1877      * {@code Calendar} instance.</span>
1878      *
1879      * @throws IndexOutOfBoundsException if the specified field is out of range
1880      *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
1881      * @see #areFieldsSet
1882      * @see #isTimeSet
1883      * @see #areAllFieldsSet
1884      * @see #set(int,int)
1885      */
1886     final void internalSet(int field, int value)
1887     {
1888         fields[field] = value;
1889     }
1890 
1891     /**
1892      * Sets the given calendar field to the given value. The value is not
1893      * interpreted by this method regardless of the leniency mode.
1894      *
1895      * @param field the given calendar field.
1896      * @param value the value to be set for the given calendar field.
1897      * @throws ArrayIndexOutOfBoundsException if the specified field is out of range
</pre>
<hr />
<pre>
1903      * @see #get(int)
1904      */
1905     public void set(int field, int value)
1906     {
1907         // If the fields are partially normalized, calculate all the
1908         // fields before changing any fields.
1909         if (areFieldsSet &amp;&amp; !areAllFieldsSet) {
1910             computeFields();
1911         }
1912         internalSet(field, value);
1913         isTimeSet = false;
1914         areFieldsSet = false;
1915         isSet[field] = true;
1916         stamp[field] = nextStamp++;
1917         if (nextStamp == Integer.MAX_VALUE) {
1918             adjustStamp();
1919         }
1920     }
1921 
1922     /**
<span class="line-modified">1923      * Sets the values for the calendar fields {@code YEAR},</span>
<span class="line-modified">1924      * {@code MONTH}, and {@code DAY_OF_MONTH}.</span>
1925      * Previous values of other calendar fields are retained.  If this is not desired,
1926      * call {@link #clear()} first.
1927      *
<span class="line-modified">1928      * @param year the value used to set the {@code YEAR} calendar field.</span>
<span class="line-modified">1929      * @param month the value used to set the {@code MONTH} calendar field.</span>
1930      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified">1931      * @param date the value used to set the {@code DAY_OF_MONTH} calendar field.</span>
1932      * @see #set(int,int)
1933      * @see #set(int,int,int,int,int)
1934      * @see #set(int,int,int,int,int,int)
1935      */
1936     public final void set(int year, int month, int date)
1937     {
1938         set(YEAR, year);
1939         set(MONTH, month);
1940         set(DATE, date);
1941     }
1942 
1943     /**
<span class="line-modified">1944      * Sets the values for the calendar fields {@code YEAR},</span>
<span class="line-modified">1945      * {@code MONTH}, {@code DAY_OF_MONTH},</span>
<span class="line-modified">1946      * {@code HOUR_OF_DAY}, and {@code MINUTE}.</span>
1947      * Previous values of other fields are retained.  If this is not desired,
1948      * call {@link #clear()} first.
1949      *
<span class="line-modified">1950      * @param year the value used to set the {@code YEAR} calendar field.</span>
<span class="line-modified">1951      * @param month the value used to set the {@code MONTH} calendar field.</span>
1952      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified">1953      * @param date the value used to set the {@code DAY_OF_MONTH} calendar field.</span>
<span class="line-modified">1954      * @param hourOfDay the value used to set the {@code HOUR_OF_DAY} calendar field.</span>
<span class="line-modified">1955      * @param minute the value used to set the {@code MINUTE} calendar field.</span>
1956      * @see #set(int,int)
1957      * @see #set(int,int,int)
1958      * @see #set(int,int,int,int,int,int)
1959      */
1960     public final void set(int year, int month, int date, int hourOfDay, int minute)
1961     {
1962         set(YEAR, year);
1963         set(MONTH, month);
1964         set(DATE, date);
1965         set(HOUR_OF_DAY, hourOfDay);
1966         set(MINUTE, minute);
1967     }
1968 
1969     /**
<span class="line-modified">1970      * Sets the values for the fields {@code YEAR}, {@code MONTH},</span>
<span class="line-modified">1971      * {@code DAY_OF_MONTH}, {@code HOUR_OF_DAY}, {@code MINUTE}, and</span>
<span class="line-modified">1972      * {@code SECOND}.</span>
1973      * Previous values of other fields are retained.  If this is not desired,
1974      * call {@link #clear()} first.
1975      *
<span class="line-modified">1976      * @param year the value used to set the {@code YEAR} calendar field.</span>
<span class="line-modified">1977      * @param month the value used to set the {@code MONTH} calendar field.</span>
1978      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified">1979      * @param date the value used to set the {@code DAY_OF_MONTH} calendar field.</span>
<span class="line-modified">1980      * @param hourOfDay the value used to set the {@code HOUR_OF_DAY} calendar field.</span>
<span class="line-modified">1981      * @param minute the value used to set the {@code MINUTE} calendar field.</span>
<span class="line-modified">1982      * @param second the value used to set the {@code SECOND} calendar field.</span>
1983      * @see #set(int,int)
1984      * @see #set(int,int,int)
1985      * @see #set(int,int,int,int,int)
1986      */
1987     public final void set(int year, int month, int date, int hourOfDay, int minute,
1988                           int second)
1989     {
1990         set(YEAR, year);
1991         set(MONTH, month);
1992         set(DATE, date);
1993         set(HOUR_OF_DAY, hourOfDay);
1994         set(MINUTE, minute);
1995         set(SECOND, second);
1996     }
1997 
1998     /**
1999      * Sets all the calendar field values and the time value
2000      * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) of
<span class="line-modified">2001      * this {@code Calendar} undefined. This means that {@link</span>
<span class="line-modified">2002      * #isSet(int) isSet()} will return {@code false} for all the</span>
2003      * calendar fields, and the date and time calculations will treat
2004      * the fields as if they had never been set. A
<span class="line-modified">2005      * {@code Calendar} implementation class may use its specific</span>
2006      * default field values for date/time calculations. For example,
<span class="line-modified">2007      * {@code GregorianCalendar} uses 1970 if the</span>
<span class="line-modified">2008      * {@code YEAR} field value is undefined.</span>
2009      *
2010      * @see #clear(int)
2011      */
2012     public final void clear()
2013     {
2014         for (int i = 0; i &lt; fields.length; ) {
2015             stamp[i] = fields[i] = 0; // UNSET == 0
2016             isSet[i++] = false;
2017         }
2018         areAllFieldsSet = areFieldsSet = false;
2019         isTimeSet = false;
2020     }
2021 
2022     /**
2023      * Sets the given calendar field value and the time value
2024      * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) of
<span class="line-modified">2025      * this {@code Calendar} undefined. This means that {@link</span>
<span class="line-modified">2026      * #isSet(int) isSet(field)} will return {@code false}, and</span>
2027      * the date and time calculations will treat the field as if it
<span class="line-modified">2028      * had never been set. A {@code Calendar} implementation</span>
2029      * class may use the field&#39;s specific default value for date and
2030      * time calculations.
2031      *
2032      * &lt;p&gt;The {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}
2033      * fields are handled independently and the &lt;a
2034      * href=&quot;#time_resolution&quot;&gt;the resolution rule for the time of
2035      * day&lt;/a&gt; is applied. Clearing one of the fields doesn&#39;t reset
<span class="line-modified">2036      * the hour of day value of this {@code Calendar}. Use {@link</span>
2037      * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour
2038      * value.
2039      *
2040      * @param field the calendar field to be cleared.
2041      * @see #clear()
2042      */
2043     public final void clear(int field)
2044     {
2045         fields[field] = 0;
2046         stamp[field] = UNSET;
2047         isSet[field] = false;
2048 
2049         areAllFieldsSet = areFieldsSet = false;
2050         isTimeSet = false;
2051     }
2052 
2053     /**
2054      * Determines if the given calendar field has a value set,
2055      * including cases that the value has been set by internal fields
<span class="line-modified">2056      * calculations triggered by a {@code get} method call.</span>
2057      *
2058      * @param field the calendar field to test
<span class="line-modified">2059      * @return {@code true} if the given calendar field has a value set;</span>
<span class="line-modified">2060      * {@code false} otherwise.</span>
2061      */
2062     public final boolean isSet(int field)
2063     {
2064         return stamp[field] != UNSET;
2065     }
2066 
2067     /**
2068      * Returns the string representation of the calendar
<span class="line-modified">2069      * {@code field} value in the given {@code style} and</span>
<span class="line-modified">2070      * {@code locale}.  If no string representation is</span>
<span class="line-modified">2071      * applicable, {@code null} is returned. This method calls</span>
2072      * {@link Calendar#get(int) get(field)} to get the calendar
<span class="line-modified">2073      * {@code field} value if the string representation is</span>
<span class="line-modified">2074      * applicable to the given calendar {@code field}.</span>
2075      *
<span class="line-modified">2076      * &lt;p&gt;For example, if this {@code Calendar} is a</span>
<span class="line-modified">2077      * {@code GregorianCalendar} and its date is 2005-01-01, then</span>
2078      * the string representation of the {@link #MONTH} field would be
2079      * &quot;January&quot; in the long style in an English locale or &quot;Jan&quot; in
2080      * the short style. However, no string representation would be
2081      * available for the {@link #DAY_OF_MONTH} field, and this method
<span class="line-modified">2082      * would return {@code null}.</span>
2083      *
2084      * &lt;p&gt;The default implementation supports the calendar fields for
2085      * which a {@link DateFormatSymbols} has names in the given
<span class="line-modified">2086      * {@code locale}.</span>
2087      *
2088      * @param field
2089      *        the calendar field for which the string representation
2090      *        is returned
2091      * @param style
2092      *        the style applied to the string representation; one of {@link
2093      *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
2094      *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
2095      *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}.
2096      * @param locale
2097      *        the locale for the string representation
2098      *        (any calendar types specified by {@code locale} are ignored)
2099      * @return the string representation of the given
2100      *        {@code field} in the given {@code style}, or
2101      *        {@code null} if no string representation is
2102      *        applicable.
<span class="line-modified">2103      * @throws    IllegalArgumentException</span>
2104      *        if {@code field} or {@code style} is invalid,
2105      *        or if this {@code Calendar} is non-lenient and any
2106      *        of the calendar fields have invalid values
<span class="line-modified">2107      * @throws    NullPointerException</span>
2108      *        if {@code locale} is null
2109      * @since 1.6
2110      */
2111     public String getDisplayName(int field, int style, Locale locale) {
2112         if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale,
2113                             ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {
2114             return null;
2115         }
2116 
2117         String calendarType = getCalendarType();
2118         int fieldValue = get(field);
2119         // the standalone/narrow styles and short era are supported only through
2120         // CalendarNameProviders.
2121         if (isStandaloneStyle(style) || isNarrowFormatStyle(style) ||
2122             field == ERA &amp;&amp; (style &amp; SHORT) == SHORT) {
2123             String val = CalendarDataUtility.retrieveFieldValueName(calendarType,
2124                                                                     field, fieldValue,
2125                                                                     style, locale);
2126             // Perform fallback here to follow the CLDR rules
2127             if (val == null) {
</pre>
<hr />
<pre>
2174      * &lt;p&gt;The default implementation supports display names contained in
2175      * a {@link DateFormatSymbols}. For example, if {@code field}
2176      * is {@link #MONTH} and {@code style} is {@link
2177      * #ALL_STYLES}, this method returns a {@code Map} containing
2178      * all strings returned by {@link DateFormatSymbols#getShortMonths()}
2179      * and {@link DateFormatSymbols#getMonths()}.
2180      *
2181      * @param field
2182      *        the calendar field for which the display names are returned
2183      * @param style
2184      *        the style applied to the string representation; one of {@link
2185      *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
2186      *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
2187      *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}
2188      * @param locale
2189      *        the locale for the display names
2190      * @return a {@code Map} containing all display names in
2191      *        {@code style} and {@code locale} and their
2192      *        field values, or {@code null} if no display names
2193      *        are defined for {@code field}
<span class="line-modified">2194      * @throws    IllegalArgumentException</span>
2195      *        if {@code field} or {@code style} is invalid,
2196      *        or if this {@code Calendar} is non-lenient and any
2197      *        of the calendar fields have invalid values
<span class="line-modified">2198      * @throws    NullPointerException</span>
2199      *        if {@code locale} is null
2200      * @since 1.6
2201      */
2202     public Map&lt;String, Integer&gt; getDisplayNames(int field, int style, Locale locale) {
2203         if (!checkDisplayNameParams(field, style, ALL_STYLES, NARROW_FORMAT, locale,
2204                                     ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {
2205             return null;
2206         }
2207 
2208         String calendarType = getCalendarType();
<span class="line-modified">2209         if (style == ALL_STYLES || isStandaloneStyle(style) || isNarrowFormatStyle(style) ||</span>
<span class="line-added">2210             field == ERA &amp;&amp; (style &amp; SHORT) == SHORT) {</span>
2211             Map&lt;String, Integer&gt; map;
2212             map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field, style, locale);
2213 
2214             // Perform fallback here to follow the CLDR rules
2215             if (map == null) {
2216                 if (isNarrowFormatStyle(style)) {
2217                     map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field,
2218                                                                       toStandaloneStyle(style), locale);
2219                 } else if (style != ALL_STYLES) {
2220                     map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field,
2221                                                                       getBaseStyle(style), locale);
2222                 }
2223             }
2224             return map;
2225         }
2226 
2227         // SHORT or LONG
2228         return getDisplayNamesImpl(field, style, locale);
2229     }
2230 
</pre>
<hr />
<pre>
2292      * from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) has not been calculated from
2293      * calendar field values. Then, the {@link #computeFields()} method is
2294      * called to calculate all calendar field values.
2295      */
2296     protected void complete()
2297     {
2298         if (!isTimeSet) {
2299             updateTime();
2300         }
2301         if (!areFieldsSet || !areAllFieldsSet) {
2302             computeFields(); // fills in unset fields
2303             areAllFieldsSet = areFieldsSet = true;
2304         }
2305     }
2306 
2307     /**
2308      * Returns whether the value of the specified calendar field has been set
2309      * externally by calling one of the setter methods rather than by the
2310      * internal time calculation.
2311      *
<span class="line-modified">2312      * @return {@code true} if the field has been set externally,</span>
<span class="line-modified">2313      * {@code false} otherwise.</span>
<span class="line-modified">2314      * @throws    IndexOutOfBoundsException if the specified</span>
<span class="line-modified">2315      *                {@code field} is out of range</span>
2316      *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
2317      * @see #selectFields()
2318      * @see #setFieldsComputed(int)
2319      */
2320     final boolean isExternallySet(int field) {
2321         return stamp[field] &gt;= MINIMUM_USER_STAMP;
2322     }
2323 
2324     /**
2325      * Returns a field mask (bit mask) indicating all calendar fields that
2326      * have the state of externally or internally set.
2327      *
2328      * @return a bit mask indicating set state fields
2329      */
2330     final int getSetStateFields() {
2331         int mask = 0;
2332         for (int i = 0; i &lt; fields.length; i++) {
2333             if (stamp[i] != UNSET) {
2334                 mask |= 1 &lt;&lt; i;
2335             }
2336         }
2337         return mask;
2338     }
2339 
2340     /**
2341      * Sets the state of the specified calendar fields to
2342      * &lt;em&gt;computed&lt;/em&gt;. This state means that the specified calendar fields
2343      * have valid values that have been set by internal time calculation
2344      * rather than by calling one of the setter methods.
2345      *
2346      * @param fieldMask the field to be marked as computed.
<span class="line-modified">2347      * @throws    IndexOutOfBoundsException if the specified</span>
<span class="line-modified">2348      *                {@code field} is out of range</span>
2349      *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
2350      * @see #isExternallySet(int)
2351      * @see #selectFields()
2352      */
2353     final void setFieldsComputed(int fieldMask) {
2354         if (fieldMask == ALL_FIELDS) {
2355             for (int i = 0; i &lt; fields.length; i++) {
2356                 stamp[i] = COMPUTED;
2357                 isSet[i] = true;
2358             }
2359             areFieldsSet = areAllFieldsSet = true;
2360         } else {
2361             for (int i = 0; i &lt; fields.length; i++) {
2362                 if ((fieldMask &amp; 1) == 1) {
2363                     stamp[i] = COMPUTED;
2364                     isSet[i] = true;
2365                 } else {
2366                     if (areAllFieldsSet &amp;&amp; !isSet[i]) {
2367                         areAllFieldsSet = false;
2368                     }
2369                 }
2370                 fieldMask &gt;&gt;&gt;= 1;
2371             }
2372         }
2373     }
2374 
2375     /**
2376      * Sets the state of the calendar fields that are &lt;em&gt;not&lt;/em&gt; specified
<span class="line-modified">2377      * by {@code fieldMask} to &lt;em&gt;unset&lt;/em&gt;. If {@code fieldMask}</span>
2378      * specifies all the calendar fields, then the state of this
<span class="line-modified">2379      * {@code Calendar} becomes that all the calendar fields are in sync</span>
2380      * with the time value (millisecond offset from the Epoch).
2381      *
2382      * @param fieldMask the field mask indicating which calendar fields are in
2383      * sync with the time value.
<span class="line-modified">2384      * @throws    IndexOutOfBoundsException if the specified</span>
<span class="line-modified">2385      *                {@code field} is out of range</span>
2386      *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
2387      * @see #isExternallySet(int)
2388      * @see #selectFields()
2389      */
2390     final void setFieldsNormalized(int fieldMask) {
2391         if (fieldMask != ALL_FIELDS) {
2392             for (int i = 0; i &lt; fields.length; i++) {
2393                 if ((fieldMask &amp; 1) == 0) {
2394                     stamp[i] = fields[i] = 0; // UNSET == 0
2395                     isSet[i] = false;
2396                 }
2397                 fieldMask &gt;&gt;= 1;
2398             }
2399         }
2400 
2401         // Some or all of the fields are in sync with the
2402         // milliseconds, but the stamp values are not normalized yet.
2403         areFieldsSet = true;
2404         areAllFieldsSet = false;
2405     }
</pre>
<hr />
<pre>
2411     final boolean isPartiallyNormalized() {
2412         return areFieldsSet &amp;&amp; !areAllFieldsSet;
2413     }
2414 
2415     /**
2416      * Returns whether the calendar fields are fully in sync with the time
2417      * value.
2418      */
2419     final boolean isFullyNormalized() {
2420         return areFieldsSet &amp;&amp; areAllFieldsSet;
2421     }
2422 
2423     /**
2424      * Marks this Calendar as not sync&#39;d.
2425      */
2426     final void setUnnormalized() {
2427         areFieldsSet = areAllFieldsSet = false;
2428     }
2429 
2430     /**
<span class="line-modified">2431      * Returns whether the specified {@code field} is on in the</span>
<span class="line-modified">2432      * {@code fieldMask}.</span>
2433      */
2434     static boolean isFieldSet(int fieldMask, int field) {
2435         return (fieldMask &amp; (1 &lt;&lt; field)) != 0;
2436     }
2437 
2438     /**
2439      * Returns a field mask indicating which calendar field values
2440      * to be used to calculate the time value. The calendar fields are
2441      * returned as a bit mask, each bit of which corresponds to a field, i.e.,
<span class="line-modified">2442      * the mask value of {@code field} is &lt;code&gt;(1 &amp;lt;&amp;lt;</span>
<span class="line-modified">2443      * field)&lt;/code&gt;. For example, 0x26 represents the {@code YEAR},</span>
<span class="line-modified">2444      * {@code MONTH}, and {@code DAY_OF_MONTH} fields (i.e., 0x26 is</span>
2445      * equal to
2446      * &lt;code&gt;(1&amp;lt;&amp;lt;YEAR)|(1&amp;lt;&amp;lt;MONTH)|(1&amp;lt;&amp;lt;DAY_OF_MONTH))&lt;/code&gt;.
2447      *
2448      * &lt;p&gt;This method supports the calendar fields resolution as described in
2449      * the class description. If the bit mask for a given field is on and its
<span class="line-modified">2450      * field has not been set (i.e., {@code isSet(field)} is</span>
<span class="line-modified">2451      * {@code false}), then the default value of the field has to be</span>
2452      * used, which case means that the field has been selected because the
2453      * selected combination involves the field.
2454      *
2455      * @return a bit mask of selected fields
2456      * @see #isExternallySet(int)
2457      */
2458     final int selectFields() {
2459         // This implementation has been taken from the GregorianCalendar class.
2460 
2461         // The YEAR field must always be used regardless of its SET
2462         // state because YEAR is a mandatory field to determine the date
2463         // and the default value (EPOCH_YEAR) may change through the
2464         // normalization process.
2465         int fieldMask = YEAR_MASK;
2466 
2467         if (stamp[ERA] != UNSET) {
2468             fieldMask |= ERA_MASK;
2469         }
2470         // Find the most recent group of fields specifying the day within
2471         // the year.  These may be any of the following combinations:
</pre>
<hr />
<pre>
2676      * defined by the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt;
2677      * specification.
2678      *
2679      * &lt;p&gt;The default implementation of this method returns the class name of
2680      * this {@code Calendar} instance. Any subclasses that implement
2681      * LDML-defined calendar systems should override this method to return
2682      * appropriate calendar types.
2683      *
2684      * @return the LDML-defined calendar type or the class name of this
2685      *         {@code Calendar} instance
2686      * @since 1.8
2687      * @see &lt;a href=&quot;Locale.html#def_extensions&quot;&gt;Locale extensions&lt;/a&gt;
2688      * @see Locale.Builder#setLocale(Locale)
2689      * @see Locale.Builder#setUnicodeLocaleKeyword(String, String)
2690      */
2691     public String getCalendarType() {
2692         return this.getClass().getName();
2693     }
2694 
2695     /**
<span class="line-modified">2696      * Compares this {@code Calendar} to the specified</span>
<span class="line-modified">2697      * {@code Object}.  The result is {@code true} if and only if</span>
<span class="line-modified">2698      * the argument is a {@code Calendar} object of the same calendar</span>
2699      * system that represents the same time value (millisecond offset from the
2700      * &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
<span class="line-modified">2701      * {@code Calendar} parameters as this object.</span>
2702      *
<span class="line-modified">2703      * &lt;p&gt;The {@code Calendar} parameters are the values represented</span>
<span class="line-modified">2704      * by the {@code isLenient}, {@code getFirstDayOfWeek},</span>
<span class="line-modified">2705      * {@code getMinimalDaysInFirstWeek} and {@code getTimeZone}</span>
2706      * methods. If there is any difference in those parameters
<span class="line-modified">2707      * between the two {@code Calendar}s, this method returns</span>
<span class="line-modified">2708      * {@code false}.</span>
2709      *
2710      * &lt;p&gt;Use the {@link #compareTo(Calendar) compareTo} method to
2711      * compare only the time values.
2712      *
2713      * @param obj the object to compare with.
<span class="line-modified">2714      * @return {@code true} if this object is equal to {@code obj};</span>
<span class="line-modified">2715      * {@code false} otherwise.</span>
2716      */
2717     @SuppressWarnings(&quot;EqualsWhichDoesntCheckParameterClass&quot;)
2718     @Override
2719     public boolean equals(Object obj) {
2720         if (this == obj) {
2721             return true;
2722         }
2723         try {
2724             Calendar that = (Calendar)obj;
2725             return compareTo(getMillisOf(that)) == 0 &amp;&amp;
2726                 lenient == that.lenient &amp;&amp;
2727                 firstDayOfWeek == that.firstDayOfWeek &amp;&amp;
2728                 minimalDaysInFirstWeek == that.minimalDaysInFirstWeek &amp;&amp;
2729                 zone.equals(that.zone);
2730         } catch (Exception e) {
2731             // Note: GregorianCalendar.computeTime throws
2732             // IllegalArgumentException if the ERA value is invalid
2733             // even it&#39;s in lenient mode.
2734         }
2735         return false;
2736     }
2737 
2738     /**
2739      * Returns a hash code for this calendar.
2740      *
2741      * @return a hash code value for this object.
2742      * @since 1.2
2743      */
2744     @Override
2745     public int hashCode() {
2746         // &#39;otheritems&#39; represents the hash code for the previous versions.
2747         int otheritems = (lenient ? 1 : 0)
2748             | (firstDayOfWeek &lt;&lt; 1)
2749             | (minimalDaysInFirstWeek &lt;&lt; 4)
2750             | (zone.hashCode() &lt;&lt; 7);
2751         long t = getMillisOf(this);
2752         return (int) t ^ (int)(t &gt;&gt; 32) ^ otheritems;
2753     }
2754 
2755     /**
<span class="line-modified">2756      * Returns whether this {@code Calendar} represents a time</span>
2757      * before the time represented by the specified
<span class="line-modified">2758      * {@code Object}. This method is equivalent to:</span>
2759      * &lt;pre&gt;{@code
2760      *         compareTo(when) &lt; 0
2761      * }&lt;/pre&gt;
<span class="line-modified">2762      * if and only if {@code when} is a {@code Calendar}</span>
<span class="line-modified">2763      * instance. Otherwise, the method returns {@code false}.</span>
2764      *
<span class="line-modified">2765      * @param when the {@code Object} to be compared</span>
<span class="line-modified">2766      * @return {@code true} if the time of this</span>
<span class="line-modified">2767      * {@code Calendar} is before the time represented by</span>
<span class="line-modified">2768      * {@code when}; {@code false} otherwise.</span>
2769      * @see     #compareTo(Calendar)
2770      */
2771     public boolean before(Object when) {
2772         return when instanceof Calendar
2773             &amp;&amp; compareTo((Calendar)when) &lt; 0;
2774     }
2775 
2776     /**
<span class="line-modified">2777      * Returns whether this {@code Calendar} represents a time</span>
2778      * after the time represented by the specified
<span class="line-modified">2779      * {@code Object}. This method is equivalent to:</span>
2780      * &lt;pre&gt;{@code
2781      *         compareTo(when) &gt; 0
2782      * }&lt;/pre&gt;
<span class="line-modified">2783      * if and only if {@code when} is a {@code Calendar}</span>
<span class="line-modified">2784      * instance. Otherwise, the method returns {@code false}.</span>
2785      *
<span class="line-modified">2786      * @param when the {@code Object} to be compared</span>
<span class="line-modified">2787      * @return {@code true} if the time of this {@code Calendar} is</span>
<span class="line-modified">2788      * after the time represented by {@code when}; {@code false}</span>
2789      * otherwise.
2790      * @see     #compareTo(Calendar)
2791      */
2792     public boolean after(Object when) {
2793         return when instanceof Calendar
2794             &amp;&amp; compareTo((Calendar)when) &gt; 0;
2795     }
2796 
2797     /**
2798      * Compares the time values (millisecond offsets from the &lt;a
2799      * href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) represented by two
<span class="line-modified">2800      * {@code Calendar} objects.</span>
2801      *
<span class="line-modified">2802      * @param anotherCalendar the {@code Calendar} to be compared.</span>
<span class="line-modified">2803      * @return the value {@code 0} if the time represented by the argument</span>
<span class="line-modified">2804      * is equal to the time represented by this {@code Calendar}; a value</span>
<span class="line-modified">2805      * less than {@code 0} if the time of this {@code Calendar} is</span>
2806      * before the time represented by the argument; and a value greater than
<span class="line-modified">2807      * {@code 0} if the time of this {@code Calendar} is after the</span>
2808      * time represented by the argument.
<span class="line-modified">2809      * @throws    NullPointerException if the specified {@code Calendar} is</span>
<span class="line-modified">2810      *            {@code null}.</span>
<span class="line-modified">2811      * @throws    IllegalArgumentException if the time value of the</span>
<span class="line-modified">2812      * specified {@code Calendar} object can&#39;t be obtained due to</span>
2813      * any invalid calendar values.
2814      * @since   1.5
2815      */
2816     @Override
2817     public int compareTo(Calendar anotherCalendar) {
2818         return compareTo(getMillisOf(anotherCalendar));
2819     }
2820 
2821     /**
2822      * Adds or subtracts the specified amount of time to the given calendar field,
2823      * based on the calendar&#39;s rules. For example, to subtract 5 days from
2824      * the current time of the calendar, you can achieve it by calling:
<span class="line-modified">2825      * &lt;p&gt;{@code add(Calendar.DAY_OF_MONTH, -5)}.</span>
2826      *
2827      * @param field the calendar field.
2828      * @param amount the amount of date or time to be added to the field.
2829      * @see #roll(int,int)
2830      * @see #set(int,int)
2831      */
2832     public abstract void add(int field, int amount);
2833 
2834     /**
2835      * Adds or subtracts (up/down) a single unit of time on the given time
2836      * field without changing larger fields. For example, to roll the current
2837      * date up by one day, you can achieve it by calling:
2838      * &lt;p&gt;roll(Calendar.DATE, true).
2839      * When rolling on the year or Calendar.YEAR field, it will roll the year
2840      * value in the range between 1 and the value returned by calling
<span class="line-modified">2841      * {@code getMaximum(Calendar.YEAR)}.</span>
2842      * When rolling on the month or Calendar.MONTH field, other fields like
2843      * date might conflict and, need to be changed. For instance,
2844      * rolling the month on the date 01/31/96 will result in 02/29/96.
2845      * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will
2846      * roll the hour value in the range between 0 and 23, which is zero-based.
2847      *
2848      * @param field the time field.
2849      * @param up indicates if the value of the specified time field is to be
2850      * rolled up or rolled down. Use true if rolling up, false otherwise.
2851      * @see Calendar#add(int,int)
2852      * @see Calendar#set(int,int)
2853      */
2854     public abstract void roll(int field, boolean up);
2855 
2856     /**
2857      * Adds the specified (signed) amount to the specified calendar field
2858      * without changing larger fields.  A negative amount means to roll
2859      * down.
2860      *
<span class="line-modified">2861      * &lt;p&gt;NOTE:  This default implementation on {@code Calendar} just repeatedly calls the</span>
2862      * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not
<span class="line-modified">2863      * always do the right thing.  For example, if the {@code DAY_OF_MONTH} field is 31,</span>
<span class="line-modified">2864      * rolling through February will leave it set to 28.  The {@code GregorianCalendar}</span>
2865      * version of this function takes care of this problem.  Other subclasses
2866      * should also provide overrides of this function that do the right thing.
2867      *
2868      * @param field the calendar field.
<span class="line-modified">2869      * @param amount the signed amount to add to the calendar {@code field}.</span>
2870      * @since 1.2
2871      * @see #roll(int,boolean)
2872      * @see #add(int,int)
2873      * @see #set(int,int)
2874      */
2875     public void roll(int field, int amount)
2876     {
2877         while (amount &gt; 0) {
2878             roll(field, true);
2879             amount--;
2880         }
2881         while (amount &lt; 0) {
2882             roll(field, false);
2883             amount++;
2884         }
2885     }
2886 
2887     /**
2888      * Sets the time zone with the given time zone value.
2889      *
</pre>
<hr />
<pre>
2912      */
2913     public TimeZone getTimeZone()
2914     {
2915         // If the TimeZone object is shared by other Calendar instances, then
2916         // create a clone.
2917         if (sharedZone) {
2918             zone = (TimeZone) zone.clone();
2919             sharedZone = false;
2920         }
2921         return zone;
2922     }
2923 
2924     /**
2925      * Returns the time zone (without cloning).
2926      */
2927     TimeZone getZone() {
2928         return zone;
2929     }
2930 
2931     /**
<span class="line-modified">2932      * Sets the sharedZone flag to {@code shared}.</span>
2933      */
2934     void setZoneShared(boolean shared) {
2935         sharedZone = shared;
2936     }
2937 
2938     /**
2939      * Specifies whether or not date/time interpretation is to be lenient.  With
2940      * lenient interpretation, a date such as &quot;February 942, 1996&quot; will be
2941      * treated as being equivalent to the 941st day after February 1, 1996.
2942      * With strict (non-lenient) interpretation, such dates will cause an exception to be
2943      * thrown. The default is lenient.
2944      *
<span class="line-modified">2945      * @param lenient {@code true} if the lenient mode is to be turned</span>
<span class="line-modified">2946      * on; {@code false} if it is to be turned off.</span>
2947      * @see #isLenient()
2948      * @see java.text.DateFormat#setLenient
2949      */
2950     public void setLenient(boolean lenient)
2951     {
2952         this.lenient = lenient;
2953     }
2954 
2955     /**
2956      * Tells whether date/time interpretation is to be lenient.
2957      *
<span class="line-modified">2958      * @return {@code true} if the interpretation mode of this calendar is lenient;</span>
<span class="line-modified">2959      * {@code false} otherwise.</span>
2960      * @see #setLenient(boolean)
2961      */
2962     public boolean isLenient()
2963     {
2964         return lenient;
2965     }
2966 
2967     /**
<span class="line-modified">2968      * Sets what the first day of the week is; e.g., {@code SUNDAY} in the U.S.,</span>
<span class="line-modified">2969      * {@code MONDAY} in France.</span>
2970      *
2971      * @param value the given first day of the week.
2972      * @see #getFirstDayOfWeek()
2973      * @see #getMinimalDaysInFirstWeek()
2974      */
2975     public void setFirstDayOfWeek(int value)
2976     {
2977         if (firstDayOfWeek == value) {
2978             return;
2979         }
2980         firstDayOfWeek = value;
2981         invalidateWeekFields();
2982     }
2983 
2984     /**
<span class="line-modified">2985      * Gets what the first day of the week is; e.g., {@code SUNDAY} in the U.S.,</span>
<span class="line-modified">2986      * {@code MONDAY} in France.</span>
2987      *
2988      * @return the first day of the week.
2989      * @see #setFirstDayOfWeek(int)
2990      * @see #getMinimalDaysInFirstWeek()
2991      */
2992     public int getFirstDayOfWeek()
2993     {
2994         return firstDayOfWeek;
2995     }
2996 
2997     /**
2998      * Sets what the minimal days required in the first week of the year are;
2999      * For example, if the first week is defined as one that contains the first
3000      * day of the first month of a year, call this method with value 1. If it
3001      * must be a full week, use value 7.
3002      *
3003      * @param value the given minimal days required in the first week
3004      * of the year.
3005      * @see #getMinimalDaysInFirstWeek()
3006      */
</pre>
<hr />
<pre>
3037      *         {@code false} otherwise.
3038      * @see #getWeekYear()
3039      * @see #setWeekDate(int,int,int)
3040      * @see #getWeeksInWeekYear()
3041      * @since 1.7
3042      */
3043     public boolean isWeekDateSupported() {
3044         return false;
3045     }
3046 
3047     /**
3048      * Returns the week year represented by this {@code Calendar}. The
3049      * week year is in sync with the week cycle. The {@linkplain
3050      * #getFirstDayOfWeek() first day of the first week} is the first
3051      * day of the week year.
3052      *
3053      * &lt;p&gt;The default implementation of this method throws an
3054      * {@link UnsupportedOperationException}.
3055      *
3056      * @return the week year of this {@code Calendar}
<span class="line-modified">3057      * @throws    UnsupportedOperationException</span>
3058      *            if any week year numbering isn&#39;t supported
3059      *            in this {@code Calendar}.
3060      * @see #isWeekDateSupported()
3061      * @see #getFirstDayOfWeek()
3062      * @see #getMinimalDaysInFirstWeek()
3063      * @since 1.7
3064      */
3065     public int getWeekYear() {
3066         throw new UnsupportedOperationException();
3067     }
3068 
3069     /**
3070      * Sets the date of this {@code Calendar} with the given date
3071      * specifiers - week year, week of year, and day of week.
3072      *
3073      * &lt;p&gt;Unlike the {@code set} method, all of the calendar fields
3074      * and {@code time} values are calculated upon return.
3075      *
3076      * &lt;p&gt;If {@code weekOfYear} is out of the valid week-of-year range
3077      * in {@code weekYear}, the {@code weekYear} and {@code
3078      * weekOfYear} values are adjusted in lenient mode, or an {@code
3079      * IllegalArgumentException} is thrown in non-lenient mode.
3080      *
3081      * &lt;p&gt;The default implementation of this method throws an
3082      * {@code UnsupportedOperationException}.
3083      *
3084      * @param weekYear   the week year
3085      * @param weekOfYear the week number based on {@code weekYear}
3086      * @param dayOfWeek  the day of week value: one of the constants
3087      *                   for the {@link #DAY_OF_WEEK} field: {@link
3088      *                   #SUNDAY}, ..., {@link #SATURDAY}.
<span class="line-modified">3089      * @throws    IllegalArgumentException</span>
3090      *            if any of the given date specifiers is invalid
3091      *            or any of the calendar fields are inconsistent
3092      *            with the given date specifiers in non-lenient mode
<span class="line-modified">3093      * @throws    UnsupportedOperationException</span>
3094      *            if any week year numbering isn&#39;t supported in this
3095      *            {@code Calendar}.
3096      * @see #isWeekDateSupported()
3097      * @see #getFirstDayOfWeek()
3098      * @see #getMinimalDaysInFirstWeek()
3099      * @since 1.7
3100      */
3101     public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
3102         throw new UnsupportedOperationException();
3103     }
3104 
3105     /**
3106      * Returns the number of weeks in the week year represented by this
3107      * {@code Calendar}.
3108      *
3109      * &lt;p&gt;The default implementation of this method throws an
3110      * {@code UnsupportedOperationException}.
3111      *
3112      * @return the number of weeks in the week year.
<span class="line-modified">3113      * @throws    UnsupportedOperationException</span>
3114      *            if any week year numbering isn&#39;t supported in this
3115      *            {@code Calendar}.
3116      * @see #WEEK_OF_YEAR
3117      * @see #isWeekDateSupported()
3118      * @see #getWeekYear()
3119      * @see #getActualMaximum(int)
3120      * @since 1.7
3121      */
3122     public int getWeeksInWeekYear() {
3123         throw new UnsupportedOperationException();
3124     }
3125 
3126     /**
3127      * Returns the minimum value for the given calendar field of this
<span class="line-modified">3128      * {@code Calendar} instance. The minimum value is defined as</span>
3129      * the smallest value returned by the {@link #get(int) get} method
3130      * for any possible time value.  The minimum value depends on
3131      * calendar system specific parameters of the instance.
3132      *
3133      * @param field the calendar field.
3134      * @return the minimum value for the given calendar field.
3135      * @see #getMaximum(int)
3136      * @see #getGreatestMinimum(int)
3137      * @see #getLeastMaximum(int)
3138      * @see #getActualMinimum(int)
3139      * @see #getActualMaximum(int)
3140      */
3141     public abstract int getMinimum(int field);
3142 
3143     /**
3144      * Returns the maximum value for the given calendar field of this
<span class="line-modified">3145      * {@code Calendar} instance. The maximum value is defined as</span>
3146      * the largest value returned by the {@link #get(int) get} method
3147      * for any possible time value. The maximum value depends on
3148      * calendar system specific parameters of the instance.
3149      *
3150      * @param field the calendar field.
3151      * @return the maximum value for the given calendar field.
3152      * @see #getMinimum(int)
3153      * @see #getGreatestMinimum(int)
3154      * @see #getLeastMaximum(int)
3155      * @see #getActualMinimum(int)
3156      * @see #getActualMaximum(int)
3157      */
3158     public abstract int getMaximum(int field);
3159 
3160     /**
3161      * Returns the highest minimum value for the given calendar field
<span class="line-modified">3162      * of this {@code Calendar} instance. The highest minimum</span>
3163      * value is defined as the largest value returned by {@link
3164      * #getActualMinimum(int)} for any possible time value. The
3165      * greatest minimum value depends on calendar system specific
3166      * parameters of the instance.
3167      *
3168      * @param field the calendar field.
3169      * @return the highest minimum value for the given calendar field.
3170      * @see #getMinimum(int)
3171      * @see #getMaximum(int)
3172      * @see #getLeastMaximum(int)
3173      * @see #getActualMinimum(int)
3174      * @see #getActualMaximum(int)
3175      */
3176     public abstract int getGreatestMinimum(int field);
3177 
3178     /**
3179      * Returns the lowest maximum value for the given calendar field
<span class="line-modified">3180      * of this {@code Calendar} instance. The lowest maximum</span>
3181      * value is defined as the smallest value returned by {@link
3182      * #getActualMaximum(int)} for any possible time value. The least
3183      * maximum value depends on calendar system specific parameters of
<span class="line-modified">3184      * the instance. For example, a {@code Calendar} for the</span>
3185      * Gregorian calendar system returns 28 for the
<span class="line-modified">3186      * {@code DAY_OF_MONTH} field, because the 28th is the last</span>
3187      * day of the shortest month of this calendar, February in a
3188      * common year.
3189      *
3190      * @param field the calendar field.
3191      * @return the lowest maximum value for the given calendar field.
3192      * @see #getMinimum(int)
3193      * @see #getMaximum(int)
3194      * @see #getGreatestMinimum(int)
3195      * @see #getActualMinimum(int)
3196      * @see #getActualMaximum(int)
3197      */
3198     public abstract int getLeastMaximum(int field);
3199 
3200     /**
3201      * Returns the minimum value that the specified calendar field
<span class="line-modified">3202      * could have, given the time value of this {@code Calendar}.</span>
3203      *
3204      * &lt;p&gt;The default implementation of this method uses an iterative
3205      * algorithm to determine the actual minimum value for the
3206      * calendar field. Subclasses should, if possible, override this
3207      * with a more efficient implementation - in many cases, they can
<span class="line-modified">3208      * simply return {@code getMinimum()}.</span>
3209      *
3210      * @param field the calendar field
3211      * @return the minimum of the given calendar field for the time
<span class="line-modified">3212      * value of this {@code Calendar}</span>
3213      * @see #getMinimum(int)
3214      * @see #getMaximum(int)
3215      * @see #getGreatestMinimum(int)
3216      * @see #getLeastMaximum(int)
3217      * @see #getActualMaximum(int)
3218      * @since 1.2
3219      */
3220     public int getActualMinimum(int field) {
3221         int fieldValue = getGreatestMinimum(field);
3222         int endValue = getMinimum(field);
3223 
3224         // if we know that the minimum value is always the same, just return it
3225         if (fieldValue == endValue) {
3226             return fieldValue;
3227         }
3228 
3229         // clone the calendar so we don&#39;t mess with the real one, and set it to
3230         // accept anything for the field values
3231         Calendar work = (Calendar)this.clone();
3232         work.setLenient(true);
</pre>
<hr />
<pre>
3235         // we get a value that normalizes to another value.  The last value that
3236         // normalizes to itself is the actual minimum for the current date
3237         int result = fieldValue;
3238 
3239         do {
3240             work.set(field, fieldValue);
3241             if (work.get(field) != fieldValue) {
3242                 break;
3243             } else {
3244                 result = fieldValue;
3245                 fieldValue--;
3246             }
3247         } while (fieldValue &gt;= endValue);
3248 
3249         return result;
3250     }
3251 
3252     /**
3253      * Returns the maximum value that the specified calendar field
3254      * could have, given the time value of this
<span class="line-modified">3255      * {@code Calendar}. For example, the actual maximum value of</span>
<span class="line-modified">3256      * the {@code MONTH} field is 12 in some years, and 13 in</span>
3257      * other years in the Hebrew calendar system.
3258      *
3259      * &lt;p&gt;The default implementation of this method uses an iterative
3260      * algorithm to determine the actual maximum value for the
3261      * calendar field. Subclasses should, if possible, override this
3262      * with a more efficient implementation.
3263      *
3264      * @param field the calendar field
3265      * @return the maximum of the given calendar field for the time
<span class="line-modified">3266      * value of this {@code Calendar}</span>
3267      * @see #getMinimum(int)
3268      * @see #getMaximum(int)
3269      * @see #getGreatestMinimum(int)
3270      * @see #getLeastMaximum(int)
3271      * @see #getActualMinimum(int)
3272      * @since 1.2
3273      */
3274     public int getActualMaximum(int field) {
3275         int fieldValue = getLeastMaximum(field);
3276         int endValue = getMaximum(field);
3277 
3278         // if we know that the maximum value is always the same, just return it.
3279         if (fieldValue == endValue) {
3280             return fieldValue;
3281         }
3282 
3283         // clone the calendar so we don&#39;t mess with the real one, and set it to
3284         // accept anything for the field values.
3285         Calendar work = (Calendar)this.clone();
3286         work.setLenient(true);
</pre>
<hr />
<pre>
3334             return other;
3335         }
3336         catch (CloneNotSupportedException e) {
3337             // this shouldn&#39;t happen, since we are Cloneable
3338             throw new InternalError(e);
3339         }
3340     }
3341 
3342     private static final String[] FIELD_NAME = {
3343         &quot;ERA&quot;, &quot;YEAR&quot;, &quot;MONTH&quot;, &quot;WEEK_OF_YEAR&quot;, &quot;WEEK_OF_MONTH&quot;, &quot;DAY_OF_MONTH&quot;,
3344         &quot;DAY_OF_YEAR&quot;, &quot;DAY_OF_WEEK&quot;, &quot;DAY_OF_WEEK_IN_MONTH&quot;, &quot;AM_PM&quot;, &quot;HOUR&quot;,
3345         &quot;HOUR_OF_DAY&quot;, &quot;MINUTE&quot;, &quot;SECOND&quot;, &quot;MILLISECOND&quot;, &quot;ZONE_OFFSET&quot;,
3346         &quot;DST_OFFSET&quot;
3347     };
3348 
3349     /**
3350      * Returns the name of the specified calendar field.
3351      *
3352      * @param field the calendar field
3353      * @return the calendar field name
<span class="line-modified">3354      * @throws    IndexOutOfBoundsException if {@code field} is negative,</span>
3355      * equal to or greater than {@code FIELD_COUNT}.
3356      */
3357     static String getFieldName(int field) {
3358         return FIELD_NAME[field];
3359     }
3360 
3361     /**
3362      * Return a string representation of this calendar. This method
3363      * is intended to be used only for debugging purposes, and the
3364      * format of the returned string may vary between implementations.
<span class="line-modified">3365      * The returned string may be empty but may not be {@code null}.</span>
3366      *
3367      * @return  a string representation of this calendar.
3368      */
3369     @Override
3370     public String toString() {
3371         // NOTE: BuddhistCalendar.toString() interprets the string
3372         // produced by this method so that the Gregorian year number
3373         // is substituted by its B.E. year value. It relies on
3374         // &quot;...,YEAR=&lt;year&gt;,...&quot; or &quot;...,YEAR=?,...&quot;.
3375         StringBuilder buffer = new StringBuilder(800);
3376         buffer.append(getClass().getName()).append(&#39;[&#39;);
3377         appendValue(buffer, &quot;time&quot;, isTimeSet, time);
3378         buffer.append(&quot;,areFieldsSet=&quot;).append(areFieldsSet);
3379         buffer.append(&quot;,areAllFieldsSet=&quot;).append(areAllFieldsSet);
3380         buffer.append(&quot;,lenient=&quot;).append(lenient);
3381         buffer.append(&quot;,zone=&quot;).append(zone);
3382         appendValue(buffer, &quot;,firstDayOfWeek&quot;, true, (long) firstDayOfWeek);
3383         appendValue(buffer, &quot;,minimalDaysInFirstWeek&quot;, true, (long) minimalDaysInFirstWeek);
3384         for (int i = 0; i &lt; FIELD_COUNT; ++i) {
3385             buffer.append(&#39;,&#39;);
</pre>
<hr />
<pre>
3500         cal.clear(WEEK_OF_YEAR);
3501 
3502         if (stamp[WEEK_OF_MONTH] == COMPUTED) {
3503             int weekOfMonth = cal.get(WEEK_OF_MONTH);
3504             if (fields[WEEK_OF_MONTH] != weekOfMonth) {
3505                 fields[WEEK_OF_MONTH] = weekOfMonth;
3506             }
3507         }
3508 
3509         if (stamp[WEEK_OF_YEAR] == COMPUTED) {
3510             int weekOfYear = cal.get(WEEK_OF_YEAR);
3511             if (fields[WEEK_OF_YEAR] != weekOfYear) {
3512                 fields[WEEK_OF_YEAR] = weekOfYear;
3513             }
3514         }
3515     }
3516 
3517     /**
3518      * Save the state of this object to a stream (i.e., serialize it).
3519      *
<span class="line-modified">3520      * Ideally, {@code Calendar} would only write out its state data and</span>
3521      * the current time, and not write any field data out, such as
<span class="line-modified">3522      * {@code fields[]}, {@code isTimeSet}, {@code areFieldsSet},</span>
<span class="line-modified">3523      * and {@code isSet[]}.  {@code nextStamp} also should not be part</span>
3524      * of the persistent state. Unfortunately, this didn&#39;t happen before JDK 1.1
3525      * shipped. To be compatible with JDK 1.1, we will always have to write out
<span class="line-modified">3526      * the field values and state flags.  However, {@code nextStamp} can be</span>
3527      * removed from the serialization stream; this will probably happen in the
3528      * near future.
3529      */
<span class="line-added">3530     @java.io.Serial</span>
3531     private synchronized void writeObject(ObjectOutputStream stream)
3532          throws IOException
3533     {
3534         // Try to compute the time correctly, for the future (stream
3535         // version 2) in which we don&#39;t write out fields[] or isSet[].
3536         if (!isTimeSet) {
3537             try {
3538                 updateTime();
3539             }
3540             catch (IllegalArgumentException e) {}
3541         }
3542 
3543         // If this Calendar has a ZoneInfo, save it and set a
3544         // SimpleTimeZone equivalent (as a single DST schedule) for
3545         // backward compatibility.
3546         TimeZone savedZone = null;
3547         if (zone instanceof ZoneInfo) {
3548             SimpleTimeZone stz = ((ZoneInfo)zone).getLastRuleInstance();
3549             if (stz == null) {
3550                 stz = new SimpleTimeZone(zone.getRawOffset(), zone.getID());
</pre>
<hr />
<pre>
3565         }
3566     }
3567 
3568     private static class CalendarAccessControlContext {
3569         private static final AccessControlContext INSTANCE;
3570         static {
3571             RuntimePermission perm = new RuntimePermission(&quot;accessClassInPackage.sun.util.calendar&quot;);
3572             PermissionCollection perms = perm.newPermissionCollection();
3573             perms.add(perm);
3574             INSTANCE = new AccessControlContext(new ProtectionDomain[] {
3575                                                     new ProtectionDomain(null, perms)
3576                                                 });
3577         }
3578         private CalendarAccessControlContext() {
3579         }
3580     }
3581 
3582     /**
3583      * Reconstitutes this object from a stream (i.e., deserialize it).
3584      */
<span class="line-added">3585     @java.io.Serial</span>
3586     private void readObject(ObjectInputStream stream)
3587          throws IOException, ClassNotFoundException
3588     {
3589         final ObjectInputStream input = stream;
3590         input.defaultReadObject();
3591 
3592         stamp = new int[FIELD_COUNT];
3593 
3594         // Starting with version 2 (not implemented yet), we expect that
3595         // fields[], isSet[], isTimeSet, and areFieldsSet may not be
3596         // streamed out anymore.  We expect &#39;time&#39; to be correct.
3597         if (serialVersionOnStream &gt;= 2)
3598         {
3599             isTimeSet = true;
3600             if (fields == null) {
3601                 fields = new int[FIELD_COUNT];
3602             }
3603             if (isSet == null) {
3604                 isSet = new boolean[FIELD_COUNT];
3605             }
</pre>
</td>
</tr>
</table>
<center><a href="BitSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Collection.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
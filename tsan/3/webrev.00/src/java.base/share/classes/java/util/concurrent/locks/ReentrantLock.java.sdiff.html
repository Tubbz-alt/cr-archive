<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LockSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantReadWriteLock.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
102  * the same thread. Attempts to exceed this limit result in
103  * {@link Error} throws from locking methods.
104  *
105  * @since 1.5
106  * @author Doug Lea
107  */
108 public class ReentrantLock implements Lock, java.io.Serializable {
109     private static final long serialVersionUID = 7373984872572414699L;
110     /** Synchronizer providing all implementation mechanics */
111     private final Sync sync;
112 
113     /**
114      * Base of synchronization control for this lock. Subclassed
115      * into fair and nonfair versions below. Uses AQS state to
116      * represent the number of holds on the lock.
117      */
118     abstract static class Sync extends AbstractQueuedSynchronizer {
119         private static final long serialVersionUID = -5179523762034025860L;
120 
121         /**
<span class="line-modified">122          * Performs non-fair tryLock.  tryAcquire is implemented in</span>
<span class="line-removed">123          * subclasses, but both need nonfair try for trylock method.</span>
124          */
125         @ReservedStackAccess
<span class="line-modified">126         final boolean nonfairTryAcquire(int acquires) {</span>
<span class="line-modified">127             final Thread current = Thread.currentThread();</span>
128             int c = getState();
129             if (c == 0) {
<span class="line-modified">130                 if (compareAndSetState(0, acquires)) {</span>
131                     setExclusiveOwnerThread(current);
132                     return true;
133                 }
<span class="line-modified">134             }</span>
<span class="line-modified">135             else if (current == getExclusiveOwnerThread()) {</span>
<span class="line-removed">136                 int nextc = c + acquires;</span>
<span class="line-removed">137                 if (nextc &lt; 0) // overflow</span>
138                     throw new Error(&quot;Maximum lock count exceeded&quot;);
<span class="line-modified">139                 setState(nextc);</span>
140                 return true;
141             }
142             return false;
143         }
144 





























145         @ReservedStackAccess
146         protected final boolean tryRelease(int releases) {
147             int c = getState() - releases;
<span class="line-modified">148             if (Thread.currentThread() != getExclusiveOwnerThread())</span>
149                 throw new IllegalMonitorStateException();
<span class="line-modified">150             boolean free = false;</span>
<span class="line-modified">151             if (c == 0) {</span>
<span class="line-removed">152                 free = true;</span>
153                 setExclusiveOwnerThread(null);
<span class="line-removed">154             }</span>
155             setState(c);
156             return free;
157         }
158 
159         protected final boolean isHeldExclusively() {
160             // While we must in general read state before owner,
161             // we don&#39;t need to do so to check if current thread is owner
162             return getExclusiveOwnerThread() == Thread.currentThread();
163         }
164 
165         final ConditionObject newCondition() {
166             return new ConditionObject();
167         }
168 
169         // Methods relayed from outer class
170 
171         final Thread getOwner() {
172             return getState() == 0 ? null : getExclusiveOwnerThread();
173         }
174 
</pre>
<hr />
<pre>
178 
179         final boolean isLocked() {
180             return getState() != 0;
181         }
182 
183         /**
184          * Reconstitutes the instance from a stream (that is, deserializes it).
185          */
186         private void readObject(java.io.ObjectInputStream s)
187             throws java.io.IOException, ClassNotFoundException {
188             s.defaultReadObject();
189             setState(0); // reset to unlocked state
190         }
191     }
192 
193     /**
194      * Sync object for non-fair locks
195      */
196     static final class NonfairSync extends Sync {
197         private static final long serialVersionUID = 7316153563782823691L;



















198         protected final boolean tryAcquire(int acquires) {
<span class="line-modified">199             return nonfairTryAcquire(acquires);</span>




200         }
201     }
202 
203     /**
204      * Sync object for fair locks
205      */
206     static final class FairSync extends Sync {
207         private static final long serialVersionUID = -3000897897090466540L;

208         /**
<span class="line-modified">209          * Fair version of tryAcquire.  Don&#39;t grant access unless</span>
<span class="line-removed">210          * recursive call or no waiters or is first.</span>
211          */
<span class="line-modified">212         @ReservedStackAccess</span>
<span class="line-modified">213         protected final boolean tryAcquire(int acquires) {</span>
<span class="line-removed">214             final Thread current = Thread.currentThread();</span>
215             int c = getState();
216             if (c == 0) {
<span class="line-modified">217                 if (!hasQueuedPredecessors() &amp;&amp;</span>
<span class="line-removed">218                     compareAndSetState(0, acquires)) {</span>
219                     setExclusiveOwnerThread(current);
220                     return true;
221                 }
<span class="line-modified">222             }</span>
<span class="line-modified">223             else if (current == getExclusiveOwnerThread()) {</span>
<span class="line-removed">224                 int nextc = c + acquires;</span>
<span class="line-removed">225                 if (nextc &lt; 0)</span>
226                     throw new Error(&quot;Maximum lock count exceeded&quot;);
<span class="line-modified">227                 setState(nextc);</span>












228                 return true;
229             }
230             return false;
231         }
232     }
233 
234     /**
235      * Creates an instance of {@code ReentrantLock}.
236      * This is equivalent to using {@code ReentrantLock(false)}.
237      */
238     public ReentrantLock() {
239         sync = new NonfairSync();
240     }
241 
242     /**
243      * Creates an instance of {@code ReentrantLock} with the
244      * given fairness policy.
245      *
246      * @param fair {@code true} if this lock should use a fair ordering policy
247      */
248     public ReentrantLock(boolean fair) {
249         sync = fair ? new FairSync() : new NonfairSync();
250     }
251 
252     /**
253      * Acquires the lock.
254      *
255      * &lt;p&gt;Acquires the lock if it is not held by another thread and returns
256      * immediately, setting the lock hold count to one.
257      *
258      * &lt;p&gt;If the current thread already holds the lock then the hold
259      * count is incremented by one and the method returns immediately.
260      *
261      * &lt;p&gt;If the lock is held by another thread then the
262      * current thread becomes disabled for thread scheduling
263      * purposes and lies dormant until the lock has been acquired,
264      * at which time the lock hold count is set to one.
265      */
266     public void lock() {
<span class="line-modified">267         sync.acquire(1);</span>
268     }
269 
270     /**
271      * Acquires the lock unless the current thread is
272      * {@linkplain Thread#interrupt interrupted}.
273      *
274      * &lt;p&gt;Acquires the lock if it is not held by another thread and returns
275      * immediately, setting the lock hold count to one.
276      *
277      * &lt;p&gt;If the current thread already holds this lock then the hold count
278      * is incremented by one and the method returns immediately.
279      *
280      * &lt;p&gt;If the lock is held by another thread then the
281      * current thread becomes disabled for thread scheduling
282      * purposes and lies dormant until one of two things happens:
283      *
284      * &lt;ul&gt;
285      *
286      * &lt;li&gt;The lock is acquired by the current thread; or
287      *
</pre>
<hr />
<pre>
297      *
298      * &lt;ul&gt;
299      *
300      * &lt;li&gt;has its interrupted status set on entry to this method; or
301      *
302      * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring
303      * the lock,
304      *
305      * &lt;/ul&gt;
306      *
307      * then {@link InterruptedException} is thrown and the current thread&#39;s
308      * interrupted status is cleared.
309      *
310      * &lt;p&gt;In this implementation, as this method is an explicit
311      * interruption point, preference is given to responding to the
312      * interrupt over normal or reentrant acquisition of the lock.
313      *
314      * @throws InterruptedException if the current thread is interrupted
315      */
316     public void lockInterruptibly() throws InterruptedException {
<span class="line-modified">317         sync.acquireInterruptibly(1);</span>
318     }
319 
320     /**
321      * Acquires the lock only if it is not held by another thread at the time
322      * of invocation.
323      *
324      * &lt;p&gt;Acquires the lock if it is not held by another thread and
325      * returns immediately with the value {@code true}, setting the
326      * lock hold count to one. Even when this lock has been set to use a
327      * fair ordering policy, a call to {@code tryLock()} &lt;em&gt;will&lt;/em&gt;
328      * immediately acquire the lock if it is available, whether or not
329      * other threads are currently waiting for the lock.
330      * This &amp;quot;barging&amp;quot; behavior can be useful in certain
331      * circumstances, even though it breaks fairness. If you want to honor
332      * the fairness setting for this lock, then use
333      * {@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS)}
334      * which is almost equivalent (it also detects interruption).
335      *
336      * &lt;p&gt;If the current thread already holds this lock then the hold
337      * count is incremented by one and the method returns {@code true}.
338      *
339      * &lt;p&gt;If the lock is held by another thread then this method will return
340      * immediately with the value {@code false}.
341      *
342      * @return {@code true} if the lock was free and was acquired by the
343      *         current thread, or the lock was already held by the current
344      *         thread; and {@code false} otherwise
345      */
346     public boolean tryLock() {
<span class="line-modified">347         return sync.nonfairTryAcquire(1);</span>
348     }
349 
350     /**
351      * Acquires the lock if it is not held by another thread within the given
352      * waiting time and the current thread has not been
353      * {@linkplain Thread#interrupt interrupted}.
354      *
355      * &lt;p&gt;Acquires the lock if it is not held by another thread and returns
356      * immediately with the value {@code true}, setting the lock hold count
357      * to one. If this lock has been set to use a fair ordering policy then
358      * an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads
359      * are waiting for the lock. This is in contrast to the {@link #tryLock()}
360      * method. If you want a timed {@code tryLock} that does permit barging on
361      * a fair lock then combine the timed and un-timed forms together:
362      *
363      * &lt;pre&gt; {@code
364      * if (lock.tryLock() ||
365      *     lock.tryLock(timeout, unit)) {
366      *   ...
367      * }}&lt;/pre&gt;
</pre>
<hr />
<pre>
404      * &lt;p&gt;If the specified waiting time elapses then the value {@code false}
405      * is returned.  If the time is less than or equal to zero, the method
406      * will not wait at all.
407      *
408      * &lt;p&gt;In this implementation, as this method is an explicit
409      * interruption point, preference is given to responding to the
410      * interrupt over normal or reentrant acquisition of the lock, and
411      * over reporting the elapse of the waiting time.
412      *
413      * @param timeout the time to wait for the lock
414      * @param unit the time unit of the timeout argument
415      * @return {@code true} if the lock was free and was acquired by the
416      *         current thread, or the lock was already held by the current
417      *         thread; and {@code false} if the waiting time elapsed before
418      *         the lock could be acquired
419      * @throws InterruptedException if the current thread is interrupted
420      * @throws NullPointerException if the time unit is null
421      */
422     public boolean tryLock(long timeout, TimeUnit unit)
423             throws InterruptedException {
<span class="line-modified">424         return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span>
425     }
426 
427     /**
428      * Attempts to release this lock.
429      *
430      * &lt;p&gt;If the current thread is the holder of this lock then the hold
431      * count is decremented.  If the hold count is now zero then the lock
432      * is released.  If the current thread is not the holder of this
433      * lock then {@link IllegalMonitorStateException} is thrown.
434      *
435      * @throws IllegalMonitorStateException if the current thread does not
436      *         hold this lock
437      */
438     public void unlock() {
439         sync.release(1);
440     }
441 
442     /**
443      * Returns a {@link Condition} instance for use with this
444      * {@link Lock} instance.
</pre>
</td>
<td>
<hr />
<pre>
102  * the same thread. Attempts to exceed this limit result in
103  * {@link Error} throws from locking methods.
104  *
105  * @since 1.5
106  * @author Doug Lea
107  */
108 public class ReentrantLock implements Lock, java.io.Serializable {
109     private static final long serialVersionUID = 7373984872572414699L;
110     /** Synchronizer providing all implementation mechanics */
111     private final Sync sync;
112 
113     /**
114      * Base of synchronization control for this lock. Subclassed
115      * into fair and nonfair versions below. Uses AQS state to
116      * represent the number of holds on the lock.
117      */
118     abstract static class Sync extends AbstractQueuedSynchronizer {
119         private static final long serialVersionUID = -5179523762034025860L;
120 
121         /**
<span class="line-modified">122          * Performs non-fair tryLock.</span>

123          */
124         @ReservedStackAccess
<span class="line-modified">125         final boolean tryLock() {</span>
<span class="line-modified">126             Thread current = Thread.currentThread();</span>
127             int c = getState();
128             if (c == 0) {
<span class="line-modified">129                 if (compareAndSetState(0, 1)) {</span>
130                     setExclusiveOwnerThread(current);
131                     return true;
132                 }
<span class="line-modified">133             } else if (getExclusiveOwnerThread() == current) {</span>
<span class="line-modified">134                 if (++c &lt; 0) // overflow</span>


135                     throw new Error(&quot;Maximum lock count exceeded&quot;);
<span class="line-modified">136                 setState(c);</span>
137                 return true;
138             }
139             return false;
140         }
141 
<span class="line-added">142         /**</span>
<span class="line-added">143          * Checks for reentrancy and acquires if lock immediately</span>
<span class="line-added">144          * available under fair vs nonfair rules. Locking methods</span>
<span class="line-added">145          * perform initialTryLock check before relaying to</span>
<span class="line-added">146          * corresponding AQS acquire methods.</span>
<span class="line-added">147          */</span>
<span class="line-added">148         abstract boolean initialTryLock();</span>
<span class="line-added">149 </span>
<span class="line-added">150         @ReservedStackAccess</span>
<span class="line-added">151         final void lock() {</span>
<span class="line-added">152             if (!initialTryLock())</span>
<span class="line-added">153                 acquire(1);</span>
<span class="line-added">154         }</span>
<span class="line-added">155 </span>
<span class="line-added">156         @ReservedStackAccess</span>
<span class="line-added">157         final void lockInterruptibly() throws InterruptedException {</span>
<span class="line-added">158             if (Thread.interrupted())</span>
<span class="line-added">159                 throw new InterruptedException();</span>
<span class="line-added">160             if (!initialTryLock())</span>
<span class="line-added">161                 acquireInterruptibly(1);</span>
<span class="line-added">162         }</span>
<span class="line-added">163 </span>
<span class="line-added">164         @ReservedStackAccess</span>
<span class="line-added">165         final boolean tryLockNanos(long nanos) throws InterruptedException {</span>
<span class="line-added">166             if (Thread.interrupted())</span>
<span class="line-added">167                 throw new InterruptedException();</span>
<span class="line-added">168             return initialTryLock() || tryAcquireNanos(1, nanos);</span>
<span class="line-added">169         }</span>
<span class="line-added">170 </span>
171         @ReservedStackAccess
172         protected final boolean tryRelease(int releases) {
173             int c = getState() - releases;
<span class="line-modified">174             if (getExclusiveOwnerThread() != Thread.currentThread())</span>
175                 throw new IllegalMonitorStateException();
<span class="line-modified">176             boolean free = (c == 0);</span>
<span class="line-modified">177             if (free)</span>

178                 setExclusiveOwnerThread(null);

179             setState(c);
180             return free;
181         }
182 
183         protected final boolean isHeldExclusively() {
184             // While we must in general read state before owner,
185             // we don&#39;t need to do so to check if current thread is owner
186             return getExclusiveOwnerThread() == Thread.currentThread();
187         }
188 
189         final ConditionObject newCondition() {
190             return new ConditionObject();
191         }
192 
193         // Methods relayed from outer class
194 
195         final Thread getOwner() {
196             return getState() == 0 ? null : getExclusiveOwnerThread();
197         }
198 
</pre>
<hr />
<pre>
202 
203         final boolean isLocked() {
204             return getState() != 0;
205         }
206 
207         /**
208          * Reconstitutes the instance from a stream (that is, deserializes it).
209          */
210         private void readObject(java.io.ObjectInputStream s)
211             throws java.io.IOException, ClassNotFoundException {
212             s.defaultReadObject();
213             setState(0); // reset to unlocked state
214         }
215     }
216 
217     /**
218      * Sync object for non-fair locks
219      */
220     static final class NonfairSync extends Sync {
221         private static final long serialVersionUID = 7316153563782823691L;
<span class="line-added">222 </span>
<span class="line-added">223         final boolean initialTryLock() {</span>
<span class="line-added">224             Thread current = Thread.currentThread();</span>
<span class="line-added">225             if (compareAndSetState(0, 1)) { // first attempt is unguarded</span>
<span class="line-added">226                 setExclusiveOwnerThread(current);</span>
<span class="line-added">227                 return true;</span>
<span class="line-added">228             } else if (getExclusiveOwnerThread() == current) {</span>
<span class="line-added">229                 int c = getState() + 1;</span>
<span class="line-added">230                 if (c &lt; 0) // overflow</span>
<span class="line-added">231                     throw new Error(&quot;Maximum lock count exceeded&quot;);</span>
<span class="line-added">232                 setState(c);</span>
<span class="line-added">233                 return true;</span>
<span class="line-added">234             } else</span>
<span class="line-added">235                 return false;</span>
<span class="line-added">236         }</span>
<span class="line-added">237 </span>
<span class="line-added">238         /**</span>
<span class="line-added">239          * Acquire for non-reentrant cases after initialTryLock prescreen</span>
<span class="line-added">240          */</span>
241         protected final boolean tryAcquire(int acquires) {
<span class="line-modified">242             if (getState() == 0 &amp;&amp; compareAndSetState(0, acquires)) {</span>
<span class="line-added">243                 setExclusiveOwnerThread(Thread.currentThread());</span>
<span class="line-added">244                 return true;</span>
<span class="line-added">245             }</span>
<span class="line-added">246             return false;</span>
247         }
248     }
249 
250     /**
251      * Sync object for fair locks
252      */
253     static final class FairSync extends Sync {
254         private static final long serialVersionUID = -3000897897090466540L;
<span class="line-added">255 </span>
256         /**
<span class="line-modified">257          * Acquires only if reentrant or queue is empty.</span>

258          */
<span class="line-modified">259         final boolean initialTryLock() {</span>
<span class="line-modified">260             Thread current = Thread.currentThread();</span>

261             int c = getState();
262             if (c == 0) {
<span class="line-modified">263                 if (!hasQueuedThreads() &amp;&amp; compareAndSetState(0, 1)) {</span>

264                     setExclusiveOwnerThread(current);
265                     return true;
266                 }
<span class="line-modified">267             } else if (getExclusiveOwnerThread() == current) {</span>
<span class="line-modified">268                 if (++c &lt; 0) // overflow</span>


269                     throw new Error(&quot;Maximum lock count exceeded&quot;);
<span class="line-modified">270                 setState(c);</span>
<span class="line-added">271                 return true;</span>
<span class="line-added">272             }</span>
<span class="line-added">273             return false;</span>
<span class="line-added">274         }</span>
<span class="line-added">275 </span>
<span class="line-added">276         /**</span>
<span class="line-added">277          * Acquires only if thread is first waiter or empty</span>
<span class="line-added">278          */</span>
<span class="line-added">279         protected final boolean tryAcquire(int acquires) {</span>
<span class="line-added">280             if (getState() == 0 &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span>
<span class="line-added">281                 compareAndSetState(0, acquires)) {</span>
<span class="line-added">282                 setExclusiveOwnerThread(Thread.currentThread());</span>
283                 return true;
284             }
285             return false;
286         }
287     }
288 
289     /**
290      * Creates an instance of {@code ReentrantLock}.
291      * This is equivalent to using {@code ReentrantLock(false)}.
292      */
293     public ReentrantLock() {
294         sync = new NonfairSync();
295     }
296 
297     /**
298      * Creates an instance of {@code ReentrantLock} with the
299      * given fairness policy.
300      *
301      * @param fair {@code true} if this lock should use a fair ordering policy
302      */
303     public ReentrantLock(boolean fair) {
304         sync = fair ? new FairSync() : new NonfairSync();
305     }
306 
307     /**
308      * Acquires the lock.
309      *
310      * &lt;p&gt;Acquires the lock if it is not held by another thread and returns
311      * immediately, setting the lock hold count to one.
312      *
313      * &lt;p&gt;If the current thread already holds the lock then the hold
314      * count is incremented by one and the method returns immediately.
315      *
316      * &lt;p&gt;If the lock is held by another thread then the
317      * current thread becomes disabled for thread scheduling
318      * purposes and lies dormant until the lock has been acquired,
319      * at which time the lock hold count is set to one.
320      */
321     public void lock() {
<span class="line-modified">322         sync.lock();</span>
323     }
324 
325     /**
326      * Acquires the lock unless the current thread is
327      * {@linkplain Thread#interrupt interrupted}.
328      *
329      * &lt;p&gt;Acquires the lock if it is not held by another thread and returns
330      * immediately, setting the lock hold count to one.
331      *
332      * &lt;p&gt;If the current thread already holds this lock then the hold count
333      * is incremented by one and the method returns immediately.
334      *
335      * &lt;p&gt;If the lock is held by another thread then the
336      * current thread becomes disabled for thread scheduling
337      * purposes and lies dormant until one of two things happens:
338      *
339      * &lt;ul&gt;
340      *
341      * &lt;li&gt;The lock is acquired by the current thread; or
342      *
</pre>
<hr />
<pre>
352      *
353      * &lt;ul&gt;
354      *
355      * &lt;li&gt;has its interrupted status set on entry to this method; or
356      *
357      * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring
358      * the lock,
359      *
360      * &lt;/ul&gt;
361      *
362      * then {@link InterruptedException} is thrown and the current thread&#39;s
363      * interrupted status is cleared.
364      *
365      * &lt;p&gt;In this implementation, as this method is an explicit
366      * interruption point, preference is given to responding to the
367      * interrupt over normal or reentrant acquisition of the lock.
368      *
369      * @throws InterruptedException if the current thread is interrupted
370      */
371     public void lockInterruptibly() throws InterruptedException {
<span class="line-modified">372         sync.lockInterruptibly();</span>
373     }
374 
375     /**
376      * Acquires the lock only if it is not held by another thread at the time
377      * of invocation.
378      *
379      * &lt;p&gt;Acquires the lock if it is not held by another thread and
380      * returns immediately with the value {@code true}, setting the
381      * lock hold count to one. Even when this lock has been set to use a
382      * fair ordering policy, a call to {@code tryLock()} &lt;em&gt;will&lt;/em&gt;
383      * immediately acquire the lock if it is available, whether or not
384      * other threads are currently waiting for the lock.
385      * This &amp;quot;barging&amp;quot; behavior can be useful in certain
386      * circumstances, even though it breaks fairness. If you want to honor
387      * the fairness setting for this lock, then use
388      * {@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS)}
389      * which is almost equivalent (it also detects interruption).
390      *
391      * &lt;p&gt;If the current thread already holds this lock then the hold
392      * count is incremented by one and the method returns {@code true}.
393      *
394      * &lt;p&gt;If the lock is held by another thread then this method will return
395      * immediately with the value {@code false}.
396      *
397      * @return {@code true} if the lock was free and was acquired by the
398      *         current thread, or the lock was already held by the current
399      *         thread; and {@code false} otherwise
400      */
401     public boolean tryLock() {
<span class="line-modified">402         return sync.tryLock();</span>
403     }
404 
405     /**
406      * Acquires the lock if it is not held by another thread within the given
407      * waiting time and the current thread has not been
408      * {@linkplain Thread#interrupt interrupted}.
409      *
410      * &lt;p&gt;Acquires the lock if it is not held by another thread and returns
411      * immediately with the value {@code true}, setting the lock hold count
412      * to one. If this lock has been set to use a fair ordering policy then
413      * an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads
414      * are waiting for the lock. This is in contrast to the {@link #tryLock()}
415      * method. If you want a timed {@code tryLock} that does permit barging on
416      * a fair lock then combine the timed and un-timed forms together:
417      *
418      * &lt;pre&gt; {@code
419      * if (lock.tryLock() ||
420      *     lock.tryLock(timeout, unit)) {
421      *   ...
422      * }}&lt;/pre&gt;
</pre>
<hr />
<pre>
459      * &lt;p&gt;If the specified waiting time elapses then the value {@code false}
460      * is returned.  If the time is less than or equal to zero, the method
461      * will not wait at all.
462      *
463      * &lt;p&gt;In this implementation, as this method is an explicit
464      * interruption point, preference is given to responding to the
465      * interrupt over normal or reentrant acquisition of the lock, and
466      * over reporting the elapse of the waiting time.
467      *
468      * @param timeout the time to wait for the lock
469      * @param unit the time unit of the timeout argument
470      * @return {@code true} if the lock was free and was acquired by the
471      *         current thread, or the lock was already held by the current
472      *         thread; and {@code false} if the waiting time elapsed before
473      *         the lock could be acquired
474      * @throws InterruptedException if the current thread is interrupted
475      * @throws NullPointerException if the time unit is null
476      */
477     public boolean tryLock(long timeout, TimeUnit unit)
478             throws InterruptedException {
<span class="line-modified">479         return sync.tryLockNanos(unit.toNanos(timeout));</span>
480     }
481 
482     /**
483      * Attempts to release this lock.
484      *
485      * &lt;p&gt;If the current thread is the holder of this lock then the hold
486      * count is decremented.  If the hold count is now zero then the lock
487      * is released.  If the current thread is not the holder of this
488      * lock then {@link IllegalMonitorStateException} is thrown.
489      *
490      * @throws IllegalMonitorStateException if the current thread does not
491      *         hold this lock
492      */
493     public void unlock() {
494         sync.release(1);
495     }
496 
497     /**
498      * Returns a {@link Condition} instance for use with this
499      * {@link Lock} instance.
</pre>
</td>
</tr>
</table>
<center><a href="LockSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantReadWriteLock.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
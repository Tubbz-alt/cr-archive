diff a/src/java.base/share/classes/java/net/URI.java b/src/java.base/share/classes/java/net/URI.java
--- a/src/java.base/share/classes/java/net/URI.java
+++ b/src/java.base/share/classes/java/net/URI.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -40,15 +40,15 @@
 import java.nio.file.Path;
 import java.text.Normalizer;
 import jdk.internal.access.JavaNetUriAccess;
 import jdk.internal.access.SharedSecrets;
 import sun.nio.cs.ThreadLocalCoders;
+import sun.nio.cs.UTF_8;
 
 import java.lang.Character;             // for javadoc
 import java.lang.NullPointerException;  // for javadoc
 
-
 /**
  * Represents a Uniform Resource Identifier (URI) reference.
  *
  * <p> Aside from some minor deviations noted below, an instance of this
  * class represents a URI reference as defined by
@@ -62,11 +62,11 @@
  * their components or by parsing their string forms, methods for accessing the
  * various components of an instance, and methods for normalizing, resolving,
  * and relativizing URI instances.  Instances of this class are immutable.
  *
  *
- * <h3> URI syntax and components </h3>
+ * <h2> URI syntax and components </h2>
  *
  * At the highest level a URI reference (hereinafter simply "URI") in string
  * form has the syntax
  *
  * <blockquote>
@@ -166,11 +166,11 @@
  * least contains the path), and may have any of the other components.  If the
  * authority component is present and is server-based then the host component
  * will be defined and the user-information and port components may be defined.
  *
  *
- * <h4> Operations on URI instances </h4>
+ * <h3> Operations on URI instances </h3>
  *
  * The key operations supported by this class are those of
  * <i>normalization</i>, <i>resolution</i>, and <i>relativization</i>.
  *
  * <p> <i>Normalization</i> is the process of removing unnecessary {@code "."}
@@ -245,11 +245,11 @@
  * </blockquote>
  *
  * yields the relative URI {@code sample/a/index.html#28}.
  *
  *
- * <h4> Character categories </h4>
+ * <h3> Character categories </h3>
  *
  * RFC&nbsp;2396 specifies precisely which characters are permitted in the
  * various components of a URI reference.  The following categories, most of
  * which are taken from that specification, are used below to describe these
  * constraints:
@@ -296,11 +296,11 @@
  * <p><a id="legal-chars"></a> The set of all legal URI characters consists of
  * the <i>unreserved</i>, <i>reserved</i>, <i>escaped</i>, and <i>other</i>
  * characters.
  *
  *
- * <h4> Escaped octets, quotation, encoding, and decoding </h4>
+ * <h3> Escaped octets, quotation, encoding, and decoding </h3>
  *
  * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
  * fragment components.  Escaping serves two purposes in URIs:
  *
  * <ul>
@@ -388,11 +388,11 @@
  *   characters.  </p></li>
  *
  * </ul>
  *
  *
- * <h4> Identities </h4>
+ * <h3> Identities </h3>
  *
  * For any URI <i>u</i>, it is always the case that
  *
  * <blockquote>
  * {@code new URI(}<i>u</i>{@code .toString()).equals(}<i>u</i>{@code )}&nbsp;.
@@ -424,11 +424,11 @@
  *     .equals(<i>u</i>)</pre>
  * if <i>u</i> is hierarchical and has either no authority or a server-based
  * authority.
  *
  *
- * <h4> URIs, URLs, and URNs </h4>
+ * <h3> URIs, URLs, and URNs </h3>
  *
  * A URI is a uniform resource <i>identifier</i> while a URL is a uniform
  * resource <i>locator</i>.  Hence every URL is a URI, abstractly speaking, but
  * not every URI is a URL.  This is because there is another subcategory of
  * URIs, uniform resource <i>names</i> (URNs), which name resources but do not
@@ -501,11 +501,11 @@
 {
 
     // Note: Comments containing the word "ASSERT" indicate places where a
     // throw of an InternalError should be replaced by an appropriate assertion
     // statement once asserts are enabled in the build.
-
+    @java.io.Serial
     static final long serialVersionUID = -6052424284110960213L;
 
 
     // -- Properties and components of this instance --
 
@@ -1570,14 +1570,15 @@
      *
      * <p> When comparing corresponding components of two URIs, if one
      * component is undefined but the other is defined then the first is
      * considered to be less than the second.  Unless otherwise noted, string
      * components are ordered according to their natural, case-sensitive
-     * ordering as defined by the {@link java.lang.String#compareTo(Object)
+     * ordering as defined by the {@link java.lang.String#compareTo(String)
      * String.compareTo} method.  String components that are subject to
      * encoding are compared by comparing their raw forms rather than their
-     * encoded forms.
+     * encoded forms and the hexadecimal digits of escaped octets are compared
+     * without regard to case.
      *
      * <p> The ordering of URIs is defined as follows: </p>
      *
      * <ul>
      *
@@ -1775,10 +1776,11 @@
      * method of the given object-output stream is invoked. </p>
      *
      * @param  os  The object-output stream to which this object
      *             is to be written
      */
+    @java.io.Serial
     private void writeObject(ObjectOutputStream os)
         throws IOException
     {
         defineString();
         os.defaultWriteObject();        // Writes the string field only
@@ -1792,10 +1794,11 @@
      * then parsed in the usual way.
      *
      * @param  is  The object-input stream from which this object
      *             is being read
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream is)
         throws ClassNotFoundException, IOException
     {
         port = -1;                      // Argh
         is.defaultReadObject();
@@ -1834,39 +1837,13 @@
             return c - ('a' - 'A');
         return c;
     }
 
     private static boolean equal(String s, String t) {
-        if (s == t) return true;
-        if ((s != null) && (t != null)) {
-            if (s.length() != t.length())
-                return false;
-            if (s.indexOf('%') < 0)
-                return s.equals(t);
-            int n = s.length();
-            for (int i = 0; i < n;) {
-                char c = s.charAt(i);
-                char d = t.charAt(i);
-                if (c != '%') {
-                    if (c != d)
-                        return false;
-                    i++;
-                    continue;
-                }
-                if (d != '%')
-                    return false;
-                i++;
-                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))
-                    return false;
-                i++;
-                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))
-                    return false;
-                i++;
-            }
-            return true;
-        }
-        return false;
+        boolean testForEquality = true;
+        int result = percentNormalizedComparison(s, t, testForEquality);
+        return result == 0;
     }
 
     // US-ASCII only
     private static boolean equalIgnoringCase(String s, String t) {
         if (s == t) return true;
@@ -1916,15 +1893,65 @@
             h = 31 * h + toLower(s.charAt(i));
         return h;
     }
 
     private static int compare(String s, String t) {
+        boolean testForEquality = false;
+        int result = percentNormalizedComparison(s, t, testForEquality);
+        return result;
+    }
+
+    // The percentNormalizedComparison method does not verify two
+    // characters that follow the % sign are hexadecimal digits.
+    // Reason being:
+    // 1) percentNormalizedComparison method is not called with
+    // 'decoded' strings
+    // 2) The only place where a percent can be followed by anything
+    // other than hexadecimal digits is in the authority component
+    // (for a IPv6 scope) and the whole authority component is case
+    // insensitive.
+    private static int percentNormalizedComparison(String s, String t,
+                                                   boolean testForEquality) {
+
         if (s == t) return 0;
         if (s != null) {
-            if (t != null)
-                return s.compareTo(t);
-            else
+            if (t != null) {
+                if (s.indexOf('%') < 0) {
+                    return s.compareTo(t);
+                }
+                int sn = s.length();
+                int tn = t.length();
+                if ((sn != tn) && testForEquality)
+                    return sn - tn;
+                int val = 0;
+                int n = sn < tn ? sn : tn;
+                for (int i = 0; i < n; ) {
+                    char c = s.charAt(i);
+                    char d = t.charAt(i);
+                    val = c - d;
+                    if (c != '%') {
+                        if (val != 0)
+                            return val;
+                        i++;
+                        continue;
+                    }
+                    if (d != '%') {
+                        if (val != 0)
+                            return val;
+                    }
+                    i++;
+                    val = toLower(s.charAt(i)) - toLower(t.charAt(i));
+                    if (val != 0)
+                        return val;
+                    i++;
+                    val = toLower(s.charAt(i)) - toLower(t.charAt(i));
+                    if (val != 0)
+                        return val;
+                    i++;
+                }
+                return sn - tn;
+            } else
                 return +1;
         } else {
             return -1;
         }
     }
@@ -2735,11 +2762,11 @@
     }
 
     private static void appendEncoded(StringBuilder sb, char c) {
         ByteBuffer bb = null;
         try {
-            bb = ThreadLocalCoders.encoderFor("UTF-8")
+            bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)
                 .encode(CharBuffer.wrap("" + c));
         } catch (CharacterCodingException x) {
             assert false;
         }
         while (bb.hasRemaining()) {
@@ -2803,11 +2830,11 @@
         }
 
         String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
         ByteBuffer bb = null;
         try {
-            bb = ThreadLocalCoders.encoderFor("UTF-8")
+            bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)
                 .encode(CharBuffer.wrap(ns));
         } catch (CharacterCodingException x) {
             assert false;
         }
 
@@ -2861,11 +2888,11 @@
             return s;
 
         StringBuilder sb = new StringBuilder(n);
         ByteBuffer bb = ByteBuffer.allocate(n);
         CharBuffer cb = CharBuffer.allocate(n);
-        CharsetDecoder dec = ThreadLocalCoders.decoderFor("UTF-8")
+        CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)
                 .onMalformedInput(CodingErrorAction.REPLACE)
                 .onUnmappableCharacter(CodingErrorAction.REPLACE);
 
         // This is not horribly efficient, but it will do for now
         char c = s.charAt(0);

diff a/src/java.base/share/classes/java/net/URL.java b/src/java.base/share/classes/java/net/URL.java
--- a/src/java.base/share/classes/java/net/URL.java
+++ b/src/java.base/share/classes/java/net/URL.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -43,10 +43,12 @@
 import java.util.ServiceConfigurationError;
 import java.util.ServiceLoader;
 
 import jdk.internal.access.JavaNetURLAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.misc.VM;
+import sun.net.util.IPAddressUtil;
 import sun.security.util.SecurityConstants;
 import sun.security.action.GetPropertyAction;
 
 /**
  * Class {@code URL} represents a Uniform Resource
@@ -172,10 +174,11 @@
  * @since 1.0
  */
 public final class URL implements java.io.Serializable {
 
     static final String BUILTIN_HANDLERS_PREFIX = "sun.net.www.protocol";
+    @java.io.Serial
     static final long serialVersionUID = -7627629688361524110L;
 
     /**
      * The property which specifies the package prefix list to be scanned
      * for protocol handlers.  The value of this property (if any) should
@@ -325,14 +328,17 @@
      *     subclass of {@code URLStreamHandler}, then a
      *     {@code MalformedURLException} is thrown.
      * </ol>
      *
      * <p>Protocol handlers for the following protocols are guaranteed
-     * to exist on the search path :-
-     * <blockquote><pre>
-     *     http, https, file, and jar
-     * </pre></blockquote>
+     * to exist on the search path:
+     * <ul>
+     * <li>{@code http}</li>
+     * <li>{@code https}</li>
+     * <li>{@code file}</li>
+     * <li>{@code jar}</li>
+     * </ul>
      * Protocol handlers for additional protocols may also be  available.
      * Some protocol handlers, for example those used for loading platform
      * classes or classes on the class path, may not be overridden. The details
      * of such restrictions, and when those restrictions apply (during
      * initialization of the runtime for example), are implementation specific
@@ -342,11 +348,11 @@
      *
      * @param      protocol   the name of the protocol to use.
      * @param      host       the name of the host.
      * @param      port       the port number on the host.
      * @param      file       the file on the host
-     * @exception  MalformedURLException  if an unknown protocol or the port
+     * @throws     MalformedURLException  if an unknown protocol or the port
      *                  is a negative number other than -1
      * @see        java.lang.System#getProperty(java.lang.String)
      * @see        java.net.URL#setURLStreamHandlerFactory(
      *                  java.net.URLStreamHandlerFactory)
      * @see        java.net.URLStreamHandler
@@ -371,11 +377,11 @@
      * No validation of the inputs is performed by this constructor.
      *
      * @param      protocol   the name of the protocol to use.
      * @param      host       the name of the host.
      * @param      file       the file on the host.
-     * @exception  MalformedURLException  if an unknown protocol is specified.
+     * @throws     MalformedURLException  if an unknown protocol is specified.
      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
      *                  int, java.lang.String)
      */
     public URL(String protocol, String host, String file)
             throws MalformedURLException {
@@ -405,13 +411,13 @@
      * @param      protocol   the name of the protocol to use.
      * @param      host       the name of the host.
      * @param      port       the port number on the host.
      * @param      file       the file on the host
      * @param      handler    the stream handler for the URL.
-     * @exception  MalformedURLException  if an unknown protocol or the port
+     * @throws     MalformedURLException  if an unknown protocol or the port
                         is a negative number other than -1
-     * @exception  SecurityException
+     * @throws     SecurityException
      *        if a security manager exists and its
      *        {@code checkPermission} method doesn't allow
      *        specifying a stream handler explicitly.
      * @see        java.lang.System#getProperty(java.lang.String)
      * @see        java.net.URL#setURLStreamHandlerFactory(
@@ -464,28 +470,44 @@
         } else {
             this.path = file;
             this.file = path;
         }
 
-        // Note: we don't do validation of the URL here. Too risky to change
+        // Note: we don't do full validation of the URL here. Too risky to change
         // right now, but worth considering for future reference. -br
         if (handler == null &&
             (handler = getURLStreamHandler(protocol)) == null) {
             throw new MalformedURLException("unknown protocol: " + protocol);
         }
         this.handler = handler;
+        if (host != null && isBuiltinStreamHandler(handler)) {
+            String s = IPAddressUtil.checkExternalForm(this);
+            if (s != null) {
+                throw new MalformedURLException(s);
+            }
+        }
+        if ("jar".equalsIgnoreCase(protocol)) {
+            if (handler instanceof sun.net.www.protocol.jar.Handler) {
+                // URL.openConnection() would throw a confusing exception
+                // so generate a better exception here instead.
+                String s = ((sun.net.www.protocol.jar.Handler) handler).checkNestedProtocol(file);
+                if (s != null) {
+                    throw new MalformedURLException(s);
+                }
+            }
+        }
     }
 
     /**
      * Creates a {@code URL} object from the {@code String}
      * representation.
      * <p>
      * This constructor is equivalent to a call to the two-argument
      * constructor with a {@code null} first argument.
      *
      * @param      spec   the {@code String} to parse as a URL.
-     * @exception  MalformedURLException  if no protocol is specified, or an
+     * @throws     MalformedURLException  if no protocol is specified, or an
      *               unknown protocol is found, or {@code spec} is {@code null},
      *               or the parsed URL fails to comply with the specific syntax
      *               of the associated protocol.
      * @see        java.net.URL#URL(java.net.URL, java.lang.String)
      */
@@ -530,11 +552,11 @@
      * <p>
      * For a more detailed description of URL parsing, refer to RFC2396.
      *
      * @param      context   the context in which to parse the specification.
      * @param      spec      the {@code String} to parse as a URL.
-     * @exception  MalformedURLException  if no protocol is specified, or an
+     * @throws     MalformedURLException  if no protocol is specified, or an
      *               unknown protocol is found, or {@code spec} is {@code null},
      *               or the parsed URL fails to comply with the specific syntax
      *               of the associated protocol.
      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
      *                  int, java.lang.String)
@@ -552,15 +574,15 @@
      * occurs as with the two argument constructor.
      *
      * @param      context   the context in which to parse the specification.
      * @param      spec      the {@code String} to parse as a URL.
      * @param      handler   the stream handler for the URL.
-     * @exception  MalformedURLException  if no protocol is specified, or an
+     * @throws     MalformedURLException  if no protocol is specified, or an
      *               unknown protocol is found, or {@code spec} is {@code null},
      *               or the parsed URL fails to comply with the specific syntax
      *               of the associated protocol.
-     * @exception  SecurityException
+     * @throws     SecurityException
      *        if a security manager exists and its
      *        {@code checkPermission} method doesn't allow
      *        specifying a stream handler.
      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
      *                  int, java.lang.String)
@@ -1029,18 +1051,23 @@
      * This method functions in the same way as {@code new URI (this.toString())}.
      * <p>Note, any URL instance that complies with RFC 2396 can be converted
      * to a URI. However, some URLs that are not strictly in compliance
      * can not be converted to a URI.
      *
-     * @exception URISyntaxException if this URL is not formatted strictly according to
+     * @throws    URISyntaxException if this URL is not formatted strictly according to
      *            RFC2396 and cannot be converted to a URI.
      *
      * @return    a URI instance equivalent to this URL.
      * @since 1.5
      */
     public URI toURI() throws URISyntaxException {
-        return new URI (toString());
+        URI uri = new URI(toString());
+        if (authority != null && isBuiltinStreamHandler(handler)) {
+            String s = IPAddressUtil.checkAuthority(this);
+            if (s != null) throw new URISyntaxException(authority, s);
+        }
+        return uri;
     }
 
     /**
      * Returns a {@link java.net.URLConnection URLConnection} instance that
      * represents a connection to the remote object referred to by the
@@ -1064,11 +1091,11 @@
      * HttpURLConnection will be returned, and for JAR a
      * JarURLConnection will be returned.</P>
      *
      * @return     a {@link java.net.URLConnection URLConnection} linking
      *             to the URL.
-     * @exception  IOException  if an I/O exception occurs.
+     * @throws     IOException  if an I/O exception occurs.
      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
      *             int, java.lang.String)
      */
     public URLConnection openConnection() throws java.io.IOException {
         return handler.openConnection(this);
@@ -1085,17 +1112,17 @@
      *
      * @param      proxy the Proxy through which this connection
      *             will be made. If direct connection is desired,
      *             Proxy.NO_PROXY should be specified.
      * @return     a {@code URLConnection} to the URL.
-     * @exception  IOException  if an I/O exception occurs.
-     * @exception  SecurityException if a security manager is present
+     * @throws     IOException  if an I/O exception occurs.
+     * @throws     SecurityException if a security manager is present
      *             and the caller doesn't have permission to connect
      *             to the proxy.
-     * @exception  IllegalArgumentException will be thrown if proxy is null,
+     * @throws     IllegalArgumentException will be thrown if proxy is null,
      *             or proxy has the wrong type
-     * @exception  UnsupportedOperationException if the subclass that
+     * @throws     UnsupportedOperationException if the subclass that
      *             implements the protocol handler doesn't support
      *             this method.
      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
      *             int, java.lang.String)
      * @see        java.net.URLConnection
@@ -1130,11 +1157,11 @@
      * <blockquote><pre>
      *     openConnection().getInputStream()
      * </pre></blockquote>
      *
      * @return     an input stream for reading from the URL connection.
-     * @exception  IOException  if an I/O exception occurs.
+     * @throws     IOException  if an I/O exception occurs.
      * @see        java.net.URL#openConnection()
      * @see        java.net.URLConnection#getInputStream()
      */
     public final InputStream openStream() throws java.io.IOException {
         return openConnection().getInputStream();
@@ -1145,11 +1172,11 @@
      * <blockquote><pre>
      *     openConnection().getContent()
      * </pre></blockquote>
      *
      * @return     the contents of this URL.
-     * @exception  IOException  if an I/O exception occurs.
+     * @throws     IOException  if an I/O exception occurs.
      * @see        java.net.URLConnection#getContent()
      */
     public final Object getContent() throws java.io.IOException {
         return openConnection().getContent();
     }
@@ -1162,11 +1189,11 @@
      *
      * @param classes an array of Java types
      * @return     the content object of this URL that is the first match of
      *               the types specified in the classes array.
      *               null if none of the requested types are supported.
-     * @exception  IOException  if an I/O exception occurs.
+     * @throws     IOException  if an I/O exception occurs.
      * @see        java.net.URLConnection#getContent(Class[])
      * @since 1.3
      */
     public final Object getContent(Class<?>[] classes)
     throws java.io.IOException {
@@ -1190,12 +1217,12 @@
      * the security manager's {@code checkSetFactory} method
      * to ensure the operation is allowed.
      * This could result in a SecurityException.
      *
      * @param      fac   the desired factory.
-     * @exception  Error  if the application has already set a factory.
-     * @exception  SecurityException  if a security manager exists and its
+     * @throws     Error  if the application has already set a factory.
+     * @throws     SecurityException  if a security manager exists and its
      *             {@code checkSetFactory} method doesn't allow
      *             the operation.
      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
      *             int, java.lang.String)
      * @see        java.net.URLStreamHandlerFactory
@@ -1401,12 +1428,13 @@
             return handler;
         }
 
         URLStreamHandlerFactory fac;
         boolean checkedWithFactory = false;
+        boolean overrideableProtocol = isOverrideable(protocol);
 
-        if (isOverrideable(protocol) && jdk.internal.misc.VM.isBooted()) {
+        if (overrideableProtocol && VM.isBooted()) {
             // Use the factory (if any). Volatile read makes
             // URLStreamHandlerFactory appear fully initialized to current thread.
             fac = factory;
             if (fac != null) {
                 handler = fac.createURLStreamHandler(protocol);
@@ -1438,11 +1466,12 @@
                 return handler2;
             }
 
             // Check with factory if another thread set a
             // factory since our last check
-            if (!checkedWithFactory && (fac = factory) != null) {
+            if (overrideableProtocol && !checkedWithFactory &&
+                (fac = factory) != null) {
                 handler2 = fac.createURLStreamHandler(protocol);
             }
 
             if (handler2 != null) {
                 // The handler from the factory must be given more
@@ -1473,10 +1502,11 @@
      * @serialField    ref String
      *
      * @serialField    hashCode int
      *
      */
+    @java.io.Serial
     private static final ObjectStreamField[] serialPersistentFields = {
         new ObjectStreamField("protocol", String.class),
         new ObjectStreamField("host", String.class),
         new ObjectStreamField("port", int.class),
         new ObjectStreamField("authority", String.class),
@@ -1492,10 +1522,11 @@
      * @serialData the default write object value. When read back in,
      * the reader must ensure that calling getURLStreamHandler with
      * the protocol variable returns a valid URLStreamHandler and
      * throw an IOException if it does not.
      */
+    @java.io.Serial
     private synchronized void writeObject(java.io.ObjectOutputStream s)
         throws IOException
     {
         s.defaultWriteObject(); // write the fields
     }
@@ -1503,10 +1534,11 @@
     /**
      * readObject is called to restore the state of the URL from the
      * stream.  It reads the components of the URL and finds the local
      * stream handler.
      */
+    @java.io.Serial
     private synchronized void readObject(java.io.ObjectInputStream s)
             throws IOException, ClassNotFoundException {
         GetField gf = s.readFields();
         String protocol = (String)gf.get("protocol", null);
         if (getURLStreamHandler(protocol) == null) {
@@ -1534,11 +1566,11 @@
      * @return a newly created object from deserialized data
      *
      * @throws ObjectStreamException if a new object replacing this
      * object could not be created
      */
-
+   @java.io.Serial
    private Object readResolve() throws ObjectStreamException {
 
         URLStreamHandler handler = null;
         // already been checked in readObject
         handler = getURLStreamHandler(tempState.getProtocol());
@@ -1631,10 +1663,16 @@
         replacementURL.setSerializedHashCode(tempState.getHashCode());
         resetState();
         return replacementURL;
     }
 
+    boolean isBuiltinStreamHandler(URLStreamHandler handler) {
+       Class<?> handlerClass = handler.getClass();
+       return isBuiltinStreamHandler(handlerClass.getName())
+                 || VM.isSystemDomainLoader(handlerClass.getClassLoader());
+    }
+
     private boolean isBuiltinStreamHandler(String handlerClassName) {
         return (handlerClassName.startsWith(BUILTIN_HANDLERS_PREFIX));
     }
 
     private void resetState() {

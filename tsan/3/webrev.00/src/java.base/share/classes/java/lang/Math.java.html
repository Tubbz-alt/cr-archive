<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/Math.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.math.BigDecimal;
  29 import java.util.Random;
  30 import jdk.internal.math.FloatConsts;
  31 import jdk.internal.math.DoubleConsts;
  32 import jdk.internal.HotSpotIntrinsicCandidate;
  33 
  34 /**
  35  * The class {@code Math} contains methods for performing basic
  36  * numeric operations such as the elementary exponential, logarithm,
  37  * square root, and trigonometric functions.
  38  *
  39  * &lt;p&gt;Unlike some of the numeric methods of class
  40  * {@code StrictMath}, all implementations of the equivalent
  41  * functions of class {@code Math} are not defined to return the
  42  * bit-for-bit same results.  This relaxation permits
  43  * better-performing implementations where strict reproducibility is
  44  * not required.
  45  *
  46  * &lt;p&gt;By default many of the {@code Math} methods simply call
  47  * the equivalent method in {@code StrictMath} for their
  48  * implementation.  Code generators are encouraged to use
  49  * platform-specific native libraries or microprocessor instructions,
  50  * where available, to provide higher-performance implementations of
  51  * {@code Math} methods.  Such higher-performance
  52  * implementations still must conform to the specification for
  53  * {@code Math}.
  54  *
  55  * &lt;p&gt;The quality of implementation specifications concern two
  56  * properties, accuracy of the returned result and monotonicity of the
  57  * method.  Accuracy of the floating-point {@code Math} methods is
  58  * measured in terms of &lt;i&gt;ulps&lt;/i&gt;, units in the last place.  For a
  59  * given floating-point format, an {@linkplain #ulp(double) ulp} of a
  60  * specific real number value is the distance between the two
  61  * floating-point values bracketing that numerical value.  When
  62  * discussing the accuracy of a method as a whole rather than at a
  63  * specific argument, the number of ulps cited is for the worst-case
  64  * error at any argument.  If a method always has an error less than
  65  * 0.5 ulps, the method always returns the floating-point number
  66  * nearest the exact result; such a method is &lt;i&gt;correctly
  67  * rounded&lt;/i&gt;.  A correctly rounded method is generally the best a
  68  * floating-point approximation can be; however, it is impractical for
  69  * many floating-point methods to be correctly rounded.  Instead, for
  70  * the {@code Math} class, a larger error bound of 1 or 2 ulps is
  71  * allowed for certain methods.  Informally, with a 1 ulp error bound,
  72  * when the exact result is a representable number, the exact result
  73  * should be returned as the computed result; otherwise, either of the
  74  * two floating-point values which bracket the exact result may be
  75  * returned.  For exact results large in magnitude, one of the
  76  * endpoints of the bracket may be infinite.  Besides accuracy at
  77  * individual arguments, maintaining proper relations between the
  78  * method at different arguments is also important.  Therefore, most
  79  * methods with more than 0.5 ulp errors are required to be
  80  * &lt;i&gt;semi-monotonic&lt;/i&gt;: whenever the mathematical function is
  81  * non-decreasing, so is the floating-point approximation, likewise,
  82  * whenever the mathematical function is non-increasing, so is the
  83  * floating-point approximation.  Not all approximations that have 1
  84  * ulp accuracy will automatically meet the monotonicity requirements.
  85  *
  86  * &lt;p&gt;
  87  * The platform uses signed two&#39;s complement integer arithmetic with
  88  * int and long primitive types.  The developer should choose
  89  * the primitive type to ensure that arithmetic operations consistently
  90  * produce correct results, which in some cases means the operations
  91  * will not overflow the range of values of the computation.
  92  * The best practice is to choose the primitive type and algorithm to avoid
  93  * overflow. In cases where the size is {@code int} or {@code long} and
  94  * overflow errors need to be detected, the methods {@code addExact},
  95  * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},
  96  * {@code incrementExact}, {@code decrementExact} and {@code negateExact}
  97  * throw an {@code ArithmeticException} when the results overflow.
  98  * For the arithmetic operations divide and absolute value, overflow
  99  * occurs only with a specific minimum or maximum value and
 100  * should be checked against the minimum or maximum as appropriate.
 101  *
 102  * @author  unascribed
 103  * @author  Joseph D. Darcy
 104  * @since   1.0
 105  */
 106 
 107 public final class Math {
 108 
 109     /**
 110      * Don&#39;t let anyone instantiate this class.
 111      */
 112     private Math() {}
 113 
 114     /**
 115      * The {@code double} value that is closer than any other to
 116      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
 117      */
 118     public static final double E = 2.7182818284590452354;
 119 
 120     /**
 121      * The {@code double} value that is closer than any other to
 122      * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its
 123      * diameter.
 124      */
 125     public static final double PI = 3.14159265358979323846;
 126 
 127     /**
 128      * Constant by which to multiply an angular value in degrees to obtain an
 129      * angular value in radians.
 130      */
 131     private static final double DEGREES_TO_RADIANS = 0.017453292519943295;
 132 
 133     /**
 134      * Constant by which to multiply an angular value in radians to obtain an
 135      * angular value in degrees.
 136      */
 137     private static final double RADIANS_TO_DEGREES = 57.29577951308232;
 138 
 139     /**
 140      * Returns the trigonometric sine of an angle.  Special cases:
 141      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 142      * result is NaN.
 143      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 144      * same sign as the argument.&lt;/ul&gt;
 145      *
 146      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 147      * Results must be semi-monotonic.
 148      *
 149      * @param   a   an angle, in radians.
 150      * @return  the sine of the argument.
 151      */
 152     @HotSpotIntrinsicCandidate
 153     public static double sin(double a) {
 154         return StrictMath.sin(a); // default impl. delegates to StrictMath
 155     }
 156 
 157     /**
 158      * Returns the trigonometric cosine of an angle. Special cases:
 159      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 160      * result is NaN.&lt;/ul&gt;
 161      *
 162      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 163      * Results must be semi-monotonic.
 164      *
 165      * @param   a   an angle, in radians.
 166      * @return  the cosine of the argument.
 167      */
 168     @HotSpotIntrinsicCandidate
 169     public static double cos(double a) {
 170         return StrictMath.cos(a); // default impl. delegates to StrictMath
 171     }
 172 
 173     /**
 174      * Returns the trigonometric tangent of an angle.  Special cases:
 175      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the result
 176      * is NaN.
 177      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 178      * same sign as the argument.&lt;/ul&gt;
 179      *
 180      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 181      * Results must be semi-monotonic.
 182      *
 183      * @param   a   an angle, in radians.
 184      * @return  the tangent of the argument.
 185      */
 186     @HotSpotIntrinsicCandidate
 187     public static double tan(double a) {
 188         return StrictMath.tan(a); // default impl. delegates to StrictMath
 189     }
 190 
 191     /**
 192      * Returns the arc sine of a value; the returned angle is in the
 193      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 194      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 195      * than 1, then the result is NaN.
 196      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 197      * same sign as the argument.&lt;/ul&gt;
 198      *
 199      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 200      * Results must be semi-monotonic.
 201      *
 202      * @param   a   the value whose arc sine is to be returned.
 203      * @return  the arc sine of the argument.
 204      */
 205     public static double asin(double a) {
 206         return StrictMath.asin(a); // default impl. delegates to StrictMath
 207     }
 208 
 209     /**
 210      * Returns the arc cosine of a value; the returned angle is in the
 211      * range 0.0 through &lt;i&gt;pi&lt;/i&gt;.  Special case:
 212      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 213      * than 1, then the result is NaN.&lt;/ul&gt;
 214      *
 215      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 216      * Results must be semi-monotonic.
 217      *
 218      * @param   a   the value whose arc cosine is to be returned.
 219      * @return  the arc cosine of the argument.
 220      */
 221     public static double acos(double a) {
 222         return StrictMath.acos(a); // default impl. delegates to StrictMath
 223     }
 224 
 225     /**
 226      * Returns the arc tangent of a value; the returned angle is in the
 227      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 228      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, then the result is NaN.
 229      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 230      * same sign as the argument.&lt;/ul&gt;
 231      *
 232      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 233      * Results must be semi-monotonic.
 234      *
 235      * @param   a   the value whose arc tangent is to be returned.
 236      * @return  the arc tangent of the argument.
 237      */
 238     public static double atan(double a) {
 239         return StrictMath.atan(a); // default impl. delegates to StrictMath
 240     }
 241 
 242     /**
 243      * Converts an angle measured in degrees to an approximately
 244      * equivalent angle measured in radians.  The conversion from
 245      * degrees to radians is generally inexact.
 246      *
 247      * @param   angdeg   an angle, in degrees
 248      * @return  the measurement of the angle {@code angdeg}
 249      *          in radians.
 250      * @since   1.2
 251      */
 252     public static double toRadians(double angdeg) {
 253         return angdeg * DEGREES_TO_RADIANS;
 254     }
 255 
 256     /**
 257      * Converts an angle measured in radians to an approximately
 258      * equivalent angle measured in degrees.  The conversion from
 259      * radians to degrees is generally inexact; users should
 260      * &lt;i&gt;not&lt;/i&gt; expect {@code cos(toRadians(90.0))} to exactly
 261      * equal {@code 0.0}.
 262      *
 263      * @param   angrad   an angle, in radians
 264      * @return  the measurement of the angle {@code angrad}
 265      *          in degrees.
 266      * @since   1.2
 267      */
 268     public static double toDegrees(double angrad) {
 269         return angrad * RADIANS_TO_DEGREES;
 270     }
 271 
 272     /**
 273      * Returns Euler&#39;s number &lt;i&gt;e&lt;/i&gt; raised to the power of a
 274      * {@code double} value.  Special cases:
 275      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is NaN.
 276      * &lt;li&gt;If the argument is positive infinity, then the result is
 277      * positive infinity.
 278      * &lt;li&gt;If the argument is negative infinity, then the result is
 279      * positive zero.&lt;/ul&gt;
 280      *
 281      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 282      * Results must be semi-monotonic.
 283      *
 284      * @param   a   the exponent to raise &lt;i&gt;e&lt;/i&gt; to.
 285      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code a}&lt;/sup&gt;,
 286      *          where &lt;i&gt;e&lt;/i&gt; is the base of the natural logarithms.
 287      */
 288     @HotSpotIntrinsicCandidate
 289     public static double exp(double a) {
 290         return StrictMath.exp(a); // default impl. delegates to StrictMath
 291     }
 292 
 293     /**
 294      * Returns the natural logarithm (base &lt;i&gt;e&lt;/i&gt;) of a {@code double}
 295      * value.  Special cases:
 296      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 297      * is NaN.
 298      * &lt;li&gt;If the argument is positive infinity, then the result is
 299      * positive infinity.
 300      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 301      * result is negative infinity.&lt;/ul&gt;
 302      *
 303      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 304      * Results must be semi-monotonic.
 305      *
 306      * @param   a   a value
 307      * @return  the value ln&amp;nbsp;{@code a}, the natural logarithm of
 308      *          {@code a}.
 309      */
 310     @HotSpotIntrinsicCandidate
 311     public static double log(double a) {
 312         return StrictMath.log(a); // default impl. delegates to StrictMath
 313     }
 314 
 315     /**
 316      * Returns the base 10 logarithm of a {@code double} value.
 317      * Special cases:
 318      *
 319      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 320      * is NaN.
 321      * &lt;li&gt;If the argument is positive infinity, then the result is
 322      * positive infinity.
 323      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 324      * result is negative infinity.
 325      * &lt;li&gt; If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for
 326      * integer &lt;i&gt;n&lt;/i&gt;, then the result is &lt;i&gt;n&lt;/i&gt;.
 327      * &lt;/ul&gt;
 328      *
 329      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 330      * Results must be semi-monotonic.
 331      *
 332      * @param   a   a value
 333      * @return  the base 10 logarithm of  {@code a}.
 334      * @since 1.5
 335      */
 336     @HotSpotIntrinsicCandidate
 337     public static double log10(double a) {
 338         return StrictMath.log10(a); // default impl. delegates to StrictMath
 339     }
 340 
 341     /**
 342      * Returns the correctly rounded positive square root of a
 343      * {@code double} value.
 344      * Special cases:
 345      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 346      * is NaN.
 347      * &lt;li&gt;If the argument is positive infinity, then the result is positive
 348      * infinity.
 349      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 350      * result is the same as the argument.&lt;/ul&gt;
 351      * Otherwise, the result is the {@code double} value closest to
 352      * the true mathematical square root of the argument value.
 353      *
 354      * @param   a   a value.
 355      * @return  the positive square root of {@code a}.
 356      *          If the argument is NaN or less than zero, the result is NaN.
 357      */
 358     @HotSpotIntrinsicCandidate
 359     public static double sqrt(double a) {
 360         return StrictMath.sqrt(a); // default impl. delegates to StrictMath
 361                                    // Note that hardware sqrt instructions
 362                                    // frequently can be directly used by JITs
 363                                    // and should be much faster than doing
 364                                    // Math.sqrt in software.
 365     }
 366 
 367 
 368     /**
 369      * Returns the cube root of a {@code double} value.  For
 370      * positive finite {@code x}, {@code cbrt(-x) ==
 371      * -cbrt(x)}; that is, the cube root of a negative value is
 372      * the negative of the cube root of that value&#39;s magnitude.
 373      *
 374      * Special cases:
 375      *
 376      * &lt;ul&gt;
 377      *
 378      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 379      *
 380      * &lt;li&gt;If the argument is infinite, then the result is an infinity
 381      * with the same sign as the argument.
 382      *
 383      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 384      * same sign as the argument.
 385      *
 386      * &lt;/ul&gt;
 387      *
 388      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 389      *
 390      * @param   a   a value.
 391      * @return  the cube root of {@code a}.
 392      * @since 1.5
 393      */
 394     public static double cbrt(double a) {
 395         return StrictMath.cbrt(a);
 396     }
 397 
 398     /**
 399      * Computes the remainder operation on two arguments as prescribed
 400      * by the IEEE 754 standard.
 401      * The remainder value is mathematically equal to
 402      * &lt;code&gt;f1&amp;nbsp;-&amp;nbsp;f2&lt;/code&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;,
 403      * where &lt;i&gt;n&lt;/i&gt; is the mathematical integer closest to the exact
 404      * mathematical value of the quotient {@code f1/f2}, and if two
 405      * mathematical integers are equally close to {@code f1/f2},
 406      * then &lt;i&gt;n&lt;/i&gt; is the integer that is even. If the remainder is
 407      * zero, its sign is the same as the sign of the first argument.
 408      * Special cases:
 409      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, or the first argument is infinite,
 410      * or the second argument is positive zero or negative zero, then the
 411      * result is NaN.
 412      * &lt;li&gt;If the first argument is finite and the second argument is
 413      * infinite, then the result is the same as the first argument.&lt;/ul&gt;
 414      *
 415      * @param   f1   the dividend.
 416      * @param   f2   the divisor.
 417      * @return  the remainder when {@code f1} is divided by
 418      *          {@code f2}.
 419      */
 420     public static double IEEEremainder(double f1, double f2) {
 421         return StrictMath.IEEEremainder(f1, f2); // delegate to StrictMath
 422     }
 423 
 424     /**
 425      * Returns the smallest (closest to negative infinity)
 426      * {@code double} value that is greater than or equal to the
 427      * argument and is equal to a mathematical integer. Special cases:
 428      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 429      * mathematical integer, then the result is the same as the
 430      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 431      * positive zero or negative zero, then the result is the same as
 432      * the argument.  &lt;li&gt;If the argument value is less than zero but
 433      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 434      * that the value of {@code Math.ceil(x)} is exactly the
 435      * value of {@code -Math.floor(-x)}.
 436      *
 437      *
 438      * @param   a   a value.
 439      * @return  the smallest (closest to negative infinity)
 440      *          floating-point value that is greater than or equal to
 441      *          the argument and is equal to a mathematical integer.
 442      */
 443     @HotSpotIntrinsicCandidate
 444     public static double ceil(double a) {
 445         return StrictMath.ceil(a); // default impl. delegates to StrictMath
 446     }
 447 
 448     /**
 449      * Returns the largest (closest to positive infinity)
 450      * {@code double} value that is less than or equal to the
 451      * argument and is equal to a mathematical integer. Special cases:
 452      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 453      * mathematical integer, then the result is the same as the
 454      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 455      * positive zero or negative zero, then the result is the same as
 456      * the argument.&lt;/ul&gt;
 457      *
 458      * @param   a   a value.
 459      * @return  the largest (closest to positive infinity)
 460      *          floating-point value that less than or equal to the argument
 461      *          and is equal to a mathematical integer.
 462      */
 463     @HotSpotIntrinsicCandidate
 464     public static double floor(double a) {
 465         return StrictMath.floor(a); // default impl. delegates to StrictMath
 466     }
 467 
 468     /**
 469      * Returns the {@code double} value that is closest in value
 470      * to the argument and is equal to a mathematical integer. If two
 471      * {@code double} values that are mathematical integers are
 472      * equally close, the result is the integer value that is
 473      * even. Special cases:
 474      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 475      * integer, then the result is the same as the argument.
 476      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 477      * zero, then the result is the same as the argument.&lt;/ul&gt;
 478      *
 479      * @param   a   a {@code double} value.
 480      * @return  the closest floating-point value to {@code a} that is
 481      *          equal to a mathematical integer.
 482      */
 483     @HotSpotIntrinsicCandidate
 484     public static double rint(double a) {
 485         return StrictMath.rint(a); // default impl. delegates to StrictMath
 486     }
 487 
 488     /**
 489      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 490      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 491      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 492      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 493      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 494      * cases:
 495      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 496      * &lt;li&gt;If the first argument is positive zero and the second argument
 497      * is positive, or the first argument is positive and finite and the
 498      * second argument is positive infinity, then the result is positive
 499      * zero.
 500      * &lt;li&gt;If the first argument is negative zero and the second argument
 501      * is positive, or the first argument is negative and finite and the
 502      * second argument is positive infinity, then the result is negative zero.
 503      * &lt;li&gt;If the first argument is positive zero and the second argument
 504      * is negative, or the first argument is positive and finite and the
 505      * second argument is negative infinity, then the result is the
 506      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;.
 507      * &lt;li&gt;If the first argument is negative zero and the second argument
 508      * is negative, or the first argument is negative and finite and the
 509      * second argument is negative infinity, then the result is the
 510      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;.
 511      * &lt;li&gt;If the first argument is positive and the second argument is
 512      * positive zero or negative zero, or the first argument is positive
 513      * infinity and the second argument is finite, then the result is the
 514      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/2.
 515      * &lt;li&gt;If the first argument is negative and the second argument is
 516      * positive zero or negative zero, or the first argument is negative
 517      * infinity and the second argument is finite, then the result is the
 518      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;/2.
 519      * &lt;li&gt;If both arguments are positive infinity, then the result is the
 520      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/4.
 521      * &lt;li&gt;If the first argument is positive infinity and the second argument
 522      * is negative infinity, then the result is the {@code double}
 523      * value closest to 3*&lt;i&gt;pi&lt;/i&gt;/4.
 524      * &lt;li&gt;If the first argument is negative infinity and the second argument
 525      * is positive infinity, then the result is the {@code double} value
 526      * closest to -&lt;i&gt;pi&lt;/i&gt;/4.
 527      * &lt;li&gt;If both arguments are negative infinity, then the result is the
 528      * {@code double} value closest to -3*&lt;i&gt;pi&lt;/i&gt;/4.&lt;/ul&gt;
 529      *
 530      * &lt;p&gt;The computed result must be within 2 ulps of the exact result.
 531      * Results must be semi-monotonic.
 532      *
 533      * @param   y   the ordinate coordinate
 534      * @param   x   the abscissa coordinate
 535      * @return  the &lt;i&gt;theta&lt;/i&gt; component of the point
 536      *          (&lt;i&gt;r&lt;/i&gt;,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;)
 537      *          in polar coordinates that corresponds to the point
 538      *          (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in Cartesian coordinates.
 539      */
 540     @HotSpotIntrinsicCandidate
 541     public static double atan2(double y, double x) {
 542         return StrictMath.atan2(y, x); // default impl. delegates to StrictMath
 543     }
 544 
 545     /**
 546      * Returns the value of the first argument raised to the power of the
 547      * second argument. Special cases:
 548      *
 549      * &lt;ul&gt;&lt;li&gt;If the second argument is positive or negative zero, then the
 550      * result is 1.0.
 551      * &lt;li&gt;If the second argument is 1.0, then the result is the same as the
 552      * first argument.
 553      * &lt;li&gt;If the second argument is NaN, then the result is NaN.
 554      * &lt;li&gt;If the first argument is NaN and the second argument is nonzero,
 555      * then the result is NaN.
 556      *
 557      * &lt;li&gt;If
 558      * &lt;ul&gt;
 559      * &lt;li&gt;the absolute value of the first argument is greater than 1
 560      * and the second argument is positive infinity, or
 561      * &lt;li&gt;the absolute value of the first argument is less than 1 and
 562      * the second argument is negative infinity,
 563      * &lt;/ul&gt;
 564      * then the result is positive infinity.
 565      *
 566      * &lt;li&gt;If
 567      * &lt;ul&gt;
 568      * &lt;li&gt;the absolute value of the first argument is greater than 1 and
 569      * the second argument is negative infinity, or
 570      * &lt;li&gt;the absolute value of the
 571      * first argument is less than 1 and the second argument is positive
 572      * infinity,
 573      * &lt;/ul&gt;
 574      * then the result is positive zero.
 575      *
 576      * &lt;li&gt;If the absolute value of the first argument equals 1 and the
 577      * second argument is infinite, then the result is NaN.
 578      *
 579      * &lt;li&gt;If
 580      * &lt;ul&gt;
 581      * &lt;li&gt;the first argument is positive zero and the second argument
 582      * is greater than zero, or
 583      * &lt;li&gt;the first argument is positive infinity and the second
 584      * argument is less than zero,
 585      * &lt;/ul&gt;
 586      * then the result is positive zero.
 587      *
 588      * &lt;li&gt;If
 589      * &lt;ul&gt;
 590      * &lt;li&gt;the first argument is positive zero and the second argument
 591      * is less than zero, or
 592      * &lt;li&gt;the first argument is positive infinity and the second
 593      * argument is greater than zero,
 594      * &lt;/ul&gt;
 595      * then the result is positive infinity.
 596      *
 597      * &lt;li&gt;If
 598      * &lt;ul&gt;
 599      * &lt;li&gt;the first argument is negative zero and the second argument
 600      * is greater than zero but not a finite odd integer, or
 601      * &lt;li&gt;the first argument is negative infinity and the second
 602      * argument is less than zero but not a finite odd integer,
 603      * &lt;/ul&gt;
 604      * then the result is positive zero.
 605      *
 606      * &lt;li&gt;If
 607      * &lt;ul&gt;
 608      * &lt;li&gt;the first argument is negative zero and the second argument
 609      * is a positive finite odd integer, or
 610      * &lt;li&gt;the first argument is negative infinity and the second
 611      * argument is a negative finite odd integer,
 612      * &lt;/ul&gt;
 613      * then the result is negative zero.
 614      *
 615      * &lt;li&gt;If
 616      * &lt;ul&gt;
 617      * &lt;li&gt;the first argument is negative zero and the second argument
 618      * is less than zero but not a finite odd integer, or
 619      * &lt;li&gt;the first argument is negative infinity and the second
 620      * argument is greater than zero but not a finite odd integer,
 621      * &lt;/ul&gt;
 622      * then the result is positive infinity.
 623      *
 624      * &lt;li&gt;If
 625      * &lt;ul&gt;
 626      * &lt;li&gt;the first argument is negative zero and the second argument
 627      * is a negative finite odd integer, or
 628      * &lt;li&gt;the first argument is negative infinity and the second
 629      * argument is a positive finite odd integer,
 630      * &lt;/ul&gt;
 631      * then the result is negative infinity.
 632      *
 633      * &lt;li&gt;If the first argument is finite and less than zero
 634      * &lt;ul&gt;
 635      * &lt;li&gt; if the second argument is a finite even integer, the
 636      * result is equal to the result of raising the absolute value of
 637      * the first argument to the power of the second argument
 638      *
 639      * &lt;li&gt;if the second argument is a finite odd integer, the result
 640      * is equal to the negative of the result of raising the absolute
 641      * value of the first argument to the power of the second
 642      * argument
 643      *
 644      * &lt;li&gt;if the second argument is finite and not an integer, then
 645      * the result is NaN.
 646      * &lt;/ul&gt;
 647      *
 648      * &lt;li&gt;If both arguments are integers, then the result is exactly equal
 649      * to the mathematical result of raising the first argument to the power
 650      * of the second argument if that result can in fact be represented
 651      * exactly as a {@code double} value.&lt;/ul&gt;
 652      *
 653      * &lt;p&gt;(In the foregoing descriptions, a floating-point value is
 654      * considered to be an integer if and only if it is finite and a
 655      * fixed point of the method {@link #ceil ceil} or,
 656      * equivalently, a fixed point of the method {@link #floor
 657      * floor}. A value is a fixed point of a one-argument
 658      * method if and only if the result of applying the method to the
 659      * value is equal to the value.)
 660      *
 661      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 662      * Results must be semi-monotonic.
 663      *
 664      * @param   a   the base.
 665      * @param   b   the exponent.
 666      * @return  the value {@code a}&lt;sup&gt;{@code b}&lt;/sup&gt;.
 667      */
 668     @HotSpotIntrinsicCandidate
 669     public static double pow(double a, double b) {
 670         return StrictMath.pow(a, b); // default impl. delegates to StrictMath
 671     }
 672 
 673     /**
 674      * Returns the closest {@code int} to the argument, with ties
 675      * rounding to positive infinity.
 676      *
 677      * &lt;p&gt;
 678      * Special cases:
 679      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 680      * &lt;li&gt;If the argument is negative infinity or any value less than or
 681      * equal to the value of {@code Integer.MIN_VALUE}, the result is
 682      * equal to the value of {@code Integer.MIN_VALUE}.
 683      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 684      * equal to the value of {@code Integer.MAX_VALUE}, the result is
 685      * equal to the value of {@code Integer.MAX_VALUE}.&lt;/ul&gt;
 686      *
 687      * @param   a   a floating-point value to be rounded to an integer.
 688      * @return  the value of the argument rounded to the nearest
 689      *          {@code int} value.
 690      * @see     java.lang.Integer#MAX_VALUE
 691      * @see     java.lang.Integer#MIN_VALUE
 692      */
 693     public static int round(float a) {
 694         int intBits = Float.floatToRawIntBits(a);
 695         int biasedExp = (intBits &amp; FloatConsts.EXP_BIT_MASK)
 696                 &gt;&gt; (FloatConsts.SIGNIFICAND_WIDTH - 1);
 697         int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2
 698                 + FloatConsts.EXP_BIAS) - biasedExp;
 699         if ((shift &amp; -32) == 0) { // shift &gt;= 0 &amp;&amp; shift &lt; 32
 700             // a is a finite number such that pow(2,-32) &lt;= ulp(a) &lt; 1
 701             int r = ((intBits &amp; FloatConsts.SIGNIF_BIT_MASK)
 702                     | (FloatConsts.SIGNIF_BIT_MASK + 1));
 703             if (intBits &lt; 0) {
 704                 r = -r;
 705             }
 706             // In the comments below each Java expression evaluates to the value
 707             // the corresponding mathematical expression:
 708             // (r) evaluates to a / ulp(a)
 709             // (r &gt;&gt; shift) evaluates to floor(a * 2)
 710             // ((r &gt;&gt; shift) + 1) evaluates to floor((a + 1/2) * 2)
 711             // (((r &gt;&gt; shift) + 1) &gt;&gt; 1) evaluates to floor(a + 1/2)
 712             return ((r &gt;&gt; shift) + 1) &gt;&gt; 1;
 713         } else {
 714             // a is either
 715             // - a finite number with abs(a) &lt; exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) &lt; 1/2
 716             // - a finite number with ulp(a) &gt;= 1 and hence a is a mathematical integer
 717             // - an infinity or NaN
 718             return (int) a;
 719         }
 720     }
 721 
 722     /**
 723      * Returns the closest {@code long} to the argument, with ties
 724      * rounding to positive infinity.
 725      *
 726      * &lt;p&gt;Special cases:
 727      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 728      * &lt;li&gt;If the argument is negative infinity or any value less than or
 729      * equal to the value of {@code Long.MIN_VALUE}, the result is
 730      * equal to the value of {@code Long.MIN_VALUE}.
 731      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 732      * equal to the value of {@code Long.MAX_VALUE}, the result is
 733      * equal to the value of {@code Long.MAX_VALUE}.&lt;/ul&gt;
 734      *
 735      * @param   a   a floating-point value to be rounded to a
 736      *          {@code long}.
 737      * @return  the value of the argument rounded to the nearest
 738      *          {@code long} value.
 739      * @see     java.lang.Long#MAX_VALUE
 740      * @see     java.lang.Long#MIN_VALUE
 741      */
 742     public static long round(double a) {
 743         long longBits = Double.doubleToRawLongBits(a);
 744         long biasedExp = (longBits &amp; DoubleConsts.EXP_BIT_MASK)
 745                 &gt;&gt; (DoubleConsts.SIGNIFICAND_WIDTH - 1);
 746         long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2
 747                 + DoubleConsts.EXP_BIAS) - biasedExp;
 748         if ((shift &amp; -64) == 0) { // shift &gt;= 0 &amp;&amp; shift &lt; 64
 749             // a is a finite number such that pow(2,-64) &lt;= ulp(a) &lt; 1
 750             long r = ((longBits &amp; DoubleConsts.SIGNIF_BIT_MASK)
 751                     | (DoubleConsts.SIGNIF_BIT_MASK + 1));
 752             if (longBits &lt; 0) {
 753                 r = -r;
 754             }
 755             // In the comments below each Java expression evaluates to the value
 756             // the corresponding mathematical expression:
 757             // (r) evaluates to a / ulp(a)
 758             // (r &gt;&gt; shift) evaluates to floor(a * 2)
 759             // ((r &gt;&gt; shift) + 1) evaluates to floor((a + 1/2) * 2)
 760             // (((r &gt;&gt; shift) + 1) &gt;&gt; 1) evaluates to floor(a + 1/2)
 761             return ((r &gt;&gt; shift) + 1) &gt;&gt; 1;
 762         } else {
 763             // a is either
 764             // - a finite number with abs(a) &lt; exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) &lt; 1/2
 765             // - a finite number with ulp(a) &gt;= 1 and hence a is a mathematical integer
 766             // - an infinity or NaN
 767             return (long) a;
 768         }
 769     }
 770 
 771     private static final class RandomNumberGeneratorHolder {
 772         static final Random randomNumberGenerator = new Random();
 773     }
 774 
 775     /**
 776      * Returns a {@code double} value with a positive sign, greater
 777      * than or equal to {@code 0.0} and less than {@code 1.0}.
 778      * Returned values are chosen pseudorandomly with (approximately)
 779      * uniform distribution from that range.
 780      *
 781      * &lt;p&gt;When this method is first called, it creates a single new
 782      * pseudorandom-number generator, exactly as if by the expression
 783      *
 784      * &lt;blockquote&gt;{@code new java.util.Random()}&lt;/blockquote&gt;
 785      *
 786      * This new pseudorandom-number generator is used thereafter for
 787      * all calls to this method and is used nowhere else.
 788      *
 789      * &lt;p&gt;This method is properly synchronized to allow correct use by
 790      * more than one thread. However, if many threads need to generate
 791      * pseudorandom numbers at a great rate, it may reduce contention
 792      * for each thread to have its own pseudorandom-number generator.
 793      *
 794      * @apiNote
 795      * As the largest {@code double} value less than {@code 1.0}
 796      * is {@code Math.nextDown(1.0)}, a value {@code x} in the closed range
 797      * {@code [x1,x2]} where {@code x1&lt;=x2} may be defined by the statements
 798      *
 799      * &lt;blockquote&gt;&lt;pre&gt;{@code
 800      * double f = Math.random()/Math.nextDown(1.0);
 801      * double x = x1*(1.0 - f) + x2*f;
 802      * }&lt;/pre&gt;&lt;/blockquote&gt;
 803      *
 804      * @return  a pseudorandom {@code double} greater than or equal
 805      * to {@code 0.0} and less than {@code 1.0}.
 806      * @see #nextDown(double)
 807      * @see Random#nextDouble()
 808      */
 809     public static double random() {
 810         return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
 811     }
 812 
 813     /**
 814      * Returns the sum of its arguments,
 815      * throwing an exception if the result overflows an {@code int}.
 816      *
 817      * @param x the first value
 818      * @param y the second value
 819      * @return the result
 820      * @throws ArithmeticException if the result overflows an int
 821      * @since 1.8
 822      */
 823     @HotSpotIntrinsicCandidate
 824     public static int addExact(int x, int y) {
 825         int r = x + y;
 826         // HD 2-12 Overflow iff both arguments have the opposite sign of the result
 827         if (((x ^ r) &amp; (y ^ r)) &lt; 0) {
 828             throw new ArithmeticException(&quot;integer overflow&quot;);
 829         }
 830         return r;
 831     }
 832 
 833     /**
 834      * Returns the sum of its arguments,
 835      * throwing an exception if the result overflows a {@code long}.
 836      *
 837      * @param x the first value
 838      * @param y the second value
 839      * @return the result
 840      * @throws ArithmeticException if the result overflows a long
 841      * @since 1.8
 842      */
 843     @HotSpotIntrinsicCandidate
 844     public static long addExact(long x, long y) {
 845         long r = x + y;
 846         // HD 2-12 Overflow iff both arguments have the opposite sign of the result
 847         if (((x ^ r) &amp; (y ^ r)) &lt; 0) {
 848             throw new ArithmeticException(&quot;long overflow&quot;);
 849         }
 850         return r;
 851     }
 852 
 853     /**
 854      * Returns the difference of the arguments,
 855      * throwing an exception if the result overflows an {@code int}.
 856      *
 857      * @param x the first value
 858      * @param y the second value to subtract from the first
 859      * @return the result
 860      * @throws ArithmeticException if the result overflows an int
 861      * @since 1.8
 862      */
 863     @HotSpotIntrinsicCandidate
 864     public static int subtractExact(int x, int y) {
 865         int r = x - y;
 866         // HD 2-12 Overflow iff the arguments have different signs and
 867         // the sign of the result is different from the sign of x
 868         if (((x ^ y) &amp; (x ^ r)) &lt; 0) {
 869             throw new ArithmeticException(&quot;integer overflow&quot;);
 870         }
 871         return r;
 872     }
 873 
 874     /**
 875      * Returns the difference of the arguments,
 876      * throwing an exception if the result overflows a {@code long}.
 877      *
 878      * @param x the first value
 879      * @param y the second value to subtract from the first
 880      * @return the result
 881      * @throws ArithmeticException if the result overflows a long
 882      * @since 1.8
 883      */
 884     @HotSpotIntrinsicCandidate
 885     public static long subtractExact(long x, long y) {
 886         long r = x - y;
 887         // HD 2-12 Overflow iff the arguments have different signs and
 888         // the sign of the result is different from the sign of x
 889         if (((x ^ y) &amp; (x ^ r)) &lt; 0) {
 890             throw new ArithmeticException(&quot;long overflow&quot;);
 891         }
 892         return r;
 893     }
 894 
 895     /**
 896      * Returns the product of the arguments,
 897      * throwing an exception if the result overflows an {@code int}.
 898      *
 899      * @param x the first value
 900      * @param y the second value
 901      * @return the result
 902      * @throws ArithmeticException if the result overflows an int
 903      * @since 1.8
 904      */
 905     @HotSpotIntrinsicCandidate
 906     public static int multiplyExact(int x, int y) {
 907         long r = (long)x * (long)y;
 908         if ((int)r != r) {
 909             throw new ArithmeticException(&quot;integer overflow&quot;);
 910         }
 911         return (int)r;
 912     }
 913 
 914     /**
 915      * Returns the product of the arguments, throwing an exception if the result
 916      * overflows a {@code long}.
 917      *
 918      * @param x the first value
 919      * @param y the second value
 920      * @return the result
 921      * @throws ArithmeticException if the result overflows a long
 922      * @since 9
 923      */
 924     public static long multiplyExact(long x, int y) {
 925         return multiplyExact(x, (long)y);
 926     }
 927 
 928     /**
 929      * Returns the product of the arguments,
 930      * throwing an exception if the result overflows a {@code long}.
 931      *
 932      * @param x the first value
 933      * @param y the second value
 934      * @return the result
 935      * @throws ArithmeticException if the result overflows a long
 936      * @since 1.8
 937      */
 938     @HotSpotIntrinsicCandidate
 939     public static long multiplyExact(long x, long y) {
 940         long r = x * y;
 941         long ax = Math.abs(x);
 942         long ay = Math.abs(y);
 943         if (((ax | ay) &gt;&gt;&gt; 31 != 0)) {
 944             // Some bits greater than 2^31 that might cause overflow
 945             // Check the result using the divide operator
 946             // and check for the special case of Long.MIN_VALUE * -1
 947            if (((y != 0) &amp;&amp; (r / y != x)) ||
 948                (x == Long.MIN_VALUE &amp;&amp; y == -1)) {
 949                 throw new ArithmeticException(&quot;long overflow&quot;);
 950             }
 951         }
 952         return r;
 953     }
 954 
 955     /**
 956      * Returns the argument incremented by one, throwing an exception if the
 957      * result overflows an {@code int}.
 958      * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.
 959      *
 960      * @param a the value to increment
 961      * @return the result
 962      * @throws ArithmeticException if the result overflows an int
 963      * @since 1.8
 964      */
 965     @HotSpotIntrinsicCandidate
 966     public static int incrementExact(int a) {
 967         if (a == Integer.MAX_VALUE) {
 968             throw new ArithmeticException(&quot;integer overflow&quot;);
 969         }
 970 
 971         return a + 1;
 972     }
 973 
 974     /**
 975      * Returns the argument incremented by one, throwing an exception if the
 976      * result overflows a {@code long}.
 977      * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.
 978      *
 979      * @param a the value to increment
 980      * @return the result
 981      * @throws ArithmeticException if the result overflows a long
 982      * @since 1.8
 983      */
 984     @HotSpotIntrinsicCandidate
 985     public static long incrementExact(long a) {
 986         if (a == Long.MAX_VALUE) {
 987             throw new ArithmeticException(&quot;long overflow&quot;);
 988         }
 989 
 990         return a + 1L;
 991     }
 992 
 993     /**
 994      * Returns the argument decremented by one, throwing an exception if the
 995      * result overflows an {@code int}.
 996      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
 997      *
 998      * @param a the value to decrement
 999      * @return the result
1000      * @throws ArithmeticException if the result overflows an int
1001      * @since 1.8
1002      */
1003     @HotSpotIntrinsicCandidate
1004     public static int decrementExact(int a) {
1005         if (a == Integer.MIN_VALUE) {
1006             throw new ArithmeticException(&quot;integer overflow&quot;);
1007         }
1008 
1009         return a - 1;
1010     }
1011 
1012     /**
1013      * Returns the argument decremented by one, throwing an exception if the
1014      * result overflows a {@code long}.
1015      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
1016      *
1017      * @param a the value to decrement
1018      * @return the result
1019      * @throws ArithmeticException if the result overflows a long
1020      * @since 1.8
1021      */
1022     @HotSpotIntrinsicCandidate
1023     public static long decrementExact(long a) {
1024         if (a == Long.MIN_VALUE) {
1025             throw new ArithmeticException(&quot;long overflow&quot;);
1026         }
1027 
1028         return a - 1L;
1029     }
1030 
1031     /**
1032      * Returns the negation of the argument, throwing an exception if the
1033      * result overflows an {@code int}.
1034      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
1035      *
1036      * @param a the value to negate
1037      * @return the result
1038      * @throws ArithmeticException if the result overflows an int
1039      * @since 1.8
1040      */
1041     @HotSpotIntrinsicCandidate
1042     public static int negateExact(int a) {
1043         if (a == Integer.MIN_VALUE) {
1044             throw new ArithmeticException(&quot;integer overflow&quot;);
1045         }
1046 
1047         return -a;
1048     }
1049 
1050     /**
1051      * Returns the negation of the argument, throwing an exception if the
1052      * result overflows a {@code long}.
1053      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
1054      *
1055      * @param a the value to negate
1056      * @return the result
1057      * @throws ArithmeticException if the result overflows a long
1058      * @since 1.8
1059      */
1060     @HotSpotIntrinsicCandidate
1061     public static long negateExact(long a) {
1062         if (a == Long.MIN_VALUE) {
1063             throw new ArithmeticException(&quot;long overflow&quot;);
1064         }
1065 
1066         return -a;
1067     }
1068 
1069     /**
1070      * Returns the value of the {@code long} argument,
1071      * throwing an exception if the value overflows an {@code int}.
1072      *
1073      * @param value the long value
1074      * @return the argument as an int
1075      * @throws ArithmeticException if the {@code argument} overflows an int
1076      * @since 1.8
1077      */
1078     public static int toIntExact(long value) {
1079         if ((int)value != value) {
1080             throw new ArithmeticException(&quot;integer overflow&quot;);
1081         }
1082         return (int)value;
1083     }
1084 
1085     /**
1086      * Returns the exact mathematical product of the arguments.
1087      *
1088      * @param x the first value
1089      * @param y the second value
1090      * @return the result
1091      * @since 9
1092      */
1093     public static long multiplyFull(int x, int y) {
1094         return (long)x * (long)y;
1095     }
1096 
1097     /**
1098      * Returns as a {@code long} the most significant 64 bits of the 128-bit
1099      * product of two 64-bit factors.
1100      *
1101      * @param x the first value
1102      * @param y the second value
1103      * @return the result
1104      * @since 9
1105      */
1106     @HotSpotIntrinsicCandidate
1107     public static long multiplyHigh(long x, long y) {
1108         if (x &lt; 0 || y &lt; 0) {
1109             // Use technique from section 8-2 of Henry S. Warren, Jr.,
1110             // Hacker&#39;s Delight (2nd ed.) (Addison Wesley, 2013), 173-174.
1111             long x1 = x &gt;&gt; 32;
1112             long x2 = x &amp; 0xFFFFFFFFL;
1113             long y1 = y &gt;&gt; 32;
1114             long y2 = y &amp; 0xFFFFFFFFL;
1115             long z2 = x2 * y2;
1116             long t = x1 * y2 + (z2 &gt;&gt;&gt; 32);
1117             long z1 = t &amp; 0xFFFFFFFFL;
1118             long z0 = t &gt;&gt; 32;
1119             z1 += x2 * y1;
1120             return x1 * y1 + z0 + (z1 &gt;&gt; 32);
1121         } else {
1122             // Use Karatsuba technique with two base 2^32 digits.
1123             long x1 = x &gt;&gt;&gt; 32;
1124             long y1 = y &gt;&gt;&gt; 32;
1125             long x2 = x &amp; 0xFFFFFFFFL;
1126             long y2 = y &amp; 0xFFFFFFFFL;
1127             long A = x1 * y1;
1128             long B = x2 * y2;
1129             long C = (x1 + x2) * (y1 + y2);
1130             long K = C - A - B;
1131             return (((B &gt;&gt;&gt; 32) + K) &gt;&gt;&gt; 32) + A;
1132         }
1133     }
1134 
1135     /**
1136      * Returns the largest (closest to positive infinity)
1137      * {@code int} value that is less than or equal to the algebraic quotient.
1138      * There is one special case, if the dividend is the
1139      * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},
1140      * then integer overflow occurs and
1141      * the result is equal to {@code Integer.MIN_VALUE}.
1142      * &lt;p&gt;
1143      * Normal integer division operates under the round to zero rounding mode
1144      * (truncation).  This operation instead acts under the round toward
1145      * negative infinity (floor) rounding mode.
1146      * The floor rounding mode gives different results from truncation
1147      * when the exact result is negative.
1148      * &lt;ul&gt;
1149      *   &lt;li&gt;If the signs of the arguments are the same, the results of
1150      *       {@code floorDiv} and the {@code /} operator are the same.  &lt;br&gt;
1151      *       For example, {@code floorDiv(4, 3) == 1} and {@code (4 / 3) == 1}.&lt;/li&gt;
1152      *   &lt;li&gt;If the signs of the arguments are different,  the quotient is negative and
1153      *       {@code floorDiv} returns the integer less than or equal to the quotient
1154      *       and the {@code /} operator returns the integer closest to zero.&lt;br&gt;
1155      *       For example, {@code floorDiv(-4, 3) == -2},
1156      *       whereas {@code (-4 / 3) == -1}.
1157      *   &lt;/li&gt;
1158      * &lt;/ul&gt;
1159      *
1160      * @param x the dividend
1161      * @param y the divisor
1162      * @return the largest (closest to positive infinity)
1163      * {@code int} value that is less than or equal to the algebraic quotient.
1164      * @throws ArithmeticException if the divisor {@code y} is zero
1165      * @see #floorMod(int, int)
1166      * @see #floor(double)
1167      * @since 1.8
1168      */
1169     public static int floorDiv(int x, int y) {
1170         int r = x / y;
1171         // if the signs are different and modulo not zero, round down
1172         if ((x ^ y) &lt; 0 &amp;&amp; (r * y != x)) {
1173             r--;
1174         }
1175         return r;
1176     }
1177 
1178     /**
1179      * Returns the largest (closest to positive infinity)
1180      * {@code long} value that is less than or equal to the algebraic quotient.
1181      * There is one special case, if the dividend is the
1182      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
1183      * then integer overflow occurs and
1184      * the result is equal to {@code Long.MIN_VALUE}.
1185      * &lt;p&gt;
1186      * Normal integer division operates under the round to zero rounding mode
1187      * (truncation).  This operation instead acts under the round toward
1188      * negative infinity (floor) rounding mode.
1189      * The floor rounding mode gives different results from truncation
1190      * when the exact result is negative.
1191      * &lt;p&gt;
1192      * For examples, see {@link #floorDiv(int, int)}.
1193      *
1194      * @param x the dividend
1195      * @param y the divisor
1196      * @return the largest (closest to positive infinity)
1197      * {@code int} value that is less than or equal to the algebraic quotient.
1198      * @throws ArithmeticException if the divisor {@code y} is zero
1199      * @see #floorMod(long, int)
1200      * @see #floor(double)
1201      * @since 9
1202      */
1203     public static long floorDiv(long x, int y) {
1204         return floorDiv(x, (long)y);
1205     }
1206 
1207     /**
1208      * Returns the largest (closest to positive infinity)
1209      * {@code long} value that is less than or equal to the algebraic quotient.
1210      * There is one special case, if the dividend is the
1211      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
1212      * then integer overflow occurs and
1213      * the result is equal to {@code Long.MIN_VALUE}.
1214      * &lt;p&gt;
1215      * Normal integer division operates under the round to zero rounding mode
1216      * (truncation).  This operation instead acts under the round toward
1217      * negative infinity (floor) rounding mode.
1218      * The floor rounding mode gives different results from truncation
1219      * when the exact result is negative.
1220      * &lt;p&gt;
1221      * For examples, see {@link #floorDiv(int, int)}.
1222      *
1223      * @param x the dividend
1224      * @param y the divisor
1225      * @return the largest (closest to positive infinity)
1226      * {@code long} value that is less than or equal to the algebraic quotient.
1227      * @throws ArithmeticException if the divisor {@code y} is zero
1228      * @see #floorMod(long, long)
1229      * @see #floor(double)
1230      * @since 1.8
1231      */
1232     public static long floorDiv(long x, long y) {
1233         long r = x / y;
1234         // if the signs are different and modulo not zero, round down
1235         if ((x ^ y) &lt; 0 &amp;&amp; (r * y != x)) {
1236             r--;
1237         }
1238         return r;
1239     }
1240 
1241     /**
1242      * Returns the floor modulus of the {@code int} arguments.
1243      * &lt;p&gt;
1244      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1245      * has the same sign as the divisor {@code y}, and
1246      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1247      *
1248      * &lt;p&gt;
1249      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1250      * &lt;ul&gt;
1251      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1252      * &lt;/ul&gt;
1253      * &lt;p&gt;
1254      * The difference in values between {@code floorMod} and
1255      * the {@code %} operator is due to the difference between
1256      * {@code floorDiv} that returns the integer less than or equal to the quotient
1257      * and the {@code /} operator that returns the integer closest to zero.
1258      * &lt;p&gt;
1259      * Examples:
1260      * &lt;ul&gt;
1261      *   &lt;li&gt;If the signs of the arguments are the same, the results
1262      *       of {@code floorMod} and the {@code %} operator are the same.&lt;br&gt;
1263      *       &lt;ul&gt;
1264      *       &lt;li&gt;{@code floorMod(+4, +3) == +1}; &amp;nbsp; and {@code (+4 % +3) == +1}&lt;/li&gt;
1265      *       &lt;li&gt;{@code floorMod(-4, -3) == -1}; &amp;nbsp; and {@code (-4 % -3) == -1}&lt;/li&gt;
1266      *       &lt;/ul&gt;
1267      *   &lt;li&gt;If the signs of the arguments are different, the results
1268      *       differ from the {@code %} operator.&lt;br&gt;
1269      *       &lt;ul&gt;
1270      *       &lt;li&gt;{@code floorMod(+4, -3) == -2}; &amp;nbsp; and {@code (+4 % -3) == +1}&lt;/li&gt;
1271      *       &lt;li&gt;{@code floorMod(-4, +3) == +2}; &amp;nbsp; and {@code (-4 % +3) == -1}&lt;/li&gt;
1272      *       &lt;/ul&gt;
1273      *   &lt;/li&gt;
1274      * &lt;/ul&gt;
1275      * &lt;p&gt;
1276      * If the signs of arguments are unknown and a positive modulus
1277      * is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
1278      *
1279      * @param x the dividend
1280      * @param y the divisor
1281      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1282      * @throws ArithmeticException if the divisor {@code y} is zero
1283      * @see #floorDiv(int, int)
1284      * @since 1.8
1285      */
1286     public static int floorMod(int x, int y) {
1287         int mod = x % y;
1288         // if the signs are different and modulo not zero, adjust result
1289         if ((mod ^ y) &lt; 0 &amp;&amp; mod != 0) {
1290             mod += y;
1291         }
1292         return mod;
1293     }
1294 
1295     /**
1296      * Returns the floor modulus of the {@code long} and {@code int} arguments.
1297      * &lt;p&gt;
1298      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1299      * has the same sign as the divisor {@code y}, and
1300      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1301      *
1302      * &lt;p&gt;
1303      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1304      * &lt;ul&gt;
1305      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1306      * &lt;/ul&gt;
1307      * &lt;p&gt;
1308      * For examples, see {@link #floorMod(int, int)}.
1309      *
1310      * @param x the dividend
1311      * @param y the divisor
1312      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1313      * @throws ArithmeticException if the divisor {@code y} is zero
1314      * @see #floorDiv(long, int)
1315      * @since 9
1316      */
1317     public static int floorMod(long x, int y) {
1318         // Result cannot overflow the range of int.
1319         return (int)floorMod(x, (long)y);
1320     }
1321 
1322     /**
1323      * Returns the floor modulus of the {@code long} arguments.
1324      * &lt;p&gt;
1325      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1326      * has the same sign as the divisor {@code y}, and
1327      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1328      *
1329      * &lt;p&gt;
1330      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1331      * &lt;ul&gt;
1332      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1333      * &lt;/ul&gt;
1334      * &lt;p&gt;
1335      * For examples, see {@link #floorMod(int, int)}.
1336      *
1337      * @param x the dividend
1338      * @param y the divisor
1339      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1340      * @throws ArithmeticException if the divisor {@code y} is zero
1341      * @see #floorDiv(long, long)
1342      * @since 1.8
1343      */
1344     public static long floorMod(long x, long y) {
1345         long mod = x % y;
1346         // if the signs are different and modulo not zero, adjust result
1347         if ((x ^ y) &lt; 0 &amp;&amp; mod != 0) {
1348             mod += y;
1349         }
1350         return mod;
1351     }
1352 
1353     /**
1354      * Returns the absolute value of an {@code int} value.
1355      * If the argument is not negative, the argument is returned.
1356      * If the argument is negative, the negation of the argument is returned.
1357      *
1358      * &lt;p&gt;Note that if the argument is equal to the value of
1359      * {@link Integer#MIN_VALUE}, the most negative representable
1360      * {@code int} value, the result is that same value, which is
1361      * negative.
1362      *
1363      * @param   a   the argument whose absolute value is to be determined
1364      * @return  the absolute value of the argument.
1365      */
1366     @HotSpotIntrinsicCandidate
1367     public static int abs(int a) {
1368         return (a &lt; 0) ? -a : a;
1369     }
1370 
1371     /**
1372      * Returns the absolute value of a {@code long} value.
1373      * If the argument is not negative, the argument is returned.
1374      * If the argument is negative, the negation of the argument is returned.
1375      *
1376      * &lt;p&gt;Note that if the argument is equal to the value of
1377      * {@link Long#MIN_VALUE}, the most negative representable
1378      * {@code long} value, the result is that same value, which
1379      * is negative.
1380      *
1381      * @param   a   the argument whose absolute value is to be determined
1382      * @return  the absolute value of the argument.
1383      */
1384     @HotSpotIntrinsicCandidate
1385     public static long abs(long a) {
1386         return (a &lt; 0) ? -a : a;
1387     }
1388 
1389     /**
1390      * Returns the absolute value of a {@code float} value.
1391      * If the argument is not negative, the argument is returned.
1392      * If the argument is negative, the negation of the argument is returned.
1393      * Special cases:
1394      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1395      * result is positive zero.
1396      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1397      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1398      *
1399      * @apiNote As implied by the above, one valid implementation of
1400      * this method is given by the expression below which computes a
1401      * {@code float} with the same exponent and significand as the
1402      * argument but with a guaranteed zero sign bit indicating a
1403      * positive value:&lt;br&gt;
1404      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1405      *
1406      * @param   a   the argument whose absolute value is to be determined
1407      * @return  the absolute value of the argument.
1408      */
1409     @HotSpotIntrinsicCandidate
1410     public static float abs(float a) {
1411         return (a &lt;= 0.0F) ? 0.0F - a : a;
1412     }
1413 
1414     /**
1415      * Returns the absolute value of a {@code double} value.
1416      * If the argument is not negative, the argument is returned.
1417      * If the argument is negative, the negation of the argument is returned.
1418      * Special cases:
1419      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1420      * is positive zero.
1421      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1422      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1423      *
1424      * @apiNote As implied by the above, one valid implementation of
1425      * this method is given by the expression below which computes a
1426      * {@code double} with the same exponent and significand as the
1427      * argument but with a guaranteed zero sign bit indicating a
1428      * positive value:&lt;br&gt;
1429      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
1430      *
1431      * @param   a   the argument whose absolute value is to be determined
1432      * @return  the absolute value of the argument.
1433      */
1434     @HotSpotIntrinsicCandidate
1435     public static double abs(double a) {
1436         return (a &lt;= 0.0D) ? 0.0D - a : a;
1437     }
1438 
1439     /**
1440      * Returns the greater of two {@code int} values. That is, the
1441      * result is the argument closer to the value of
1442      * {@link Integer#MAX_VALUE}. If the arguments have the same value,
1443      * the result is that same value.
1444      *
1445      * @param   a   an argument.
1446      * @param   b   another argument.
1447      * @return  the larger of {@code a} and {@code b}.
1448      */
1449     @HotSpotIntrinsicCandidate
1450     public static int max(int a, int b) {
1451         return (a &gt;= b) ? a : b;
1452     }
1453 
1454     /**
1455      * Returns the greater of two {@code long} values. That is, the
1456      * result is the argument closer to the value of
1457      * {@link Long#MAX_VALUE}. If the arguments have the same value,
1458      * the result is that same value.
1459      *
1460      * @param   a   an argument.
1461      * @param   b   another argument.
1462      * @return  the larger of {@code a} and {@code b}.
1463      */
1464     public static long max(long a, long b) {
1465         return (a &gt;= b) ? a : b;
1466     }
1467 
1468     // Use raw bit-wise conversions on guaranteed non-NaN arguments.
1469     private static final long negativeZeroFloatBits  = Float.floatToRawIntBits(-0.0f);
1470     private static final long negativeZeroDoubleBits = Double.doubleToRawLongBits(-0.0d);
1471 
1472     /**
1473      * Returns the greater of two {@code float} values.  That is,
1474      * the result is the argument closer to positive infinity. If the
1475      * arguments have the same value, the result is that same
1476      * value. If either value is NaN, then the result is NaN.  Unlike
1477      * the numerical comparison operators, this method considers
1478      * negative zero to be strictly smaller than positive zero. If one
1479      * argument is positive zero and the other negative zero, the
1480      * result is positive zero.
1481      *
1482      * @param   a   an argument.
1483      * @param   b   another argument.
1484      * @return  the larger of {@code a} and {@code b}.
1485      */
1486     @HotSpotIntrinsicCandidate
1487     public static float max(float a, float b) {
1488         if (a != a)
1489             return a;   // a is NaN
1490         if ((a == 0.0f) &amp;&amp;
1491             (b == 0.0f) &amp;&amp;
1492             (Float.floatToRawIntBits(a) == negativeZeroFloatBits)) {
1493             // Raw conversion ok since NaN can&#39;t map to -0.0.
1494             return b;
1495         }
1496         return (a &gt;= b) ? a : b;
1497     }
1498 
1499     /**
1500      * Returns the greater of two {@code double} values.  That
1501      * is, the result is the argument closer to positive infinity. If
1502      * the arguments have the same value, the result is that same
1503      * value. If either value is NaN, then the result is NaN.  Unlike
1504      * the numerical comparison operators, this method considers
1505      * negative zero to be strictly smaller than positive zero. If one
1506      * argument is positive zero and the other negative zero, the
1507      * result is positive zero.
1508      *
1509      * @param   a   an argument.
1510      * @param   b   another argument.
1511      * @return  the larger of {@code a} and {@code b}.
1512      */
1513     @HotSpotIntrinsicCandidate
1514     public static double max(double a, double b) {
1515         if (a != a)
1516             return a;   // a is NaN
1517         if ((a == 0.0d) &amp;&amp;
1518             (b == 0.0d) &amp;&amp;
1519             (Double.doubleToRawLongBits(a) == negativeZeroDoubleBits)) {
1520             // Raw conversion ok since NaN can&#39;t map to -0.0.
1521             return b;
1522         }
1523         return (a &gt;= b) ? a : b;
1524     }
1525 
1526     /**
1527      * Returns the smaller of two {@code int} values. That is,
1528      * the result the argument closer to the value of
1529      * {@link Integer#MIN_VALUE}.  If the arguments have the same
1530      * value, the result is that same value.
1531      *
1532      * @param   a   an argument.
1533      * @param   b   another argument.
1534      * @return  the smaller of {@code a} and {@code b}.
1535      */
1536     @HotSpotIntrinsicCandidate
1537     public static int min(int a, int b) {
1538         return (a &lt;= b) ? a : b;
1539     }
1540 
1541     /**
1542      * Returns the smaller of two {@code long} values. That is,
1543      * the result is the argument closer to the value of
1544      * {@link Long#MIN_VALUE}. If the arguments have the same
1545      * value, the result is that same value.
1546      *
1547      * @param   a   an argument.
1548      * @param   b   another argument.
1549      * @return  the smaller of {@code a} and {@code b}.
1550      */
1551     public static long min(long a, long b) {
1552         return (a &lt;= b) ? a : b;
1553     }
1554 
1555     /**
1556      * Returns the smaller of two {@code float} values.  That is,
1557      * the result is the value closer to negative infinity. If the
1558      * arguments have the same value, the result is that same
1559      * value. If either value is NaN, then the result is NaN.  Unlike
1560      * the numerical comparison operators, this method considers
1561      * negative zero to be strictly smaller than positive zero.  If
1562      * one argument is positive zero and the other is negative zero,
1563      * the result is negative zero.
1564      *
1565      * @param   a   an argument.
1566      * @param   b   another argument.
1567      * @return  the smaller of {@code a} and {@code b}.
1568      */
1569     @HotSpotIntrinsicCandidate
1570     public static float min(float a, float b) {
1571         if (a != a)
1572             return a;   // a is NaN
1573         if ((a == 0.0f) &amp;&amp;
1574             (b == 0.0f) &amp;&amp;
1575             (Float.floatToRawIntBits(b) == negativeZeroFloatBits)) {
1576             // Raw conversion ok since NaN can&#39;t map to -0.0.
1577             return b;
1578         }
1579         return (a &lt;= b) ? a : b;
1580     }
1581 
1582     /**
1583      * Returns the smaller of two {@code double} values.  That
1584      * is, the result is the value closer to negative infinity. If the
1585      * arguments have the same value, the result is that same
1586      * value. If either value is NaN, then the result is NaN.  Unlike
1587      * the numerical comparison operators, this method considers
1588      * negative zero to be strictly smaller than positive zero. If one
1589      * argument is positive zero and the other is negative zero, the
1590      * result is negative zero.
1591      *
1592      * @param   a   an argument.
1593      * @param   b   another argument.
1594      * @return  the smaller of {@code a} and {@code b}.
1595      */
1596     @HotSpotIntrinsicCandidate
1597     public static double min(double a, double b) {
1598         if (a != a)
1599             return a;   // a is NaN
1600         if ((a == 0.0d) &amp;&amp;
1601             (b == 0.0d) &amp;&amp;
1602             (Double.doubleToRawLongBits(b) == negativeZeroDoubleBits)) {
1603             // Raw conversion ok since NaN can&#39;t map to -0.0.
1604             return b;
1605         }
1606         return (a &lt;= b) ? a : b;
1607     }
1608 
1609     /**
1610      * Returns the fused multiply add of the three arguments; that is,
1611      * returns the exact product of the first two arguments summed
1612      * with the third argument and then rounded once to the nearest
1613      * {@code double}.
1614      *
1615      * The rounding is done using the {@linkplain
1616      * java.math.RoundingMode#HALF_EVEN round to nearest even
1617      * rounding mode}.
1618      *
1619      * In contrast, if {@code a * b + c} is evaluated as a regular
1620      * floating-point expression, two rounding errors are involved,
1621      * the first for the multiply operation, the second for the
1622      * addition operation.
1623      *
1624      * &lt;p&gt;Special cases:
1625      * &lt;ul&gt;
1626      * &lt;li&gt; If any argument is NaN, the result is NaN.
1627      *
1628      * &lt;li&gt; If one of the first two arguments is infinite and the
1629      * other is zero, the result is NaN.
1630      *
1631      * &lt;li&gt; If the exact product of the first two arguments is infinite
1632      * (in other words, at least one of the arguments is infinite and
1633      * the other is neither zero nor NaN) and the third argument is an
1634      * infinity of the opposite sign, the result is NaN.
1635      *
1636      * &lt;/ul&gt;
1637      *
1638      * &lt;p&gt;Note that {@code fma(a, 1.0, c)} returns the same
1639      * result as ({@code a + c}).  However,
1640      * {@code fma(a, b, +0.0)} does &lt;em&gt;not&lt;/em&gt; always return the
1641      * same result as ({@code a * b}) since
1642      * {@code fma(-0.0, +0.0, +0.0)} is {@code +0.0} while
1643      * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fma(a, b, -0.0)} is
1644      * equivalent to ({@code a * b}) however.
1645      *
1646      * @apiNote This method corresponds to the fusedMultiplyAdd
1647      * operation defined in IEEE 754-2008.
1648      *
1649      * @param a a value
1650      * @param b a value
1651      * @param c a value
1652      *
1653      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1654      * computed, as if with unlimited range and precision, and rounded
1655      * once to the nearest {@code double} value
1656      *
1657      * @since 9
1658      */
1659     @HotSpotIntrinsicCandidate
1660     public static double fma(double a, double b, double c) {
1661         /*
1662          * Infinity and NaN arithmetic is not quite the same with two
1663          * roundings as opposed to just one so the simple expression
1664          * &quot;a * b + c&quot; cannot always be used to compute the correct
1665          * result.  With two roundings, the product can overflow and
1666          * if the addend is infinite, a spurious NaN can be produced
1667          * if the infinity from the overflow and the infinite addend
1668          * have opposite signs.
1669          */
1670 
1671         // First, screen for and handle non-finite input values whose
1672         // arithmetic is not supported by BigDecimal.
1673         if (Double.isNaN(a) || Double.isNaN(b) || Double.isNaN(c)) {
1674             return Double.NaN;
1675         } else { // All inputs non-NaN
1676             boolean infiniteA = Double.isInfinite(a);
1677             boolean infiniteB = Double.isInfinite(b);
1678             boolean infiniteC = Double.isInfinite(c);
1679             double result;
1680 
1681             if (infiniteA || infiniteB || infiniteC) {
1682                 if (infiniteA &amp;&amp; b == 0.0 ||
1683                     infiniteB &amp;&amp; a == 0.0 ) {
1684                     return Double.NaN;
1685                 }
1686                 // Store product in a double field to cause an
1687                 // overflow even if non-strictfp evaluation is being
1688                 // used.
1689                 double product = a * b;
1690                 if (Double.isInfinite(product) &amp;&amp; !infiniteA &amp;&amp; !infiniteB) {
1691                     // Intermediate overflow; might cause a
1692                     // spurious NaN if added to infinite c.
1693                     assert Double.isInfinite(c);
1694                     return c;
1695                 } else {
1696                     result = product + c;
1697                     assert !Double.isFinite(result);
1698                     return result;
1699                 }
1700             } else { // All inputs finite
1701                 BigDecimal product = (new BigDecimal(a)).multiply(new BigDecimal(b));
1702                 if (c == 0.0) { // Positive or negative zero
1703                     // If the product is an exact zero, use a
1704                     // floating-point expression to compute the sign
1705                     // of the zero final result. The product is an
1706                     // exact zero if and only if at least one of a and
1707                     // b is zero.
1708                     if (a == 0.0 || b == 0.0) {
1709                         return a * b + c;
1710                     } else {
1711                         // The sign of a zero addend doesn&#39;t matter if
1712                         // the product is nonzero. The sign of a zero
1713                         // addend is not factored in the result if the
1714                         // exact product is nonzero but underflows to
1715                         // zero; see IEEE-754 2008 section 6.3 &quot;The
1716                         // sign bit&quot;.
1717                         return product.doubleValue();
1718                     }
1719                 } else {
1720                     return product.add(new BigDecimal(c)).doubleValue();
1721                 }
1722             }
1723         }
1724     }
1725 
1726     /**
1727      * Returns the fused multiply add of the three arguments; that is,
1728      * returns the exact product of the first two arguments summed
1729      * with the third argument and then rounded once to the nearest
1730      * {@code float}.
1731      *
1732      * The rounding is done using the {@linkplain
1733      * java.math.RoundingMode#HALF_EVEN round to nearest even
1734      * rounding mode}.
1735      *
1736      * In contrast, if {@code a * b + c} is evaluated as a regular
1737      * floating-point expression, two rounding errors are involved,
1738      * the first for the multiply operation, the second for the
1739      * addition operation.
1740      *
1741      * &lt;p&gt;Special cases:
1742      * &lt;ul&gt;
1743      * &lt;li&gt; If any argument is NaN, the result is NaN.
1744      *
1745      * &lt;li&gt; If one of the first two arguments is infinite and the
1746      * other is zero, the result is NaN.
1747      *
1748      * &lt;li&gt; If the exact product of the first two arguments is infinite
1749      * (in other words, at least one of the arguments is infinite and
1750      * the other is neither zero nor NaN) and the third argument is an
1751      * infinity of the opposite sign, the result is NaN.
1752      *
1753      * &lt;/ul&gt;
1754      *
1755      * &lt;p&gt;Note that {@code fma(a, 1.0f, c)} returns the same
1756      * result as ({@code a + c}).  However,
1757      * {@code fma(a, b, +0.0f)} does &lt;em&gt;not&lt;/em&gt; always return the
1758      * same result as ({@code a * b}) since
1759      * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
1760      * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
1761      * equivalent to ({@code a * b}) however.
1762      *
1763      * @apiNote This method corresponds to the fusedMultiplyAdd
1764      * operation defined in IEEE 754-2008.
1765      *
1766      * @param a a value
1767      * @param b a value
1768      * @param c a value
1769      *
1770      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1771      * computed, as if with unlimited range and precision, and rounded
1772      * once to the nearest {@code float} value
1773      *
1774      * @since 9
1775      */
1776     @HotSpotIntrinsicCandidate
1777     public static float fma(float a, float b, float c) {
1778         /*
1779          *  Since the double format has more than twice the precision
1780          *  of the float format, the multiply of a * b is exact in
1781          *  double. The add of c to the product then incurs one
1782          *  rounding error. Since the double format moreover has more
1783          *  than (2p + 2) precision bits compared to the p bits of the
1784          *  float format, the two roundings of (a * b + c), first to
1785          *  the double format and then secondarily to the float format,
1786          *  are equivalent to rounding the intermediate result directly
1787          *  to the float format.
1788          *
1789          * In terms of strictfp vs default-fp concerns related to
1790          * overflow and underflow, since
1791          *
1792          * (Float.MAX_VALUE * Float.MAX_VALUE) &lt;&lt; Double.MAX_VALUE
1793          * (Float.MIN_VALUE * Float.MIN_VALUE) &gt;&gt; Double.MIN_VALUE
1794          *
1795          * neither the multiply nor add will overflow or underflow in
1796          * double. Therefore, it is not necessary for this method to
1797          * be declared strictfp to have reproducible
1798          * behavior. However, it is necessary to explicitly store down
1799          * to a float variable to avoid returning a value in the float
1800          * extended value set.
1801          */
1802         float result = (float)(((double) a * (double) b ) + (double) c);
1803         return result;
1804     }
1805 
1806     /**
1807      * Returns the size of an ulp of the argument.  An ulp, unit in
1808      * the last place, of a {@code double} value is the positive
1809      * distance between this floating-point value and the {@code
1810      * double} value next larger in magnitude.  Note that for non-NaN
1811      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1812      *
1813      * &lt;p&gt;Special Cases:
1814      * &lt;ul&gt;
1815      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1816      * &lt;li&gt; If the argument is positive or negative infinity, then the
1817      * result is positive infinity.
1818      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1819      * {@code Double.MIN_VALUE}.
1820      * &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
1821      * the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
1822      * &lt;/ul&gt;
1823      *
1824      * @param d the floating-point value whose ulp is to be returned
1825      * @return the size of an ulp of the argument
1826      * @author Joseph D. Darcy
1827      * @since 1.5
1828      */
1829     public static double ulp(double d) {
1830         int exp = getExponent(d);
1831 
1832         switch(exp) {
1833         case Double.MAX_EXPONENT + 1:       // NaN or infinity
1834             return Math.abs(d);
1835 
1836         case Double.MIN_EXPONENT - 1:       // zero or subnormal
1837             return Double.MIN_VALUE;
1838 
1839         default:
1840             assert exp &lt;= Double.MAX_EXPONENT &amp;&amp; exp &gt;= Double.MIN_EXPONENT;
1841 
1842             // ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
1843             exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH-1);
1844             if (exp &gt;= Double.MIN_EXPONENT) {
1845                 return powerOfTwoD(exp);
1846             }
1847             else {
1848                 // return a subnormal result; left shift integer
1849                 // representation of Double.MIN_VALUE appropriate
1850                 // number of positions
1851                 return Double.longBitsToDouble(1L &lt;&lt;
1852                 (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH-1)) ));
1853             }
1854         }
1855     }
1856 
1857     /**
1858      * Returns the size of an ulp of the argument.  An ulp, unit in
1859      * the last place, of a {@code float} value is the positive
1860      * distance between this floating-point value and the {@code
1861      * float} value next larger in magnitude.  Note that for non-NaN
1862      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1863      *
1864      * &lt;p&gt;Special Cases:
1865      * &lt;ul&gt;
1866      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1867      * &lt;li&gt; If the argument is positive or negative infinity, then the
1868      * result is positive infinity.
1869      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1870      * {@code Float.MIN_VALUE}.
1871      * &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
1872      * the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
1873      * &lt;/ul&gt;
1874      *
1875      * @param f the floating-point value whose ulp is to be returned
1876      * @return the size of an ulp of the argument
1877      * @author Joseph D. Darcy
1878      * @since 1.5
1879      */
1880     public static float ulp(float f) {
1881         int exp = getExponent(f);
1882 
1883         switch(exp) {
1884         case Float.MAX_EXPONENT+1:        // NaN or infinity
1885             return Math.abs(f);
1886 
1887         case Float.MIN_EXPONENT-1:        // zero or subnormal
1888             return Float.MIN_VALUE;
1889 
1890         default:
1891             assert exp &lt;= Float.MAX_EXPONENT &amp;&amp; exp &gt;= Float.MIN_EXPONENT;
1892 
1893             // ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
1894             exp = exp - (FloatConsts.SIGNIFICAND_WIDTH-1);
1895             if (exp &gt;= Float.MIN_EXPONENT) {
1896                 return powerOfTwoF(exp);
1897             } else {
1898                 // return a subnormal result; left shift integer
1899                 // representation of FloatConsts.MIN_VALUE appropriate
1900                 // number of positions
1901                 return Float.intBitsToFloat(1 &lt;&lt;
1902                 (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH-1)) ));
1903             }
1904         }
1905     }
1906 
1907     /**
1908      * Returns the signum function of the argument; zero if the argument
1909      * is zero, 1.0 if the argument is greater than zero, -1.0 if the
1910      * argument is less than zero.
1911      *
1912      * &lt;p&gt;Special Cases:
1913      * &lt;ul&gt;
1914      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1915      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1916      *      result is the same as the argument.
1917      * &lt;/ul&gt;
1918      *
1919      * @param d the floating-point value whose signum is to be returned
1920      * @return the signum function of the argument
1921      * @author Joseph D. Darcy
1922      * @since 1.5
1923      */
1924     public static double signum(double d) {
1925         return (d == 0.0 || Double.isNaN(d))?d:copySign(1.0, d);
1926     }
1927 
1928     /**
1929      * Returns the signum function of the argument; zero if the argument
1930      * is zero, 1.0f if the argument is greater than zero, -1.0f if the
1931      * argument is less than zero.
1932      *
1933      * &lt;p&gt;Special Cases:
1934      * &lt;ul&gt;
1935      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1936      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1937      *      result is the same as the argument.
1938      * &lt;/ul&gt;
1939      *
1940      * @param f the floating-point value whose signum is to be returned
1941      * @return the signum function of the argument
1942      * @author Joseph D. Darcy
1943      * @since 1.5
1944      */
1945     public static float signum(float f) {
1946         return (f == 0.0f || Float.isNaN(f))?f:copySign(1.0f, f);
1947     }
1948 
1949     /**
1950      * Returns the hyperbolic sine of a {@code double} value.
1951      * The hyperbolic sine of &lt;i&gt;x&lt;/i&gt; is defined to be
1952      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1953      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1954      *
1955      * &lt;p&gt;Special cases:
1956      * &lt;ul&gt;
1957      *
1958      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1959      *
1960      * &lt;li&gt;If the argument is infinite, then the result is an infinity
1961      * with the same sign as the argument.
1962      *
1963      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1964      * same sign as the argument.
1965      *
1966      * &lt;/ul&gt;
1967      *
1968      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
1969      *
1970      * @param   x The number whose hyperbolic sine is to be returned.
1971      * @return  The hyperbolic sine of {@code x}.
1972      * @since 1.5
1973      */
1974     public static double sinh(double x) {
1975         return StrictMath.sinh(x);
1976     }
1977 
1978     /**
1979      * Returns the hyperbolic cosine of a {@code double} value.
1980      * The hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; is defined to be
1981      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1982      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1983      *
1984      * &lt;p&gt;Special cases:
1985      * &lt;ul&gt;
1986      *
1987      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1988      *
1989      * &lt;li&gt;If the argument is infinite, then the result is positive
1990      * infinity.
1991      *
1992      * &lt;li&gt;If the argument is zero, then the result is {@code 1.0}.
1993      *
1994      * &lt;/ul&gt;
1995      *
1996      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
1997      *
1998      * @param   x The number whose hyperbolic cosine is to be returned.
1999      * @return  The hyperbolic cosine of {@code x}.
2000      * @since 1.5
2001      */
2002     public static double cosh(double x) {
2003         return StrictMath.cosh(x);
2004     }
2005 
2006     /**
2007      * Returns the hyperbolic tangent of a {@code double} value.
2008      * The hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; is defined to be
2009      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/(&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;),
2010      * in other words, {@linkplain Math#sinh
2011      * sinh(&lt;i&gt;x&lt;/i&gt;)}/{@linkplain Math#cosh cosh(&lt;i&gt;x&lt;/i&gt;)}.  Note
2012      * that the absolute value of the exact tanh is always less than
2013      * 1.
2014      *
2015      * &lt;p&gt;Special cases:
2016      * &lt;ul&gt;
2017      *
2018      * &lt;li&gt;If the argument is NaN, then the result is NaN.
2019      *
2020      * &lt;li&gt;If the argument is zero, then the result is a zero with the
2021      * same sign as the argument.
2022      *
2023      * &lt;li&gt;If the argument is positive infinity, then the result is
2024      * {@code +1.0}.
2025      *
2026      * &lt;li&gt;If the argument is negative infinity, then the result is
2027      * {@code -1.0}.
2028      *
2029      * &lt;/ul&gt;
2030      *
2031      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
2032      * The result of {@code tanh} for any finite input must have
2033      * an absolute value less than or equal to 1.  Note that once the
2034      * exact result of tanh is within 1/2 of an ulp of the limit value
2035      * of &amp;plusmn;1, correctly signed &amp;plusmn;{@code 1.0} should
2036      * be returned.
2037      *
2038      * @param   x The number whose hyperbolic tangent is to be returned.
2039      * @return  The hyperbolic tangent of {@code x}.
2040      * @since 1.5
2041      */
2042     public static double tanh(double x) {
2043         return StrictMath.tanh(x);
2044     }
2045 
2046     /**
2047      * Returns sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
2048      * without intermediate overflow or underflow.
2049      *
2050      * &lt;p&gt;Special cases:
2051      * &lt;ul&gt;
2052      *
2053      * &lt;li&gt; If either argument is infinite, then the result
2054      * is positive infinity.
2055      *
2056      * &lt;li&gt; If either argument is NaN and neither argument is infinite,
2057      * then the result is NaN.
2058      *
2059      * &lt;/ul&gt;
2060      *
2061      * &lt;p&gt;The computed result must be within 1 ulp of the exact
2062      * result.  If one parameter is held constant, the results must be
2063      * semi-monotonic in the other parameter.
2064      *
2065      * @param x a value
2066      * @param y a value
2067      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
2068      * without intermediate overflow or underflow
2069      * @since 1.5
2070      */
2071     public static double hypot(double x, double y) {
2072         return StrictMath.hypot(x, y);
2073     }
2074 
2075     /**
2076      * Returns &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-1.  Note that for values of
2077      * &lt;i&gt;x&lt;/i&gt; near 0, the exact sum of
2078      * {@code expm1(x)}&amp;nbsp;+&amp;nbsp;1 is much closer to the true
2079      * result of &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt; than {@code exp(x)}.
2080      *
2081      * &lt;p&gt;Special cases:
2082      * &lt;ul&gt;
2083      * &lt;li&gt;If the argument is NaN, the result is NaN.
2084      *
2085      * &lt;li&gt;If the argument is positive infinity, then the result is
2086      * positive infinity.
2087      *
2088      * &lt;li&gt;If the argument is negative infinity, then the result is
2089      * -1.0.
2090      *
2091      * &lt;li&gt;If the argument is zero, then the result is a zero with the
2092      * same sign as the argument.
2093      *
2094      * &lt;/ul&gt;
2095      *
2096      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
2097      * Results must be semi-monotonic.  The result of
2098      * {@code expm1} for any finite input must be greater than or
2099      * equal to {@code -1.0}.  Note that once the exact result of
2100      * &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1 is within 1/2
2101      * ulp of the limit value -1, {@code -1.0} should be
2102      * returned.
2103      *
2104      * @param   x   the exponent to raise &lt;i&gt;e&lt;/i&gt; to in the computation of
2105      *              &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-1.
2106      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1.
2107      * @since 1.5
2108      */
2109     public static double expm1(double x) {
2110         return StrictMath.expm1(x);
2111     }
2112 
2113     /**
2114      * Returns the natural logarithm of the sum of the argument and 1.
2115      * Note that for small values {@code x}, the result of
2116      * {@code log1p(x)} is much closer to the true result of ln(1
2117      * + {@code x}) than the floating-point evaluation of
2118      * {@code log(1.0+x)}.
2119      *
2120      * &lt;p&gt;Special cases:
2121      *
2122      * &lt;ul&gt;
2123      *
2124      * &lt;li&gt;If the argument is NaN or less than -1, then the result is
2125      * NaN.
2126      *
2127      * &lt;li&gt;If the argument is positive infinity, then the result is
2128      * positive infinity.
2129      *
2130      * &lt;li&gt;If the argument is negative one, then the result is
2131      * negative infinity.
2132      *
2133      * &lt;li&gt;If the argument is zero, then the result is a zero with the
2134      * same sign as the argument.
2135      *
2136      * &lt;/ul&gt;
2137      *
2138      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
2139      * Results must be semi-monotonic.
2140      *
2141      * @param   x   a value
2142      * @return the value ln({@code x}&amp;nbsp;+&amp;nbsp;1), the natural
2143      * log of {@code x}&amp;nbsp;+&amp;nbsp;1
2144      * @since 1.5
2145      */
2146     public static double log1p(double x) {
2147         return StrictMath.log1p(x);
2148     }
2149 
2150     /**
2151      * Returns the first floating-point argument with the sign of the
2152      * second floating-point argument.  Note that unlike the {@link
2153      * StrictMath#copySign(double, double) StrictMath.copySign}
2154      * method, this method does not require NaN {@code sign}
2155      * arguments to be treated as positive values; implementations are
2156      * permitted to treat some NaN arguments as positive and other NaN
2157      * arguments as negative to allow greater performance.
2158      *
2159      * @param magnitude  the parameter providing the magnitude of the result
2160      * @param sign   the parameter providing the sign of the result
2161      * @return a value with the magnitude of {@code magnitude}
2162      * and the sign of {@code sign}.
2163      * @since 1.6
2164      */
2165     public static double copySign(double magnitude, double sign) {
2166         return Double.longBitsToDouble((Double.doubleToRawLongBits(sign) &amp;
2167                                         (DoubleConsts.SIGN_BIT_MASK)) |
2168                                        (Double.doubleToRawLongBits(magnitude) &amp;
2169                                         (DoubleConsts.EXP_BIT_MASK |
2170                                          DoubleConsts.SIGNIF_BIT_MASK)));
2171     }
2172 
2173     /**
2174      * Returns the first floating-point argument with the sign of the
2175      * second floating-point argument.  Note that unlike the {@link
2176      * StrictMath#copySign(float, float) StrictMath.copySign}
2177      * method, this method does not require NaN {@code sign}
2178      * arguments to be treated as positive values; implementations are
2179      * permitted to treat some NaN arguments as positive and other NaN
2180      * arguments as negative to allow greater performance.
2181      *
2182      * @param magnitude  the parameter providing the magnitude of the result
2183      * @param sign   the parameter providing the sign of the result
2184      * @return a value with the magnitude of {@code magnitude}
2185      * and the sign of {@code sign}.
2186      * @since 1.6
2187      */
2188     public static float copySign(float magnitude, float sign) {
2189         return Float.intBitsToFloat((Float.floatToRawIntBits(sign) &amp;
2190                                      (FloatConsts.SIGN_BIT_MASK)) |
2191                                     (Float.floatToRawIntBits(magnitude) &amp;
2192                                      (FloatConsts.EXP_BIT_MASK |
2193                                       FloatConsts.SIGNIF_BIT_MASK)));
2194     }
2195 
2196     /**
2197      * Returns the unbiased exponent used in the representation of a
2198      * {@code float}.  Special cases:
2199      *
2200      * &lt;ul&gt;
2201      * &lt;li&gt;If the argument is NaN or infinite, then the result is
2202      * {@link Float#MAX_EXPONENT} + 1.
2203      * &lt;li&gt;If the argument is zero or subnormal, then the result is
2204      * {@link Float#MIN_EXPONENT} -1.
2205      * &lt;/ul&gt;
2206      * @param f a {@code float} value
2207      * @return the unbiased exponent of the argument
2208      * @since 1.6
2209      */
2210     public static int getExponent(float f) {
2211         /*
2212          * Bitwise convert f to integer, mask out exponent bits, shift
2213          * to the right and then subtract out float&#39;s bias adjust to
2214          * get true exponent value
2215          */
2216         return ((Float.floatToRawIntBits(f) &amp; FloatConsts.EXP_BIT_MASK) &gt;&gt;
2217                 (FloatConsts.SIGNIFICAND_WIDTH - 1)) - FloatConsts.EXP_BIAS;
2218     }
2219 
2220     /**
2221      * Returns the unbiased exponent used in the representation of a
2222      * {@code double}.  Special cases:
2223      *
2224      * &lt;ul&gt;
2225      * &lt;li&gt;If the argument is NaN or infinite, then the result is
2226      * {@link Double#MAX_EXPONENT} + 1.
2227      * &lt;li&gt;If the argument is zero or subnormal, then the result is
2228      * {@link Double#MIN_EXPONENT} -1.
2229      * &lt;/ul&gt;
2230      * @param d a {@code double} value
2231      * @return the unbiased exponent of the argument
2232      * @since 1.6
2233      */
2234     public static int getExponent(double d) {
2235         /*
2236          * Bitwise convert d to long, mask out exponent bits, shift
2237          * to the right and then subtract out double&#39;s bias adjust to
2238          * get true exponent value.
2239          */
2240         return (int)(((Double.doubleToRawLongBits(d) &amp; DoubleConsts.EXP_BIT_MASK) &gt;&gt;
2241                       (DoubleConsts.SIGNIFICAND_WIDTH - 1)) - DoubleConsts.EXP_BIAS);
2242     }
2243 
2244     /**
2245      * Returns the floating-point number adjacent to the first
2246      * argument in the direction of the second argument.  If both
2247      * arguments compare as equal the second argument is returned.
2248      *
2249      * &lt;p&gt;
2250      * Special cases:
2251      * &lt;ul&gt;
2252      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
2253      *
2254      * &lt;li&gt; If both arguments are signed zeros, {@code direction}
2255      * is returned unchanged (as implied by the requirement of
2256      * returning the second argument if the arguments compare as
2257      * equal).
2258      *
2259      * &lt;li&gt; If {@code start} is
2260      * &amp;plusmn;{@link Double#MIN_VALUE} and {@code direction}
2261      * has a value such that the result should have a smaller
2262      * magnitude, then a zero with the same sign as {@code start}
2263      * is returned.
2264      *
2265      * &lt;li&gt; If {@code start} is infinite and
2266      * {@code direction} has a value such that the result should
2267      * have a smaller magnitude, {@link Double#MAX_VALUE} with the
2268      * same sign as {@code start} is returned.
2269      *
2270      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
2271      * {@link Double#MAX_VALUE} and {@code direction} has a
2272      * value such that the result should have a larger magnitude, an
2273      * infinity with same sign as {@code start} is returned.
2274      * &lt;/ul&gt;
2275      *
2276      * @param start  starting floating-point value
2277      * @param direction value indicating which of
2278      * {@code start}&#39;s neighbors or {@code start} should
2279      * be returned
2280      * @return The floating-point number adjacent to {@code start} in the
2281      * direction of {@code direction}.
2282      * @since 1.6
2283      */
2284     public static double nextAfter(double start, double direction) {
2285         /*
2286          * The cases:
2287          *
2288          * nextAfter(+infinity, 0)  == MAX_VALUE
2289          * nextAfter(+infinity, +infinity)  == +infinity
2290          * nextAfter(-infinity, 0)  == -MAX_VALUE
2291          * nextAfter(-infinity, -infinity)  == -infinity
2292          *
2293          * are naturally handled without any additional testing
2294          */
2295 
2296         /*
2297          * IEEE 754 floating-point numbers are lexicographically
2298          * ordered if treated as signed-magnitude integers.
2299          * Since Java&#39;s integers are two&#39;s complement,
2300          * incrementing the two&#39;s complement representation of a
2301          * logically negative floating-point value *decrements*
2302          * the signed-magnitude representation. Therefore, when
2303          * the integer representation of a floating-point value
2304          * is negative, the adjustment to the representation is in
2305          * the opposite direction from what would initially be expected.
2306          */
2307 
2308         // Branch to descending case first as it is more costly than ascending
2309         // case due to start != 0.0d conditional.
2310         if (start &gt; direction) { // descending
2311             if (start != 0.0d) {
2312                 final long transducer = Double.doubleToRawLongBits(start);
2313                 return Double.longBitsToDouble(transducer + ((transducer &gt; 0L) ? -1L : 1L));
2314             } else { // start == 0.0d &amp;&amp; direction &lt; 0.0d
2315                 return -Double.MIN_VALUE;
2316             }
2317         } else if (start &lt; direction) { // ascending
2318             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0)
2319             // then bitwise convert start to integer.
2320             final long transducer = Double.doubleToRawLongBits(start + 0.0d);
2321             return Double.longBitsToDouble(transducer + ((transducer &gt;= 0L) ? 1L : -1L));
2322         } else if (start == direction) {
2323             return direction;
2324         } else { // isNaN(start) || isNaN(direction)
2325             return start + direction;
2326         }
2327     }
2328 
2329     /**
2330      * Returns the floating-point number adjacent to the first
2331      * argument in the direction of the second argument.  If both
2332      * arguments compare as equal a value equivalent to the second argument
2333      * is returned.
2334      *
2335      * &lt;p&gt;
2336      * Special cases:
2337      * &lt;ul&gt;
2338      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
2339      *
2340      * &lt;li&gt; If both arguments are signed zeros, a value equivalent
2341      * to {@code direction} is returned.
2342      *
2343      * &lt;li&gt; If {@code start} is
2344      * &amp;plusmn;{@link Float#MIN_VALUE} and {@code direction}
2345      * has a value such that the result should have a smaller
2346      * magnitude, then a zero with the same sign as {@code start}
2347      * is returned.
2348      *
2349      * &lt;li&gt; If {@code start} is infinite and
2350      * {@code direction} has a value such that the result should
2351      * have a smaller magnitude, {@link Float#MAX_VALUE} with the
2352      * same sign as {@code start} is returned.
2353      *
2354      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
2355      * {@link Float#MAX_VALUE} and {@code direction} has a
2356      * value such that the result should have a larger magnitude, an
2357      * infinity with same sign as {@code start} is returned.
2358      * &lt;/ul&gt;
2359      *
2360      * @param start  starting floating-point value
2361      * @param direction value indicating which of
2362      * {@code start}&#39;s neighbors or {@code start} should
2363      * be returned
2364      * @return The floating-point number adjacent to {@code start} in the
2365      * direction of {@code direction}.
2366      * @since 1.6
2367      */
2368     public static float nextAfter(float start, double direction) {
2369         /*
2370          * The cases:
2371          *
2372          * nextAfter(+infinity, 0)  == MAX_VALUE
2373          * nextAfter(+infinity, +infinity)  == +infinity
2374          * nextAfter(-infinity, 0)  == -MAX_VALUE
2375          * nextAfter(-infinity, -infinity)  == -infinity
2376          *
2377          * are naturally handled without any additional testing
2378          */
2379 
2380         /*
2381          * IEEE 754 floating-point numbers are lexicographically
2382          * ordered if treated as signed-magnitude integers.
2383          * Since Java&#39;s integers are two&#39;s complement,
2384          * incrementing the two&#39;s complement representation of a
2385          * logically negative floating-point value *decrements*
2386          * the signed-magnitude representation. Therefore, when
2387          * the integer representation of a floating-point value
2388          * is negative, the adjustment to the representation is in
2389          * the opposite direction from what would initially be expected.
2390          */
2391 
2392         // Branch to descending case first as it is more costly than ascending
2393         // case due to start != 0.0f conditional.
2394         if (start &gt; direction) { // descending
2395             if (start != 0.0f) {
2396                 final int transducer = Float.floatToRawIntBits(start);
2397                 return Float.intBitsToFloat(transducer + ((transducer &gt; 0) ? -1 : 1));
2398             } else { // start == 0.0f &amp;&amp; direction &lt; 0.0f
2399                 return -Float.MIN_VALUE;
2400             }
2401         } else if (start &lt; direction) { // ascending
2402             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0)
2403             // then bitwise convert start to integer.
2404             final int transducer = Float.floatToRawIntBits(start + 0.0f);
2405             return Float.intBitsToFloat(transducer + ((transducer &gt;= 0) ? 1 : -1));
2406         } else if (start == direction) {
2407             return (float)direction;
2408         } else { // isNaN(start) || isNaN(direction)
2409             return start + (float)direction;
2410         }
2411     }
2412 
2413     /**
2414      * Returns the floating-point value adjacent to {@code d} in
2415      * the direction of positive infinity.  This method is
2416      * semantically equivalent to {@code nextAfter(d,
2417      * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}
2418      * implementation may run faster than its equivalent
2419      * {@code nextAfter} call.
2420      *
2421      * &lt;p&gt;Special Cases:
2422      * &lt;ul&gt;
2423      * &lt;li&gt; If the argument is NaN, the result is NaN.
2424      *
2425      * &lt;li&gt; If the argument is positive infinity, the result is
2426      * positive infinity.
2427      *
2428      * &lt;li&gt; If the argument is zero, the result is
2429      * {@link Double#MIN_VALUE}
2430      *
2431      * &lt;/ul&gt;
2432      *
2433      * @param d starting floating-point value
2434      * @return The adjacent floating-point value closer to positive
2435      * infinity.
2436      * @since 1.6
2437      */
2438     public static double nextUp(double d) {
2439         // Use a single conditional and handle the likely cases first.
2440         if (d &lt; Double.POSITIVE_INFINITY) {
2441             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0).
2442             final long transducer = Double.doubleToRawLongBits(d + 0.0D);
2443             return Double.longBitsToDouble(transducer + ((transducer &gt;= 0L) ? 1L : -1L));
2444         } else { // d is NaN or +Infinity
2445             return d;
2446         }
2447     }
2448 
2449     /**
2450      * Returns the floating-point value adjacent to {@code f} in
2451      * the direction of positive infinity.  This method is
2452      * semantically equivalent to {@code nextAfter(f,
2453      * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}
2454      * implementation may run faster than its equivalent
2455      * {@code nextAfter} call.
2456      *
2457      * &lt;p&gt;Special Cases:
2458      * &lt;ul&gt;
2459      * &lt;li&gt; If the argument is NaN, the result is NaN.
2460      *
2461      * &lt;li&gt; If the argument is positive infinity, the result is
2462      * positive infinity.
2463      *
2464      * &lt;li&gt; If the argument is zero, the result is
2465      * {@link Float#MIN_VALUE}
2466      *
2467      * &lt;/ul&gt;
2468      *
2469      * @param f starting floating-point value
2470      * @return The adjacent floating-point value closer to positive
2471      * infinity.
2472      * @since 1.6
2473      */
2474     public static float nextUp(float f) {
2475         // Use a single conditional and handle the likely cases first.
2476         if (f &lt; Float.POSITIVE_INFINITY) {
2477             // Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0).
2478             final int transducer = Float.floatToRawIntBits(f + 0.0F);
2479             return Float.intBitsToFloat(transducer + ((transducer &gt;= 0) ? 1 : -1));
2480         } else { // f is NaN or +Infinity
2481             return f;
2482         }
2483     }
2484 
2485     /**
2486      * Returns the floating-point value adjacent to {@code d} in
2487      * the direction of negative infinity.  This method is
2488      * semantically equivalent to {@code nextAfter(d,
2489      * Double.NEGATIVE_INFINITY)}; however, a
2490      * {@code nextDown} implementation may run faster than its
2491      * equivalent {@code nextAfter} call.
2492      *
2493      * &lt;p&gt;Special Cases:
2494      * &lt;ul&gt;
2495      * &lt;li&gt; If the argument is NaN, the result is NaN.
2496      *
2497      * &lt;li&gt; If the argument is negative infinity, the result is
2498      * negative infinity.
2499      *
2500      * &lt;li&gt; If the argument is zero, the result is
2501      * {@code -Double.MIN_VALUE}
2502      *
2503      * &lt;/ul&gt;
2504      *
2505      * @param d  starting floating-point value
2506      * @return The adjacent floating-point value closer to negative
2507      * infinity.
2508      * @since 1.8
2509      */
2510     public static double nextDown(double d) {
2511         if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY)
2512             return d;
2513         else {
2514             if (d == 0.0)
2515                 return -Double.MIN_VALUE;
2516             else
2517                 return Double.longBitsToDouble(Double.doubleToRawLongBits(d) +
2518                                                ((d &gt; 0.0d)?-1L:+1L));
2519         }
2520     }
2521 
2522     /**
2523      * Returns the floating-point value adjacent to {@code f} in
2524      * the direction of negative infinity.  This method is
2525      * semantically equivalent to {@code nextAfter(f,
2526      * Float.NEGATIVE_INFINITY)}; however, a
2527      * {@code nextDown} implementation may run faster than its
2528      * equivalent {@code nextAfter} call.
2529      *
2530      * &lt;p&gt;Special Cases:
2531      * &lt;ul&gt;
2532      * &lt;li&gt; If the argument is NaN, the result is NaN.
2533      *
2534      * &lt;li&gt; If the argument is negative infinity, the result is
2535      * negative infinity.
2536      *
2537      * &lt;li&gt; If the argument is zero, the result is
2538      * {@code -Float.MIN_VALUE}
2539      *
2540      * &lt;/ul&gt;
2541      *
2542      * @param f  starting floating-point value
2543      * @return The adjacent floating-point value closer to negative
2544      * infinity.
2545      * @since 1.8
2546      */
2547     public static float nextDown(float f) {
2548         if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY)
2549             return f;
2550         else {
2551             if (f == 0.0f)
2552                 return -Float.MIN_VALUE;
2553             else
2554                 return Float.intBitsToFloat(Float.floatToRawIntBits(f) +
2555                                             ((f &gt; 0.0f)?-1:+1));
2556         }
2557     }
2558 
2559     /**
2560      * Returns {@code d} &amp;times;
2561      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2562      * by a single correctly rounded floating-point multiply to a
2563      * member of the double value set.  See the Java
2564      * Language Specification for a discussion of floating-point
2565      * value sets.  If the exponent of the result is between {@link
2566      * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the
2567      * answer is calculated exactly.  If the exponent of the result
2568      * would be larger than {@code Double.MAX_EXPONENT}, an
2569      * infinity is returned.  Note that if the result is subnormal,
2570      * precision may be lost; that is, when {@code scalb(x, n)}
2571      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2572      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2573      * sign as {@code d}.
2574      *
2575      * &lt;p&gt;Special cases:
2576      * &lt;ul&gt;
2577      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2578      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2579      * same sign is returned.
2580      * &lt;li&gt; If the first argument is zero, then a zero of the same
2581      * sign is returned.
2582      * &lt;/ul&gt;
2583      *
2584      * @param d number to be scaled by a power of two.
2585      * @param scaleFactor power of 2 used to scale {@code d}
2586      * @return {@code d} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2587      * @since 1.6
2588      */
2589     public static double scalb(double d, int scaleFactor) {
2590         /*
2591          * This method does not need to be declared strictfp to
2592          * compute the same correct result on all platforms.  When
2593          * scaling up, it does not matter what order the
2594          * multiply-store operations are done; the result will be
2595          * finite or overflow regardless of the operation ordering.
2596          * However, to get the correct result when scaling down, a
2597          * particular ordering must be used.
2598          *
2599          * When scaling down, the multiply-store operations are
2600          * sequenced so that it is not possible for two consecutive
2601          * multiply-stores to return subnormal results.  If one
2602          * multiply-store result is subnormal, the next multiply will
2603          * round it away to zero.  This is done by first multiplying
2604          * by 2 ^ (scaleFactor % n) and then multiplying several
2605          * times by 2^n as needed where n is the exponent of number
2606          * that is a covenient power of two.  In this way, at most one
2607          * real rounding error occurs.  If the double value set is
2608          * being used exclusively, the rounding will occur on a
2609          * multiply.  If the double-extended-exponent value set is
2610          * being used, the products will (perhaps) be exact but the
2611          * stores to d are guaranteed to round to the double value
2612          * set.
2613          *
2614          * It is _not_ a valid implementation to first multiply d by
2615          * 2^MIN_EXPONENT and then by 2 ^ (scaleFactor %
2616          * MIN_EXPONENT) since even in a strictfp program double
2617          * rounding on underflow could occur; e.g. if the scaleFactor
2618          * argument was (MIN_EXPONENT - n) and the exponent of d was a
2619          * little less than -(MIN_EXPONENT - n), meaning the final
2620          * result would be subnormal.
2621          *
2622          * Since exact reproducibility of this method can be achieved
2623          * without any undue performance burden, there is no
2624          * compelling reason to allow double rounding on underflow in
2625          * scalb.
2626          */
2627 
2628         // magnitude of a power of two so large that scaling a finite
2629         // nonzero value by it would be guaranteed to over or
2630         // underflow; due to rounding, scaling down takes an
2631         // additional power of two which is reflected here
2632         final int MAX_SCALE = Double.MAX_EXPONENT + -Double.MIN_EXPONENT +
2633                               DoubleConsts.SIGNIFICAND_WIDTH + 1;
2634         int exp_adjust = 0;
2635         int scale_increment = 0;
2636         double exp_delta = Double.NaN;
2637 
2638         // Make sure scaling factor is in a reasonable range
2639 
2640         if(scaleFactor &lt; 0) {
2641             scaleFactor = Math.max(scaleFactor, -MAX_SCALE);
2642             scale_increment = -512;
2643             exp_delta = twoToTheDoubleScaleDown;
2644         }
2645         else {
2646             scaleFactor = Math.min(scaleFactor, MAX_SCALE);
2647             scale_increment = 512;
2648             exp_delta = twoToTheDoubleScaleUp;
2649         }
2650 
2651         // Calculate (scaleFactor % +/-512), 512 = 2^9, using
2652         // technique from &quot;Hacker&#39;s Delight&quot; section 10-2.
2653         int t = (scaleFactor &gt;&gt; 9-1) &gt;&gt;&gt; 32 - 9;
2654         exp_adjust = ((scaleFactor + t) &amp; (512 -1)) - t;
2655 
2656         d *= powerOfTwoD(exp_adjust);
2657         scaleFactor -= exp_adjust;
2658 
2659         while(scaleFactor != 0) {
2660             d *= exp_delta;
2661             scaleFactor -= scale_increment;
2662         }
2663         return d;
2664     }
2665 
2666     /**
2667      * Returns {@code f} &amp;times;
2668      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2669      * by a single correctly rounded floating-point multiply to a
2670      * member of the float value set.  See the Java
2671      * Language Specification for a discussion of floating-point
2672      * value sets.  If the exponent of the result is between {@link
2673      * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the
2674      * answer is calculated exactly.  If the exponent of the result
2675      * would be larger than {@code Float.MAX_EXPONENT}, an
2676      * infinity is returned.  Note that if the result is subnormal,
2677      * precision may be lost; that is, when {@code scalb(x, n)}
2678      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2679      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2680      * sign as {@code f}.
2681      *
2682      * &lt;p&gt;Special cases:
2683      * &lt;ul&gt;
2684      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2685      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2686      * same sign is returned.
2687      * &lt;li&gt; If the first argument is zero, then a zero of the same
2688      * sign is returned.
2689      * &lt;/ul&gt;
2690      *
2691      * @param f number to be scaled by a power of two.
2692      * @param scaleFactor power of 2 used to scale {@code f}
2693      * @return {@code f} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2694      * @since 1.6
2695      */
2696     public static float scalb(float f, int scaleFactor) {
2697         // magnitude of a power of two so large that scaling a finite
2698         // nonzero value by it would be guaranteed to over or
2699         // underflow; due to rounding, scaling down takes an
2700         // additional power of two which is reflected here
2701         final int MAX_SCALE = Float.MAX_EXPONENT + -Float.MIN_EXPONENT +
2702                               FloatConsts.SIGNIFICAND_WIDTH + 1;
2703 
2704         // Make sure scaling factor is in a reasonable range
2705         scaleFactor = Math.max(Math.min(scaleFactor, MAX_SCALE), -MAX_SCALE);
2706 
2707         /*
2708          * Since + MAX_SCALE for float fits well within the double
2709          * exponent range and + float -&gt; double conversion is exact
2710          * the multiplication below will be exact. Therefore, the
2711          * rounding that occurs when the double product is cast to
2712          * float will be the correctly rounded float result.  Since
2713          * all operations other than the final multiply will be exact,
2714          * it is not necessary to declare this method strictfp.
2715          */
2716         return (float)((double)f*powerOfTwoD(scaleFactor));
2717     }
2718 
2719     // Constants used in scalb
2720     static double twoToTheDoubleScaleUp = powerOfTwoD(512);
2721     static double twoToTheDoubleScaleDown = powerOfTwoD(-512);
2722 
2723     /**
2724      * Returns a floating-point power of two in the normal range.
2725      */
2726     static double powerOfTwoD(int n) {
2727         assert(n &gt;= Double.MIN_EXPONENT &amp;&amp; n &lt;= Double.MAX_EXPONENT);
2728         return Double.longBitsToDouble((((long)n + (long)DoubleConsts.EXP_BIAS) &lt;&lt;
2729                                         (DoubleConsts.SIGNIFICAND_WIDTH-1))
2730                                        &amp; DoubleConsts.EXP_BIT_MASK);
2731     }
2732 
2733     /**
2734      * Returns a floating-point power of two in the normal range.
2735      */
2736     static float powerOfTwoF(int n) {
2737         assert(n &gt;= Float.MIN_EXPONENT &amp;&amp; n &lt;= Float.MAX_EXPONENT);
2738         return Float.intBitsToFloat(((n + FloatConsts.EXP_BIAS) &lt;&lt;
2739                                      (FloatConsts.SIGNIFICAND_WIDTH-1))
2740                                     &amp; FloatConsts.EXP_BIT_MASK);
2741     }
2742 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CharacterName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassCastException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;

  49 import java.lang.reflect.Type;
  50 import java.lang.reflect.TypeVariable;
  51 import java.lang.constant.Constable;
  52 import java.net.URL;
  53 import java.security.AccessController;
  54 import java.security.PrivilegedAction;
  55 import java.util.ArrayList;
  56 import java.util.Arrays;
  57 import java.util.Collection;
  58 import java.util.HashMap;
  59 import java.util.LinkedHashMap;
  60 import java.util.LinkedHashSet;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Objects;
  64 import java.util.Optional;
  65 import java.util.StringJoiner;
  66 import java.util.stream.Stream;
  67 import java.util.stream.Collectors;
  68 
</pre>
<hr />
<pre>
  71 import jdk.internal.loader.BuiltinClassLoader;
  72 import jdk.internal.misc.Unsafe;
  73 import jdk.internal.module.Resources;
  74 import jdk.internal.reflect.CallerSensitive;
  75 import jdk.internal.reflect.ConstantPool;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.reflect.ReflectionFactory;
  78 import jdk.internal.vm.annotation.ForceInline;
  79 import sun.invoke.util.Wrapper;
  80 import sun.reflect.generics.factory.CoreReflectionFactory;
  81 import sun.reflect.generics.factory.GenericsFactory;
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
<span class="line-modified">  91  * Instances of the class {@code Class} represent classes and interfaces</span>
<span class="line-modified">  92  * in a running Java application. An enum type is a kind of class and an</span>
<span class="line-modified">  93  * annotation type is a kind of interface. Every array also</span>
<span class="line-modified">  94  * belongs to a class that is reflected as a {@code Class} object</span>
<span class="line-modified">  95  * that is shared by all arrays with the same element type and number</span>
<span class="line-modified">  96  * of dimensions.  The primitive Java types ({@code boolean},</span>
<span class="line-modified">  97  * {@code byte}, {@code char}, {@code short},</span>
<span class="line-modified">  98  * {@code int}, {@code long}, {@code float}, and</span>
<span class="line-modified">  99  * {@code double}), and the keyword {@code void} are also</span>
<span class="line-removed"> 100  * represented as {@code Class} objects.</span>
 101  *
 102  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 103  * object is constructed automatically by the Java Virtual Machine
 104  * when a class loader invokes one of the
 105  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
 106  * and passes the bytes of a {@code class} file.
 107  *
 108  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 109  * class or interface. Most characteristics are derived from the {@code class}
 110  * file that the class loader passed to the Java Virtual Machine. A few
 111  * characteristics are determined by the class loading environment at run time,
 112  * such as the module returned by {@link #getModule() getModule()}.
 113  *
 114  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 115  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 116  * another declaration. Other methods describe how a class or interface
 117  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 118  * classes and interfaces, in the same run-time package, that
 119  * allow mutual access to their {@code private} members.
 120  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
</pre>
<hr />
<pre>
 189      * fully qualified name of the class in the format returned by
 190      * {@code getName}.  If this {@code Class} object represents a
 191      * primitive type, this method returns the name of the primitive type.  If
 192      * this {@code Class} object represents void this method returns
 193      * &quot;void&quot;. If this {@code Class} object represents an array type,
 194      * this method returns &quot;class &quot; followed by {@code getName}.
 195      *
 196      * @return a string representation of this class object.
 197      */
 198     public String toString() {
 199         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200             + getName();
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
<span class="line-modified"> 209      * and {@code class}, {@code enum}, {@code interface}, or</span>
<span class="line-modified"> 210      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, as appropriate), followed</span>
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
 231      * @return a string describing this {@code Class}, including
 232      * information about modifiers and type parameters
 233      *
 234      * @since 1.8
 235      */

 236     public String toGenericString() {
 237         if (isPrimitive()) {
 238             return toString();
 239         } else {
 240             StringBuilder sb = new StringBuilder();
 241             Class&lt;?&gt; component = this;
 242             int arrayDepth = 0;
 243 
 244             if (isArray()) {
 245                 do {
 246                     arrayDepth++;
 247                     component = component.getComponentType();
 248                 } while (component.isArray());
 249                 sb.append(component.getName());
 250             } else {
 251                 // Class modifiers are a superset of interface modifiers
 252                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 253                 if (modifiers != 0) {
 254                     sb.append(Modifier.toString(modifiers));
 255                     sb.append(&#39; &#39;);
 256                 }
 257 
 258                 if (isAnnotation()) {
 259                     sb.append(&#39;@&#39;);
 260                 }
 261                 if (isInterface()) { // Note: all annotation types are interfaces
 262                     sb.append(&quot;interface&quot;);
 263                 } else {
 264                     if (isEnum())
 265                         sb.append(&quot;enum&quot;);


 266                     else
 267                         sb.append(&quot;class&quot;);
 268                 }
 269                 sb.append(&#39; &#39;);
 270                 sb.append(getName());
 271             }
 272 
 273             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 274             if (typeparms.length &gt; 0) {
 275                 sb.append(Arrays.stream(typeparms)
 276                           .map(Class::typeVarBounds)
 277                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 278             }
 279 
<span class="line-modified"> 280             for (int i = 0; i &lt; arrayDepth; i++)</span>
<span class="line-removed"> 281                 sb.append(&quot;[]&quot;);</span>
 282 
 283             return sb.toString();
 284         }
 285     }
 286 
 287     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 288         Type[] bounds = typeVar.getBounds();
 289         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 290             return typeVar.getName();
 291         } else {
 292             return typeVar.getName() + &quot; extends &quot; +
 293                 Arrays.stream(bounds)
 294                 .map(Type::getTypeName)
 295                 .collect(Collectors.joining(&quot; &amp; &quot;));
 296         }
 297     }
 298 
 299     /**
 300      * Returns the {@code Class} object associated with the class or
 301      * interface with the given string name.  Invoking this method is
</pre>
<hr />
<pre>
 305      *  {@code Class.forName(className, true, currentLoader)}
 306      * &lt;/blockquote&gt;
 307      *
 308      * where {@code currentLoader} denotes the defining class loader of
 309      * the current class.
 310      *
 311      * &lt;p&gt; For example, the following code fragment returns the
 312      * runtime {@code Class} descriptor for the class named
 313      * {@code java.lang.Thread}:
 314      *
 315      * &lt;blockquote&gt;
 316      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 317      * &lt;/blockquote&gt;
 318      * &lt;p&gt;
 319      * A call to {@code forName(&quot;X&quot;)} causes the class named
 320      * {@code X} to be initialized.
 321      *
 322      * @param      className   the fully qualified name of the desired class.
 323      * @return     the {@code Class} object for the class with the
 324      *             specified name.
<span class="line-modified"> 325      * @exception LinkageError if the linkage fails</span>
<span class="line-modified"> 326      * @exception ExceptionInInitializerError if the initialization provoked</span>
 327      *            by this method fails
<span class="line-modified"> 328      * @exception ClassNotFoundException if the class cannot be located</span>




 329      */
 330     @CallerSensitive
 331     public static Class&lt;?&gt; forName(String className)
 332                 throws ClassNotFoundException {
 333         Class&lt;?&gt; caller = Reflection.getCallerClass();
 334         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 335     }
 336 
 337 
 338     /**
 339      * Returns the {@code Class} object associated with the class or
 340      * interface with the given string name, using the given class loader.
 341      * Given the fully qualified name for a class or interface (in the same
 342      * format returned by {@code getName}) this method attempts to
<span class="line-modified"> 343      * locate, load, and link the class or interface.  The specified class</span>
 344      * loader is used to load the class or interface.  If the parameter
 345      * {@code loader} is null, the class is loaded through the bootstrap
 346      * class loader.  The class is initialized only if the
 347      * {@code initialize} parameter is {@code true} and if it has
 348      * not been initialized earlier.
 349      *
 350      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 351      * will be made to locate a user-defined class in the unnamed package whose
 352      * name is {@code name}. Therefore, this method cannot be used to
 353      * obtain any of the {@code Class} objects representing primitive
 354      * types or void.
 355      *
 356      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 357      * the array class is loaded but not initialized.
 358      *
 359      * &lt;p&gt; For example, in an instance method the expression:
 360      *
 361      * &lt;blockquote&gt;
 362      *  {@code Class.forName(&quot;Foo&quot;)}
 363      * &lt;/blockquote&gt;
 364      *
 365      * is equivalent to:
 366      *
 367      * &lt;blockquote&gt;
 368      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 369      * &lt;/blockquote&gt;
 370      *
<span class="line-modified"> 371      * Note that this method throws errors related to loading, linking or</span>
<span class="line-modified"> 372      * initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The</span>
<span class="line-modified"> 373      * Java Language Specification&lt;/em&gt;.</span>

 374      * Note that this method does not check whether the requested class
 375      * is accessible to its caller.
 376      *
 377      * @param name       fully qualified name of the desired class
<span class="line-modified"> 378      * @param initialize if {@code true} the class will be initialized.</span>
<span class="line-modified"> 379      *                   See Section 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>
 380      * @param loader     class loader from which the class must be loaded
 381      * @return           class object representing the desired class
 382      *
<span class="line-modified"> 383      * @exception LinkageError if the linkage fails</span>
<span class="line-modified"> 384      * @exception ExceptionInInitializerError if the initialization provoked</span>
 385      *            by this method fails
<span class="line-modified"> 386      * @exception ClassNotFoundException if the class cannot be located by</span>
 387      *            the specified class loader
<span class="line-modified"> 388      * @exception SecurityException</span>
 389      *            if a security manager is present, and the {@code loader} is
 390      *            {@code null}, and the caller&#39;s class loader is not
 391      *            {@code null}, and the caller does not have the
 392      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 393      *
 394      * @see       java.lang.Class#forName(String)
 395      * @see       java.lang.ClassLoader




 396      * @since     1.2
 397      */
 398     @CallerSensitive
 399     public static Class&lt;?&gt; forName(String name, boolean initialize,
 400                                    ClassLoader loader)
 401         throws ClassNotFoundException
 402     {
 403         Class&lt;?&gt; caller = null;
 404         SecurityManager sm = System.getSecurityManager();
 405         if (sm != null) {
 406             // Reflective call to get caller class is only needed if a security manager
 407             // is present.  Avoid the overhead of making this call otherwise.
 408             caller = Reflection.getCallerClass();
 409             if (loader == null) {
 410                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 411                 if (ccl != null) {
 412                     sm.checkPermission(
 413                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 414                 }
 415             }
 416         }
 417         return forName0(name, initialize, loader, caller);
 418     }
 419 
 420     /** Called after security check for system loader access checks have been made. */
 421     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 422                                             ClassLoader loader,
 423                                             Class&lt;?&gt; caller)
 424         throws ClassNotFoundException;
 425 
 426 
 427     /**
 428      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 429      * binary name&lt;/a&gt; in the given module.
 430      *
<span class="line-modified"> 431      * &lt;p&gt; This method attempts to locate, load, and link the class or interface.</span>
<span class="line-modified"> 432      * It does not run the class initializer.  If the class is not found, this</span>
<span class="line-modified"> 433      * method returns {@code null}. &lt;/p&gt;</span>
 434      *
 435      * &lt;p&gt; If the class loader of the given module defines other modules and
 436      * the given name is a class defined in a different module, this method
 437      * returns {@code null} after the class is loaded. &lt;/p&gt;
 438      *
 439      * &lt;p&gt; This method does not check whether the requested class is
 440      * accessible to its caller. &lt;/p&gt;
 441      *
 442      * @apiNote
 443      * This method returns {@code null} on failure rather than
 444      * throwing a {@link ClassNotFoundException}, as is done by
 445      * the {@link #forName(String, boolean, ClassLoader)} method.
 446      * The security check is a stack-based permission check if the caller
 447      * loads a class in another module.
 448      *
 449      * @param  module   A module
 450      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 451      *                  of the class
 452      * @return {@code Class} object of the given name defined in the given module;
 453      *         {@code null} if not found.
 454      *
 455      * @throws NullPointerException if the given module or name is {@code null}
 456      *
 457      * @throws LinkageError if the linkage fails
 458      *
 459      * @throws SecurityException
 460      *         &lt;ul&gt;
 461      *         &lt;li&gt; if the caller is not the specified module and
 462      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 463      *         &lt;li&gt; access to the module content is denied. For example,
 464      *         permission check will be performed when a class loader calls
 465      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 466      *         in a module.&lt;/li&gt;
 467      *         &lt;/ul&gt;
 468      *


 469      * @since 9
 470      * @spec JPMS
 471      */
 472     @CallerSensitive
 473     public static Class&lt;?&gt; forName(Module module, String name) {
 474         Objects.requireNonNull(module);
 475         Objects.requireNonNull(name);
 476 
 477         ClassLoader cl;
 478         SecurityManager sm = System.getSecurityManager();
 479         if (sm != null) {
 480             Class&lt;?&gt; caller = Reflection.getCallerClass();
 481             if (caller != null &amp;&amp; caller.getModule() != module) {
 482                 // if caller is null, Class.forName is the last java frame on the stack.
 483                 // java.base has all permissions
 484                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 485             }
 486             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 487             cl = AccessController.doPrivileged(pa);
 488         } else {
</pre>
<hr />
<pre>
 631      */
 632     @HotSpotIntrinsicCandidate
 633     public native boolean isInstance(Object obj);
 634 
 635 
 636     /**
 637      * Determines if the class or interface represented by this
 638      * {@code Class} object is either the same as, or is a superclass or
 639      * superinterface of, the class or interface represented by the specified
 640      * {@code Class} parameter. It returns {@code true} if so;
 641      * otherwise it returns {@code false}. If this {@code Class}
 642      * object represents a primitive type, this method returns
 643      * {@code true} if the specified {@code Class} parameter is
 644      * exactly this {@code Class} object; otherwise it returns
 645      * {@code false}.
 646      *
 647      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 648      * specified {@code Class} parameter can be converted to the type
 649      * represented by this {@code Class} object via an identity conversion
 650      * or via a widening reference conversion. See &lt;em&gt;The Java Language
<span class="line-modified"> 651      * Specification&lt;/em&gt;, sections 5.1.1 and 5.1.4 , for details.</span>

 652      *
<span class="line-modified"> 653      * @param cls the {@code Class} object to be checked</span>
<span class="line-modified"> 654      * @return the {@code boolean} value indicating whether objects of the</span>
<span class="line-modified"> 655      * type {@code cls} can be assigned to objects of this class</span>
<span class="line-modified"> 656      * @exception NullPointerException if the specified Class parameter is</span>
 657      *            null.
<span class="line-modified"> 658      * @since 1.1</span>
 659      */
 660     @HotSpotIntrinsicCandidate
 661     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 662 
 663 
 664     /**
 665      * Determines if the specified {@code Class} object represents an
 666      * interface type.
 667      *
 668      * @return  {@code true} if this object represents an interface;
 669      *          {@code false} otherwise.
 670      */
 671     @HotSpotIntrinsicCandidate
 672     public native boolean isInterface();
 673 
 674 
 675     /**
 676      * Determines if this {@code Class} object represents an array class.
 677      *
 678      * @return  {@code true} if this object represents an array class;
</pre>
<hr />
<pre>
 901      * entity (class, interface, primitive type or void) represented by
 902      * this {@code Class}.  If this {@code Class} represents either the
 903      * {@code Object} class, an interface, a primitive type, or void, then
 904      * null is returned.  If this object represents an array class then the
 905      * {@code Class} object representing the {@code Object} class is
 906      * returned.
 907      *
 908      * @return the direct superclass of the class represented by this object
 909      */
 910     @HotSpotIntrinsicCandidate
 911     public native Class&lt;? super T&gt; getSuperclass();
 912 
 913 
 914     /**
 915      * Returns the {@code Type} representing the direct superclass of
 916      * the entity (class, interface, primitive type or void) represented by
 917      * this {@code Class}.
 918      *
 919      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 920      * object returned must accurately reflect the actual type
<span class="line-modified"> 921      * parameters used in the source code. The parameterized type</span>
 922      * representing the superclass is created if it had not been
 923      * created before. See the declaration of {@link
 924      * java.lang.reflect.ParameterizedType ParameterizedType} for the
 925      * semantics of the creation process for parameterized types.  If
 926      * this {@code Class} represents either the {@code Object}
 927      * class, an interface, a primitive type, or void, then null is
 928      * returned.  If this object represents an array class then the
 929      * {@code Class} object representing the {@code Object} class is
 930      * returned.
 931      *
 932      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 933      *     class signature does not conform to the format specified in
 934      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 935      * @throws TypeNotPresentException if the generic superclass
 936      *     refers to a non-existent type declaration
 937      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
 938      *     generic superclass refers to a parameterized type that cannot be
 939      *     instantiated  for any reason
 940      * @return the direct superclass of the class represented by this object
 941      * @since 1.5
</pre>
<hr />
<pre>
 983      * empty string if the class is in an unnamed package.
 984      *
 985      * &lt;p&gt; If this class is a member class, then this method is equivalent to
 986      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
 987      * enclosing class}.
 988      *
 989      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
 990      * #isAnonymousClass() anonymous class}, then this method is equivalent to
 991      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
 992      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
 993      * {@linkplain #getEnclosingConstructor enclosing constructor}.
 994      *
 995      * &lt;p&gt; If this class represents an array type then this method returns the
 996      * package name of the element type. If this class represents a primitive
 997      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
 998      *
 999      * @return the fully qualified package name
1000      *
1001      * @since 9
1002      * @spec JPMS
<span class="line-modified">1003      * @jls 6.7  Fully Qualified Names</span>
1004      */
1005     public String getPackageName() {
1006         String pn = this.packageName;
1007         if (pn == null) {
1008             Class&lt;?&gt; c = this;
1009             while (c.isArray()) {
1010                 c = c.getComponentType();
1011             }
1012             if (c.isPrimitive()) {
1013                 pn = &quot;java.lang&quot;;
1014             } else {
1015                 String cn = c.getName();
1016                 int dot = cn.lastIndexOf(&#39;.&#39;);
1017                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1018             }
1019             this.packageName = pn;
1020         }
1021         return pn;
1022     }
1023 
</pre>
<hr />
<pre>
1081         } else {
1082             Class&lt;?&gt;[] interfaces = rd.interfaces;
1083             if (interfaces == null) {
1084                 interfaces = getInterfaces0();
1085                 rd.interfaces = interfaces;
1086             }
1087             // defensively copy if requested
1088             return cloneArray ? interfaces.clone() : interfaces;
1089         }
1090     }
1091 
1092     private native Class&lt;?&gt;[] getInterfaces0();
1093 
1094     /**
1095      * Returns the {@code Type}s representing the interfaces
1096      * directly implemented by the class or interface represented by
1097      * this object.
1098      *
1099      * &lt;p&gt;If a superinterface is a parameterized type, the
1100      * {@code Type} object returned for it must accurately reflect
<span class="line-modified">1101      * the actual type parameters used in the source code. The</span>
1102      * parameterized type representing each superinterface is created
1103      * if it had not been created before. See the declaration of
1104      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1105      * for the semantics of the creation process for parameterized
1106      * types.
1107      *
1108      * &lt;p&gt;If this object represents a class, the return value is an array
1109      * containing objects representing all interfaces directly implemented by
1110      * the class.  The order of the interface objects in the array corresponds
1111      * to the order of the interface names in the {@code implements} clause of
1112      * the declaration of the class represented by this object.
1113      *
1114      * &lt;p&gt;If this object represents an interface, the array contains objects
1115      * representing all interfaces directly extended by the interface.  The
1116      * order of the interface objects in the array corresponds to the order of
1117      * the interface names in the {@code extends} clause of the declaration of
1118      * the interface represented by this object.
1119      *
1120      * &lt;p&gt;If this object represents a class or interface that implements no
1121      * interfaces, the method returns an array of length 0.
</pre>
<hr />
<pre>
1478         final Class&lt;?&gt; candidate = getDeclaringClass0();
1479 
1480         if (candidate != null) {
1481             SecurityManager sm = System.getSecurityManager();
1482             if (sm != null) {
1483                 candidate.checkPackageAccess(sm,
1484                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1485             }
1486         }
1487         return candidate;
1488     }
1489 
1490     private native Class&lt;?&gt; getDeclaringClass0();
1491 
1492 
1493     /**
1494      * Returns the immediately enclosing class of the underlying
1495      * class.  If the underlying class is a top level class this
1496      * method returns {@code null}.
1497      * @return the immediately enclosing class of the underlying class
<span class="line-modified">1498      * @exception  SecurityException</span>
1499      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1500      *             class loader is not the same as or an ancestor of the class
1501      *             loader for the enclosing class and invocation of {@link
1502      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1503      *             denies access to the package of the enclosing class
1504      * @since 1.5
1505      */
1506     @CallerSensitive
1507     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1508         // There are five kinds of classes (or interfaces):
1509         // a) Top level classes
1510         // b) Nested classes (static member classes)
1511         // c) Inner classes (non-static member classes)
1512         // d) Local classes (named classes declared within a method)
1513         // e) Anonymous classes
1514 
1515 
1516         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1517         // attribute if and only if it is a local class or an
1518         // anonymous class.
</pre>
<hr />
<pre>
1572             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1573         }
1574         return simpleName;
1575     }
1576 
1577     /**
1578      * Return an informative string for the name of this type.
1579      *
1580      * @return an informative string for the name of this type
1581      * @since 1.8
1582      */
1583     public String getTypeName() {
1584         if (isArray()) {
1585             try {
1586                 Class&lt;?&gt; cl = this;
1587                 int dimensions = 0;
1588                 do {
1589                     dimensions++;
1590                     cl = cl.getComponentType();
1591                 } while (cl.isArray());
<span class="line-modified">1592                 StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">1593                 sb.append(cl.getName());</span>
<span class="line-removed">1594                 for (int i = 0; i &lt; dimensions; i++) {</span>
<span class="line-removed">1595                     sb.append(&quot;[]&quot;);</span>
<span class="line-removed">1596                 }</span>
<span class="line-removed">1597                 return sb.toString();</span>
1598             } catch (Throwable e) { /*FALLTHRU*/ }
1599         }
1600         return getName();
1601     }
1602 
1603     /**
1604      * Returns the canonical name of the underlying class as
1605      * defined by the Java Language Specification.  Returns null if
1606      * the underlying class does not have a canonical name (i.e., if
1607      * it is a local or anonymous class or an array whose component
1608      * type does not have a canonical name).
1609      * @return the canonical name of the underlying class if it exists, and
1610      * {@code null} otherwise.
1611      * @since 1.5
1612      */
1613     public String getCanonicalName() {
1614         ReflectionData&lt;T&gt; rd = reflectionData();
1615         String canonicalName = rd.canonicalName;
1616         if (canonicalName == null) {
1617             rd.canonicalName = canonicalName = getCanonicalName0();
</pre>
<hr />
<pre>
2238      *          ancestor of the class loader for the current class and
2239      *          invocation of {@link SecurityManager#checkPackageAccess
2240      *          s.checkPackageAccess()} denies access to the package
2241      *          of this class
2242      *
2243      *          &lt;/ul&gt;
2244      *
2245      * @since 1.1
2246      * @jls 8.2 Class Members
2247      * @jls 8.3 Field Declarations
2248      */
2249     @CallerSensitive
2250     public Field[] getDeclaredFields() throws SecurityException {
2251         SecurityManager sm = System.getSecurityManager();
2252         if (sm != null) {
2253             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2254         }
2255         return copyFields(privateGetDeclaredFields(false));
2256     }
2257 
































































2258 
2259     /**
2260      * Returns an array containing {@code Method} objects reflecting all the
2261      * declared methods of the class or interface represented by this {@code
2262      * Class} object, including public, protected, default (package)
2263      * access, and private methods, but excluding inherited methods.
2264      *
2265      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2266      * declared methods with the same name and parameter types, but different
2267      * return types, then the returned array has a {@code Method} object for
2268      * each such method.
2269      *
2270      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2271      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2272      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2273      *
2274      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2275      * declared methods, then the returned array has length 0.
2276      *
2277      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
</pre>
<hr />
<pre>
2311     public Method[] getDeclaredMethods() throws SecurityException {
2312         SecurityManager sm = System.getSecurityManager();
2313         if (sm != null) {
2314             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2315         }
2316         return copyMethods(privateGetDeclaredMethods(false));
2317     }
2318 
2319 
2320     /**
2321      * Returns an array of {@code Constructor} objects reflecting all the
2322      * constructors declared by the class represented by this
2323      * {@code Class} object. These are public, protected, default
2324      * (package) access, and private constructors.  The elements in the array
2325      * returned are not sorted and are not in any particular order.  If the
2326      * class has a default constructor, it is included in the returned array.
2327      * This method returns an array of length 0 if this {@code Class}
2328      * object represents an interface, a primitive type, an array class, or
2329      * void.
2330      *
<span class="line-modified">2331      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.</span>
2332      *
2333      * @return  the array of {@code Constructor} objects representing all the
2334      *          declared constructors of this class
2335      * @throws  SecurityException
2336      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2337      *          following conditions is met:
2338      *
2339      *          &lt;ul&gt;
2340      *
2341      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2342      *          class loader of this class and invocation of
2343      *          {@link SecurityManager#checkPermission
2344      *          s.checkPermission} method with
2345      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2346      *          denies access to the declared constructors within this class
2347      *
2348      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2349      *          ancestor of the class loader for the current class and
2350      *          invocation of {@link SecurityManager#checkPackageAccess
2351      *          s.checkPackageAccess()} denies access to the package
</pre>
<hr />
<pre>
3396         ReflectionFactory fact = getReflectionFactory();
3397         for (int i = 0; i &lt; arg.length; i++) {
3398             out[i] = fact.copyMethod(arg[i]);
3399         }
3400         return out;
3401     }
3402 
3403     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3404         Constructor&lt;U&gt;[] out = arg.clone();
3405         ReflectionFactory fact = getReflectionFactory();
3406         for (int i = 0; i &lt; out.length; i++) {
3407             out[i] = fact.copyConstructor(out[i]);
3408         }
3409         return out;
3410     }
3411 
3412     private native Field[]       getDeclaredFields0(boolean publicOnly);
3413     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3414     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3415     private native Class&lt;?&gt;[]   getDeclaredClasses0();



3416 
3417     /**
3418      * Helper method to get the method name from arguments.
3419      */
3420     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
<span class="line-modified">3421         StringBuilder sb = new StringBuilder();</span>
<span class="line-modified">3422         sb.append(getName() + &quot;.&quot; + name + &quot;(&quot;);</span>
<span class="line-modified">3423         if (argTypes != null) {</span>
<span class="line-modified">3424             sb.append(Arrays.stream(argTypes)</span>
<span class="line-modified">3425                       .map(c -&gt; (c == null) ? &quot;null&quot; : c.getName())</span>
<span class="line-modified">3426                       .collect(Collectors.joining(&quot;,&quot;)));</span>
<span class="line-removed">3427         }</span>
<span class="line-removed">3428         sb.append(&quot;)&quot;);</span>
<span class="line-removed">3429         return sb.toString();</span>
3430     }
3431 
3432     /** use serialVersionUID from JDK 1.1 for interoperability */

3433     private static final long serialVersionUID = 3206093459760846163L;
3434 
3435 
3436     /**
3437      * Class Class is special cased within the Serialization Stream Protocol.
3438      *
3439      * A Class instance is written initially into an ObjectOutputStream in the
3440      * following format:
3441      * &lt;pre&gt;
3442      *      {@code TC_CLASS} ClassDescriptor
3443      *      A ClassDescriptor is a special cased serialization of
3444      *      a {@code java.io.ObjectStreamClass} instance.
3445      * &lt;/pre&gt;
3446      * A new handle is generated for the initial time the class descriptor
3447      * is written into the stream. Future references to the class descriptor
3448      * are written as references to the initial class descriptor instance.
3449      *
3450      * @see java.io.ObjectStreamClass
3451      */

3452     private static final ObjectStreamField[] serialPersistentFields =
3453         new ObjectStreamField[0];
3454 
3455 
3456     /**
3457      * Returns the assertion status that would be assigned to this
3458      * class if it were to be initialized at the time this method is invoked.
3459      * If this class has had its assertion status set, the most recent
3460      * setting will be returned; otherwise, if any package default assertion
3461      * status pertains to this class, the most recent setting for the most
3462      * specific pertinent package default assertion status is returned;
3463      * otherwise, if this class is not a system class (i.e., it has a
3464      * class loader) its class loader&#39;s default assertion status is returned;
3465      * otherwise, the system class default assertion status is returned.
3466      * &lt;p&gt;
3467      * Few programmers will have any need for this method; it is provided
3468      * for the benefit of the JRE itself.  (It allows a class to determine at
3469      * the time that it is initialized whether assertions should be enabled.)
3470      * Note that this method is not guaranteed to return the actual
3471      * assertion status that was (or will be) associated with the specified
</pre>
<hr />
<pre>
3483         if (loader == null)
3484             return desiredAssertionStatus0(this);
3485 
3486         // If the classloader has been initialized with the assertion
3487         // directives, ask it. Otherwise, ask the VM.
3488         synchronized(loader.assertionLock) {
3489             if (loader.classAssertionStatus != null) {
3490                 return loader.desiredAssertionStatus(getName());
3491             }
3492         }
3493         return desiredAssertionStatus0(this);
3494     }
3495 
3496     // Retrieves the desired assertion status of this class from the VM
3497     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3498 
3499     /**
3500      * Returns true if and only if this class was declared as an enum in the
3501      * source code.
3502      *









3503      * @return true if and only if this class was declared as an enum in the
3504      *     source code
3505      * @since 1.5

3506      */
3507     public boolean isEnum() {
3508         // An enum must both directly extend java.lang.Enum and have
3509         // the ENUM bit set; classes for specialized enum constants
3510         // don&#39;t do the former.
3511         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3512         this.getSuperclass() == java.lang.Enum.class;
3513     }
3514 






































3515     // Fetches the factory for reflective objects
3516     private static ReflectionFactory getReflectionFactory() {
3517         if (reflectionFactory == null) {
3518             reflectionFactory =
3519                 java.security.AccessController.doPrivileged
3520                     (new ReflectionFactory.GetReflectionFactoryAction());
3521         }
3522         return reflectionFactory;
3523     }
3524     private static ReflectionFactory reflectionFactory;
3525 
3526     /**
3527      * Returns the elements of this enum class or null if this
3528      * Class object does not represent an enum type.
3529      *
3530      * @return an array containing the values comprising the enum class
3531      *     represented by this Class object in the order they&#39;re
3532      *     declared, or null if this Class object does not
3533      *     represent an enum type
3534      * @since 1.5
</pre>
<hr />
<pre>
3902      *
3903      * @apiNote A {@code class} file of version 55.0 or greater may record the
3904      * host of the nest to which it belongs by using the {@code NestHost}
3905      * attribute (JVMS 4.7.28). Alternatively, a {@code class} file of
3906      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
3907      * other members with the
3908      * {@code NestMembers} attribute (JVMS 4.7.29).
3909      * A {@code class} file of version 54.0 or lower does not use these
3910      * attributes.
3911      *
3912      * @return the nest host of this class or interface
3913      *
3914      * @throws SecurityException
3915      *         If the returned class is not the current class, and
3916      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
3917      *         class loader is not the same as or an ancestor of the class
3918      *         loader for the returned class and invocation of {@link
3919      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
3920      *         denies access to the package of the returned class
3921      * @since 11
<span class="line-modified">3922      * @jvms 4.7.28 and 4.7.29 NestHost and NestMembers attributes</span>

3923      * @jvms 5.4.4 Access Control
3924      */
3925     @CallerSensitive
3926     public Class&lt;?&gt; getNestHost() {
3927         if (isPrimitive() || isArray()) {
3928             return this;
3929         }
3930         Class&lt;?&gt; host;
3931         try {
3932             host = getNestHost0();
3933         } catch (LinkageError e) {
3934             // if we couldn&#39;t load our nest-host then we
3935             // act as-if we have no nest-host attribute
3936             return this;
3937         }
3938         // if null then nest membership validation failed, so we
3939         // act as-if we have no nest-host attribute
3940         if (host == null || host == this) {
3941             return this;
3942         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
<span class="line-added">  49 import java.lang.reflect.RecordComponent;</span>
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;
  66 import java.util.StringJoiner;
  67 import java.util.stream.Stream;
  68 import java.util.stream.Collectors;
  69 
</pre>
<hr />
<pre>
  72 import jdk.internal.loader.BuiltinClassLoader;
  73 import jdk.internal.misc.Unsafe;
  74 import jdk.internal.module.Resources;
  75 import jdk.internal.reflect.CallerSensitive;
  76 import jdk.internal.reflect.ConstantPool;
  77 import jdk.internal.reflect.Reflection;
  78 import jdk.internal.reflect.ReflectionFactory;
  79 import jdk.internal.vm.annotation.ForceInline;
  80 import sun.invoke.util.Wrapper;
  81 import sun.reflect.generics.factory.CoreReflectionFactory;
  82 import sun.reflect.generics.factory.GenericsFactory;
  83 import sun.reflect.generics.repository.ClassRepository;
  84 import sun.reflect.generics.repository.MethodRepository;
  85 import sun.reflect.generics.repository.ConstructorRepository;
  86 import sun.reflect.generics.scope.ClassScope;
  87 import sun.security.util.SecurityConstants;
  88 import sun.reflect.annotation.*;
  89 import sun.reflect.misc.ReflectUtil;
  90 
  91 /**
<span class="line-modified">  92  * Instances of the class {@code Class} represent classes and</span>
<span class="line-modified">  93  * interfaces in a running Java application. An enum type and a record</span>
<span class="line-modified">  94  * type are kinds of class; an annotation type is a kind of</span>
<span class="line-modified">  95  * interface. Every array also belongs to a class that is reflected as</span>
<span class="line-modified">  96  * a {@code Class} object that is shared by all arrays with the same</span>
<span class="line-modified">  97  * element type and number of dimensions.  The primitive Java types</span>
<span class="line-modified">  98  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code</span>
<span class="line-modified">  99  * int}, {@code long}, {@code float}, and {@code double}), and the</span>
<span class="line-modified"> 100  * keyword {@code void} are also represented as {@code Class} objects.</span>

 101  *
 102  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 103  * object is constructed automatically by the Java Virtual Machine
 104  * when a class loader invokes one of the
 105  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
 106  * and passes the bytes of a {@code class} file.
 107  *
 108  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 109  * class or interface. Most characteristics are derived from the {@code class}
 110  * file that the class loader passed to the Java Virtual Machine. A few
 111  * characteristics are determined by the class loading environment at run time,
 112  * such as the module returned by {@link #getModule() getModule()}.
 113  *
 114  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 115  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 116  * another declaration. Other methods describe how a class or interface
 117  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 118  * classes and interfaces, in the same run-time package, that
 119  * allow mutual access to their {@code private} members.
 120  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
</pre>
<hr />
<pre>
 189      * fully qualified name of the class in the format returned by
 190      * {@code getName}.  If this {@code Class} object represents a
 191      * primitive type, this method returns the name of the primitive type.  If
 192      * this {@code Class} object represents void this method returns
 193      * &quot;void&quot;. If this {@code Class} object represents an array type,
 194      * this method returns &quot;class &quot; followed by {@code getName}.
 195      *
 196      * @return a string representation of this class object.
 197      */
 198     public String toString() {
 199         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200             + getName();
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
<span class="line-modified"> 209      * and {@code class}, {@code enum}, {@code interface},</span>
<span class="line-modified"> 210      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed</span>
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
 231      * @return a string describing this {@code Class}, including
 232      * information about modifiers and type parameters
 233      *
 234      * @since 1.8
 235      */
<span class="line-added"> 236     @SuppressWarnings(&quot;preview&quot;)</span>
 237     public String toGenericString() {
 238         if (isPrimitive()) {
 239             return toString();
 240         } else {
 241             StringBuilder sb = new StringBuilder();
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }
 262                 if (isInterface()) { // Note: all annotation types are interfaces
 263                     sb.append(&quot;interface&quot;);
 264                 } else {
 265                     if (isEnum())
 266                         sb.append(&quot;enum&quot;);
<span class="line-added"> 267                     else if (isRecord())</span>
<span class="line-added"> 268                         sb.append(&quot;record&quot;);</span>
 269                     else
 270                         sb.append(&quot;class&quot;);
 271                 }
 272                 sb.append(&#39; &#39;);
 273                 sb.append(getName());
 274             }
 275 
 276             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 277             if (typeparms.length &gt; 0) {
 278                 sb.append(Arrays.stream(typeparms)
 279                           .map(Class::typeVarBounds)
 280                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 281             }
 282 
<span class="line-modified"> 283             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));</span>

 284 
 285             return sb.toString();
 286         }
 287     }
 288 
 289     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 290         Type[] bounds = typeVar.getBounds();
 291         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 292             return typeVar.getName();
 293         } else {
 294             return typeVar.getName() + &quot; extends &quot; +
 295                 Arrays.stream(bounds)
 296                 .map(Type::getTypeName)
 297                 .collect(Collectors.joining(&quot; &amp; &quot;));
 298         }
 299     }
 300 
 301     /**
 302      * Returns the {@code Class} object associated with the class or
 303      * interface with the given string name.  Invoking this method is
</pre>
<hr />
<pre>
 307      *  {@code Class.forName(className, true, currentLoader)}
 308      * &lt;/blockquote&gt;
 309      *
 310      * where {@code currentLoader} denotes the defining class loader of
 311      * the current class.
 312      *
 313      * &lt;p&gt; For example, the following code fragment returns the
 314      * runtime {@code Class} descriptor for the class named
 315      * {@code java.lang.Thread}:
 316      *
 317      * &lt;blockquote&gt;
 318      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 319      * &lt;/blockquote&gt;
 320      * &lt;p&gt;
 321      * A call to {@code forName(&quot;X&quot;)} causes the class named
 322      * {@code X} to be initialized.
 323      *
 324      * @param      className   the fully qualified name of the desired class.
 325      * @return     the {@code Class} object for the class with the
 326      *             specified name.
<span class="line-modified"> 327      * @throws    LinkageError if the linkage fails</span>
<span class="line-modified"> 328      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 329      *            by this method fails
<span class="line-modified"> 330      * @throws    ClassNotFoundException if the class cannot be located</span>
<span class="line-added"> 331      *</span>
<span class="line-added"> 332      * @jls 12.2 Loading of Classes and Interfaces</span>
<span class="line-added"> 333      * @jls 12.3 Linking of Classes and Interfaces</span>
<span class="line-added"> 334      * @jls 12.4 Initialization of Classes and Interfaces</span>
 335      */
 336     @CallerSensitive
 337     public static Class&lt;?&gt; forName(String className)
 338                 throws ClassNotFoundException {
 339         Class&lt;?&gt; caller = Reflection.getCallerClass();
 340         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 341     }
 342 
 343 
 344     /**
 345      * Returns the {@code Class} object associated with the class or
 346      * interface with the given string name, using the given class loader.
 347      * Given the fully qualified name for a class or interface (in the same
 348      * format returned by {@code getName}) this method attempts to
<span class="line-modified"> 349      * locate and load the class or interface.  The specified class</span>
 350      * loader is used to load the class or interface.  If the parameter
 351      * {@code loader} is null, the class is loaded through the bootstrap
 352      * class loader.  The class is initialized only if the
 353      * {@code initialize} parameter is {@code true} and if it has
 354      * not been initialized earlier.
 355      *
 356      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 357      * will be made to locate a user-defined class in the unnamed package whose
 358      * name is {@code name}. Therefore, this method cannot be used to
 359      * obtain any of the {@code Class} objects representing primitive
 360      * types or void.
 361      *
 362      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 363      * the array class is loaded but not initialized.
 364      *
 365      * &lt;p&gt; For example, in an instance method the expression:
 366      *
 367      * &lt;blockquote&gt;
 368      *  {@code Class.forName(&quot;Foo&quot;)}
 369      * &lt;/blockquote&gt;
 370      *
 371      * is equivalent to:
 372      *
 373      * &lt;blockquote&gt;
 374      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 375      * &lt;/blockquote&gt;
 376      *
<span class="line-modified"> 377      * Note that this method throws errors related to loading, linking</span>
<span class="line-modified"> 378      * or initializing as specified in Sections {@jls 12.2}, {@jls</span>
<span class="line-modified"> 379      * 12.3}, and {@jls 12.4} of &lt;em&gt;The Java Language</span>
<span class="line-added"> 380      * Specification&lt;/em&gt;.</span>
 381      * Note that this method does not check whether the requested class
 382      * is accessible to its caller.
 383      *
 384      * @param name       fully qualified name of the desired class
<span class="line-modified"> 385      * @param initialize if {@code true} the class will be initialized (which implies linking).</span>
<span class="line-modified"> 386      *                   See Section {@jls 12.4} of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>
 387      * @param loader     class loader from which the class must be loaded
 388      * @return           class object representing the desired class
 389      *
<span class="line-modified"> 390      * @throws    LinkageError if the linkage fails</span>
<span class="line-modified"> 391      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 392      *            by this method fails
<span class="line-modified"> 393      * @throws    ClassNotFoundException if the class cannot be located by</span>
 394      *            the specified class loader
<span class="line-modified"> 395      * @throws    SecurityException</span>
 396      *            if a security manager is present, and the {@code loader} is
 397      *            {@code null}, and the caller&#39;s class loader is not
 398      *            {@code null}, and the caller does not have the
 399      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 400      *
 401      * @see       java.lang.Class#forName(String)
 402      * @see       java.lang.ClassLoader
<span class="line-added"> 403      *</span>
<span class="line-added"> 404      * @jls 12.2 Loading of Classes and Interfaces</span>
<span class="line-added"> 405      * @jls 12.3 Linking of Classes and Interfaces</span>
<span class="line-added"> 406      * @jls 12.4 Initialization of Classes and Interfaces</span>
 407      * @since     1.2
 408      */
 409     @CallerSensitive
 410     public static Class&lt;?&gt; forName(String name, boolean initialize,
 411                                    ClassLoader loader)
 412         throws ClassNotFoundException
 413     {
 414         Class&lt;?&gt; caller = null;
 415         SecurityManager sm = System.getSecurityManager();
 416         if (sm != null) {
 417             // Reflective call to get caller class is only needed if a security manager
 418             // is present.  Avoid the overhead of making this call otherwise.
 419             caller = Reflection.getCallerClass();
 420             if (loader == null) {
 421                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 422                 if (ccl != null) {
 423                     sm.checkPermission(
 424                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 425                 }
 426             }
 427         }
 428         return forName0(name, initialize, loader, caller);
 429     }
 430 
 431     /** Called after security check for system loader access checks have been made. */
 432     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 433                                             ClassLoader loader,
 434                                             Class&lt;?&gt; caller)
 435         throws ClassNotFoundException;
 436 
 437 
 438     /**
 439      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 440      * binary name&lt;/a&gt; in the given module.
 441      *
<span class="line-modified"> 442      * &lt;p&gt; This method attempts to locate and load the class or interface.</span>
<span class="line-modified"> 443      * It does not link the class, and does not run the class initializer.</span>
<span class="line-modified"> 444      * If the class is not found, this method returns {@code null}. &lt;/p&gt;</span>
 445      *
 446      * &lt;p&gt; If the class loader of the given module defines other modules and
 447      * the given name is a class defined in a different module, this method
 448      * returns {@code null} after the class is loaded. &lt;/p&gt;
 449      *
 450      * &lt;p&gt; This method does not check whether the requested class is
 451      * accessible to its caller. &lt;/p&gt;
 452      *
 453      * @apiNote
 454      * This method returns {@code null} on failure rather than
 455      * throwing a {@link ClassNotFoundException}, as is done by
 456      * the {@link #forName(String, boolean, ClassLoader)} method.
 457      * The security check is a stack-based permission check if the caller
 458      * loads a class in another module.
 459      *
 460      * @param  module   A module
 461      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 462      *                  of the class
 463      * @return {@code Class} object of the given name defined in the given module;
 464      *         {@code null} if not found.
 465      *
 466      * @throws NullPointerException if the given module or name is {@code null}
 467      *
 468      * @throws LinkageError if the linkage fails
 469      *
 470      * @throws SecurityException
 471      *         &lt;ul&gt;
 472      *         &lt;li&gt; if the caller is not the specified module and
 473      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 474      *         &lt;li&gt; access to the module content is denied. For example,
 475      *         permission check will be performed when a class loader calls
 476      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 477      *         in a module.&lt;/li&gt;
 478      *         &lt;/ul&gt;
 479      *
<span class="line-added"> 480      * @jls 12.2 Loading of Classes and Interfaces</span>
<span class="line-added"> 481      * @jls 12.3 Linking of Classes and Interfaces</span>
 482      * @since 9
 483      * @spec JPMS
 484      */
 485     @CallerSensitive
 486     public static Class&lt;?&gt; forName(Module module, String name) {
 487         Objects.requireNonNull(module);
 488         Objects.requireNonNull(name);
 489 
 490         ClassLoader cl;
 491         SecurityManager sm = System.getSecurityManager();
 492         if (sm != null) {
 493             Class&lt;?&gt; caller = Reflection.getCallerClass();
 494             if (caller != null &amp;&amp; caller.getModule() != module) {
 495                 // if caller is null, Class.forName is the last java frame on the stack.
 496                 // java.base has all permissions
 497                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 498             }
 499             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 500             cl = AccessController.doPrivileged(pa);
 501         } else {
</pre>
<hr />
<pre>
 644      */
 645     @HotSpotIntrinsicCandidate
 646     public native boolean isInstance(Object obj);
 647 
 648 
 649     /**
 650      * Determines if the class or interface represented by this
 651      * {@code Class} object is either the same as, or is a superclass or
 652      * superinterface of, the class or interface represented by the specified
 653      * {@code Class} parameter. It returns {@code true} if so;
 654      * otherwise it returns {@code false}. If this {@code Class}
 655      * object represents a primitive type, this method returns
 656      * {@code true} if the specified {@code Class} parameter is
 657      * exactly this {@code Class} object; otherwise it returns
 658      * {@code false}.
 659      *
 660      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 661      * specified {@code Class} parameter can be converted to the type
 662      * represented by this {@code Class} object via an identity conversion
 663      * or via a widening reference conversion. See &lt;em&gt;The Java Language
<span class="line-modified"> 664      * Specification&lt;/em&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
<span class="line-added"> 665      * for details.</span>
 666      *
<span class="line-modified"> 667      * @param     cls the {@code Class} object to be checked</span>
<span class="line-modified"> 668      * @return    the {@code boolean} value indicating whether objects of the</span>
<span class="line-modified"> 669      *            type {@code cls} can be assigned to objects of this class</span>
<span class="line-modified"> 670      * @throws    NullPointerException if the specified Class parameter is</span>
 671      *            null.
<span class="line-modified"> 672      * @since     1.1</span>
 673      */
 674     @HotSpotIntrinsicCandidate
 675     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 676 
 677 
 678     /**
 679      * Determines if the specified {@code Class} object represents an
 680      * interface type.
 681      *
 682      * @return  {@code true} if this object represents an interface;
 683      *          {@code false} otherwise.
 684      */
 685     @HotSpotIntrinsicCandidate
 686     public native boolean isInterface();
 687 
 688 
 689     /**
 690      * Determines if this {@code Class} object represents an array class.
 691      *
 692      * @return  {@code true} if this object represents an array class;
</pre>
<hr />
<pre>
 915      * entity (class, interface, primitive type or void) represented by
 916      * this {@code Class}.  If this {@code Class} represents either the
 917      * {@code Object} class, an interface, a primitive type, or void, then
 918      * null is returned.  If this object represents an array class then the
 919      * {@code Class} object representing the {@code Object} class is
 920      * returned.
 921      *
 922      * @return the direct superclass of the class represented by this object
 923      */
 924     @HotSpotIntrinsicCandidate
 925     public native Class&lt;? super T&gt; getSuperclass();
 926 
 927 
 928     /**
 929      * Returns the {@code Type} representing the direct superclass of
 930      * the entity (class, interface, primitive type or void) represented by
 931      * this {@code Class}.
 932      *
 933      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 934      * object returned must accurately reflect the actual type
<span class="line-modified"> 935      * arguments used in the source code. The parameterized type</span>
 936      * representing the superclass is created if it had not been
 937      * created before. See the declaration of {@link
 938      * java.lang.reflect.ParameterizedType ParameterizedType} for the
 939      * semantics of the creation process for parameterized types.  If
 940      * this {@code Class} represents either the {@code Object}
 941      * class, an interface, a primitive type, or void, then null is
 942      * returned.  If this object represents an array class then the
 943      * {@code Class} object representing the {@code Object} class is
 944      * returned.
 945      *
 946      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 947      *     class signature does not conform to the format specified in
 948      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 949      * @throws TypeNotPresentException if the generic superclass
 950      *     refers to a non-existent type declaration
 951      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
 952      *     generic superclass refers to a parameterized type that cannot be
 953      *     instantiated  for any reason
 954      * @return the direct superclass of the class represented by this object
 955      * @since 1.5
</pre>
<hr />
<pre>
 997      * empty string if the class is in an unnamed package.
 998      *
 999      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1000      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1001      * enclosing class}.
1002      *
1003      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1004      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1005      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1006      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1007      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1008      *
1009      * &lt;p&gt; If this class represents an array type then this method returns the
1010      * package name of the element type. If this class represents a primitive
1011      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1012      *
1013      * @return the fully qualified package name
1014      *
1015      * @since 9
1016      * @spec JPMS
<span class="line-modified">1017      * @jls 6.7 Fully Qualified Names</span>
1018      */
1019     public String getPackageName() {
1020         String pn = this.packageName;
1021         if (pn == null) {
1022             Class&lt;?&gt; c = this;
1023             while (c.isArray()) {
1024                 c = c.getComponentType();
1025             }
1026             if (c.isPrimitive()) {
1027                 pn = &quot;java.lang&quot;;
1028             } else {
1029                 String cn = c.getName();
1030                 int dot = cn.lastIndexOf(&#39;.&#39;);
1031                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1032             }
1033             this.packageName = pn;
1034         }
1035         return pn;
1036     }
1037 
</pre>
<hr />
<pre>
1095         } else {
1096             Class&lt;?&gt;[] interfaces = rd.interfaces;
1097             if (interfaces == null) {
1098                 interfaces = getInterfaces0();
1099                 rd.interfaces = interfaces;
1100             }
1101             // defensively copy if requested
1102             return cloneArray ? interfaces.clone() : interfaces;
1103         }
1104     }
1105 
1106     private native Class&lt;?&gt;[] getInterfaces0();
1107 
1108     /**
1109      * Returns the {@code Type}s representing the interfaces
1110      * directly implemented by the class or interface represented by
1111      * this object.
1112      *
1113      * &lt;p&gt;If a superinterface is a parameterized type, the
1114      * {@code Type} object returned for it must accurately reflect
<span class="line-modified">1115      * the actual type arguments used in the source code. The</span>
1116      * parameterized type representing each superinterface is created
1117      * if it had not been created before. See the declaration of
1118      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1119      * for the semantics of the creation process for parameterized
1120      * types.
1121      *
1122      * &lt;p&gt;If this object represents a class, the return value is an array
1123      * containing objects representing all interfaces directly implemented by
1124      * the class.  The order of the interface objects in the array corresponds
1125      * to the order of the interface names in the {@code implements} clause of
1126      * the declaration of the class represented by this object.
1127      *
1128      * &lt;p&gt;If this object represents an interface, the array contains objects
1129      * representing all interfaces directly extended by the interface.  The
1130      * order of the interface objects in the array corresponds to the order of
1131      * the interface names in the {@code extends} clause of the declaration of
1132      * the interface represented by this object.
1133      *
1134      * &lt;p&gt;If this object represents a class or interface that implements no
1135      * interfaces, the method returns an array of length 0.
</pre>
<hr />
<pre>
1492         final Class&lt;?&gt; candidate = getDeclaringClass0();
1493 
1494         if (candidate != null) {
1495             SecurityManager sm = System.getSecurityManager();
1496             if (sm != null) {
1497                 candidate.checkPackageAccess(sm,
1498                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1499             }
1500         }
1501         return candidate;
1502     }
1503 
1504     private native Class&lt;?&gt; getDeclaringClass0();
1505 
1506 
1507     /**
1508      * Returns the immediately enclosing class of the underlying
1509      * class.  If the underlying class is a top level class this
1510      * method returns {@code null}.
1511      * @return the immediately enclosing class of the underlying class
<span class="line-modified">1512      * @throws     SecurityException</span>
1513      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1514      *             class loader is not the same as or an ancestor of the class
1515      *             loader for the enclosing class and invocation of {@link
1516      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1517      *             denies access to the package of the enclosing class
1518      * @since 1.5
1519      */
1520     @CallerSensitive
1521     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1522         // There are five kinds of classes (or interfaces):
1523         // a) Top level classes
1524         // b) Nested classes (static member classes)
1525         // c) Inner classes (non-static member classes)
1526         // d) Local classes (named classes declared within a method)
1527         // e) Anonymous classes
1528 
1529 
1530         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1531         // attribute if and only if it is a local class or an
1532         // anonymous class.
</pre>
<hr />
<pre>
1586             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1587         }
1588         return simpleName;
1589     }
1590 
1591     /**
1592      * Return an informative string for the name of this type.
1593      *
1594      * @return an informative string for the name of this type
1595      * @since 1.8
1596      */
1597     public String getTypeName() {
1598         if (isArray()) {
1599             try {
1600                 Class&lt;?&gt; cl = this;
1601                 int dimensions = 0;
1602                 do {
1603                     dimensions++;
1604                     cl = cl.getComponentType();
1605                 } while (cl.isArray());
<span class="line-modified">1606                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);</span>





1607             } catch (Throwable e) { /*FALLTHRU*/ }
1608         }
1609         return getName();
1610     }
1611 
1612     /**
1613      * Returns the canonical name of the underlying class as
1614      * defined by the Java Language Specification.  Returns null if
1615      * the underlying class does not have a canonical name (i.e., if
1616      * it is a local or anonymous class or an array whose component
1617      * type does not have a canonical name).
1618      * @return the canonical name of the underlying class if it exists, and
1619      * {@code null} otherwise.
1620      * @since 1.5
1621      */
1622     public String getCanonicalName() {
1623         ReflectionData&lt;T&gt; rd = reflectionData();
1624         String canonicalName = rd.canonicalName;
1625         if (canonicalName == null) {
1626             rd.canonicalName = canonicalName = getCanonicalName0();
</pre>
<hr />
<pre>
2247      *          ancestor of the class loader for the current class and
2248      *          invocation of {@link SecurityManager#checkPackageAccess
2249      *          s.checkPackageAccess()} denies access to the package
2250      *          of this class
2251      *
2252      *          &lt;/ul&gt;
2253      *
2254      * @since 1.1
2255      * @jls 8.2 Class Members
2256      * @jls 8.3 Field Declarations
2257      */
2258     @CallerSensitive
2259     public Field[] getDeclaredFields() throws SecurityException {
2260         SecurityManager sm = System.getSecurityManager();
2261         if (sm != null) {
2262             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2263         }
2264         return copyFields(privateGetDeclaredFields(false));
2265     }
2266 
<span class="line-added">2267     /**</span>
<span class="line-added">2268      * {@preview Associated with records, a preview feature of the Java language.</span>
<span class="line-added">2269      *</span>
<span class="line-added">2270      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview</span>
<span class="line-added">2271      *           feature of the Java language. Preview features</span>
<span class="line-added">2272      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">2273      *           features of the Java language.}</span>
<span class="line-added">2274      *</span>
<span class="line-added">2275      * Returns an array of {@code RecordComponent} objects representing all the</span>
<span class="line-added">2276      * record components of this record class, or {@code null} if this class is</span>
<span class="line-added">2277      * not a record class.</span>
<span class="line-added">2278      *</span>
<span class="line-added">2279      * &lt;p&gt; The components are returned in the same order that they are declared</span>
<span class="line-added">2280      * in the record header. The array is empty if this record class has no</span>
<span class="line-added">2281      * components. If the class is not a record class, that is {@link</span>
<span class="line-added">2282      * #isRecord()} returns {@code false}, then this method returns {@code null}.</span>
<span class="line-added">2283      * Conversely, if {@link #isRecord()} returns {@code true}, then this method</span>
<span class="line-added">2284      * returns a non-null value.</span>
<span class="line-added">2285      *</span>
<span class="line-added">2286      * @return  An array of {@code RecordComponent} objects representing all the</span>
<span class="line-added">2287      *          record components of this record class, or {@code null} if this</span>
<span class="line-added">2288      *          class is not a record class</span>
<span class="line-added">2289      * @throws  SecurityException</span>
<span class="line-added">2290      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the</span>
<span class="line-added">2291      *          following conditions is met:</span>
<span class="line-added">2292      *</span>
<span class="line-added">2293      *          &lt;ul&gt;</span>
<span class="line-added">2294      *</span>
<span class="line-added">2295      *          &lt;li&gt; the caller&#39;s class loader is not the same as the</span>
<span class="line-added">2296      *          class loader of this class and invocation of</span>
<span class="line-added">2297      *          {@link SecurityManager#checkPermission</span>
<span class="line-added">2298      *          s.checkPermission} method with</span>
<span class="line-added">2299      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}</span>
<span class="line-added">2300      *          denies access to the declared methods within this class</span>
<span class="line-added">2301      *</span>
<span class="line-added">2302      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an</span>
<span class="line-added">2303      *          ancestor of the class loader for the current class and</span>
<span class="line-added">2304      *          invocation of {@link SecurityManager#checkPackageAccess</span>
<span class="line-added">2305      *          s.checkPackageAccess()} denies access to the package</span>
<span class="line-added">2306      *          of this class</span>
<span class="line-added">2307      *</span>
<span class="line-added">2308      *          &lt;/ul&gt;</span>
<span class="line-added">2309      *</span>
<span class="line-added">2310      * @jls 8.10 Record Types</span>
<span class="line-added">2311      * @since 14</span>
<span class="line-added">2312      */</span>
<span class="line-added">2313     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,</span>
<span class="line-added">2314                                  essentialAPI=false)</span>
<span class="line-added">2315     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2316     @CallerSensitive</span>
<span class="line-added">2317     public RecordComponent[] getRecordComponents() {</span>
<span class="line-added">2318         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">2319         if (sm != null) {</span>
<span class="line-added">2320             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="line-added">2321         }</span>
<span class="line-added">2322         if (!isRecord()) {</span>
<span class="line-added">2323             return null;</span>
<span class="line-added">2324         }</span>
<span class="line-added">2325         RecordComponent[] recordComponents = getRecordComponents0();</span>
<span class="line-added">2326         if (recordComponents == null) {</span>
<span class="line-added">2327             return new RecordComponent[0];</span>
<span class="line-added">2328         }</span>
<span class="line-added">2329         return recordComponents;</span>
<span class="line-added">2330     }</span>
2331 
2332     /**
2333      * Returns an array containing {@code Method} objects reflecting all the
2334      * declared methods of the class or interface represented by this {@code
2335      * Class} object, including public, protected, default (package)
2336      * access, and private methods, but excluding inherited methods.
2337      *
2338      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2339      * declared methods with the same name and parameter types, but different
2340      * return types, then the returned array has a {@code Method} object for
2341      * each such method.
2342      *
2343      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2344      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2345      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2346      *
2347      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2348      * declared methods, then the returned array has length 0.
2349      *
2350      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
</pre>
<hr />
<pre>
2384     public Method[] getDeclaredMethods() throws SecurityException {
2385         SecurityManager sm = System.getSecurityManager();
2386         if (sm != null) {
2387             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2388         }
2389         return copyMethods(privateGetDeclaredMethods(false));
2390     }
2391 
2392 
2393     /**
2394      * Returns an array of {@code Constructor} objects reflecting all the
2395      * constructors declared by the class represented by this
2396      * {@code Class} object. These are public, protected, default
2397      * (package) access, and private constructors.  The elements in the array
2398      * returned are not sorted and are not in any particular order.  If the
2399      * class has a default constructor, it is included in the returned array.
2400      * This method returns an array of length 0 if this {@code Class}
2401      * object represents an interface, a primitive type, an array class, or
2402      * void.
2403      *
<span class="line-modified">2404      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section {@jls 8.2}.</span>
2405      *
2406      * @return  the array of {@code Constructor} objects representing all the
2407      *          declared constructors of this class
2408      * @throws  SecurityException
2409      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2410      *          following conditions is met:
2411      *
2412      *          &lt;ul&gt;
2413      *
2414      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2415      *          class loader of this class and invocation of
2416      *          {@link SecurityManager#checkPermission
2417      *          s.checkPermission} method with
2418      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2419      *          denies access to the declared constructors within this class
2420      *
2421      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2422      *          ancestor of the class loader for the current class and
2423      *          invocation of {@link SecurityManager#checkPackageAccess
2424      *          s.checkPackageAccess()} denies access to the package
</pre>
<hr />
<pre>
3469         ReflectionFactory fact = getReflectionFactory();
3470         for (int i = 0; i &lt; arg.length; i++) {
3471             out[i] = fact.copyMethod(arg[i]);
3472         }
3473         return out;
3474     }
3475 
3476     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3477         Constructor&lt;U&gt;[] out = arg.clone();
3478         ReflectionFactory fact = getReflectionFactory();
3479         for (int i = 0; i &lt; out.length; i++) {
3480             out[i] = fact.copyConstructor(out[i]);
3481         }
3482         return out;
3483     }
3484 
3485     private native Field[]       getDeclaredFields0(boolean publicOnly);
3486     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3487     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3488     private native Class&lt;?&gt;[]   getDeclaredClasses0();
<span class="line-added">3489     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">3490     private native RecordComponent[] getRecordComponents0();</span>
<span class="line-added">3491     private native boolean      isRecord0();</span>
3492 
3493     /**
3494      * Helper method to get the method name from arguments.
3495      */
3496     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
<span class="line-modified">3497         return getName() + &#39;.&#39; + name +</span>
<span class="line-modified">3498                 ((argTypes == null || argTypes.length == 0) ?</span>
<span class="line-modified">3499                 &quot;()&quot; :</span>
<span class="line-modified">3500                 Arrays.stream(argTypes)</span>
<span class="line-modified">3501                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())</span>
<span class="line-modified">3502                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));</span>



3503     }
3504 
3505     /** use serialVersionUID from JDK 1.1 for interoperability */
<span class="line-added">3506     @java.io.Serial</span>
3507     private static final long serialVersionUID = 3206093459760846163L;
3508 
3509 
3510     /**
3511      * Class Class is special cased within the Serialization Stream Protocol.
3512      *
3513      * A Class instance is written initially into an ObjectOutputStream in the
3514      * following format:
3515      * &lt;pre&gt;
3516      *      {@code TC_CLASS} ClassDescriptor
3517      *      A ClassDescriptor is a special cased serialization of
3518      *      a {@code java.io.ObjectStreamClass} instance.
3519      * &lt;/pre&gt;
3520      * A new handle is generated for the initial time the class descriptor
3521      * is written into the stream. Future references to the class descriptor
3522      * are written as references to the initial class descriptor instance.
3523      *
3524      * @see java.io.ObjectStreamClass
3525      */
<span class="line-added">3526     @java.io.Serial</span>
3527     private static final ObjectStreamField[] serialPersistentFields =
3528         new ObjectStreamField[0];
3529 
3530 
3531     /**
3532      * Returns the assertion status that would be assigned to this
3533      * class if it were to be initialized at the time this method is invoked.
3534      * If this class has had its assertion status set, the most recent
3535      * setting will be returned; otherwise, if any package default assertion
3536      * status pertains to this class, the most recent setting for the most
3537      * specific pertinent package default assertion status is returned;
3538      * otherwise, if this class is not a system class (i.e., it has a
3539      * class loader) its class loader&#39;s default assertion status is returned;
3540      * otherwise, the system class default assertion status is returned.
3541      * &lt;p&gt;
3542      * Few programmers will have any need for this method; it is provided
3543      * for the benefit of the JRE itself.  (It allows a class to determine at
3544      * the time that it is initialized whether assertions should be enabled.)
3545      * Note that this method is not guaranteed to return the actual
3546      * assertion status that was (or will be) associated with the specified
</pre>
<hr />
<pre>
3558         if (loader == null)
3559             return desiredAssertionStatus0(this);
3560 
3561         // If the classloader has been initialized with the assertion
3562         // directives, ask it. Otherwise, ask the VM.
3563         synchronized(loader.assertionLock) {
3564             if (loader.classAssertionStatus != null) {
3565                 return loader.desiredAssertionStatus(getName());
3566             }
3567         }
3568         return desiredAssertionStatus0(this);
3569     }
3570 
3571     // Retrieves the desired assertion status of this class from the VM
3572     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3573 
3574     /**
3575      * Returns true if and only if this class was declared as an enum in the
3576      * source code.
3577      *
<span class="line-added">3578      * Note that {@link java.lang.Enum} is not itself an enum type.</span>
<span class="line-added">3579      *</span>
<span class="line-added">3580      * Also note that if an enum constant is declared with a class body,</span>
<span class="line-added">3581      * the class of that enum constant object is an anonymous class</span>
<span class="line-added">3582      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The</span>
<span class="line-added">3583      * {@link Enum#getDeclaringClass} method of an enum constant can</span>
<span class="line-added">3584      * be used to get the class of the enum type declaring the</span>
<span class="line-added">3585      * constant.</span>
<span class="line-added">3586      *</span>
3587      * @return true if and only if this class was declared as an enum in the
3588      *     source code
3589      * @since 1.5
<span class="line-added">3590      * @jls 8.9.1 Enum Constants</span>
3591      */
3592     public boolean isEnum() {
3593         // An enum must both directly extend java.lang.Enum and have
3594         // the ENUM bit set; classes for specialized enum constants
3595         // don&#39;t do the former.
3596         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3597         this.getSuperclass() == java.lang.Enum.class;
3598     }
3599 
<span class="line-added">3600     /** java.lang.Record.class */</span>
<span class="line-added">3601     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();</span>
<span class="line-added">3602     private static Class&lt;?&gt; javaLangRecordClass() {</span>
<span class="line-added">3603         try {</span>
<span class="line-added">3604             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);</span>
<span class="line-added">3605         } catch (ClassNotFoundException e) {</span>
<span class="line-added">3606             throw new InternalError(&quot;should not reach here&quot;, e);</span>
<span class="line-added">3607         }</span>
<span class="line-added">3608     }</span>
<span class="line-added">3609 </span>
<span class="line-added">3610     /**</span>
<span class="line-added">3611      * {@preview Associated with records, a preview feature of the Java language.</span>
<span class="line-added">3612      *</span>
<span class="line-added">3613      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview</span>
<span class="line-added">3614      *           feature of the Java language. Preview features</span>
<span class="line-added">3615      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">3616      *           features of the Java language.}</span>
<span class="line-added">3617      *</span>
<span class="line-added">3618      * Returns {@code true} if and only if this class is a record class.</span>
<span class="line-added">3619      *</span>
<span class="line-added">3620      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record</span>
<span class="line-added">3621      * class is {@code java.lang.Record}. A record class has (possibly zero)</span>
<span class="line-added">3622      * record components, that is, {@link #getRecordComponents()} returns a</span>
<span class="line-added">3623      * non-null value.</span>
<span class="line-added">3624      *</span>
<span class="line-added">3625      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking</span>
<span class="line-added">3626      * this method on class {@code Record} returns {@code false}.</span>
<span class="line-added">3627      *</span>
<span class="line-added">3628      * @return true if and only if this class is a record class, otherwise false</span>
<span class="line-added">3629      * @jls 8.10 Record Types</span>
<span class="line-added">3630      * @since 14</span>
<span class="line-added">3631      */</span>
<span class="line-added">3632     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,</span>
<span class="line-added">3633                                  essentialAPI=false)</span>
<span class="line-added">3634     public boolean isRecord() {</span>
<span class="line-added">3635         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();</span>
<span class="line-added">3636     }</span>
<span class="line-added">3637 </span>
3638     // Fetches the factory for reflective objects
3639     private static ReflectionFactory getReflectionFactory() {
3640         if (reflectionFactory == null) {
3641             reflectionFactory =
3642                 java.security.AccessController.doPrivileged
3643                     (new ReflectionFactory.GetReflectionFactoryAction());
3644         }
3645         return reflectionFactory;
3646     }
3647     private static ReflectionFactory reflectionFactory;
3648 
3649     /**
3650      * Returns the elements of this enum class or null if this
3651      * Class object does not represent an enum type.
3652      *
3653      * @return an array containing the values comprising the enum class
3654      *     represented by this Class object in the order they&#39;re
3655      *     declared, or null if this Class object does not
3656      *     represent an enum type
3657      * @since 1.5
</pre>
<hr />
<pre>
4025      *
4026      * @apiNote A {@code class} file of version 55.0 or greater may record the
4027      * host of the nest to which it belongs by using the {@code NestHost}
4028      * attribute (JVMS 4.7.28). Alternatively, a {@code class} file of
4029      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4030      * other members with the
4031      * {@code NestMembers} attribute (JVMS 4.7.29).
4032      * A {@code class} file of version 54.0 or lower does not use these
4033      * attributes.
4034      *
4035      * @return the nest host of this class or interface
4036      *
4037      * @throws SecurityException
4038      *         If the returned class is not the current class, and
4039      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4040      *         class loader is not the same as or an ancestor of the class
4041      *         loader for the returned class and invocation of {@link
4042      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4043      *         denies access to the package of the returned class
4044      * @since 11
<span class="line-modified">4045      * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="line-added">4046      * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
4047      * @jvms 5.4.4 Access Control
4048      */
4049     @CallerSensitive
4050     public Class&lt;?&gt; getNestHost() {
4051         if (isPrimitive() || isArray()) {
4052             return this;
4053         }
4054         Class&lt;?&gt; host;
4055         try {
4056             host = getNestHost0();
4057         } catch (LinkageError e) {
4058             // if we couldn&#39;t load our nest-host then we
4059             // act as-if we have no nest-host attribute
4060             return this;
4061         }
4062         // if null then nest membership validation failed, so we
4063         // act as-if we have no nest-host attribute
4064         if (host == null || host == this) {
4065             return this;
4066         }
</pre>
</td>
</tr>
</table>
<center><a href="CharacterName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassCastException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
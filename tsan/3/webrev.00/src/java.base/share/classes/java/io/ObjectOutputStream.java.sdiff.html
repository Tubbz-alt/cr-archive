<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/ObjectOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectOutput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamClass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 133  * the constant&#39;s name method.  Like other serializable or externalizable
 134  * objects, enum constants can function as the targets of back references
 135  * appearing subsequently in the serialization stream.  The process by which
 136  * enum constants are serialized cannot be customized; any class-specific
 137  * writeObject and writeReplace methods defined by enum types are ignored
 138  * during serialization.  Similarly, any serialPersistentFields or
 139  * serialVersionUID field declarations are also ignored--all enum types have a
 140  * fixed serialVersionUID of 0L.
 141  *
 142  * &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
 143  * written to the ObjectOutputStream in block-data records. A block data record
 144  * is composed of a header and data. The block data header consists of a marker
 145  * and the number of bytes to follow the header.  Consecutive primitive data
 146  * writes are merged into one block-data record.  The blocking factor used for
 147  * a block-data record will be 1024 bytes.  Each block-data record will be
 148  * filled up to 1024 bytes, or be written whenever there is a termination of
 149  * block-data mode.  Calls to the ObjectOutputStream methods writeObject,
 150  * defaultWriteObject and writeFields initially terminate any existing
 151  * block-data record.
 152  *




 153  * @author      Mike Warres
 154  * @author      Roger Riggs
 155  * @see java.io.DataOutput
 156  * @see java.io.ObjectInputStream
 157  * @see java.io.Serializable
 158  * @see java.io.Externalizable
 159  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/output.html&quot;&gt;
 160  *     Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;
 161  * @since       1.1
 162  */
 163 public class ObjectOutputStream
 164     extends OutputStream implements ObjectOutput, ObjectStreamConstants
 165 {
 166 
 167     private static class Caches {
 168         /** cache of subclass security audit results */
 169         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 170             new ConcurrentHashMap&lt;&gt;();
 171 
 172         /** queue for WeakReferences to audited subclasses */
</pre>
<hr />
<pre>
 215             new sun.security.action.GetBooleanAction(
 216                 &quot;sun.io.serialization.extendedDebugInfo&quot;)).booleanValue();
 217 
 218     /**
 219      * Creates an ObjectOutputStream that writes to the specified OutputStream.
 220      * This constructor writes the serialization stream header to the
 221      * underlying stream; callers may wish to flush the stream immediately to
 222      * ensure that constructors for receiving ObjectInputStreams will not block
 223      * when reading the header.
 224      *
 225      * &lt;p&gt;If a security manager is installed, this constructor will check for
 226      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 227      * directly or indirectly by the constructor of a subclass which overrides
 228      * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared
 229      * methods.
 230      *
 231      * @param   out output stream to write to
 232      * @throws  IOException if an I/O error occurs while writing stream header
 233      * @throws  SecurityException if untrusted subclass illegally overrides
 234      *          security-sensitive methods
<span class="line-modified"> 235      * @throws  NullPointerException if &lt;code&gt;out&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
 236      * @since   1.4
 237      * @see     ObjectOutputStream#ObjectOutputStream()
 238      * @see     ObjectOutputStream#putFields()
 239      * @see     ObjectInputStream#ObjectInputStream(InputStream)
 240      */
 241     public ObjectOutputStream(OutputStream out) throws IOException {
 242         verifySubclass();
 243         bout = new BlockDataOutputStream(out);
 244         handles = new HandleTable(10, (float) 3.00);
 245         subs = new ReplaceTable(10, (float) 3.00);
 246         enableOverride = false;
 247         writeStreamHeader();
 248         bout.setBlockDataMode(true);
 249         if (extendedDebugInfo) {
 250             debugInfoStack = new DebugTraceInfoStack();
 251         } else {
 252             debugInfoStack = null;
 253         }
 254     }
 255 
 256     /**
 257      * Provide a way for subclasses that are completely reimplementing
 258      * ObjectOutputStream to not have to allocate private data just used by
 259      * this implementation of ObjectOutputStream.
 260      *
 261      * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified"> 262      * security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method with a</span>
<span class="line-modified"> 263      * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;</span>
 264      * permission to ensure it&#39;s ok to enable subclassing.
 265      *
 266      * @throws  SecurityException if a security manager exists and its
<span class="line-modified"> 267      *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling</span>
 268      *          subclassing.
 269      * @throws  IOException if an I/O error occurs while creating this stream
 270      * @see SecurityManager#checkPermission
 271      * @see java.io.SerializablePermission
 272      */
 273     protected ObjectOutputStream() throws IOException, SecurityException {
 274         SecurityManager sm = System.getSecurityManager();
 275         if (sm != null) {
 276             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 277         }
 278         bout = null;
 279         handles = null;
 280         subs = null;
 281         enableOverride = true;
 282         debugInfoStack = null;
 283     }
 284 
 285     /**
 286      * Specify stream protocol version to use when writing the stream.
 287      *
</pre>
<hr />
<pre>
 340      * @throws  IOException Any exception thrown by the underlying
 341      *          OutputStream.
 342      */
 343     public final void writeObject(Object obj) throws IOException {
 344         if (enableOverride) {
 345             writeObjectOverride(obj);
 346             return;
 347         }
 348         try {
 349             writeObject0(obj, false);
 350         } catch (IOException ex) {
 351             if (depth == 0) {
 352                 writeFatalException(ex);
 353             }
 354             throw ex;
 355         }
 356     }
 357 
 358     /**
 359      * Method used by subclasses to override the default writeObject method.
<span class="line-modified"> 360      * This method is called by trusted subclasses of ObjectInputStream that</span>
<span class="line-modified"> 361      * constructed ObjectInputStream using the protected no-arg constructor.</span>
 362      * The subclass is expected to provide an override method with the modifier
 363      * &quot;final&quot;.
 364      *
 365      * @param   obj object to be written to the underlying stream
 366      * @throws  IOException if there are I/O errors while writing to the
 367      *          underlying stream
 368      * @see #ObjectOutputStream()
 369      * @see #writeObject(Object)
 370      * @since 1.2
 371      */
 372     protected void writeObjectOverride(Object obj) throws IOException {
 373     }
 374 
 375     /**
 376      * Writes an &quot;unshared&quot; object to the ObjectOutputStream.  This method is
 377      * identical to writeObject, except that it always writes the given object
 378      * as a new, unique object in the stream (as opposed to a back-reference
 379      * pointing to a previously serialized instance).  Specifically:
 380      * &lt;ul&gt;
 381      *   &lt;li&gt;An object written via writeUnshared is always serialized in the
</pre>
<hr />
<pre>
 412      * @since 1.4
 413      */
 414     public void writeUnshared(Object obj) throws IOException {
 415         try {
 416             writeObject0(obj, true);
 417         } catch (IOException ex) {
 418             if (depth == 0) {
 419                 writeFatalException(ex);
 420             }
 421             throw ex;
 422         }
 423     }
 424 
 425     /**
 426      * Write the non-static and non-transient fields of the current class to
 427      * this stream.  This may only be called from the writeObject method of the
 428      * class being serialized. It will throw the NotActiveException if it is
 429      * called otherwise.
 430      *
 431      * @throws  IOException if I/O errors occur while writing to the underlying
<span class="line-modified"> 432      *          &lt;code&gt;OutputStream&lt;/code&gt;</span>
 433      */
 434     public void defaultWriteObject() throws IOException {
 435         SerialCallbackContext ctx = curContext;
 436         if (ctx == null) {
 437             throw new NotActiveException(&quot;not in call to writeObject&quot;);
 438         }
 439         Object curObj = ctx.getObj();
 440         ObjectStreamClass curDesc = ctx.getDesc();
 441         bout.setBlockDataMode(false);
 442         defaultWriteFields(curObj, curDesc);
 443         bout.setBlockDataMode(true);
 444     }
 445 
 446     /**
 447      * Retrieve the object used to buffer persistent fields to be written to
 448      * the stream.  The fields will be written to the stream when writeFields
 449      * method is called.
 450      *
 451      * @return  an instance of the class Putfield that holds the serializable
 452      *          fields
</pre>
<hr />
<pre>
 512      * signature will have already been written to the stream.  This method may
 513      * make free use of the ObjectOutputStream to save any representation of
 514      * the class it deems suitable (for example, the bytes of the class file).
 515      * The resolveClass method in the corresponding subclass of
 516      * ObjectInputStream must read and use any data or objects written by
 517      * annotateClass.
 518      *
 519      * @param   cl the class to annotate custom data for
 520      * @throws  IOException Any exception thrown by the underlying
 521      *          OutputStream.
 522      */
 523     protected void annotateClass(Class&lt;?&gt; cl) throws IOException {
 524     }
 525 
 526     /**
 527      * Subclasses may implement this method to store custom data in the stream
 528      * along with descriptors for dynamic proxy classes.
 529      *
 530      * &lt;p&gt;This method is called exactly once for each unique proxy class
 531      * descriptor in the stream.  The default implementation of this method in
<span class="line-modified"> 532      * &lt;code&gt;ObjectOutputStream&lt;/code&gt; does nothing.</span>
 533      *
<span class="line-modified"> 534      * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectInputStream&lt;/code&gt; is</span>
<span class="line-modified"> 535      * &lt;code&gt;resolveProxyClass&lt;/code&gt;.  For a given subclass of</span>
<span class="line-modified"> 536      * &lt;code&gt;ObjectOutputStream&lt;/code&gt; that overrides this method, the</span>
<span class="line-modified"> 537      * &lt;code&gt;resolveProxyClass&lt;/code&gt; method in the corresponding subclass of</span>
<span class="line-modified"> 538      * &lt;code&gt;ObjectInputStream&lt;/code&gt; must read any data or objects written by</span>
<span class="line-modified"> 539      * &lt;code&gt;annotateProxyClass&lt;/code&gt;.</span>
 540      *
 541      * @param   cl the proxy class to annotate custom data for
 542      * @throws  IOException any exception thrown by the underlying
<span class="line-modified"> 543      *          &lt;code&gt;OutputStream&lt;/code&gt;</span>
 544      * @see ObjectInputStream#resolveProxyClass(String[])
 545      * @since   1.3
 546      */
 547     protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException {
 548     }
 549 
 550     /**
 551      * This method will allow trusted subclasses of ObjectOutputStream to
 552      * substitute one object for another during serialization. Replacing
 553      * objects is disabled until enableReplaceObject is called. The
 554      * enableReplaceObject method checks that the stream requesting to do
 555      * replacement can be trusted.  The first occurrence of each object written
 556      * into the serialization stream is passed to replaceObject.  Subsequent
 557      * references to the object are replaced by the object returned by the
 558      * original call to replaceObject.  To ensure that the private state of
 559      * objects is not unintentionally exposed, only trusted streams may use
 560      * replaceObject.
 561      *
 562      * &lt;p&gt;The ObjectOutputStream.writeObject method takes a parameter of type
 563      * Object (as opposed to type Serializable) to allow for cases where
</pre>
<hr />
<pre>
 629 
 630     /**
 631      * The writeStreamHeader method is provided so subclasses can append or
 632      * prepend their own header to the stream.  It writes the magic number and
 633      * version to the stream.
 634      *
 635      * @throws  IOException if I/O errors occur while writing to the underlying
 636      *          stream
 637      */
 638     protected void writeStreamHeader() throws IOException {
 639         bout.writeShort(STREAM_MAGIC);
 640         bout.writeShort(STREAM_VERSION);
 641     }
 642 
 643     /**
 644      * Write the specified class descriptor to the ObjectOutputStream.  Class
 645      * descriptors are used to identify the classes of objects written to the
 646      * stream.  Subclasses of ObjectOutputStream may override this method to
 647      * customize the way in which class descriptors are written to the
 648      * serialization stream.  The corresponding method in ObjectInputStream,
<span class="line-modified"> 649      * &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to</span>
 650      * reconstitute the class descriptor from its custom stream representation.
 651      * By default, this method writes class descriptors according to the format
 652      * defined in the Object Serialization specification.
 653      *
 654      * &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
 655      * is not using the old serialization stream format (set by calling
<span class="line-modified"> 656      * ObjectOutputStream&#39;s &lt;code&gt;useProtocolVersion&lt;/code&gt; method).  If this</span>
 657      * serialization stream is using the old format
<span class="line-modified"> 658      * (&lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt;), the class descriptor will be written</span>
 659      * internally in a manner that cannot be overridden or customized.
 660      *
 661      * @param   desc class descriptor to write to the stream
 662      * @throws  IOException If an I/O error has occurred.
 663      * @see java.io.ObjectInputStream#readClassDescriptor()
 664      * @see #useProtocolVersion(int)
 665      * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1
 666      * @since 1.3
 667      */
 668     protected void writeClassDescriptor(ObjectStreamClass desc)
 669         throws IOException
 670     {
 671         desc.writeNonProxy(this);
 672     }
 673 
 674     /**
 675      * Writes a byte. This method will block until the byte is actually
 676      * written.
 677      *
 678      * @param   val the byte to be written to the stream
</pre>
<hr />
<pre>
 862      * significant difference between writing a String into the stream as
 863      * primitive data or as an Object. A String instance written by writeObject
 864      * is written into the stream as a String initially. Future writeObject()
 865      * calls write references to the string into the stream.
 866      *
 867      * @param   str the String to be written
 868      * @throws  IOException if I/O errors occur while writing to the underlying
 869      *          stream
 870      */
 871     public void writeUTF(String str) throws IOException {
 872         bout.writeUTF(str);
 873     }
 874 
 875     /**
 876      * Provide programmatic access to the persistent fields to be written
 877      * to ObjectOutput.
 878      *
 879      * @since 1.2
 880      */
 881     public abstract static class PutField {




 882 
 883         /**
 884          * Put the value of the named boolean field into the persistent field.
 885          *
 886          * @param  name the name of the serializable field
 887          * @param  val the value to assign to the field
<span class="line-modified"> 888          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 889          * match the name of a serializable field for the class whose fields
 890          * are being written, or if the type of the named field is not
<span class="line-modified"> 891          * &lt;code&gt;boolean&lt;/code&gt;</span>
 892          */
 893         public abstract void put(String name, boolean val);
 894 
 895         /**
 896          * Put the value of the named byte field into the persistent field.
 897          *
 898          * @param  name the name of the serializable field
 899          * @param  val the value to assign to the field
<span class="line-modified"> 900          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 901          * match the name of a serializable field for the class whose fields
 902          * are being written, or if the type of the named field is not
<span class="line-modified"> 903          * &lt;code&gt;byte&lt;/code&gt;</span>
 904          */
 905         public abstract void put(String name, byte val);
 906 
 907         /**
 908          * Put the value of the named char field into the persistent field.
 909          *
 910          * @param  name the name of the serializable field
 911          * @param  val the value to assign to the field
<span class="line-modified"> 912          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 913          * match the name of a serializable field for the class whose fields
 914          * are being written, or if the type of the named field is not
<span class="line-modified"> 915          * &lt;code&gt;char&lt;/code&gt;</span>
 916          */
 917         public abstract void put(String name, char val);
 918 
 919         /**
 920          * Put the value of the named short field into the persistent field.
 921          *
 922          * @param  name the name of the serializable field
 923          * @param  val the value to assign to the field
<span class="line-modified"> 924          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 925          * match the name of a serializable field for the class whose fields
 926          * are being written, or if the type of the named field is not
<span class="line-modified"> 927          * &lt;code&gt;short&lt;/code&gt;</span>
 928          */
 929         public abstract void put(String name, short val);
 930 
 931         /**
 932          * Put the value of the named int field into the persistent field.
 933          *
 934          * @param  name the name of the serializable field
 935          * @param  val the value to assign to the field
<span class="line-modified"> 936          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 937          * match the name of a serializable field for the class whose fields
 938          * are being written, or if the type of the named field is not
<span class="line-modified"> 939          * &lt;code&gt;int&lt;/code&gt;</span>
 940          */
 941         public abstract void put(String name, int val);
 942 
 943         /**
 944          * Put the value of the named long field into the persistent field.
 945          *
 946          * @param  name the name of the serializable field
 947          * @param  val the value to assign to the field
<span class="line-modified"> 948          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 949          * match the name of a serializable field for the class whose fields
 950          * are being written, or if the type of the named field is not
<span class="line-modified"> 951          * &lt;code&gt;long&lt;/code&gt;</span>
 952          */
 953         public abstract void put(String name, long val);
 954 
 955         /**
 956          * Put the value of the named float field into the persistent field.
 957          *
 958          * @param  name the name of the serializable field
 959          * @param  val the value to assign to the field
<span class="line-modified"> 960          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 961          * match the name of a serializable field for the class whose fields
 962          * are being written, or if the type of the named field is not
<span class="line-modified"> 963          * &lt;code&gt;float&lt;/code&gt;</span>
 964          */
 965         public abstract void put(String name, float val);
 966 
 967         /**
 968          * Put the value of the named double field into the persistent field.
 969          *
 970          * @param  name the name of the serializable field
 971          * @param  val the value to assign to the field
<span class="line-modified"> 972          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 973          * match the name of a serializable field for the class whose fields
 974          * are being written, or if the type of the named field is not
<span class="line-modified"> 975          * &lt;code&gt;double&lt;/code&gt;</span>
 976          */
 977         public abstract void put(String name, double val);
 978 
 979         /**
 980          * Put the value of the named Object field into the persistent field.
 981          *
 982          * @param  name the name of the serializable field
 983          * @param  val the value to assign to the field
<span class="line-modified"> 984          *         (which may be &lt;code&gt;null&lt;/code&gt;)</span>
<span class="line-modified"> 985          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
 986          * match the name of a serializable field for the class whose fields
 987          * are being written, or if the type of the named field is not a
 988          * reference type
 989          */
 990         public abstract void put(String name, Object val);
 991 
 992         /**
 993          * Write the data and fields to the specified ObjectOutput stream,
 994          * which must be the same stream that produced this
<span class="line-modified"> 995          * &lt;code&gt;PutField&lt;/code&gt; object.</span>
 996          *
 997          * @param  out the stream to write the data and fields to
 998          * @throws IOException if I/O errors occur while writing to the
 999          *         underlying stream
1000          * @throws IllegalArgumentException if the specified stream is not
<span class="line-modified">1001          *         the same stream that produced this &lt;code&gt;PutField&lt;/code&gt;</span>
1002          *         object
1003          * @deprecated This method does not write the values contained by this
<span class="line-modified">1004          *         &lt;code&gt;PutField&lt;/code&gt; object in a proper format, and may</span>
1005          *         result in corruption of the serialization stream.  The
<span class="line-modified">1006          *         correct way to write &lt;code&gt;PutField&lt;/code&gt; data is by</span>
1007          *         calling the {@link java.io.ObjectOutputStream#writeFields()}
1008          *         method.
1009          */
1010         @Deprecated
1011         public abstract void write(ObjectOutput out) throws IOException;
1012     }
1013 
1014 
1015     /**
1016      * Returns protocol version in use.
1017      */
1018     int getProtocolVersion() {
1019         return protocol;
1020     }
1021 
1022     /**
1023      * Writes string without allowing it to be replaced in stream.  Used by
1024      * ObjectStreamClass to write class descriptor type strings.
1025      */
1026     void writeTypeString(String str) throws IOException {
</pre>
<hr />
<pre>
1410      * Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class,
1411      * ObjectStreamClass, array, or enum constant) serializable object to the
1412      * stream.
1413      */
1414     private void writeOrdinaryObject(Object obj,
1415                                      ObjectStreamClass desc,
1416                                      boolean unshared)
1417         throws IOException
1418     {
1419         if (extendedDebugInfo) {
1420             debugInfoStack.push(
1421                 (depth == 1 ? &quot;root &quot; : &quot;&quot;) + &quot;object (class \&quot;&quot; +
1422                 obj.getClass().getName() + &quot;\&quot;, &quot; + obj.toString() + &quot;)&quot;);
1423         }
1424         try {
1425             desc.checkSerialize();
1426 
1427             bout.writeByte(TC_OBJECT);
1428             writeClassDesc(desc, false);
1429             handles.assign(unshared ? null : obj);
<span class="line-modified">1430             if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {</span>



1431                 writeExternalData((Externalizable) obj);
1432             } else {
1433                 writeSerialData(obj, desc);
1434             }
1435         } finally {
1436             if (extendedDebugInfo) {
1437                 debugInfoStack.pop();
1438             }
1439         }
1440     }
1441 
1442     /**
1443      * Writes externalizable data of given object by invoking its
1444      * writeExternal() method.
1445      */
1446     private void writeExternalData(Externalizable obj) throws IOException {
1447         PutFieldImpl oldPut = curPut;
1448         curPut = null;
1449 
1450         if (extendedDebugInfo) {
</pre>
<hr />
<pre>
1454         try {
1455             curContext = null;
1456             if (protocol == PROTOCOL_VERSION_1) {
1457                 obj.writeExternal(this);
1458             } else {
1459                 bout.setBlockDataMode(true);
1460                 obj.writeExternal(this);
1461                 bout.setBlockDataMode(false);
1462                 bout.writeByte(TC_ENDBLOCKDATA);
1463             }
1464         } finally {
1465             curContext = oldContext;
1466             if (extendedDebugInfo) {
1467                 debugInfoStack.pop();
1468             }
1469         }
1470 
1471         curPut = oldPut;
1472     }
1473 















1474     /**
1475      * Writes instance data for each serializable class of given object, from
1476      * superclass to subclass.
1477      */
1478     private void writeSerialData(Object obj, ObjectStreamClass desc)
1479         throws IOException
1480     {
1481         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
1482         for (int i = 0; i &lt; slots.length; i++) {
1483             ObjectStreamClass slotDesc = slots[i].desc;
1484             if (slotDesc.hasWriteObjectMethod()) {
1485                 PutFieldImpl oldPut = curPut;
1486                 curPut = null;
1487                 SerialCallbackContext oldContext = curContext;
1488 
1489                 if (extendedDebugInfo) {
1490                     debugInfoStack.push(
1491                         &quot;custom writeObject data (class \&quot;&quot; +
1492                         slotDesc.getName() + &quot;\&quot;)&quot;);
1493                 }
</pre>
<hr />
<pre>
1570          * Note: the serialization specification states that if a second
1571          * IOException occurs while attempting to serialize the original fatal
1572          * exception to the stream, then a StreamCorruptedException should be
1573          * thrown (section 2.1).  However, due to a bug in previous
1574          * implementations of serialization, StreamCorruptedExceptions were
1575          * rarely (if ever) actually thrown--the &quot;root&quot; exceptions from
1576          * underlying streams were thrown instead.  This historical behavior is
1577          * followed here for consistency.
1578          */
1579         clear();
1580         boolean oldMode = bout.setBlockDataMode(false);
1581         try {
1582             bout.writeByte(TC_EXCEPTION);
1583             writeObject0(ex, false);
1584             clear();
1585         } finally {
1586             bout.setBlockDataMode(oldMode);
1587         }
1588     }
1589 
<span class="line-removed">1590     /**</span>
<span class="line-removed">1591      * Converts specified span of float values into byte values.</span>
<span class="line-removed">1592      */</span>
<span class="line-removed">1593     // REMIND: remove once hotspot inlines Float.floatToIntBits</span>
<span class="line-removed">1594     private static native void floatsToBytes(float[] src, int srcpos,</span>
<span class="line-removed">1595                                              byte[] dst, int dstpos,</span>
<span class="line-removed">1596                                              int nfloats);</span>
<span class="line-removed">1597 </span>
<span class="line-removed">1598     /**</span>
<span class="line-removed">1599      * Converts specified span of double values into byte values.</span>
<span class="line-removed">1600      */</span>
<span class="line-removed">1601     // REMIND: remove once hotspot inlines Double.doubleToLongBits</span>
<span class="line-removed">1602     private static native void doublesToBytes(double[] src, int srcpos,</span>
<span class="line-removed">1603                                               byte[] dst, int dstpos,</span>
<span class="line-removed">1604                                               int ndoubles);</span>
<span class="line-removed">1605 </span>
1606     /**
1607      * Default PutField implementation.
1608      */
1609     private class PutFieldImpl extends PutField {
1610 
1611         /** class descriptor describing serializable fields */
1612         private final ObjectStreamClass desc;
1613         /** primitive field values */
1614         private final byte[] primVals;
1615         /** object field values */
1616         private final Object[] objVals;
1617 
1618         /**
1619          * Creates PutFieldImpl object for writing fields defined in given
1620          * class descriptor.
1621          */
1622         PutFieldImpl(ObjectStreamClass desc) {
1623             this.desc = desc;
1624             primVals = new byte[desc.getPrimDataSize()];
1625             objVals = new Object[desc.getNumObjFields()];
</pre>
<hr />
<pre>
2075             while (off &lt; endoff) {
2076                 if (pos &lt;= limit) {
2077                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
2078                     int stop = Math.min(endoff, off + avail);
2079                     while (off &lt; stop) {
2080                         Bits.putInt(buf, pos, v[off++]);
2081                         pos += 4;
2082                     }
2083                 } else {
2084                     dout.writeInt(v[off++]);
2085                 }
2086             }
2087         }
2088 
2089         void writeFloats(float[] v, int off, int len) throws IOException {
2090             int limit = MAX_BLOCK_SIZE - 4;
2091             int endoff = off + len;
2092             while (off &lt; endoff) {
2093                 if (pos &lt;= limit) {
2094                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
<span class="line-modified">2095                     int chunklen = Math.min(endoff - off, avail);</span>
<span class="line-modified">2096                     floatsToBytes(v, off, buf, pos, chunklen);</span>
<span class="line-modified">2097                     off += chunklen;</span>
<span class="line-modified">2098                     pos += chunklen &lt;&lt; 2;</span>

2099                 } else {
2100                     dout.writeFloat(v[off++]);
2101                 }
2102             }
2103         }
2104 
2105         void writeLongs(long[] v, int off, int len) throws IOException {
2106             int limit = MAX_BLOCK_SIZE - 8;
2107             int endoff = off + len;
2108             while (off &lt; endoff) {
2109                 if (pos &lt;= limit) {
2110                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
2111                     int stop = Math.min(endoff, off + avail);
2112                     while (off &lt; stop) {
2113                         Bits.putLong(buf, pos, v[off++]);
2114                         pos += 8;
2115                     }
2116                 } else {
2117                     dout.writeLong(v[off++]);
2118                 }
2119             }
2120         }
2121 
2122         void writeDoubles(double[] v, int off, int len) throws IOException {
2123             int limit = MAX_BLOCK_SIZE - 8;
2124             int endoff = off + len;
2125             while (off &lt; endoff) {
2126                 if (pos &lt;= limit) {
2127                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
<span class="line-modified">2128                     int chunklen = Math.min(endoff - off, avail);</span>
<span class="line-modified">2129                     doublesToBytes(v, off, buf, pos, chunklen);</span>
<span class="line-modified">2130                     off += chunklen;</span>
<span class="line-modified">2131                     pos += chunklen &lt;&lt; 3;</span>

2132                 } else {
2133                     dout.writeDouble(v[off++]);
2134                 }
2135             }
2136         }
2137 
2138         /**
2139          * Returns the length in bytes of the UTF encoding of the given string.
2140          */
2141         long getUTFLength(String s) {
2142             int len = s.length();
2143             long utflen = 0;
2144             for (int off = 0; off &lt; len; ) {
2145                 int csize = Math.min(len - off, CHAR_BUF_SIZE);
2146                 s.getChars(off, off + csize, cbuf, 0);
2147                 for (int cpos = 0; cpos &lt; csize; cpos++) {
2148                     char c = cbuf[cpos];
2149                     if (c &gt;= 0x0001 &amp;&amp; c &lt;= 0x007F) {
2150                         utflen++;
2151                     } else if (c &gt; 0x07FF) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 133  * the constant&#39;s name method.  Like other serializable or externalizable
 134  * objects, enum constants can function as the targets of back references
 135  * appearing subsequently in the serialization stream.  The process by which
 136  * enum constants are serialized cannot be customized; any class-specific
 137  * writeObject and writeReplace methods defined by enum types are ignored
 138  * during serialization.  Similarly, any serialPersistentFields or
 139  * serialVersionUID field declarations are also ignored--all enum types have a
 140  * fixed serialVersionUID of 0L.
 141  *
 142  * &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
 143  * written to the ObjectOutputStream in block-data records. A block data record
 144  * is composed of a header and data. The block data header consists of a marker
 145  * and the number of bytes to follow the header.  Consecutive primitive data
 146  * writes are merged into one block-data record.  The blocking factor used for
 147  * a block-data record will be 1024 bytes.  Each block-data record will be
 148  * filled up to 1024 bytes, or be written whenever there is a termination of
 149  * block-data mode.  Calls to the ObjectOutputStream methods writeObject,
 150  * defaultWriteObject and writeFields initially terminate any existing
 151  * block-data record.
 152  *
<span class="line-added"> 153  * @implSpec</span>
<span class="line-added"> 154  * Records are serialized differently than ordinary serializable or externalizable</span>
<span class="line-added"> 155  * objects, see &lt;a href=&quot;ObjectInputStream.html#record-serialization&quot;&gt;record serialization&lt;/a&gt;.</span>
<span class="line-added"> 156  *</span>
 157  * @author      Mike Warres
 158  * @author      Roger Riggs
 159  * @see java.io.DataOutput
 160  * @see java.io.ObjectInputStream
 161  * @see java.io.Serializable
 162  * @see java.io.Externalizable
 163  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/output.html&quot;&gt;
 164  *     Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;
 165  * @since       1.1
 166  */
 167 public class ObjectOutputStream
 168     extends OutputStream implements ObjectOutput, ObjectStreamConstants
 169 {
 170 
 171     private static class Caches {
 172         /** cache of subclass security audit results */
 173         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 174             new ConcurrentHashMap&lt;&gt;();
 175 
 176         /** queue for WeakReferences to audited subclasses */
</pre>
<hr />
<pre>
 219             new sun.security.action.GetBooleanAction(
 220                 &quot;sun.io.serialization.extendedDebugInfo&quot;)).booleanValue();
 221 
 222     /**
 223      * Creates an ObjectOutputStream that writes to the specified OutputStream.
 224      * This constructor writes the serialization stream header to the
 225      * underlying stream; callers may wish to flush the stream immediately to
 226      * ensure that constructors for receiving ObjectInputStreams will not block
 227      * when reading the header.
 228      *
 229      * &lt;p&gt;If a security manager is installed, this constructor will check for
 230      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 231      * directly or indirectly by the constructor of a subclass which overrides
 232      * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared
 233      * methods.
 234      *
 235      * @param   out output stream to write to
 236      * @throws  IOException if an I/O error occurs while writing stream header
 237      * @throws  SecurityException if untrusted subclass illegally overrides
 238      *          security-sensitive methods
<span class="line-modified"> 239      * @throws  NullPointerException if {@code out} is {@code null}</span>
 240      * @since   1.4
 241      * @see     ObjectOutputStream#ObjectOutputStream()
 242      * @see     ObjectOutputStream#putFields()
 243      * @see     ObjectInputStream#ObjectInputStream(InputStream)
 244      */
 245     public ObjectOutputStream(OutputStream out) throws IOException {
 246         verifySubclass();
 247         bout = new BlockDataOutputStream(out);
 248         handles = new HandleTable(10, (float) 3.00);
 249         subs = new ReplaceTable(10, (float) 3.00);
 250         enableOverride = false;
 251         writeStreamHeader();
 252         bout.setBlockDataMode(true);
 253         if (extendedDebugInfo) {
 254             debugInfoStack = new DebugTraceInfoStack();
 255         } else {
 256             debugInfoStack = null;
 257         }
 258     }
 259 
 260     /**
 261      * Provide a way for subclasses that are completely reimplementing
 262      * ObjectOutputStream to not have to allocate private data just used by
 263      * this implementation of ObjectOutputStream.
 264      *
 265      * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified"> 266      * security manager&#39;s {@code checkPermission} method with a</span>
<span class="line-modified"> 267      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}</span>
 268      * permission to ensure it&#39;s ok to enable subclassing.
 269      *
 270      * @throws  SecurityException if a security manager exists and its
<span class="line-modified"> 271      *          {@code checkPermission} method denies enabling</span>
 272      *          subclassing.
 273      * @throws  IOException if an I/O error occurs while creating this stream
 274      * @see SecurityManager#checkPermission
 275      * @see java.io.SerializablePermission
 276      */
 277     protected ObjectOutputStream() throws IOException, SecurityException {
 278         SecurityManager sm = System.getSecurityManager();
 279         if (sm != null) {
 280             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 281         }
 282         bout = null;
 283         handles = null;
 284         subs = null;
 285         enableOverride = true;
 286         debugInfoStack = null;
 287     }
 288 
 289     /**
 290      * Specify stream protocol version to use when writing the stream.
 291      *
</pre>
<hr />
<pre>
 344      * @throws  IOException Any exception thrown by the underlying
 345      *          OutputStream.
 346      */
 347     public final void writeObject(Object obj) throws IOException {
 348         if (enableOverride) {
 349             writeObjectOverride(obj);
 350             return;
 351         }
 352         try {
 353             writeObject0(obj, false);
 354         } catch (IOException ex) {
 355             if (depth == 0) {
 356                 writeFatalException(ex);
 357             }
 358             throw ex;
 359         }
 360     }
 361 
 362     /**
 363      * Method used by subclasses to override the default writeObject method.
<span class="line-modified"> 364      * This method is called by trusted subclasses of ObjectOutputStream that</span>
<span class="line-modified"> 365      * constructed ObjectOutputStream using the protected no-arg constructor.</span>
 366      * The subclass is expected to provide an override method with the modifier
 367      * &quot;final&quot;.
 368      *
 369      * @param   obj object to be written to the underlying stream
 370      * @throws  IOException if there are I/O errors while writing to the
 371      *          underlying stream
 372      * @see #ObjectOutputStream()
 373      * @see #writeObject(Object)
 374      * @since 1.2
 375      */
 376     protected void writeObjectOverride(Object obj) throws IOException {
 377     }
 378 
 379     /**
 380      * Writes an &quot;unshared&quot; object to the ObjectOutputStream.  This method is
 381      * identical to writeObject, except that it always writes the given object
 382      * as a new, unique object in the stream (as opposed to a back-reference
 383      * pointing to a previously serialized instance).  Specifically:
 384      * &lt;ul&gt;
 385      *   &lt;li&gt;An object written via writeUnshared is always serialized in the
</pre>
<hr />
<pre>
 416      * @since 1.4
 417      */
 418     public void writeUnshared(Object obj) throws IOException {
 419         try {
 420             writeObject0(obj, true);
 421         } catch (IOException ex) {
 422             if (depth == 0) {
 423                 writeFatalException(ex);
 424             }
 425             throw ex;
 426         }
 427     }
 428 
 429     /**
 430      * Write the non-static and non-transient fields of the current class to
 431      * this stream.  This may only be called from the writeObject method of the
 432      * class being serialized. It will throw the NotActiveException if it is
 433      * called otherwise.
 434      *
 435      * @throws  IOException if I/O errors occur while writing to the underlying
<span class="line-modified"> 436      *          {@code OutputStream}</span>
 437      */
 438     public void defaultWriteObject() throws IOException {
 439         SerialCallbackContext ctx = curContext;
 440         if (ctx == null) {
 441             throw new NotActiveException(&quot;not in call to writeObject&quot;);
 442         }
 443         Object curObj = ctx.getObj();
 444         ObjectStreamClass curDesc = ctx.getDesc();
 445         bout.setBlockDataMode(false);
 446         defaultWriteFields(curObj, curDesc);
 447         bout.setBlockDataMode(true);
 448     }
 449 
 450     /**
 451      * Retrieve the object used to buffer persistent fields to be written to
 452      * the stream.  The fields will be written to the stream when writeFields
 453      * method is called.
 454      *
 455      * @return  an instance of the class Putfield that holds the serializable
 456      *          fields
</pre>
<hr />
<pre>
 516      * signature will have already been written to the stream.  This method may
 517      * make free use of the ObjectOutputStream to save any representation of
 518      * the class it deems suitable (for example, the bytes of the class file).
 519      * The resolveClass method in the corresponding subclass of
 520      * ObjectInputStream must read and use any data or objects written by
 521      * annotateClass.
 522      *
 523      * @param   cl the class to annotate custom data for
 524      * @throws  IOException Any exception thrown by the underlying
 525      *          OutputStream.
 526      */
 527     protected void annotateClass(Class&lt;?&gt; cl) throws IOException {
 528     }
 529 
 530     /**
 531      * Subclasses may implement this method to store custom data in the stream
 532      * along with descriptors for dynamic proxy classes.
 533      *
 534      * &lt;p&gt;This method is called exactly once for each unique proxy class
 535      * descriptor in the stream.  The default implementation of this method in
<span class="line-modified"> 536      * {@code ObjectOutputStream} does nothing.</span>
 537      *
<span class="line-modified"> 538      * &lt;p&gt;The corresponding method in {@code ObjectInputStream} is</span>
<span class="line-modified"> 539      * {@code resolveProxyClass}.  For a given subclass of</span>
<span class="line-modified"> 540      * {@code ObjectOutputStream} that overrides this method, the</span>
<span class="line-modified"> 541      * {@code resolveProxyClass} method in the corresponding subclass of</span>
<span class="line-modified"> 542      * {@code ObjectInputStream} must read any data or objects written by</span>
<span class="line-modified"> 543      * {@code annotateProxyClass}.</span>
 544      *
 545      * @param   cl the proxy class to annotate custom data for
 546      * @throws  IOException any exception thrown by the underlying
<span class="line-modified"> 547      *          {@code OutputStream}</span>
 548      * @see ObjectInputStream#resolveProxyClass(String[])
 549      * @since   1.3
 550      */
 551     protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException {
 552     }
 553 
 554     /**
 555      * This method will allow trusted subclasses of ObjectOutputStream to
 556      * substitute one object for another during serialization. Replacing
 557      * objects is disabled until enableReplaceObject is called. The
 558      * enableReplaceObject method checks that the stream requesting to do
 559      * replacement can be trusted.  The first occurrence of each object written
 560      * into the serialization stream is passed to replaceObject.  Subsequent
 561      * references to the object are replaced by the object returned by the
 562      * original call to replaceObject.  To ensure that the private state of
 563      * objects is not unintentionally exposed, only trusted streams may use
 564      * replaceObject.
 565      *
 566      * &lt;p&gt;The ObjectOutputStream.writeObject method takes a parameter of type
 567      * Object (as opposed to type Serializable) to allow for cases where
</pre>
<hr />
<pre>
 633 
 634     /**
 635      * The writeStreamHeader method is provided so subclasses can append or
 636      * prepend their own header to the stream.  It writes the magic number and
 637      * version to the stream.
 638      *
 639      * @throws  IOException if I/O errors occur while writing to the underlying
 640      *          stream
 641      */
 642     protected void writeStreamHeader() throws IOException {
 643         bout.writeShort(STREAM_MAGIC);
 644         bout.writeShort(STREAM_VERSION);
 645     }
 646 
 647     /**
 648      * Write the specified class descriptor to the ObjectOutputStream.  Class
 649      * descriptors are used to identify the classes of objects written to the
 650      * stream.  Subclasses of ObjectOutputStream may override this method to
 651      * customize the way in which class descriptors are written to the
 652      * serialization stream.  The corresponding method in ObjectInputStream,
<span class="line-modified"> 653      * {@code readClassDescriptor}, should then be overridden to</span>
 654      * reconstitute the class descriptor from its custom stream representation.
 655      * By default, this method writes class descriptors according to the format
 656      * defined in the Object Serialization specification.
 657      *
 658      * &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
 659      * is not using the old serialization stream format (set by calling
<span class="line-modified"> 660      * ObjectOutputStream&#39;s {@code useProtocolVersion} method).  If this</span>
 661      * serialization stream is using the old format
<span class="line-modified"> 662      * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written</span>
 663      * internally in a manner that cannot be overridden or customized.
 664      *
 665      * @param   desc class descriptor to write to the stream
 666      * @throws  IOException If an I/O error has occurred.
 667      * @see java.io.ObjectInputStream#readClassDescriptor()
 668      * @see #useProtocolVersion(int)
 669      * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1
 670      * @since 1.3
 671      */
 672     protected void writeClassDescriptor(ObjectStreamClass desc)
 673         throws IOException
 674     {
 675         desc.writeNonProxy(this);
 676     }
 677 
 678     /**
 679      * Writes a byte. This method will block until the byte is actually
 680      * written.
 681      *
 682      * @param   val the byte to be written to the stream
</pre>
<hr />
<pre>
 866      * significant difference between writing a String into the stream as
 867      * primitive data or as an Object. A String instance written by writeObject
 868      * is written into the stream as a String initially. Future writeObject()
 869      * calls write references to the string into the stream.
 870      *
 871      * @param   str the String to be written
 872      * @throws  IOException if I/O errors occur while writing to the underlying
 873      *          stream
 874      */
 875     public void writeUTF(String str) throws IOException {
 876         bout.writeUTF(str);
 877     }
 878 
 879     /**
 880      * Provide programmatic access to the persistent fields to be written
 881      * to ObjectOutput.
 882      *
 883      * @since 1.2
 884      */
 885     public abstract static class PutField {
<span class="line-added"> 886         /**</span>
<span class="line-added"> 887          * Constructor for subclasses to call.</span>
<span class="line-added"> 888          */</span>
<span class="line-added"> 889         public PutField() {}</span>
 890 
 891         /**
 892          * Put the value of the named boolean field into the persistent field.
 893          *
 894          * @param  name the name of the serializable field
 895          * @param  val the value to assign to the field
<span class="line-modified"> 896          * @throws IllegalArgumentException if {@code name} does not</span>
 897          * match the name of a serializable field for the class whose fields
 898          * are being written, or if the type of the named field is not
<span class="line-modified"> 899          * {@code boolean}</span>
 900          */
 901         public abstract void put(String name, boolean val);
 902 
 903         /**
 904          * Put the value of the named byte field into the persistent field.
 905          *
 906          * @param  name the name of the serializable field
 907          * @param  val the value to assign to the field
<span class="line-modified"> 908          * @throws IllegalArgumentException if {@code name} does not</span>
 909          * match the name of a serializable field for the class whose fields
 910          * are being written, or if the type of the named field is not
<span class="line-modified"> 911          * {@code byte}</span>
 912          */
 913         public abstract void put(String name, byte val);
 914 
 915         /**
 916          * Put the value of the named char field into the persistent field.
 917          *
 918          * @param  name the name of the serializable field
 919          * @param  val the value to assign to the field
<span class="line-modified"> 920          * @throws IllegalArgumentException if {@code name} does not</span>
 921          * match the name of a serializable field for the class whose fields
 922          * are being written, or if the type of the named field is not
<span class="line-modified"> 923          * {@code char}</span>
 924          */
 925         public abstract void put(String name, char val);
 926 
 927         /**
 928          * Put the value of the named short field into the persistent field.
 929          *
 930          * @param  name the name of the serializable field
 931          * @param  val the value to assign to the field
<span class="line-modified"> 932          * @throws IllegalArgumentException if {@code name} does not</span>
 933          * match the name of a serializable field for the class whose fields
 934          * are being written, or if the type of the named field is not
<span class="line-modified"> 935          * {@code short}</span>
 936          */
 937         public abstract void put(String name, short val);
 938 
 939         /**
 940          * Put the value of the named int field into the persistent field.
 941          *
 942          * @param  name the name of the serializable field
 943          * @param  val the value to assign to the field
<span class="line-modified"> 944          * @throws IllegalArgumentException if {@code name} does not</span>
 945          * match the name of a serializable field for the class whose fields
 946          * are being written, or if the type of the named field is not
<span class="line-modified"> 947          * {@code int}</span>
 948          */
 949         public abstract void put(String name, int val);
 950 
 951         /**
 952          * Put the value of the named long field into the persistent field.
 953          *
 954          * @param  name the name of the serializable field
 955          * @param  val the value to assign to the field
<span class="line-modified"> 956          * @throws IllegalArgumentException if {@code name} does not</span>
 957          * match the name of a serializable field for the class whose fields
 958          * are being written, or if the type of the named field is not
<span class="line-modified"> 959          * {@code long}</span>
 960          */
 961         public abstract void put(String name, long val);
 962 
 963         /**
 964          * Put the value of the named float field into the persistent field.
 965          *
 966          * @param  name the name of the serializable field
 967          * @param  val the value to assign to the field
<span class="line-modified"> 968          * @throws IllegalArgumentException if {@code name} does not</span>
 969          * match the name of a serializable field for the class whose fields
 970          * are being written, or if the type of the named field is not
<span class="line-modified"> 971          * {@code float}</span>
 972          */
 973         public abstract void put(String name, float val);
 974 
 975         /**
 976          * Put the value of the named double field into the persistent field.
 977          *
 978          * @param  name the name of the serializable field
 979          * @param  val the value to assign to the field
<span class="line-modified"> 980          * @throws IllegalArgumentException if {@code name} does not</span>
 981          * match the name of a serializable field for the class whose fields
 982          * are being written, or if the type of the named field is not
<span class="line-modified"> 983          * {@code double}</span>
 984          */
 985         public abstract void put(String name, double val);
 986 
 987         /**
 988          * Put the value of the named Object field into the persistent field.
 989          *
 990          * @param  name the name of the serializable field
 991          * @param  val the value to assign to the field
<span class="line-modified"> 992          *         (which may be {@code null})</span>
<span class="line-modified"> 993          * @throws IllegalArgumentException if {@code name} does not</span>
 994          * match the name of a serializable field for the class whose fields
 995          * are being written, or if the type of the named field is not a
 996          * reference type
 997          */
 998         public abstract void put(String name, Object val);
 999 
1000         /**
1001          * Write the data and fields to the specified ObjectOutput stream,
1002          * which must be the same stream that produced this
<span class="line-modified">1003          * {@code PutField} object.</span>
1004          *
1005          * @param  out the stream to write the data and fields to
1006          * @throws IOException if I/O errors occur while writing to the
1007          *         underlying stream
1008          * @throws IllegalArgumentException if the specified stream is not
<span class="line-modified">1009          *         the same stream that produced this {@code PutField}</span>
1010          *         object
1011          * @deprecated This method does not write the values contained by this
<span class="line-modified">1012          *         {@code PutField} object in a proper format, and may</span>
1013          *         result in corruption of the serialization stream.  The
<span class="line-modified">1014          *         correct way to write {@code PutField} data is by</span>
1015          *         calling the {@link java.io.ObjectOutputStream#writeFields()}
1016          *         method.
1017          */
1018         @Deprecated
1019         public abstract void write(ObjectOutput out) throws IOException;
1020     }
1021 
1022 
1023     /**
1024      * Returns protocol version in use.
1025      */
1026     int getProtocolVersion() {
1027         return protocol;
1028     }
1029 
1030     /**
1031      * Writes string without allowing it to be replaced in stream.  Used by
1032      * ObjectStreamClass to write class descriptor type strings.
1033      */
1034     void writeTypeString(String str) throws IOException {
</pre>
<hr />
<pre>
1418      * Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class,
1419      * ObjectStreamClass, array, or enum constant) serializable object to the
1420      * stream.
1421      */
1422     private void writeOrdinaryObject(Object obj,
1423                                      ObjectStreamClass desc,
1424                                      boolean unshared)
1425         throws IOException
1426     {
1427         if (extendedDebugInfo) {
1428             debugInfoStack.push(
1429                 (depth == 1 ? &quot;root &quot; : &quot;&quot;) + &quot;object (class \&quot;&quot; +
1430                 obj.getClass().getName() + &quot;\&quot;, &quot; + obj.toString() + &quot;)&quot;);
1431         }
1432         try {
1433             desc.checkSerialize();
1434 
1435             bout.writeByte(TC_OBJECT);
1436             writeClassDesc(desc, false);
1437             handles.assign(unshared ? null : obj);
<span class="line-modified">1438 </span>
<span class="line-added">1439             if (desc.isRecord()) {</span>
<span class="line-added">1440                 writeRecordData(obj, desc);</span>
<span class="line-added">1441             } else if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {</span>
1442                 writeExternalData((Externalizable) obj);
1443             } else {
1444                 writeSerialData(obj, desc);
1445             }
1446         } finally {
1447             if (extendedDebugInfo) {
1448                 debugInfoStack.pop();
1449             }
1450         }
1451     }
1452 
1453     /**
1454      * Writes externalizable data of given object by invoking its
1455      * writeExternal() method.
1456      */
1457     private void writeExternalData(Externalizable obj) throws IOException {
1458         PutFieldImpl oldPut = curPut;
1459         curPut = null;
1460 
1461         if (extendedDebugInfo) {
</pre>
<hr />
<pre>
1465         try {
1466             curContext = null;
1467             if (protocol == PROTOCOL_VERSION_1) {
1468                 obj.writeExternal(this);
1469             } else {
1470                 bout.setBlockDataMode(true);
1471                 obj.writeExternal(this);
1472                 bout.setBlockDataMode(false);
1473                 bout.writeByte(TC_ENDBLOCKDATA);
1474             }
1475         } finally {
1476             curContext = oldContext;
1477             if (extendedDebugInfo) {
1478                 debugInfoStack.pop();
1479             }
1480         }
1481 
1482         curPut = oldPut;
1483     }
1484 
<span class="line-added">1485     /** Writes the record component values for the given record object. */</span>
<span class="line-added">1486     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1487     private void writeRecordData(Object obj, ObjectStreamClass desc)</span>
<span class="line-added">1488         throws IOException</span>
<span class="line-added">1489     {</span>
<span class="line-added">1490         assert obj.getClass().isRecord();</span>
<span class="line-added">1491         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="line-added">1492         if (slots.length != 1) {</span>
<span class="line-added">1493             throw new InvalidClassException(</span>
<span class="line-added">1494                     &quot;expected a single record slot length, but found: &quot; + slots.length);</span>
<span class="line-added">1495         }</span>
<span class="line-added">1496 </span>
<span class="line-added">1497         defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors</span>
<span class="line-added">1498     }</span>
<span class="line-added">1499 </span>
1500     /**
1501      * Writes instance data for each serializable class of given object, from
1502      * superclass to subclass.
1503      */
1504     private void writeSerialData(Object obj, ObjectStreamClass desc)
1505         throws IOException
1506     {
1507         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
1508         for (int i = 0; i &lt; slots.length; i++) {
1509             ObjectStreamClass slotDesc = slots[i].desc;
1510             if (slotDesc.hasWriteObjectMethod()) {
1511                 PutFieldImpl oldPut = curPut;
1512                 curPut = null;
1513                 SerialCallbackContext oldContext = curContext;
1514 
1515                 if (extendedDebugInfo) {
1516                     debugInfoStack.push(
1517                         &quot;custom writeObject data (class \&quot;&quot; +
1518                         slotDesc.getName() + &quot;\&quot;)&quot;);
1519                 }
</pre>
<hr />
<pre>
1596          * Note: the serialization specification states that if a second
1597          * IOException occurs while attempting to serialize the original fatal
1598          * exception to the stream, then a StreamCorruptedException should be
1599          * thrown (section 2.1).  However, due to a bug in previous
1600          * implementations of serialization, StreamCorruptedExceptions were
1601          * rarely (if ever) actually thrown--the &quot;root&quot; exceptions from
1602          * underlying streams were thrown instead.  This historical behavior is
1603          * followed here for consistency.
1604          */
1605         clear();
1606         boolean oldMode = bout.setBlockDataMode(false);
1607         try {
1608             bout.writeByte(TC_EXCEPTION);
1609             writeObject0(ex, false);
1610             clear();
1611         } finally {
1612             bout.setBlockDataMode(oldMode);
1613         }
1614     }
1615 
















1616     /**
1617      * Default PutField implementation.
1618      */
1619     private class PutFieldImpl extends PutField {
1620 
1621         /** class descriptor describing serializable fields */
1622         private final ObjectStreamClass desc;
1623         /** primitive field values */
1624         private final byte[] primVals;
1625         /** object field values */
1626         private final Object[] objVals;
1627 
1628         /**
1629          * Creates PutFieldImpl object for writing fields defined in given
1630          * class descriptor.
1631          */
1632         PutFieldImpl(ObjectStreamClass desc) {
1633             this.desc = desc;
1634             primVals = new byte[desc.getPrimDataSize()];
1635             objVals = new Object[desc.getNumObjFields()];
</pre>
<hr />
<pre>
2085             while (off &lt; endoff) {
2086                 if (pos &lt;= limit) {
2087                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
2088                     int stop = Math.min(endoff, off + avail);
2089                     while (off &lt; stop) {
2090                         Bits.putInt(buf, pos, v[off++]);
2091                         pos += 4;
2092                     }
2093                 } else {
2094                     dout.writeInt(v[off++]);
2095                 }
2096             }
2097         }
2098 
2099         void writeFloats(float[] v, int off, int len) throws IOException {
2100             int limit = MAX_BLOCK_SIZE - 4;
2101             int endoff = off + len;
2102             while (off &lt; endoff) {
2103                 if (pos &lt;= limit) {
2104                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
<span class="line-modified">2105                     int stop = Math.min(endoff, off + avail);</span>
<span class="line-modified">2106                     while (off &lt; stop) {</span>
<span class="line-modified">2107                         Bits.putFloat(buf, pos, v[off++]);</span>
<span class="line-modified">2108                         pos += 4;</span>
<span class="line-added">2109                     }</span>
2110                 } else {
2111                     dout.writeFloat(v[off++]);
2112                 }
2113             }
2114         }
2115 
2116         void writeLongs(long[] v, int off, int len) throws IOException {
2117             int limit = MAX_BLOCK_SIZE - 8;
2118             int endoff = off + len;
2119             while (off &lt; endoff) {
2120                 if (pos &lt;= limit) {
2121                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
2122                     int stop = Math.min(endoff, off + avail);
2123                     while (off &lt; stop) {
2124                         Bits.putLong(buf, pos, v[off++]);
2125                         pos += 8;
2126                     }
2127                 } else {
2128                     dout.writeLong(v[off++]);
2129                 }
2130             }
2131         }
2132 
2133         void writeDoubles(double[] v, int off, int len) throws IOException {
2134             int limit = MAX_BLOCK_SIZE - 8;
2135             int endoff = off + len;
2136             while (off &lt; endoff) {
2137                 if (pos &lt;= limit) {
2138                     int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
<span class="line-modified">2139                     int stop = Math.min(endoff, off + avail);</span>
<span class="line-modified">2140                     while (off &lt; stop) {</span>
<span class="line-modified">2141                         Bits.putDouble(buf, pos, v[off++]);</span>
<span class="line-modified">2142                         pos += 8;</span>
<span class="line-added">2143                     }</span>
2144                 } else {
2145                     dout.writeDouble(v[off++]);
2146                 }
2147             }
2148         }
2149 
2150         /**
2151          * Returns the length in bytes of the UTF encoding of the given string.
2152          */
2153         long getUTFLength(String s) {
2154             int len = s.length();
2155             long utflen = 0;
2156             for (int off = 0; off &lt; len; ) {
2157                 int csize = Math.min(len - off, CHAR_BUF_SIZE);
2158                 s.getChars(off, off + csize, cbuf, 0);
2159                 for (int cpos = 0; cpos &lt; csize; cpos++) {
2160                     char c = cbuf[cpos];
2161                     if (c &gt;= 0x0001 &amp;&amp; c &lt;= 0x007F) {
2162                         utflen++;
2163                     } else if (c &gt; 0x07FF) {
</pre>
</td>
</tr>
</table>
<center><a href="ObjectOutput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamClass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/ChoiceFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CharacterIteratorFieldDelegate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CollationElementIterator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/ChoiceFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.InvalidObjectException;
 42 import java.io.IOException;
 43 import java.io.ObjectInputStream;
 44 import java.util.Arrays;
 45 
 46 /**
<span class="line-modified"> 47  * A &lt;code&gt;ChoiceFormat&lt;/code&gt; allows you to attach a format to a range of numbers.</span>
<span class="line-modified"> 48  * It is generally used in a &lt;code&gt;MessageFormat&lt;/code&gt; for handling plurals.</span>
 49  * The choice is specified with an ascending list of doubles, where each item
 50  * specifies a half-open interval up to the next item:
 51  * &lt;blockquote&gt;
 52  * &lt;pre&gt;
 53  * X matches j if and only if limit[j] &amp;le; X &amp;lt; limit[j+1]
 54  * &lt;/pre&gt;
 55  * &lt;/blockquote&gt;
 56  * If there is no match, then either the first or last index is used, depending
 57  * on whether the number (X) is too low or too high.  If the limit array is not
 58  * in ascending order, the results of formatting will be incorrect.  ChoiceFormat
 59  * also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
 60  *
 61  * &lt;p&gt;
 62  * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified"> 63  * &lt;code&gt;ChoiceFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified"> 64  * classes in that you create a &lt;code&gt;ChoiceFormat&lt;/code&gt; object with a</span>
<span class="line-modified"> 65  * constructor (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory</span>
<span class="line-modified"> 66  * method). The factory methods aren&#39;t necessary because &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
 67  * doesn&#39;t require any complex setup for a given locale. In fact,
<span class="line-modified"> 68  * &lt;code&gt;ChoiceFormat&lt;/code&gt; doesn&#39;t implement any locale specific behavior.</span>
 69  *
 70  * &lt;p&gt;
<span class="line-modified"> 71  * When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats</span>
 72  * and an array of limits. The length of these arrays must be the same.
 73  * For example,
 74  * &lt;ul&gt;
 75  * &lt;li&gt;
 76  *     &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
 77  *     &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
 78  * &lt;li&gt;
 79  *     &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
 80  *     &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
<span class="line-modified"> 81  *     (&lt;code&gt;nextDouble&lt;/code&gt; can be used to get the next higher double, to</span>
 82  *     make the half-open interval.)
 83  * &lt;/ul&gt;
 84  *
 85  * &lt;p&gt;
 86  * Here is a simple example that shows formatting and parsing:
 87  * &lt;blockquote&gt;
 88  * &lt;pre&gt;{@code
 89  * double[] limits = {1,2,3,4,5,6,7};
 90  * String[] dayOfWeekNames = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;};
 91  * ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
 92  * ParsePosition status = new ParsePosition(0);
 93  * for (double i = 0.0; i &lt;= 8.0; ++i) {
 94  *     status.setIndex(0);
 95  *     System.out.println(i + &quot; -&gt; &quot; + form.format(i) + &quot; -&gt; &quot;
 96  *                              + form.parse(form.format(i),status));
 97  * }
 98  * }&lt;/pre&gt;
 99  * &lt;/blockquote&gt;
100  * Here is a more complex example, with a pattern format:
101  * &lt;blockquote&gt;
</pre>
<hr />
<pre>
134  * System.out.println(&quot;Format with NaN : &quot; + fmt.format(Double.NaN));
135  * System.out.println(&quot;Format with +INF : &quot; + fmt.format(Double.POSITIVE_INFINITY));
136  * }&lt;/pre&gt;
137  * &lt;/blockquote&gt;
138  * And the output result would be like the following:
139  * &lt;blockquote&gt;
140  * &lt;pre&gt;{@code
141  * Format with -INF : is negative
142  * Format with -1.0 : is negative
143  * Format with 0 : is zero or fraction
144  * Format with 0.9 : is zero or fraction
145  * Format with 1.0 : is one
146  * Format with 1.5 : is 1+
147  * Format with 2 : is two
148  * Format with 2.1 : is more than 2.
149  * Format with NaN : is negative
150  * Format with +INF : is more than 2.
151  * }&lt;/pre&gt;
152  * &lt;/blockquote&gt;
153  *
<span class="line-modified">154  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
155  *
156  * &lt;p&gt;
157  * Choice formats are not synchronized.
158  * It is recommended to create separate format instances for each thread.
159  * If multiple threads access a format concurrently, it must be synchronized
160  * externally.
161  *
162  *
163  * @see          DecimalFormat
164  * @see          MessageFormat
165  * @author       Mark Davis
166  * @since 1.1
167  */
168 public class ChoiceFormat extends NumberFormat {
169 
170     // Proclaim serial compatibility with 1.1 FCS

171     private static final long serialVersionUID = 1795184449645032964L;
172 
173     /**
174      * Sets the pattern.
175      * @param newPattern See the class description.
<span class="line-modified">176      * @exception NullPointerException if {@code newPattern}</span>
177      *            is {@code null}
178      */
179     public void applyPattern(String newPattern) {
180         StringBuffer[] segments = new StringBuffer[2];
181         for (int i = 0; i &lt; segments.length; ++i) {
182             segments[i] = new StringBuffer();
183         }
184         double[] newChoiceLimits = new double[30];
185         String[] newChoiceFormats = new String[30];
186         int count = 0;
187         int part = 0;
188         double startValue = 0;
189         double oldStartValue = Double.NaN;
190         boolean inQuote = false;
191         for (int i = 0; i &lt; newPattern.length(); ++i) {
192             char ch = newPattern.charAt(i);
193             if (ch==&#39;\&#39;&#39;) {
194                 // Check for &quot;&#39;&#39;&quot; indicating a literal quote
195                 if ((i+1)&lt;newPattern.length() &amp;&amp; newPattern.charAt(i+1)==ch) {
196                     segments[part].append(ch);
</pre>
<hr />
<pre>
295                 || text.indexOf(&#39;\u2264&#39;) &gt;= 0
296                 || text.indexOf(&#39;|&#39;) &gt;= 0;
297             if (needQuote) result.append(&#39;\&#39;&#39;);
298             if (text.indexOf(&#39;\&#39;&#39;) &lt; 0) result.append(text);
299             else {
300                 for (int j=0; j&lt;text.length(); ++j) {
301                     char c = text.charAt(j);
302                     result.append(c);
303                     if (c == &#39;\&#39;&#39;) result.append(c);
304                 }
305             }
306             if (needQuote) result.append(&#39;\&#39;&#39;);
307         }
308         return result.toString();
309     }
310 
311     /**
312      * Constructs with limits and corresponding formats based on the pattern.
313      *
314      * @param newPattern the new pattern string
<span class="line-modified">315      * @exception NullPointerException if {@code newPattern} is</span>
316      *            {@code null}
317      * @see #applyPattern
318      */
319     public ChoiceFormat(String newPattern)  {
320         applyPattern(newPattern);
321     }
322 
323     /**
324      * Constructs with the limits and the corresponding formats.
325      *
326      * @param limits limits in ascending order
327      * @param formats corresponding format strings
<span class="line-modified">328      * @exception NullPointerException if {@code limits} or {@code formats}</span>
329      *            is {@code null}
330      * @see #setChoices
331      */
332     public ChoiceFormat(double[] limits, String[] formats) {
333         setChoices(limits, formats);
334     }
335 
336     /**
337      * Set the choices to be used in formatting.
338      * @param limits contains the top value that you want
339      * parsed with that format, and should be in ascending sorted order. When
340      * formatting X, the choice will be the i, where
341      * limit[i] &amp;le; X {@literal &lt;} limit[i+1].
342      * If the limit array is not in ascending order, the results of formatting
343      * will be incorrect.
344      * @param formats are the formats you want to use for each limit.
345      * They can be either Format objects or Strings.
346      * When formatting with object Y,
347      * if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
348      * is called. Otherwise Y.toString() is called.
<span class="line-modified">349      * @exception NullPointerException if {@code limits} or</span>
350      *            {@code formats} is {@code null}
351      */
352     public void setChoices(double[] limits, String formats[]) {
353         if (limits.length != formats.length) {
354             throw new IllegalArgumentException(
355                 &quot;Array and limit arrays must be of the same length.&quot;);
356         }
357         choiceLimits = Arrays.copyOf(limits, limits.length);
358         choiceFormats = Arrays.copyOf(formats, formats.length);
359     }
360 
361     /**
362      * Get the limits passed in the constructor.
363      * @return the limits.
364      */
365     public double[] getLimits() {
366         double[] newLimits = Arrays.copyOf(choiceLimits, choiceLimits.length);
367         return newLimits;
368     }
369 
370     /**
371      * Get the formats passed in the constructor.
372      * @return the formats.
373      */
374     public Object[] getFormats() {
375         Object[] newFormats = Arrays.copyOf(choiceFormats, choiceFormats.length);
376         return newFormats;
377     }
378 
379     // Overrides
380 
381     /**
382      * Specialization of format. This method really calls
<span class="line-modified">383      * &lt;code&gt;format(double, StringBuffer, FieldPosition)&lt;/code&gt;</span>
384      * thus the range of longs that are supported is only equal to
385      * the range that can be stored by double. This will never be
386      * a practical limitation.
387      */
388     public StringBuffer format(long number, StringBuffer toAppendTo,
389                                FieldPosition status) {
390         return format((double)number, toAppendTo, status);
391     }
392 
393     /**
394      * Returns pattern with formatted double.
395      * @param number number to be formatted and substituted.
396      * @param toAppendTo where text is appended.
397      * @param status ignore no useful status is returned.
<span class="line-modified">398      * @exception NullPointerException if {@code toAppendTo}</span>
399      *            is {@code null}
400      */
401    public StringBuffer format(double number, StringBuffer toAppendTo,
402                                FieldPosition status) {
403         // find the number
404         int i;
405         for (i = 0; i &lt; choiceLimits.length; ++i) {
406             if (!(number &gt;= choiceLimits[i])) {
407                 // same as number &lt; choiceLimits, except catchs NaN
408                 break;
409             }
410         }
411         --i;
412         if (i &lt; 0) i = 0;
413         // return either a formatted number, or a string
414         return toAppendTo.append(choiceFormats[i]);
415     }
416 
417     /**
418      * Parses a Number from the input text.
419      * @param text the source text.
420      * @param status an input-output parameter.  On input, the
421      * status.index field indicates the first character of the
422      * source text that should be parsed.  On exit, if no error
423      * occurred, status.index is set to the first unparsed character
424      * in the source text.  On exit, if an error did occur,
425      * status.index is unchanged and status.errorIndex is set to the
426      * first index of the character that caused the parse to fail.
427      * @return A Number representing the value of the number parsed.
<span class="line-modified">428      * @exception NullPointerException if {@code status} is {@code null}</span>
429      *            or if {@code text} is {@code null} and the list of
430      *            choice strings is not empty.
431      */
432     public Number parse(String text, ParsePosition status) {
433         // find the best number (defined as the one with the longest parse)
434         int start = status.index;
435         int furthest = start;
436         double bestNumber = Double.NaN;
437         double tempNumber = 0.0;
438         for (int i = 0; i &lt; choiceFormats.length; ++i) {
439             String tempString = choiceFormats[i];
440             if (text.regionMatches(start, tempString, 0, tempString.length())) {
441                 status.index = start + tempString.length();
442                 tempNumber = choiceLimits[i];
443                 if (status.index &gt; furthest) {
444                     furthest = status.index;
445                     bestNumber = tempNumber;
446                     if (furthest == text.length()) break;
447                 }
448             }
</pre>
<hr />
<pre>
511 
512     /**
513      * Equality comparison between two
514      */
515     public boolean equals(Object obj) {
516         if (obj == null) return false;
517         if (this == obj)                      // quick check
518             return true;
519         if (getClass() != obj.getClass())
520             return false;
521         ChoiceFormat other = (ChoiceFormat) obj;
522         return (Arrays.equals(choiceLimits, other.choiceLimits)
523              &amp;&amp; Arrays.equals(choiceFormats, other.choiceFormats));
524     }
525 
526     /**
527      * After reading an object from the input stream, do a simple verification
528      * to maintain class invariants.
529      * @throws InvalidObjectException if the objects read from the stream is invalid.
530      */

531     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
532         in.defaultReadObject();
533         if (choiceLimits.length != choiceFormats.length) {
534             throw new InvalidObjectException(
535                     &quot;limits and format arrays of different length.&quot;);
536         }
537     }
538 
539     // ===============privates===========================
540 
541     /**
542      * A list of lower bounds for the choices.  The formatter will return
<span class="line-modified">543      * &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to</span>
<span class="line-modified">544      * &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.</span>
545      * @serial
546      */
547     private double[] choiceLimits;
548 
549     /**
550      * A list of choice strings.  The formatter will return
<span class="line-modified">551      * &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to</span>
<span class="line-modified">552      * &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.</span>
553      * @serial
554      */
555     private String[] choiceFormats;
556 
557     /**
558      * Finds the least double greater than {@code d} (if {@code positive} is
559      * {@code true}), or the greatest double less than {@code d} (if
560      * {@code positive} is {@code false}).
561      * If {@code NaN}, returns same value.
562      *
563      * @implNote This is equivalent to calling
564      * {@code positive ? Math.nextUp(d) : Math.nextDown(d)}
565      *
566      * @param d        the reference value
567      * @param positive {@code true} if the least double is desired;
568      *                 {@code false} otherwise
569      * @return the least or greater double value
570      */
571     public static double nextDouble (double d, boolean positive) {
572         return positive ? Math.nextUp(d) : Math.nextDown(d);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.InvalidObjectException;
 42 import java.io.IOException;
 43 import java.io.ObjectInputStream;
 44 import java.util.Arrays;
 45 
 46 /**
<span class="line-modified"> 47  * A {@code ChoiceFormat} allows you to attach a format to a range of numbers.</span>
<span class="line-modified"> 48  * It is generally used in a {@code MessageFormat} for handling plurals.</span>
 49  * The choice is specified with an ascending list of doubles, where each item
 50  * specifies a half-open interval up to the next item:
 51  * &lt;blockquote&gt;
 52  * &lt;pre&gt;
 53  * X matches j if and only if limit[j] &amp;le; X &amp;lt; limit[j+1]
 54  * &lt;/pre&gt;
 55  * &lt;/blockquote&gt;
 56  * If there is no match, then either the first or last index is used, depending
 57  * on whether the number (X) is too low or too high.  If the limit array is not
 58  * in ascending order, the results of formatting will be incorrect.  ChoiceFormat
 59  * also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
 60  *
 61  * &lt;p&gt;
 62  * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified"> 63  * {@code ChoiceFormat} differs from the other {@code Format}</span>
<span class="line-modified"> 64  * classes in that you create a {@code ChoiceFormat} object with a</span>
<span class="line-modified"> 65  * constructor (not with a {@code getInstance} style factory</span>
<span class="line-modified"> 66  * method). The factory methods aren&#39;t necessary because {@code ChoiceFormat}</span>
 67  * doesn&#39;t require any complex setup for a given locale. In fact,
<span class="line-modified"> 68  * {@code ChoiceFormat} doesn&#39;t implement any locale specific behavior.</span>
 69  *
 70  * &lt;p&gt;
<span class="line-modified"> 71  * When creating a {@code ChoiceFormat}, you must specify an array of formats</span>
 72  * and an array of limits. The length of these arrays must be the same.
 73  * For example,
 74  * &lt;ul&gt;
 75  * &lt;li&gt;
 76  *     &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
 77  *     &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
 78  * &lt;li&gt;
 79  *     &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
 80  *     &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
<span class="line-modified"> 81  *     ({@code nextDouble} can be used to get the next higher double, to</span>
 82  *     make the half-open interval.)
 83  * &lt;/ul&gt;
 84  *
 85  * &lt;p&gt;
 86  * Here is a simple example that shows formatting and parsing:
 87  * &lt;blockquote&gt;
 88  * &lt;pre&gt;{@code
 89  * double[] limits = {1,2,3,4,5,6,7};
 90  * String[] dayOfWeekNames = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;};
 91  * ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
 92  * ParsePosition status = new ParsePosition(0);
 93  * for (double i = 0.0; i &lt;= 8.0; ++i) {
 94  *     status.setIndex(0);
 95  *     System.out.println(i + &quot; -&gt; &quot; + form.format(i) + &quot; -&gt; &quot;
 96  *                              + form.parse(form.format(i),status));
 97  * }
 98  * }&lt;/pre&gt;
 99  * &lt;/blockquote&gt;
100  * Here is a more complex example, with a pattern format:
101  * &lt;blockquote&gt;
</pre>
<hr />
<pre>
134  * System.out.println(&quot;Format with NaN : &quot; + fmt.format(Double.NaN));
135  * System.out.println(&quot;Format with +INF : &quot; + fmt.format(Double.POSITIVE_INFINITY));
136  * }&lt;/pre&gt;
137  * &lt;/blockquote&gt;
138  * And the output result would be like the following:
139  * &lt;blockquote&gt;
140  * &lt;pre&gt;{@code
141  * Format with -INF : is negative
142  * Format with -1.0 : is negative
143  * Format with 0 : is zero or fraction
144  * Format with 0.9 : is zero or fraction
145  * Format with 1.0 : is one
146  * Format with 1.5 : is 1+
147  * Format with 2 : is two
148  * Format with 2.1 : is more than 2.
149  * Format with NaN : is negative
150  * Format with +INF : is more than 2.
151  * }&lt;/pre&gt;
152  * &lt;/blockquote&gt;
153  *
<span class="line-modified">154  * &lt;h2&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h2&gt;</span>
155  *
156  * &lt;p&gt;
157  * Choice formats are not synchronized.
158  * It is recommended to create separate format instances for each thread.
159  * If multiple threads access a format concurrently, it must be synchronized
160  * externally.
161  *
162  *
163  * @see          DecimalFormat
164  * @see          MessageFormat
165  * @author       Mark Davis
166  * @since 1.1
167  */
168 public class ChoiceFormat extends NumberFormat {
169 
170     // Proclaim serial compatibility with 1.1 FCS
<span class="line-added">171     @java.io.Serial</span>
172     private static final long serialVersionUID = 1795184449645032964L;
173 
174     /**
175      * Sets the pattern.
176      * @param newPattern See the class description.
<span class="line-modified">177      * @throws    NullPointerException if {@code newPattern}</span>
178      *            is {@code null}
179      */
180     public void applyPattern(String newPattern) {
181         StringBuffer[] segments = new StringBuffer[2];
182         for (int i = 0; i &lt; segments.length; ++i) {
183             segments[i] = new StringBuffer();
184         }
185         double[] newChoiceLimits = new double[30];
186         String[] newChoiceFormats = new String[30];
187         int count = 0;
188         int part = 0;
189         double startValue = 0;
190         double oldStartValue = Double.NaN;
191         boolean inQuote = false;
192         for (int i = 0; i &lt; newPattern.length(); ++i) {
193             char ch = newPattern.charAt(i);
194             if (ch==&#39;\&#39;&#39;) {
195                 // Check for &quot;&#39;&#39;&quot; indicating a literal quote
196                 if ((i+1)&lt;newPattern.length() &amp;&amp; newPattern.charAt(i+1)==ch) {
197                     segments[part].append(ch);
</pre>
<hr />
<pre>
296                 || text.indexOf(&#39;\u2264&#39;) &gt;= 0
297                 || text.indexOf(&#39;|&#39;) &gt;= 0;
298             if (needQuote) result.append(&#39;\&#39;&#39;);
299             if (text.indexOf(&#39;\&#39;&#39;) &lt; 0) result.append(text);
300             else {
301                 for (int j=0; j&lt;text.length(); ++j) {
302                     char c = text.charAt(j);
303                     result.append(c);
304                     if (c == &#39;\&#39;&#39;) result.append(c);
305                 }
306             }
307             if (needQuote) result.append(&#39;\&#39;&#39;);
308         }
309         return result.toString();
310     }
311 
312     /**
313      * Constructs with limits and corresponding formats based on the pattern.
314      *
315      * @param newPattern the new pattern string
<span class="line-modified">316      * @throws    NullPointerException if {@code newPattern} is</span>
317      *            {@code null}
318      * @see #applyPattern
319      */
320     public ChoiceFormat(String newPattern)  {
321         applyPattern(newPattern);
322     }
323 
324     /**
325      * Constructs with the limits and the corresponding formats.
326      *
327      * @param limits limits in ascending order
328      * @param formats corresponding format strings
<span class="line-modified">329      * @throws    NullPointerException if {@code limits} or {@code formats}</span>
330      *            is {@code null}
331      * @see #setChoices
332      */
333     public ChoiceFormat(double[] limits, String[] formats) {
334         setChoices(limits, formats);
335     }
336 
337     /**
338      * Set the choices to be used in formatting.
339      * @param limits contains the top value that you want
340      * parsed with that format, and should be in ascending sorted order. When
341      * formatting X, the choice will be the i, where
342      * limit[i] &amp;le; X {@literal &lt;} limit[i+1].
343      * If the limit array is not in ascending order, the results of formatting
344      * will be incorrect.
345      * @param formats are the formats you want to use for each limit.
346      * They can be either Format objects or Strings.
347      * When formatting with object Y,
348      * if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
349      * is called. Otherwise Y.toString() is called.
<span class="line-modified">350      * @throws    NullPointerException if {@code limits} or</span>
351      *            {@code formats} is {@code null}
352      */
353     public void setChoices(double[] limits, String formats[]) {
354         if (limits.length != formats.length) {
355             throw new IllegalArgumentException(
356                 &quot;Array and limit arrays must be of the same length.&quot;);
357         }
358         choiceLimits = Arrays.copyOf(limits, limits.length);
359         choiceFormats = Arrays.copyOf(formats, formats.length);
360     }
361 
362     /**
363      * Get the limits passed in the constructor.
364      * @return the limits.
365      */
366     public double[] getLimits() {
367         double[] newLimits = Arrays.copyOf(choiceLimits, choiceLimits.length);
368         return newLimits;
369     }
370 
371     /**
372      * Get the formats passed in the constructor.
373      * @return the formats.
374      */
375     public Object[] getFormats() {
376         Object[] newFormats = Arrays.copyOf(choiceFormats, choiceFormats.length);
377         return newFormats;
378     }
379 
380     // Overrides
381 
382     /**
383      * Specialization of format. This method really calls
<span class="line-modified">384      * {@code format(double, StringBuffer, FieldPosition)}</span>
385      * thus the range of longs that are supported is only equal to
386      * the range that can be stored by double. This will never be
387      * a practical limitation.
388      */
389     public StringBuffer format(long number, StringBuffer toAppendTo,
390                                FieldPosition status) {
391         return format((double)number, toAppendTo, status);
392     }
393 
394     /**
395      * Returns pattern with formatted double.
396      * @param number number to be formatted and substituted.
397      * @param toAppendTo where text is appended.
398      * @param status ignore no useful status is returned.
<span class="line-modified">399      * @throws    NullPointerException if {@code toAppendTo}</span>
400      *            is {@code null}
401      */
402    public StringBuffer format(double number, StringBuffer toAppendTo,
403                                FieldPosition status) {
404         // find the number
405         int i;
406         for (i = 0; i &lt; choiceLimits.length; ++i) {
407             if (!(number &gt;= choiceLimits[i])) {
408                 // same as number &lt; choiceLimits, except catchs NaN
409                 break;
410             }
411         }
412         --i;
413         if (i &lt; 0) i = 0;
414         // return either a formatted number, or a string
415         return toAppendTo.append(choiceFormats[i]);
416     }
417 
418     /**
419      * Parses a Number from the input text.
420      * @param text the source text.
421      * @param status an input-output parameter.  On input, the
422      * status.index field indicates the first character of the
423      * source text that should be parsed.  On exit, if no error
424      * occurred, status.index is set to the first unparsed character
425      * in the source text.  On exit, if an error did occur,
426      * status.index is unchanged and status.errorIndex is set to the
427      * first index of the character that caused the parse to fail.
428      * @return A Number representing the value of the number parsed.
<span class="line-modified">429      * @throws    NullPointerException if {@code status} is {@code null}</span>
430      *            or if {@code text} is {@code null} and the list of
431      *            choice strings is not empty.
432      */
433     public Number parse(String text, ParsePosition status) {
434         // find the best number (defined as the one with the longest parse)
435         int start = status.index;
436         int furthest = start;
437         double bestNumber = Double.NaN;
438         double tempNumber = 0.0;
439         for (int i = 0; i &lt; choiceFormats.length; ++i) {
440             String tempString = choiceFormats[i];
441             if (text.regionMatches(start, tempString, 0, tempString.length())) {
442                 status.index = start + tempString.length();
443                 tempNumber = choiceLimits[i];
444                 if (status.index &gt; furthest) {
445                     furthest = status.index;
446                     bestNumber = tempNumber;
447                     if (furthest == text.length()) break;
448                 }
449             }
</pre>
<hr />
<pre>
512 
513     /**
514      * Equality comparison between two
515      */
516     public boolean equals(Object obj) {
517         if (obj == null) return false;
518         if (this == obj)                      // quick check
519             return true;
520         if (getClass() != obj.getClass())
521             return false;
522         ChoiceFormat other = (ChoiceFormat) obj;
523         return (Arrays.equals(choiceLimits, other.choiceLimits)
524              &amp;&amp; Arrays.equals(choiceFormats, other.choiceFormats));
525     }
526 
527     /**
528      * After reading an object from the input stream, do a simple verification
529      * to maintain class invariants.
530      * @throws InvalidObjectException if the objects read from the stream is invalid.
531      */
<span class="line-added">532     @java.io.Serial</span>
533     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
534         in.defaultReadObject();
535         if (choiceLimits.length != choiceFormats.length) {
536             throw new InvalidObjectException(
537                     &quot;limits and format arrays of different length.&quot;);
538         }
539     }
540 
541     // ===============privates===========================
542 
543     /**
544      * A list of lower bounds for the choices.  The formatter will return
<span class="line-modified">545      * {@code choiceFormats[i]} if the number being formatted is greater than or equal to</span>
<span class="line-modified">546      * {@code choiceLimits[i]} and less than {@code choiceLimits[i+1]}.</span>
547      * @serial
548      */
549     private double[] choiceLimits;
550 
551     /**
552      * A list of choice strings.  The formatter will return
<span class="line-modified">553      * {@code choiceFormats[i]} if the number being formatted is greater than or equal to</span>
<span class="line-modified">554      * {@code choiceLimits[i]} and less than {@code choiceLimits[i+1]}.</span>
555      * @serial
556      */
557     private String[] choiceFormats;
558 
559     /**
560      * Finds the least double greater than {@code d} (if {@code positive} is
561      * {@code true}), or the greatest double less than {@code d} (if
562      * {@code positive} is {@code false}).
563      * If {@code NaN}, returns same value.
564      *
565      * @implNote This is equivalent to calling
566      * {@code positive ? Math.nextUp(d) : Math.nextDown(d)}
567      *
568      * @param d        the reference value
569      * @param positive {@code true} if the least double is desired;
570      *                 {@code false} otherwise
571      * @return the least or greater double value
572      */
573     public static double nextDouble (double d, boolean positive) {
574         return positive ? Math.nextUp(d) : Math.nextDown(d);
</pre>
</td>
</tr>
</table>
<center><a href="CharacterIteratorFieldDelegate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CollationElementIterator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
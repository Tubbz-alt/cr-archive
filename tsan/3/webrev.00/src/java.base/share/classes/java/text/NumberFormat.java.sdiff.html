<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/NumberFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Normalizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ParseException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/NumberFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.io.ObjectOutputStream;
  45 import java.math.BigInteger;
  46 import java.math.RoundingMode;
  47 import java.text.spi.NumberFormatProvider;
  48 import java.util.Currency;
  49 import java.util.HashMap;
  50 import java.util.Locale;
  51 import java.util.Map;
  52 import java.util.Objects;
  53 import java.util.concurrent.atomic.AtomicInteger;
  54 import java.util.concurrent.atomic.AtomicLong;
  55 import sun.util.locale.provider.LocaleProviderAdapter;
  56 import sun.util.locale.provider.LocaleServiceProviderPool;
  57 
  58 /**
<span class="line-modified">  59  * &lt;code&gt;NumberFormat&lt;/code&gt; is the abstract base class for all number</span>
  60  * formats. This class provides the interface for formatting and parsing
<span class="line-modified">  61  * numbers. &lt;code&gt;NumberFormat&lt;/code&gt; also provides methods for determining</span>
  62  * which locales have number formats, and what their names are.
  63  *
  64  * &lt;p&gt;
<span class="line-modified">  65  * &lt;code&gt;NumberFormat&lt;/code&gt; helps you to format and parse numbers for any locale.</span>
  66  * Your code can be completely independent of the locale conventions for
  67  * decimal points, thousands-separators, or even the particular decimal
  68  * digits used, or whether the number format is even decimal.
  69  *
  70  * &lt;p&gt;
  71  * To format a number for the current Locale, use one of the factory
  72  * class methods:
  73  * &lt;blockquote&gt;
  74  * &lt;pre&gt;{@code
  75  * myString = NumberFormat.getInstance().format(myNumber);
  76  * }&lt;/pre&gt;
  77  * &lt;/blockquote&gt;
  78  * If you are formatting multiple numbers, it is
  79  * more efficient to get the format and use it multiple times so that
  80  * the system doesn&#39;t have to fetch the information about the local
  81  * language and country conventions multiple times.
  82  * &lt;blockquote&gt;
  83  * &lt;pre&gt;{@code
  84  * NumberFormat nf = NumberFormat.getInstance();
  85  * for (int i = 0; i &lt; myNumber.length; ++i) {
  86  *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
  87  * }
  88  * }&lt;/pre&gt;
  89  * &lt;/blockquote&gt;
  90  * To format a number for a different Locale, specify it in the
<span class="line-modified">  91  * call to &lt;code&gt;getInstance&lt;/code&gt;.</span>
  92  * &lt;blockquote&gt;
  93  * &lt;pre&gt;{@code
  94  * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
  95  * }&lt;/pre&gt;
  96  * &lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;If the locale contains &quot;nu&quot; (numbers) and/or &quot;rg&quot; (region override)
  99  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
 100  * the decimal digits, and/or the country used for formatting are overridden.
 101  * If both &quot;nu&quot; and &quot;rg&quot; are specified, the decimal digits from the &quot;nu&quot;
 102  * extension supersedes the implicit one from the &quot;rg&quot; extension.
 103  *
 104  * &lt;p&gt;You can also use a {@code NumberFormat} to parse numbers:
 105  * &lt;blockquote&gt;
 106  * &lt;pre&gt;{@code
 107  * myNumber = nf.parse(myString);
 108  * }&lt;/pre&gt;
 109  * &lt;/blockquote&gt;
<span class="line-modified"> 110  * Use &lt;code&gt;getInstance&lt;/code&gt; or &lt;code&gt;getNumberInstance&lt;/code&gt; to get the</span>
<span class="line-modified"> 111  * normal number format. Use &lt;code&gt;getIntegerInstance&lt;/code&gt; to get an</span>
<span class="line-modified"> 112  * integer number format. Use &lt;code&gt;getCurrencyInstance&lt;/code&gt; to get the</span>
 113  * currency number format. Use {@code getCompactNumberInstance} to get the
 114  * compact number format to format a number in shorter form. For example,
 115  * {@code 2000} can be formatted as {@code &quot;2K&quot;} in
<span class="line-modified"> 116  * {@link java.util.Locale#US US locale}. Use &lt;code&gt;getPercentInstance&lt;/code&gt;</span>
 117  * to get a format for displaying percentages. With this format, a fraction
 118  * like 0.53 is displayed as 53%.
 119  *
 120  * &lt;p&gt;
 121  * You can also control the display of numbers with such methods as
<span class="line-modified"> 122  * &lt;code&gt;setMinimumFractionDigits&lt;/code&gt;.</span>
 123  * If you want even more control over the format or parsing,
 124  * or want to give your users more control,
<span class="line-modified"> 125  * you can try casting the &lt;code&gt;NumberFormat&lt;/code&gt; you get from the factory methods</span>
 126  * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on
 127  * the factory method used. This will work for the vast majority of locales;
<span class="line-modified"> 128  * just remember to put it in a &lt;code&gt;try&lt;/code&gt; block in case you encounter</span>
 129  * an unusual one.
 130  *
 131  * &lt;p&gt;
 132  * NumberFormat and DecimalFormat are designed such that some controls
 133  * work for formatting and others work for parsing.  The following is
 134  * the detailed description for each these control methods,
 135  * &lt;p&gt;
 136  * setParseIntegerOnly : only affects parsing, e.g.
 137  * if true,  &quot;3456.78&quot; &amp;rarr; 3456 (and leaves the parse position just after index 6)
 138  * if false, &quot;3456.78&quot; &amp;rarr; 3456.78 (and leaves the parse position just after index 8)
 139  * This is independent of formatting.  If you want to not show a decimal point
 140  * where there might be no digits after the decimal point, use
 141  * setDecimalSeparatorAlwaysShown.
 142  * &lt;p&gt;
 143  * setDecimalSeparatorAlwaysShown : only affects formatting, and only where
 144  * there might be no digits after the decimal point, such as with a pattern
 145  * like &quot;#,##0.##&quot;, e.g.,
 146  * if true,  3456.00 &amp;rarr; &quot;3,456.&quot;
 147  * if false, 3456.00 &amp;rarr; &quot;3456&quot;
 148  * This is independent of parsing.  If you want parsing to stop at the decimal
 149  * point, use setParseIntegerOnly.
 150  *
 151  * &lt;p&gt;
<span class="line-modified"> 152  * You can also use forms of the &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt;</span>
<span class="line-modified"> 153  * methods with &lt;code&gt;ParsePosition&lt;/code&gt; and &lt;code&gt;FieldPosition&lt;/code&gt; to</span>
 154  * allow you to:
 155  * &lt;ul&gt;
 156  * &lt;li&gt; progressively parse through pieces of a string
 157  * &lt;li&gt; align the decimal point and other areas
 158  * &lt;/ul&gt;
 159  * For example, you can align numbers in two ways:
 160  * &lt;ol&gt;
 161  * &lt;li&gt; If you are using a monospaced font with spacing for alignment,
<span class="line-modified"> 162  *      you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with</span>
<span class="line-modified"> 163  *      &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output,</span>
<span class="line-modified"> 164  *      &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the</span>
 165  *      last character of the integer and the decimal. Add
 166  *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
 167  *
 168  * &lt;li&gt; If you are using proportional fonts,
 169  *      instead of padding with spaces, measure the width
<span class="line-modified"> 170  *      of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;.</span>
 171  *      Then move the pen by
 172  *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
 173  *      It also works where there is no decimal, but possibly additional
 174  *      characters at the end, e.g., with parentheses in negative
 175  *      numbers: &quot;(12)&quot; for -12.
 176  * &lt;/ol&gt;
 177  *
<span class="line-modified"> 178  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
 179  *
 180  * &lt;p&gt;
 181  * Number formats are generally not synchronized.
 182  * It is recommended to create separate format instances for each thread.
 183  * If multiple threads access a format concurrently, it must be synchronized
 184  * externally.
 185  *
 186  * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},
 187  * {@link #format(long, StringBuffer, FieldPosition)} and
 188  * {@link #parse(String, ParsePosition)} methods may throw
 189  * {@code NullPointerException}, if any of their parameter is {@code null}.
 190  * The subclass may provide its own implementation and specification about
 191  * {@code NullPointerException}.
 192  *
 193  * &lt;p&gt;
 194  * The default implementation provides rounding modes defined
 195  * in {@link java.math.RoundingMode} for formatting numbers. It
 196  * uses the {@linkplain java.math.RoundingMode#HALF_EVEN
 197  * round half-even algorithm}. To change the rounding mode use
 198  * {@link #setRoundingMode(java.math.RoundingMode) setRoundingMode}.
</pre>
<hr />
<pre>
 221      * Field constant used to construct a FieldPosition object. Signifies that
 222      * the position of the fraction part of a formatted number should be returned.
 223      * @see java.text.FieldPosition
 224      */
 225     public static final int FRACTION_FIELD = 1;
 226 
 227     /**
 228      * Sole constructor.  (For invocation by subclass constructors, typically
 229      * implicit.)
 230      */
 231     protected NumberFormat() {
 232     }
 233 
 234     /**
 235      * Formats a number and appends the resulting text to the given string
 236      * buffer.
 237      * The number can be of any subclass of {@link java.lang.Number}.
 238      * &lt;p&gt;
 239      * This implementation extracts the number&#39;s value using
 240      * {@link java.lang.Number#longValue()} for all integral type values that
<span class="line-modified"> 241      * can be converted to &lt;code&gt;long&lt;/code&gt; without loss of information,</span>
<span class="line-modified"> 242      * including &lt;code&gt;BigInteger&lt;/code&gt; values with a</span>
 243      * {@link java.math.BigInteger#bitLength() bit length} of less than 64,
 244      * and {@link java.lang.Number#doubleValue()} for all other types. It
 245      * then calls
 246      * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
 247      * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
 248      * This may result in loss of magnitude information and precision for
<span class="line-modified"> 249      * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; values.</span>
 250      * @param number     the number to format
<span class="line-modified"> 251      * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted</span>
 252      *                   text is to be appended
 253      * @param pos        keeps track on the position of the field within the
 254      *                   returned string. For example, for formatting a number
 255      *                   {@code 1234567.89} in {@code Locale.US} locale,
 256      *                   if the given {@code fieldPosition} is
 257      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 258      *                   and end index of {@code fieldPosition} will be set
 259      *                   to 0 and 9, respectively for the output string
 260      *                   {@code 1,234,567.89}.
<span class="line-modified"> 261      * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;</span>
<span class="line-modified"> 262      * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is</span>
<span class="line-modified"> 263      *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</span>
<span class="line-modified"> 264      * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified"> 265      *                   &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified"> 266      * @exception        ArithmeticException if rounding is needed with rounding</span>
 267      *                   mode being set to RoundingMode.UNNECESSARY
 268      * @see              java.text.FieldPosition
 269      */
 270     @Override
 271     public StringBuffer format(Object number,
 272                                StringBuffer toAppendTo,
 273                                FieldPosition pos) {
 274         if (number instanceof Long || number instanceof Integer ||
 275             number instanceof Short || number instanceof Byte ||
 276             number instanceof AtomicInteger || number instanceof AtomicLong ||
 277             (number instanceof BigInteger &amp;&amp;
 278              ((BigInteger)number).bitLength() &lt; 64)) {
 279             return format(((Number)number).longValue(), toAppendTo, pos);
 280         } else if (number instanceof Number) {
 281             return format(((Number)number).doubleValue(), toAppendTo, pos);
 282         } else {
 283             throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
 284         }
 285     }
 286 
 287     /**
<span class="line-modified"> 288      * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.</span>
 289      * &lt;p&gt;
 290      * The method attempts to parse text starting at the index given by
<span class="line-modified"> 291      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified"> 292      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
 293      * to the index after the last character used (parsing does not necessarily
 294      * use all characters up to the end of the string), and the parsed
<span class="line-modified"> 295      * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
 296      * indicate the starting point for the next call to this method.
<span class="line-modified"> 297      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified"> 298      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
 299      * the character where the error occurred, and null is returned.
 300      * &lt;p&gt;
 301      * See the {@link #parse(String, ParsePosition)} method for more information
 302      * on number parsing.
 303      *
<span class="line-modified"> 304      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified"> 305      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
 306      *            index information as described above.
<span class="line-modified"> 307      * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string. In case of</span>
 308      *         error, returns null.
 309      * @throws NullPointerException if {@code source} or {@code pos} is null.
 310      */
 311     @Override
 312     public final Object parseObject(String source, ParsePosition pos) {
 313         return parse(source, pos);
 314     }
 315 
 316    /**
 317      * Specialization of format.
 318      *
 319      * @param number the double number to format
 320      * @return the formatted String
<span class="line-modified"> 321      * @exception        ArithmeticException if rounding is needed with rounding</span>
 322      *                   mode being set to RoundingMode.UNNECESSARY
 323      * @see java.text.Format#format
 324      */
 325     public final String format(double number) {
 326         // Use fast-path for double result if that works
 327         String result = fastFormat(number);
 328         if (result != null)
 329             return result;
 330 
 331         return format(number, new StringBuffer(),
 332                       DontCareFieldPosition.INSTANCE).toString();
 333     }
 334 
 335     /*
 336      * fastFormat() is supposed to be implemented in concrete subclasses only.
 337      * Default implem always returns null.
 338      */
 339     String fastFormat(double number) { return null; }
 340 
 341    /**
 342      * Specialization of format.
 343      *
 344      * @param number the long number to format
 345      * @return the formatted String
<span class="line-modified"> 346      * @exception        ArithmeticException if rounding is needed with rounding</span>
 347      *                   mode being set to RoundingMode.UNNECESSARY
 348      * @see java.text.Format#format
 349      */
 350     public final String format(long number) {
 351         return format(number, new StringBuffer(),
 352                       DontCareFieldPosition.INSTANCE).toString();
 353     }
 354 
 355    /**
 356      * Specialization of format.
 357      *
 358      * @param number     the double number to format
 359      * @param toAppendTo the StringBuffer to which the formatted text is to be
 360      *                   appended
 361      * @param pos        keeps track on the position of the field within the
 362      *                   returned string. For example, for formatting a number
 363      *                   {@code 1234567.89} in {@code Locale.US} locale,
 364      *                   if the given {@code fieldPosition} is
 365      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 366      *                   and end index of {@code fieldPosition} will be set
 367      *                   to 0 and 9, respectively for the output string
 368      *                   {@code 1,234,567.89}.
 369      * @return the formatted StringBuffer
<span class="line-modified"> 370      * @exception        ArithmeticException if rounding is needed with rounding</span>
 371      *                   mode being set to RoundingMode.UNNECESSARY
 372      * @see java.text.Format#format
 373      */
 374     public abstract StringBuffer format(double number,
 375                                         StringBuffer toAppendTo,
 376                                         FieldPosition pos);
 377 
 378    /**
 379      * Specialization of format.
 380      *
 381      * @param number     the long number to format
 382      * @param toAppendTo the StringBuffer to which the formatted text is to be
 383      *                   appended
 384      * @param pos        keeps track on the position of the field within the
 385      *                   returned string. For example, for formatting a number
 386      *                   {@code 123456789} in {@code Locale.US} locale,
 387      *                   if the given {@code fieldPosition} is
 388      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 389      *                   and end index of {@code fieldPosition} will be set
 390      *                   to 0 and 11, respectively for the output string
 391      *                   {@code 123,456,789}.
 392      * @return the formatted StringBuffer
<span class="line-modified"> 393      * @exception        ArithmeticException if rounding is needed with rounding</span>
 394      *                   mode being set to RoundingMode.UNNECESSARY
 395      * @see java.text.Format#format
 396      */
 397     public abstract StringBuffer format(long number,
 398                                         StringBuffer toAppendTo,
 399                                         FieldPosition pos);
 400 
 401    /**
 402      * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
 403      * Long.MAX_VALUE] and with no decimals), otherwise a Double.
 404      * If IntegerOnly is set, will stop at a decimal
 405      * point (or equivalent; e.g., for rational numbers &quot;1 2/3&quot;, will stop
 406      * after the 1).
 407      * Does not throw an exception; if no object can be parsed, index is
 408      * unchanged!
 409      *
 410      * @param source the String to parse
 411      * @param parsePosition the parse position
 412      * @return the parsed value
 413      * @see java.text.NumberFormat#isParseIntegerOnly
 414      * @see java.text.Format#parseObject
 415      */
 416     public abstract Number parse(String source, ParsePosition parsePosition);
 417 
 418     /**
 419      * Parses text from the beginning of the given string to produce a number.
 420      * The method may not use the entire text of the given string.
 421      * &lt;p&gt;
 422      * See the {@link #parse(String, ParsePosition)} method for more information
 423      * on number parsing.
 424      *
<span class="line-modified"> 425      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified"> 426      * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string.</span>
<span class="line-modified"> 427      * @exception ParseException if the beginning of the specified string</span>
 428      *            cannot be parsed.
 429      */
 430     public Number parse(String source) throws ParseException {
 431         ParsePosition parsePosition = new ParsePosition(0);
 432         Number result = parse(source, parsePosition);
 433         if (parsePosition.index == 0) {
 434             throw new ParseException(&quot;Unparseable number: \&quot;&quot; + source + &quot;\&quot;&quot;,
 435                                      parsePosition.errorIndex);
 436         }
 437         return result;
 438     }
 439 
 440     /**
 441      * Returns true if this format will parse numbers as integers only.
 442      * For example in the English locale, with ParseIntegerOnly true, the
 443      * string &quot;1234.&quot; would be parsed as the integer value 1234 and parsing
 444      * would stop at the &quot;.&quot; character.  Of course, the exact format accepted
 445      * by the parse operation is locale dependent and determined by sub-classes
 446      * of NumberFormat.
 447      *
</pre>
<hr />
<pre>
 558     }
 559 
 560     /**
 561      * Returns a currency format for the current default
 562      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 563      * &lt;p&gt;This is equivalent to calling
 564      * {@link #getCurrencyInstance(Locale)
 565      *     getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 566      *
 567      * @return the {@code NumberFormat} instance for currency formatting
 568      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 569      * @see java.util.Locale.Category#FORMAT
 570      */
 571     public static final NumberFormat getCurrencyInstance() {
 572         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, CURRENCYSTYLE);
 573     }
 574 
 575     /**
 576      * Returns a currency format for the specified locale.
 577      *









 578      * @param inLocale the desired locale
 579      * @return the {@code NumberFormat} instance for currency formatting
 580      */
 581     public static NumberFormat getCurrencyInstance(Locale inLocale) {
 582         return getInstance(inLocale, null, CURRENCYSTYLE);
 583     }
 584 
 585     /**
 586      * Returns a percentage format for the current default
 587      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 588      * &lt;p&gt;This is equivalent to calling
 589      * {@link #getPercentInstance(Locale)
 590      *     getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 591      *
 592      * @return the {@code NumberFormat} instance for percentage formatting
 593      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 594      * @see java.util.Locale.Category#FORMAT
 595      */
 596     public static final NumberFormat getPercentInstance() {
 597         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, PERCENTSTYLE);
</pre>
<hr />
<pre>
 651      * @return A {@code NumberFormat} instance for compact number
 652      *         formatting
 653      * @throws NullPointerException if {@code locale} or {@code formatStyle}
 654      *                              is {@code null}
 655      *
 656      * @see CompactNumberFormat
 657      * @see NumberFormat.Style
 658      * @see java.util.Locale
 659      * @since 12
 660      */
 661     public static NumberFormat getCompactNumberInstance(Locale locale,
 662             NumberFormat.Style formatStyle) {
 663 
 664         Objects.requireNonNull(locale);
 665         Objects.requireNonNull(formatStyle);
 666         return getInstance(locale, formatStyle, COMPACTSTYLE);
 667     }
 668 
 669     /**
 670      * Returns an array of all locales for which the
<span class="line-modified"> 671      * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return</span>
 672      * localized instances.
 673      * The returned array represents the union of locales supported by the Java
 674      * runtime and by installed
 675      * {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
<span class="line-modified"> 676      * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to</span>
 677      * {@link java.util.Locale#US Locale.US}.
 678      *
 679      * @return An array of locales for which localized
<span class="line-modified"> 680      *         &lt;code&gt;NumberFormat&lt;/code&gt; instances are available.</span>
 681      */
 682     public static Locale[] getAvailableLocales() {
 683         LocaleServiceProviderPool pool =
 684             LocaleServiceProviderPool.getPool(NumberFormatProvider.class);
 685         return pool.getAvailableLocales();
 686     }
 687 
 688     /**
 689      * Overrides hashCode.
 690      */
 691     @Override
 692     public int hashCode() {
 693         return maximumIntegerDigits * 37 + maxFractionDigits;
 694         // just enough fields for a reasonable distribution
 695     }
 696 
 697     /**
 698      * Overrides equals.
 699      */
 700     @Override
</pre>
<hr />
<pre>
 862      * @param newValue the minimum number of fraction digits to be shown; if
 863      * less than zero, then zero is used. The concrete subclass may enforce an
 864      * upper limit to this value appropriate to the numeric type being formatted.
 865      * @see #getMinimumFractionDigits
 866      */
 867     public void setMinimumFractionDigits(int newValue) {
 868         minimumFractionDigits = Math.max(0,newValue);
 869         if (maximumFractionDigits &lt; minimumFractionDigits) {
 870             maximumFractionDigits = minimumFractionDigits;
 871         }
 872     }
 873 
 874     /**
 875      * Gets the currency used by this number format when formatting
 876      * currency values. The initial value is derived in a locale dependent
 877      * way. The returned value may be null if no valid
 878      * currency could be determined and no currency has been set using
 879      * {@link #setCurrency(java.util.Currency) setCurrency}.
 880      * &lt;p&gt;
 881      * The default implementation throws
<span class="line-modified"> 882      * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</span>
 883      *
<span class="line-modified"> 884      * @return the currency used by this number format, or &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 885      * @exception UnsupportedOperationException if the number format class</span>
 886      * doesn&#39;t implement currency formatting
 887      * @since 1.4
 888      */
 889     public Currency getCurrency() {
 890         throw new UnsupportedOperationException();
 891     }
 892 
 893     /**
 894      * Sets the currency used by this number format when formatting
 895      * currency values. This does not update the minimum or maximum
 896      * number of fraction digits used by the number format.
 897      * &lt;p&gt;
 898      * The default implementation throws
<span class="line-modified"> 899      * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</span>
 900      *
 901      * @param currency the new currency to be used by this number format
<span class="line-modified"> 902      * @exception UnsupportedOperationException if the number format class</span>
 903      * doesn&#39;t implement currency formatting
<span class="line-modified"> 904      * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</span>
 905      * @since 1.4
 906      */
 907     public void setCurrency(Currency currency) {
 908         throw new UnsupportedOperationException();
 909     }
 910 
 911     /**
 912      * Gets the {@link java.math.RoundingMode} used in this NumberFormat.
 913      * The default implementation of this method in NumberFormat
 914      * always throws {@link java.lang.UnsupportedOperationException}.
 915      * Subclasses which handle different rounding modes should override
 916      * this method.
 917      *
<span class="line-modified"> 918      * @exception UnsupportedOperationException The default implementation</span>
 919      *     always throws this exception
<span class="line-modified"> 920      * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this NumberFormat.</span>
 921      * @see #setRoundingMode(RoundingMode)
 922      * @since 1.6
 923      */
 924     public RoundingMode getRoundingMode() {
 925         throw new UnsupportedOperationException();
 926     }
 927 
 928     /**
 929      * Sets the {@link java.math.RoundingMode} used in this NumberFormat.
 930      * The default implementation of this method in NumberFormat always
 931      * throws {@link java.lang.UnsupportedOperationException}.
 932      * Subclasses which handle different rounding modes should override
 933      * this method.
 934      *
<span class="line-modified"> 935      * @exception UnsupportedOperationException The default implementation</span>
 936      *     always throws this exception
<span class="line-modified"> 937      * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null</span>
<span class="line-modified"> 938      * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</span>
 939      * @see #getRoundingMode()
 940      * @since 1.6
 941      */
 942     public void setRoundingMode(RoundingMode roundingMode) {
 943         throw new UnsupportedOperationException();
 944     }
 945 
 946     // =======================privates===============================
 947 
 948     private static NumberFormat getInstance(Locale desiredLocale,
 949                                             Style formatStyle, int choice) {
 950         LocaleProviderAdapter adapter;
 951         adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class,
 952                 desiredLocale);
 953         NumberFormat numberFormat = getInstance(adapter, desiredLocale,
 954                 formatStyle, choice);
 955         if (numberFormat == null) {
 956             numberFormat = getInstance(LocaleProviderAdapter.forJRE(),
 957                     desiredLocale, formatStyle, choice);
 958         }
</pre>
<hr />
<pre>
 970             break;
 971         case PERCENTSTYLE:
 972             numberFormat = provider.getPercentInstance(locale);
 973             break;
 974         case CURRENCYSTYLE:
 975             numberFormat = provider.getCurrencyInstance(locale);
 976             break;
 977         case INTEGERSTYLE:
 978             numberFormat = provider.getIntegerInstance(locale);
 979             break;
 980         case COMPACTSTYLE:
 981             numberFormat = provider.getCompactNumberInstance(locale, formatStyle);
 982             break;
 983         }
 984         return numberFormat;
 985     }
 986 
 987     /**
 988      * First, read in the default serializable data.
 989      *
<span class="line-modified"> 990      * Then, if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that</span>
 991      * the stream was written by JDK 1.1,
<span class="line-modified"> 992      * set the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
<span class="line-modified"> 993      * to be equal to the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt;,</span>
<span class="line-modified"> 994      * since the &lt;code&gt;int&lt;/code&gt; fields were not present in JDK 1.1.</span>
 995      * Finally, set serialVersionOnStream back to the maximum allowed value so that
 996      * default serialization will work properly if this object is streamed out again.
 997      *
<span class="line-modified"> 998      * &lt;p&gt;If &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is greater than</span>
<span class="line-modified"> 999      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;minimumFractionDigits&lt;/code&gt;</span>
<span class="line-modified">1000      * is greater than &lt;code&gt;maximumFractionDigits&lt;/code&gt;, then the stream data</span>
<span class="line-modified">1001      * is invalid and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
1002      * In addition, if any of these values is negative, then this method throws
<span class="line-modified">1003      * an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
1004      *
1005      * @since 1.2
1006      */

1007     private void readObject(ObjectInputStream stream)
1008          throws IOException, ClassNotFoundException
1009     {
1010         stream.defaultReadObject();
1011         if (serialVersionOnStream &lt; 1) {
1012             // Didn&#39;t have additional int fields, reassign to use them.
1013             maximumIntegerDigits = maxIntegerDigits;
1014             minimumIntegerDigits = minIntegerDigits;
1015             maximumFractionDigits = maxFractionDigits;
1016             minimumFractionDigits = minFractionDigits;
1017         }
1018         if (minimumIntegerDigits &gt; maximumIntegerDigits ||
1019             minimumFractionDigits &gt; maximumFractionDigits ||
1020             minimumIntegerDigits &lt; 0 || minimumFractionDigits &lt; 0) {
1021             throw new InvalidObjectException(&quot;Digit count range invalid&quot;);
1022         }
1023         serialVersionOnStream = currentSerialVersion;
1024     }
1025 
1026     /**
1027      * Write out the default serializable data, after first setting
<span class="line-modified">1028      * the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; to be</span>
<span class="line-modified">1029      * equal to the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
<span class="line-modified">1030      * (or to &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;, whichever is smaller), for compatibility</span>
1031      * with the JDK 1.1 version of the stream format.
1032      *
1033      * @since 1.2
1034      */

1035     private void writeObject(ObjectOutputStream stream)
1036          throws IOException
1037     {
1038         maxIntegerDigits = (maximumIntegerDigits &gt; Byte.MAX_VALUE) ?
1039                            Byte.MAX_VALUE : (byte)maximumIntegerDigits;
1040         minIntegerDigits = (minimumIntegerDigits &gt; Byte.MAX_VALUE) ?
1041                            Byte.MAX_VALUE : (byte)minimumIntegerDigits;
1042         maxFractionDigits = (maximumFractionDigits &gt; Byte.MAX_VALUE) ?
1043                             Byte.MAX_VALUE : (byte)maximumFractionDigits;
1044         minFractionDigits = (minimumFractionDigits &gt; Byte.MAX_VALUE) ?
1045                             Byte.MAX_VALUE : (byte)minimumFractionDigits;
1046         stream.defaultWriteObject();
1047     }
1048 
1049     // Constants used by factory methods to specify a style of format.
1050     private static final int NUMBERSTYLE = 0;
1051     private static final int CURRENCYSTYLE = 1;
1052     private static final int PERCENTSTYLE = 2;
1053     private static final int SCIENTIFICSTYLE = 3;
1054     private static final int INTEGERSTYLE = 4;
1055     private static final int COMPACTSTYLE = 5;
1056 
1057     /**
1058      * True if the grouping (i.e. thousands) separator is used when
1059      * formatting and parsing numbers.
1060      *
1061      * @serial
1062      * @see #isGroupingUsed
1063      */
1064     private boolean groupingUsed = true;
1065 
1066     /**
1067      * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">1068      * number.  &lt;code&gt;maxIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1069      * &lt;code&gt;minIntegerDigits&lt;/code&gt;.</span>
1070      * &lt;p&gt;
1071      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1072      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1073      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumIntegerDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1074      * When writing to a stream, &lt;code&gt;maxIntegerDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1075      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1076      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1077      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1078      *
1079      * @serial
1080      * @see #getMaximumIntegerDigits
1081      */
1082     private byte    maxIntegerDigits = 40;
1083 
1084     /**
1085      * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">1086      * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1087      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
1088      * &lt;p&gt;
1089      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1090      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1091      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1092      * When writing to a stream, &lt;code&gt;minIntegerDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1093      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1094      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1095      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1096      *
1097      * @serial
1098      * @see #getMinimumIntegerDigits
1099      */
1100     private byte    minIntegerDigits = 1;
1101 
1102     /**
1103      * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">1104      * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1105      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
1106      * &lt;p&gt;
1107      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1108      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1109      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumFractionDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1110      * When writing to a stream, &lt;code&gt;maxFractionDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1111      * &lt;code&gt;maximumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1112      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1113      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1114      *
1115      * @serial
1116      * @see #getMaximumFractionDigits
1117      */
1118     private byte    maxFractionDigits = 3;    // invariant, &gt;= minFractionDigits
1119 
1120     /**
1121      * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">1122      * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1123      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
1124      * &lt;p&gt;
1125      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1126      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1127      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumFractionDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">1128      * When writing to a stream, &lt;code&gt;minFractionDigits&lt;/code&gt; is set to</span>
<span class="line-modified">1129      * &lt;code&gt;minimumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
1130      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1131      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
1132      *
1133      * @serial
1134      * @see #getMinimumFractionDigits
1135      */
1136     private byte    minFractionDigits = 0;
1137 
1138     /**
1139      * True if this format will parse numbers as integers only.
1140      *
1141      * @serial
1142      * @see #isParseIntegerOnly
1143      */
1144     private boolean parseIntegerOnly = false;
1145 
1146     // new fields for 1.2.  byte is too small for integer digits.
1147 
1148     /**
1149      * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">1150      * number.  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1151      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</span>
1152      *
1153      * @serial
1154      * @since 1.2
1155      * @see #getMaximumIntegerDigits
1156      */
1157     private int    maximumIntegerDigits = 40;
1158 
1159     /**
1160      * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">1161      * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1162      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
1163      *
1164      * @serial
1165      * @since 1.2
1166      * @see #getMinimumIntegerDigits
1167      */
1168     private int    minimumIntegerDigits = 1;
1169 
1170     /**
1171      * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">1172      * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">1173      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
1174      *
1175      * @serial
1176      * @since 1.2
1177      * @see #getMaximumFractionDigits
1178      */
1179     private int    maximumFractionDigits = 3;    // invariant, &gt;= minFractionDigits
1180 
1181     /**
1182      * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">1183      * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">1184      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
1185      *
1186      * @serial
1187      * @since 1.2
1188      * @see #getMinimumFractionDigits
1189      */
1190     private int    minimumFractionDigits = 0;
1191 
1192     static final int currentSerialVersion = 1;
1193 
1194     /**
<span class="line-modified">1195      * Describes the version of &lt;code&gt;NumberFormat&lt;/code&gt; present on the stream.</span>
1196      * Possible values are:
1197      * &lt;ul&gt;
1198      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
<span class="line-modified">1199      *     In this version, the &lt;code&gt;int&lt;/code&gt; fields such as</span>
<span class="line-modified">1200      *     &lt;code&gt;maximumIntegerDigits&lt;/code&gt; were not present, and the &lt;code&gt;byte&lt;/code&gt;</span>
<span class="line-modified">1201      *     fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are used instead.</span>
1202      *
1203      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
<span class="line-modified">1204      *     &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are ignored,</span>
<span class="line-modified">1205      *     and the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
1206      *     are used instead.
1207      * &lt;/ul&gt;
<span class="line-modified">1208      * When streaming out a &lt;code&gt;NumberFormat&lt;/code&gt;, the most recent format</span>
<span class="line-modified">1209      * (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)</span>
1210      * is always written.
1211      *
1212      * @serial
1213      * @since 1.2
1214      */
1215     private int serialVersionOnStream = currentSerialVersion;
1216 
1217     // Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization
1218     // ID for backward compatibility.

1219     static final long serialVersionUID = -2308460125733713944L;
1220 
1221 
1222     //
1223     // class for AttributedCharacterIterator attributes
1224     //
1225     /**
1226      * Defines constants that are used as attribute keys in the
<span class="line-modified">1227      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">1228      * from &lt;code&gt;NumberFormat.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">1229      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
1230      *
1231      * @since 1.4
1232      */
1233     public static class Field extends Format.Field {
1234 
1235         // Proclaim serial compatibility with 1.4 FCS

1236         private static final long serialVersionUID = 7494728892700160890L;
1237 
1238         // table of all instances in this class, used by readResolve
1239         private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(11);
1240 
1241         /**
1242          * Creates a Field instance with the specified
1243          * name.
1244          *
1245          * @param name Name of the attribute
1246          */
1247         protected Field(String name) {
1248             super(name);
1249             if (this.getClass() == NumberFormat.Field.class) {
1250                 instanceMap.put(name, this);
1251             }
1252         }
1253 
1254         /**
1255          * Resolves instances being deserialized to the predefined constants.
1256          *
1257          * @throws InvalidObjectException if the constant could not be resolved.
1258          * @return resolved NumberFormat.Field constant
1259          */
1260         @Override

1261         protected Object readResolve() throws InvalidObjectException {
1262             if (this.getClass() != NumberFormat.Field.class) {
1263                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1264             }
1265 
1266             Object instance = instanceMap.get(getName());
1267             if (instance != null) {
1268                 return instance;
1269             } else {
1270                 throw new InvalidObjectException(&quot;unknown attribute name&quot;);
1271             }
1272         }
1273 
1274         /**
1275          * Constant identifying the integer field.
1276          */
1277         public static final Field INTEGER = new Field(&quot;integer&quot;);
1278 
1279         /**
1280          * Constant identifying the fraction field.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.io.ObjectOutputStream;
  45 import java.math.BigInteger;
  46 import java.math.RoundingMode;
  47 import java.text.spi.NumberFormatProvider;
  48 import java.util.Currency;
  49 import java.util.HashMap;
  50 import java.util.Locale;
  51 import java.util.Map;
  52 import java.util.Objects;
  53 import java.util.concurrent.atomic.AtomicInteger;
  54 import java.util.concurrent.atomic.AtomicLong;
  55 import sun.util.locale.provider.LocaleProviderAdapter;
  56 import sun.util.locale.provider.LocaleServiceProviderPool;
  57 
  58 /**
<span class="line-modified">  59  * {@code NumberFormat} is the abstract base class for all number</span>
  60  * formats. This class provides the interface for formatting and parsing
<span class="line-modified">  61  * numbers. {@code NumberFormat} also provides methods for determining</span>
  62  * which locales have number formats, and what their names are.
  63  *
  64  * &lt;p&gt;
<span class="line-modified">  65  * {@code NumberFormat} helps you to format and parse numbers for any locale.</span>
  66  * Your code can be completely independent of the locale conventions for
  67  * decimal points, thousands-separators, or even the particular decimal
  68  * digits used, or whether the number format is even decimal.
  69  *
  70  * &lt;p&gt;
  71  * To format a number for the current Locale, use one of the factory
  72  * class methods:
  73  * &lt;blockquote&gt;
  74  * &lt;pre&gt;{@code
  75  * myString = NumberFormat.getInstance().format(myNumber);
  76  * }&lt;/pre&gt;
  77  * &lt;/blockquote&gt;
  78  * If you are formatting multiple numbers, it is
  79  * more efficient to get the format and use it multiple times so that
  80  * the system doesn&#39;t have to fetch the information about the local
  81  * language and country conventions multiple times.
  82  * &lt;blockquote&gt;
  83  * &lt;pre&gt;{@code
  84  * NumberFormat nf = NumberFormat.getInstance();
  85  * for (int i = 0; i &lt; myNumber.length; ++i) {
  86  *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
  87  * }
  88  * }&lt;/pre&gt;
  89  * &lt;/blockquote&gt;
  90  * To format a number for a different Locale, specify it in the
<span class="line-modified">  91  * call to {@code getInstance}.</span>
  92  * &lt;blockquote&gt;
  93  * &lt;pre&gt;{@code
  94  * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
  95  * }&lt;/pre&gt;
  96  * &lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;If the locale contains &quot;nu&quot; (numbers) and/or &quot;rg&quot; (region override)
  99  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
 100  * the decimal digits, and/or the country used for formatting are overridden.
 101  * If both &quot;nu&quot; and &quot;rg&quot; are specified, the decimal digits from the &quot;nu&quot;
 102  * extension supersedes the implicit one from the &quot;rg&quot; extension.
 103  *
 104  * &lt;p&gt;You can also use a {@code NumberFormat} to parse numbers:
 105  * &lt;blockquote&gt;
 106  * &lt;pre&gt;{@code
 107  * myNumber = nf.parse(myString);
 108  * }&lt;/pre&gt;
 109  * &lt;/blockquote&gt;
<span class="line-modified"> 110  * Use {@code getInstance} or {@code getNumberInstance} to get the</span>
<span class="line-modified"> 111  * normal number format. Use {@code getIntegerInstance} to get an</span>
<span class="line-modified"> 112  * integer number format. Use {@code getCurrencyInstance} to get the</span>
 113  * currency number format. Use {@code getCompactNumberInstance} to get the
 114  * compact number format to format a number in shorter form. For example,
 115  * {@code 2000} can be formatted as {@code &quot;2K&quot;} in
<span class="line-modified"> 116  * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}</span>
 117  * to get a format for displaying percentages. With this format, a fraction
 118  * like 0.53 is displayed as 53%.
 119  *
 120  * &lt;p&gt;
 121  * You can also control the display of numbers with such methods as
<span class="line-modified"> 122  * {@code setMinimumFractionDigits}.</span>
 123  * If you want even more control over the format or parsing,
 124  * or want to give your users more control,
<span class="line-modified"> 125  * you can try casting the {@code NumberFormat} you get from the factory methods</span>
 126  * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on
 127  * the factory method used. This will work for the vast majority of locales;
<span class="line-modified"> 128  * just remember to put it in a {@code try} block in case you encounter</span>
 129  * an unusual one.
 130  *
 131  * &lt;p&gt;
 132  * NumberFormat and DecimalFormat are designed such that some controls
 133  * work for formatting and others work for parsing.  The following is
 134  * the detailed description for each these control methods,
 135  * &lt;p&gt;
 136  * setParseIntegerOnly : only affects parsing, e.g.
 137  * if true,  &quot;3456.78&quot; &amp;rarr; 3456 (and leaves the parse position just after index 6)
 138  * if false, &quot;3456.78&quot; &amp;rarr; 3456.78 (and leaves the parse position just after index 8)
 139  * This is independent of formatting.  If you want to not show a decimal point
 140  * where there might be no digits after the decimal point, use
 141  * setDecimalSeparatorAlwaysShown.
 142  * &lt;p&gt;
 143  * setDecimalSeparatorAlwaysShown : only affects formatting, and only where
 144  * there might be no digits after the decimal point, such as with a pattern
 145  * like &quot;#,##0.##&quot;, e.g.,
 146  * if true,  3456.00 &amp;rarr; &quot;3,456.&quot;
 147  * if false, 3456.00 &amp;rarr; &quot;3456&quot;
 148  * This is independent of parsing.  If you want parsing to stop at the decimal
 149  * point, use setParseIntegerOnly.
 150  *
 151  * &lt;p&gt;
<span class="line-modified"> 152  * You can also use forms of the {@code parse} and {@code format}</span>
<span class="line-modified"> 153  * methods with {@code ParsePosition} and {@code FieldPosition} to</span>
 154  * allow you to:
 155  * &lt;ul&gt;
 156  * &lt;li&gt; progressively parse through pieces of a string
 157  * &lt;li&gt; align the decimal point and other areas
 158  * &lt;/ul&gt;
 159  * For example, you can align numbers in two ways:
 160  * &lt;ol&gt;
 161  * &lt;li&gt; If you are using a monospaced font with spacing for alignment,
<span class="line-modified"> 162  *      you can pass the {@code FieldPosition} in your format call, with</span>
<span class="line-modified"> 163  *      {@code field} = {@code INTEGER_FIELD}. On output,</span>
<span class="line-modified"> 164  *      {@code getEndIndex} will be set to the offset between the</span>
 165  *      last character of the integer and the decimal. Add
 166  *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
 167  *
 168  * &lt;li&gt; If you are using proportional fonts,
 169  *      instead of padding with spaces, measure the width
<span class="line-modified"> 170  *      of the string in pixels from the start to {@code getEndIndex}.</span>
 171  *      Then move the pen by
 172  *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
 173  *      It also works where there is no decimal, but possibly additional
 174  *      characters at the end, e.g., with parentheses in negative
 175  *      numbers: &quot;(12)&quot; for -12.
 176  * &lt;/ol&gt;
 177  *
<span class="line-modified"> 178  * &lt;h2&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h2&gt;</span>
 179  *
 180  * &lt;p&gt;
 181  * Number formats are generally not synchronized.
 182  * It is recommended to create separate format instances for each thread.
 183  * If multiple threads access a format concurrently, it must be synchronized
 184  * externally.
 185  *
 186  * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},
 187  * {@link #format(long, StringBuffer, FieldPosition)} and
 188  * {@link #parse(String, ParsePosition)} methods may throw
 189  * {@code NullPointerException}, if any of their parameter is {@code null}.
 190  * The subclass may provide its own implementation and specification about
 191  * {@code NullPointerException}.
 192  *
 193  * &lt;p&gt;
 194  * The default implementation provides rounding modes defined
 195  * in {@link java.math.RoundingMode} for formatting numbers. It
 196  * uses the {@linkplain java.math.RoundingMode#HALF_EVEN
 197  * round half-even algorithm}. To change the rounding mode use
 198  * {@link #setRoundingMode(java.math.RoundingMode) setRoundingMode}.
</pre>
<hr />
<pre>
 221      * Field constant used to construct a FieldPosition object. Signifies that
 222      * the position of the fraction part of a formatted number should be returned.
 223      * @see java.text.FieldPosition
 224      */
 225     public static final int FRACTION_FIELD = 1;
 226 
 227     /**
 228      * Sole constructor.  (For invocation by subclass constructors, typically
 229      * implicit.)
 230      */
 231     protected NumberFormat() {
 232     }
 233 
 234     /**
 235      * Formats a number and appends the resulting text to the given string
 236      * buffer.
 237      * The number can be of any subclass of {@link java.lang.Number}.
 238      * &lt;p&gt;
 239      * This implementation extracts the number&#39;s value using
 240      * {@link java.lang.Number#longValue()} for all integral type values that
<span class="line-modified"> 241      * can be converted to {@code long} without loss of information,</span>
<span class="line-modified"> 242      * including {@code BigInteger} values with a</span>
 243      * {@link java.math.BigInteger#bitLength() bit length} of less than 64,
 244      * and {@link java.lang.Number#doubleValue()} for all other types. It
 245      * then calls
 246      * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
 247      * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
 248      * This may result in loss of magnitude information and precision for
<span class="line-modified"> 249      * {@code BigInteger} and {@code BigDecimal} values.</span>
 250      * @param number     the number to format
<span class="line-modified"> 251      * @param toAppendTo the {@code StringBuffer} to which the formatted</span>
 252      *                   text is to be appended
 253      * @param pos        keeps track on the position of the field within the
 254      *                   returned string. For example, for formatting a number
 255      *                   {@code 1234567.89} in {@code Locale.US} locale,
 256      *                   if the given {@code fieldPosition} is
 257      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 258      *                   and end index of {@code fieldPosition} will be set
 259      *                   to 0 and 9, respectively for the output string
 260      *                   {@code 1,234,567.89}.
<span class="line-modified"> 261      * @return           the value passed in as {@code toAppendTo}</span>
<span class="line-modified"> 262      * @throws           IllegalArgumentException if {@code number} is</span>
<span class="line-modified"> 263      *                   null or not an instance of {@code Number}.</span>
<span class="line-modified"> 264      * @throws           NullPointerException if {@code toAppendTo} or</span>
<span class="line-modified"> 265      *                   {@code pos} is null</span>
<span class="line-modified"> 266      * @throws           ArithmeticException if rounding is needed with rounding</span>
 267      *                   mode being set to RoundingMode.UNNECESSARY
 268      * @see              java.text.FieldPosition
 269      */
 270     @Override
 271     public StringBuffer format(Object number,
 272                                StringBuffer toAppendTo,
 273                                FieldPosition pos) {
 274         if (number instanceof Long || number instanceof Integer ||
 275             number instanceof Short || number instanceof Byte ||
 276             number instanceof AtomicInteger || number instanceof AtomicLong ||
 277             (number instanceof BigInteger &amp;&amp;
 278              ((BigInteger)number).bitLength() &lt; 64)) {
 279             return format(((Number)number).longValue(), toAppendTo, pos);
 280         } else if (number instanceof Number) {
 281             return format(((Number)number).doubleValue(), toAppendTo, pos);
 282         } else {
 283             throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
 284         }
 285     }
 286 
 287     /**
<span class="line-modified"> 288      * Parses text from a string to produce a {@code Number}.</span>
 289      * &lt;p&gt;
 290      * The method attempts to parse text starting at the index given by
<span class="line-modified"> 291      * {@code pos}.</span>
<span class="line-modified"> 292      * If parsing succeeds, then the index of {@code pos} is updated</span>
 293      * to the index after the last character used (parsing does not necessarily
 294      * use all characters up to the end of the string), and the parsed
<span class="line-modified"> 295      * number is returned. The updated {@code pos} can be used to</span>
 296      * indicate the starting point for the next call to this method.
<span class="line-modified"> 297      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified"> 298      * changed, the error index of {@code pos} is set to the index of</span>
 299      * the character where the error occurred, and null is returned.
 300      * &lt;p&gt;
 301      * See the {@link #parse(String, ParsePosition)} method for more information
 302      * on number parsing.
 303      *
<span class="line-modified"> 304      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified"> 305      * @param pos A {@code ParsePosition} object with index and error</span>
 306      *            index information as described above.
<span class="line-modified"> 307      * @return A {@code Number} parsed from the string. In case of</span>
 308      *         error, returns null.
 309      * @throws NullPointerException if {@code source} or {@code pos} is null.
 310      */
 311     @Override
 312     public final Object parseObject(String source, ParsePosition pos) {
 313         return parse(source, pos);
 314     }
 315 
 316    /**
 317      * Specialization of format.
 318      *
 319      * @param number the double number to format
 320      * @return the formatted String
<span class="line-modified"> 321      * @throws           ArithmeticException if rounding is needed with rounding</span>
 322      *                   mode being set to RoundingMode.UNNECESSARY
 323      * @see java.text.Format#format
 324      */
 325     public final String format(double number) {
 326         // Use fast-path for double result if that works
 327         String result = fastFormat(number);
 328         if (result != null)
 329             return result;
 330 
 331         return format(number, new StringBuffer(),
 332                       DontCareFieldPosition.INSTANCE).toString();
 333     }
 334 
 335     /*
 336      * fastFormat() is supposed to be implemented in concrete subclasses only.
 337      * Default implem always returns null.
 338      */
 339     String fastFormat(double number) { return null; }
 340 
 341    /**
 342      * Specialization of format.
 343      *
 344      * @param number the long number to format
 345      * @return the formatted String
<span class="line-modified"> 346      * @throws           ArithmeticException if rounding is needed with rounding</span>
 347      *                   mode being set to RoundingMode.UNNECESSARY
 348      * @see java.text.Format#format
 349      */
 350     public final String format(long number) {
 351         return format(number, new StringBuffer(),
 352                       DontCareFieldPosition.INSTANCE).toString();
 353     }
 354 
 355    /**
 356      * Specialization of format.
 357      *
 358      * @param number     the double number to format
 359      * @param toAppendTo the StringBuffer to which the formatted text is to be
 360      *                   appended
 361      * @param pos        keeps track on the position of the field within the
 362      *                   returned string. For example, for formatting a number
 363      *                   {@code 1234567.89} in {@code Locale.US} locale,
 364      *                   if the given {@code fieldPosition} is
 365      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 366      *                   and end index of {@code fieldPosition} will be set
 367      *                   to 0 and 9, respectively for the output string
 368      *                   {@code 1,234,567.89}.
 369      * @return the formatted StringBuffer
<span class="line-modified"> 370      * @throws           ArithmeticException if rounding is needed with rounding</span>
 371      *                   mode being set to RoundingMode.UNNECESSARY
 372      * @see java.text.Format#format
 373      */
 374     public abstract StringBuffer format(double number,
 375                                         StringBuffer toAppendTo,
 376                                         FieldPosition pos);
 377 
 378    /**
 379      * Specialization of format.
 380      *
 381      * @param number     the long number to format
 382      * @param toAppendTo the StringBuffer to which the formatted text is to be
 383      *                   appended
 384      * @param pos        keeps track on the position of the field within the
 385      *                   returned string. For example, for formatting a number
 386      *                   {@code 123456789} in {@code Locale.US} locale,
 387      *                   if the given {@code fieldPosition} is
 388      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 389      *                   and end index of {@code fieldPosition} will be set
 390      *                   to 0 and 11, respectively for the output string
 391      *                   {@code 123,456,789}.
 392      * @return the formatted StringBuffer
<span class="line-modified"> 393      * @throws           ArithmeticException if rounding is needed with rounding</span>
 394      *                   mode being set to RoundingMode.UNNECESSARY
 395      * @see java.text.Format#format
 396      */
 397     public abstract StringBuffer format(long number,
 398                                         StringBuffer toAppendTo,
 399                                         FieldPosition pos);
 400 
 401    /**
 402      * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
 403      * Long.MAX_VALUE] and with no decimals), otherwise a Double.
 404      * If IntegerOnly is set, will stop at a decimal
 405      * point (or equivalent; e.g., for rational numbers &quot;1 2/3&quot;, will stop
 406      * after the 1).
 407      * Does not throw an exception; if no object can be parsed, index is
 408      * unchanged!
 409      *
 410      * @param source the String to parse
 411      * @param parsePosition the parse position
 412      * @return the parsed value
 413      * @see java.text.NumberFormat#isParseIntegerOnly
 414      * @see java.text.Format#parseObject
 415      */
 416     public abstract Number parse(String source, ParsePosition parsePosition);
 417 
 418     /**
 419      * Parses text from the beginning of the given string to produce a number.
 420      * The method may not use the entire text of the given string.
 421      * &lt;p&gt;
 422      * See the {@link #parse(String, ParsePosition)} method for more information
 423      * on number parsing.
 424      *
<span class="line-modified"> 425      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified"> 426      * @return A {@code Number} parsed from the string.</span>
<span class="line-modified"> 427      * @throws    ParseException if the beginning of the specified string</span>
 428      *            cannot be parsed.
 429      */
 430     public Number parse(String source) throws ParseException {
 431         ParsePosition parsePosition = new ParsePosition(0);
 432         Number result = parse(source, parsePosition);
 433         if (parsePosition.index == 0) {
 434             throw new ParseException(&quot;Unparseable number: \&quot;&quot; + source + &quot;\&quot;&quot;,
 435                                      parsePosition.errorIndex);
 436         }
 437         return result;
 438     }
 439 
 440     /**
 441      * Returns true if this format will parse numbers as integers only.
 442      * For example in the English locale, with ParseIntegerOnly true, the
 443      * string &quot;1234.&quot; would be parsed as the integer value 1234 and parsing
 444      * would stop at the &quot;.&quot; character.  Of course, the exact format accepted
 445      * by the parse operation is locale dependent and determined by sub-classes
 446      * of NumberFormat.
 447      *
</pre>
<hr />
<pre>
 558     }
 559 
 560     /**
 561      * Returns a currency format for the current default
 562      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 563      * &lt;p&gt;This is equivalent to calling
 564      * {@link #getCurrencyInstance(Locale)
 565      *     getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 566      *
 567      * @return the {@code NumberFormat} instance for currency formatting
 568      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 569      * @see java.util.Locale.Category#FORMAT
 570      */
 571     public static final NumberFormat getCurrencyInstance() {
 572         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, CURRENCYSTYLE);
 573     }
 574 
 575     /**
 576      * Returns a currency format for the specified locale.
 577      *
<span class="line-added"> 578      * &lt;p&gt;If the specified locale contains the &quot;{@code cf}&quot; (</span>
<span class="line-added"> 579      * &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier&quot;&gt;</span>
<span class="line-added"> 580      * currency format style&lt;/a&gt;)</span>
<span class="line-added"> 581      * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,</span>
<span class="line-added"> 582      * the returned currency format uses the style if it is available.</span>
<span class="line-added"> 583      * Otherwise, the style uses the default &quot;{@code standard}&quot; currency format.</span>
<span class="line-added"> 584      * For example, if the style designates &quot;{@code account}&quot;, negative</span>
<span class="line-added"> 585      * currency amounts use a pair of parentheses in some locales.</span>
<span class="line-added"> 586      *</span>
 587      * @param inLocale the desired locale
 588      * @return the {@code NumberFormat} instance for currency formatting
 589      */
 590     public static NumberFormat getCurrencyInstance(Locale inLocale) {
 591         return getInstance(inLocale, null, CURRENCYSTYLE);
 592     }
 593 
 594     /**
 595      * Returns a percentage format for the current default
 596      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 597      * &lt;p&gt;This is equivalent to calling
 598      * {@link #getPercentInstance(Locale)
 599      *     getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 600      *
 601      * @return the {@code NumberFormat} instance for percentage formatting
 602      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 603      * @see java.util.Locale.Category#FORMAT
 604      */
 605     public static final NumberFormat getPercentInstance() {
 606         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, PERCENTSTYLE);
</pre>
<hr />
<pre>
 660      * @return A {@code NumberFormat} instance for compact number
 661      *         formatting
 662      * @throws NullPointerException if {@code locale} or {@code formatStyle}
 663      *                              is {@code null}
 664      *
 665      * @see CompactNumberFormat
 666      * @see NumberFormat.Style
 667      * @see java.util.Locale
 668      * @since 12
 669      */
 670     public static NumberFormat getCompactNumberInstance(Locale locale,
 671             NumberFormat.Style formatStyle) {
 672 
 673         Objects.requireNonNull(locale);
 674         Objects.requireNonNull(formatStyle);
 675         return getInstance(locale, formatStyle, COMPACTSTYLE);
 676     }
 677 
 678     /**
 679      * Returns an array of all locales for which the
<span class="line-modified"> 680      * {@code get*Instance} methods of this class can return</span>
 681      * localized instances.
 682      * The returned array represents the union of locales supported by the Java
 683      * runtime and by installed
 684      * {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
<span class="line-modified"> 685      * It must contain at least a {@code Locale} instance equal to</span>
 686      * {@link java.util.Locale#US Locale.US}.
 687      *
 688      * @return An array of locales for which localized
<span class="line-modified"> 689      *         {@code NumberFormat} instances are available.</span>
 690      */
 691     public static Locale[] getAvailableLocales() {
 692         LocaleServiceProviderPool pool =
 693             LocaleServiceProviderPool.getPool(NumberFormatProvider.class);
 694         return pool.getAvailableLocales();
 695     }
 696 
 697     /**
 698      * Overrides hashCode.
 699      */
 700     @Override
 701     public int hashCode() {
 702         return maximumIntegerDigits * 37 + maxFractionDigits;
 703         // just enough fields for a reasonable distribution
 704     }
 705 
 706     /**
 707      * Overrides equals.
 708      */
 709     @Override
</pre>
<hr />
<pre>
 871      * @param newValue the minimum number of fraction digits to be shown; if
 872      * less than zero, then zero is used. The concrete subclass may enforce an
 873      * upper limit to this value appropriate to the numeric type being formatted.
 874      * @see #getMinimumFractionDigits
 875      */
 876     public void setMinimumFractionDigits(int newValue) {
 877         minimumFractionDigits = Math.max(0,newValue);
 878         if (maximumFractionDigits &lt; minimumFractionDigits) {
 879             maximumFractionDigits = minimumFractionDigits;
 880         }
 881     }
 882 
 883     /**
 884      * Gets the currency used by this number format when formatting
 885      * currency values. The initial value is derived in a locale dependent
 886      * way. The returned value may be null if no valid
 887      * currency could be determined and no currency has been set using
 888      * {@link #setCurrency(java.util.Currency) setCurrency}.
 889      * &lt;p&gt;
 890      * The default implementation throws
<span class="line-modified"> 891      * {@code UnsupportedOperationException}.</span>
 892      *
<span class="line-modified"> 893      * @return the currency used by this number format, or {@code null}</span>
<span class="line-modified"> 894      * @throws    UnsupportedOperationException if the number format class</span>
 895      * doesn&#39;t implement currency formatting
 896      * @since 1.4
 897      */
 898     public Currency getCurrency() {
 899         throw new UnsupportedOperationException();
 900     }
 901 
 902     /**
 903      * Sets the currency used by this number format when formatting
 904      * currency values. This does not update the minimum or maximum
 905      * number of fraction digits used by the number format.
 906      * &lt;p&gt;
 907      * The default implementation throws
<span class="line-modified"> 908      * {@code UnsupportedOperationException}.</span>
 909      *
 910      * @param currency the new currency to be used by this number format
<span class="line-modified"> 911      * @throws    UnsupportedOperationException if the number format class</span>
 912      * doesn&#39;t implement currency formatting
<span class="line-modified"> 913      * @throws    NullPointerException if {@code currency} is null</span>
 914      * @since 1.4
 915      */
 916     public void setCurrency(Currency currency) {
 917         throw new UnsupportedOperationException();
 918     }
 919 
 920     /**
 921      * Gets the {@link java.math.RoundingMode} used in this NumberFormat.
 922      * The default implementation of this method in NumberFormat
 923      * always throws {@link java.lang.UnsupportedOperationException}.
 924      * Subclasses which handle different rounding modes should override
 925      * this method.
 926      *
<span class="line-modified"> 927      * @throws    UnsupportedOperationException The default implementation</span>
 928      *     always throws this exception
<span class="line-modified"> 929      * @return The {@code RoundingMode} used for this NumberFormat.</span>
 930      * @see #setRoundingMode(RoundingMode)
 931      * @since 1.6
 932      */
 933     public RoundingMode getRoundingMode() {
 934         throw new UnsupportedOperationException();
 935     }
 936 
 937     /**
 938      * Sets the {@link java.math.RoundingMode} used in this NumberFormat.
 939      * The default implementation of this method in NumberFormat always
 940      * throws {@link java.lang.UnsupportedOperationException}.
 941      * Subclasses which handle different rounding modes should override
 942      * this method.
 943      *
<span class="line-modified"> 944      * @throws    UnsupportedOperationException The default implementation</span>
 945      *     always throws this exception
<span class="line-modified"> 946      * @throws    NullPointerException if {@code roundingMode} is null</span>
<span class="line-modified"> 947      * @param roundingMode The {@code RoundingMode} to be used</span>
 948      * @see #getRoundingMode()
 949      * @since 1.6
 950      */
 951     public void setRoundingMode(RoundingMode roundingMode) {
 952         throw new UnsupportedOperationException();
 953     }
 954 
 955     // =======================privates===============================
 956 
 957     private static NumberFormat getInstance(Locale desiredLocale,
 958                                             Style formatStyle, int choice) {
 959         LocaleProviderAdapter adapter;
 960         adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class,
 961                 desiredLocale);
 962         NumberFormat numberFormat = getInstance(adapter, desiredLocale,
 963                 formatStyle, choice);
 964         if (numberFormat == null) {
 965             numberFormat = getInstance(LocaleProviderAdapter.forJRE(),
 966                     desiredLocale, formatStyle, choice);
 967         }
</pre>
<hr />
<pre>
 979             break;
 980         case PERCENTSTYLE:
 981             numberFormat = provider.getPercentInstance(locale);
 982             break;
 983         case CURRENCYSTYLE:
 984             numberFormat = provider.getCurrencyInstance(locale);
 985             break;
 986         case INTEGERSTYLE:
 987             numberFormat = provider.getIntegerInstance(locale);
 988             break;
 989         case COMPACTSTYLE:
 990             numberFormat = provider.getCompactNumberInstance(locale, formatStyle);
 991             break;
 992         }
 993         return numberFormat;
 994     }
 995 
 996     /**
 997      * First, read in the default serializable data.
 998      *
<span class="line-modified"> 999      * Then, if {@code serialVersionOnStream} is less than 1, indicating that</span>
1000      * the stream was written by JDK 1.1,
<span class="line-modified">1001      * set the {@code int} fields such as {@code maximumIntegerDigits}</span>
<span class="line-modified">1002      * to be equal to the {@code byte} fields such as {@code maxIntegerDigits},</span>
<span class="line-modified">1003      * since the {@code int} fields were not present in JDK 1.1.</span>
1004      * Finally, set serialVersionOnStream back to the maximum allowed value so that
1005      * default serialization will work properly if this object is streamed out again.
1006      *
<span class="line-modified">1007      * &lt;p&gt;If {@code minimumIntegerDigits} is greater than</span>
<span class="line-modified">1008      * {@code maximumIntegerDigits} or {@code minimumFractionDigits}</span>
<span class="line-modified">1009      * is greater than {@code maximumFractionDigits}, then the stream data</span>
<span class="line-modified">1010      * is invalid and this method throws an {@code InvalidObjectException}.</span>
1011      * In addition, if any of these values is negative, then this method throws
<span class="line-modified">1012      * an {@code InvalidObjectException}.</span>
1013      *
1014      * @since 1.2
1015      */
<span class="line-added">1016     @java.io.Serial</span>
1017     private void readObject(ObjectInputStream stream)
1018          throws IOException, ClassNotFoundException
1019     {
1020         stream.defaultReadObject();
1021         if (serialVersionOnStream &lt; 1) {
1022             // Didn&#39;t have additional int fields, reassign to use them.
1023             maximumIntegerDigits = maxIntegerDigits;
1024             minimumIntegerDigits = minIntegerDigits;
1025             maximumFractionDigits = maxFractionDigits;
1026             minimumFractionDigits = minFractionDigits;
1027         }
1028         if (minimumIntegerDigits &gt; maximumIntegerDigits ||
1029             minimumFractionDigits &gt; maximumFractionDigits ||
1030             minimumIntegerDigits &lt; 0 || minimumFractionDigits &lt; 0) {
1031             throw new InvalidObjectException(&quot;Digit count range invalid&quot;);
1032         }
1033         serialVersionOnStream = currentSerialVersion;
1034     }
1035 
1036     /**
1037      * Write out the default serializable data, after first setting
<span class="line-modified">1038      * the {@code byte} fields such as {@code maxIntegerDigits} to be</span>
<span class="line-modified">1039      * equal to the {@code int} fields such as {@code maximumIntegerDigits}</span>
<span class="line-modified">1040      * (or to {@code Byte.MAX_VALUE}, whichever is smaller), for compatibility</span>
1041      * with the JDK 1.1 version of the stream format.
1042      *
1043      * @since 1.2
1044      */
<span class="line-added">1045     @java.io.Serial</span>
1046     private void writeObject(ObjectOutputStream stream)
1047          throws IOException
1048     {
1049         maxIntegerDigits = (maximumIntegerDigits &gt; Byte.MAX_VALUE) ?
1050                            Byte.MAX_VALUE : (byte)maximumIntegerDigits;
1051         minIntegerDigits = (minimumIntegerDigits &gt; Byte.MAX_VALUE) ?
1052                            Byte.MAX_VALUE : (byte)minimumIntegerDigits;
1053         maxFractionDigits = (maximumFractionDigits &gt; Byte.MAX_VALUE) ?
1054                             Byte.MAX_VALUE : (byte)maximumFractionDigits;
1055         minFractionDigits = (minimumFractionDigits &gt; Byte.MAX_VALUE) ?
1056                             Byte.MAX_VALUE : (byte)minimumFractionDigits;
1057         stream.defaultWriteObject();
1058     }
1059 
1060     // Constants used by factory methods to specify a style of format.
1061     private static final int NUMBERSTYLE = 0;
1062     private static final int CURRENCYSTYLE = 1;
1063     private static final int PERCENTSTYLE = 2;
1064     private static final int SCIENTIFICSTYLE = 3;
1065     private static final int INTEGERSTYLE = 4;
1066     private static final int COMPACTSTYLE = 5;
1067 
1068     /**
1069      * True if the grouping (i.e. thousands) separator is used when
1070      * formatting and parsing numbers.
1071      *
1072      * @serial
1073      * @see #isGroupingUsed
1074      */
1075     private boolean groupingUsed = true;
1076 
1077     /**
1078      * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">1079      * number.  {@code maxIntegerDigits} must be greater than or equal to</span>
<span class="line-modified">1080      * {@code minIntegerDigits}.</span>
1081      * &lt;p&gt;
1082      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1083      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1084      * {@code int} field {@code maximumIntegerDigits} is used instead.</span>
<span class="line-modified">1085      * When writing to a stream, {@code maxIntegerDigits} is set to</span>
<span class="line-modified">1086      * {@code maximumIntegerDigits} or {@code Byte.MAX_VALUE},</span>
1087      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1088      * only if {@code serialVersionOnStream} is less than 1.</span>
1089      *
1090      * @serial
1091      * @see #getMaximumIntegerDigits
1092      */
1093     private byte    maxIntegerDigits = 40;
1094 
1095     /**
1096      * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">1097      * number.  {@code minimumIntegerDigits} must be less than or equal to</span>
<span class="line-modified">1098      * {@code maximumIntegerDigits}.</span>
1099      * &lt;p&gt;
1100      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1101      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1102      * {@code int} field {@code minimumIntegerDigits} is used instead.</span>
<span class="line-modified">1103      * When writing to a stream, {@code minIntegerDigits} is set to</span>
<span class="line-modified">1104      * {@code minimumIntegerDigits} or {@code Byte.MAX_VALUE},</span>
1105      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1106      * only if {@code serialVersionOnStream} is less than 1.</span>
1107      *
1108      * @serial
1109      * @see #getMinimumIntegerDigits
1110      */
1111     private byte    minIntegerDigits = 1;
1112 
1113     /**
1114      * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">1115      * number.  {@code maximumFractionDigits} must be greater than or equal to</span>
<span class="line-modified">1116      * {@code minimumFractionDigits}.</span>
1117      * &lt;p&gt;
1118      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1119      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1120      * {@code int} field {@code maximumFractionDigits} is used instead.</span>
<span class="line-modified">1121      * When writing to a stream, {@code maxFractionDigits} is set to</span>
<span class="line-modified">1122      * {@code maximumFractionDigits} or {@code Byte.MAX_VALUE},</span>
1123      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1124      * only if {@code serialVersionOnStream} is less than 1.</span>
1125      *
1126      * @serial
1127      * @see #getMaximumFractionDigits
1128      */
1129     private byte    maxFractionDigits = 3;    // invariant, &gt;= minFractionDigits
1130 
1131     /**
1132      * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">1133      * number.  {@code minimumFractionDigits} must be less than or equal to</span>
<span class="line-modified">1134      * {@code maximumFractionDigits}.</span>
1135      * &lt;p&gt;
1136      * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
1137      * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">1138      * {@code int} field {@code minimumFractionDigits} is used instead.</span>
<span class="line-modified">1139      * When writing to a stream, {@code minFractionDigits} is set to</span>
<span class="line-modified">1140      * {@code minimumFractionDigits} or {@code Byte.MAX_VALUE},</span>
1141      * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">1142      * only if {@code serialVersionOnStream} is less than 1.</span>
1143      *
1144      * @serial
1145      * @see #getMinimumFractionDigits
1146      */
1147     private byte    minFractionDigits = 0;
1148 
1149     /**
1150      * True if this format will parse numbers as integers only.
1151      *
1152      * @serial
1153      * @see #isParseIntegerOnly
1154      */
1155     private boolean parseIntegerOnly = false;
1156 
1157     // new fields for 1.2.  byte is too small for integer digits.
1158 
1159     /**
1160      * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">1161      * number.  {@code maximumIntegerDigits} must be greater than or equal to</span>
<span class="line-modified">1162      * {@code minimumIntegerDigits}.</span>
1163      *
1164      * @serial
1165      * @since 1.2
1166      * @see #getMaximumIntegerDigits
1167      */
1168     private int    maximumIntegerDigits = 40;
1169 
1170     /**
1171      * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">1172      * number.  {@code minimumIntegerDigits} must be less than or equal to</span>
<span class="line-modified">1173      * {@code maximumIntegerDigits}.</span>
1174      *
1175      * @serial
1176      * @since 1.2
1177      * @see #getMinimumIntegerDigits
1178      */
1179     private int    minimumIntegerDigits = 1;
1180 
1181     /**
1182      * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">1183      * number.  {@code maximumFractionDigits} must be greater than or equal to</span>
<span class="line-modified">1184      * {@code minimumFractionDigits}.</span>
1185      *
1186      * @serial
1187      * @since 1.2
1188      * @see #getMaximumFractionDigits
1189      */
1190     private int    maximumFractionDigits = 3;    // invariant, &gt;= minFractionDigits
1191 
1192     /**
1193      * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">1194      * number.  {@code minimumFractionDigits} must be less than or equal to</span>
<span class="line-modified">1195      * {@code maximumFractionDigits}.</span>
1196      *
1197      * @serial
1198      * @since 1.2
1199      * @see #getMinimumFractionDigits
1200      */
1201     private int    minimumFractionDigits = 0;
1202 
1203     static final int currentSerialVersion = 1;
1204 
1205     /**
<span class="line-modified">1206      * Describes the version of {@code NumberFormat} present on the stream.</span>
1207      * Possible values are:
1208      * &lt;ul&gt;
1209      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
<span class="line-modified">1210      *     In this version, the {@code int} fields such as</span>
<span class="line-modified">1211      *     {@code maximumIntegerDigits} were not present, and the {@code byte}</span>
<span class="line-modified">1212      *     fields such as {@code maxIntegerDigits} are used instead.</span>
1213      *
1214      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
<span class="line-modified">1215      *     {@code byte} fields such as {@code maxIntegerDigits} are ignored,</span>
<span class="line-modified">1216      *     and the {@code int} fields such as {@code maximumIntegerDigits}</span>
1217      *     are used instead.
1218      * &lt;/ul&gt;
<span class="line-modified">1219      * When streaming out a {@code NumberFormat}, the most recent format</span>
<span class="line-modified">1220      * (corresponding to the highest allowable {@code serialVersionOnStream})</span>
1221      * is always written.
1222      *
1223      * @serial
1224      * @since 1.2
1225      */
1226     private int serialVersionOnStream = currentSerialVersion;
1227 
1228     // Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization
1229     // ID for backward compatibility.
<span class="line-added">1230     @java.io.Serial</span>
1231     static final long serialVersionUID = -2308460125733713944L;
1232 
1233 
1234     //
1235     // class for AttributedCharacterIterator attributes
1236     //
1237     /**
1238      * Defines constants that are used as attribute keys in the
<span class="line-modified">1239      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">1240      * from {@code NumberFormat.formatToCharacterIterator} and as</span>
<span class="line-modified">1241      * field identifiers in {@code FieldPosition}.</span>
1242      *
1243      * @since 1.4
1244      */
1245     public static class Field extends Format.Field {
1246 
1247         // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">1248         @java.io.Serial</span>
1249         private static final long serialVersionUID = 7494728892700160890L;
1250 
1251         // table of all instances in this class, used by readResolve
1252         private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(11);
1253 
1254         /**
1255          * Creates a Field instance with the specified
1256          * name.
1257          *
1258          * @param name Name of the attribute
1259          */
1260         protected Field(String name) {
1261             super(name);
1262             if (this.getClass() == NumberFormat.Field.class) {
1263                 instanceMap.put(name, this);
1264             }
1265         }
1266 
1267         /**
1268          * Resolves instances being deserialized to the predefined constants.
1269          *
1270          * @throws InvalidObjectException if the constant could not be resolved.
1271          * @return resolved NumberFormat.Field constant
1272          */
1273         @Override
<span class="line-added">1274         @java.io.Serial</span>
1275         protected Object readResolve() throws InvalidObjectException {
1276             if (this.getClass() != NumberFormat.Field.class) {
1277                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1278             }
1279 
1280             Object instance = instanceMap.get(getName());
1281             if (instance != null) {
1282                 return instance;
1283             } else {
1284                 throw new InvalidObjectException(&quot;unknown attribute name&quot;);
1285             }
1286         }
1287 
1288         /**
1289          * Constant identifying the integer field.
1290          */
1291         public static final Field INTEGER = new Field(&quot;integer&quot;);
1292 
1293         /**
1294          * Constant identifying the fraction field.
</pre>
</td>
</tr>
</table>
<center><a href="Normalizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ParseException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
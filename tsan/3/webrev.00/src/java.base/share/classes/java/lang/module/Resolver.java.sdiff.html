<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/module/Resolver.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResolvedModule.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/module/Resolver.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.module;
 27 
 28 import java.io.PrintStream;
 29 import java.lang.module.ModuleDescriptor.Provides;
 30 import java.lang.module.ModuleDescriptor.Requires.Modifier;
<span class="line-removed"> 31 import java.net.URI;</span>
 32 import java.util.ArrayDeque;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import java.util.Deque;
 37 import java.util.HashMap;
 38 import java.util.HashSet;
 39 import java.util.LinkedHashSet;
 40 import java.util.List;
 41 import java.util.Map;
 42 import java.util.Optional;
 43 import java.util.Set;
 44 import java.util.stream.Collectors;
 45 
 46 import jdk.internal.module.ModuleHashes;
 47 import jdk.internal.module.ModuleReferenceImpl;

 48 import jdk.internal.module.ModuleTarget;
 49 
 50 /**
 51  * The resolver used by {@link Configuration#resolve} and {@link
 52  * Configuration#resolveAndBind}.
 53  *
 54  * @implNote The resolver is used at VM startup and so deliberately avoids
 55  * using lambda and stream usages in code paths used during startup.
 56  */
 57 
 58 final class Resolver {
 59 
 60     private final ModuleFinder beforeFinder;
 61     private final List&lt;Configuration&gt; parents;
 62     private final ModuleFinder afterFinder;
 63     private final PrintStream traceOutput;
 64 
 65     // maps module name to module reference
 66     private final Map&lt;String, ModuleReference&gt; nameToReference = new HashMap&lt;&gt;();
 67 
</pre>
<hr />
<pre>
198                 }
199 
200                 if (!nameToReference.containsKey(dn)) {
201                     addFoundModule(mref);
202                     q.offer(mref.descriptor());
203                 }
204 
205             }
206 
207             resolved.add(descriptor);
208         }
209 
210         return resolved;
211     }
212 
213     /**
214      * Augments the set of resolved modules with modules induced by the
215      * service-use relation.
216      */
217     Resolver bind() {


218 








219         // Scan the finders for all available service provider modules. As
220         // java.base uses services then the module finders will be scanned
221         // anyway.
222         Map&lt;String, Set&lt;ModuleReference&gt;&gt; availableProviders = new HashMap&lt;&gt;();
223         for (ModuleReference mref : findAll()) {
224             ModuleDescriptor descriptor = mref.descriptor();
<span class="line-removed">225             if (!descriptor.provides().isEmpty()) {</span>
226 








227                 for (Provides provides :  descriptor.provides()) {
228                     String sn = provides.service();
229 
230                     // computeIfAbsent
231                     Set&lt;ModuleReference&gt; providers = availableProviders.get(sn);
232                     if (providers == null) {
233                         providers = new HashSet&lt;&gt;();
234                         availableProviders.put(sn, providers);
235                     }
236                     providers.add(mref);
237                 }
238 
239             }
240         }
241 
242         // create the visit stack
243         Deque&lt;ModuleDescriptor&gt; q = new ArrayDeque&lt;&gt;();
244 
245         // the initial set of modules that may use services
246         Set&lt;ModuleDescriptor&gt; initialConsumers;
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.module;
 27 
 28 import java.io.PrintStream;
 29 import java.lang.module.ModuleDescriptor.Provides;
 30 import java.lang.module.ModuleDescriptor.Requires.Modifier;

 31 import java.util.ArrayDeque;
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.Collection;
 35 import java.util.Deque;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.LinkedHashSet;
 39 import java.util.List;
 40 import java.util.Map;
 41 import java.util.Optional;
 42 import java.util.Set;
 43 import java.util.stream.Collectors;
 44 
 45 import jdk.internal.module.ModuleHashes;
 46 import jdk.internal.module.ModuleReferenceImpl;
<span class="line-added"> 47 import jdk.internal.module.ModuleResolution;</span>
 48 import jdk.internal.module.ModuleTarget;
 49 
 50 /**
 51  * The resolver used by {@link Configuration#resolve} and {@link
 52  * Configuration#resolveAndBind}.
 53  *
 54  * @implNote The resolver is used at VM startup and so deliberately avoids
 55  * using lambda and stream usages in code paths used during startup.
 56  */
 57 
 58 final class Resolver {
 59 
 60     private final ModuleFinder beforeFinder;
 61     private final List&lt;Configuration&gt; parents;
 62     private final ModuleFinder afterFinder;
 63     private final PrintStream traceOutput;
 64 
 65     // maps module name to module reference
 66     private final Map&lt;String, ModuleReference&gt; nameToReference = new HashMap&lt;&gt;();
 67 
</pre>
<hr />
<pre>
198                 }
199 
200                 if (!nameToReference.containsKey(dn)) {
201                     addFoundModule(mref);
202                     q.offer(mref.descriptor());
203                 }
204 
205             }
206 
207             resolved.add(descriptor);
208         }
209 
210         return resolved;
211     }
212 
213     /**
214      * Augments the set of resolved modules with modules induced by the
215      * service-use relation.
216      */
217     Resolver bind() {
<span class="line-added">218         return bind(/*bindIncubatorModules*/true);</span>
<span class="line-added">219     }</span>
220 
<span class="line-added">221     /**</span>
<span class="line-added">222      * Augments the set of resolved modules with modules induced by the</span>
<span class="line-added">223      * service-use relation.</span>
<span class="line-added">224      *</span>
<span class="line-added">225      * @param bindIncubatorModules true if incubator modules are candidates to</span>
<span class="line-added">226      *        add to the module graph</span>
<span class="line-added">227      */</span>
<span class="line-added">228     Resolver bind(boolean bindIncubatorModules) {</span>
229         // Scan the finders for all available service provider modules. As
230         // java.base uses services then the module finders will be scanned
231         // anyway.
232         Map&lt;String, Set&lt;ModuleReference&gt;&gt; availableProviders = new HashMap&lt;&gt;();
233         for (ModuleReference mref : findAll()) {
234             ModuleDescriptor descriptor = mref.descriptor();

235 
<span class="line-added">236             boolean candidate;</span>
<span class="line-added">237             if (!bindIncubatorModules &amp;&amp; (mref instanceof ModuleReferenceImpl)) {</span>
<span class="line-added">238                 ModuleResolution mres = ((ModuleReferenceImpl) mref).moduleResolution();</span>
<span class="line-added">239                 candidate = (mres == null) || (mres.hasIncubatingWarning() == false);</span>
<span class="line-added">240             } else {</span>
<span class="line-added">241                 candidate = true;</span>
<span class="line-added">242             }</span>
<span class="line-added">243             if (candidate &amp;&amp; !descriptor.provides().isEmpty()) {</span>
244                 for (Provides provides :  descriptor.provides()) {
245                     String sn = provides.service();
246 
247                     // computeIfAbsent
248                     Set&lt;ModuleReference&gt; providers = availableProviders.get(sn);
249                     if (providers == null) {
250                         providers = new HashSet&lt;&gt;();
251                         availableProviders.put(sn, providers);
252                     }
253                     providers.add(mref);
254                 }
255 
256             }
257         }
258 
259         // create the visit stack
260         Deque&lt;ModuleDescriptor&gt; q = new ArrayDeque&lt;&gt;();
261 
262         // the initial set of modules that may use services
263         Set&lt;ModuleDescriptor&gt; initialConsumers;
</pre>
</td>
</tr>
</table>
<center><a href="ResolvedModule.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
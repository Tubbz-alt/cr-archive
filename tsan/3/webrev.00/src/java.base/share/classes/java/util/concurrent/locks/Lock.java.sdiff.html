<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/locks/Lock.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Condition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LockSupport.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/Lock.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
100  * the lock that can timeout ({@link #tryLock(long, TimeUnit)}).
101  *
102  * &lt;p&gt;A {@code Lock} class can also provide behavior and semantics
103  * that is quite different from that of the implicit monitor lock,
104  * such as guaranteed ordering, non-reentrant usage, or deadlock
105  * detection. If an implementation provides such specialized semantics
106  * then the implementation must document those semantics.
107  *
108  * &lt;p&gt;Note that {@code Lock} instances are just normal objects and can
109  * themselves be used as the target in a {@code synchronized} statement.
110  * Acquiring the
111  * monitor lock of a {@code Lock} instance has no specified relationship
112  * with invoking any of the {@link #lock} methods of that instance.
113  * It is recommended that to avoid confusion you never use {@code Lock}
114  * instances in this way, except within their own implementation.
115  *
116  * &lt;p&gt;Except where noted, passing a {@code null} value for any
117  * parameter will result in a {@link NullPointerException} being
118  * thrown.
119  *
<span class="line-modified">120  * &lt;h3&gt;Memory Synchronization&lt;/h3&gt;</span>
121  *
122  * &lt;p&gt;All {@code Lock} implementations &lt;em&gt;must&lt;/em&gt; enforce the same
123  * memory synchronization semantics as provided by the built-in monitor
124  * lock, as described in
<span class="line-removed">125  * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4&quot;&gt;</span>
126  * Chapter 17 of
<span class="line-modified">127  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;&lt;/a&gt;:</span>
128  * &lt;ul&gt;
129  * &lt;li&gt;A successful {@code lock} operation has the same memory
130  * synchronization effects as a successful &lt;em&gt;Lock&lt;/em&gt; action.
131  * &lt;li&gt;A successful {@code unlock} operation has the same
132  * memory synchronization effects as a successful &lt;em&gt;Unlock&lt;/em&gt; action.
133  * &lt;/ul&gt;
134  *
135  * Unsuccessful locking and unlocking operations, and reentrant
136  * locking/unlocking operations, do not require any memory
137  * synchronization effects.
138  *
<span class="line-modified">139  * &lt;h3&gt;Implementation Considerations&lt;/h3&gt;</span>
140  *
141  * &lt;p&gt;The three forms of lock acquisition (interruptible,
142  * non-interruptible, and timed) may differ in their performance
143  * characteristics, ordering guarantees, or other implementation
144  * qualities.  Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt;
145  * acquisition of a lock may not be available in a given {@code Lock}
146  * class.  Consequently, an implementation is not required to define
147  * exactly the same guarantees or semantics for all three forms of
148  * lock acquisition, nor is it required to support interruption of an
149  * ongoing lock acquisition.  An implementation is required to clearly
150  * document the semantics and guarantees provided by each of the
151  * locking methods. It must also obey the interruption semantics as
152  * defined in this interface, to the extent that interruption of lock
153  * acquisition is supported: which is either totally, or only on
154  * method entry.
155  *
156  * &lt;p&gt;As interruption generally implies cancellation, and checks for
157  * interruption are often infrequent, an implementation can favor responding
158  * to an interrupt over normal method return. This is true even if it can be
159  * shown that the interrupt occurred after another action may have unblocked
160  * the thread. An implementation should document this behavior.
161  *
162  * @see ReentrantLock
163  * @see Condition
164  * @see ReadWriteLock

165  *
166  * @since 1.5
167  * @author Doug Lea
168  */
169 public interface Lock {
170 
171     /**
172      * Acquires the lock.
173      *
174      * &lt;p&gt;If the lock is not available then the current thread becomes
175      * disabled for thread scheduling purposes and lies dormant until the
176      * lock has been acquired.
177      *
178      * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
179      *
180      * &lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use
181      * of the lock, such as an invocation that would cause deadlock, and
182      * may throw an (unchecked) exception in such circumstances.  The
183      * circumstances and the exception type must be documented by that
184      * {@code Lock} implementation.
</pre>
</td>
<td>
<hr />
<pre>
100  * the lock that can timeout ({@link #tryLock(long, TimeUnit)}).
101  *
102  * &lt;p&gt;A {@code Lock} class can also provide behavior and semantics
103  * that is quite different from that of the implicit monitor lock,
104  * such as guaranteed ordering, non-reentrant usage, or deadlock
105  * detection. If an implementation provides such specialized semantics
106  * then the implementation must document those semantics.
107  *
108  * &lt;p&gt;Note that {@code Lock} instances are just normal objects and can
109  * themselves be used as the target in a {@code synchronized} statement.
110  * Acquiring the
111  * monitor lock of a {@code Lock} instance has no specified relationship
112  * with invoking any of the {@link #lock} methods of that instance.
113  * It is recommended that to avoid confusion you never use {@code Lock}
114  * instances in this way, except within their own implementation.
115  *
116  * &lt;p&gt;Except where noted, passing a {@code null} value for any
117  * parameter will result in a {@link NullPointerException} being
118  * thrown.
119  *
<span class="line-modified">120  * &lt;h2&gt;Memory Synchronization&lt;/h2&gt;</span>
121  *
122  * &lt;p&gt;All {@code Lock} implementations &lt;em&gt;must&lt;/em&gt; enforce the same
123  * memory synchronization semantics as provided by the built-in monitor
124  * lock, as described in

125  * Chapter 17 of
<span class="line-modified">126  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</span>
127  * &lt;ul&gt;
128  * &lt;li&gt;A successful {@code lock} operation has the same memory
129  * synchronization effects as a successful &lt;em&gt;Lock&lt;/em&gt; action.
130  * &lt;li&gt;A successful {@code unlock} operation has the same
131  * memory synchronization effects as a successful &lt;em&gt;Unlock&lt;/em&gt; action.
132  * &lt;/ul&gt;
133  *
134  * Unsuccessful locking and unlocking operations, and reentrant
135  * locking/unlocking operations, do not require any memory
136  * synchronization effects.
137  *
<span class="line-modified">138  * &lt;h2&gt;Implementation Considerations&lt;/h2&gt;</span>
139  *
140  * &lt;p&gt;The three forms of lock acquisition (interruptible,
141  * non-interruptible, and timed) may differ in their performance
142  * characteristics, ordering guarantees, or other implementation
143  * qualities.  Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt;
144  * acquisition of a lock may not be available in a given {@code Lock}
145  * class.  Consequently, an implementation is not required to define
146  * exactly the same guarantees or semantics for all three forms of
147  * lock acquisition, nor is it required to support interruption of an
148  * ongoing lock acquisition.  An implementation is required to clearly
149  * document the semantics and guarantees provided by each of the
150  * locking methods. It must also obey the interruption semantics as
151  * defined in this interface, to the extent that interruption of lock
152  * acquisition is supported: which is either totally, or only on
153  * method entry.
154  *
155  * &lt;p&gt;As interruption generally implies cancellation, and checks for
156  * interruption are often infrequent, an implementation can favor responding
157  * to an interrupt over normal method return. This is true even if it can be
158  * shown that the interrupt occurred after another action may have unblocked
159  * the thread. An implementation should document this behavior.
160  *
161  * @see ReentrantLock
162  * @see Condition
163  * @see ReadWriteLock
<span class="line-added">164  * @jls 17.4 Memory Model</span>
165  *
166  * @since 1.5
167  * @author Doug Lea
168  */
169 public interface Lock {
170 
171     /**
172      * Acquires the lock.
173      *
174      * &lt;p&gt;If the lock is not available then the current thread becomes
175      * disabled for thread scheduling purposes and lies dormant until the
176      * lock has been acquired.
177      *
178      * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
179      *
180      * &lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use
181      * of the lock, such as an invocation that would cause deadlock, and
182      * may throw an (unchecked) exception in such circumstances.  The
183      * circumstances and the exception type must be documented by that
184      * {@code Lock} implementation.
</pre>
</td>
</tr>
</table>
<center><a href="Condition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LockSupport.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
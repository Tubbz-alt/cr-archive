<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/StringLatin1.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
 28 import java.util.Arrays;
 29 import java.util.Locale;
 30 import java.util.Objects;
 31 import java.util.Spliterator;
 32 import java.util.function.Consumer;
 33 import java.util.function.IntConsumer;
 34 import java.util.stream.IntStream;
 35 import java.util.stream.Stream;
 36 import java.util.stream.StreamSupport;
 37 import jdk.internal.HotSpotIntrinsicCandidate;
<a name="2" id="anc2"></a>
 38 
 39 import static java.lang.String.LATIN1;
 40 import static java.lang.String.UTF16;
 41 import static java.lang.String.checkOffset;
 42 
 43 final class StringLatin1 {
 44 
 45     public static char charAt(byte[] value, int index) {
 46         if (index &lt; 0 || index &gt;= value.length) {
 47             throw new StringIndexOutOfBoundsException(index);
 48         }
 49         return (char)(value[index] &amp; 0xff);
 50     }
 51 
 52     public static boolean canEncode(int cp) {
 53         return cp &gt;&gt;&gt; 8 == 0;
 54     }
 55 
 56     public static int length(byte[] value) {
 57         return value.length;
 58     }
 59 
 60     public static int codePointAt(byte[] value, int index, int end) {
 61         return value[index] &amp; 0xff;
 62     }
 63 
 64     public static int codePointBefore(byte[] value, int index) {
 65         return value[index - 1] &amp; 0xff;
 66     }
 67 
 68     public static int codePointCount(byte[] value, int beginIndex, int endIndex) {
 69         return endIndex - beginIndex;
 70     }
 71 
 72     public static char[] toChars(byte[] value) {
 73         char[] dst = new char[value.length];
 74         inflate(value, 0, dst, 0, value.length);
 75         return dst;
 76     }
 77 
 78     public static byte[] inflate(byte[] value, int off, int len) {
 79         byte[] ret = StringUTF16.newBytesFor(len);
 80         inflate(value, off, ret, 0, len);
 81         return ret;
 82     }
 83 
 84     public static void getChars(byte[] value, int srcBegin, int srcEnd, char dst[], int dstBegin) {
 85         inflate(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
 86     }
 87 
 88     public static void getBytes(byte[] value, int srcBegin, int srcEnd, byte dst[], int dstBegin) {
 89         System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
 90     }
 91 
 92     @HotSpotIntrinsicCandidate
 93     public static boolean equals(byte[] value, byte[] other) {
 94         if (value.length == other.length) {
 95             for (int i = 0; i &lt; value.length; i++) {
 96                 if (value[i] != other[i]) {
 97                     return false;
 98                 }
 99             }
100             return true;
101         }
102         return false;
103     }
104 
105     @HotSpotIntrinsicCandidate
106     public static int compareTo(byte[] value, byte[] other) {
107         int len1 = value.length;
108         int len2 = other.length;
109         return compareTo(value, other, len1, len2);
110     }
111 
112     public static int compareTo(byte[] value, byte[] other, int len1, int len2) {
113         int lim = Math.min(len1, len2);
114         for (int k = 0; k &lt; lim; k++) {
115             if (value[k] != other[k]) {
116                 return getChar(value, k) - getChar(other, k);
117             }
118         }
119         return len1 - len2;
120     }
121 
122     @HotSpotIntrinsicCandidate
123     public static int compareToUTF16(byte[] value, byte[] other) {
124         int len1 = length(value);
125         int len2 = StringUTF16.length(other);
126         return compareToUTF16Values(value, other, len1, len2);
127     }
128 
129     /*
130      * Checks the boundary and then compares the byte arrays.
131      */
132     public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2) {
133         checkOffset(len1, length(value));
134         checkOffset(len2, StringUTF16.length(other));
135 
136         return compareToUTF16Values(value, other, len1, len2);
137     }
138 
139     private static int compareToUTF16Values(byte[] value, byte[] other, int len1, int len2) {
140         int lim = Math.min(len1, len2);
141         for (int k = 0; k &lt; lim; k++) {
142             char c1 = getChar(value, k);
143             char c2 = StringUTF16.getChar(other, k);
144             if (c1 != c2) {
145                 return c1 - c2;
146             }
147         }
148         return len1 - len2;
149     }
150 
151     public static int compareToCI(byte[] value, byte[] other) {
152         int len1 = value.length;
153         int len2 = other.length;
154         int lim = Math.min(len1, len2);
155         for (int k = 0; k &lt; lim; k++) {
156             if (value[k] != other[k]) {
157                 char c1 = (char) CharacterDataLatin1.instance.toUpperCase(getChar(value, k));
158                 char c2 = (char) CharacterDataLatin1.instance.toUpperCase(getChar(other, k));
159                 if (c1 != c2) {
160                     c1 = Character.toLowerCase(c1);
161                     c2 = Character.toLowerCase(c2);
162                     if (c1 != c2) {
163                         return c1 - c2;
164                     }
165                 }
166             }
167         }
168         return len1 - len2;
169     }
170 
171     public static int compareToCI_UTF16(byte[] value, byte[] other) {
172         int len1 = length(value);
173         int len2 = StringUTF16.length(other);
174         int lim = Math.min(len1, len2);
175         for (int k = 0; k &lt; lim; k++) {
176             char c1 = getChar(value, k);
177             char c2 = StringUTF16.getChar(other, k);
178             if (c1 != c2) {
<a name="3" id="anc3"></a><span class="line-modified">179                 c1 = Character.toUpperCase(c1);</span>
180                 c2 = Character.toUpperCase(c2);
181                 if (c1 != c2) {
182                     c1 = Character.toLowerCase(c1);
183                     c2 = Character.toLowerCase(c2);
184                     if (c1 != c2) {
185                         return c1 - c2;
186                     }
187                 }
188             }
189         }
190         return len1 - len2;
191     }
192 
193     public static int hashCode(byte[] value) {
194         int h = 0;
195         for (byte v : value) {
196             h = 31 * h + (v &amp; 0xff);
197         }
198         return h;
199     }
200 
201     public static int indexOf(byte[] value, int ch, int fromIndex) {
202         if (!canEncode(ch)) {
203             return -1;
204         }
205         int max = value.length;
206         if (fromIndex &lt; 0) {
207             fromIndex = 0;
208         } else if (fromIndex &gt;= max) {
209             // Note: fromIndex might be near -1&gt;&gt;&gt;1.
210             return -1;
211         }
212         byte c = (byte)ch;
213         for (int i = fromIndex; i &lt; max; i++) {
214             if (value[i] == c) {
215                return i;
216             }
217         }
218         return -1;
219     }
220 
221     @HotSpotIntrinsicCandidate
222     public static int indexOf(byte[] value, byte[] str) {
223         if (str.length == 0) {
224             return 0;
225         }
226         if (value.length == 0) {
227             return -1;
228         }
229         return indexOf(value, value.length, str, str.length, 0);
230     }
231 
232     @HotSpotIntrinsicCandidate
233     public static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {
234         byte first = str[0];
235         int max = (valueCount - strCount);
236         for (int i = fromIndex; i &lt;= max; i++) {
237             // Look for first character.
238             if (value[i] != first) {
239                 while (++i &lt;= max &amp;&amp; value[i] != first);
240             }
241             // Found first character, now look at the rest of value
242             if (i &lt;= max) {
243                 int j = i + 1;
244                 int end = j + strCount - 1;
245                 for (int k = 1; j &lt; end &amp;&amp; value[j] == str[k]; j++, k++);
246                 if (j == end) {
247                     // Found whole string.
248                     return i;
249                 }
250             }
251         }
252         return -1;
253     }
254 
255     public static int lastIndexOf(byte[] src, int srcCount,
256                                   byte[] tgt, int tgtCount, int fromIndex) {
257         int min = tgtCount - 1;
258         int i = min + fromIndex;
259         int strLastIndex = tgtCount - 1;
260         char strLastChar = (char)(tgt[strLastIndex] &amp; 0xff);
261 
262   startSearchForLastChar:
263         while (true) {
264             while (i &gt;= min &amp;&amp; (src[i] &amp; 0xff) != strLastChar) {
265                 i--;
266             }
267             if (i &lt; min) {
268                 return -1;
269             }
270             int j = i - 1;
271             int start = j - strLastIndex;
272             int k = strLastIndex - 1;
273             while (j &gt; start) {
274                 if ((src[j--] &amp; 0xff) != (tgt[k--] &amp; 0xff)) {
275                     i--;
276                     continue startSearchForLastChar;
277                 }
278             }
279             return start + 1;
280         }
281     }
282 
283     public static int lastIndexOf(final byte[] value, int ch, int fromIndex) {
284         if (!canEncode(ch)) {
285             return -1;
286         }
287         int off  = Math.min(fromIndex, value.length - 1);
288         for (; off &gt;= 0; off--) {
289             if (value[off] == (byte)ch) {
290                 return off;
291             }
292         }
293         return -1;
294     }
295 
296     public static String replace(byte[] value, char oldChar, char newChar) {
297         if (canEncode(oldChar)) {
298             int len = value.length;
299             int i = -1;
300             while (++i &lt; len) {
301                 if (value[i] == (byte)oldChar) {
302                     break;
303                 }
304             }
305             if (i &lt; len) {
306                 if (canEncode(newChar)) {
<a name="4" id="anc4"></a><span class="line-modified">307                     byte buf[] = new byte[len];</span>
308                     for (int j = 0; j &lt; i; j++) {    // TBD arraycopy?
309                         buf[j] = value[j];
310                     }
311                     while (i &lt; len) {
312                         byte c = value[i];
313                         buf[i] = (c == (byte)oldChar) ? (byte)newChar : c;
314                         i++;
315                     }
316                     return new String(buf, LATIN1);
317                 } else {
318                     byte[] buf = StringUTF16.newBytesFor(len);
319                     // inflate from latin1 to UTF16
320                     inflate(value, 0, buf, 0, i);
321                     while (i &lt; len) {
322                         char c = (char)(value[i] &amp; 0xff);
323                         StringUTF16.putChar(buf, i, (c == oldChar) ? newChar : c);
324                         i++;
325                     }
326                     return new String(buf, UTF16);
327                 }
328             }
329         }
330         return null; // for string to return this;
331     }
332 
<a name="5" id="anc5"></a>

















































333     // case insensitive
334     public static boolean regionMatchesCI(byte[] value, int toffset,
335                                           byte[] other, int ooffset, int len) {
336         int last = toffset + len;
337         while (toffset &lt; last) {
338             char c1 = (char)(value[toffset++] &amp; 0xff);
339             char c2 = (char)(other[ooffset++] &amp; 0xff);
340             if (c1 == c2) {
341                 continue;
342             }
<a name="6" id="anc6"></a><span class="line-modified">343             char u1 = Character.toUpperCase(c1);</span>
<span class="line-modified">344             char u2 = Character.toUpperCase(c2);</span>
345             if (u1 == u2) {
346                 continue;
347             }
348             if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {
349                 continue;
350             }
351             return false;
352         }
353         return true;
354     }
355 
356     public static boolean regionMatchesCI_UTF16(byte[] value, int toffset,
357                                                 byte[] other, int ooffset, int len) {
358         int last = toffset + len;
359         while (toffset &lt; last) {
360             char c1 = (char)(value[toffset++] &amp; 0xff);
361             char c2 = StringUTF16.getChar(other, ooffset++);
362             if (c1 == c2) {
363                 continue;
364             }
<a name="7" id="anc7"></a><span class="line-modified">365             char u1 = Character.toUpperCase(c1);</span>
366             char u2 = Character.toUpperCase(c2);
367             if (u1 == u2) {
368                 continue;
369             }
370             if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {
371                 continue;
372             }
373             return false;
374         }
375         return true;
376     }
377 
378     public static String toLowerCase(String str, byte[] value, Locale locale) {
379         if (locale == null) {
380             throw new NullPointerException();
381         }
382         int first;
383         final int len = value.length;
384         // Now check if there are any characters that need to be changed, or are surrogate
385         for (first = 0 ; first &lt; len; first++) {
386             int cp = value[first] &amp; 0xff;
<a name="8" id="anc8"></a><span class="line-modified">387             if (cp != Character.toLowerCase(cp)) {  // no need to check Character.ERROR</span>
388                 break;
389             }
390         }
391         if (first == len)
392             return str;
393         String lang = locale.getLanguage();
394         if (lang == &quot;tr&quot; || lang == &quot;az&quot; || lang == &quot;lt&quot;) {
395             return toLowerCaseEx(str, value, first, locale, true);
396         }
397         byte[] result = new byte[len];
398         System.arraycopy(value, 0, result, 0, first);  // Just copy the first few
399                                                        // lowerCase characters.
400         for (int i = first; i &lt; len; i++) {
401             int cp = value[i] &amp; 0xff;
<a name="9" id="anc9"></a><span class="line-modified">402             cp = Character.toLowerCase(cp);</span>
403             if (!canEncode(cp)) {                      // not a latin1 character
404                 return toLowerCaseEx(str, value, first, locale, false);
405             }
406             result[i] = (byte)cp;
407         }
408         return new String(result, LATIN1);
409     }
410 
411     private static String toLowerCaseEx(String str, byte[] value,
412                                         int first, Locale locale, boolean localeDependent)
413     {
414         byte[] result = StringUTF16.newBytesFor(value.length);
415         int resultOffset = 0;
416         for (int i = 0; i &lt; first; i++) {
417             StringUTF16.putChar(result, resultOffset++, value[i] &amp; 0xff);
418         }
419         for (int i = first; i &lt; value.length; i++) {
420             int srcChar = value[i] &amp; 0xff;
421             int lowerChar;
422             char[] lowerCharArray;
423             if (localeDependent) {
424                 lowerChar = ConditionalSpecialCasing.toLowerCaseEx(str, i, locale);
425             } else {
<a name="10" id="anc10"></a><span class="line-modified">426                 lowerChar = Character.toLowerCase(srcChar);</span>
427             }
428             if (Character.isBmpCodePoint(lowerChar)) {    // Character.ERROR is not a bmp
429                 StringUTF16.putChar(result, resultOffset++, lowerChar);
430             } else {
431                 if (lowerChar == Character.ERROR) {
432                     lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(str, i, locale);
433                 } else {
434                     lowerCharArray = Character.toChars(lowerChar);
435                 }
436                 /* Grow result if needed */
437                 int mapLen = lowerCharArray.length;
438                 if (mapLen &gt; 1) {
439                     byte[] result2 = StringUTF16.newBytesFor((result.length &gt;&gt; 1) + mapLen - 1);
440                     System.arraycopy(result, 0, result2, 0, resultOffset &lt;&lt; 1);
441                     result = result2;
442                 }
443                 for (int x = 0; x &lt; mapLen; ++x) {
444                     StringUTF16.putChar(result, resultOffset++, lowerCharArray[x]);
445                 }
446             }
447         }
448         return StringUTF16.newString(result, 0, resultOffset);
449     }
450 
451     public static String toUpperCase(String str, byte[] value, Locale locale) {
452         if (locale == null) {
453             throw new NullPointerException();
454         }
455         int first;
456         final int len = value.length;
457 
458         // Now check if there are any characters that need to be changed, or are surrogate
459         for (first = 0 ; first &lt; len; first++ ) {
460             int cp = value[first] &amp; 0xff;
<a name="11" id="anc11"></a><span class="line-modified">461             if (cp != Character.toUpperCaseEx(cp)) {   // no need to check Character.ERROR</span>
462                 break;
463             }
464         }
465         if (first == len) {
466             return str;
467         }
468         String lang = locale.getLanguage();
469         if (lang == &quot;tr&quot; || lang == &quot;az&quot; || lang == &quot;lt&quot;) {
470             return toUpperCaseEx(str, value, first, locale, true);
471         }
472         byte[] result = new byte[len];
473         System.arraycopy(value, 0, result, 0, first);  // Just copy the first few
474                                                        // upperCase characters.
475         for (int i = first; i &lt; len; i++) {
476             int cp = value[i] &amp; 0xff;
<a name="12" id="anc12"></a><span class="line-modified">477             cp = Character.toUpperCaseEx(cp);</span>
478             if (!canEncode(cp)) {                      // not a latin1 character
479                 return toUpperCaseEx(str, value, first, locale, false);
480             }
481             result[i] = (byte)cp;
482         }
483         return new String(result, LATIN1);
484     }
485 
486     private static String toUpperCaseEx(String str, byte[] value,
487                                         int first, Locale locale, boolean localeDependent)
488     {
489         byte[] result = StringUTF16.newBytesFor(value.length);
490         int resultOffset = 0;
491         for (int i = 0; i &lt; first; i++) {
492             StringUTF16.putChar(result, resultOffset++, value[i] &amp; 0xff);
493         }
494         for (int i = first; i &lt; value.length; i++) {
495             int srcChar = value[i] &amp; 0xff;
496             int upperChar;
497             char[] upperCharArray;
498             if (localeDependent) {
499                 upperChar = ConditionalSpecialCasing.toUpperCaseEx(str, i, locale);
500             } else {
<a name="13" id="anc13"></a><span class="line-modified">501                 upperChar = Character.toUpperCaseEx(srcChar);</span>
502             }
503             if (Character.isBmpCodePoint(upperChar)) {
504                 StringUTF16.putChar(result, resultOffset++, upperChar);
505             } else {
506                 if (upperChar == Character.ERROR) {
507                     if (localeDependent) {
508                         upperCharArray =
509                             ConditionalSpecialCasing.toUpperCaseCharArray(str, i, locale);
510                     } else {
<a name="14" id="anc14"></a><span class="line-modified">511                         upperCharArray = Character.toUpperCaseCharArray(srcChar);</span>
512                     }
513                 } else {
514                     upperCharArray = Character.toChars(upperChar);
515                 }
516                 /* Grow result if needed */
517                 int mapLen = upperCharArray.length;
518                 if (mapLen &gt; 1) {
519                     byte[] result2 = StringUTF16.newBytesFor((result.length &gt;&gt; 1) + mapLen - 1);
520                     System.arraycopy(result, 0, result2, 0, resultOffset &lt;&lt; 1);
521                     result = result2;
522                 }
523                 for (int x = 0; x &lt; mapLen; ++x) {
524                     StringUTF16.putChar(result, resultOffset++, upperCharArray[x]);
525                 }
526             }
527         }
528         return StringUTF16.newString(result, 0, resultOffset);
529     }
530 
531     public static String trim(byte[] value) {
532         int len = value.length;
533         int st = 0;
534         while ((st &lt; len) &amp;&amp; ((value[st] &amp; 0xff) &lt;= &#39; &#39;)) {
535             st++;
536         }
537         while ((st &lt; len) &amp;&amp; ((value[len - 1] &amp; 0xff) &lt;= &#39; &#39;)) {
538             len--;
539         }
540         return ((st &gt; 0) || (len &lt; value.length)) ?
541             newString(value, st, len - st) : null;
542     }
543 
544     public static int indexOfNonWhitespace(byte[] value) {
545         int length = value.length;
546         int left = 0;
547         while (left &lt; length) {
548             char ch = getChar(value, left);
<a name="15" id="anc15"></a><span class="line-modified">549             if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; !Character.isWhitespace(ch)) {</span>
550                 break;
551             }
552             left++;
553         }
554         return left;
555     }
556 
557     public static int lastIndexOfNonWhitespace(byte[] value) {
558         int length = value.length;
559         int right = length;
560         while (0 &lt; right) {
561             char ch = getChar(value, right - 1);
<a name="16" id="anc16"></a><span class="line-modified">562             if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; !Character.isWhitespace(ch)) {</span>
563                 break;
564             }
565             right--;
566         }
567         return right;
568     }
569 
570     public static String strip(byte[] value) {
571         int left = indexOfNonWhitespace(value);
572         if (left == value.length) {
573             return &quot;&quot;;
574         }
575         int right = lastIndexOfNonWhitespace(value);
576         boolean ifChanged = (left &gt; 0) || (right &lt; value.length);
577         return ifChanged ? newString(value, left, right - left) : null;
578     }
579 
580     public static String stripLeading(byte[] value) {
581         int left = indexOfNonWhitespace(value);
582         if (left == value.length) {
583             return &quot;&quot;;
584         }
585         return (left != 0) ? newString(value, left, value.length - left) : null;
586     }
587 
588     public static String stripTrailing(byte[] value) {
589         int right = lastIndexOfNonWhitespace(value);
590         if (right == 0) {
591             return &quot;&quot;;
592         }
593         return (right != value.length) ? newString(value, 0, right) : null;
594     }
595 
596     private final static class LinesSpliterator implements Spliterator&lt;String&gt; {
597         private byte[] value;
598         private int index;        // current index, modified on advance/split
599         private final int fence;  // one past last index
600 
601         private LinesSpliterator(byte[] value, int start, int length) {
602             this.value = value;
603             this.index = start;
604             this.fence = start + length;
605         }
606 
607         private int indexOfLineSeparator(int start) {
608             for (int current = start; current &lt; fence; current++) {
609                 char ch = getChar(value, current);
610                 if (ch == &#39;\n&#39; || ch == &#39;\r&#39;) {
611                     return current;
612                 }
613             }
614             return fence;
615         }
616 
617         private int skipLineSeparator(int start) {
618             if (start &lt; fence) {
619                 if (getChar(value, start) == &#39;\r&#39;) {
620                     int next = start + 1;
621                     if (next &lt; fence &amp;&amp; getChar(value, next) == &#39;\n&#39;) {
622                         return next + 1;
623                     }
624                 }
625                 return start + 1;
626             }
627             return fence;
628         }
629 
630         private String next() {
631             int start = index;
632             int end = indexOfLineSeparator(start);
633             index = skipLineSeparator(end);
634             return newString(value, start, end - start);
635         }
636 
637         @Override
638         public boolean tryAdvance(Consumer&lt;? super String&gt; action) {
639             if (action == null) {
640                 throw new NullPointerException(&quot;tryAdvance action missing&quot;);
641             }
642             if (index != fence) {
643                 action.accept(next());
644                 return true;
645             }
646             return false;
647         }
648 
649         @Override
650         public void forEachRemaining(Consumer&lt;? super String&gt; action) {
651             if (action == null) {
652                 throw new NullPointerException(&quot;forEachRemaining action missing&quot;);
653             }
654             while (index != fence) {
655                 action.accept(next());
656             }
657         }
658 
659         @Override
660         public Spliterator&lt;String&gt; trySplit() {
661             int half = (fence + index) &gt;&gt;&gt; 1;
662             int mid = skipLineSeparator(indexOfLineSeparator(half));
663             if (mid &lt; fence) {
664                 int start = index;
665                 index = mid;
666                 return new LinesSpliterator(value, start, mid - start);
667             }
668             return null;
669         }
670 
671         @Override
672         public long estimateSize() {
673             return fence - index + 1;
674         }
675 
676         @Override
677         public int characteristics() {
678             return Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL;
679         }
680 
681         static LinesSpliterator spliterator(byte[] value) {
682             return new LinesSpliterator(value, 0, value.length);
683         }
<a name="17" id="anc17"></a><span class="line-removed">684 </span>
<span class="line-removed">685         static LinesSpliterator spliterator(byte[] value, int leading, int trailing) {</span>
<span class="line-removed">686             int length = value.length;</span>
<span class="line-removed">687             int left = 0;</span>
<span class="line-removed">688             int index;</span>
<span class="line-removed">689             for (int l = 0; l &lt; leading; l++) {</span>
<span class="line-removed">690                 index = skipBlankForward(value, left, length);</span>
<span class="line-removed">691                 if (index == left) {</span>
<span class="line-removed">692                     break;</span>
<span class="line-removed">693                 }</span>
<span class="line-removed">694                 left = index;</span>
<span class="line-removed">695             }</span>
<span class="line-removed">696             int right = length;</span>
<span class="line-removed">697             for (int t = 0; t &lt; trailing; t++) {</span>
<span class="line-removed">698                 index = skipBlankBackward(value, left, right);</span>
<span class="line-removed">699                 if (index == right) {</span>
<span class="line-removed">700                     break;</span>
<span class="line-removed">701                 }</span>
<span class="line-removed">702                 right = index;</span>
<span class="line-removed">703             }</span>
<span class="line-removed">704             return new LinesSpliterator(value, left, right - left);</span>
<span class="line-removed">705         }</span>
<span class="line-removed">706 </span>
<span class="line-removed">707         private static int skipBlankForward(byte[] value, int start, int length) {</span>
<span class="line-removed">708             int index = start;</span>
<span class="line-removed">709             while (index &lt; length) {</span>
<span class="line-removed">710                 char ch = getChar(value, index++);</span>
<span class="line-removed">711                 if (ch == &#39;\n&#39;) {</span>
<span class="line-removed">712                     return index;</span>
<span class="line-removed">713                 }</span>
<span class="line-removed">714                 if (ch == &#39;\r&#39;) {</span>
<span class="line-removed">715                     if (index &lt; length &amp;&amp; getChar(value, index) == &#39;\n&#39;) {</span>
<span class="line-removed">716                         return index + 1;</span>
<span class="line-removed">717                     }</span>
<span class="line-removed">718                     return index;</span>
<span class="line-removed">719                 }</span>
<span class="line-removed">720                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; !Character.isWhitespace(ch)) {</span>
<span class="line-removed">721                     return start;</span>
<span class="line-removed">722                 }</span>
<span class="line-removed">723             }</span>
<span class="line-removed">724             return length;</span>
<span class="line-removed">725         }</span>
<span class="line-removed">726 </span>
<span class="line-removed">727         private static int skipBlankBackward(byte[] value, int start, int fence) {</span>
<span class="line-removed">728             int index = fence;</span>
<span class="line-removed">729             if (start &lt; index &amp;&amp; getChar(value, index - 1) == &#39;\n&#39;) {</span>
<span class="line-removed">730                 index--;</span>
<span class="line-removed">731             }</span>
<span class="line-removed">732             if (start &lt; index &amp;&amp; getChar(value, index - 1) == &#39;\r&#39;) {</span>
<span class="line-removed">733                 index--;</span>
<span class="line-removed">734             }</span>
<span class="line-removed">735             while (start &lt; index) {</span>
<span class="line-removed">736                 char ch = getChar(value, --index);</span>
<span class="line-removed">737                 if (ch == &#39;\r&#39; || ch == &#39;\n&#39;) {</span>
<span class="line-removed">738                     return index + 1;</span>
<span class="line-removed">739                 }</span>
<span class="line-removed">740                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; !Character.isWhitespace(ch)) {</span>
<span class="line-removed">741                     return fence;</span>
<span class="line-removed">742                 }</span>
<span class="line-removed">743             }</span>
<span class="line-removed">744             return start;</span>
<span class="line-removed">745         }</span>
746     }
747 
<a name="18" id="anc18"></a><span class="line-modified">748     static Stream&lt;String&gt; lines(byte[] value, int leading, int trailing) {</span>
<span class="line-modified">749         if (leading == 0 &amp;&amp; trailing == 0) {</span>
<span class="line-removed">750             return StreamSupport.stream(LinesSpliterator.spliterator(value), false);</span>
<span class="line-removed">751         } else {</span>
<span class="line-removed">752             return StreamSupport.stream(LinesSpliterator.spliterator(value, leading, trailing), false);</span>
<span class="line-removed">753         }</span>
754     }
755 
756     public static void putChar(byte[] val, int index, int c) {
757         //assert (canEncode(c));
758         val[index] = (byte)(c);
759     }
760 
761     public static char getChar(byte[] val, int index) {
762         return (char)(val[index] &amp; 0xff);
763     }
764 
765     public static byte[] toBytes(int[] val, int off, int len) {
766         byte[] ret = new byte[len];
767         for (int i = 0; i &lt; len; i++) {
768             int cp = val[off++];
769             if (!canEncode(cp)) {
770                 return null;
771             }
772             ret[i] = (byte)cp;
773         }
774         return ret;
775     }
776 
777     public static byte[] toBytes(char c) {
778         return new byte[] { (byte)c };
779     }
780 
781     public static String newString(byte[] val, int index, int len) {
782         return new String(Arrays.copyOfRange(val, index, index + len),
783                           LATIN1);
784     }
785 
786     public static void fillNull(byte[] val, int index, int end) {
787         Arrays.fill(val, index, end, (byte)0);
788     }
789 
790     // inflatedCopy byte[] -&gt; char[]
791     @HotSpotIntrinsicCandidate
792     public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
793         for (int i = 0; i &lt; len; i++) {
794             dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
795         }
796     }
797 
798     // inflatedCopy byte[] -&gt; byte[]
799     @HotSpotIntrinsicCandidate
800     public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {
801         StringUTF16.inflate(src, srcOff, dst, dstOff, len);
802     }
803 
804     static class CharsSpliterator implements Spliterator.OfInt {
805         private final byte[] array;
806         private int index;        // current index, modified on advance/split
807         private final int fence;  // one past last index
808         private final int cs;
809 
810         CharsSpliterator(byte[] array, int acs) {
811             this(array, 0, array.length, acs);
812         }
813 
814         CharsSpliterator(byte[] array, int origin, int fence, int acs) {
815             this.array = array;
816             this.index = origin;
817             this.fence = fence;
818             this.cs = acs | Spliterator.ORDERED | Spliterator.SIZED
819                       | Spliterator.SUBSIZED;
820         }
821 
822         @Override
823         public OfInt trySplit() {
824             int lo = index, mid = (lo + fence) &gt;&gt;&gt; 1;
825             return (lo &gt;= mid)
826                    ? null
827                    : new CharsSpliterator(array, lo, index = mid, cs);
828         }
829 
830         @Override
831         public void forEachRemaining(IntConsumer action) {
832             byte[] a; int i, hi; // hoist accesses and checks from loop
833             if (action == null)
834                 throw new NullPointerException();
835             if ((a = array).length &gt;= (hi = fence) &amp;&amp;
836                 (i = index) &gt;= 0 &amp;&amp; i &lt; (index = hi)) {
837                 do { action.accept(a[i] &amp; 0xff); } while (++i &lt; hi);
838             }
839         }
840 
841         @Override
842         public boolean tryAdvance(IntConsumer action) {
843             if (action == null)
844                 throw new NullPointerException();
845             if (index &gt;= 0 &amp;&amp; index &lt; fence) {
846                 action.accept(array[index++] &amp; 0xff);
847                 return true;
848             }
849             return false;
850         }
851 
852         @Override
853         public long estimateSize() { return (long)(fence - index); }
854 
855         @Override
856         public int characteristics() {
857             return cs;
858         }
859     }
860 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
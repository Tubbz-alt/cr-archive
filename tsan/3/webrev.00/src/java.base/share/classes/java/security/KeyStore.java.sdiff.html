<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/KeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyRep.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="KeyStoreException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/KeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 279             this.protectionAlgorithm = null;
 280             this.protectionParameters = null;
 281         }
 282 
 283         /**
 284          * Creates a password parameter and specifies the protection algorithm
 285          * and associated parameters to use when encrypting a keystore entry.
 286          * &lt;p&gt;
 287          * The specified {@code password} is cloned before it is stored in the
 288          * new {@code PasswordProtection} object.
 289          *
 290          * @param password the password, which may be {@code null}
 291          * @param protectionAlgorithm the encryption algorithm name, for
 292          *     example, {@code PBEWithHmacSHA256AndAES_256}.
 293          *     See the Cipher section in the &lt;a href=
 294          * &quot;{@docRoot}/../specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;
 295          * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 296          *     for information about standard encryption algorithm names.
 297          * @param protectionParameters the encryption algorithm parameter
 298          *     specification, which may be {@code null}
<span class="line-modified"> 299          * @exception NullPointerException if {@code protectionAlgorithm} is</span>
 300          *     {@code null}
 301          *
 302          * @since 1.8
 303          */
 304         public PasswordProtection(char[] password, String protectionAlgorithm,
 305             AlgorithmParameterSpec protectionParameters) {
 306             if (protectionAlgorithm == null) {
 307                 throw new NullPointerException(&quot;invalid null input&quot;);
 308             }
 309             this.password = (password == null) ? null : password.clone();
 310             this.protectionAlgorithm = protectionAlgorithm;
 311             this.protectionParameters = protectionParameters;
 312         }
 313 
 314         /**
 315          * Gets the name of the protection algorithm.
 316          * If none was set then the keystore provider will use its default
 317          * protection algorithm.
 318          *
 319          * @return the algorithm name, or {@code null} if none was set
</pre>
<hr />
<pre>
 329          *
 330          * @return the algorithm parameter specification, or {@code  null},
 331          *     if none was set
 332          *
 333          * @since 1.8
 334          */
 335         public AlgorithmParameterSpec getProtectionParameters() {
 336             return protectionParameters;
 337         }
 338 
 339         /**
 340          * Gets the password.
 341          *
 342          * &lt;p&gt;Note that this method returns a reference to the password.
 343          * If a clone of the array is created it is the caller&#39;s
 344          * responsibility to zero out the password information
 345          * after it is no longer needed.
 346          *
 347          * @see #destroy()
 348          * @return the password, which may be {@code null}
<span class="line-modified"> 349          * @exception IllegalStateException if the password has</span>
 350          *              been cleared (destroyed)
 351          */
 352         public synchronized char[] getPassword() {
 353             if (destroyed) {
 354                 throw new IllegalStateException(&quot;password has been cleared&quot;);
 355             }
 356             return password;
 357         }
 358 
 359         /**
 360          * Clears the password.
 361          *
<span class="line-modified"> 362          * @exception DestroyFailedException if this method was unable</span>
 363          *      to clear the password
 364          */
 365         public synchronized void destroy() throws DestroyFailedException {
 366             destroyed = true;
 367             if (password != null) {
 368                 Arrays.fill(password, &#39; &#39;);
 369             }
 370         }
 371 
 372         /**
 373          * Determines if password has been cleared.
 374          *
 375          * @return true if the password has been cleared, false otherwise
 376          */
 377         public synchronized boolean isDestroyed() {
 378             return destroyed;
 379         }
 380     }
 381 
 382     /**
 383      * A ProtectionParameter encapsulating a CallbackHandler.
 384      *
 385      * @since 1.5
 386      */
 387     public static class CallbackHandlerProtection
 388             implements ProtectionParameter {
 389 
 390         private final CallbackHandler handler;
 391 
 392         /**
 393          * Constructs a new CallbackHandlerProtection from a
 394          * CallbackHandler.
 395          *
 396          * @param handler the CallbackHandler
<span class="line-modified"> 397          * @exception NullPointerException if handler is null</span>
 398          */
 399         public CallbackHandlerProtection(CallbackHandler handler) {
 400             if (handler == null) {
 401                 throw new NullPointerException(&quot;handler must not be null&quot;);
 402             }
 403             this.handler = handler;
 404         }
 405 
 406         /**
 407          * Returns the CallbackHandler.
 408          *
 409          * @return the CallbackHandler.
 410          */
 411         public CallbackHandler getCallbackHandler() {
 412             return handler;
 413         }
 414 
 415     }
 416 
 417     /**
</pre>
<hr />
<pre>
 468     public static final class PrivateKeyEntry implements Entry {
 469 
 470         private final PrivateKey privKey;
 471         private final Certificate[] chain;
 472         private final Set&lt;Attribute&gt; attributes;
 473 
 474         /**
 475          * Constructs a {@code PrivateKeyEntry} with a
 476          * {@code PrivateKey} and corresponding certificate chain.
 477          *
 478          * &lt;p&gt; The specified {@code chain} is cloned before it is stored
 479          * in the new {@code PrivateKeyEntry} object.
 480          *
 481          * @param privateKey the {@code PrivateKey}
 482          * @param chain an array of {@code Certificate}s
 483          *      representing the certificate chain.
 484          *      The chain must be ordered and contain a
 485          *      {@code Certificate} at index 0
 486          *      corresponding to the private key.
 487          *
<span class="line-modified"> 488          * @exception NullPointerException if</span>
 489          *      {@code privateKey} or {@code chain}
 490          *      is {@code null}
<span class="line-modified"> 491          * @exception IllegalArgumentException if the specified chain has a</span>
 492          *      length of 0, if the specified chain does not contain
 493          *      {@code Certificate}s of the same type,
 494          *      or if the {@code PrivateKey} algorithm
 495          *      does not match the algorithm of the {@code PublicKey}
 496          *      in the end entity {@code Certificate} (at index 0)
 497          */
 498         public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain) {
 499             this(privateKey, chain, Collections.&lt;Attribute&gt;emptySet());
 500         }
 501 
 502         /**
 503          * Constructs a {@code PrivateKeyEntry} with a {@code PrivateKey} and
 504          * corresponding certificate chain and associated entry attributes.
 505          *
 506          * &lt;p&gt; The specified {@code chain} and {@code attributes} are cloned
 507          * before they are stored in the new {@code PrivateKeyEntry} object.
 508          *
 509          * @param privateKey the {@code PrivateKey}
 510          * @param chain an array of {@code Certificate}s
 511          *      representing the certificate chain.
 512          *      The chain must be ordered and contain a
 513          *      {@code Certificate} at index 0
 514          *      corresponding to the private key.
 515          * @param attributes the attributes
 516          *
<span class="line-modified"> 517          * @exception NullPointerException if {@code privateKey}, {@code chain}</span>
 518          *      or {@code attributes} is {@code null}
<span class="line-modified"> 519          * @exception IllegalArgumentException if the specified chain has a</span>
 520          *      length of 0, if the specified chain does not contain
 521          *      {@code Certificate}s of the same type,
 522          *      or if the {@code PrivateKey} algorithm
 523          *      does not match the algorithm of the {@code PublicKey}
 524          *      in the end entity {@code Certificate} (at index 0)
 525          *
 526          * @since 1.8
 527          */
 528         public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain,
 529            Set&lt;Attribute&gt; attributes) {
 530 
 531             if (privateKey == null || chain == null || attributes == null) {
 532                 throw new NullPointerException(&quot;invalid null input&quot;);
 533             }
 534             if (chain.length == 0) {
 535                 throw new IllegalArgumentException
 536                                 (&quot;invalid zero-length input chain&quot;);
 537             }
 538 
 539             Certificate[] clonedChain = chain.clone();
</pre>
<hr />
<pre>
 634         }
 635 
 636     }
 637 
 638     /**
 639      * A {@code KeyStore} entry that holds a {@code SecretKey}.
 640      *
 641      * @since 1.5
 642      */
 643     public static final class SecretKeyEntry implements Entry {
 644 
 645         private final SecretKey sKey;
 646         private final Set&lt;Attribute&gt; attributes;
 647 
 648         /**
 649          * Constructs a {@code SecretKeyEntry} with a
 650          * {@code SecretKey}.
 651          *
 652          * @param secretKey the {@code SecretKey}
 653          *
<span class="line-modified"> 654          * @exception NullPointerException if {@code secretKey}</span>
 655          *      is {@code null}
 656          */
 657         public SecretKeyEntry(SecretKey secretKey) {
 658             if (secretKey == null) {
 659                 throw new NullPointerException(&quot;invalid null input&quot;);
 660             }
 661             this.sKey = secretKey;
 662             this.attributes = Collections.&lt;Attribute&gt;emptySet();
 663         }
 664 
 665         /**
 666          * Constructs a {@code SecretKeyEntry} with a {@code SecretKey} and
 667          * associated entry attributes.
 668          *
 669          * &lt;p&gt; The specified {@code attributes} is cloned before it is stored
 670          * in the new {@code SecretKeyEntry} object.
 671          *
 672          * @param secretKey the {@code SecretKey}
 673          * @param attributes the attributes
 674          *
<span class="line-modified"> 675          * @exception NullPointerException if {@code secretKey} or</span>
 676          *     {@code attributes} is {@code null}
 677          *
 678          * @since 1.8
 679          */
 680         public SecretKeyEntry(SecretKey secretKey, Set&lt;Attribute&gt; attributes) {
 681 
 682             if (secretKey == null || attributes == null) {
 683                 throw new NullPointerException(&quot;invalid null input&quot;);
 684             }
 685             this.sKey = secretKey;
 686             this.attributes =
 687                 Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));
 688         }
 689 
 690         /**
 691          * Gets the {@code SecretKey} from this entry.
 692          *
 693          * @return the {@code SecretKey} from this entry
 694          */
 695         public SecretKey getSecretKey() {
</pre>
<hr />
<pre>
 717         }
 718     }
 719 
 720     /**
 721      * A {@code KeyStore} entry that holds a trusted
 722      * {@code Certificate}.
 723      *
 724      * @since 1.5
 725      */
 726     public static final class TrustedCertificateEntry implements Entry {
 727 
 728         private final Certificate cert;
 729         private final Set&lt;Attribute&gt; attributes;
 730 
 731         /**
 732          * Constructs a {@code TrustedCertificateEntry} with a
 733          * trusted {@code Certificate}.
 734          *
 735          * @param trustedCert the trusted {@code Certificate}
 736          *
<span class="line-modified"> 737          * @exception NullPointerException if</span>
 738          *      {@code trustedCert} is {@code null}
 739          */
 740         public TrustedCertificateEntry(Certificate trustedCert) {
 741             if (trustedCert == null) {
 742                 throw new NullPointerException(&quot;invalid null input&quot;);
 743             }
 744             this.cert = trustedCert;
 745             this.attributes = Collections.&lt;Attribute&gt;emptySet();
 746         }
 747 
 748         /**
 749          * Constructs a {@code TrustedCertificateEntry} with a
 750          * trusted {@code Certificate} and associated entry attributes.
 751          *
 752          * &lt;p&gt; The specified {@code attributes} is cloned before it is stored
 753          * in the new {@code TrustedCertificateEntry} object.
 754          *
 755          * @param trustedCert the trusted {@code Certificate}
 756          * @param attributes the attributes
 757          *
<span class="line-modified"> 758          * @exception NullPointerException if {@code trustedCert} or</span>
 759          *     {@code attributes} is {@code null}
 760          *
 761          * @since 1.8
 762          */
 763         public TrustedCertificateEntry(Certificate trustedCert,
 764            Set&lt;Attribute&gt; attributes) {
 765             if (trustedCert == null || attributes == null) {
 766                 throw new NullPointerException(&quot;invalid null input&quot;);
 767             }
 768             this.cert = trustedCert;
 769             this.attributes =
 770                 Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));
 771         }
 772 
 773         /**
 774          * Gets the trusted {@code Certficate} from this entry.
 775          *
 776          * @return the trusted {@code Certificate} from this entry
 777          */
 778         public Certificate getTrustedCertificate() {
</pre>
<hr />
<pre>
1016      * @return the type of this keystore.
1017      */
1018     public final String getType()
1019     {
1020         return this.type;
1021     }
1022 
1023     /**
1024      * Returns the key associated with the given alias, using the given
1025      * password to recover it.  The key must have been associated with
1026      * the alias by a call to {@code setKeyEntry},
1027      * or by a call to {@code setEntry} with a
1028      * {@code PrivateKeyEntry} or {@code SecretKeyEntry}.
1029      *
1030      * @param alias the alias name
1031      * @param password the password for recovering the key
1032      *
1033      * @return the requested key, or null if the given alias does not exist
1034      * or does not identify a key-related entry.
1035      *
<span class="line-modified">1036      * @exception KeyStoreException if the keystore has not been initialized</span>
1037      * (loaded).
<span class="line-modified">1038      * @exception NoSuchAlgorithmException if the algorithm for recovering the</span>
1039      * key cannot be found
<span class="line-modified">1040      * @exception UnrecoverableKeyException if the key cannot be recovered</span>
1041      * (e.g., the given password is wrong).
1042      */
1043     public final Key getKey(String alias, char[] password)
1044         throws KeyStoreException, NoSuchAlgorithmException,
1045             UnrecoverableKeyException
1046     {
1047         if (!initialized) {
1048             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1049         }
1050         return keyStoreSpi.engineGetKey(alias, password);
1051     }
1052 
1053     /**
1054      * Returns the certificate chain associated with the given alias.
1055      * The certificate chain must have been associated with the alias
1056      * by a call to {@code setKeyEntry},
1057      * or by a call to {@code setEntry} with a
1058      * {@code PrivateKeyEntry}.
1059      *
1060      * @param alias the alias name
1061      *
1062      * @return the certificate chain (ordered with the user&#39;s certificate first
1063      * followed by zero or more certificate authorities), or null if the given alias
1064      * does not exist or does not contain a certificate chain
1065      *
<span class="line-modified">1066      * @exception KeyStoreException if the keystore has not been initialized</span>
1067      * (loaded).
1068      */
1069     public final Certificate[] getCertificateChain(String alias)
1070         throws KeyStoreException
1071     {
1072         if (!initialized) {
1073             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1074         }
1075         return keyStoreSpi.engineGetCertificateChain(alias);
1076     }
1077 
1078     /**
1079      * Returns the certificate associated with the given alias.
1080      *
1081      * &lt;p&gt; If the given alias name identifies an entry
1082      * created by a call to {@code setCertificateEntry},
1083      * or created by a call to {@code setEntry} with a
1084      * {@code TrustedCertificateEntry},
1085      * then the trusted certificate contained in that entry is returned.
1086      *
1087      * &lt;p&gt; If the given alias name identifies an entry
1088      * created by a call to {@code setKeyEntry},
1089      * or created by a call to {@code setEntry} with a
1090      * {@code PrivateKeyEntry},
1091      * then the first element of the certificate chain in that entry
1092      * is returned.
1093      *
1094      * @param alias the alias name
1095      *
1096      * @return the certificate, or null if the given alias does not exist or
1097      * does not contain a certificate.
1098      *
<span class="line-modified">1099      * @exception KeyStoreException if the keystore has not been initialized</span>
1100      * (loaded).
1101      */
1102     public final Certificate getCertificate(String alias)
1103         throws KeyStoreException
1104     {
1105         if (!initialized) {
1106             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1107         }
1108         return keyStoreSpi.engineGetCertificate(alias);
1109     }
1110 
1111     /**
1112      * Returns the creation date of the entry identified by the given alias.
1113      *
1114      * @param alias the alias name
1115      *
1116      * @return the creation date of this entry, or null if the given alias does
1117      * not exist
1118      *
<span class="line-modified">1119      * @exception KeyStoreException if the keystore has not been initialized</span>
1120      * (loaded).
1121      */
1122     public final Date getCreationDate(String alias)
1123         throws KeyStoreException
1124     {
1125         if (!initialized) {
1126             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1127         }
1128         return keyStoreSpi.engineGetCreationDate(alias);
1129     }
1130 
1131     /**
1132      * Assigns the given key to the given alias, protecting it with the given
1133      * password.
1134      *
1135      * &lt;p&gt;If the given key is of type {@code java.security.PrivateKey},
1136      * it must be accompanied by a certificate chain certifying the
1137      * corresponding public key.
1138      *
1139      * &lt;p&gt;If the given alias already exists, the keystore information
1140      * associated with it is overridden by the given key (and possibly
1141      * certificate chain).
1142      *
1143      * @param alias the alias name
1144      * @param key the key to be associated with the alias
1145      * @param password the password to protect the key
1146      * @param chain the certificate chain for the corresponding public
1147      * key (only required if the given key is of type
1148      * {@code java.security.PrivateKey}).
1149      *
<span class="line-modified">1150      * @exception KeyStoreException if the keystore has not been initialized</span>
1151      * (loaded), the given key cannot be protected, or this operation fails
1152      * for some other reason
1153      */
1154     public final void setKeyEntry(String alias, Key key, char[] password,
1155                                   Certificate[] chain)
1156         throws KeyStoreException
1157     {
1158         if (!initialized) {
1159             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1160         }
1161         if ((key instanceof PrivateKey) &amp;&amp;
1162             (chain == null || chain.length == 0)) {
1163             throw new IllegalArgumentException(&quot;Private key must be &quot;
1164                                                + &quot;accompanied by certificate &quot;
1165                                                + &quot;chain&quot;);
1166         }
1167         keyStoreSpi.engineSetKeyEntry(alias, key, password, chain);
1168     }
1169 
1170     /**
1171      * Assigns the given key (that has already been protected) to the given
1172      * alias.
1173      *
1174      * &lt;p&gt;If the protected key is of type
1175      * {@code java.security.PrivateKey}, it must be accompanied by a
1176      * certificate chain certifying the corresponding public key. If the
1177      * underlying keystore implementation is of type {@code jks},
1178      * {@code key} must be encoded as an
1179      * {@code EncryptedPrivateKeyInfo} as defined in the PKCS #8 standard.
1180      *
1181      * &lt;p&gt;If the given alias already exists, the keystore information
1182      * associated with it is overridden by the given key (and possibly
1183      * certificate chain).
1184      *
1185      * @param alias the alias name
1186      * @param key the key (in protected format) to be associated with the alias
1187      * @param chain the certificate chain for the corresponding public
1188      *          key (only useful if the protected key is of type
1189      *          {@code java.security.PrivateKey}).
1190      *
<span class="line-modified">1191      * @exception KeyStoreException if the keystore has not been initialized</span>
1192      * (loaded), or if this operation fails for some other reason.
1193      */
1194     public final void setKeyEntry(String alias, byte[] key,
1195                                   Certificate[] chain)
1196         throws KeyStoreException
1197     {
1198         if (!initialized) {
1199             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1200         }
1201         keyStoreSpi.engineSetKeyEntry(alias, key, chain);
1202     }
1203 
1204     /**
1205      * Assigns the given trusted certificate to the given alias.
1206      *
1207      * &lt;p&gt; If the given alias identifies an existing entry
1208      * created by a call to {@code setCertificateEntry},
1209      * or created by a call to {@code setEntry} with a
1210      * {@code TrustedCertificateEntry},
1211      * the trusted certificate in the existing entry
1212      * is overridden by the given certificate.
1213      *
1214      * @param alias the alias name
1215      * @param cert the certificate
1216      *
<span class="line-modified">1217      * @exception KeyStoreException if the keystore has not been initialized,</span>
1218      * or the given alias already exists and does not identify an
1219      * entry containing a trusted certificate,
1220      * or this operation fails for some other reason.
1221      */
1222     public final void setCertificateEntry(String alias, Certificate cert)
1223         throws KeyStoreException
1224     {
1225         if (!initialized) {
1226             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1227         }
1228         keyStoreSpi.engineSetCertificateEntry(alias, cert);
1229     }
1230 
1231     /**
1232      * Deletes the entry identified by the given alias from this keystore.
1233      *
1234      * @param alias the alias name
1235      *
<span class="line-modified">1236      * @exception KeyStoreException if the keystore has not been initialized,</span>
1237      * or if the entry cannot be removed.
1238      */
1239     public final void deleteEntry(String alias)
1240         throws KeyStoreException
1241     {
1242         if (!initialized) {
1243             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1244         }
1245         keyStoreSpi.engineDeleteEntry(alias);
1246     }
1247 
1248     /**
1249      * Lists all the alias names of this keystore.
1250      *
1251      * @return enumeration of the alias names
1252      *
<span class="line-modified">1253      * @exception KeyStoreException if the keystore has not been initialized</span>
1254      * (loaded).
1255      */
1256     public final Enumeration&lt;String&gt; aliases()
1257         throws KeyStoreException
1258     {
1259         if (!initialized) {
1260             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1261         }
1262         return keyStoreSpi.engineAliases();
1263     }
1264 
1265     /**
1266      * Checks if the given alias exists in this keystore.
1267      *
1268      * @param alias the alias name
1269      *
1270      * @return true if the alias exists, false otherwise
1271      *
<span class="line-modified">1272      * @exception KeyStoreException if the keystore has not been initialized</span>
1273      * (loaded).
1274      */
1275     public final boolean containsAlias(String alias)
1276         throws KeyStoreException
1277     {
1278         if (!initialized) {
1279             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1280         }
1281         return keyStoreSpi.engineContainsAlias(alias);
1282     }
1283 
1284     /**
1285      * Retrieves the number of entries in this keystore.
1286      *
1287      * @return the number of entries in this keystore
1288      *
<span class="line-modified">1289      * @exception KeyStoreException if the keystore has not been initialized</span>
1290      * (loaded).
1291      */
1292     public final int size()
1293         throws KeyStoreException
1294     {
1295         if (!initialized) {
1296             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1297         }
1298         return keyStoreSpi.engineSize();
1299     }
1300 
1301     /**
1302      * Returns true if the entry identified by the given alias
1303      * was created by a call to {@code setKeyEntry},
1304      * or created by a call to {@code setEntry} with a
1305      * {@code PrivateKeyEntry} or a {@code SecretKeyEntry}.
1306      *
1307      * @param alias the alias for the keystore entry to be checked
1308      *
1309      * @return true if the entry identified by the given alias is a
1310      * key-related entry, false otherwise.
1311      *
<span class="line-modified">1312      * @exception KeyStoreException if the keystore has not been initialized</span>
1313      * (loaded).
1314      */
1315     public final boolean isKeyEntry(String alias)
1316         throws KeyStoreException
1317     {
1318         if (!initialized) {
1319             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1320         }
1321         return keyStoreSpi.engineIsKeyEntry(alias);
1322     }
1323 
1324     /**
1325      * Returns true if the entry identified by the given alias
1326      * was created by a call to {@code setCertificateEntry},
1327      * or created by a call to {@code setEntry} with a
1328      * {@code TrustedCertificateEntry}.
1329      *
1330      * @param alias the alias for the keystore entry to be checked
1331      *
1332      * @return true if the entry identified by the given alias contains a
1333      * trusted certificate, false otherwise.
1334      *
<span class="line-modified">1335      * @exception KeyStoreException if the keystore has not been initialized</span>
1336      * (loaded).
1337      */
1338     public final boolean isCertificateEntry(String alias)
1339         throws KeyStoreException
1340     {
1341         if (!initialized) {
1342             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1343         }
1344         return keyStoreSpi.engineIsCertificateEntry(alias);
1345     }
1346 
1347     /**
1348      * Returns the (alias) name of the first keystore entry whose certificate
1349      * matches the given certificate.
1350      *
1351      * &lt;p&gt; This method attempts to match the given certificate with each
1352      * keystore entry. If the entry being considered was
1353      * created by a call to {@code setCertificateEntry},
1354      * or created by a call to {@code setEntry} with a
1355      * {@code TrustedCertificateEntry},
1356      * then the given certificate is compared to that entry&#39;s certificate.
1357      *
1358      * &lt;p&gt; If the entry being considered was
1359      * created by a call to {@code setKeyEntry},
1360      * or created by a call to {@code setEntry} with a
1361      * {@code PrivateKeyEntry},
1362      * then the given certificate is compared to the first
1363      * element of that entry&#39;s certificate chain.
1364      *
1365      * @param cert the certificate to match with.
1366      *
1367      * @return the alias name of the first entry with a matching certificate,
1368      * or null if no such entry exists in this keystore.
1369      *
<span class="line-modified">1370      * @exception KeyStoreException if the keystore has not been initialized</span>
1371      * (loaded).
1372      */
1373     public final String getCertificateAlias(Certificate cert)
1374         throws KeyStoreException
1375     {
1376         if (!initialized) {
1377             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1378         }
1379         return keyStoreSpi.engineGetCertificateAlias(cert);
1380     }
1381 
1382     /**
1383      * Stores this keystore to the given output stream, and protects its
1384      * integrity with the given password.
1385      *
1386      * @param stream the output stream to which this keystore is written.
1387      * @param password the password to generate the keystore integrity check
1388      *
<span class="line-modified">1389      * @exception KeyStoreException if the keystore has not been initialized</span>
1390      * (loaded).
<span class="line-modified">1391      * @exception IOException if there was an I/O problem with data</span>
<span class="line-modified">1392      * @exception NoSuchAlgorithmException if the appropriate data integrity</span>
1393      * algorithm could not be found
<span class="line-modified">1394      * @exception CertificateException if any of the certificates included in</span>
1395      * the keystore data could not be stored
1396      */
1397     public final void store(OutputStream stream, char[] password)
1398         throws KeyStoreException, IOException, NoSuchAlgorithmException,
1399             CertificateException
1400     {
1401         if (!initialized) {
1402             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1403         }
1404         keyStoreSpi.engineStore(stream, password);
1405     }
1406 
1407     /**
1408      * Stores this keystore using the given {@code LoadStoreParameter}.
1409      *
1410      * @param param the {@code LoadStoreParameter}
1411      *          that specifies how to store the keystore,
1412      *          which may be {@code null}
1413      *
<span class="line-modified">1414      * @exception IllegalArgumentException if the given</span>
1415      *          {@code LoadStoreParameter}
1416      *          input is not recognized
<span class="line-modified">1417      * @exception KeyStoreException if the keystore has not been initialized</span>
1418      *          (loaded)
<span class="line-modified">1419      * @exception IOException if there was an I/O problem with data</span>
<span class="line-modified">1420      * @exception NoSuchAlgorithmException if the appropriate data integrity</span>
1421      *          algorithm could not be found
<span class="line-modified">1422      * @exception CertificateException if any of the certificates included in</span>
1423      *          the keystore data could not be stored
1424      *
1425      * @since 1.5
1426      */
1427     public final void store(LoadStoreParameter param)
1428                 throws KeyStoreException, IOException,
1429                 NoSuchAlgorithmException, CertificateException {
1430         if (!initialized) {
1431             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1432         }
1433         keyStoreSpi.engineStore(param);
1434     }
1435 
1436     /**
1437      * Loads this KeyStore from the given input stream.
1438      *
1439      * &lt;p&gt;A password may be given to unlock the keystore
1440      * (e.g. the keystore resides on a hardware token device),
1441      * or to check the integrity of the keystore data.
1442      * If a password is not given for integrity checking,
1443      * then integrity checking is not performed.
1444      *
1445      * &lt;p&gt;In order to create an empty keystore, or if the keystore cannot
1446      * be initialized from a stream, pass {@code null}
1447      * as the {@code stream} argument.
1448      *
1449      * &lt;p&gt; Note that if this keystore has already been loaded, it is
1450      * reinitialized and loaded again from the given input stream.
1451      *
1452      * @param stream the input stream from which the keystore is loaded,
1453      * or {@code null}
1454      * @param password the password used to check the integrity of
1455      * the keystore, the password used to unlock the keystore,
1456      * or {@code null}
1457      *
<span class="line-modified">1458      * @exception IOException if there is an I/O or format problem with the</span>
1459      * keystore data, if a password is required but not given,
1460      * or if the given password was incorrect. If the error is due to a
1461      * wrong password, the {@link Throwable#getCause cause} of the
1462      * {@code IOException} should be an
1463      * {@code UnrecoverableKeyException}
<span class="line-modified">1464      * @exception NoSuchAlgorithmException if the algorithm used to check</span>
1465      * the integrity of the keystore cannot be found
<span class="line-modified">1466      * @exception CertificateException if any of the certificates in the</span>
1467      * keystore could not be loaded
1468      */
1469     public final void load(InputStream stream, char[] password)
1470         throws IOException, NoSuchAlgorithmException, CertificateException
1471     {
1472         keyStoreSpi.engineLoad(stream, password);
1473         initialized = true;
1474     }
1475 
1476     /**
1477      * Loads this keystore using the given {@code LoadStoreParameter}.
1478      *
1479      * &lt;p&gt; Note that if this KeyStore has already been loaded, it is
1480      * reinitialized and loaded again from the given parameter.
1481      *
1482      * @param param the {@code LoadStoreParameter}
1483      *          that specifies how to load the keystore,
1484      *          which may be {@code null}
1485      *
<span class="line-modified">1486      * @exception IllegalArgumentException if the given</span>
1487      *          {@code LoadStoreParameter}
1488      *          input is not recognized
<span class="line-modified">1489      * @exception IOException if there is an I/O or format problem with the</span>
1490      *          keystore data. If the error is due to an incorrect
1491      *         {@code ProtectionParameter} (e.g. wrong password)
1492      *         the {@link Throwable#getCause cause} of the
1493      *         {@code IOException} should be an
1494      *         {@code UnrecoverableKeyException}
<span class="line-modified">1495      * @exception NoSuchAlgorithmException if the algorithm used to check</span>
1496      *          the integrity of the keystore cannot be found
<span class="line-modified">1497      * @exception CertificateException if any of the certificates in the</span>
1498      *          keystore could not be loaded
1499      *
1500      * @since 1.5
1501      */
1502     public final void load(LoadStoreParameter param)
1503                 throws IOException, NoSuchAlgorithmException,
1504                 CertificateException {
1505 
1506         keyStoreSpi.engineLoad(param);
1507         initialized = true;
1508     }
1509 
1510     /**
1511      * Gets a keystore {@code Entry} for the specified alias
1512      * with the specified protection parameter.
1513      *
1514      * @param alias get the keystore {@code Entry} for this alias
1515      * @param protParam the {@code ProtectionParameter}
1516      *          used to protect the {@code Entry},
1517      *          which may be {@code null}
1518      *
1519      * @return the keystore {@code Entry} for the specified alias,
1520      *          or {@code null} if there is no such entry
1521      *
<span class="line-modified">1522      * @exception NullPointerException if</span>
1523      *          {@code alias} is {@code null}
<span class="line-modified">1524      * @exception NoSuchAlgorithmException if the algorithm for recovering the</span>
1525      *          entry cannot be found
<span class="line-modified">1526      * @exception UnrecoverableEntryException if the specified</span>
1527      *          {@code protParam} were insufficient or invalid
<span class="line-modified">1528      * @exception UnrecoverableKeyException if the entry is a</span>
1529      *          {@code PrivateKeyEntry} or {@code SecretKeyEntry}
1530      *          and the specified {@code protParam} does not contain
1531      *          the information needed to recover the key (e.g. wrong password)
<span class="line-modified">1532      * @exception KeyStoreException if the keystore has not been initialized</span>
1533      *          (loaded).
1534      * @see #setEntry(String, KeyStore.Entry, KeyStore.ProtectionParameter)
1535      *
1536      * @since 1.5
1537      */
1538     public final Entry getEntry(String alias, ProtectionParameter protParam)
1539                 throws NoSuchAlgorithmException, UnrecoverableEntryException,
1540                 KeyStoreException {
1541 
1542         if (alias == null) {
1543             throw new NullPointerException(&quot;invalid null input&quot;);
1544         }
1545         if (!initialized) {
1546             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1547         }
1548         return keyStoreSpi.engineGetEntry(alias, protParam);
1549     }
1550 
1551     /**
1552      * Saves a keystore {@code Entry} under the specified alias.
1553      * The protection parameter is used to protect the
1554      * {@code Entry}.
1555      *
1556      * &lt;p&gt; If an entry already exists for the specified alias,
1557      * it is overridden.
1558      *
1559      * @param alias save the keystore {@code Entry} under this alias
1560      * @param entry the {@code Entry} to save
1561      * @param protParam the {@code ProtectionParameter}
1562      *          used to protect the {@code Entry},
1563      *          which may be {@code null}
1564      *
<span class="line-modified">1565      * @exception NullPointerException if</span>
1566      *          {@code alias} or {@code entry}
1567      *          is {@code null}
<span class="line-modified">1568      * @exception KeyStoreException if the keystore has not been initialized</span>
1569      *          (loaded), or if this operation fails for some other reason
1570      *
1571      * @see #getEntry(String, KeyStore.ProtectionParameter)
1572      *
1573      * @since 1.5
1574      */
1575     public final void setEntry(String alias, Entry entry,
1576                         ProtectionParameter protParam)
1577                 throws KeyStoreException {
1578         if (alias == null || entry == null) {
1579             throw new NullPointerException(&quot;invalid null input&quot;);
1580         }
1581         if (!initialized) {
1582             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1583         }
1584         keyStoreSpi.engineSetEntry(alias, entry, protParam);
1585     }
1586 
1587     /**
1588      * Determines if the keystore {@code Entry} for the specified
1589      * {@code alias} is an instance or subclass of the specified
1590      * {@code entryClass}.
1591      *
1592      * @param alias the alias name
1593      * @param entryClass the entry class
1594      *
1595      * @return true if the keystore {@code Entry} for the specified
1596      *          {@code alias} is an instance or subclass of the
1597      *          specified {@code entryClass}, false otherwise
1598      *
<span class="line-modified">1599      * @exception NullPointerException if</span>
1600      *          {@code alias} or {@code entryClass}
1601      *          is {@code null}
<span class="line-modified">1602      * @exception KeyStoreException if the keystore has not been</span>
1603      *          initialized (loaded)
1604      *
1605      * @since 1.5
1606      */
1607     public final boolean
1608         entryInstanceOf(String alias,
1609                         Class&lt;? extends KeyStore.Entry&gt; entryClass)
1610         throws KeyStoreException
1611     {
1612 
1613         if (alias == null || entryClass == null) {
1614             throw new NullPointerException(&quot;invalid null input&quot;);
1615         }
1616         if (!initialized) {
1617             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1618         }
1619         return keyStoreSpi.engineEntryInstanceOf(alias, entryClass);
1620     }
1621 
1622     /**
</pre>
<hr />
<pre>
1824      * @see KeyStore
1825      * @see javax.net.ssl.KeyStoreBuilderParameters
1826      * @since 1.5
1827      */
1828     public abstract static class Builder {
1829 
1830         // maximum times to try the callbackhandler if the password is wrong
1831         static final int MAX_CALLBACK_TRIES = 3;
1832 
1833         /**
1834          * Construct a new Builder.
1835          */
1836         protected Builder() {
1837             // empty
1838         }
1839 
1840         /**
1841          * Returns the KeyStore described by this object.
1842          *
1843          * @return the {@code KeyStore} described by this object
<span class="line-modified">1844          * @exception KeyStoreException if an error occurred during the</span>
1845          *   operation, for example if the KeyStore could not be
1846          *   instantiated or loaded
1847          */
1848         public abstract KeyStore getKeyStore() throws KeyStoreException;
1849 
1850         /**
1851          * Returns the ProtectionParameters that should be used to obtain
1852          * the {@link KeyStore.Entry Entry} with the given alias.
1853          * The {@code getKeyStore} method must be invoked before this
1854          * method may be called.
1855          *
1856          * @return the ProtectionParameters that should be used to obtain
1857          *   the {@link KeyStore.Entry Entry} with the given alias.
1858          * @param alias the alias of the KeyStore entry
1859          * @throws NullPointerException if alias is null
1860          * @throws KeyStoreException if an error occurred during the
1861          *   operation
1862          * @throws IllegalStateException if the getKeyStore method has
1863          *   not been invoked prior to calling this method
1864          */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 279             this.protectionAlgorithm = null;
 280             this.protectionParameters = null;
 281         }
 282 
 283         /**
 284          * Creates a password parameter and specifies the protection algorithm
 285          * and associated parameters to use when encrypting a keystore entry.
 286          * &lt;p&gt;
 287          * The specified {@code password} is cloned before it is stored in the
 288          * new {@code PasswordProtection} object.
 289          *
 290          * @param password the password, which may be {@code null}
 291          * @param protectionAlgorithm the encryption algorithm name, for
 292          *     example, {@code PBEWithHmacSHA256AndAES_256}.
 293          *     See the Cipher section in the &lt;a href=
 294          * &quot;{@docRoot}/../specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;
 295          * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 296          *     for information about standard encryption algorithm names.
 297          * @param protectionParameters the encryption algorithm parameter
 298          *     specification, which may be {@code null}
<span class="line-modified"> 299          * @throws    NullPointerException if {@code protectionAlgorithm} is</span>
 300          *     {@code null}
 301          *
 302          * @since 1.8
 303          */
 304         public PasswordProtection(char[] password, String protectionAlgorithm,
 305             AlgorithmParameterSpec protectionParameters) {
 306             if (protectionAlgorithm == null) {
 307                 throw new NullPointerException(&quot;invalid null input&quot;);
 308             }
 309             this.password = (password == null) ? null : password.clone();
 310             this.protectionAlgorithm = protectionAlgorithm;
 311             this.protectionParameters = protectionParameters;
 312         }
 313 
 314         /**
 315          * Gets the name of the protection algorithm.
 316          * If none was set then the keystore provider will use its default
 317          * protection algorithm.
 318          *
 319          * @return the algorithm name, or {@code null} if none was set
</pre>
<hr />
<pre>
 329          *
 330          * @return the algorithm parameter specification, or {@code  null},
 331          *     if none was set
 332          *
 333          * @since 1.8
 334          */
 335         public AlgorithmParameterSpec getProtectionParameters() {
 336             return protectionParameters;
 337         }
 338 
 339         /**
 340          * Gets the password.
 341          *
 342          * &lt;p&gt;Note that this method returns a reference to the password.
 343          * If a clone of the array is created it is the caller&#39;s
 344          * responsibility to zero out the password information
 345          * after it is no longer needed.
 346          *
 347          * @see #destroy()
 348          * @return the password, which may be {@code null}
<span class="line-modified"> 349          * @throws    IllegalStateException if the password has</span>
 350          *              been cleared (destroyed)
 351          */
 352         public synchronized char[] getPassword() {
 353             if (destroyed) {
 354                 throw new IllegalStateException(&quot;password has been cleared&quot;);
 355             }
 356             return password;
 357         }
 358 
 359         /**
 360          * Clears the password.
 361          *
<span class="line-modified"> 362          * @throws    DestroyFailedException if this method was unable</span>
 363          *      to clear the password
 364          */
 365         public synchronized void destroy() throws DestroyFailedException {
 366             destroyed = true;
 367             if (password != null) {
 368                 Arrays.fill(password, &#39; &#39;);
 369             }
 370         }
 371 
 372         /**
 373          * Determines if password has been cleared.
 374          *
 375          * @return true if the password has been cleared, false otherwise
 376          */
 377         public synchronized boolean isDestroyed() {
 378             return destroyed;
 379         }
 380     }
 381 
 382     /**
 383      * A ProtectionParameter encapsulating a CallbackHandler.
 384      *
 385      * @since 1.5
 386      */
 387     public static class CallbackHandlerProtection
 388             implements ProtectionParameter {
 389 
 390         private final CallbackHandler handler;
 391 
 392         /**
 393          * Constructs a new CallbackHandlerProtection from a
 394          * CallbackHandler.
 395          *
 396          * @param handler the CallbackHandler
<span class="line-modified"> 397          * @throws    NullPointerException if handler is null</span>
 398          */
 399         public CallbackHandlerProtection(CallbackHandler handler) {
 400             if (handler == null) {
 401                 throw new NullPointerException(&quot;handler must not be null&quot;);
 402             }
 403             this.handler = handler;
 404         }
 405 
 406         /**
 407          * Returns the CallbackHandler.
 408          *
 409          * @return the CallbackHandler.
 410          */
 411         public CallbackHandler getCallbackHandler() {
 412             return handler;
 413         }
 414 
 415     }
 416 
 417     /**
</pre>
<hr />
<pre>
 468     public static final class PrivateKeyEntry implements Entry {
 469 
 470         private final PrivateKey privKey;
 471         private final Certificate[] chain;
 472         private final Set&lt;Attribute&gt; attributes;
 473 
 474         /**
 475          * Constructs a {@code PrivateKeyEntry} with a
 476          * {@code PrivateKey} and corresponding certificate chain.
 477          *
 478          * &lt;p&gt; The specified {@code chain} is cloned before it is stored
 479          * in the new {@code PrivateKeyEntry} object.
 480          *
 481          * @param privateKey the {@code PrivateKey}
 482          * @param chain an array of {@code Certificate}s
 483          *      representing the certificate chain.
 484          *      The chain must be ordered and contain a
 485          *      {@code Certificate} at index 0
 486          *      corresponding to the private key.
 487          *
<span class="line-modified"> 488          * @throws    NullPointerException if</span>
 489          *      {@code privateKey} or {@code chain}
 490          *      is {@code null}
<span class="line-modified"> 491          * @throws    IllegalArgumentException if the specified chain has a</span>
 492          *      length of 0, if the specified chain does not contain
 493          *      {@code Certificate}s of the same type,
 494          *      or if the {@code PrivateKey} algorithm
 495          *      does not match the algorithm of the {@code PublicKey}
 496          *      in the end entity {@code Certificate} (at index 0)
 497          */
 498         public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain) {
 499             this(privateKey, chain, Collections.&lt;Attribute&gt;emptySet());
 500         }
 501 
 502         /**
 503          * Constructs a {@code PrivateKeyEntry} with a {@code PrivateKey} and
 504          * corresponding certificate chain and associated entry attributes.
 505          *
 506          * &lt;p&gt; The specified {@code chain} and {@code attributes} are cloned
 507          * before they are stored in the new {@code PrivateKeyEntry} object.
 508          *
 509          * @param privateKey the {@code PrivateKey}
 510          * @param chain an array of {@code Certificate}s
 511          *      representing the certificate chain.
 512          *      The chain must be ordered and contain a
 513          *      {@code Certificate} at index 0
 514          *      corresponding to the private key.
 515          * @param attributes the attributes
 516          *
<span class="line-modified"> 517          * @throws    NullPointerException if {@code privateKey}, {@code chain}</span>
 518          *      or {@code attributes} is {@code null}
<span class="line-modified"> 519          * @throws    IllegalArgumentException if the specified chain has a</span>
 520          *      length of 0, if the specified chain does not contain
 521          *      {@code Certificate}s of the same type,
 522          *      or if the {@code PrivateKey} algorithm
 523          *      does not match the algorithm of the {@code PublicKey}
 524          *      in the end entity {@code Certificate} (at index 0)
 525          *
 526          * @since 1.8
 527          */
 528         public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain,
 529            Set&lt;Attribute&gt; attributes) {
 530 
 531             if (privateKey == null || chain == null || attributes == null) {
 532                 throw new NullPointerException(&quot;invalid null input&quot;);
 533             }
 534             if (chain.length == 0) {
 535                 throw new IllegalArgumentException
 536                                 (&quot;invalid zero-length input chain&quot;);
 537             }
 538 
 539             Certificate[] clonedChain = chain.clone();
</pre>
<hr />
<pre>
 634         }
 635 
 636     }
 637 
 638     /**
 639      * A {@code KeyStore} entry that holds a {@code SecretKey}.
 640      *
 641      * @since 1.5
 642      */
 643     public static final class SecretKeyEntry implements Entry {
 644 
 645         private final SecretKey sKey;
 646         private final Set&lt;Attribute&gt; attributes;
 647 
 648         /**
 649          * Constructs a {@code SecretKeyEntry} with a
 650          * {@code SecretKey}.
 651          *
 652          * @param secretKey the {@code SecretKey}
 653          *
<span class="line-modified"> 654          * @throws    NullPointerException if {@code secretKey}</span>
 655          *      is {@code null}
 656          */
 657         public SecretKeyEntry(SecretKey secretKey) {
 658             if (secretKey == null) {
 659                 throw new NullPointerException(&quot;invalid null input&quot;);
 660             }
 661             this.sKey = secretKey;
 662             this.attributes = Collections.&lt;Attribute&gt;emptySet();
 663         }
 664 
 665         /**
 666          * Constructs a {@code SecretKeyEntry} with a {@code SecretKey} and
 667          * associated entry attributes.
 668          *
 669          * &lt;p&gt; The specified {@code attributes} is cloned before it is stored
 670          * in the new {@code SecretKeyEntry} object.
 671          *
 672          * @param secretKey the {@code SecretKey}
 673          * @param attributes the attributes
 674          *
<span class="line-modified"> 675          * @throws    NullPointerException if {@code secretKey} or</span>
 676          *     {@code attributes} is {@code null}
 677          *
 678          * @since 1.8
 679          */
 680         public SecretKeyEntry(SecretKey secretKey, Set&lt;Attribute&gt; attributes) {
 681 
 682             if (secretKey == null || attributes == null) {
 683                 throw new NullPointerException(&quot;invalid null input&quot;);
 684             }
 685             this.sKey = secretKey;
 686             this.attributes =
 687                 Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));
 688         }
 689 
 690         /**
 691          * Gets the {@code SecretKey} from this entry.
 692          *
 693          * @return the {@code SecretKey} from this entry
 694          */
 695         public SecretKey getSecretKey() {
</pre>
<hr />
<pre>
 717         }
 718     }
 719 
 720     /**
 721      * A {@code KeyStore} entry that holds a trusted
 722      * {@code Certificate}.
 723      *
 724      * @since 1.5
 725      */
 726     public static final class TrustedCertificateEntry implements Entry {
 727 
 728         private final Certificate cert;
 729         private final Set&lt;Attribute&gt; attributes;
 730 
 731         /**
 732          * Constructs a {@code TrustedCertificateEntry} with a
 733          * trusted {@code Certificate}.
 734          *
 735          * @param trustedCert the trusted {@code Certificate}
 736          *
<span class="line-modified"> 737          * @throws    NullPointerException if</span>
 738          *      {@code trustedCert} is {@code null}
 739          */
 740         public TrustedCertificateEntry(Certificate trustedCert) {
 741             if (trustedCert == null) {
 742                 throw new NullPointerException(&quot;invalid null input&quot;);
 743             }
 744             this.cert = trustedCert;
 745             this.attributes = Collections.&lt;Attribute&gt;emptySet();
 746         }
 747 
 748         /**
 749          * Constructs a {@code TrustedCertificateEntry} with a
 750          * trusted {@code Certificate} and associated entry attributes.
 751          *
 752          * &lt;p&gt; The specified {@code attributes} is cloned before it is stored
 753          * in the new {@code TrustedCertificateEntry} object.
 754          *
 755          * @param trustedCert the trusted {@code Certificate}
 756          * @param attributes the attributes
 757          *
<span class="line-modified"> 758          * @throws    NullPointerException if {@code trustedCert} or</span>
 759          *     {@code attributes} is {@code null}
 760          *
 761          * @since 1.8
 762          */
 763         public TrustedCertificateEntry(Certificate trustedCert,
 764            Set&lt;Attribute&gt; attributes) {
 765             if (trustedCert == null || attributes == null) {
 766                 throw new NullPointerException(&quot;invalid null input&quot;);
 767             }
 768             this.cert = trustedCert;
 769             this.attributes =
 770                 Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));
 771         }
 772 
 773         /**
 774          * Gets the trusted {@code Certficate} from this entry.
 775          *
 776          * @return the trusted {@code Certificate} from this entry
 777          */
 778         public Certificate getTrustedCertificate() {
</pre>
<hr />
<pre>
1016      * @return the type of this keystore.
1017      */
1018     public final String getType()
1019     {
1020         return this.type;
1021     }
1022 
1023     /**
1024      * Returns the key associated with the given alias, using the given
1025      * password to recover it.  The key must have been associated with
1026      * the alias by a call to {@code setKeyEntry},
1027      * or by a call to {@code setEntry} with a
1028      * {@code PrivateKeyEntry} or {@code SecretKeyEntry}.
1029      *
1030      * @param alias the alias name
1031      * @param password the password for recovering the key
1032      *
1033      * @return the requested key, or null if the given alias does not exist
1034      * or does not identify a key-related entry.
1035      *
<span class="line-modified">1036      * @throws    KeyStoreException if the keystore has not been initialized</span>
1037      * (loaded).
<span class="line-modified">1038      * @throws    NoSuchAlgorithmException if the algorithm for recovering the</span>
1039      * key cannot be found
<span class="line-modified">1040      * @throws    UnrecoverableKeyException if the key cannot be recovered</span>
1041      * (e.g., the given password is wrong).
1042      */
1043     public final Key getKey(String alias, char[] password)
1044         throws KeyStoreException, NoSuchAlgorithmException,
1045             UnrecoverableKeyException
1046     {
1047         if (!initialized) {
1048             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1049         }
1050         return keyStoreSpi.engineGetKey(alias, password);
1051     }
1052 
1053     /**
1054      * Returns the certificate chain associated with the given alias.
1055      * The certificate chain must have been associated with the alias
1056      * by a call to {@code setKeyEntry},
1057      * or by a call to {@code setEntry} with a
1058      * {@code PrivateKeyEntry}.
1059      *
1060      * @param alias the alias name
1061      *
1062      * @return the certificate chain (ordered with the user&#39;s certificate first
1063      * followed by zero or more certificate authorities), or null if the given alias
1064      * does not exist or does not contain a certificate chain
1065      *
<span class="line-modified">1066      * @throws    KeyStoreException if the keystore has not been initialized</span>
1067      * (loaded).
1068      */
1069     public final Certificate[] getCertificateChain(String alias)
1070         throws KeyStoreException
1071     {
1072         if (!initialized) {
1073             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1074         }
1075         return keyStoreSpi.engineGetCertificateChain(alias);
1076     }
1077 
1078     /**
1079      * Returns the certificate associated with the given alias.
1080      *
1081      * &lt;p&gt; If the given alias name identifies an entry
1082      * created by a call to {@code setCertificateEntry},
1083      * or created by a call to {@code setEntry} with a
1084      * {@code TrustedCertificateEntry},
1085      * then the trusted certificate contained in that entry is returned.
1086      *
1087      * &lt;p&gt; If the given alias name identifies an entry
1088      * created by a call to {@code setKeyEntry},
1089      * or created by a call to {@code setEntry} with a
1090      * {@code PrivateKeyEntry},
1091      * then the first element of the certificate chain in that entry
1092      * is returned.
1093      *
1094      * @param alias the alias name
1095      *
1096      * @return the certificate, or null if the given alias does not exist or
1097      * does not contain a certificate.
1098      *
<span class="line-modified">1099      * @throws    KeyStoreException if the keystore has not been initialized</span>
1100      * (loaded).
1101      */
1102     public final Certificate getCertificate(String alias)
1103         throws KeyStoreException
1104     {
1105         if (!initialized) {
1106             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1107         }
1108         return keyStoreSpi.engineGetCertificate(alias);
1109     }
1110 
1111     /**
1112      * Returns the creation date of the entry identified by the given alias.
1113      *
1114      * @param alias the alias name
1115      *
1116      * @return the creation date of this entry, or null if the given alias does
1117      * not exist
1118      *
<span class="line-modified">1119      * @throws    KeyStoreException if the keystore has not been initialized</span>
1120      * (loaded).
1121      */
1122     public final Date getCreationDate(String alias)
1123         throws KeyStoreException
1124     {
1125         if (!initialized) {
1126             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1127         }
1128         return keyStoreSpi.engineGetCreationDate(alias);
1129     }
1130 
1131     /**
1132      * Assigns the given key to the given alias, protecting it with the given
1133      * password.
1134      *
1135      * &lt;p&gt;If the given key is of type {@code java.security.PrivateKey},
1136      * it must be accompanied by a certificate chain certifying the
1137      * corresponding public key.
1138      *
1139      * &lt;p&gt;If the given alias already exists, the keystore information
1140      * associated with it is overridden by the given key (and possibly
1141      * certificate chain).
1142      *
1143      * @param alias the alias name
1144      * @param key the key to be associated with the alias
1145      * @param password the password to protect the key
1146      * @param chain the certificate chain for the corresponding public
1147      * key (only required if the given key is of type
1148      * {@code java.security.PrivateKey}).
1149      *
<span class="line-modified">1150      * @throws    KeyStoreException if the keystore has not been initialized</span>
1151      * (loaded), the given key cannot be protected, or this operation fails
1152      * for some other reason
1153      */
1154     public final void setKeyEntry(String alias, Key key, char[] password,
1155                                   Certificate[] chain)
1156         throws KeyStoreException
1157     {
1158         if (!initialized) {
1159             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1160         }
1161         if ((key instanceof PrivateKey) &amp;&amp;
1162             (chain == null || chain.length == 0)) {
1163             throw new IllegalArgumentException(&quot;Private key must be &quot;
1164                                                + &quot;accompanied by certificate &quot;
1165                                                + &quot;chain&quot;);
1166         }
1167         keyStoreSpi.engineSetKeyEntry(alias, key, password, chain);
1168     }
1169 
1170     /**
1171      * Assigns the given key (that has already been protected) to the given
1172      * alias.
1173      *
1174      * &lt;p&gt;If the protected key is of type
1175      * {@code java.security.PrivateKey}, it must be accompanied by a
1176      * certificate chain certifying the corresponding public key. If the
1177      * underlying keystore implementation is of type {@code jks},
1178      * {@code key} must be encoded as an
1179      * {@code EncryptedPrivateKeyInfo} as defined in the PKCS #8 standard.
1180      *
1181      * &lt;p&gt;If the given alias already exists, the keystore information
1182      * associated with it is overridden by the given key (and possibly
1183      * certificate chain).
1184      *
1185      * @param alias the alias name
1186      * @param key the key (in protected format) to be associated with the alias
1187      * @param chain the certificate chain for the corresponding public
1188      *          key (only useful if the protected key is of type
1189      *          {@code java.security.PrivateKey}).
1190      *
<span class="line-modified">1191      * @throws    KeyStoreException if the keystore has not been initialized</span>
1192      * (loaded), or if this operation fails for some other reason.
1193      */
1194     public final void setKeyEntry(String alias, byte[] key,
1195                                   Certificate[] chain)
1196         throws KeyStoreException
1197     {
1198         if (!initialized) {
1199             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1200         }
1201         keyStoreSpi.engineSetKeyEntry(alias, key, chain);
1202     }
1203 
1204     /**
1205      * Assigns the given trusted certificate to the given alias.
1206      *
1207      * &lt;p&gt; If the given alias identifies an existing entry
1208      * created by a call to {@code setCertificateEntry},
1209      * or created by a call to {@code setEntry} with a
1210      * {@code TrustedCertificateEntry},
1211      * the trusted certificate in the existing entry
1212      * is overridden by the given certificate.
1213      *
1214      * @param alias the alias name
1215      * @param cert the certificate
1216      *
<span class="line-modified">1217      * @throws    KeyStoreException if the keystore has not been initialized,</span>
1218      * or the given alias already exists and does not identify an
1219      * entry containing a trusted certificate,
1220      * or this operation fails for some other reason.
1221      */
1222     public final void setCertificateEntry(String alias, Certificate cert)
1223         throws KeyStoreException
1224     {
1225         if (!initialized) {
1226             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1227         }
1228         keyStoreSpi.engineSetCertificateEntry(alias, cert);
1229     }
1230 
1231     /**
1232      * Deletes the entry identified by the given alias from this keystore.
1233      *
1234      * @param alias the alias name
1235      *
<span class="line-modified">1236      * @throws    KeyStoreException if the keystore has not been initialized,</span>
1237      * or if the entry cannot be removed.
1238      */
1239     public final void deleteEntry(String alias)
1240         throws KeyStoreException
1241     {
1242         if (!initialized) {
1243             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1244         }
1245         keyStoreSpi.engineDeleteEntry(alias);
1246     }
1247 
1248     /**
1249      * Lists all the alias names of this keystore.
1250      *
1251      * @return enumeration of the alias names
1252      *
<span class="line-modified">1253      * @throws    KeyStoreException if the keystore has not been initialized</span>
1254      * (loaded).
1255      */
1256     public final Enumeration&lt;String&gt; aliases()
1257         throws KeyStoreException
1258     {
1259         if (!initialized) {
1260             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1261         }
1262         return keyStoreSpi.engineAliases();
1263     }
1264 
1265     /**
1266      * Checks if the given alias exists in this keystore.
1267      *
1268      * @param alias the alias name
1269      *
1270      * @return true if the alias exists, false otherwise
1271      *
<span class="line-modified">1272      * @throws    KeyStoreException if the keystore has not been initialized</span>
1273      * (loaded).
1274      */
1275     public final boolean containsAlias(String alias)
1276         throws KeyStoreException
1277     {
1278         if (!initialized) {
1279             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1280         }
1281         return keyStoreSpi.engineContainsAlias(alias);
1282     }
1283 
1284     /**
1285      * Retrieves the number of entries in this keystore.
1286      *
1287      * @return the number of entries in this keystore
1288      *
<span class="line-modified">1289      * @throws    KeyStoreException if the keystore has not been initialized</span>
1290      * (loaded).
1291      */
1292     public final int size()
1293         throws KeyStoreException
1294     {
1295         if (!initialized) {
1296             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1297         }
1298         return keyStoreSpi.engineSize();
1299     }
1300 
1301     /**
1302      * Returns true if the entry identified by the given alias
1303      * was created by a call to {@code setKeyEntry},
1304      * or created by a call to {@code setEntry} with a
1305      * {@code PrivateKeyEntry} or a {@code SecretKeyEntry}.
1306      *
1307      * @param alias the alias for the keystore entry to be checked
1308      *
1309      * @return true if the entry identified by the given alias is a
1310      * key-related entry, false otherwise.
1311      *
<span class="line-modified">1312      * @throws    KeyStoreException if the keystore has not been initialized</span>
1313      * (loaded).
1314      */
1315     public final boolean isKeyEntry(String alias)
1316         throws KeyStoreException
1317     {
1318         if (!initialized) {
1319             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1320         }
1321         return keyStoreSpi.engineIsKeyEntry(alias);
1322     }
1323 
1324     /**
1325      * Returns true if the entry identified by the given alias
1326      * was created by a call to {@code setCertificateEntry},
1327      * or created by a call to {@code setEntry} with a
1328      * {@code TrustedCertificateEntry}.
1329      *
1330      * @param alias the alias for the keystore entry to be checked
1331      *
1332      * @return true if the entry identified by the given alias contains a
1333      * trusted certificate, false otherwise.
1334      *
<span class="line-modified">1335      * @throws    KeyStoreException if the keystore has not been initialized</span>
1336      * (loaded).
1337      */
1338     public final boolean isCertificateEntry(String alias)
1339         throws KeyStoreException
1340     {
1341         if (!initialized) {
1342             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1343         }
1344         return keyStoreSpi.engineIsCertificateEntry(alias);
1345     }
1346 
1347     /**
1348      * Returns the (alias) name of the first keystore entry whose certificate
1349      * matches the given certificate.
1350      *
1351      * &lt;p&gt; This method attempts to match the given certificate with each
1352      * keystore entry. If the entry being considered was
1353      * created by a call to {@code setCertificateEntry},
1354      * or created by a call to {@code setEntry} with a
1355      * {@code TrustedCertificateEntry},
1356      * then the given certificate is compared to that entry&#39;s certificate.
1357      *
1358      * &lt;p&gt; If the entry being considered was
1359      * created by a call to {@code setKeyEntry},
1360      * or created by a call to {@code setEntry} with a
1361      * {@code PrivateKeyEntry},
1362      * then the given certificate is compared to the first
1363      * element of that entry&#39;s certificate chain.
1364      *
1365      * @param cert the certificate to match with.
1366      *
1367      * @return the alias name of the first entry with a matching certificate,
1368      * or null if no such entry exists in this keystore.
1369      *
<span class="line-modified">1370      * @throws    KeyStoreException if the keystore has not been initialized</span>
1371      * (loaded).
1372      */
1373     public final String getCertificateAlias(Certificate cert)
1374         throws KeyStoreException
1375     {
1376         if (!initialized) {
1377             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1378         }
1379         return keyStoreSpi.engineGetCertificateAlias(cert);
1380     }
1381 
1382     /**
1383      * Stores this keystore to the given output stream, and protects its
1384      * integrity with the given password.
1385      *
1386      * @param stream the output stream to which this keystore is written.
1387      * @param password the password to generate the keystore integrity check
1388      *
<span class="line-modified">1389      * @throws    KeyStoreException if the keystore has not been initialized</span>
1390      * (loaded).
<span class="line-modified">1391      * @throws    IOException if there was an I/O problem with data</span>
<span class="line-modified">1392      * @throws    NoSuchAlgorithmException if the appropriate data integrity</span>
1393      * algorithm could not be found
<span class="line-modified">1394      * @throws    CertificateException if any of the certificates included in</span>
1395      * the keystore data could not be stored
1396      */
1397     public final void store(OutputStream stream, char[] password)
1398         throws KeyStoreException, IOException, NoSuchAlgorithmException,
1399             CertificateException
1400     {
1401         if (!initialized) {
1402             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1403         }
1404         keyStoreSpi.engineStore(stream, password);
1405     }
1406 
1407     /**
1408      * Stores this keystore using the given {@code LoadStoreParameter}.
1409      *
1410      * @param param the {@code LoadStoreParameter}
1411      *          that specifies how to store the keystore,
1412      *          which may be {@code null}
1413      *
<span class="line-modified">1414      * @throws    IllegalArgumentException if the given</span>
1415      *          {@code LoadStoreParameter}
1416      *          input is not recognized
<span class="line-modified">1417      * @throws    KeyStoreException if the keystore has not been initialized</span>
1418      *          (loaded)
<span class="line-modified">1419      * @throws    IOException if there was an I/O problem with data</span>
<span class="line-modified">1420      * @throws    NoSuchAlgorithmException if the appropriate data integrity</span>
1421      *          algorithm could not be found
<span class="line-modified">1422      * @throws    CertificateException if any of the certificates included in</span>
1423      *          the keystore data could not be stored
1424      *
1425      * @since 1.5
1426      */
1427     public final void store(LoadStoreParameter param)
1428                 throws KeyStoreException, IOException,
1429                 NoSuchAlgorithmException, CertificateException {
1430         if (!initialized) {
1431             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1432         }
1433         keyStoreSpi.engineStore(param);
1434     }
1435 
1436     /**
1437      * Loads this KeyStore from the given input stream.
1438      *
1439      * &lt;p&gt;A password may be given to unlock the keystore
1440      * (e.g. the keystore resides on a hardware token device),
1441      * or to check the integrity of the keystore data.
1442      * If a password is not given for integrity checking,
1443      * then integrity checking is not performed.
1444      *
1445      * &lt;p&gt;In order to create an empty keystore, or if the keystore cannot
1446      * be initialized from a stream, pass {@code null}
1447      * as the {@code stream} argument.
1448      *
1449      * &lt;p&gt; Note that if this keystore has already been loaded, it is
1450      * reinitialized and loaded again from the given input stream.
1451      *
1452      * @param stream the input stream from which the keystore is loaded,
1453      * or {@code null}
1454      * @param password the password used to check the integrity of
1455      * the keystore, the password used to unlock the keystore,
1456      * or {@code null}
1457      *
<span class="line-modified">1458      * @throws    IOException if there is an I/O or format problem with the</span>
1459      * keystore data, if a password is required but not given,
1460      * or if the given password was incorrect. If the error is due to a
1461      * wrong password, the {@link Throwable#getCause cause} of the
1462      * {@code IOException} should be an
1463      * {@code UnrecoverableKeyException}
<span class="line-modified">1464      * @throws    NoSuchAlgorithmException if the algorithm used to check</span>
1465      * the integrity of the keystore cannot be found
<span class="line-modified">1466      * @throws    CertificateException if any of the certificates in the</span>
1467      * keystore could not be loaded
1468      */
1469     public final void load(InputStream stream, char[] password)
1470         throws IOException, NoSuchAlgorithmException, CertificateException
1471     {
1472         keyStoreSpi.engineLoad(stream, password);
1473         initialized = true;
1474     }
1475 
1476     /**
1477      * Loads this keystore using the given {@code LoadStoreParameter}.
1478      *
1479      * &lt;p&gt; Note that if this KeyStore has already been loaded, it is
1480      * reinitialized and loaded again from the given parameter.
1481      *
1482      * @param param the {@code LoadStoreParameter}
1483      *          that specifies how to load the keystore,
1484      *          which may be {@code null}
1485      *
<span class="line-modified">1486      * @throws    IllegalArgumentException if the given</span>
1487      *          {@code LoadStoreParameter}
1488      *          input is not recognized
<span class="line-modified">1489      * @throws    IOException if there is an I/O or format problem with the</span>
1490      *          keystore data. If the error is due to an incorrect
1491      *         {@code ProtectionParameter} (e.g. wrong password)
1492      *         the {@link Throwable#getCause cause} of the
1493      *         {@code IOException} should be an
1494      *         {@code UnrecoverableKeyException}
<span class="line-modified">1495      * @throws    NoSuchAlgorithmException if the algorithm used to check</span>
1496      *          the integrity of the keystore cannot be found
<span class="line-modified">1497      * @throws    CertificateException if any of the certificates in the</span>
1498      *          keystore could not be loaded
1499      *
1500      * @since 1.5
1501      */
1502     public final void load(LoadStoreParameter param)
1503                 throws IOException, NoSuchAlgorithmException,
1504                 CertificateException {
1505 
1506         keyStoreSpi.engineLoad(param);
1507         initialized = true;
1508     }
1509 
1510     /**
1511      * Gets a keystore {@code Entry} for the specified alias
1512      * with the specified protection parameter.
1513      *
1514      * @param alias get the keystore {@code Entry} for this alias
1515      * @param protParam the {@code ProtectionParameter}
1516      *          used to protect the {@code Entry},
1517      *          which may be {@code null}
1518      *
1519      * @return the keystore {@code Entry} for the specified alias,
1520      *          or {@code null} if there is no such entry
1521      *
<span class="line-modified">1522      * @throws    NullPointerException if</span>
1523      *          {@code alias} is {@code null}
<span class="line-modified">1524      * @throws    NoSuchAlgorithmException if the algorithm for recovering the</span>
1525      *          entry cannot be found
<span class="line-modified">1526      * @throws    UnrecoverableEntryException if the specified</span>
1527      *          {@code protParam} were insufficient or invalid
<span class="line-modified">1528      * @throws    UnrecoverableKeyException if the entry is a</span>
1529      *          {@code PrivateKeyEntry} or {@code SecretKeyEntry}
1530      *          and the specified {@code protParam} does not contain
1531      *          the information needed to recover the key (e.g. wrong password)
<span class="line-modified">1532      * @throws    KeyStoreException if the keystore has not been initialized</span>
1533      *          (loaded).
1534      * @see #setEntry(String, KeyStore.Entry, KeyStore.ProtectionParameter)
1535      *
1536      * @since 1.5
1537      */
1538     public final Entry getEntry(String alias, ProtectionParameter protParam)
1539                 throws NoSuchAlgorithmException, UnrecoverableEntryException,
1540                 KeyStoreException {
1541 
1542         if (alias == null) {
1543             throw new NullPointerException(&quot;invalid null input&quot;);
1544         }
1545         if (!initialized) {
1546             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1547         }
1548         return keyStoreSpi.engineGetEntry(alias, protParam);
1549     }
1550 
1551     /**
1552      * Saves a keystore {@code Entry} under the specified alias.
1553      * The protection parameter is used to protect the
1554      * {@code Entry}.
1555      *
1556      * &lt;p&gt; If an entry already exists for the specified alias,
1557      * it is overridden.
1558      *
1559      * @param alias save the keystore {@code Entry} under this alias
1560      * @param entry the {@code Entry} to save
1561      * @param protParam the {@code ProtectionParameter}
1562      *          used to protect the {@code Entry},
1563      *          which may be {@code null}
1564      *
<span class="line-modified">1565      * @throws    NullPointerException if</span>
1566      *          {@code alias} or {@code entry}
1567      *          is {@code null}
<span class="line-modified">1568      * @throws    KeyStoreException if the keystore has not been initialized</span>
1569      *          (loaded), or if this operation fails for some other reason
1570      *
1571      * @see #getEntry(String, KeyStore.ProtectionParameter)
1572      *
1573      * @since 1.5
1574      */
1575     public final void setEntry(String alias, Entry entry,
1576                         ProtectionParameter protParam)
1577                 throws KeyStoreException {
1578         if (alias == null || entry == null) {
1579             throw new NullPointerException(&quot;invalid null input&quot;);
1580         }
1581         if (!initialized) {
1582             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1583         }
1584         keyStoreSpi.engineSetEntry(alias, entry, protParam);
1585     }
1586 
1587     /**
1588      * Determines if the keystore {@code Entry} for the specified
1589      * {@code alias} is an instance or subclass of the specified
1590      * {@code entryClass}.
1591      *
1592      * @param alias the alias name
1593      * @param entryClass the entry class
1594      *
1595      * @return true if the keystore {@code Entry} for the specified
1596      *          {@code alias} is an instance or subclass of the
1597      *          specified {@code entryClass}, false otherwise
1598      *
<span class="line-modified">1599      * @throws    NullPointerException if</span>
1600      *          {@code alias} or {@code entryClass}
1601      *          is {@code null}
<span class="line-modified">1602      * @throws    KeyStoreException if the keystore has not been</span>
1603      *          initialized (loaded)
1604      *
1605      * @since 1.5
1606      */
1607     public final boolean
1608         entryInstanceOf(String alias,
1609                         Class&lt;? extends KeyStore.Entry&gt; entryClass)
1610         throws KeyStoreException
1611     {
1612 
1613         if (alias == null || entryClass == null) {
1614             throw new NullPointerException(&quot;invalid null input&quot;);
1615         }
1616         if (!initialized) {
1617             throw new KeyStoreException(&quot;Uninitialized keystore&quot;);
1618         }
1619         return keyStoreSpi.engineEntryInstanceOf(alias, entryClass);
1620     }
1621 
1622     /**
</pre>
<hr />
<pre>
1824      * @see KeyStore
1825      * @see javax.net.ssl.KeyStoreBuilderParameters
1826      * @since 1.5
1827      */
1828     public abstract static class Builder {
1829 
1830         // maximum times to try the callbackhandler if the password is wrong
1831         static final int MAX_CALLBACK_TRIES = 3;
1832 
1833         /**
1834          * Construct a new Builder.
1835          */
1836         protected Builder() {
1837             // empty
1838         }
1839 
1840         /**
1841          * Returns the KeyStore described by this object.
1842          *
1843          * @return the {@code KeyStore} described by this object
<span class="line-modified">1844          * @throws    KeyStoreException if an error occurred during the</span>
1845          *   operation, for example if the KeyStore could not be
1846          *   instantiated or loaded
1847          */
1848         public abstract KeyStore getKeyStore() throws KeyStoreException;
1849 
1850         /**
1851          * Returns the ProtectionParameters that should be used to obtain
1852          * the {@link KeyStore.Entry Entry} with the given alias.
1853          * The {@code getKeyStore} method must be invoked before this
1854          * method may be called.
1855          *
1856          * @return the ProtectionParameters that should be used to obtain
1857          *   the {@link KeyStore.Entry Entry} with the given alias.
1858          * @param alias the alias of the KeyStore entry
1859          * @throws NullPointerException if alias is null
1860          * @throws KeyStoreException if an error occurred during the
1861          *   operation
1862          * @throws IllegalStateException if the getKeyStore method has
1863          *   not been invoked prior to calling this method
1864          */
</pre>
</td>
</tr>
</table>
<center><a href="KeyRep.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="KeyStoreException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>